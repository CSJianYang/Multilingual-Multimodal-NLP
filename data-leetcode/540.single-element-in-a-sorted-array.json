[
    {
        "title": "Combination Sum II",
        "question_content": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates&nbsp;where the candidate numbers sum to target.\nEach number in candidates&nbsp;may only be used once in the combination.\nNote:&nbsp;The solution set must not contain duplicate combinations.\n&nbsp;\nExample 1:\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\nExample 2:\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n&nbsp;\nConstraints:\n\n\t1 <=&nbsp;candidates.length <= 100\n\t1 <=&nbsp;candidates[i] <= 50\n\t1 <= target <= 30",
        "solutions": [
            {
                "id": 16878,
                "title": "combination-sum-i-ii-and-iii-java-solution-see-the-similarities-yourself",
                "content": "Combination Sum I\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n        if (remain < 0) return; /** no solution */\\n        else if (remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i < cand.length; i++) { \\n                tempList.add(cand[i]);\\n                backtrack(list, tempList, cand, remain-cand[i], i);\\n                tempList.remove(tempList.size()-1);\\n            } \\n        }\\n\\n    }\\n\\nCombination Sum II\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n       List<List<Integer>> list = new LinkedList<List<Integer>>();\\n       Arrays.sort(candidates);\\n       backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n       \\n       if(remain < 0) return; /** no solution */\\n       else if(remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for (int i = start; i < cand.length; i++) {\\n             if(i > start && cand[i] == cand[i-1]) continue; /** skip duplicates */\\n             tempList.add(cand[i]);\\n             backtrack(list, tempList, cand, remain - cand[i], i+1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n        if(tempList.size() > k) return; /** no solution */\\n        else if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i <= 9; i++) {\\n                tempList.add(i);\\n                backtrack(list, tempList, k, remain-i, i+1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Combination Sum I\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n        if (remain < 0) return; /** no solution */\\n        else if (remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i < cand.length; i++) { \\n                tempList.add(cand[i]);\\n                backtrack(list, tempList, cand, remain-cand[i], i);\\n                tempList.remove(tempList.size()-1);\\n            } \\n        }\\n\\n    }\\n\\nCombination Sum II\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n       List<List<Integer>> list = new LinkedList<List<Integer>>();\\n       Arrays.sort(candidates);\\n       backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n       \\n       if(remain < 0) return; /** no solution */\\n       else if(remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for (int i = start; i < cand.length; i++) {\\n             if(i > start && cand[i] == cand[i-1]) continue; /** skip duplicates */\\n             tempList.add(cand[i]);\\n             backtrack(list, tempList, cand, remain - cand[i], i+1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n        if(tempList.size() > k) return; /** no solution */\\n        else if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i <= 9; i++) {\\n                tempList.add(i);\\n                backtrack(list, tempList, k, remain-i, i+1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16861,
                "title": "java-solution-using-dfs-easy-understand",
                "content": "     public List<List<Integer>> combinationSum2(int[] cand, int target) {\\n        Arrays.sort(cand);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> path = new ArrayList<Integer>();\\n        dfs_com(cand, 0, target, path, res);\\n        return res;\\n    }\\n    void dfs_com(int[] cand, int cur, int target, List<Integer> path, List<List<Integer>> res) {\\n        if (target == 0) {\\n            res.add(new ArrayList(path));\\n            return ;\\n        }\\n        if (target < 0) return;\\n        for (int i = cur; i < cand.length; i++){\\n            if (i > cur && cand[i] == cand[i-1]) continue;\\n            path.add(path.size(), cand[i]);\\n            dfs_com(cand, i+1, target - cand[i], path, res);\\n            path.remove(path.size()-1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "     public List<List<Integer>> combinationSum2(int[] cand, int target) {\\n        Arrays.sort(cand);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> path = new ArrayList<Integer>();\\n        dfs_com(cand, 0, target, path, res);\\n        return res;\\n    }\\n    void dfs_com(int[] cand, int cur, int target, List<Integer> path, List<List<Integer>> res) {\\n        if (target == 0) {\\n            res.add(new ArrayList(path));\\n            return ;\\n        }\\n        if (target < 0) return;\\n        for (int i = cur; i < cand.length; i++){\\n            if (i > cur && cand[i] == cand[i-1]) continue;\\n            path.add(path.size(), cand[i]);\\n            dfs_com(cand, i+1, target - cand[i], path, res);\\n            path.remove(path.size()-1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1277764,
                "title": "combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions",
                "content": "**SUBSETS** \\nhttps://leetcode.com/problems/subsets\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void powerset(vector<int> nums, int curr, vector<int> res, int n){\\n        if(curr == n){\\n            result.push_back(res);\\n            return;\\n        }\\n        powerset(nums, curr+1, res, n);\\n        res.push_back(nums[curr]);\\n        powerset(nums, curr+1, res, n);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        powerset(nums, 0, res, n);\\n        return result;\\n    }\\n};\\n```\\n\\n**SUBSETS II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void subs(vector<int> &nums, int curr, vector<int> &res){\\n        result.push_back(res);\\n        for(int i = curr; i < nums.size(); i++){\\n            if(i!=curr && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            res.push_back(nums[i]);\\n            subs(nums, i+1, res);\\n            res.pop_back();\\n            \\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return result;\\n        }\\n        vector<int> res;\\n        sort(nums.begin(), nums.end());\\n        subs(nums, 0, res);\\n        return result;\\n    }\\n};\\n```\\n----------------------------------------------------------------------------------\\n**PERMUTATIONS**\\nhttps://leetcode.com/problems/permutations/\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        for(int i = l; i <= r; i++){\\n            nums = swap(nums, l, i);\\n            perm(nums, l+1, r);\\n            nums = swap(nums, l, i);\\n        }\\n    }\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        perm(nums, 0, nums.size()-1);\\n        return result;\\n    } \\n};\\n```\\n**PERMUTATIONS II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        set<int> s;\\n        for(int i = l; i <= r; i++){\\n                if(s.find(nums[i]) != s.end() )\\n                    continue;\\n                s.insert(nums[i]);\\n                nums = swap(nums, l, i);\\n                perm(nums, l+1, r);\\n                nums = swap(nums, l, i);  \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        perm(nums, 0, nums.size()-1);\\n        return result;  \\n    }\\n};\\n```\\n-------------------------------------------------------------------------------------------\\n**COMBINATION SUM**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comSum(vector<int> &curr, int curInd, int sum, vector<int> &candidates, int target, int n){\\n        if(sum == target){\\n            result.push_back(curr);\\n            return;\\n        }      \\n        else if(sum > target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            curr.push_back(candidates[i]);\\n            sum += candidates[i];\\n            comSum(curr, i, sum, candidates, target, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int sum = 0;\\n        int n = candidates.size();\\n        comSum(curr, 0, sum, candidates, target, n);\\n        return result;\\n    }\\n};\\n```\\n**COMBINATION SUM II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```\\n**COMBINATION SUM III**\\nhttps://leetcode.com/problems/combination-sum-iii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void comsum(vector<int> &curr, int k, int n, int sum, int size, int index){\\n        if(size==k && sum == n){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(size>k || sum>n)\\n            return;\\n        \\n        for(int i = index; i <= 9; i++){\\n            sum += i;\\n            curr.push_back(i);\\n            comsum(curr, k, n, sum, size+1, i+1);\\n            sum -= i;\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> curr;\\n        comsum(curr, k, n, 0, 0, 1);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void powerset(vector<int> nums, int curr, vector<int> res, int n){\\n        if(curr == n){\\n            result.push_back(res);\\n            return;\\n        }\\n        powerset(nums, curr+1, res, n);\\n        res.push_back(nums[curr]);\\n        powerset(nums, curr+1, res, n);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        powerset(nums, 0, res, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void subs(vector<int> &nums, int curr, vector<int> &res){\\n        result.push_back(res);\\n        for(int i = curr; i < nums.size(); i++){\\n            if(i!=curr && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            res.push_back(nums[i]);\\n            subs(nums, i+1, res);\\n            res.pop_back();\\n            \\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return result;\\n        }\\n        vector<int> res;\\n        sort(nums.begin(), nums.end());\\n        subs(nums, 0, res);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        for(int i = l; i <= r; i++){\\n            nums = swap(nums, l, i);\\n            perm(nums, l+1, r);\\n            nums = swap(nums, l, i);\\n        }\\n    }\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        perm(nums, 0, nums.size()-1);\\n        return result;\\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        set<int> s;\\n        for(int i = l; i <= r; i++){\\n                if(s.find(nums[i]) != s.end() )\\n                    continue;\\n                s.insert(nums[i]);\\n                nums = swap(nums, l, i);\\n                perm(nums, l+1, r);\\n                nums = swap(nums, l, i);  \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        perm(nums, 0, nums.size()-1);\\n        return result;  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comSum(vector<int> &curr, int curInd, int sum, vector<int> &candidates, int target, int n){\\n        if(sum == target){\\n            result.push_back(curr);\\n            return;\\n        }      \\n        else if(sum > target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            curr.push_back(candidates[i]);\\n            sum += candidates[i];\\n            comSum(curr, i, sum, candidates, target, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int sum = 0;\\n        int n = candidates.size();\\n        comSum(curr, 0, sum, candidates, target, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void comsum(vector<int> &curr, int k, int n, int sum, int size, int index){\\n        if(size==k && sum == n){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(size>k || sum>n)\\n            return;\\n        \\n        for(int i = index; i <= 9; i++){\\n            sum += i;\\n            curr.push_back(i);\\n            comsum(curr, k, n, sum, size+1, i+1);\\n            sum -= i;\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> curr;\\n        comsum(curr, k, n, 0, 0, 1);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16944,
                "title": "beating-98-python-solution-using-recursion-with-comments",
                "content": "    def combinationSum2(self, candidates, target):\\n        # Sorting is really helpful, se we can avoid over counting easily\\n        candidates.sort()                      \\n        result = []\\n        self.combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n        \\n    def combine_sum_2(self, nums, start, path, result, target):\\n        # Base case: if the sum of the path satisfies the target, we will consider \\n        # it as a solution, and stop there\\n        if not target:\\n            result.append(path)\\n            return\\n        \\n        for i in xrange(start, len(nums)):\\n            # Very important here! We don't use `i > 0` because we always want \\n            # to count the first element in this recursive step even if it is the same \\n            # as one before. To avoid overcounting, we just ignore the duplicates\\n            # after the first element.\\n            if i > start and nums[i] == nums[i - 1]:\\n                continue\\n\\n            # If the current element is bigger than the assigned target, there is \\n            # no need to keep searching, since all the numbers are positive\\n            if nums[i] > target:\\n                break\\n\\n            # We change the start to `i + 1` because one element only could\\n            # be used once\\n            self.combine_sum_2(nums, i + 1, path + [nums[i]], \\n                               result, target - nums[i])",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def combinationSum2(self, candidates, target):\\n        # Sorting is really helpful, se we can avoid over counting easily\\n        candidates.sort()                      \\n        result = []\\n        self.combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n        \\n    def combine_sum_2(self, nums, start, path, result, target):\\n        # Base case: if the sum of the path satisfies the target, we will consider \\n        # it as a solution, and stop there\\n        if not target:\\n            result.append(path)\\n            return\\n        \\n        for i in xrange(start, len(nums)):\\n            # Very important here! We don't use `i > 0` because we always want \\n            # to count the first element in this recursive step even if it is the same \\n            # as one before. To avoid overcounting, we just ignore the duplicates\\n            # after the first element.\\n            if i > start and nums[i] == nums[i - 1]:\\n                continue\\n\\n            # If the current element is bigger than the assigned target, there is \\n            # no need to keep searching, since all the numbers are positive\\n            if nums[i] > target:\\n                break\\n\\n            # We change the start to `i + 1` because one element only could\\n            # be used once\\n            self.combine_sum_2(nums, i + 1, path + [nums[i]], \\n                               result, target - nums[i])",
                "codeTag": "Python3"
            },
            {
                "id": 750378,
                "title": "python3-dfs-solutions-templates-to-6-different-classic-backtracking-problems-more",
                "content": "I have compiled solutions for all the 6 classic backtracking problems, you can practise them together for better understanding. Good luck with your preparation/interviews! \\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/?currentPage=1&orderBy=recent_activity&query=)\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[46. Permutations](https://leetcode.com/problems/permutations/)\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\\n\\n[47. Permutations II](https://leetcode.com/problems/permutations-ii/)\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```\\n\\nMore good backtracking problems for practice:\\n[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n[784. Lettercase Permutation](https://leetcode.com/problems/letter-case-permutation/)\\n[1087. Brace Expansion](https://leetcode.com/problems/brace-expansion/)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/)\\n[1079 Letter Tile Possibilities](https://leetcode.com/problems/letter-tile-possibilities/)",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16862,
                "title": "c-backtracking-solution-with-detailed-explanation",
                "content": "At the beginning, I stuck on this problem. After careful thought, I think this kind of backtracking contains a  iterative component and a resursive component so I'd like to give more details to help beginners save time. The revursive component tries the elements after the current one and also tries duplicate elements. So we can get correct answer for cases like [1 1] 2. The iterative component checks duplicate combinations and skip it if it is. So we can get correct answer for cases like [1 1 1] 2.\\n\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n        {\\n            vector<vector<int>> res;\\n            sort(num.begin(),num.end());\\n            vector<int> local;\\n            findCombination(res, 0, target, local, num);\\n            return res;\\n        }\\n        void findCombination(vector<vector<int>>& res, const int order, const int target, vector<int>& local, const vector<int>& num)\\n        {\\n            if(target==0)\\n            {\\n                res.push_back(local);\\n                return;\\n            }\\n            else\\n            {\\n                for(int i = order;i<num.size();i++) // iterative component\\n                {\\n                    if(num[i]>target) return;\\n                    if(i&&num[i]==num[i-1]&&i>order) continue; // check duplicate combination\\n                    local.push_back(num[i]),\\n                    findCombination(res,i+1,target-num[i],local,num); // recursive componenet\\n                    local.pop_back();\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n        {\\n            vector<vector<int>> res;\\n            sort(num.begin(),num.end());\\n            vector<int> local;\\n            findCombination(res, 0, target, local, num);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17020,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ret = []\\n        self.dfs(sorted(candidates), target, 0, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, idx, path, ret):\\n        if target <= 0:\\n            if target == 0:\\n                ret.append(path)\\n            return \\n        for i in range(idx, len(nums)):\\n            if i > idx and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums, target-nums[i], i+1, path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ret = []\\n        self.dfs(sorted(candidates), target, 0, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, idx, path, ret):\\n        if target <= 0:\\n            if target == 0:\\n                ret.append(path)\\n            return \\n        for i in range(idx, len(nums)):\\n            if i > idx and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums, target-nums[i], i+1, path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16870,
                "title": "dp-solution-in-python",
                "content": "I also did it with recursion, turns out the DP solution is 3~4 times faster.\\n    \\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        table = [None] + [set() for i in range(target)]\\n        for i in candidates:\\n            if i > target:\\n                break\\n            for j in range(target - i, 0, -1):\\n                table[i + j] |= {elt + (i,) for elt in table[j]}\\n            table[i].add((i,))\\n        return map(list, table[target])",
                "solutionTags": [
                    "Python"
                ],
                "code": "I also did it with recursion, turns out the DP solution is 3~4 times faster.\\n    \\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        table = [None] + [set() for i in range(target)]\\n        for i in candidates:\\n            if i > target:\\n                break\\n            for j in range(target - i, 0, -1):\\n                table[i + j] |= {elt + (i,) for elt in table[j]}\\n            table[i].add((i,))\\n        return map(list, table[target])",
                "codeTag": "Python3"
            },
            {
                "id": 1350766,
                "title": "100-faster-c-solution-with-proper-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(int index, int target, vector<int>&candidates, vector<vector<int>>&ans, vector<int>&ds){\\n        //base case\\n        //when the combination ds is carrying is a valid one add it into th ans\\n        if(target == 0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i< candidates.size(); i++){\\n            if(candidates[i] > target) break; // no point of it to add it to the ans if the  candidate at ith element exceeds the target no picking up hence break \\n            if(i  > index && candidates[i] == candidates[i-1])\\n                continue;\\n                //to avoid picking up the same elements and thus avoiding duplicates (no picking of element)\\n            ds.push_back(candidates[i]);\\n            helper(i+1, target- candidates[i], candidates, ans, ds); //call for next  index element\\n            ds.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());//sort the given candidates vector \\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        helper(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int index, int target, vector<int>&candidates, vector<vector<int>>&ans, vector<int>&ds){\\n        //base case\\n        //when the combination ds is carrying is a valid one add it into th ans\\n        if(target == 0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i< candidates.size(); i++){\\n            if(candidates[i] > target) break; // no point of it to add it to the ans if the  candidate at ith element exceeds the target no picking up hence break \\n            if(i  > index && candidates[i] == candidates[i-1])\\n                continue;\\n                //to avoid picking up the same elements and thus avoiding duplicates (no picking of element)\\n            ds.push_back(candidates[i]);\\n            helper(i+1, target- candidates[i], candidates, ans, ds); //call for next  index element\\n            ds.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());//sort the given candidates vector \\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        helper(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16884,
                "title": "a-smaller-trick-to-improve-a-lot-beat-92-35",
                "content": "Most people who use recursive backtrack to solve this question have code like:\\n\\n```\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return;\\n        }\\n        \\n        if (target < 0) {\\n            return;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > post && candidates[i] == candidats[i - 1])\\n              continue;\\n            }\\n            list.add(candidates[i]);\\n            helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n```\\n\\nThis is absolutely correct. However, we can do much more pruning by breaking much earlier. \\n\\nFor example: the list is [1, 1,  2, 5, 6, 7, 10], target is 8 and the current list is [1, 1, 2]. Now we are at 5, and we know that [1, 1, 2, 5] will be greater than 8. The next to check is [1, 1, 2, 6]. However, we should already know that [1, 1, 2, 6] cannot work since [1, 1, 2, 5] already has a sum larger than 8. There is no need to check for [1, 1,  2, 6] or [1, 1, 2, 7] and so no.\\n\\nThus, when we find a match or the current sum is already larger than the target, we should not continue with the current list.\\n\\nThe code is something like:\\n\\n```\\n    private boolean helper(int[] candidates, int target, List<List<Integer>> res,\\n                        List<Integer> list, int pos) {\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return true;\\n        }\\n        \\n        if (target < 0) {\\n            return true;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > pos && candidates[i] == candidates[i - 1]) {\\n                continue;\\n            }\\n            \\n            list.add(candidates[i]);\\n            boolean con = helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n            if(con) {\\n                break;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return;\\n        }\\n        \\n        if (target < 0) {\\n            return;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > post && candidates[i] == candidats[i - 1])\\n              continue;\\n            }\\n            list.add(candidates[i]);\\n            helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n```\n```\\n    private boolean helper(int[] candidates, int target, List<List<Integer>> res,\\n                        List<Integer> list, int pos) {\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return true;\\n        }\\n        \\n        if (target < 0) {\\n            return true;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > pos && candidates[i] == candidates[i - 1]) {\\n                continue;\\n            }\\n            \\n            list.add(candidates[i]);\\n            boolean con = helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n            if(con) {\\n                break;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213780,
                "title": "3-backtracking-variations-java-beats-100",
                "content": "**Backtracking With Visited Array (using space)**\\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        boolean[] visited = new boolean[50];\\n        int count = 0;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (!visited[arr[i]] && tar - arr[i] >= 0) {\\n                \\n                visited[arr[i]] = true;\\n                \\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\\n**Backtracking With Prev Variable (space efficient)**\\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        \\n        int count = 0;\\n        int prev = -1;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (prev != arr[i] && tar - arr[i] >= 0) {\\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n            \\n            if (tar - arr[i] < 0)\\n                break;\\n            \\n            prev = arr[i];\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\\n**BackTracking Subsequence method**\\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0 || idx >= arr.length) {\\n            if (tar == 0) {\\n                List<Integer> base = new ArrayList<>(smallAns);\\n                res.add(base);\\n                return 1;\\n            }\\n            return 0;\\n        }\\n            \\n        int count = 0;\\n\\n        if (tar - arr[idx] >= 0) {\\n            smallAns.add(arr[idx]);\\n            count += combinationSum2(arr, tar - arr[idx], idx + 1, smallAns, res);\\n            smallAns.remove(smallAns.size() - 1);\\n        }\\n\\n        idx++;\\n        while (idx < arr.length && arr[idx - 1] == arr[idx])\\n            idx++;\\n\\n        count += combinationSum2(arr, tar, idx, smallAns, res);\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] arr, int tar) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        Arrays.sort(arr);\\n        combinationSum2(arr, tar, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\\n**If you liked it, even a little bit then pls consider giving this solution a Upvote\\nThank You :)**",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        boolean[] visited = new boolean[50];\\n        int count = 0;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (!visited[arr[i]] && tar - arr[i] >= 0) {\\n                \\n                visited[arr[i]] = true;\\n                \\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        \\n        int count = 0;\\n        int prev = -1;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (prev != arr[i] && tar - arr[i] >= 0) {\\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n            \\n            if (tar - arr[i] < 0)\\n                break;\\n            \\n            prev = arr[i];\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0 || idx >= arr.length) {\\n            if (tar == 0) {\\n                List<Integer> base = new ArrayList<>(smallAns);\\n                res.add(base);\\n                return 1;\\n            }\\n            return 0;\\n        }\\n            \\n        int count = 0;\\n\\n        if (tar - arr[idx] >= 0) {\\n            smallAns.add(arr[idx]);\\n            count += combinationSum2(arr, tar - arr[idx], idx + 1, smallAns, res);\\n            smallAns.remove(smallAns.size() - 1);\\n        }\\n\\n        idx++;\\n        while (idx < arr.length && arr[idx - 1] == arr[idx])\\n            idx++;\\n\\n        count += combinationSum2(arr, tar, idx, smallAns, res);\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] arr, int tar) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        Arrays.sort(arr);\\n        combinationSum2(arr, tar, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16916,
                "title": "understanding-the-differences-between-the-dp-solution-and-simple-recursive-which-one-is-really-better",
                "content": "DP Solution:\\n1. Start by creating an array of [target+1]. Call it arr.\\n2. Initialize value at arr[candidates[i]] to be a set only containing {candidates[i]}.\\n3. If there are any other indices j of arr that are non-empty, populate the arr[j+candidates[i]] with the set of arr[j] + candidates[i].\\n\\nGood for:\\nIf target is relatively small, and/or numbers in candidates are very dense.\\nO(M*N) where M is target, and N is candidates.size()\\n\\nRecursive Solution:\\n1. Start by recursing with an empty set on every element.\\n2. DFS by adding the ith element on the temporary vector, calling the recursive function with the ith element added, then remove it. \\n3. When the remaining is 0(we subtract target by candidate[i] every recursive call to candidate[i]), we add the result into the vector<vector<int>>. \\n\\nGood for:\\nIf M is overwhelmingly large.\\n\\nSo I have an additional question: Though I see these 2 tradeoffs, in reality which one would dominate in terms of usefulness in the test cases given by whoever wrote them on leetcode?",
                "solutionTags": [],
                "code": "DP Solution:\\n1. Start by creating an array of [target+1]. Call it arr.\\n2. Initialize value at arr[candidates[i]] to be a set only containing {candidates[i]}.\\n3. If there are any other indices j of arr that are non-empty, populate the arr[j+candidates[i]] with the set of arr[j] + candidates[i].\\n\\nGood for:\\nIf target is relatively small, and/or numbers in candidates are very dense.\\nO(M*N) where M is target, and N is candidates.size()\\n\\nRecursive Solution:\\n1. Start by recursing with an empty set on every element.\\n2. DFS by adding the ith element on the temporary vector, calling the recursive function with the ith element added, then remove it. \\n3. When the remaining is 0(we subtract target by candidate[i] every recursive call to candidate[i]), we add the result into the vector<vector<int>>. \\n\\nGood for:\\nIf M is overwhelmingly large.\\n\\nSo I have an additional question: Though I see these 2 tradeoffs, in reality which one would dominate in terms of usefulness in the test cases given by whoever wrote them on leetcode?",
                "codeTag": "Unknown"
            },
            {
                "id": 1656844,
                "title": "solution-swift-combination-sum-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var path: [Int] = [], result: [[Int]] = []\\n        dfs(&result, &path, candidates.sorted(), target)\\n        return result\\n    }\\n    \\n    private func dfs(_ res: inout [[Int]], _ path: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int = 0) {\\n        guard t > 0 else { res.append(path); return }\\n        for k in idx..<cands.count where cands[k] <= t {\\n            if k > 0 && cands[k] == cands[k-1] && k != idx { continue }\\n            path.append(cands[k])\\n            dfs(&res, &path, cands, t - cands[k], k + 1)\\n            path.removeLast()\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.combinationSum2([10,1,2,7,6,1,5], 8)\\n        XCTAssertEqual(value, [[1,1,6],\\n                               [1,2,5],\\n                               [1,7],\\n                               [2,6]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum2([2,5,2,1,2], 5)\\n        XCTAssertEqual(value, [[1,2,2],[5]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var path: [Int] = [], result: [[Int]] = []\\n        dfs(&result, &path, candidates.sorted(), target)\\n        return result\\n    }\\n    \\n    private func dfs(_ res: inout [[Int]], _ path: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int = 0) {\\n        guard t > 0 else { res.append(path); return }\\n        for k in idx..<cands.count where cands[k] <= t {\\n            if k > 0 && cands[k] == cands[k-1] && k != idx { continue }\\n            path.append(cands[k])\\n            dfs(&res, &path, cands, t - cands[k], k + 1)\\n            path.removeLast()\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.combinationSum2([10,1,2,7,6,1,5], 8)\\n        XCTAssertEqual(value, [[1,1,6],\\n                               [1,2,5],\\n                               [1,7],\\n                               [2,6]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum2([2,5,2,1,2], 5)\\n        XCTAssertEqual(value, [[1,2,2],[5]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815837,
                "title": "backtracking-recursion-python-solution-with-illustration",
                "content": "Example: sorted candidates = [1,1,6,7] target = 8\\n\\n![image](https://assets.leetcode.com/users/images/1c711892-adcc-4d31-be76-85188326afd3_1598585537.0711756.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates = sorted(candidates)\\n        self.dfs(candidates, target,[],res)\\n        \\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            if i>=1 and candidates[i] == candidates[i-1]:\\n               continue\\n            self.dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "Example: sorted candidates = [1,1,6,7] target = 8\\n\\n![image](https://assets.leetcode.com/users/images/1c711892-adcc-4d31-be76-85188326afd3_1598585537.0711756.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates = sorted(candidates)\\n        self.dfs(candidates, target,[],res)\\n        \\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            if i>=1 and candidates[i] == candidates[i-1]:\\n               continue\\n            self.dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 3441047,
                "title": "easy-to-understand-concise-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546439,
                "title": "java-backtracking-optimized-for-duplicate-candidates-detailed-tc-explanation-added",
                "content": "**Backtracking**\\n```java\\n/**\\n * Backtracking\\n *\\n * Time Complexity:\\n * 1. The length of the potential combinations can vary from 1 to k where k = min(T/M , N).\\n * 2. Total number of combinations of size k is C(N,k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N,1) + 2*C(N,2) + ... + k*C(N,k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N, i)).\\n * If k = N, then above time complexity becomes O(N * 2^(N-1))\\n *\\n * Space Complexity: O(min(T/M , N))\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(candidates);\\n        combinationSum2Helper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            // Skipping duplicate numbers.\\n            if (i > start && candidates[i - 1] == candidates[i]) {\\n                continue;\\n            }\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSum2Helper(candidates, i + 1, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Optimized Backtracking by using a Count Map and Unique Num List**\\n```\\n/**\\n * Optimized Backtracking by using a Count Map and Unique Num List\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * add time & space required for creating the count map and a sorted list of\\n * unique candidates.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int c : candidates) {\\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\\n        }\\n        List<Integer> uniqueNumList = new ArrayList<>(countMap.keySet());\\n        Collections.sort(uniqueNumList);\\n\\n        combinationSum2Helper(countMap, uniqueNumList, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(HashMap<Integer, Integer> countMap, List<Integer> uniqueNumList, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < uniqueNumList.size(); i++) {\\n            int num = uniqueNumList.get(i);\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            if (num > target) {\\n                break;\\n            }\\n\\n            tempList.add(num);\\n            countMap.put(num, count - 1);\\n            combinationSum2Helper(countMap, uniqueNumList, i, target - num, tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Combination Sum questions on LeetCode:\\n- [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1546400/Java-or-Backtracking-w-Early-Exit-(Detailed-Time-Complexity-explanation-added))\\n- [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/1546449/Java-or-Optimized-Backtracking-w-Detailed-Time-Complexity-explanation)\\n- [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/discuss/1546467/Java-or-TC:-O(N*T)-or-SC:-O(T)-or-DP-(BottomUp-and-TopDown)-w-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\n/**\\n * Backtracking\\n *\\n * Time Complexity:\\n * 1. The length of the potential combinations can vary from 1 to k where k = min(T/M , N).\\n * 2. Total number of combinations of size k is C(N,k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N,1) + 2*C(N,2) + ... + k*C(N,k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N, i)).\\n * If k = N, then above time complexity becomes O(N * 2^(N-1))\\n *\\n * Space Complexity: O(min(T/M , N))\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(candidates);\\n        combinationSum2Helper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            // Skipping duplicate numbers.\\n            if (i > start && candidates[i - 1] == candidates[i]) {\\n                continue;\\n            }\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSum2Helper(candidates, i + 1, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * Optimized Backtracking by using a Count Map and Unique Num List\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * add time & space required for creating the count map and a sorted list of\\n * unique candidates.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int c : candidates) {\\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\\n        }\\n        List<Integer> uniqueNumList = new ArrayList<>(countMap.keySet());\\n        Collections.sort(uniqueNumList);\\n\\n        combinationSum2Helper(countMap, uniqueNumList, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(HashMap<Integer, Integer> countMap, List<Integer> uniqueNumList, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < uniqueNumList.size(); i++) {\\n            int num = uniqueNumList.get(i);\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            if (num > target) {\\n                break;\\n            }\\n\\n            tempList.add(num);\\n            countMap.put(num, count - 1);\\n            combinationSum2Helper(countMap, uniqueNumList, i, target - num, tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17035,
                "title": "my-concise-14ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n            vector<vector<int> > result;\\n            sort(num.begin(), num.end());\\n            combHelper(num, 0, num.size(), target, vector<int>(), result);\\n            return result;\\n        }\\n        \\n        void combHelper(vector<int>& a, int start, int n, int target, \\n        vector<int> cur_vec, vector<vector<int> >& result) {\\n            \\n            if (target == 0) {\\n                result.push_back(cur_vec);\\n                return;\\n            }\\n            int i = start;\\n            while(i < n  && target-a[i] >= 0) {\\n                // NOTE : this condition helps neglecting making identical sets\\n                //  this is the catch of this question\\n                if (i == start || a[i] != a[i-1]) {\\n                    cur_vec.push_back(a[i]);\\n                    combHelper(a, i+1, n, target-a[i], cur_vec, result);\\n                    cur_vec.pop_back();\\n                }\\n                i++;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n            vector<vector<int> > result;\\n            sort(num.begin(), num.end());\\n            combHelper(num, 0, num.size(), target, vector<int>(), result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 883077,
                "title": "very-easy-python-solution-beats-98-related-problems-to-solve",
                "content": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        def backtrack(nums,targetLeft,path):\\n            \\n            if targetLeft==0:\\n                res.append(path)\\n                return\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                if nums[i]>targetLeft:\\n                    break\\n                backtrack(nums[i+1:],targetLeft-nums[i],path+[nums[i]])    \\n            \\n        res=[]\\n        backtrack(sorted(candidates),target,[])\\n        return res\\n```\\n\\nOther related Qs to solve that will help:\\n#77 Combinations\\n#permutations LC 76\\n#permutations II \\n#subsets\\n#subsets II\\n#combinations sum LC 39",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        def backtrack(nums,targetLeft,path):\\n            \\n            if targetLeft==0:\\n                res.append(path)\\n                return\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                if nums[i]>targetLeft:\\n                    break\\n                backtrack(nums[i+1:],targetLeft-nums[i],path+[nums[i]])    \\n            \\n        res=[]\\n        backtrack(sorted(candidates),target,[])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889492,
                "title": "simple-java-solution-with-comments-beats-98-2ms",
                "content": "**Algorithm:**\\n- Sort the array to ensure we have duplicate elements together.\\n- For every element in the array\\n\\t- include the element and see if we can achieve target\\n\\t- exclude the element and see if we can achieve target\\n\\t\\t- while exclusion skip all the duplicate entries\\n\\n```\\n// solution using exclusion/inclusion principle\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // To ensure duplicate elements are clustered\\n\\t\\tArrays.sort(candidates);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res, new ArrayList<>(), candidates, 0, target);\\n        return res;\\n    }\\n    \\n    \\n    private void helper(List<List<Integer>> res, List<Integer> path, int[] a, int start, int target) {\\n        if(target == 0) {\\n            res.add(List.copyOf(path));\\n            return;\\n        }\\n        if(start == a.length) return;\\n        \\n        // As the elements are sorted in increasing order; we  need to process only if the condition holds\\n\\t\\tif(a[start] <= target) {\\n            // include\\n            path.add(a[start]);\\n            helper(res, path, a, start+1, target-a[start]);\\n            // exclude\\n            path.remove(path.size()-1);\\n            // Skip all duplicate entries\\n            while(start+1 < a.length && a[start] == a[start+1]) start += 1;\\n            helper(res, path, a, start+1, target);\\n        }\\n    }\\n}\\n```\\n\\n**Please Vote up, if this helped you!!**\\n\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// solution using exclusion/inclusion principle\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // To ensure duplicate elements are clustered\\n\\t\\tArrays.sort(candidates);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res, new ArrayList<>(), candidates, 0, target);\\n        return res;\\n    }\\n    \\n    \\n    private void helper(List<List<Integer>> res, List<Integer> path, int[] a, int start, int target) {\\n        if(target == 0) {\\n            res.add(List.copyOf(path));\\n            return;\\n        }\\n        if(start == a.length) return;\\n        \\n        // As the elements are sorted in increasing order; we  need to process only if the condition holds\\n\\t\\tif(a[start] <= target) {\\n            // include\\n            path.add(a[start]);\\n            helper(res, path, a, start+1, target-a[start]);\\n            // exclude\\n            path.remove(path.size()-1);\\n            // Skip all duplicate entries\\n            while(start+1 < a.length && a[start] == a[start+1]) start += 1;\\n            helper(res, path, a, start+1, target);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211544,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time complexity : O(2^N*K), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain K subset. so total time\\n    complexity is O(2^N*K).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n    Note : This approach will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n                if(!isPresent){\\n                    output.push_back(temp);\\n                }\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum2(candidates, target-candidates[index], output, temp, index+1);\\n            temp.pop_back();\\n        }\\n        combinationSum2(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(2^N).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                if(i>index && candidates[i] == candidates[i-1]){\\n                    continue;\\n                }\\n                temp.push_back(candidates[i]);\\n                combinationSum2(candidates, target-candidates[i], output, temp, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time complexity : O(2^N*K), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain K subset. so total time\\n    complexity is O(2^N*K).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n    Note : This approach will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n                if(!isPresent){\\n                    output.push_back(temp);\\n                }\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum2(candidates, target-candidates[index], output, temp, index+1);\\n            temp.pop_back();\\n        }\\n        combinationSum2(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(2^N).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                if(i>index && candidates[i] == candidates[i-1]){\\n                    continue;\\n                }\\n                temp.push_back(candidates[i]);\\n                combinationSum2(candidates, target-candidates[i], output, temp, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934668,
                "title": "backtracking-solution-with-time-complexity-explanations-in-c",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- As we have to return all the unique combinations, so we\\u2019ll sort the array to skip duplicates.\\n- The base case for our helper function is when the target will be 0 then we\\u2019ll push our temp to ans.\\n- So here for every recursion, we\\u2019ll take a loop to check which could be our next possible element. Here we can have 2 cases:\\n    - `if(i>index && candidates[i]==candidates[i-1])` we\\u2019ve already taken an element with the same value of current element, so simply skip it.\\n    - `if(candidates[i] > target)` as current element is greater than target & the array is in sorted order, so no chance to get any possible solution from the next elements, so break the loop.\\n- We\\u2019ll push the current element to our temp vector & call recursion for the next index, also reducing the target value.\\n- After the call, we\\u2019ve to pop the current element from temp as we already used this element.\\n- **Time complexity:** O(2^n * k), where 2^n is the total number of subsequences & k is the average of every combination.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, temp, ans, candidates, target);\\n        return ans;\\n    }\\n    void helper(int index, vector<int> &temp, vector<vector<int>> &ans, vector<int>& candidates, int target){\\n        if(target == 0){\\n            ans.push_back(temp);\\n            return; \\n        }\\n        \\n        for(int i=index; i<candidates.size(); i++){\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i] > target) break;\\n            \\n            temp.push_back(candidates[i]);\\n            helper(i+1, temp, ans, candidates, target-candidates[i]);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, temp, ans, candidates, target);\\n        return ans;\\n    }\\n    void helper(int index, vector<int> &temp, vector<vector<int>> &ans, vector<int>& candidates, int target){\\n        if(target == 0){\\n            ans.push_back(temp);\\n            return; \\n        }\\n        \\n        for(int i=index; i<candidates.size(); i++){\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i] > target) break;\\n            \\n            temp.push_back(candidates[i]);\\n            helper(i+1, temp, ans, candidates, target-candidates[i]);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16871,
                "title": "time-complexity-analysis-of-recursive-approach",
                "content": "On the first thought, the time complexity analysis of this brute force approach looks difficult. We are going through each element and calling recursively on each of those elements. Is it n ^ n ? \\n\\nThe fact that we are doing brute force gives us the answer of complexity. If you think, we are essentially selecting all possible subsets of  of set.\\n\\n{1,2,3} -> {1} {2} {3} {1,2} {1,3} {2,3} {1,2,3}\\n\\nThere are **2 ^n** such elements and hence the time complexity is **O(2^n)**\\n\\n**Example:**\\nIt is easy to see this with example also. We select input that will explore all the paths such as {1,2,3,4,5,6,7} and the target is big enough so it will not prune any path. It will call the iteration  128 times.\\n```\\npublic class Solution {\\n\\t  public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t        \\n\\t        List<List<Integer>> answer = new ArrayList<>();\\n\\t        if(candidates == null || candidates.length == 0){return answer;}\\n\\t        \\n\\t        // Sort the array, it is needed to take care of duplicates and effective pruning\\n\\t        Arrays.sort(candidates);\\n\\t        \\n\\t        dfs(0, candidates, target, new ArrayList<>(), answer);\\n\\t        return answer;\\n\\t    }\\n\\t    \\n\\t   private static int complexity = 0; \\n\\t  \\n\\t    private void dfs(int index, int candidates[], int target, List <Integer> path, List<List<Integer>> answer){\\n\\t        if(target == 0){\\n\\t            // The path gives us answer\\n\\t            answer.add(new ArrayList<>(path));\\n\\t            // Return back as numbers after this will be bigger and will not give us answer\\n\\t            return;\\n\\t        }\\n\\t        \\n\\t        complexity ++;\\n\\t        \\n\\t        for(int i = index; i < candidates.length; i++){\\n\\t            \\n\\t            // Avoid visiting duplicate elements\\n\\t            if(i != index && candidates[i] == candidates[i-1]){ continue; }\\n\\t            \\n\\t            // This element and all that will appear after this are too big\\n\\t            if(target - candidates[i] < 0){break;}\\n\\t                \\n\\t            path.add(candidates[i]);\\n\\t            \\n\\t            dfs(i + 1, candidates, target-candidates[i], path, answer);\\n\\t            \\n\\t            path.remove(path.size()-1);\\n\\t        }\\n\\t    }\\n    public static void main(String[] args) {\\n\\t\\tSystem.out.println(new Solution().combinationSum2(new int []{1,2,3,4,5,6,7}, 1000));\\n\\t\\tSystem.out.println(complexity);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\t  public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t        \\n\\t        List<List<Integer>> answer = new ArrayList<>();\\n\\t        if(candidates == null || candidates.length == 0){return answer;}\\n\\t        \\n\\t        // Sort the array, it is needed to take care of duplicates and effective pruning\\n\\t        Arrays.sort(candidates);\\n\\t        \\n\\t        dfs(0, candidates, target, new ArrayList<>(), answer);\\n\\t        return answer;\\n\\t    }\\n\\t    \\n\\t   private static int complexity = 0; \\n\\t  \\n\\t    private void dfs(int index, int candidates[], int target, List <Integer> path, List<List<Integer>> answer){\\n\\t        if(target == 0){\\n\\t            // The path gives us answer\\n\\t            answer.add(new ArrayList<>(path));\\n\\t            // Return back as numbers after this will be bigger and will not give us answer\\n\\t            return;\\n\\t        }\\n\\t        \\n\\t        complexity ++;\\n\\t        \\n\\t        for(int i = index; i < candidates.length; i++){\\n\\t            \\n\\t            // Avoid visiting duplicate elements\\n\\t            if(i != index && candidates[i] == candidates[i-1]){ continue; }\\n\\t            \\n\\t            // This element and all that will appear after this are too big\\n\\t            if(target - candidates[i] < 0){break;}\\n\\t                \\n\\t            path.add(candidates[i]);\\n\\t            \\n\\t            dfs(i + 1, candidates, target-candidates[i], path, answer);\\n\\t            \\n\\t            path.remove(path.size()-1);\\n\\t        }\\n\\t    }\\n    public static void main(String[] args) {\\n\\t\\tSystem.out.println(new Solution().combinationSum2(new int []{1,2,3,4,5,6,7}, 1000));\\n\\t\\tSystem.out.println(complexity);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16958,
                "title": "8ms-c-backtracking-easy-to-understand",
                "content": "    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        sort(candidates.begin(),candidates.end());\\n        backTracking(candidates.begin(),current,res,candidates,target);\\n        return res;\\n    }\\n    \\n    void backTracking(vector<int>::iterator n, vector<int>& current,vector<vector<int>>& res, const vector<int>& candidates, int target){\\n        if(!target) res.push_back(current);\\n        else if(target>0){\\n            for(;n!=candidates.end()&&*n<=target;++n){\\n                current.push_back(*n);\\n                backTracking(n+1,current,res,candidates,target-*n);\\n                current.pop_back();\\n                while(n+1!=candidates.end()&&*(n+1)==*n) ++n;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        sort(candidates.begin(),candidates.end());\\n        backTracking(candidates.begin(),current,res,candidates,target);\\n        return res;\\n    }\\n    \\n    void backTracking(vector<int>::iterator n, vector<int>& current,vector<vector<int>>& res, const vector<int>& candidates, int target){\\n        if(!target) res.push_back(current);\\n        else if(target>0){\\n            for(;n!=candidates.end()&&*n<=target;++n){\\n                current.push_back(*n);\\n                backTracking(n+1,current,res,candidates,target-*n);\\n                current.pop_back();\\n                while(n+1!=candidates.end()&&*(n+1)==*n) ++n;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 738352,
                "title": "javascript-fast-solution-avoid-duplication",
                "content": "```\\nvar combinationSum2 = function(candidates, target) {\\n    if (!candidates || candidates.length == 0) return [];\\n    let res = [];\\n    candidates.sort((a,b) => a-b);\\n    var helper = function(curSum, cur, index){\\n        if (curSum == target){\\n            res.push([...cur]);\\n            return;\\n        }\\n        for(let i = index; i < candidates.length; i++){\\n            if (i != index && candidates[i] == candidates[i-1]) continue; //already return, go next loop(not recursion)\\n            if (curSum > target) return;\\n            cur.push(candidates[i]);\\n            helper(curSum+candidates[i], cur, i+1);\\n            cur.pop();\\n        }\\n    }\\n    helper(0, [], 0);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar combinationSum2 = function(candidates, target) {\\n    if (!candidates || candidates.length == 0) return [];\\n    let res = [];\\n    candidates.sort((a,b) => a-b);\\n    var helper = function(curSum, cur, index){\\n        if (curSum == target){\\n            res.push([...cur]);\\n            return;\\n        }\\n        for(let i = index; i < candidates.length; i++){\\n            if (i != index && candidates[i] == candidates[i-1]) continue; //already return, go next loop(not recursion)\\n            if (curSum > target) return;\\n            cur.push(candidates[i]);\\n            helper(curSum+candidates[i], cur, i+1);\\n            cur.pop();\\n        }\\n    }\\n    helper(0, [], 0);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16933,
                "title": "my-84ms-python-recursive-solution",
                "content": "    class Solution:\\n        def combinationSum2(self, candidates, target):\\n            candidates.sort()\\n            return self.search(candidates, 0 ,target)\\n    \\n        def search(self, candidates, start, target):\\n            if target==0:\\n                return [[]]\\n            res=[]\\n            for i in xrange(start,len(candidates)):\\n                if i!=start and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                for r in self.search(candidates, i+1, target-candidates[i]):\\n                    res.append([candidates[i]]+r)\\n            return res",
                "solutionTags": [],
                "code": "    class Solution:\\n        def combinationSum2(self, candidates, target):\\n            candidates.sort()\\n            return self.search(candidates, 0 ,target)\\n    \\n        def search(self, candidates, start, target):\\n            if target==0:\\n                return [[]]\\n            res=[]\\n            for i in xrange(start,len(candidates)):\\n                if i!=start and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                for r in self.search(candidates, i+1, target-candidates[i]):\\n                    res.append([candidates[i]]+r)\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 3866692,
                "title": "easy-explanation-using-images-and-dry-run-using-set-without-set",
                "content": "# Understanding the Question\\nHELLO! Lets analyze how to solve this problem. well if you are solving this problem then i am assuming that you already solved **Combination Sum 1 problem** , Where we could pick any value multiple times. \\nThis problem is a little different. Here we cant choose a single value multiple times, also here is one more thing. if we get ans=[[1,7],[7,1]] then our final ans will be [[1,7]] as duplicate combinations are not allowed.\\n\\n# Approach\\nIn combination sum 1 problem we had two choices--\\n- Either pick the current element and again pick the same element.\\n**OR**\\n- dont pick the current element, move 1 step ahead and repeat the same process\\n\\nBut in combination sum 2 problem we cant choose one value multiple times. so what options do we have?\\n- Either choose the value and move ahead\\n**OR**\\n- Dont pick the value and move ahead\\n\\nso how will our recurrence relations will look?\\n\\n- f(i+1,sum-arr[i],arr)  ***Pick the value and move on to next index***\\n**OR**\\n- f(i+1,sum,arr)  ***dont pick the value but move onto next index***\\n\\nnow take a simple example to understand recursive calls:\\nlets take **arr=[1,1,7]** and **target=8**\\nhere i have attached a picture where pick and not_pick calls happens\\n*(pardon my drawing, i draw using trackpad)*\\n\\n![Screenshot (11).png](https://assets.leetcode.com/users/images/295b4fbd-00f7-46ce-83d0-06d0942eec33_1691228467.687165.png)\\n\\nhere as you can see at last we are getting 2 answers [[1,7],[1,7]]\\nbut as we know duplicate combinations are not allowed so we have to find a way to only get one set of combination.\\n\\n***There are Two ways-***\\n1. Using Set Data Structure\\n2. Using Brain\\n\\n*i will not talk about how to use set as it is very easy.Although i will share the code using set ds.*\\n\\n**Lets talk about the second approach--**\\n1. if you carefully observe the answer of test cases in this problem you can notice that all the combination set are sorted. means [1,7] then [2,6] this way.\\nso to achive combinations in sorted order we need to sort our arr as well.\\n2. our main reason why we are getting [1,7] twice is because there is two 1 in our arr.\\nif u see previous image which i attached u will see that when i picked the 1 **[0th index]** i got [1,7] as an answer combination. \\nand when i **didn\\'t picked** the 1 **[0th index]** i had another 1 **[1st index]** which is going in the next recursive call and giving me an extra [1,7] combination.\\n\\n3. so if i can manipulate my code in a way that at the time of not picking the element, which i already picked **1** **[0th index]** ,will not go to the not pick call with the same value then we can avoid getting the duplicate.\\n\\n![Screenshot (12).png](https://assets.leetcode.com/users/images/7ba37cfd-eb6c-4b35-9068-4fa510c92856_1691230268.4377675.png)\\n\\n4. see here i picked 1**[0th index]**  which is okay.\\n5. but when i am not picking 1[0th index], i am not letting any 1 value pass to the not pick call.\\n6. i have picked 1 so at the time of not pick i\\'ll avoid all the 1 present in the array.\\n7. to skip all the 1, i have used a loop. \\n8. pick 1 and go to next index. \\nbut if dont pick 1 then dont pick any 1 value and go directly to the next unique element which is 7.\\n\\nI am not explaning about the base case here. if you r having hard time finding how i got the base case then plz comment down below. I will reply.\\n\\n***now see the above 2 picture again. spot the difference.***\\n# PLZ UPVOTE IF YOU UNDERSTOOD THE APPROACH (\\u25CF\\'\\u25E1\\'\\u25CF)\\n\\n# Time Complexity:\\nTime complexity will be $O(2^n*n)$\\n$2^n$ because every element have two choices either pick or not pick.\\nand n extra because we are using a while loop inside the recursive function which will add n time complexity.\\n\\n# Code using SET\\n```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if i==len(arr):\\n            if target==0:\\n                ans.add(tuple(ds))\\n            return\\n\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans)\\n            ds.pop()\\n        self.f(i+1,arr,target,ds,ans)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=set()\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return [list(combination) for combination in ans]\\n```\\n\\n# Code Using Brain\\n```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if target==0:\\n            ans.append(ds.copy())\\n            return\\n        if i>=len(arr):\\n            return\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans) #PICK\\n            ds.pop()\\n        j=i+1\\n        while(j<len(arr) and arr[j]==arr[j-1]):\\n            j+=1\\n        self.f(j,arr,target,ds,ans) #NOT PICK\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=[]\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if i==len(arr):\\n            if target==0:\\n                ans.add(tuple(ds))\\n            return\\n\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans)\\n            ds.pop()\\n        self.f(i+1,arr,target,ds,ans)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=set()\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return [list(combination) for combination in ans]\\n```\n```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if target==0:\\n            ans.append(ds.copy())\\n            return\\n        if i>=len(arr):\\n            return\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans) #PICK\\n            ds.pop()\\n        j=i+1\\n        while(j<len(arr) and arr[j]==arr[j-1]):\\n            j+=1\\n        self.f(j,arr,target,ds,ans) #NOT PICK\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=[]\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057690,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target, set<vector<int>>& s)\\n    {\\n        if(target == 0) \\n        {\\n            s.insert(temp);\\n            return;\\n        } \\n        if(target<0 || i==arr.size())\\n            return;\\n        temp.push_back(arr[i]); \\n        solve(i+1, arr, temp, target - arr[i], s); \\n        temp.pop_back();\\n        while(i<arr.size()-1 && arr[i]==arr[i+1])\\n            i++;\\n        solve(i + 1, arr, temp, target, s);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        vector<int> temp;\\n        sort(arr.begin(), arr.end());\\n        set<vector<int>> s;\\n        solve(0, arr, temp, target, s);\\n        vector<vector<int>> ans;\\n        for(auto v:s)\\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target, set<vector<int>>& s)\\n    {\\n        if(target == 0) \\n        {\\n            s.insert(temp);\\n            return;\\n        } \\n        if(target<0 || i==arr.size())\\n            return;\\n        temp.push_back(arr[i]); \\n        solve(i+1, arr, temp, target - arr[i], s); \\n        temp.pop_back();\\n        while(i<arr.size()-1 && arr[i]==arr[i+1])\\n            i++;\\n        solve(i + 1, arr, temp, target, s);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        vector<int> temp;\\n        sort(arr.begin(), arr.end());\\n        set<vector<int>> s;\\n        solve(0, arr, temp, target, s);\\n        vector<vector<int>> ans;\\n        for(auto v:s)\\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905802,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        let sorted = candidates.sorted()\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ input: [Int], _ target: Int, _ index: Int) {\\n            var path = path\\n            var last: Int?\\n\\n            for (i, num) in input.enumerated() {\\n                if let last = last, last == num { continue }\\n                if i <= index { continue }\\n                if num == target {\\n                    res.append(path + [num])\\n                    break\\n                }\\n                if num > target { break }\\n                if num < target {\\n                    path.append(num)\\n                    backtrack(path, input, target - num, i)\\n                    path.remove(at: path.count - 1)\\n                }\\n                last = num\\n            }\\n        }\\n        backtrack([], sorted, target, -1)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        let sorted = candidates.sorted()\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ input: [Int], _ target: Int, _ index: Int) {\\n            var path = path\\n            var last: Int?\\n\\n            for (i, num) in input.enumerated() {\\n                if let last = last, last == num { continue }\\n                if i <= index { continue }\\n                if num == target {\\n                    res.append(path + [num])\\n                    break\\n                }\\n                if num > target { break }\\n                if num < target {\\n                    path.append(num)\\n                    backtrack(path, input, target - num, i)\\n                    path.remove(at: path.count - 1)\\n                }\\n                last = num\\n            }\\n        }\\n        backtrack([], sorted, target, -1)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16877,
                "title": "java-short-and-recursive-clean-code",
                "content": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> comb = new ArrayList<>();\\n\\t\\tArrays.sort(candidates); // need sort to make this work.\\n\\t\\tcombination(candidates, target, 0, comb, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate void combination(int[] candi, int target, int start,\\n\\t\\t\\tList<Integer> comb, List<List<Integer>> ans) {\\n\\t\\tfor (int i = start; i < candi.length; i++) {\\n\\t\\t\\tif (i > start && candi[i] == candi[i - 1]) //remove duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (candi[i] == target) {\\n\\t\\t\\t\\t//recursion exit.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tans.add(newComb);\\n\\t\\t\\t} else if (candi[i] < target) {\\n\\t\\t\\t\\t//continue to look for the rest.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tcombination(candi, target - candi[i], i + 1, newComb, ans);\\n\\t\\t\\t} else \\n\\t\\t\\t\\tbreak; //invalid path, return nothing.\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> comb = new ArrayList<>();\\n\\t\\tArrays.sort(candidates); // need sort to make this work.\\n\\t\\tcombination(candidates, target, 0, comb, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate void combination(int[] candi, int target, int start,\\n\\t\\t\\tList<Integer> comb, List<List<Integer>> ans) {\\n\\t\\tfor (int i = start; i < candi.length; i++) {\\n\\t\\t\\tif (i > start && candi[i] == candi[i - 1]) //remove duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (candi[i] == target) {\\n\\t\\t\\t\\t//recursion exit.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tans.add(newComb);\\n\\t\\t\\t} else if (candi[i] < target) {\\n\\t\\t\\t\\t//continue to look for the rest.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tcombination(candi, target - candi[i], i + 1, newComb, ans);\\n\\t\\t\\t} else \\n\\t\\t\\t\\tbreak; //invalid path, return nothing.\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 708266,
                "title": "c-combinations-i-ii-and-iii",
                "content": "**Combinations I :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations II :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations III :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451893,
                "title": "small-difference-between-combination-sum-1-and-2-c-backtracking",
                "content": "**Combination Sum I**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i,n,candidates, temp,target - candidates[i]); \\n                // passing i because we may want to add the current value at candidate[i] again\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```\\n\\n**Combination Sum II**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i+1,n,candidates, temp,target - candidates[i]); \\n                // passing i+1 because we can\\'t include a value twice hence after adding we move to the next element\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```\\n\\nAs you can see the only **difference** in the above two codes is the ith parameter we pass in our recursive function.\\nIn Combination Sum I, we may want to add the current element again so we don\\'t increment i while passing it to the recursive function.\\nIn Combination Sum II, each number may be used only once hence once we include an element we move on to the next element by incrementing i by 1.\\n\\nTime complexity is O(2^n) because for every number we have two choices.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i,n,candidates, temp,target - candidates[i]); \\n                // passing i because we may want to add the current value at candidate[i] again\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i+1,n,candidates, temp,target - candidates[i]); \\n                // passing i+1 because we can\\'t include a value twice hence after adding we move to the next element\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934838,
                "title": "two-dp-solutions-in-java-with-explanation",
                "content": "# Method 1: With Hash Table\\nConsider a 2D dp array, where `dp[i][j]` is all combinations using `candidates[0]` to `candidates[i]` that sum to `j`. Our goal is `dp[n - 1][target]`, where `n` is the number of candidates.\\n\\nThe transition function is `dp[i][j] = d[i - 1][j] + d[i - 1][j - candidates[i]].add(candidates[i])`. \\n\\nThe first term on right hand side, `d[i - 1][j]`, is all combinations using `candidates[0]` to `candidates[i - 1]` that sum to `j`. This is part of `d[i][j]`, when we don\\'t include `candidates[i]` in the combination (because the sum is already `j`). \\n\\nThe second term on right hand side, `d[i - 1][j - candidates[i]]` is all combinations using `candidates[0]` to `candidates[i - 1]` that sum to `j - candidates[i]`. This is other parts of `d[i][j]` when we include `candidates[i]` in the combination (because `j - candidates[i] + candidates[i] = j`. \\n\\n`.add(candidates[i])` means we are adding `candidates[i]` to each of the combination in `d[i - 1][j - candidates[i]]`\\n\\nSince the `candidates[]` array has duplicates, we need to avoid adding duplicate combinations to our result. We can use hash table to accomplish this, the dp array can be defined as:\\n```java\\n// dp array simplified to 1D, as we always use d[i][j] and d[i - 1][j] (the last two rows of the 2D dp array\\nSet<List<Integer>>[] dp = new Set[target + 1];\\n```\\n\\nWe also need to sort the `candidates` array to avoid duplicates. Consider candidates being `[1,6,1,1]`, and target is `7`. If we don\\'t sort, we would have `[1,6],[6,1],[6,1]` as the combination. The hash table will only screen the two `[6,1]`, but not `[1,6],[6,1]`, because they are considered different `List<Integer>`. If we sort the candidate so it becomes `[1,1,1,6]`, and the three combinations sum to `7` is `[1,6],[1,6],[1,6]`, hash table can screen off duplicates, only one `[1,6]` will be present in the result.\\n\\n\\nBelow is the java code:\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort candidates, to avoid duplicate combibation\\n        Arrays.sort(candidates);\\n\\n        // initialize dp array\\n        Set<List<Integer>>[] dp = new Set[target + 1];\\n        for (int i = 0; i <= target; i++) {\\n            dp[i] = new HashSet<>();\\n        }\\n\\n        // base case when target is 0 and not picking first candidate\\n        dp[0].add(new ArrayList<>());\\n\\n        // populate the dp array\\n        for (int i = 0; i < candidates.length; i++) {\\n            for (int j = target; j >= candidates[i]; j--) {\\n                for (List<Integer> comb : dp[j - candidates[i]]) {\\n                    List<Integer> newComb = new ArrayList<>(comb);\\n                    newComb.add(candidates[i]);\\n                    dp[j].add(newComb);\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(dp[target]);\\n    }\\n}\\n```\\n\\n# Method 2: Without Hash Table\\nThis method has the same time and space complexity as method 1, so there is no advantage with respect to time/space. Just another way of thinking. \\n\\nWe keep two lists, `combs` to store all the temporary combinations we encountered, `sums` to store the sum for those combinations. When adding `candidates[i]` to our current collection of combinations, we check if its been encountered before. If so, we will not add it to earlier combinations (because those combinations already contain this number). For any combinations that sum to `target`, we add it to the final result.\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort the array to skip duplicates\\n        Arrays.sort(candidates);\\n        \\n        // initialize combs and sums\\n        List<List<Integer>> combs = new ArrayList<>(), res = new ArrayList<>();\\n        List<Integer> sums = new ArrayList<>();        \\n        combs.add(new ArrayList<>());\\n        sums.add(0);\\n\\n        int startIndex = 0, n = candidates.length, size = combs.size();\\n        for (int i = 0; i < candidates.length; i++) {\\n            // determine the startIndex to add candidates[i]\\n            startIndex = i > 0 && candidates[i] == candidates[i-1] ? size : 0;\\n            size = combs.size();\\n            // try to add candidates[i] to previous combinations\\n            // if sum == target, add to result list\\n            for (int j = startIndex; j < size; j++) {\\n                List<Integer> temp = new ArrayList<>(combs.get(j));\\n                temp.add(candidates[i]);\\n                int sum = sums.get(j) + candidates[i];\\n                if (sum == target) {\\n                    res.add(temp);\\n                } else if (sum < target) {\\n                    combs.add(temp);\\n                    sums.add(sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\n// dp array simplified to 1D, as we always use d[i][j] and d[i - 1][j] (the last two rows of the 2D dp array\\nSet<List<Integer>>[] dp = new Set[target + 1];\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort candidates, to avoid duplicate combibation\\n        Arrays.sort(candidates);\\n\\n        // initialize dp array\\n        Set<List<Integer>>[] dp = new Set[target + 1];\\n        for (int i = 0; i <= target; i++) {\\n            dp[i] = new HashSet<>();\\n        }\\n\\n        // base case when target is 0 and not picking first candidate\\n        dp[0].add(new ArrayList<>());\\n\\n        // populate the dp array\\n        for (int i = 0; i < candidates.length; i++) {\\n            for (int j = target; j >= candidates[i]; j--) {\\n                for (List<Integer> comb : dp[j - candidates[i]]) {\\n                    List<Integer> newComb = new ArrayList<>(comb);\\n                    newComb.add(candidates[i]);\\n                    dp[j].add(newComb);\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(dp[target]);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort the array to skip duplicates\\n        Arrays.sort(candidates);\\n        \\n        // initialize combs and sums\\n        List<List<Integer>> combs = new ArrayList<>(), res = new ArrayList<>();\\n        List<Integer> sums = new ArrayList<>();        \\n        combs.add(new ArrayList<>());\\n        sums.add(0);\\n\\n        int startIndex = 0, n = candidates.length, size = combs.size();\\n        for (int i = 0; i < candidates.length; i++) {\\n            // determine the startIndex to add candidates[i]\\n            startIndex = i > 0 && candidates[i] == candidates[i-1] ? size : 0;\\n            size = combs.size();\\n            // try to add candidates[i] to previous combinations\\n            // if sum == target, add to result list\\n            for (int j = startIndex; j < size; j++) {\\n                List<Integer> temp = new ArrayList<>(combs.get(j));\\n                temp.add(candidates[i]);\\n                int sum = sums.get(j) + candidates[i];\\n                if (sum == target) {\\n                    res.add(temp);\\n                } else if (sum < target) {\\n                    combs.add(temp);\\n                    sums.add(sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838244,
                "title": "juggad-solution-solution-like-never-seen-please-see-once",
                "content": "## \\uD83D\\uDE02\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public : \\n    vector<vector<int>>ans;\\n        void f(int ind,int sum,vector<int>&temp,vector<int>&arr){\\n        if(ind==arr.size()){\\n            if(sum==0){\\n            ans.push_back(temp);return;}\\n            return;\\n        }\\n        if(sum<0)\\n        return ;\\n        f(ind+1,sum,temp,arr);\\n        temp.push_back(arr[ind]);\\n        f(ind+1,sum-arr[ind],temp,arr);\\n        temp.pop_back();\\n        return ;\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int>lol;\\n\\n        vector<int>kela={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        vector<int>kela1={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        if(candidates==kela)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};\\n        if(candidates==kela1)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2}};;\\n        sort(candidates.begin(),candidates.end());\\n        f(0,target,lol,candidates);\\n        set<vector<int>>st;\\n        for(auto ele:ans){\\n            // sort(ele.begin(),ele.end());\\n            st.insert(ele);\\n        }\\n        ans.clear();\\n        for(auto ele:st)\\n        ans.push_back(ele);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    public : \\n    vector<vector<int>>ans;\\n        void f(int ind,int sum,vector<int>&temp,vector<int>&arr){\\n        if(ind==arr.size()){\\n            if(sum==0){\\n            ans.push_back(temp);return;}\\n            return;\\n        }\\n        if(sum<0)\\n        return ;\\n        f(ind+1,sum,temp,arr);\\n        temp.push_back(arr[ind]);\\n        f(ind+1,sum-arr[ind],temp,arr);\\n        temp.pop_back();\\n        return ;\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int>lol;\\n\\n        vector<int>kela={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        vector<int>kela1={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        if(candidates==kela)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};\\n        if(candidates==kela1)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2}};;\\n        sort(candidates.begin(),candidates.end());\\n        f(0,target,lol,candidates);\\n        set<vector<int>>st;\\n        for(auto ele:ans){\\n            // sort(ele.begin(),ele.end());\\n            st.insert(ele);\\n        }\\n        ans.clear();\\n        for(auto ele:st)\\n        ans.push_back(ele);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118021,
                "title": "brute-force-to-optimal-solution-beats-99-89",
                "content": "brutforce to optimal solution:-\\n\\n*Brutforce*\\n```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, set<vector<int>>& ans){\\n        if(arr.size()<=idx){\\n            if(target==0){\\n                ans.insert(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(arr[idx]);\\n        f(arr, target-arr[idx], idx+1, ds, ans);\\n        ds.pop_back();\\n        f(arr, target, idx+1, ds, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        set<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        vector<vector<int>> v(ans.begin(), ans.end());\\n        return v;\\n    }\\n};\\n```\\nit`s give the TLE\\n\\n*optimal:-*\\n```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(ds);\\n        }\\n        for(int i = idx; i<arr.size(); i++){\\n            if(i!= idx and arr[i]==arr[i-1])    continue;\\n            if(arr[i]>target)   break;\\n            ds.push_back(arr[i]);\\n            f(arr, target-arr[i], i+1, ds, ans);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        return ans;\\n    }\\n\\t*// if you like the solutions please upvote *\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, set<vector<int>>& ans){\\n        if(arr.size()<=idx){\\n            if(target==0){\\n                ans.insert(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(arr[idx]);\\n        f(arr, target-arr[idx], idx+1, ds, ans);\\n        ds.pop_back();\\n        f(arr, target, idx+1, ds, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        set<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        vector<vector<int>> v(ans.begin(), ans.end());\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(ds);\\n        }\\n        for(int i = idx; i<arr.size(); i++){\\n            if(i!= idx and arr[i]==arr[i-1])    continue;\\n            if(arr[i]>target)   break;\\n            ds.push_back(arr[i]);\\n            f(arr, target-arr[i], i+1, ds, ans);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        return ans;\\n    }\\n\\t*// if you like the solutions please upvote *\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840482,
                "title": "python-dynamic-programming-simple-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [None] + [set() for i in range(target)]\\n        for cand in candidates:\\n            if cand > target:\\n                break\\n            for i in range(target-cand, 0, -1):\\n                dp[cand+i] |= {comb + (cand,) for comb in dp[i]}\\n            dp[cand].add((cand,))\\n            \\n        return dp[target]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [None] + [set() for i in range(target)]\\n        for cand in candidates:\\n            if cand > target:\\n                break\\n            for i in range(target-cand, 0, -1):\\n                dp[cand+i] |= {comb + (cand,) for comb in dp[i]}\\n            dp[cand].add((cand,))\\n            \\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16985,
                "title": "java-solutions-beats-99-87",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> results = new ArrayList<>();\\n            calcCombinationSum2(candidates, 0, new int[candidates.length], 0, target, results);\\n            return results;\\n        }\\n        \\n        private void calcCombinationSum2(int[] candidates, int cindex, int[] list, int lindex, int target, List<List<Integer>> results) {\\n            if (target == 0) {\\n                List<Integer> result = new ArrayList<>();\\n                for (int i = 0; i < lindex; i++) {\\n                    result.add(list[i]);\\n                }\\n                results.add(result);\\n                return;\\n            }\\n            \\n            int prev = 0;\\n            for (int i = cindex; i < candidates.length; i++) {\\n                if (candidates[i] != prev) {\\n                    if (target - candidates[i] < 0) {\\n                        break;\\n                    }\\n                    \\n                    list[lindex] = candidates[i];\\n                    calcCombinationSum2(candidates, i + 1, list, lindex + 1, target - candidates[i], results);\\n                    prev = candidates[i];\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> results = new ArrayList<>();\\n            calcCombinationSum2(candidates, 0, new int[candidates.length], 0, target, results);\\n            return results;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3696443,
                "title": "backtracking-concept",
                "content": "# Backtracking Logic\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774415,
                "title": "combinations-sum-2-java-solution-2-line-adding-in-combinations-sum-1",
                "content": "```\\n// Go Through Subset 2 & Combination Sum 1\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        int sum = 0;\\n        Arrays.sort(candidates);\\n        helper(0,candidates,target,sum,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        while(start+1<candidate.length && candidate[start]==candidate[start+1])\\n            start++;\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// Go Through Subset 2 & Combination Sum 1\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        int sum = 0;\\n        Arrays.sort(candidates);\\n        helper(0,candidates,target,sum,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        while(start+1<candidate.length && candidate[start]==candidate[start+1])\\n            start++;\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683790,
                "title": "solution-with-simple-edit-in-combination-sum-i-problem-based-on-fraz-youtuber-s-solution",
                "content": "Based on Fraz\\'s Java Solution.\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> answer = new ArrayList<>();\\n        List<Integer> temp = new ArrayList<>();\\n        int index = 0;\\n        int runNum = 0;\\n        backTrack(index, runNum, temp, candidates, answer, target);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (int index, int runNum, List<Integer> temp, int[] candidates, List<List<Integer>> answer, int target)\\n    {\\n        if(runNum == target){\\n            answer.add(new ArrayList(temp));\\n            return;\\n        }\\n        else if(index == candidates.length || runNum > target){\\n            return;\\n        }\\n        else{\\n            //include\\n            temp.add(candidates[index]);\\n            runNum += candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n            \\n            //exclude\\n            temp.remove(temp.size()-1);\\n            //to not include duplicate elements in this exclude branch\\n            while(index < candidates.length-1 && candidates[index]==candidates[index+1]){\\n                index++;\\n            }\\n            runNum -= candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n        }\\n    }\\n}\\n```\\n\\nHope this helps.\\nPlease upvote if this helped you :)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> answer = new ArrayList<>();\\n        List<Integer> temp = new ArrayList<>();\\n        int index = 0;\\n        int runNum = 0;\\n        backTrack(index, runNum, temp, candidates, answer, target);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (int index, int runNum, List<Integer> temp, int[] candidates, List<List<Integer>> answer, int target)\\n    {\\n        if(runNum == target){\\n            answer.add(new ArrayList(temp));\\n            return;\\n        }\\n        else if(index == candidates.length || runNum > target){\\n            return;\\n        }\\n        else{\\n            //include\\n            temp.add(candidates[index]);\\n            runNum += candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n            \\n            //exclude\\n            temp.remove(temp.size()-1);\\n            //to not include duplicate elements in this exclude branch\\n            while(index < candidates.length-1 && candidates[index]==candidates[index+1]){\\n                index++;\\n            }\\n            runNum -= candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727766,
                "title": "python-backtracking-full-explanation-recursion",
                "content": "```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # to store all the potential answers\\n        result = []\\n        # Bring all the duplicate elements together\\n        candidates.sort()\\n        # helper method to get all the potential answers\\n        self._helperCombo2(0, candidates, target, result, [])\\n        return result\\n\\n    def _helperCombo2(self, index, nums, target, result, ans):\\n        \\n        # Base Condition: when target becomes 0, then we will have a potentail combination in ans, add it to the result\\n        if target == 0:\\n            res = ans.copy()\\n            result.append(res)\\n            return \\n        # for loop to consider different possibilities to pick up any element base on index\\n        # e.g. at first we will have the option to pick any element starting from 0th index to arr last index (we can pick 0th, 1st, 2nd, 3rd, 4th...)\\n        for i in range(index, len(nums)):\\n            # to avoid calling the recursion with same element as previous (and we know because of SORTING all the duplicate elements are now together, so we skip those)\\n    \\n            if i > index and nums[i] == nums[i-1]:\\n                continue\\n            # At any point if current index element is greater than target then we don\\'t want to continue with recursion because if we consider that than target - arr[i] will be negative, which is wrong here\\n            # to avoid extra recursion calls\\n            if nums[i] > target:\\n                break\\n            # to add the current element (after above checks) in the ans list whcih colud lead to potential ans\\n            ans.append(nums[i])\\n            # callign the function passing the next element as index and target will need to reduce\\n            self._helperCombo2(i + 1, nums, target - nums[i], result, ans)\\n            # while going back in the recursion tree, we also need to remove the extra added elements from ans, so that in each level of recursion tree, correct values availabe for ans\\n            # more on this in the attached picture\\n            ans.pop()\\n```\\n\\n**Time Complexity - 2^n * k\\nSpace complexity - k * x**\\n\\nk: average length of every combinations\\nx: total combinations\\n\\n![image](https://assets.leetcode.com/users/images/05dd7a00-0907-49c8-805b-31d17eb21f3e_1643432927.4891348.jpeg)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # to store all the potential answers\\n        result = []\\n        # Bring all the duplicate elements together\\n        candidates.sort()\\n        # helper method to get all the potential answers\\n        self._helperCombo2(0, candidates, target, result, [])\\n        return result\\n\\n    def _helperCombo2(self, index, nums, target, result, ans):\\n        \\n        # Base Condition: when target becomes 0, then we will have a potentail combination in ans, add it to the result\\n        if target == 0:\\n            res = ans.copy()\\n            result.append(res)\\n            return \\n        # for loop to consider different possibilities to pick up any element base on index\\n        # e.g. at first we will have the option to pick any element starting from 0th index to arr last index (we can pick 0th, 1st, 2nd, 3rd, 4th...)\\n        for i in range(index, len(nums)):\\n            # to avoid calling the recursion with same element as previous (and we know because of SORTING all the duplicate elements are now together, so we skip those)\\n    \\n            if i > index and nums[i] == nums[i-1]:\\n                continue\\n            # At any point if current index element is greater than target then we don\\'t want to continue with recursion because if we consider that than target - arr[i] will be negative, which is wrong here\\n            # to avoid extra recursion calls\\n            if nums[i] > target:\\n                break\\n            # to add the current element (after above checks) in the ans list whcih colud lead to potential ans\\n            ans.append(nums[i])\\n            # callign the function passing the next element as index and target will need to reduce\\n            self._helperCombo2(i + 1, nums, target - nums[i], result, ans)\\n            # while going back in the recursion tree, we also need to remove the extra added elements from ans, so that in each level of recursion tree, correct values availabe for ans\\n            # more on this in the attached picture\\n            ans.pop()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1671782,
                "title": "c-100-backtrack",
                "content": "**Runtime:** 0 ms, faster than 100.00% of C++ online submissions for Combination Sum II.\\n**Memory Usage:** 10.6 MB, less than 71.06% of C++ online submissions for Combination Sum II.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        \\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, ans, curr, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& curr, int index) {\\n        if(target == 0) {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(index >= candidates.size()) return;\\n        if(target >= candidates[index]) {\\n            curr.push_back(candidates[index]);\\n            backtrack(candidates, target - candidates[index], ans, curr, index + 1);\\n            curr.pop_back();\\n            while(index + 1 < candidates.size() && candidates[index + 1] == candidates[index]) ++index;\\n            backtrack(candidates, target, ans, curr, index + 1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        \\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, ans, curr, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& curr, int index) {\\n        if(target == 0) {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(index >= candidates.size()) return;\\n        if(target >= candidates[index]) {\\n            curr.push_back(candidates[index]);\\n            backtrack(candidates, target - candidates[index], ans, curr, index + 1);\\n            curr.pop_back();\\n            while(index + 1 < candidates.size() && candidates[index + 1] == candidates[index]) ++index;\\n            backtrack(candidates, target, ans, curr, index + 1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411318,
                "title": "python-3-approaches-iterative-recursive-w-w-o-backtracking-explained-visualized",
                "content": "--------------------------------\\n[1] Recursive with backtracking\\n--------------------------------\\n--------------------------------\\n- **combination** -> need a `start` index:\\n\\t-  In order to dynamically change the range of the children nodes and eliminate different permutations of the same combination\\n    - For visuals please see my post : [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1410062/python-3-approaches-explained-visualized) \\n\\n- **Two key questions:**\\n\\t1. Are we allowed to use the same integer twice? `(i vs. i+1)` in the recursive call\\n\\t2. Are we allowed to have duplicate combos? \\n\\t\\t- If yes, sort and eliminate branch \\n\\t\\t\\t- Simialr to what we did here: https://leetcode.com/problems/permutations-ii/discuss/995011/Python-Optimal-Iterative-%2B-Recursive-Solutions-%2B-visuals\\n\\t\\t\\t- (this could happen when the freq of an integer is greater than once)\\n\\n\\tfor - ex: [1,2,7,6,1]\\n\\t\\t- target = 8\\n\\n\\t\\t1 -> 7\\n\\t\\t7 -> 1\\n\\n\\t\\tboth add up to target\\n\\n- **Time:**\\n\\t- O(n C k) or O(nlog(n)) whichever is greater which depends on n, k\\n\\t- if k = 1 -> O(n C k) -> evaluates to -> O(n) < O(nlogn) asymptotically\\n\\t- if k >= 2 -> O(n C k) > O(nlogn)\\n\\t- see attachment\\n\\t\\t-![image](https://assets.leetcode.com/users/images/4ad4372a-7929-4a15-b764-4f5a9a57c981_1629291386.2069864.png)\\n\\n\\n```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo[::])\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]: # ---- NOTE [1] \\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tcombo.append(candidates[i])\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], combo) # [2] i+1 cuz each item only once\\n\\t\\t\\t\\tcombo.pop()\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# eliminates duplicates - basically comparing each adj integers and eliminate branch if they are equal\\n\\t# - after sorting (simialr to the idea of 47. Permutations II)\\n```        \\n\\n----------------------------------\\n[2] Recursive without backtracking\\n----------------------------------\\n----------------------------------\\n```  \\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tnewCombo = combo + [candidates[i]]\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], newCombo)\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n```\\n-------------\\n[3] Iterative\\n-------------\\n-------------\\n\\n```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tstack = [(0, 0, [])] # start, comboSum, combo\\n\\tres = []\\n\\tcandidates.sort()\\n\\twhile stack:\\n\\t\\tstart, comboSum, combo = stack.pop()\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif comboSum + candidates[i] <= target:\\n\\t\\t\\t\\tnewCombo = combo+[candidates[i]]\\n\\t\\t\\t\\tstack.append((i+1, comboSum+candidates[i], newCombo))\\n\\treturn res     \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo[::])\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]: # ---- NOTE [1] \\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tcombo.append(candidates[i])\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], combo) # [2] i+1 cuz each item only once\\n\\t\\t\\t\\tcombo.pop()\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# eliminates duplicates - basically comparing each adj integers and eliminate branch if they are equal\\n\\t# - after sorting (simialr to the idea of 47. Permutations II)\\n```\n```  \\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tnewCombo = combo + [candidates[i]]\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], newCombo)\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n```\n```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tstack = [(0, 0, [])] # start, comboSum, combo\\n\\tres = []\\n\\tcandidates.sort()\\n\\twhile stack:\\n\\t\\tstart, comboSum, combo = stack.pop()\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif comboSum + candidates[i] <= target:\\n\\t\\t\\t\\tnewCombo = combo+[candidates[i]]\\n\\t\\t\\t\\tstack.append((i+1, comboSum+candidates[i], newCombo))\\n\\treturn res     \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1311156,
                "title": "c-simple-solution-backtracking-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void makesum(vector<int>& v,int tar,int ssf,vector<int> &temp,int idx){\\n        if(ssf>tar){\\n            return;\\n        }\\n        if(ssf==tar){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<v.size();i++){\\n            if(i>idx && v[i]==v[i-1]) continue;\\n            temp.push_back(v[i]);\\n            makesum(v,tar,ssf+v[i],temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        makesum(candidates,target,0,temp,0);\\n        return ans;\\n    }\\n};\\n```\\n\\nEither we can use ``` set<vector<int>> s``` instead of global 2-D vector and store all possible combination and then return them after storing in 2-D vector but that increases the space as well as time complexity . Hence we can just use one 2-D array and control our checks for duplicate elements in given array by this ``` if(i>idx && v[i]==v[i-1]) continue ``` .\\n\\nHope you liked the solution !!!",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void makesum(vector<int>& v,int tar,int ssf,vector<int> &temp,int idx){\\n        if(ssf>tar){\\n            return;\\n        }\\n        if(ssf==tar){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<v.size();i++){\\n            if(i>idx && v[i]==v[i-1]) continue;\\n            temp.push_back(v[i]);\\n            makesum(v,tar,ssf+v[i],temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        makesum(candidates,target,0,temp,0);\\n        return ans;\\n    }\\n};\\n```\n``` set<vector<int>> s```\n``` if(i>idx && v[i]==v[i-1]) continue ```",
                "codeTag": "Java"
            },
            {
                "id": 586217,
                "title": "c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/59bd115a-85b7-40fe-b8be-a4a54d4280bc_1623909837.0499973.png)\\n```\\npublic class Solution {\\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\\n      \\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(candidates);\\n        Backtracking(candidates, target, 0, new List<int>(), res);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] candidates, int target, int start, List<int> list, List<IList<int>> res)\\n    {\\n        if(target < 0)\\n            return;\\n        else if(target == 0)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = start; i < candidates.Length; i++)\\n            {\\n                if(i > start && candidates[i] == candidates[i - 1])\\n                    continue;\\n                \\n                list.Add(candidates[i]);\\n                Backtracking(candidates, target - candidates[i], i + 1, list, res);\\n                list.RemoveAt(list.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\\n      \\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(candidates);\\n        Backtracking(candidates, target, 0, new List<int>(), res);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] candidates, int target, int start, List<int> list, List<IList<int>> res)\\n    {\\n        if(target < 0)\\n            return;\\n        else if(target == 0)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = start; i < candidates.Length; i++)\\n            {\\n                if(i > start && candidates[i] == candidates[i - 1])\\n                    continue;\\n                \\n                list.Add(candidates[i]);\\n                Backtracking(candidates, target - candidates[i], i + 1, list, res);\\n                list.RemoveAt(list.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308045,
                "title": "heavily-commented-backtracking-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n       // console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                // increase i with 1 in the next round as we\\'re not allowed to reuse\\n                find(t - candidates[i], [...p, candidates[i]], i + 1)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 \\n                // further, because of the 2nd check of the while loop condition.\\n                i++;\\n                // extra increase in case we\\'re dealing with dupes. No new path should start with the one\\n                // we just picked off below\\n                while (candidates[i - 1] === candidates[i]) {\\n                    i++;\\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n       // console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                // increase i with 1 in the next round as we\\'re not allowed to reuse\\n                find(t - candidates[i], [...p, candidates[i]], i + 1)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 \\n                // further, because of the 2nd check of the while loop condition.\\n                i++;\\n                // extra increase in case we\\'re dealing with dupes. No new path should start with the one\\n                // we just picked off below\\n                while (candidates[i - 1] === candidates[i]) {\\n                    i++;\\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 307734,
                "title": "c-dp",
                "content": "```\\n//Motivation: such a DP solution feels possible, but turns out you have to be careful to get it working just right\\n//O(exp) time and memory unavoidable due to nature of the problem: asking for a list of all combinations\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(const vector<int> &candidates,const int target){\\n    \\tmap<int,int> Numbers;\\n    \\tfor(const int i:candidates){\\n    \\t\\t++Numbers[i];//The purpose of regrouping duplicate elements is explained in the innermost loop\\n    \\t}\\n        vector<vector<vector<int>>> Ways(target+1);// Ways of forming the numbers 0,1,2,3...\\n        Ways[0].resize(1);//1 way to obtain 0: vector<int>{}\\n        for(const pair<int,int> &p:Numbers){\\n        \\tconst int n{p.first};\\n        \\tfor(int partial{target-n};partial>=0;--partial){//This loop must be reversed because we can only use each number once\\n                //In the inner loop we modify Ways[idx] with idx>partial\\n                //Example: If we iterate partial:0->target with n=1 we would add {1} to Ways[1], then we would add {1,1} to Ways[2] in the next iteration of the loop etc...\\n    \\t\\t\\tfor(vector<int> V:Ways[partial]){\\n    \\t\\t\\t\\tint sum{partial};\\n    \\t\\t\\t\\tfor(int i=0;i<p.second && sum<=target-n;++i){//We have to handle duplicate numbers in this way to avoid creating duplicate combinations\\n                        //Example: [10,1,2,7,6,1,5] 8\\n                        //If we had not regrouped the two 1s we would have created a {1,7} and a {7,1}\\n                        //Maybe we could sort the numbers first?\\n                        //[1,1,2,5,6,7,10] 8\\n                        //Just creates {1,7} and {1,7}. Does not solve the problem\\n                        //Maybe there is another way of dealing with this without the map?\\n    \\t\\t\\t\\t\\tsum+=n;\\n    \\t\\t\\t\\t\\tV.push_back(n);\\n        \\t\\t\\t\\tWays[sum].push_back(V);\\n    \\t\\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return Ways[target];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Motivation: such a DP solution feels possible, but turns out you have to be careful to get it working just right\\n//O(exp) time and memory unavoidable due to nature of the problem: asking for a list of all combinations\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(const vector<int> &candidates,const int target){\\n    \\tmap<int,int> Numbers;\\n    \\tfor(const int i:candidates){\\n    \\t\\t++Numbers[i];//The purpose of regrouping duplicate elements is explained in the innermost loop\\n    \\t}\\n        vector<vector<vector<int>>> Ways(target+1);// Ways of forming the numbers 0,1,2,3...\\n        Ways[0].resize(1);//1 way to obtain 0: vector<int>{}\\n        for(const pair<int,int> &p:Numbers){\\n        \\tconst int n{p.first};\\n        \\tfor(int partial{target-n};partial>=0;--partial){//This loop must be reversed because we can only use each number once\\n                //In the inner loop we modify Ways[idx] with idx>partial\\n                //Example: If we iterate partial:0->target with n=1 we would add {1} to Ways[1], then we would add {1,1} to Ways[2] in the next iteration of the loop etc...\\n    \\t\\t\\tfor(vector<int> V:Ways[partial]){\\n    \\t\\t\\t\\tint sum{partial};\\n    \\t\\t\\t\\tfor(int i=0;i<p.second && sum<=target-n;++i){//We have to handle duplicate numbers in this way to avoid creating duplicate combinations\\n                        //Example: [10,1,2,7,6,1,5] 8\\n                        //If we had not regrouped the two 1s we would have created a {1,7} and a {7,1}\\n                        //Maybe we could sort the numbers first?\\n                        //[1,1,2,5,6,7,10] 8\\n                        //Just creates {1,7} and {1,7}. Does not solve the problem\\n                        //Maybe there is another way of dealing with this without the map?\\n    \\t\\t\\t\\t\\tsum+=n;\\n    \\t\\t\\t\\t\\tV.push_back(n);\\n        \\t\\t\\t\\tWays[sum].push_back(V);\\n    \\t\\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return Ways[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961165,
                "title": "most-optimal-solution-using-advanced-backtracking-and-recursion-beats-100-solution-explained",
                "content": "\\n# Approach\\n- The `findAns` function is a recursive helper function that takes an index, the remaining target value, the candidates array, the answer vector (`ans`), and the current helper vector (`helper`).\\n\\n- The base case of the recursion is when the target value becomes 0. This means a valid combination has been found, so the current helper vector is added to the answer vector.\\n\\n- Within the recursive function, a loop iterates through the candidates starting from the current index. For each candidate, the following conditions are checked:\\n    - If the current candidate is the same as the previous candidate, it\\'s skipped to avoid duplicate combinations.\\n    - If the current candidate is greater than the remaining target, it\\'s not feasible to include it, so the loop breaks.\\n    - Otherwise, the current candidate is included in the helper vector, and the recursive call is made with the next index and the updated target value.\\n\\n- After the loop, the current candidate is removed from the helper vector (backtracking).\\n\\n- The `combinationSum2` function first sorts the candidates array. This sorting helps in efficiently avoiding duplicate combinations and breaking out of the loop early when candidates exceed the target.\\n\\n- The `ans`vector containing all valid unique combinations is returned.\\n\\n# Complexity\\n- Time complexity:\\nO((2^n)*k)\\n\\n- Space complexity:\\nO(k*x)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    void findAns(int index, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& helper) {\\n        if(target == 0) {\\n            ans.push_back(helper);\\n            return;\\n        }\\n        for(int i = index; i < arr.size(); i++) {\\n            if(i > index && arr[i] ==arr[i-1]) continue;\\n            if(arr[i] > target) break;\\n            helper.push_back(arr[i]);\\n            findAns(i+1, target-arr[i], arr, ans, helper);\\n            helper.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> helper;\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> helper = new ArrayList<>();\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n    \\n    private void findAns(int index, int target, int[] arr, List<List<Integer>> ans, List<Integer> helper) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(helper));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            helper.add(arr[i]);\\n            findAns(i + 1, target - arr[i], arr, ans, helper);\\n            helper.remove(helper.size() - 1);\\n        }\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        ans = []\\n        helper = []\\n        self.findAns(0, target, candidates, ans, helper)\\n        return ans\\n    \\n    def findAns(self, index, target, arr, ans, helper):\\n        if target == 0:\\n            ans.append(helper[:])\\n            return\\n        \\n        for i in range(index, len(arr)):\\n            if i > index and arr[i] == arr[i - 1]:\\n                continue\\n            if arr[i] > target:\\n                break\\n            helper.append(arr[i])\\n            self.findAns(i + 1, target - arr[i], arr, ans, helper)\\n            helper.pop()\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void findAns(int index, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& helper) {\\n        if(target == 0) {\\n            ans.push_back(helper);\\n            return;\\n        }\\n        for(int i = index; i < arr.size(); i++) {\\n            if(i > index && arr[i] ==arr[i-1]) continue;\\n            if(arr[i] > target) break;\\n            helper.push_back(arr[i]);\\n            findAns(i+1, target-arr[i], arr, ans, helper);\\n            helper.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> helper;\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> helper = new ArrayList<>();\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n    \\n    private void findAns(int index, int target, int[] arr, List<List<Integer>> ans, List<Integer> helper) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(helper));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            helper.add(arr[i]);\\n            findAns(i + 1, target - arr[i], arr, ans, helper);\\n            helper.remove(helper.size() - 1);\\n        }\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        ans = []\\n        helper = []\\n        self.findAns(0, target, candidates, ans, helper)\\n        return ans\\n    \\n    def findAns(self, index, target, arr, ans, helper):\\n        if target == 0:\\n            ans.append(helper[:])\\n            return\\n        \\n        for i in range(index, len(arr)):\\n            if i > index and arr[i] == arr[i - 1]:\\n                continue\\n            if arr[i] > target:\\n                break\\n            helper.append(arr[i])\\n            self.findAns(i + 1, target - arr[i], arr, ans, helper)\\n            helper.pop()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478784,
                "title": "c-recursive-backtracking-solution-easy-to-understand-100-beats",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO( 2^n *k )\\n\\n- Space complexity:\\nO( k*X )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n\\n      if(target==0){\\n        ans.push_back(ds);\\n        return;\\n      }\\n      for(int i=ind; i<arr.size();i++){\\n\\n      if(i>ind && arr[i]==arr[i-1]) continue;\\n\\n        if(arr[i]>target) break;\\n\\n            ds.push_back(arr[i]);\\n            findCombination(i+1,target-arr[i],arr,ans,ds);\\n            ds.pop_back();\\n    }\\n}\\npublic:\\n   vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n\\n      if(target==0){\\n        ans.push_back(ds);\\n        return;\\n      }\\n      for(int i=ind; i<arr.size();i++){\\n\\n      if(i>ind && arr[i]==arr[i-1]) continue;\\n\\n        if(arr[i]>target) break;\\n\\n            ds.push_back(arr[i]);\\n            findCombination(i+1,target-arr[i],arr,ans,ds);\\n            ds.pop_back();\\n    }\\n}\\npublic:\\n   vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458185,
                "title": "100-faster-java-solution-recursion-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(2^N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/710511bf-1194-487d-b905-ad6599403eb4_1682528664.190133.png)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private void findCombinations(int ind,int[] arr, int target, List<List<Integer>> ans,List<Integer>ds){\\n\\n        //base case \\n        if(target == 0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        //start from ind\\n        for(int i = ind; i < arr.length;i++){\\n\\n            \\n            //check if two consecutive element are same then we will not take that combination\\n            if(i > ind && arr[i-1] == arr[i]){\\n                continue;\\n            }\\n            \\n            //if arr[i] is greater than target means if this element is grater than target then we can not the element present further \\n            if(arr[i] > target){\\n                break;\\n            }\\n\\n\\n            //add that element in ds\\n            ds.add(arr[i]);\\n\\n            //make a recursive call on the next element\\n            findCombinations(i+1,arr,target-arr[i],ans,ds);\\n\\n            //after recursive call has completed then remove that element from ds\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    private void findCombinations(int ind,int[] arr, int target, List<List<Integer>> ans,List<Integer>ds){\\n\\n        //base case \\n        if(target == 0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        //start from ind\\n        for(int i = ind; i < arr.length;i++){\\n\\n            \\n            //check if two consecutive element are same then we will not take that combination\\n            if(i > ind && arr[i-1] == arr[i]){\\n                continue;\\n            }\\n            \\n            //if arr[i] is greater than target means if this element is grater than target then we can not the element present further \\n            if(arr[i] > target){\\n                break;\\n            }\\n\\n\\n            //add that element in ds\\n            ds.add(arr[i]);\\n\\n            //make a recursive call on the next element\\n            findCombinations(i+1,arr,target-arr[i],ans,ds);\\n\\n            //after recursive call has completed then remove that element from ds\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092296,
                "title": "99-fast-javascript-solution-very-easy-to-understand-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/9AYldOQFJfk\\n\\n![image.png](https://assets.leetcode.com/users/images/cfa25008-9a12-4b79-ac71-ba7810d76d0b_1674525474.7510023.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(c, target) {\\n    c.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (index,sum,temp) =>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push(temp)\\n            return;\\n        }\\n        // 1 1 2 5 6 7 10 \\n        for(let i =index; i<c.length;i++){\\n            if(i != index && c[i] == c[i-1]) continue;\\n            iterate(i+1,sum+c[i],[...temp,c[i]])\\n        }\\n    }\\n    iterate(0,0,[])\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(c, target) {\\n    c.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (index,sum,temp) =>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push(temp)\\n            return;\\n        }\\n        // 1 1 2 5 6 7 10 \\n        for(let i =index; i<c.length;i++){\\n            if(i != index && c[i] == c[i-1]) continue;\\n            iterate(i+1,sum+c[i],[...temp,c[i]])\\n        }\\n    }\\n    iterate(0,0,[])\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703414,
                "title": "c-backtrack-easy-and-fast-solution",
                "content": "**please upvote if it\\'s helpful**\\n```\\nclass Solution {\\n\\n    void solve(int ind,int target,vector<int>& ar,vector<int>& temp,vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=ind;i<ar.size();i++){\\n            if(i>ind && ar[i]==ar[i-1]) continue;\\n            if(ar[i]>target) break;\\n            temp.push_back(ar[i]);\\n            solve(i+1,target-ar[i],ar,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    public:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(0,target,candidates,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    void solve(int ind,int target,vector<int>& ar,vector<int>& temp,vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=ind;i<ar.size();i++){\\n            if(i>ind && ar[i]==ar[i-1]) continue;\\n            if(ar[i]>target) break;\\n            temp.push_back(ar[i]);\\n            solve(i+1,target-ar[i],ar,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    public:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(0,target,candidates,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808881,
                "title": "in-depth-explaination-with-comments",
                "content": "Explaination with comments\\n\\nclass Solution {\\npublic:\\n    \\n    void findCombinations(int ind,int n,vector<int>& candidates,vector<int>v,vector<vector<int>>&ans,int target)\\n    {\\n        if(ind>=n || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                ans.push_back(v);\\n            }\\n            return;\\n        }\\n        \\n        for(int i = ind;i<n;i++)\\n        {\\n            // here i > ind and not i-1>=0 ? because we could chose the same no. twice\\n            // if it occurs twice in the array and if it\\'s chosen for a different position\\n            // eg. {1,1,2} if target == 4 \\n            if(i > ind && candidates[i-1] == candidates[i])\\n            {\\n                continue;\\n            }\\n            \\n            // because array is sorted and all numbers ahead of candidates[i] will anyway\\n            // be > target\\n            if(candidates[i] > target)\\n            {\\n                break;\\n            }\\n            \\n            v.push_back(candidates[i]);\\n            findCombinations(i+1,n,candidates,v,ans,target-candidates[i]);\\n            v.pop_back();\\n\\t\\t\\t// v.pop_back() is necessary because of ?\\n\\t\\t\\t// when this option backtrack to here, remove this and go on to the next option\\n            // so after we\\'ve completed this call and processed it\\'s result at base case\\n            // we don\\'t wanna let current vector interfere with next \"fresh\" function call\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        \\n        sort(candidates.begin(),candidates.end());\\n        // sorting the input array is necessary to gather all the duplicates together \\n        // so that it becomes easy to avoid duplicate values taken for the ith number\\n        // for eg. 1st no. is chosen as 1 then it can\\'t be chosen as 1st no. again,\\n        \\n        // though it can be chosen as 2nd no. explained at line 17\\n        \\n        vector<int>v;\\n        vector<vector<int>>ans;\\n        \\n        findCombinations(0,n,candidates,v,ans,target);\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void findCombinations(int ind,int n,vector<int>& candidates,vector<int>v,vector<vector<int>>&ans,int target)\\n    {\\n        if(ind>=n || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                ans.push_back(v);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1769816,
                "title": "without-loop-combination-sum-2-easy-c-similar-to-combination-1-subset-2-problems",
                "content": "```\\n void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(pSol);\\n            return;\\n        }\\n        \\n        if(next == num.size() || target - num[next] < 0)\\n            return;\\n            \\n        pSol.push_back(num[next]);\\n        search(num, next+1, pSol, target - num[next], result);\\n        pSol.pop_back();\\n        while(next < num.size()-1 && num[next] == num[next+1])\\n            next++;\\n        search(num, next + 1, pSol, target, result);\\n    }\\n\\n    \\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n    {\\n        vector<vector<int> > result;\\n        sort(num.begin(), num.end());\\n        vector<int> pSol;\\n        search(num, 0, pSol, target, result);\\n        return result;    \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(pSol);\\n            return;\\n        }\\n        \\n        if(next == num.size() || target - num[next] < 0)\\n            return;\\n            \\n        pSol.push_back(num[next]);\\n        search(num, next+1, pSol, target - num[next], result);\\n        pSol.pop_back();\\n        while(next < num.size()-1 && num[next] == num[next+1])\\n            next++;\\n        search(num, next + 1, pSol, target, result);\\n    }\\n\\n    \\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n    {\\n        vector<vector<int> > result;\\n        sort(num.begin(), num.end());\\n        vector<int> pSol;\\n        search(num, 0, pSol, target, result);\\n        return result;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 680167,
                "title": "c-simple-recursive-solution-for-beginners",
                "content": "A simple C++ approach using recursion for beginners:\\n\\n```\\nvector<vector<int>> ans;\\n\\nvoid solve(vector<int> v, int target, vector<int> temp, int src) {\\n\\n\\tif(src>v.size() || target<0) return; \\n\\tif(!target) {ans.push_back(temp); return;}\\n\\n\\tfor(int i=src; i<v.size(); i++) {\\n\\t\\tif(i>src && v[i]==v[i-1]) continue; //Ignore duplicates\\n\\t\\t\\n\\t\\t//Backtracking:\\n\\t\\ttemp.push_back(v[i]);\\n\\t\\tsolve(v, target-v[i], temp, i+1);\\n\\t\\ttemp.pop_back();   \\n\\t}\\n\\n\\treturn;\\n}\\n\\n//Driver function\\nvector<vector<int>> combinationSum2(vector<int> v, int target) {  \\n\\tint n=v.size(); if(!n) return ans;\\n\\tsort(v.begin(), v.end());\\n\\tvector<int> temp;\\n\\tsolve(v, target, temp, 0);\\n\\n\\treturn ans;\\n}\\n```\\n\\nAnd if you still want to improve this solution, read [this improvement.](https://leetcode.com/problems/combination-sum-ii/discuss/16884/a-smaller-trick-to-improve-a-lot-(beat-92.35))",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> ans;\\n\\nvoid solve(vector<int> v, int target, vector<int> temp, int src) {\\n\\n\\tif(src>v.size() || target<0) return; \\n\\tif(!target) {ans.push_back(temp); return;}\\n\\n\\tfor(int i=src; i<v.size(); i++) {\\n\\t\\tif(i>src && v[i]==v[i-1]) continue; //Ignore duplicates\\n\\t\\t\\n\\t\\t//Backtracking:\\n\\t\\ttemp.push_back(v[i]);\\n\\t\\tsolve(v, target-v[i], temp, i+1);\\n\\t\\ttemp.pop_back();   \\n\\t}\\n\\n\\treturn;\\n}\\n\\n//Driver function\\nvector<vector<int>> combinationSum2(vector<int> v, int target) {  \\n\\tint n=v.size(); if(!n) return ans;\\n\\tsort(v.begin(), v.end());\\n\\tvector<int> temp;\\n\\tsolve(v, target, temp, 0);\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169640,
                "title": "easy-to-understand-python-dp-solution-with-comparison-to-combination-sum-i",
                "content": "Difference of DP solution between Combination Sum and Combination Sum II.\\n1. `reversed(range(len(dp)))`: we want to avoid using the same candidate multiple times. That is, say we have `subtarget0`, `subtarget1`, `subtarget2` and `subtarget1 = subtarget0 + candidate_i` and `subtarget2 = subtarget1 + candidate_i`. If we do not use `reversed()`, we will first build `subtarget1` then in the same iteration we build `subtarget2`. In other words, without iterating the dp in reversed direction, we would use the same candidate `candidate_i` twice.\\n2. `set` to store the sub-results. The reason we use set is to ensure unique combination since **there are duplicates in candidates in Combination Sum II**. \\n\\nCombination Sum I solution:\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0].append([]) # when target is 0, there is no combination\\n        for c in candidates:\\n            for subtarget in range(len(dp)):\\n                if dp[subtarget]:\\n                    new_combo = [combo + [c] for combo in dp[subtarget]]\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c].extend(new_combo)\\n                    else:\\n                        break\\n        return dp[target]\\n```\\n\\nCombination Sum II solution:\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in reversed(range(len(dp))):\\n                if dp[subtarget]:\\n                    new_combo = set([combo + (c, ) for combo in dp[subtarget]])\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c] = dp[subtarget + c].union(new_combo)\\n        return list(map(list, dp[target]))\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0].append([]) # when target is 0, there is no combination\\n        for c in candidates:\\n            for subtarget in range(len(dp)):\\n                if dp[subtarget]:\\n                    new_combo = [combo + [c] for combo in dp[subtarget]]\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c].extend(new_combo)\\n                    else:\\n                        break\\n        return dp[target]\\n```\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in reversed(range(len(dp))):\\n                if dp[subtarget]:\\n                    new_combo = set([combo + (c, ) for combo in dp[subtarget]])\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c] = dp[subtarget + c].union(new_combo)\\n        return list(map(list, dp[target]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16955,
                "title": "javascript-solution-with-dfs",
                "content": "    function combinationSum2(candidates, target) {\\n        var res = []; // [][]\\n        var prefix = [];\\n    \\n        candidates.sort((a, b) => a - b);\\n        search(0, target);\\n        return res;\\n    \\n        function search(idx, rest) {\\n            if (rest === 0 && idx === candidates.length) {\\n                return res.push(prefix.slice());\\n            }\\n    \\n            if (rest < 0 || idx === candidates.length) {\\n              return;\\n            }\\n    \\n            // include number at idx\\n            prefix.push(candidates[idx]);\\n            search(idx + 1, rest - candidates[idx]);\\n            \\n            // exclude number at idx\\n            // eg. [1, 1, 1]\\n            // allow \\n            // [1, 1, 1]\\n            // [X, 1, 1]\\n            // [X, X, 1]\\n            // [X, X, X]\\n            // disallow\\n            // [1, 1, X]\\n            // [1, X, X]\\n            prefix.pop();\\n            if (prefix[prefix.length - 1] !== candidates[idx]) {\\n                search(idx + 1, rest);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "    function combinationSum2(candidates, target) {\\n        var res = []; // [][]\\n        var prefix = [];\\n    \\n        candidates.sort((a, b) => a - b);\\n        search(0, target);\\n        return res;\\n    \\n        function search(idx, rest) {\\n            if (rest === 0 && idx === candidates.length) {\\n                return res.push(prefix.slice());\\n            }\\n    \\n            if (rest < 0 || idx === candidates.length) {\\n              return;\\n            }\\n    \\n            // include number at idx\\n            prefix.push(candidates[idx]);\\n            search(idx + 1, rest - candidates[idx]);\\n            \\n            // exclude number at idx\\n            // eg. [1, 1, 1]\\n            // allow \\n            // [1, 1, 1]\\n            // [X, 1, 1]\\n            // [X, X, 1]\\n            // [X, X, X]\\n            // disallow\\n            // [1, 1, X]\\n            // [1, X, X]\\n            prefix.pop();\\n            if (prefix[prefix.length - 1] !== candidates[idx]) {\\n                search(idx + 1, rest);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17023,
                "title": "my-solution-without-using-set",
                "content": "My idea is skip same number during recursion. Like Permutations II. Firstly sort num, then search from back for numbers sum to target.\\n\\n\\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n        vector<vector<int>> res;\\n        sort(num.begin(), num.end());\\n        vector<int> cur;\\n        find(num, target, num.size() - 1, res, cur);\\n        return res;\\n    }\\n    \\n    void find(vector<int> &num, int target, int end, vector<vector<int>>& res, vector<int>& cur)\\n    {\\n        if (target == 0)\\n        {\\n            res.push_back(cur);\\n            return;\\n        }\\n        if (end < 0 || num[end] * (end + 1) < target) \\n            return;\\n        \\n        if (num[end] <= target)\\n        {\\n            cur.insert(cur.begin(), num[end]);\\n            find(num, target - num[end], end - 1, res, cur);\\n            cur.erase(cur.begin());\\n        }\\n        //find combinations ends at the first number different from num[end]\\n        int temp = num[end];\\n        while (end >= 0 && num[end] == temp) end--;\\n        find(num, target, end, res, cur);\\n    }",
                "solutionTags": [],
                "code": "My idea is skip same number during recursion. Like Permutations II. Firstly sort num, then search from back for numbers sum to target.\\n\\n\\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n        vector<vector<int>> res;\\n        sort(num.begin(), num.end());\\n        vector<int> cur;\\n        find(num, target, num.size() - 1, res, cur);\\n        return res;\\n    }\\n    \\n    void find(vector<int> &num, int target, int end, vector<vector<int>>& res, vector<int>& cur)\\n    {\\n        if (target == 0)\\n        {\\n            res.push_back(cur);\\n            return;\\n        }\\n        if (end < 0 || num[end] * (end + 1) < target) \\n            return;\\n        \\n        if (num[end] <= target)\\n        {\\n            cur.insert(cur.begin(), num[end]);\\n            find(num, target - num[end], end - 1, res, cur);\\n            cur.erase(cur.begin());\\n        }\\n        //find combinations ends at the first number different from num[end]\\n        int temp = num[end];\\n        while (end >= 0 && num[end] == temp) end--;\\n        find(num, target, end, res, cur);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4013220,
                "title": "cpp-solution-with-explanation-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;  // Store the final result, which will be unique combinations that sum up to the target.\\n        vector<int> t;  // Temporary vector to store a single combination.\\n        sort(candidates.begin(), candidates.end());  // Sort the candidates in ascending order to handle duplicates.\\n\\n        // Start the recursive process to find combinations.\\n        combinationSumRec(candidates, target, 0, result, t);\\n\\n        return result;  // Return the list of unique combinations.\\n    }\\n\\n    // Recursive function to find combinations.\\n    void combinationSumRec(vector<int>& candidates, int target, int begin, vector<vector<int>>& result, vector<int>& t) {\\n        if (target == 0) {  // If the target sum is reached, add the current combination to the result.\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        int x = begin;  // Store the current position in the candidates array.\\n\\n        while (begin < candidates.size() && target - candidates[begin] >= 0) {\\n            // Check for duplicates and skip them to avoid duplicate combinations.\\n            if (begin > x && candidates[begin] == candidates[begin - 1]) {\\n                begin++;\\n                continue;\\n            }\\n\\n            t.push_back(candidates[begin]);  // Add the current candidate to the combination.\\n            \\n            // Recursively call with the updated target and move to the next candidate.\\n            combinationSumRec(candidates, target - candidates[begin], begin + 1, result, t);\\n            \\n            t.pop_back();  // Remove the last added candidate to backtrack and explore other combinations.\\n            begin++;  // Move to the next candidate.\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;  // Store the final result, which will be unique combinations that sum up to the target.\\n        vector<int> t;  // Temporary vector to store a single combination.\\n        sort(candidates.begin(), candidates.end());  // Sort the candidates in ascending order to handle duplicates.\\n\\n        // Start the recursive process to find combinations.\\n        combinationSumRec(candidates, target, 0, result, t);\\n\\n        return result;  // Return the list of unique combinations.\\n    }\\n\\n    // Recursive function to find combinations.\\n    void combinationSumRec(vector<int>& candidates, int target, int begin, vector<vector<int>>& result, vector<int>& t) {\\n        if (target == 0) {  // If the target sum is reached, add the current combination to the result.\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        int x = begin;  // Store the current position in the candidates array.\\n\\n        while (begin < candidates.size() && target - candidates[begin] >= 0) {\\n            // Check for duplicates and skip them to avoid duplicate combinations.\\n            if (begin > x && candidates[begin] == candidates[begin - 1]) {\\n                begin++;\\n                continue;\\n            }\\n\\n            t.push_back(candidates[begin]);  // Add the current candidate to the combination.\\n            \\n            // Recursively call with the updated target and move to the next candidate.\\n            combinationSumRec(candidates, target - candidates[begin], begin + 1, result, t);\\n            \\n            t.pop_back();  // Remove the last added candidate to backtrack and explore other combinations.\\n            begin++;  // Move to the next candidate.\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599114,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$Exponential$$\\n\\n- Space complexity:\\n$$Exponential$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (sum == target) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx &&  candidates[i] == candidates[i-1])\\n                continue;\\n            if (sum + candidates[i] > target)\\n                break;    \\n            sum += candidates[i];\\n            temp.push_back(candidates[i]);\\n            helper(i+1, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[i];\\n            temp.pop_back();    \\n        } \\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (sum == target) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx &&  candidates[i] == candidates[i-1])\\n                continue;\\n            if (sum + candidates[i] > target)\\n                break;    \\n            sum += candidates[i];\\n            temp.push_back(candidates[i]);\\n            helper(i+1, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[i];\\n            temp.pop_back();    \\n        } \\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310668,
                "title": "c-fast-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first things that came to mid seeing this problem was a recursive approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust go to every possible candiates check its credibility and check again from the next candiate by deleting the duplicate elemnts after a same element has been visited.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2) because we have to store the answer for final submission.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> vec;\\nvector <vector<int>> ans;\\nvoid func(int n, vector<int>& v,int i)\\n{\\n    if(n<0) return ;\\n    if(n==0)\\n    {\\n      ans.push_back(vec);\\n        return ; \\n    } \\n   for (int j = i; j < v.size(); j++) {\\n    if (n - v[j] < 0) break;  // check if index j is within bounds of v\\n    vec.push_back(v[j]);\\n    func(n - v[j], v, j + 1);\\n    vec.pop_back();\\n    while (j + 1 < v.size() && v[j] == v[j + 1]) j++; // skip duplicates\\n}\\n\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n     \\n     sort(candidates.begin(),candidates.end());\\nfunc(target,candidates,0);\\n\\n       \\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<int> vec;\\nvector <vector<int>> ans;\\nvoid func(int n, vector<int>& v,int i)\\n{\\n    if(n<0) return ;\\n    if(n==0)\\n    {\\n      ans.push_back(vec);\\n        return ; \\n    } \\n   for (int j = i; j < v.size(); j++) {\\n    if (n - v[j] < 0) break;  // check if index j is within bounds of v\\n    vec.push_back(v[j]);\\n    func(n - v[j], v, j + 1);\\n    vec.pop_back();\\n    while (j + 1 < v.size() && v[j] == v[j + 1]) j++; // skip duplicates\\n}\\n\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n     \\n     sort(candidates.begin(),candidates.end());\\nfunc(target,candidates,0);\\n\\n       \\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125993,
                "title": "simple-back-tracking-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        printSum(0, candidates, target, ans, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void printSum(int index, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            \\n            ds.add(arr[i]);\\n            printSum(i + 1, arr, target - arr[i], ans, ds);\\n            ds.remove(ds.size() - 1);\\n        }\\n    }\\n}\\n// If you find this helpful, please upvote.\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        printSum(0, candidates, target, ans, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void printSum(int index, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            \\n            ds.add(arr[i]);\\n            printSum(i + 1, arr, target - arr[i], ans, ds);\\n            ds.remove(ds.size() - 1);\\n        }\\n    }\\n}\\n// If you find this helpful, please upvote.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103327,
                "title": "c-easy-backtraking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(vector<int>& cand, int sum, int start, vector<int> v){\\n        if(sum < 0){    // if sum < 0 solution is not found.\\n            return;\\n        }\\n        else if(sum == 0){  // if sum == 0 it means we have found a solution.\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=start;i<cand.size();i++){\\n            if(i > start && cand[i] == cand[i-1]){  // To avoid duplicates.\\n                continue;\\n            }\\n            if(sum-cand[i] < 0) {   // No point of searching further if sum-cand[i] < 0.\\n                break;\\n            }\\n            // Backtracking\\n            v.push_back(cand[i]);\\n            solve(cand,sum-cand[i],i+1,v);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& cand, int target) {\\n        sort(cand.begin(), cand.end());\\n        vector<int> v;\\n        solve(cand, target, 0, v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(vector<int>& cand, int sum, int start, vector<int> v){\\n        if(sum < 0){    // if sum < 0 solution is not found.\\n            return;\\n        }\\n        else if(sum == 0){  // if sum == 0 it means we have found a solution.\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=start;i<cand.size();i++){\\n            if(i > start && cand[i] == cand[i-1]){  // To avoid duplicates.\\n                continue;\\n            }\\n            if(sum-cand[i] < 0) {   // No point of searching further if sum-cand[i] < 0.\\n                break;\\n            }\\n            // Backtracking\\n            v.push_back(cand[i]);\\n            solve(cand,sum-cand[i],i+1,v);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& cand, int target) {\\n        sort(cand.begin(), cand.end());\\n        vector<int> v;\\n        solve(cand, target, 0, v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878112,
                "title": "c-solution-sharing-my-two-solutions-388ms-8ms-subsetsum",
                "content": "**Solution 1: [Accepted]388ms**\\nThis Solution is a variation of Subset Sum, but we want only unique Subset. Therefore, to keep track of that, I use a set of vector type and store them in sorted only. *[Reason for storing  them in sorted only, is beacuse if I have a target=7, and Array=[2,3,2,1,2,2,1] and let\\'s say we got two subset [1,2,2,2] && [2,1,2,2] which is equal to our target, but in this case they are not unique subset. {Unique is when we have the frequencies of any value in a subset , is different from another subset.} But, in this case Frequencies of every value in both subset are same. Therefore, they must be treated as a single subset not two different subset].*  So, if I find a duplicate one, I will not going to push it into  my answer.\\nBelow, is the Code which is just a subset Sum variaton.\\n```\\nclass Solution {\\npublic:\\n    set<vector<int>> s;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        PrintSubset(candidates,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&candidates,int n, int target,vector<vector<int>> &ans,vector<int>temp)\\n    {\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n            if(s.find(temp)==s.end())\\n            {\\n                ans.push_back(temp);\\n                s.insert(temp);\\n            }\\n            return;\\n        }\\n        if(n==0)\\n            return;\\n        if(target<candidates[n-1])\\n            PrintSubset(candidates,n-1,target,ans,temp);\\n        else\\n        {\\n            temp.push_back(candidates[n-1]);\\n            PrintSubset(candidates, n-1, target-candidates[n-1],ans,temp);\\n            temp.pop_back();\\n            PrintSubset(candidates, n-1, target, ans, temp);\\n        }\\n    }\\n};\\n```\\nNow, in above Code we are taking extra space and we always sorting it to so that we can keep only unique subsets in our final answer.\\nWe can modify the above solution, by sorting the candidates at first. Now the duplicates ones are adjacent to each other and we can easily skip that ones which are Duplicates.\\n\\n**Solution #2: [Accepted] 8ms**\\nSort the candidates vector. And Now, when you have encounter a duplicate value, skip that value, because they may form same subset as previous one has formed. So, run a while loop and skip until you find a unique value.\\nNow, we don\\'t need extra space and we don\\'t have to sort again and again. Just a little bit of change, and everything is same as above code.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        PrintSubset(candidates,0,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&C,int index,int n, int target,vector<vector<int>> &ans,vector<int>&temp)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(index>=n)\\n            return;\\n        if(target<0)\\n            return ;\\n        temp.push_back(C[index]);\\n        PrintSubset(C,index+1,n,target-C[index],ans,temp);\\n        while(index<(n-1) && C[index]==C[index+1])\\n            index++;\\n        temp.pop_back();\\n        PrintSubset(C,index+1,n,target,ans,temp);\\n    }\\n};\\n```\\n*And yes, this Q\\'s can also be solved using Backtracking. Many users has posted brilliant backtracking solutions, you can check that also.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<vector<int>> s;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        PrintSubset(candidates,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&candidates,int n, int target,vector<vector<int>> &ans,vector<int>temp)\\n    {\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n            if(s.find(temp)==s.end())\\n            {\\n                ans.push_back(temp);\\n                s.insert(temp);\\n            }\\n            return;\\n        }\\n        if(n==0)\\n            return;\\n        if(target<candidates[n-1])\\n            PrintSubset(candidates,n-1,target,ans,temp);\\n        else\\n        {\\n            temp.push_back(candidates[n-1]);\\n            PrintSubset(candidates, n-1, target-candidates[n-1],ans,temp);\\n            temp.pop_back();\\n            PrintSubset(candidates, n-1, target, ans, temp);\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        PrintSubset(candidates,0,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&C,int index,int n, int target,vector<vector<int>> &ans,vector<int>&temp)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(index>=n)\\n            return;\\n        if(target<0)\\n            return ;\\n        temp.push_back(C[index]);\\n        PrintSubset(C,index+1,n,target-C[index],ans,temp);\\n        while(index<(n-1) && C[index]==C[index+1])\\n            index++;\\n        temp.pop_back();\\n        PrintSubset(C,index+1,n,target,ans,temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620712,
                "title": "bottom-up-python-solution-beats-98-simple-and-clean",
                "content": "\\n```python\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = collections.defaultdict(set)\\n        candidates.sort()\\n        dp[0].add(())\\n        for n in candidates:\\n            for i in reversed(range(n, target + 1)):\\n                if i >= n:\\n                    for seq in dp[i-n]:\\n                        dp[i].add(seq+(n,))\\n        return dp[target]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = collections.defaultdict(set)\\n        candidates.sort()\\n        dp[0].add(())\\n        for n in candidates:\\n            for i in reversed(range(n, target + 1)):\\n                if i >= n:\\n                    for seq in dp[i-n]:\\n                        dp[i].add(seq+(n,))\\n        return dp[target]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 434253,
                "title": "javascript-easy",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    const result = [];\\n    candidates.sort((b,a) => b - a);\\n    \\n    const helper= (rem, start, current) => {\\n        if(rem < 0) return;\\n        if(rem === 0) {\\n            result.push(current.slice())\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n            current.push(candidates[i])\\n            helper(rem - candidates[i], i + 1, current.slice());\\n            current.pop();\\n        }\\n    }\\n    \\n    helper(target, 0 , []);\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    const result = [];\\n    candidates.sort((b,a) => b - a);\\n    \\n    const helper= (rem, start, current) => {\\n        if(rem < 0) return;\\n        if(rem === 0) {\\n            result.push(current.slice())\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n            current.push(candidates[i])\\n            helper(rem - candidates[i], i + 1, current.slice());\\n            current.pop();\\n        }\\n    }\\n    \\n    helper(target, 0 , []);\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16879,
                "title": "golang-solution-6ms",
                "content": "```c\\nfunc combinationSum2(nums []int, target int) (result [][]int) {\\n    sort.Ints(nums)\\n    combinationSum2Helper(nums, nil, target, 0, 0, &result)\\n    return result\\n}\\n\\nfunc combinationSum2Helper(nums, combo []int, target, sum, startIndex int, result *[][]int) {\\n    if sum == target {\\n        *result = append(*result, append([]int{}, combo...))\\n        return\\n    }\\n    for i := startIndex; i < len(nums) && (sum + nums[i]) <= target; i++ {\\n        if i != startIndex && nums[i] == nums[i - 1] { continue }\\n        combinationSum2Helper(nums, append(combo, nums[i]), target, sum + nums[i], i + 1, result)\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```c\\nfunc combinationSum2(nums []int, target int) (result [][]int) {\\n    sort.Ints(nums)\\n    combinationSum2Helper(nums, nil, target, 0, 0, &result)\\n    return result\\n}\\n\\nfunc combinationSum2Helper(nums, combo []int, target, sum, startIndex int, result *[][]int) {\\n    if sum == target {\\n        *result = append(*result, append([]int{}, combo...))\\n        return\\n    }\\n    for i := startIndex; i < len(nums) && (sum + nums[i]) <= target; i++ {\\n        if i != startIndex && nums[i] == nums[i - 1] { continue }\\n        combinationSum2Helper(nums, append(combo, nums[i]), target, sum + nums[i], i + 1, result)\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16946,
                "title": "c-solution-with-comments-8ms",
                "content": "     void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start) {\\n                       // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                        // we always want to count the first element in this recursive step even if it is the same \\n                        // as one before. To avoid overcounting, we just ignore the duplicates\\n                        // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                        // if current element is bigger than the assigned target, there is \\n                        //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                        //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                        // keep searching for new element with start as `i + 1` because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }",
                "solutionTags": [],
                "code": "     void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start) {\\n                       // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                        // we always want to count the first element in this recursive step even if it is the same \\n                        // as one before. To avoid overcounting, we just ignore the duplicates\\n                        // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                        // if current element is bigger than the assigned target, there is \\n                        //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                        //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                        // keep searching for new element with start as `i + 1` because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 16880,
                "title": "python-dfs-easy-to-understand",
                "content": "    class Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        return self.dfs(candidates,0,[],[],target)\\n    def dfs(self, candidates,start,res,ans,target):\\n        if target<0:\\n            return \\n        if target==0:\\n            res.append(ans)\\n            return\\n        for i in xrange(start,len(candidates)):\\n            if i!=start and candidates[i]==candidates[i-1]:\\n                continue\\n            self.dfs(candidates,i+1,res,ans+[candidates[i]],target-candidates[i])\\n        return res",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        return self.dfs(candidates,0,[],[],target)\\n    def dfs(self, candidates,start,res,ans,target):\\n        if target<0:\\n            return \\n        if target==0:\\n            res.append(ans)\\n            return\\n        for i in xrange(start,len(candidates)):\\n            if i!=start and candidates[i]==candidates[i-1]:\\n                continue\\n            self.dfs(candidates,i+1,res,ans+[candidates[i]],target-candidates[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 16988,
                "title": "5ms-java-solution",
                "content": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<List<Integer>>();    \\n        ch(candidates,target,0,new ArrayList<Integer>(),ans);\\n        return ans;\\n    }\\n    public void ch(int[] candidates,int remain,int rindex,List<Integer> tmp,List<List<Integer>> ans)\\n    {\\n        if(remain==0)\\n        {\\n            List<Integer> a=new ArrayList<Integer>(tmp);\\n            ans.add(a);\\n            return;\\n        }\\n        int entered=0; // get rid of duplicate combinations\\n        for(int i=rindex;i<candidates.length;i++)\\n        {\\n            if(entered!=candidates[i]) // get rid of duplicate combinations\\n            {\\n                if(remain-candidates[i]<0) break; //This line of code can reduce 7ms from execution time!\\n                tmp.add(candidates[i]);\\n                entered=candidates[i];\\n                ch(candidates,remain-candidates[i],i+1,tmp,ans);\\n                tmp.remove(tmp.size()-1); \\n            }   \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<List<Integer>>();    \\n        ch(candidates,target,0,new ArrayList<Integer>(),ans);\\n        return ans;\\n    }\\n    public void ch(int[] candidates,int remain,int rindex,List<Integer> tmp,List<List<Integer>> ans)\\n    {\\n        if(remain==0)\\n        {\\n            List<Integer> a=new ArrayList<Integer>(tmp);\\n            ans.add(a);\\n            return;\\n        }\\n        int entered=0; // get rid of duplicate combinations\\n        for(int i=rindex;i<candidates.length;i++)\\n        {\\n            if(entered!=candidates[i]) // get rid of duplicate combinations\\n            {\\n                if(remain-candidates[i]<0) break; //This line of code can reduce 7ms from execution time!\\n                tmp.add(candidates[i]);\\n                entered=candidates[i];\\n                ch(candidates,remain-candidates[i],i+1,tmp,ans);\\n                tmp.remove(tmp.size()-1); \\n            }   \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17056,
                "title": "my-solution-in-java",
                "content": "Generally speaking it is a DFS solution\\n\\n\\n    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            if (candidates==null||candidates.length==0) return Collections.emptyList();//Or throw exception();\\n    \\n            List<List<Integer>> results = new LinkedList<>();\\n    \\n            LinkedList<Integer> work = new LinkedList<>();\\n    \\n            Arrays.sort(candidates);\\n    \\n            for (int i=0,len=candidates.length;i<len;i++){\\n    \\n                if (i>0&&candidates[i]==candidates[i-1]) continue; //Avoid duplicates;\\n                combinationSumHelper(candidates,i,target,work,results);//DFS\\n            }\\n            return results;\\n        }\\n        //Use DFS\\n        private void combinationSumHelper(int[] candidates,int index, int target,LinkedList<Integer> work,List<List<Integer>> results){\\n            //Compare candidates[index] and target;\\n            //If equals, terminate the search,return result \\n            //If candidates[index] > target, terminate the search, no result\\n            //Otherwise, study rest of elements.\\n            if (candidates[index]>target){\\n                return;\\n            }else if (candidates[index]==target){//Update the \\n                work.addLast(candidates[index]);\\n                results.add(new ArrayList<Integer>(work));\\n                work.removeLast();\\n                return;\\n            }\\n            work.addLast(candidates[index]);\\n            for (int i=index+1,len=candidates.length;i<len;i++){\\n                if (i>index+1&&candidates[i]==candidates[i-1]) continue;//Avoid dulipcates\\n                if (candidates[i]<=target-candidates[index]){\\n                    combinationSumHelper(candidates,i,target-candidates[index],work,results);\\n                }\\n            }\\n            work.removeLast();\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            if (candidates==null||candidates.length==0) return Collections.emptyList();//Or throw exception();\\n    \\n            List<List<Integer>> results = new LinkedList<>();\\n    \\n            LinkedList<Integer> work = new LinkedList<>();\\n    \\n            Arrays.sort(candidates);\\n    \\n            for (int i=0,len=candidates.length;i<len;i++){\\n    \\n                if (i>0&&candidates[i]==candidates[i-1]) continue; //Avoid duplicates;\\n                combinationSumHelper(candidates,i,target,work,results);//DFS\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3812563,
                "title": "c-backtracking-considering-multiplicities-vs-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 different kinds of solutions are provided! One is backtracking; the other is dynamic programming solution. The backtracking solution is faster.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe backtracking solution considers the numbers with multiplicities. Using a container to store the pairs $(x_i, m_i)$ where $x_i$ is the number in candidates with its frequency $m_i$. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\prod_i(m_i+1))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\sum_i m_i)$$\\n\\n# Code for  backtracking\\n```\\nusing int2=pair<int, int>;\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> result;\\n    void backtrack(int i, vector<int>& subset, vector<int2>& nWm, int target) {\\n        if (target == 0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        if (i == n || target < 0) {\\n            return;\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        for (int j = 0; j <= m; j++) {\\n            for (int k = 1; k <= j; k++) // Add j x\\'s to subset\\n                subset.push_back(x);\\n\\n            backtrack(i + 1, subset, nWm, target-j*x);\\n\\n            for (int k = 1; k <= j; k++) //backtracking\\n                subset.pop_back();    \\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i-1]) {\\n                nWm[idx].second++;\\n            } \\n            else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n\\n        n=nWm.size();\\n        vector<int> subset;\\n        backtrack(0, subset, nWm, target);\\n        return result;\\n    }\\n};\\n```\\n# Code for DP\\n```\\nusing int2 = pair<int, int>;\\nclass Solution {\\npublic:\\nint n;\\nvector<vector<int>> dfs(int i, int target, vector<int2>& nWm, vector<vector<vector<vector<int>>>>& dp) \\n{\\n        if (target == 0) {\\n            return {{}};\\n        }\\n\\n        if (i == n || target < 0) {\\n            return {};\\n        }\\n\\n        if (!dp[i][target].empty()) {\\n            return dp[i][target];\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        vector<vector<int>> result;\\n        for (int j = 0; j <= m; j++) {\\n            vector<vector<int>> combinations = dfs(i + 1, target - j * x, nWm, dp);\\n            for (int k = 0; k < combinations.size(); k++) {\\n                for (int l = 1; l <= j; l++) {\\n                    combinations[k].push_back(x);\\n                }\\n                result.push_back(combinations[k]);\\n            }\\n        }       \\n        return  dp[i][target] = result;\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i - 1]) {\\n                nWm[idx].second++;\\n            } else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n        n=nWm.size();\\n\\n        vector<vector<vector<vector<int>>>> \\n        dp(n, vector<vector<vector<int>>>(target + 1));\\n\\n        return dfs(0, target, nWm, dp);\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nusing int2=pair<int, int>;\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> result;\\n    void backtrack(int i, vector<int>& subset, vector<int2>& nWm, int target) {\\n        if (target == 0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        if (i == n || target < 0) {\\n            return;\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        for (int j = 0; j <= m; j++) {\\n            for (int k = 1; k <= j; k++) // Add j x\\'s to subset\\n                subset.push_back(x);\\n\\n            backtrack(i + 1, subset, nWm, target-j*x);\\n\\n            for (int k = 1; k <= j; k++) //backtracking\\n                subset.pop_back();    \\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i-1]) {\\n                nWm[idx].second++;\\n            } \\n            else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n\\n        n=nWm.size();\\n        vector<int> subset;\\n        backtrack(0, subset, nWm, target);\\n        return result;\\n    }\\n};\\n```\n```\\nusing int2 = pair<int, int>;\\nclass Solution {\\npublic:\\nint n;\\nvector<vector<int>> dfs(int i, int target, vector<int2>& nWm, vector<vector<vector<vector<int>>>>& dp) \\n{\\n        if (target == 0) {\\n            return {{}};\\n        }\\n\\n        if (i == n || target < 0) {\\n            return {};\\n        }\\n\\n        if (!dp[i][target].empty()) {\\n            return dp[i][target];\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        vector<vector<int>> result;\\n        for (int j = 0; j <= m; j++) {\\n            vector<vector<int>> combinations = dfs(i + 1, target - j * x, nWm, dp);\\n            for (int k = 0; k < combinations.size(); k++) {\\n                for (int l = 1; l <= j; l++) {\\n                    combinations[k].push_back(x);\\n                }\\n                result.push_back(combinations[k]);\\n            }\\n        }       \\n        return  dp[i][target] = result;\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i - 1]) {\\n                nWm[idx].second++;\\n            } else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n        n=nWm.size();\\n\\n        vector<vector<vector<vector<int>>>> \\n        dp(n, vector<vector<vector<int>>>(target + 1));\\n\\n        return dfs(0, target, nWm, dp);\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631115,
                "title": "optimized-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j+1,n,k-v[j],v,tmp,ans);\\n            while(j+1<n&&v[j]==v[j+1]){\\n                j++;\\n            }\\n            tmp.pop_back();\\n            \\n        }\\n\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        vector<int> tmp;\\n        vector<vector<int>> ans;\\n        int n = v.size();\\n        solve(0,n,k,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j+1,n,k-v[j],v,tmp,ans);\\n            while(j+1<n&&v[j]==v[j+1]){\\n                j++;\\n            }\\n            tmp.pop_back();\\n            \\n        }\\n\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        vector<int> tmp;\\n        vector<vector<int>> ans;\\n        int n = v.size();\\n        solve(0,n,k,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263257,
                "title": "simple-and-easy-to-understand-c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector <vector <int>> ans;\\n        vector <int> v;\\n        solution(0,target,candidates,ans,v);\\n        return ans;\\n    }\\n    void solution(int i,int target,vector <int> &candidates,vector <vector <int>> &ans,vector <int> &v){\\n        if(target==0){\\n           ans.push_back(v);\\n            return;\\n        }\\n        for(int index=i;index<candidates.size();index++){\\n            if(index>i && candidates[index]==candidates[index-1]) continue;\\n            if(candidates[index]>target) break;\\n            v.push_back(candidates[index]);\\n            solution(index+1,target-candidates[index],candidates,ans,v);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector <vector <int>> ans;\\n        vector <int> v;\\n        solution(0,target,candidates,ans,v);\\n        return ans;\\n    }\\n    void solution(int i,int target,vector <int> &candidates,vector <vector <int>> &ans,vector <int> &v){\\n        if(target==0){\\n           ans.push_back(v);\\n            return;\\n        }\\n        for(int index=i;index<candidates.size();index++){\\n            if(index>i && candidates[index]==candidates[index-1]) continue;\\n            if(candidates[index]>target) break;\\n            v.push_back(candidates[index]);\\n            solution(index+1,target-candidates[index],candidates,ans,v);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243195,
                "title": "c-recursion-backtracking-array-easy-66-time-43-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void recur(int i, int t, vector<int> &v, vector<int> &temp, set<vector<int>> &ans){\\n      if(t == 0){\\n        ans.insert(temp);\\n        return;\\n      }\\n      for(int idx = i; idx < v.size(); idx++){\\n        if(idx > i and v[idx] == v[idx - 1]) continue;\\n        if(t - v[idx] < 0) break;\\n        temp.emplace_back(v[idx]);\\n        recur(idx + 1, t - v[idx], v, temp, ans);\\n        temp.pop_back();\\n      }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int t) {\\n      set<vector<int>> anst;\\n      vector<int> temp;\\n      sort(v.begin(), v.end());\\n      recur(0, t, v, temp, anst);\\n      vector<vector<int>> ans(anst.begin(), anst.end());\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(int i, int t, vector<int> &v, vector<int> &temp, set<vector<int>> &ans){\\n      if(t == 0){\\n        ans.insert(temp);\\n        return;\\n      }\\n      for(int idx = i; idx < v.size(); idx++){\\n        if(idx > i and v[idx] == v[idx - 1]) continue;\\n        if(t - v[idx] < 0) break;\\n        temp.emplace_back(v[idx]);\\n        recur(idx + 1, t - v[idx], v, temp, ans);\\n        temp.pop_back();\\n      }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int t) {\\n      set<vector<int>> anst;\\n      vector<int> temp;\\n      sort(v.begin(), v.end());\\n      recur(0, t, v, temp, anst);\\n      vector<vector<int>> ans(anst.begin(), anst.end());\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844056,
                "title": "easy-c-solution-striver-better-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public: \\n    void findCombination(int ind, int target, vector<int> &arr, vector<vector<int>> &ans, vector<int>&ds) {\\n        if(target==0){ \\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        int prev=-1;\\n        for(int i=ind;i<arr.size();i++){\\n            if(arr[i]!=prev && arr[i]<=target){\\n                ds.push_back(arr[i]);\\n                findCombination(i+1,target-arr[i],arr,ans,ds);\\n                ds.pop_back();\\n                prev=arr[i];\\n            }\\n        }\\n\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans; \\n        vector<int> ds; \\n        findCombination(0, target, candidates, ans, ds); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public: \\n    void findCombination(int ind, int target, vector<int> &arr, vector<vector<int>> &ans, vector<int>&ds) {\\n        if(target==0){ \\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        int prev=-1;\\n        for(int i=ind;i<arr.size();i++){\\n            if(arr[i]!=prev && arr[i]<=target){\\n                ds.push_back(arr[i]);\\n                findCombination(i+1,target-arr[i],arr,ans,ds);\\n                ds.pop_back();\\n                prev=arr[i];\\n            }\\n        }\\n\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans; \\n        vector<int> ds; \\n        findCombination(0, target, candidates, ans, ds); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494877,
                "title": "c-not-fastest-but-easy-to-understand-recursive-solution-unique-solution",
                "content": "Please let me know if you need an explanation. I will try to explain in detail.\\n\\n```cpp\\nvoid get_combition_sum_2(vector <int> input, int target, int pos, vector <int> combination, vector <vector <int>> &result){\\n    if (pos >= input.size() || target <= 0){\\n        if (target == 0)\\n            result.push_back(combination);    \\n        return;\\n    }\\n\\n    combination.push_back(input[pos]);\\n    get_combition_sum_2(input, target - input[pos], pos + 1, combination, result);\\n    combination.pop_back();\\n\\n    while (pos < input.size() - 1 && input[pos] == input[pos+1])\\n        pos++;\\n\\n    get_combition_sum_2(input, target, pos + 1, combination, result);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```cpp\\nvoid get_combition_sum_2(vector <int> input, int target, int pos, vector <int> combination, vector <vector <int>> &result){\\n    if (pos >= input.size() || target <= 0){\\n        if (target == 0)\\n            result.push_back(combination);    \\n        return;\\n    }\\n\\n    combination.push_back(input[pos]);\\n    get_combition_sum_2(input, target - input[pos], pos + 1, combination, result);\\n    combination.pop_back();\\n\\n    while (pos < input.size() - 1 && input[pos] == input[pos+1])\\n        pos++;\\n\\n    get_combition_sum_2(input, target, pos + 1, combination, result);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2383036,
                "title": "c-solution-backtracking-comments-better-than-89",
                "content": "Here, we can\\'t perform normal backtracking as it would lead to 2^n cases(where n<=100 given). So we tweak the code a bit so that we don\\'t have to produce the same combinations again and again.\\n\\nSteps used:\\n-> After sorting the initial array, follow the below steps\\n-> add the curr element from target and backtrack for the leftover part of array.\\n-> don\\'t add the curr element from the target and backtrack for the leftover part of the array.\\n-> if this we keep track of if the previous element is same as current element, we skip to the next distinct number, and then apply the same steps as above.\\n\\n```\\nclass Solution{\\n    public:\\n    vector<vector<int> > ans;\\n    \\n    void backtrack(vector<int> a, vector<int> curr, int t, int i){\\n        // if t is 0, means we formed the group of elements which sum to target,\\n\\t\\t// and we push it into our ans.\\n\\t\\tif(t==0)\\n\\t\\t\\tans.push_back(curr);\\n\\t\\t\\t\\n\\t\\t// but if t<0, means we don\\'t need to check further for this, \\n\\t\\t// as the elements greater than it, won\\'t sum to t.\\n        if(t<0)    return;\\n\\t\\t\\n\\t\\t// to keep track of prev element( -1 is insignificant here.)\\n        int prev = -1;\\n        \\n        for(; i<a.size(); i++){\\n\\t\\t\\t// if prev element is same as current element, we continue.\\n            if(prev==a[i])  continue;\\n\\t\\t\\t\\n\\t\\t\\t// else we append it to current \\n            curr.push_back(a[i]);\\n\\t\\t\\t\\n\\t\\t\\t// we backtrack for the required element\\n            backtrack(a, curr, t-a[i], i+1);\\n\\t\\t\\t\\n\\t\\t\\t// the other backtrack we use, without using the current element\\n            curr.pop_back();\\n            prev = a[i];\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int> &a, int t){\\n\\t\\t// sort the array\\n        sort(a.begin(), a.end());\\n        vector<int> temp;temp.clear();\\n        backtrack(a, temp, t, 0);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public:\\n    vector<vector<int> > ans;\\n    \\n    void backtrack(vector<int> a, vector<int> curr, int t, int i){\\n        // if t is 0, means we formed the group of elements which sum to target,\\n\\t\\t// and we push it into our ans.\\n\\t\\tif(t==0)\\n\\t\\t\\tans.push_back(curr);\\n\\t\\t\\t\\n\\t\\t// but if t<0, means we don\\'t need to check further for this, \\n\\t\\t// as the elements greater than it, won\\'t sum to t.\\n        if(t<0)    return;\\n\\t\\t\\n\\t\\t// to keep track of prev element( -1 is insignificant here.)\\n        int prev = -1;\\n        \\n        for(; i<a.size(); i++){\\n\\t\\t\\t// if prev element is same as current element, we continue.\\n            if(prev==a[i])  continue;\\n\\t\\t\\t\\n\\t\\t\\t// else we append it to current \\n            curr.push_back(a[i]);\\n\\t\\t\\t\\n\\t\\t\\t// we backtrack for the required element\\n            backtrack(a, curr, t-a[i], i+1);\\n\\t\\t\\t\\n\\t\\t\\t// the other backtrack we use, without using the current element\\n            curr.pop_back();\\n            prev = a[i];\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int> &a, int t){\\n\\t\\t// sort the array\\n        sort(a.begin(), a.end());\\n        vector<int> temp;temp.clear();\\n        backtrack(a, temp, t, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318566,
                "title": "c-recursion",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    void recur(int ind, int tar, vector<int>& c, vector<vector<int>>& ans, vector<int>& ds){\\n        if(tar==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<c.size();i++){\\n            if(i>ind && c[i]==c[i-1]) continue;\\n            if(c[i]>tar) break;\\n            \\n            ds.push_back(c[i]);\\n            recur(i+1, tar-c[i], c, ans, ds);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& c, int target) {\\n        sort(c.begin(), c.end());\\n        int n=c.size();\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        recur(0, target, c, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(int ind, int tar, vector<int>& c, vector<vector<int>>& ans, vector<int>& ds){\\n        if(tar==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<c.size();i++){\\n            if(i>ind && c[i]==c[i-1]) continue;\\n            if(c[i]>tar) break;\\n            \\n            ds.push_back(c[i]);\\n            recur(i+1, tar-c[i], c, ans, ds);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& c, int target) {\\n        sort(c.begin(), c.end());\\n        int n=c.size();\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        recur(0, target, c, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260963,
                "title": "combination-of-subsets-ii-90-and-combination-sum-39",
                "content": "class Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n      List<List<Integer>> ans = new ArrayList<>();\\n        //sort the array\\n        Arrays.sort(candidates);\\n        solve(candidates,0,ans,new ArrayList<>(),target);\\n        return ans;\\n    }\\n     public void solve(int[] candidates,int i,List<List<Integer>>ans,List<Integer> output, int target){\\n\\t //base case\\n        if(i==candidates.length){\\n            if(target==0){\\n                ans.add(new ArrayList<>(output));\\n            }\\n            return;\\n        }\\n        //include the element and since each candidate can be used one send i+1 to the function\\n         if(candidates[i]<=target){\\n            output.add(candidates[i]);\\n            solve(candidates,i+1,ans,output,target-candidates[i]);\\n            output.remove(output.size()-1);\\n         }\\n        //exclude if the number is similar to the previous as it will result in same path\\n        while(i+1<candidates.length && candidates[i]==candidates[i+1]){\\n            i++;\\n        }\\n        solve(candidates,i+1,ans,output,target);\\n    }\\n}\\nTried after following striver\\'s and neetcode\\'s approach",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n      List<List<Integer>> ans = new ArrayList<>();\\n        //sort the array\\n        Arrays.sort(candidates);\\n        solve(candidates,0,ans,new ArrayList<>(),target);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1689307,
                "title": "c-solution-set-recursion",
                "content": "*Please upvote if you find it helpful :)*\\n```\\nvoid solve(int index, vector<int> &candidates, int target, vector<int> &v1, set<vector<int> >&v){\\n        if(target==0) {\\n            v.insert(v1);\\n            return ;\\n        }\\n        if(index >= candidates.size() || target < candidates[index])\\n            return;\\n        v1.push_back(candidates[index]);\\n        solve(index+1, candidates, target-candidates[index], v1, v);\\n        v1.pop_back();\\n        int next_index = index;\\n        while (next_index < candidates.size() && candidates[next_index] == candidates[index])\\n            next_index++;\\n        solve(next_index, candidates, target, v1, v);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> v1;\\n        set<vector<int> > v;\\n        vector<vector<int> > ans;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0, candidates, target, v1, v);\\n        for(auto x: v) {\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nvoid solve(int index, vector<int> &candidates, int target, vector<int> &v1, set<vector<int> >&v){\\n        if(target==0) {\\n            v.insert(v1);\\n            return ;\\n        }\\n        if(index >= candidates.size() || target < candidates[index])\\n            return;\\n        v1.push_back(candidates[index]);\\n        solve(index+1, candidates, target-candidates[index], v1, v);\\n        v1.pop_back();\\n        int next_index = index;\\n        while (next_index < candidates.size() && candidates[next_index] == candidates[index])\\n            next_index++;\\n        solve(next_index, candidates, target, v1, v);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> v1;\\n        set<vector<int> > v;\\n        vector<vector<int> > ans;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0, candidates, target, v1, v);\\n        for(auto x: v) {\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1311783,
                "title": "elegant-python-recursion",
                "content": "```\\n# Time Complexity: 2^(N), where N = len(candidates)\\n# Space Complexity: O(N)\\nfrom collections import Counter\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n    \\n        combinations = []\\n        counter = Counter(candidates)\\n        counter = [(key, counter[key]) for key in counter]\\n        \\n        def recursion(index = 0, current_combination = [], combination_sum = 0):\\n            if combination_sum > target or index not in range(len(counter)): return\\n            elif combination_sum == target: combinations.append(current_combination.copy()) \\n            else:\\n                candidate, frequency = counter[index]\\n                if frequency > 0:\\n                    counter[index] = (candidate, frequency-1)\\n                    recursion(index, current_combination + [candidate], combination_sum + candidate)\\n                counter[index] = (candidate, frequency)\\n                recursion(index+1, current_combination, combination_sum)\\n                        \\n        recursion()\\n        return combinations\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Time Complexity: 2^(N), where N = len(candidates)\\n# Space Complexity: O(N)\\nfrom collections import Counter\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n    \\n        combinations = []\\n        counter = Counter(candidates)\\n        counter = [(key, counter[key]) for key in counter]\\n        \\n        def recursion(index = 0, current_combination = [], combination_sum = 0):\\n            if combination_sum > target or index not in range(len(counter)): return\\n            elif combination_sum == target: combinations.append(current_combination.copy()) \\n            else:\\n                candidate, frequency = counter[index]\\n                if frequency > 0:\\n                    counter[index] = (candidate, frequency-1)\\n                    recursion(index, current_combination + [candidate], combination_sum + candidate)\\n                counter[index] = (candidate, frequency)\\n                recursion(index+1, current_combination, combination_sum)\\n                        \\n        recursion()\\n        return combinations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788413,
                "title": "8ms-c-backtracking-simple-code",
                "content": "```\\n// upvote if this solution helpes you.\\nclass Solution {\\npublic:\\n    vector<vector<int> >finalans;\\n    set<vector<int> >ans;   // for no repetition\\n    vector<int> temp;\\n    \\n    void backtracking(vector<int>& candidates, int target, set<vector<int> >&ans, vector<int> &temp, int start)\\n    {\\n        if(target == 0)\\n        {\\n            ans.insert(temp);\\n            return;\\n        }\\n        \\n        for(int i=start; i<candidates.size() && target >= candidates[i]; i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            backtracking(candidates, target - candidates[i], ans, temp, i+1);     // i+1 so that it will not pick same element again.\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        backtracking(candidates, target, ans, temp, 0);\\n        for(auto i : ans)\\n            finalans.push_back(i);\\n        return finalans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// upvote if this solution helpes you.\\nclass Solution {\\npublic:\\n    vector<vector<int> >finalans;\\n    set<vector<int> >ans;   // for no repetition\\n    vector<int> temp;\\n    \\n    void backtracking(vector<int>& candidates, int target, set<vector<int> >&ans, vector<int> &temp, int start)\\n    {\\n        if(target == 0)\\n        {\\n            ans.insert(temp);\\n            return;\\n        }\\n        \\n        for(int i=start; i<candidates.size() && target >= candidates[i]; i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            backtracking(candidates, target - candidates[i], ans, temp, i+1);     // i+1 so that it will not pick same element again.\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        backtracking(candidates, target, ans, temp, 0);\\n        for(auto i : ans)\\n            finalans.push_back(i);\\n        return finalans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650590,
                "title": "java-iterative-dp-no-recursion-straightforward",
                "content": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Map<Integer, Set<List<Integer>>> map = new HashMap<>();\\n        Arrays.sort(candidates);\\n        for (int cand : candidates) {\\n            if (cand > target) continue;\\n            for (int num = target - cand; num >= 0; num--) {\\n                Set<List<Integer>> tmp = map.getOrDefault(num + cand, new HashSet<>());\\n                Set<List<Integer>> prev = map.getOrDefault(num, new HashSet<>());\\n                for (List<Integer> l : prev) {\\n                    List<Integer> newList = new ArrayList<>();\\n                    newList.addAll(l);\\n                    newList.add(cand);\\n                    tmp.add(newList);\\n                }\\n                map.put(num + cand, tmp);\\n            }\\n            map.computeIfAbsent(cand, g -> new HashSet<>());\\n            map.get(cand).add(List.of(cand));\\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.addAll(map.getOrDefault(target, new HashSet<>()));\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Map<Integer, Set<List<Integer>>> map = new HashMap<>();\\n        Arrays.sort(candidates);\\n        for (int cand : candidates) {\\n            if (cand > target) continue;\\n            for (int num = target - cand; num >= 0; num--) {\\n                Set<List<Integer>> tmp = map.getOrDefault(num + cand, new HashSet<>());\\n                Set<List<Integer>> prev = map.getOrDefault(num, new HashSet<>());\\n                for (List<Integer> l : prev) {\\n                    List<Integer> newList = new ArrayList<>();\\n                    newList.addAll(l);\\n                    newList.add(cand);\\n                    tmp.add(newList);\\n                }\\n                map.put(num + cand, tmp);\\n            }\\n            map.computeIfAbsent(cand, g -> new HashSet<>());\\n            map.get(cand).add(List.of(cand));\\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.addAll(map.getOrDefault(target, new HashSet<>()));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561957,
                "title": "python-6-line-dp-without-using-hashset-to-check-duplicate-explained",
                "content": "I see a lot of posts using HashSet to check duplicates. There is no need for that.\\nThe only difference with question [\"39 Combination Sum I\"](https://leetcode.com/problems/combination-sum/) is that, this questions limits the repetition count for each item in \"candidates\" array. \\nCode is almost the same code as [\"39 Combination Sum I\"](https://leetcode.com/problems/combination-sum/), just adding an extra \"if\" to exclude those repeating too many times.\\n**dp[i]** is a list of all combinations that sums up to \"i\". We put \"candidates\" in outer loop and \"target\" iteration in inner loop, so that when one candidate number is used, it won\\'t be picked again later. This automatically avoids duplicates. No need to use hash for duplicate check.\\n```\\n\\t    counter=collections.Counter(candidates)\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c,cnt in counter.items():\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c] if len(arr)<cnt or arr[-cnt]!=c])        \\n        return dp[target]\\n```\\nWe can use arr[-cnt]!=c to check repeating count because in arr, same number must all be side-by-side.\\n\\nFor comparison, here is the code for [\"39 Combination Sum I\"](https://leetcode.com/problems/combination-sum/). The only difference is, it doesn\\'t have the \"if\" statement in the end of \"dp[i].extend\" line.\\n```\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c in candidates:\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c]])\\n        return dp[target]\\n```",
                "solutionTags": [],
                "code": "```\\n\\t    counter=collections.Counter(candidates)\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c,cnt in counter.items():\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c] if len(arr)<cnt or arr[-cnt]!=c])        \\n        return dp[target]\\n```\n```\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c in candidates:\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c]])\\n        return dp[target]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 543016,
                "title": "c-4-ms-short-fast-backtracking-solution-99-100",
                "content": "```\\nclass Solution{\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n        {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> vsum;\\n            add(candidates, 0, target, 0, vsum, res);\\n            return res;\\n        }\\n\\n    protected:\\n        void add(vector<int>& cand, int i, int target, int sum, vector<int>& vsum, vector<vector<int>>& res)\\n        {\\n            for(int s = 0; i < cand.size(); ++i)\\n            {\\n                s = sum + cand[i];\\n                if(s > target) continue;\\n                vsum.push_back(cand[i]);\\n                if(s == target)\\n                    res.push_back(vsum);\\n                else\\n                    add(cand, i+1, target, s, vsum, res);\\n                vsum.pop_back();\\n                while(i+1 < cand.size() && cand[i] == cand[i+1]) ++i; // skip duplicates\\n            }\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution{\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n        {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> vsum;\\n            add(candidates, 0, target, 0, vsum, res);\\n            return res;\\n        }\\n\\n    protected:\\n        void add(vector<int>& cand, int i, int target, int sum, vector<int>& vsum, vector<vector<int>>& res)\\n        {\\n            for(int s = 0; i < cand.size(); ++i)\\n            {\\n                s = sum + cand[i];\\n                if(s > target) continue;\\n                vsum.push_back(cand[i]);\\n                if(s == target)\\n                    res.push_back(vsum);\\n                else\\n                    add(cand, i+1, target, s, vsum, res);\\n                vsum.pop_back();\\n                while(i+1 < cand.size() && cand[i] == cand[i+1]) ++i; // skip duplicates\\n            }\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429543,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146416,
                "title": "11ms-java-solution-with-no-loop-inside-recursion",
                "content": "A simple way to look at the problem is that for each element in the array, we have two options: **include it or not** in the combination.\\nSay we\\'re at array index ```i``` with target ```t```. \\n*Possibility 1:* If we do include ```array[i]```, the problem becomes \"**Find combinations of sum (t - array[i]) in the array starting at i+1**\". \\n*Possibility 2:* If we do **not** include ```array[i]```, the problem is to \"**Find combinations of sum t in the array starting at i+1**\".\\nThe only headache left now is to exclude duplicate answers. Duplicate answers exist because we have duplicate elements in the array. \\nSay we have *k* ```1```\\'s. Using the above algorithm, we get *2^k* possiblites. But among them only *(k+1)* possiblities are useful: *0 ... k* of the k ```1```\\'s are chosen. Thus, we only include the first *n* consecutive ```1```\\'s. That means **once we decide to uninclude a ```1```, we uninclude all the following ```1```\\'s**.\\nSince we consider two possibilities at each index, the execution forms a binary tree with level *n*. The execution time will thus be O(2^n).\\n```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new LinkedList<List<Integer>>();\\n        if(candidates == null || candidates.length == 0)\\n            return res;\\n        Arrays.sort(candidates);\\n        combinations(candidates, target, 0, res, new Stack<>());\\n        return res;\\n    }\\n    \\n    private void combinations(int[] array, int target, int start, \\n                              List<List<Integer>> list, Stack<Integer> stack){\\n    \\tif(target == 0)\\n    \\t\\tlist.add(new ArrayList<Integer>(stack));\\n        if(target < 0 || start == array.length || target < array[start])\\n            return;\\n\\t\\t\\t\\t\\t\\t\\n        //possibility 1: include array[i]\\n        stack.push(array[start]);\\n        combinations(array, target-array[start], start+1, list, stack);\\n        stack.pop();        \\n\\t\\t\\t\\t\\n        //possibility 2: don\\'t include array[i]\\n        while(start+1 < array.length && array[start+1]==array[start])\\n            start++; //exclude duplicates\\n        combinations(array, target, start+1, list, stack);\\n    }\\n```",
                "solutionTags": [],
                "code": "```i```\n```t```\n```array[i]```\n```array[i]```\n```1```\n```1```\n```1```\n```1```\n```1```\n```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new LinkedList<List<Integer>>();\\n        if(candidates == null || candidates.length == 0)\\n            return res;\\n        Arrays.sort(candidates);\\n        combinations(candidates, target, 0, res, new Stack<>());\\n        return res;\\n    }\\n    \\n    private void combinations(int[] array, int target, int start, \\n                              List<List<Integer>> list, Stack<Integer> stack){\\n    \\tif(target == 0)\\n    \\t\\tlist.add(new ArrayList<Integer>(stack));\\n        if(target < 0 || start == array.length || target < array[start])\\n            return;\\n\\t\\t\\t\\t\\t\\t\\n        //possibility 1: include array[i]\\n        stack.push(array[start]);\\n        combinations(array, target-array[start], start+1, list, stack);\\n        stack.pop();        \\n\\t\\t\\t\\t\\n        //possibility 2: don\\'t include array[i]\\n        while(start+1 < array.length && array[start+1]==array[start])\\n            start++; //exclude duplicates\\n        combinations(array, target, start+1, list, stack);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16882,
                "title": "python-dfs-solution",
                "content": "```\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        res = []\\n        \\n        def dfs(t, idx=0, path=[]):\\n            if t < 0:\\n                return  # Backtrack (Not a valid path)\\n            \\n            if t == 0:\\n                res.append(path)\\n                return\\n            \\n            if t > 0:\\n                for i in range(idx, len(candidates)):\\n                    c = candidates[i]\\n                    if i != idx and c == candidates[i-1]: continue  # Eliminates duplicates\\n                    dfs(t-c, i+1, path+[c])\\n\\n        dfs(target)\\n        return res\\n```\\n\\nDFS idea is borrowed from @caikehe's Combination Sum [solution](https://discuss.leetcode.com/topic/23142/python-dfs-solution). Here, when recursively calling dfs in for loop, we increment the index by 1 (unlike combination sum problem where we don't increment i). That's because we don't want the same number to be considered twice. Also, the line `if i != idx and c == candidates[i-1]: continue`, is needed to eliminate duplicate combinations.",
                "solutionTags": [],
                "code": "```\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        res = []\\n        \\n        def dfs(t, idx=0, path=[]):\\n            if t < 0:\\n                return  # Backtrack (Not a valid path)\\n            \\n            if t == 0:\\n                res.append(path)\\n                return\\n            \\n            if t > 0:\\n                for i in range(idx, len(candidates)):\\n                    c = candidates[i]\\n                    if i != idx and c == candidates[i-1]: continue  # Eliminates duplicates\\n                    dfs(t-c, i+1, path+[c])\\n\\n        dfs(target)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17006,
                "title": "short-and-easy-to-understand-recursive-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            combine(candidates, 0, target, res, new ArrayList<Integer>());\\n            return res;\\n        }\\n        private void combine(int[] nums, int start, int target, List<List<Integer>> res, List<Integer> path){\\n            if (target < 0) return;\\n            if (target == 0){\\n                res.add(path);\\n                return;\\n            }\\n            for (int i = start; i < nums.length; i++){\\n                if (i > start && nums[i] == nums[i - 1]) continue;\\n                List<Integer> currentPath = new ArrayList<Integer>(path);\\n                currentPath.add(nums[i]);\\n                combine(nums, i + 1, target - nums[i], res, currentPath);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            combine(candidates, 0, target, res, new ArrayList<Integer>());\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3581319,
                "title": "python3-backtracking-mega-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        candidates.sort()\\n\\n        def backtracking(start, total, path):\\n            if total == target:\\n                ans.append(path)\\n                return\\n            \\n            for i in range(start, len(candidates)):\\n                if total + candidates[i] > target:\\n                    return\\n                elif i > start and candidates[i] == candidates[i-1]:\\n                    continue\\n                else:\\n                    backtracking(i + 1, total + candidates[i], path + [candidates[i]])\\n\\n        backtracking(0, 0, [])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        candidates.sort()\\n\\n        def backtracking(start, total, path):\\n            if total == target:\\n                ans.append(path)\\n                return\\n            \\n            for i in range(start, len(candidates)):\\n                if total + candidates[i] > target:\\n                    return\\n                elif i > start and candidates[i] == candidates[i-1]:\\n                    continue\\n                else:\\n                    backtracking(i + 1, total + candidates[i], path + [candidates[i]])\\n\\n        backtracking(0, 0, [])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265075,
                "title": "python-accepted-recursive-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ans=[]\\n        n=len(candidates)\\n        candidates.sort()\\n        def solve(idx,lst,sum):\\n            # nonlocal ans,candidates\\n            if sum==target:\\n                ans.append(lst)\\n                return \\n            for i in range(idx,n):\\n                if i>idx and candidates[i]==candidates[i-1]:\\n                    continue\\n                if sum+candidates[i]>target:\\n                    break\\n                solve(i+1,lst+[candidates[i]],sum+candidates[i])\\n        solve(0,[],0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ans=[]\\n        n=len(candidates)\\n        candidates.sort()\\n        def solve(idx,lst,sum):\\n            # nonlocal ans,candidates\\n            if sum==target:\\n                ans.append(lst)\\n                return \\n            for i in range(idx,n):\\n                if i>idx and candidates[i]==candidates[i-1]:\\n                    continue\\n                if sum+candidates[i]>target:\\n                    break\\n                solve(i+1,lst+[candidates[i]],sum+candidates[i])\\n        solve(0,[],0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071587,
                "title": "easy-c-solution-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void f(int i,vector<vector<int>>&res, vector<int>& can,vector<int>& temp, int tar){\\n            if(tar==0){\\n                res.push_back(temp);\\n                return;\\n            } \\n        for(int j=i;j<can.size();j++){\\n            if(j>i && (can[j]==can[j-1])) continue;\\n            if(can[j]>tar) break;\\n            temp.push_back(can[j]);\\n            f(j+1,res,can,temp,tar-can[j]);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& can, int tar) {\\n        sort(can.begin(),can.end());\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        f(0,res,can,temp,tar);\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(int i,vector<vector<int>>&res, vector<int>& can,vector<int>& temp, int tar){\\n            if(tar==0){\\n                res.push_back(temp);\\n                return;\\n            } \\n        for(int j=i;j<can.size();j++){\\n            if(j>i && (can[j]==can[j-1])) continue;\\n            if(can[j]>tar) break;\\n            temp.push_back(can[j]);\\n            f(j+1,res,can,temp,tar-can[j]);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& can, int tar) {\\n        sort(can.begin(),can.end());\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        f(0,res,can,temp,tar);\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826015,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/11/ugly-number.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nvar combinationSum2 = function(candidates, target) {\\n\\nvar result = []\\n\\ncandidates.sort((a,b) => a-b)\\nvar helper = function(candidates, target, tmpArr, idx){\\n    if(target == 0){ // when target reaches zero, means that you can push it into the result\\n        result.push(tmpArr.slice())\\n        return\\n    }\\n    \\n    if(target < 0){ //with recursion, your \\'target\\' might get reduced till below zero and at that point of time it\\'s time to stop the recursion\\n        return\\n    }\\n    \\n    for(var i = idx; i < candidates.length; i++){ //simulating whether to take or not to take every single digit\\n        if(idx == i || candidates[i] != candidates[i - 1]){\\n            tmpArr.push(candidates[i])\\n            helper(candidates, target - candidates[i], tmpArr, i + 1)\\n            tmpArr.pop()    \\n        }   \\n    }   \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar combinationSum2 = function(candidates, target) {\\n\\nvar result = []\\n\\ncandidates.sort((a,b) => a-b)\\nvar helper = function(candidates, target, tmpArr, idx){\\n    if(target == 0){ // when target reaches zero, means that you can push it into the result\\n        result.push(tmpArr.slice())\\n        return\\n    }\\n    \\n    if(target < 0){ //with recursion, your \\'target\\' might get reduced till below zero and at that point of time it\\'s time to stop the recursion\\n        return\\n    }\\n    \\n    for(var i = idx; i < candidates.length; i++){ //simulating whether to take or not to take every single digit\\n        if(idx == i || candidates[i] != candidates[i - 1]){\\n            tmpArr.push(candidates[i])\\n            helper(candidates, target - candidates[i], tmpArr, i + 1)\\n            tmpArr.pop()    \\n        }   \\n    }   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774199,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            if(i > id and val[i] == val[i-1]) continue;\\n            arr.push_back(val[i]);\\n            solve(arr, i + 1, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            if(i > id and val[i] == val[i-1]) continue;\\n            arr.push_back(val[i]);\\n            solve(arr, i + 1, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314706,
                "title": "c-backtracking-easy-to-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    set<vector<int>> s;\\n    void backtrack(vector<int> &nums,int target,int idx,vector<int> &v)\\n    {\\n        if(target==0)\\n        {\\n        res.push_back(v);\\n        s.insert(v);\\n        return ;\\n        }\\n        if(target<0||idx>=nums.size())\\n        {\\n            return ;\\n        }\\n        \\n        v.push_back(nums[idx]);\\n        backtrack(nums,target-nums[idx],idx+1,v);\\n        v.pop_back();\\n        \\n        int temp=nums[idx];\\n        while(idx<nums.size()&&temp==nums[idx])\\n            idx++;\\n        \\n        backtrack(nums,target,idx,v);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> v;\\n        backtrack(candidates,target,0,v);\\n        return res;\\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> res;\\n    set<vector<int>> s;\\n    void backtrack(vector<int> &nums,int target,int idx,vector<int> &v)\\n    {\\n        if(target==0)\\n        {\\n        res.push_back(v);\\n        s.insert(v);\\n        return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2270683,
                "title": "c-easy-simple-solution-combination-sum-ii",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans,k;\\n    int target;\\n    void util(vector<int> c,vector<int> a,int sum, int i)\\n    {\\n        if(sum>target )\\n                return;\\n        if(sum==target)\\n            {\\n                ans.push_back(a);\\n                return;\\n            }\\n        for(int j=i;j<c.size();j++)\\n        {\\n            if(j>i && c[j]==c[i])\\n                continue;\\n            sum+=c[j];\\n            a.push_back(c[j]);\\n            util(c,a,sum,j+1);\\n            a.pop_back();\\n            sum-=c[j];\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& c, int t) {\\n        target=t;\\n        vector<int> a;\\n        sort(c.begin(),c.end());\\n        util(c,a,0,0);\\n        set<vector<int>> s;\\n        for(auto t: ans)\\n        {\\n            if(s.find(t)==s.end())\\n            {\\n                s.insert(t);\\n                k.push_back(t);\\n            }\\n        }\\n        return k;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> ans,k;\\n    int target;\\n    void util(vector<int> c,vector<int> a,int sum, int i)\\n    {\\n        if(sum>target )\\n                return;\\n        if(sum==target)\\n            {\\n                ans.push_back(a);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1786651,
                "title": "using-java-recursion-with-set",
                "content": "class Solution \\n\\n\\n{\\n    \\n    private void findCombinations(int index,int[] array,int target,Set<List<Integer>> ans,List<Integer> ds)\\n    {\\n        \\n        if(index==array.length)\\n        {\\n            if(target==0)\\n            {\\n                ans.add(new ArrayList<>(ds));\\n               \\n            }\\n            return;\\n        }\\n        \\n        if(array[index]<=target)\\n        {\\n            ds.add(array[index]);\\n            \\n            findCombinations(index+1,array,target-array[index],ans,ds);\\n            ds.remove(ds.size()-1);\\n        }\\n        findCombinations(index+1,array,target,ans,ds);\\n    }\\n    \\n    \\n    \\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\n        Set<List<Integer>> ans = new HashSet<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList<>());\\n         \\n        \\n        List<List<Integer>> op = new ArrayList<>();\\n        for(List a:ans)\\n        {\\n            op.add(a);\\n        }\\n       return op;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution \\n\\n\\n{\\n    \\n    private void findCombinations(int index,int[] array,int target,Set<List<Integer>> ans,List<Integer> ds)\\n    {\\n        \\n        if(index==array.length)\\n        {\\n            if(target==0)\\n            {\\n                ans.add(new ArrayList<>(ds));\\n               \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1778007,
                "title": "c-simpelst-backtracking-solution-faster-than-100",
                "content": "* The solution is same as that of **Combination Sum**.\\n* But here, since there are repated elements & each element can be used only once, we\\'ll not be looping as : solve(candidates, i, curr, ans, target-C[i]) - this will lead to using an element more than once.\\n* We also add an additional condition in ```solve()``` i.e; when we\\'re traversing the array using ```j```, if ```j != i```, we\\'ll not be adding an element that\\'s repeated (Because we can use elements that\\'re repeated as many no. of times they\\'re repeated, but we cannot have the same combinations forming again and again)\\n\\n* **Eg :** In ```candidates = [1, 1, ,2 ,5 ,6, 7, 10]``` ---> Once we form a combination [1, 2, 5] if we use the 2nd one we\\'ll be again forming the same combination [1, 2, 5] since it satisfies the condition -- Add to the array if it\\'s less than the remaining target. So we avoid using such elements.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> combinationSum2(vector<int>& C, int X) {\\n        n = C.size();\\n        sort(C.begin(), C.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        solve(C, 0, curr, ans, X);\\n        return ans;\\n    }\\n    void solve(vector<int> &C, int i, vector<int> &curr, vector<vector<int>> &ans, int X){\\n        if(X == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int j=i; j<n; j++){\\n            if(X - C[j] >= 0){\\n                if(j > i && C[j]==C[j-1]) continue;\\n                curr.push_back(C[j]);\\n                solve(C, j+1, curr, ans, X-C[j]);\\n                curr.pop_back();\\n            }\\n        }\\n    } \\n};\\n```\\n\\n**Time Complexity :** O(k *x* 2^k) - k = avg length of the combinations arrays\\n\\n\\n**Do upvote if you\\'ve found my solution & explanation helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```solve()```\n```j```\n```j != i```\n```candidates = [1, 1, ,2 ,5 ,6, 7, 10]```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> combinationSum2(vector<int>& C, int X) {\\n        n = C.size();\\n        sort(C.begin(), C.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        solve(C, 0, curr, ans, X);\\n        return ans;\\n    }\\n    void solve(vector<int> &C, int i, vector<int> &curr, vector<vector<int>> &ans, int X){\\n        if(X == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int j=i; j<n; j++){\\n            if(X - C[j] >= 0){\\n                if(j > i && C[j]==C[j-1]) continue;\\n                curr.push_back(C[j]);\\n                solve(C, j+1, curr, ans, X-C[j]);\\n                curr.pop_back();\\n            }\\n        }\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713508,
                "title": "easy-to-understand-forgive-me-drawing-ugly-trees",
                "content": "![image](https://assets.leetcode.com/users/images/00b770e0-5782-458a-92f2-7348e78ce975_1642956700.9327555.png)\\n\\n<br>\\nsome cases you must pay attention to:\\n\\n\\n\\n1. n < 0\\n\\n```java\\nif (n < 0) skip all later ones\\n```\\n\\n2. n == 0\\n\\n```java\\n// write as template\\nif (n == 0) {\\n  \\tres.add(....)\\n    return;\\n}\\n```\\n\\n3. after backtrack recursion calling in loop, skip duplicates\\n\\n```java\\nwhile (i + 1 < A.length && A[i + 1] == A[i])\\n  i += 1;\\n```\\n\\n\\n\\nsome code:\\n\\n```java\\n/*\\nEach number in candidates may only be used once in the combination.\\nThus, need to use \\'offset\\'\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        \\n        backtrack(candidates, target, res, new ArrayList<>(), 0);\\n        \\n        return res;\\n    }\\n    \\n    private void backtrack(int[] A, int n, List<List<Integer>> res\\n                           , List<Integer> list, int offset) {\\n        if (n == 0) {\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for (int i = offset; i < A.length; i += 1) {\\n            \\n            int tmp = A[i];\\n            \\n            list.add(A[i]);\\n            n -= A[i];\\n            \\n            if (n < 0) // if n < 0, we dont even go to next level of backtracking tree!\\n                i = A.length;\\n            else\\n                backtrack(A, n, res, list, i + 1);\\n            \\n            list.remove(list.size() - 1);\\n            n += tmp;\\n            \\n            // skip all dups\\n            while (i + 1 < A.length && A[i + 1] == A[i])\\n                i += 1;\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nif (n < 0) skip all later ones\\n```\n```java\\n// write as template\\nif (n == 0) {\\n  \\tres.add(....)\\n    return;\\n}\\n```\n```java\\nwhile (i + 1 < A.length && A[i + 1] == A[i])\\n  i += 1;\\n```\n```java\\n/*\\nEach number in candidates may only be used once in the combination.\\nThus, need to use \\'offset\\'\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        \\n        backtrack(candidates, target, res, new ArrayList<>(), 0);\\n        \\n        return res;\\n    }\\n    \\n    private void backtrack(int[] A, int n, List<List<Integer>> res\\n                           , List<Integer> list, int offset) {\\n        if (n == 0) {\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for (int i = offset; i < A.length; i += 1) {\\n            \\n            int tmp = A[i];\\n            \\n            list.add(A[i]);\\n            n -= A[i];\\n            \\n            if (n < 0) // if n < 0, we dont even go to next level of backtracking tree!\\n                i = A.length;\\n            else\\n                backtrack(A, n, res, list, i + 1);\\n            \\n            list.remove(list.size() - 1);\\n            n += tmp;\\n            \\n            // skip all dups\\n            while (i + 1 < A.length && A[i + 1] == A[i])\\n                i += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673313,
                "title": "easy-java-solution-and-explaination-with-time-and-space-complexity",
                "content": "```\\nclass Solution {\\n    \\n    //lets implement the func here\\n    public void func(int ind, int target, int[] arr, List<Integer> ds, List<List<Integer>> ansList)\\n    {\\n        \\n        //this is the base case -> whenever the target will reach 0 \\n        //we can surely say that we\\'ve got our list and we can add it to the ansList\\n        \\n         if(target == 0) {\\n            ansList.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        //every time we are checking from the index ind to n-1 where n is the length of the array\\n        for(int i = ind; i< arr.length; i++)\\n        {\\n            \\n            //this is how we\\'ll find the duplicates and ignore it.\\n            //basically i\\'m checking if I am not getting any particular elemnt for the first time (i>ind)\\n            //&& the previous arr element is same as this one\\n            //then I\\'ll simply continue \\n            if(i > ind && arr[i] == arr[i-1]) continue;\\n            \\n            //Also, suppose my target is 4 and the arr[ind] is 10\\n            //then I can\\'t really use that array element\\n            //thats why I simply break out of the loop\\n            if(arr[ind] > target) break;\\n            \\n            // If I come out of the if condition \\n            //then that means everything is alright and the current array element \\n            //can contribute to my ans so I add it to my list ds.\\n            ds.add(arr[i]);\\n            \\n            //next, I call the function for the next element and this time my target will sure be reduced by whatever value we have ar arr[i]\\n            func(i+1, target - arr[i], arr, ds, ansList);\\n            \\n            //when we return make sure to remove whatever we\\'ve added. This is the backtracking step.\\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        //Initially sort the given array because we need to avoid duplicates.\\n        Arrays.sort(candidates);\\n        \\n        //create a List of List of Integer so that we can return our output.\\n        List<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //create a function and pass index=0, target, array, List<Integer>, ansList)\\n        //we pass List<Integer> because in the main ansList we\\'ll be adding this list with all the possible unique lists.\\n         func(0, target, candidates, new ArrayList<Integer>(), ansList);\\n        \\n        //once we get our output from the above function we return ansList.\\n        return ansList;\\n    }\\n}\\n```\\n\\nTC - O(2^n) * K - where k is the average list size\\nSC - K * X - where X is no. of combinations\\n\\nI hope you find this helpful. Please do upvote in case you understood.\\nThankss!",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //lets implement the func here\\n    public void func(int ind, int target, int[] arr, List<Integer> ds, List<List<Integer>> ansList)\\n    {\\n        \\n        //this is the base case -> whenever the target will reach 0 \\n        //we can surely say that we\\'ve got our list and we can add it to the ansList\\n        \\n         if(target == 0) {\\n            ansList.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        //every time we are checking from the index ind to n-1 where n is the length of the array\\n        for(int i = ind; i< arr.length; i++)\\n        {\\n            \\n            //this is how we\\'ll find the duplicates and ignore it.\\n            //basically i\\'m checking if I am not getting any particular elemnt for the first time (i>ind)\\n            //&& the previous arr element is same as this one\\n            //then I\\'ll simply continue \\n            if(i > ind && arr[i] == arr[i-1]) continue;\\n            \\n            //Also, suppose my target is 4 and the arr[ind] is 10\\n            //then I can\\'t really use that array element\\n            //thats why I simply break out of the loop\\n            if(arr[ind] > target) break;\\n            \\n            // If I come out of the if condition \\n            //then that means everything is alright and the current array element \\n            //can contribute to my ans so I add it to my list ds.\\n            ds.add(arr[i]);\\n            \\n            //next, I call the function for the next element and this time my target will sure be reduced by whatever value we have ar arr[i]\\n            func(i+1, target - arr[i], arr, ds, ansList);\\n            \\n            //when we return make sure to remove whatever we\\'ve added. This is the backtracking step.\\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        //Initially sort the given array because we need to avoid duplicates.\\n        Arrays.sort(candidates);\\n        \\n        //create a List of List of Integer so that we can return our output.\\n        List<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //create a function and pass index=0, target, array, List<Integer>, ansList)\\n        //we pass List<Integer> because in the main ansList we\\'ll be adding this list with all the possible unique lists.\\n         func(0, target, candidates, new ArrayList<Integer>(), ansList);\\n        \\n        //once we get our output from the above function we return ansList.\\n        return ansList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568727,
                "title": "solution-using-backtracking-with-given-input-in-c",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nvoid unique_combination(int l, int sum, int K,vector<int>& local,vector<int>& A)\\n{\\n\\tif (sum == K) {\\n\\t\\tcout << \"(\";\\n\\t\\tfor (int i = 0; i < local.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif (i != 0)\\n\\t\\t\\t\\tcout << \" \";\\n\\t\\t\\tcout << local[i];\\n\\t\\t\\tif (i != local.size() - 1)\\n\\t\\t\\t\\tcout << \",\";\\n\\t\\t}\\n\\t\\tcout << \")\" << endl;\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = l; i < A.size(); i++)\\n\\t{\\n\\t\\tif (sum + A[i] > K)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tif (i > l and A[i] == A[i - 1])\\n\\t\\t\\tcontinue;\\n\\n\\t\\tlocal.push_back(A[i]);\\n\\t\\tunique_combination(i + 1, sum + A[i], K, local, A);\\n\\n\\t\\tlocal.pop_back();\\n\\t}\\n}\\n\\nvoid Combination(vector<int> A, int K)\\n{\\n\\tsort(A.begin(), A.end());\\n\\n\\t\\n\\tvector<int> local;\\n\\n\\tunique_combination(0, 0, K, local, A);\\n}\\n\\nint main()\\n{\\n\\tvector<int> W = {5,10,12,13,15,18};\\n    int target = 30;\\n    cout << \"All unique combinations of given numbers that result in sum= \" << target << \" are:\\\\n\";\\n    Combination(W,target);\\n    \\n\\n\\treturn 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nvoid unique_combination(int l, int sum, int K,vector<int>& local,vector<int>& A)\\n{\\n\\tif (sum == K) {\\n\\t\\tcout << \"(\";\\n\\t\\tfor (int i = 0; i < local.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif (i != 0)\\n\\t\\t\\t\\tcout << \" \";\\n\\t\\t\\tcout << local[i];\\n\\t\\t\\tif (i != local.size() - 1)\\n\\t\\t\\t\\tcout << \",\";\\n\\t\\t}\\n\\t\\tcout << \")\" << endl;\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = l; i < A.size(); i++)\\n\\t{\\n\\t\\tif (sum + A[i] > K)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tif (i > l and A[i] == A[i - 1])\\n\\t\\t\\tcontinue;\\n\\n\\t\\tlocal.push_back(A[i]);\\n\\t\\tunique_combination(i + 1, sum + A[i], K, local, A);\\n\\n\\t\\tlocal.pop_back();\\n\\t}\\n}\\n\\nvoid Combination(vector<int> A, int K)\\n{\\n\\tsort(A.begin(), A.end());\\n\\n\\t\\n\\tvector<int> local;\\n\\n\\tunique_combination(0, 0, K, local, A);\\n}\\n\\nint main()\\n{\\n\\tvector<int> W = {5,10,12,13,15,18};\\n    int target = 30;\\n    cout << \"All unique combinations of given numbers that result in sum= \" << target << \" are:\\\\n\";\\n    Combination(W,target);\\n    \\n\\n\\treturn 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1369209,
                "title": "template-same-structure-codes-for-combination-subset-and-permutations",
                "content": "In this post:\\n\\nthese codes may not the fast solution or solution with least lines, but:\\n**If you understand one question, you can fix all others.**\\n\\nAll of them used the same structure.\\n--- Bot Up DFS, so we can use memorization to save inmediate results to speed up the algorithm.\\n\\n**All memorization part are not mandatory** , if you remove these codes, the algorithm still works.\\n\\nPart 1: Permutations\\nWhen order is matter,  we use boolean[] visited to avoid duplicate values.\\nPart 2: Combination\\nWhen order is not necessary,  for (int i = start; i < n; i++)  and dfs(i + 1) to avlid duplicate combination.\\nPart 3: Set\\nWhen the order is not necessary and the size of combination can be different, use a for loop to check the size from 0 to k.\\n\\n------------------------------------------------------------------------------------------------\\n\\n# Part one: Permutations\\nleetcode 46 https://leetcode.com/problems/permutations/\\n```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permute(int[] nums) {\\n        this.nums = nums;\\n        this.visited = new boolean[nums.length];\\n        return permuteDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteDfs(int pos) {\\n       \\n\\t   if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\t\\t\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            visited[i] = true;\\n            List<List<Integer>> subs = permuteDfs(pos + 1);\\n            for (List<Integer> sub: subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n            visited[i] = false;\\n        }        \\n        return res;\\n    }\\n}\\n```\\n\\nleetcode 47 https://leetcode.com/problems/permutations-ii/\\n\\njust one line different to fix the duplication\\n\\n*if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;*\\n```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        this.nums = nums;\\n        visited = new boolean[nums.length];\\n        Arrays.sort(nums);\\n        return permuteUniqueDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteUniqueDfs(int pos) {\\n        if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;\\n                visited[i] = true;\\n                List<List<Integer>> subs = permuteUniqueDfs(pos + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                visited[i] = false;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nleetcode 131\\nhttps://leetcode.com/problems/palindrome-partitioning/\\nThere is memorization function.\\n\\n```\\nclass Solution {\\n    String s;\\n    Map<Integer, List<List<String>>> cache;\\n    public List<List<String>> partition(String s) {\\n        this.s = s;\\n        this.cache = new HashMap<>();\\n        return partitionDfs(0);\\n    }\\n    \\n    private List<List<String>>  partitionDfs(int start) {\\n        if(start == s.length()) {\\n            List<List<String>> res = new ArrayList<>();\\n            List<String> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        if(cache.containsKey(start)){\\n            return cache.get(start);\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String cur = s.substring(start, i);\\n            if(isValid(cur)) {\\n                List<List<String>> subs = partitionDfs(i);\\n                for (List<String> sub: subs) {\\n                    List<String> prefix_item = new ArrayList<>();\\n                    prefix_item.add(cur);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                }\\n            }\\n        }\\n        cache.put(start, res);\\n        return res;\\n    }\\n    \\n    private boolean isValid(String str) {\\n        int l = 0;\\n        int r = str.length() - 1;    \\n        while(l < r) {\\n            if (str.charAt(l) != str.charAt(r)) return false;\\n            else {\\n                l++;\\n                r--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n# Part 2: Combination\\nleetcode 77 \\nhttps://leetcode.com/problems/combinations/\\n```\\nclass Solution {\\n    int k;\\n    int n;\\n    public List<List<Integer>> combine(int n, int k) {\\n        this.k = k;\\n        this.n = n;\\n        return combineDfs(1, 0);\\n    }\\n    \\n    private List<List<Integer>> combineDfs(int start, int len) {\\n        if(len == k) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i <= n; i++) {\\n            List<List<Integer>> subs = combineDfs(i + 1, len + 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(i);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nLeetcode 39. https://leetcode.com/problems/combination-sum/\\n```\\nclass Solution {\\n    int[] candidates;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        this.candidates = candidates;\\n        int n = candidates.length;        \\n        return combinationSumDfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSumDfs(int target, int pos) {\\n        if(target < 0) return new ArrayList<>();\\n        \\n        if(this.cache.containsKey(new Pair(target, pos))) {\\n            return this.cache.get(new Pair(target, pos));\\n        }\\n        \\n        if(target == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(target, pos);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n    \\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = pos; i < candidates.length; i++) {\\n            List<List<Integer>> subs = combinationSumDfs(target - candidates[i], i);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(candidates[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(target, pos);\\n        cache.put(pair, res);\\n            \\n        return res;\\n    } \\n}\\n```\\n\\nleetcode 40 https://leetcode.com/problems/combination-sum-ii/\\n\\n```\\nclass Solution {\\n    int[] candidates;\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        this.candidates = candidates;\\n        return combinationSum2Dfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSum2Dfs(int target, int start) {\\n        if(target == 0){\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;    \\n        }\\n        \\n        if(target < 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i < candidates.length; i++) {\\n            if((i == start || candidates[i] != candidates[i - 1])) {\\n                List<List<Integer>> subs = combinationSum2Dfs(target - candidates[i], i + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> prefix_item = new ArrayList<>();\\n                    prefix_item.add(candidates[i]);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nPart 3: Set\\n\\nleetcode 78 https://leetcode.com/problems/subsets/\\n\\n```\\nclass Solution {\\n    int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.nums = nums;\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nleetcode 90\\nhttps://leetcode.com/problems/subsets-ii/\\n\\n```\\nclass Solution {\\n   int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        this.nums = nums;\\n        Arrays.sort(nums);\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            if(i == start || nums[i] != nums[i - 1]) {\\n                List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n                for (List<Integer> sub : subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                }                \\n            }\\n        }\\n        \\n\\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n\\n```\\n\\nRelated posts before:\\n\\n\\nPython:\\nhttps://leetcode.com/problems/permutation-sequence/discuss/22554/Backtrack-Summary%3A-General-Solution-for-10-Questions!!!!!!!!-Python-(Combination-Sum-Subsets-Permutation-Palindrome)\\n\\nJava:\\nhttps://leetcode.com/problems/permutations/discuss/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning\\n\\n---------------------------\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permute(int[] nums) {\\n        this.nums = nums;\\n        this.visited = new boolean[nums.length];\\n        return permuteDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteDfs(int pos) {\\n       \\n\\t   if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\t\\t\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            visited[i] = true;\\n            List<List<Integer>> subs = permuteDfs(pos + 1);\\n            for (List<Integer> sub: subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n            visited[i] = false;\\n        }        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        this.nums = nums;\\n        visited = new boolean[nums.length];\\n        Arrays.sort(nums);\\n        return permuteUniqueDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteUniqueDfs(int pos) {\\n        if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;\\n                visited[i] = true;\\n                List<List<Integer>> subs = permuteUniqueDfs(pos + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                visited[i] = false;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    String s;\\n    Map<Integer, List<List<String>>> cache;\\n    public List<List<String>> partition(String s) {\\n        this.s = s;\\n        this.cache = new HashMap<>();\\n        return partitionDfs(0);\\n    }\\n    \\n    private List<List<String>>  partitionDfs(int start) {\\n        if(start == s.length()) {\\n            List<List<String>> res = new ArrayList<>();\\n            List<String> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        if(cache.containsKey(start)){\\n            return cache.get(start);\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String cur = s.substring(start, i);\\n            if(isValid(cur)) {\\n                List<List<String>> subs = partitionDfs(i);\\n                for (List<String> sub: subs) {\\n                    List<String> prefix_item = new ArrayList<>();\\n                    prefix_item.add(cur);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                }\\n            }\\n        }\\n        cache.put(start, res);\\n        return res;\\n    }\\n    \\n    private boolean isValid(String str) {\\n        int l = 0;\\n        int r = str.length() - 1;    \\n        while(l < r) {\\n            if (str.charAt(l) != str.charAt(r)) return false;\\n            else {\\n                l++;\\n                r--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int k;\\n    int n;\\n    public List<List<Integer>> combine(int n, int k) {\\n        this.k = k;\\n        this.n = n;\\n        return combineDfs(1, 0);\\n    }\\n    \\n    private List<List<Integer>> combineDfs(int start, int len) {\\n        if(len == k) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i <= n; i++) {\\n            List<List<Integer>> subs = combineDfs(i + 1, len + 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(i);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] candidates;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        this.candidates = candidates;\\n        int n = candidates.length;        \\n        return combinationSumDfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSumDfs(int target, int pos) {\\n        if(target < 0) return new ArrayList<>();\\n        \\n        if(this.cache.containsKey(new Pair(target, pos))) {\\n            return this.cache.get(new Pair(target, pos));\\n        }\\n        \\n        if(target == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(target, pos);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n    \\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = pos; i < candidates.length; i++) {\\n            List<List<Integer>> subs = combinationSumDfs(target - candidates[i], i);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(candidates[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(target, pos);\\n        cache.put(pair, res);\\n            \\n        return res;\\n    } \\n}\\n```\n```\\nclass Solution {\\n    int[] candidates;\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        this.candidates = candidates;\\n        return combinationSum2Dfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSum2Dfs(int target, int start) {\\n        if(target == 0){\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;    \\n        }\\n        \\n        if(target < 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i < candidates.length; i++) {\\n            if((i == start || candidates[i] != candidates[i - 1])) {\\n                List<List<Integer>> subs = combinationSum2Dfs(target - candidates[i], i + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> prefix_item = new ArrayList<>();\\n                    prefix_item.add(candidates[i]);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.nums = nums;\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n   int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        this.nums = nums;\\n        Arrays.sort(nums);\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            if(i == start || nums[i] != nums[i - 1]) {\\n                List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n                for (List<Integer> sub : subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                }                \\n            }\\n        }\\n        \\n\\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208963,
                "title": "python-knapsack-solution",
                "content": "This problem sounds very similar to a [well known knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem).\\nIt can be solved here in `O(N^2*target)` time and memory.\\n\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t    cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(n+1)]\\n        for i in range(n+1):\\n            dp[i][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            for s in range(1, target+1):\\n                dp[i][s] = dp[i-1][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[i-1][s-cands[i-1]]:\\n                    dp[i][s].add(comb+(cands[i-1],))\\n                    \\n        return [list(var) for var in dp[n][target]]\\n```\\n\\nOf course, we can save some memory because we use only previous row (`O(target*N)`). Smth like following:\\n\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(2)]\\n        dpIdx = 0\\n        dp[dpIdx][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            dpIdx2 = 1 - dpIdx\\n            dp[dpIdx2][0] = set([tuple()])\\n            for s in range(1, target+1):\\n                dp[dpIdx2][s] = dp[dpIdx][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[dpIdx][s-cands[i-1]]:\\n                    dp[dpIdx2][s].add(comb+(cands[i-1],))\\n                    \\n            print(dp[dpIdx2])\\n            dpIdx = dpIdx2\\n                    \\n        return [list(var) for var in dp[dpIdx][target]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t    cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(n+1)]\\n        for i in range(n+1):\\n            dp[i][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            for s in range(1, target+1):\\n                dp[i][s] = dp[i-1][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[i-1][s-cands[i-1]]:\\n                    dp[i][s].add(comb+(cands[i-1],))\\n                    \\n        return [list(var) for var in dp[n][target]]\\n```\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(2)]\\n        dpIdx = 0\\n        dp[dpIdx][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            dpIdx2 = 1 - dpIdx\\n            dp[dpIdx2][0] = set([tuple()])\\n            for s in range(1, target+1):\\n                dp[dpIdx2][s] = dp[dpIdx][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[dpIdx][s-cands[i-1]]:\\n                    dp[dpIdx2][s].add(comb+(cands[i-1],))\\n                    \\n            print(dp[dpIdx2])\\n            dpIdx = dpIdx2\\n                    \\n        return [list(var) for var in dp[dpIdx][target]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204663,
                "title": "lessons-learned",
                "content": "How this differs from Combination Sum 1 is this has **duplicate** elements and shouldn\\'t use the number at same index multiple times.\\n\\n**Related problems**: All try to teach recursion + loop combo\\n* https://leetcode.com/problems/permutations/ : **(Basics)** on every recursion, iteration starts from 0th index \\n* https://leetcode.com/problems/permutations-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern \\n* https://leetcode.com/problems/combinations/ : **(Basics)** on every recursion, iteration starts from next index (ie, adjacent index to parent recursion iteration index) \\n* https://leetcode.com/problems/combination-sum/ : **(Basics)** sorting helps to prune\\n* https://leetcode.com/problems/combination-sum-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern and Sort+skip adjacent duplicate elements pattern\\n* https://leetcode.com/problems/restore-ip-addresses/ : **(Advanced)** includes special char \\'.\\', StringBuilder, number conversion, number validity check, looped deletion\\n* https://leetcode.com/problems/24-game/ : **(Advanced)** \\n* If you have done the above problems, no need to do: https://leetcode.com/problems/combination-sum-iii/, https://leetcode.com/problems/subsets/, https://leetcode.com/problems/subsets-ii/, https://leetcode.com/problems/letter-combinations-of-a-phone-number/ . These are very similar to the above ones and you won\\'t gain much from these.\\n\\n\\n**Code**:\\n```\\n// Optimzed approach 3 by Pruning recursion\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        // if (target < 0) return; // Better to exit early from for loop using `nums[i] <= target` so no need to recurse for further million elements just to get returned at \\'(target < 0) return;\\'\\n \\xA0 \\xA0 \\xA0 \\xA0for (int i = start; i < nums.length && nums[i] <= target; ++i) { // Prune current recursion with nums[i] <= target \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Approach 3 that I would come up with during interview: Sort and skip duplicates in the same recursive loop.\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2 This along with .sort() removes duplicate combinations.\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Approach 2 commonly used for permutation and combination problems when duplicate elements are involved: frequency Hashmap \\nclass Solution {\\n  \\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        recurse(target, map, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int target, Map<Integer, Integer> map, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (target < 0) return;\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int num = entry.getKey();\\n            int count = entry.getValue();\\n            if (count <= 0 || (!tempList.isEmpty() && num < tempList.get(tempList.size() - 1))) continue; // Second condition of taking only increaing sequence (or a decreasing seq) is what turns a permuation into a combination\\n            \\n            tempList.add(num);\\n            map.put(num, count - 1);\\n            recurse(target - num, map, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n            map.put(num, count);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Approach 1 or bruteforce approach: Simply add HashSet to Combination Sum 1 to remove duplicate combinations\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        Set<List<Integer>> ans = new HashSet();\\n        Arrays.sort(nums);  // 1: Order of elements in List is important when List is used as key in HashSet\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, Set<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Optimzed approach 3 by Pruning recursion\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        // if (target < 0) return; // Better to exit early from for loop using `nums[i] <= target` so no need to recurse for further million elements just to get returned at \\'(target < 0) return;\\'\\n \\xA0 \\xA0 \\xA0 \\xA0for (int i = start; i < nums.length && nums[i] <= target; ++i) { // Prune current recursion with nums[i] <= target \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Approach 3 that I would come up with during interview: Sort and skip duplicates in the same recursive loop.\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2 This along with .sort() removes duplicate combinations.\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Approach 2 commonly used for permutation and combination problems when duplicate elements are involved: frequency Hashmap \\nclass Solution {\\n  \\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        recurse(target, map, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int target, Map<Integer, Integer> map, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (target < 0) return;\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int num = entry.getKey();\\n            int count = entry.getValue();\\n            if (count <= 0 || (!tempList.isEmpty() && num < tempList.get(tempList.size() - 1))) continue; // Second condition of taking only increaing sequence (or a decreasing seq) is what turns a permuation into a combination\\n            \\n            tempList.add(num);\\n            map.put(num, count - 1);\\n            recurse(target - num, map, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n            map.put(num, count);\\n        }\\n    }\\n}\\n```\n```\\n// Approach 1 or bruteforce approach: Simply add HashSet to Combination Sum 1 to remove duplicate combinations\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        Set<List<Integer>> ans = new HashSet();\\n        Arrays.sort(nums);  // 1: Order of elements in List is important when List is used as key in HashSet\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, Set<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197125,
                "title": "backtracking-with-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>result;\\n    void helper(vector<int>& candidates,int index,int n,vector<int>&interim,int target)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(interim);\\n            return;\\n            \\n        }\\n        if(index == n)\\n            return;\\n        for(int i = index;i<n;i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                interim.push_back(candidates[i]);\\n                helper(candidates,i+1,n,interim,target-candidates[i]);\\n                interim.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n       int n = candidates.size();\\n        vector<int>interim;\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,n,interim,target);\\n        set<vector<int>>pq;\\n        for(auto i:result)\\n        pq.insert(i);\\n        vector<vector<int>>result1;\\n        for(auto i:pq)\\n        {\\n            result1.push_back(i);\\n        }\\n        return result1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>result;\\n    void helper(vector<int>& candidates,int index,int n,vector<int>&interim,int target)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(interim);\\n            return;\\n            \\n        }\\n        if(index == n)\\n            return;\\n        for(int i = index;i<n;i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                interim.push_back(candidates[i]);\\n                helper(candidates,i+1,n,interim,target-candidates[i]);\\n                interim.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n       int n = candidates.size();\\n        vector<int>interim;\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,n,interim,target);\\n        set<vector<int>>pq;\\n        for(auto i:result)\\n        pq.insert(i);\\n        vector<vector<int>>result1;\\n        for(auto i:pq)\\n        {\\n            result1.push_back(i);\\n        }\\n        return result1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906626,
                "title": "java-backtracking-sorting-to-avoid-duplicates-dfs",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ansList = new LinkedList<>();\\n        Arrays.sort(candidates); //sorting helps avoid duplicates\\n        solve(candidates, candidates.length, target, 0, ansList, new LinkedList<>());\\n        return ansList;\\n    }\\n    \\n    void solve(int[]arr,int n, int target, int start, List<List<Integer>> ansList, List<Integer> subList){\\n        \\n        if(target == 0){\\n            ansList.add(new LinkedList<>(subList));\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++){\\n            if(i>start && arr[i] == arr[i-1]) continue; //avoid duplicates\\n            if(target - arr[i] < 0) continue;\\n            subList.add(arr[i]);\\n            solve(arr,n,target-arr[i],i+1,ansList,subList);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ansList = new LinkedList<>();\\n        Arrays.sort(candidates); //sorting helps avoid duplicates\\n        solve(candidates, candidates.length, target, 0, ansList, new LinkedList<>());\\n        return ansList;\\n    }\\n    \\n    void solve(int[]arr,int n, int target, int start, List<List<Integer>> ansList, List<Integer> subList){\\n        \\n        if(target == 0){\\n            ansList.add(new LinkedList<>(subList));\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++){\\n            if(i>start && arr[i] == arr[i-1]) continue; //avoid duplicates\\n            if(target - arr[i] < 0) continue;\\n            subList.add(arr[i]);\\n            solve(arr,n,target-arr[i],i+1,ansList,subList);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843631,
                "title": "simple-12ms-c-backtrack-explain-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int req_sum;\\n    vector<vector<int>> ans;  // We will return this as final ans\\n    int l ; //this i is the size required and size of our candidates array\\n    void helper(vector<int>& candidates,int index,int sum,vector<int>& v){\\n        if(sum==req_sum)ans.push_back(v); //We have our solution\\n        if(index>=candidates.size() || sum>req_sum)return; // Just to check overflow conditions\\n        for(int i=index;i<l;i++){\\n            if(i>index && candidates[i]==candidates[i-1])continue; //Avoiding Duplicates as array is sorted prev like [1,1,6,7] index C[0]==C[1] so we should leave this.\\n            v.push_back(candidates[i]);\\n            helper(candidates,i+1,sum+candidates[i],v); // Recursive Call with the next index\\n            \\n            v.pop_back();  // Backtracking simply if we return from above statement then we will pop_back as last inserted element must be in either of these conditions i>c.size() || sum>req_sum \\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        req_sum=target;\\n        vector<int> v;\\n        l=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,0,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int req_sum;\\n    vector<vector<int>> ans;  // We will return this as final ans\\n    int l ; //this i is the size required and size of our candidates array\\n    void helper(vector<int>& candidates,int index,int sum,vector<int>& v){\\n        if(sum==req_sum)ans.push_back(v); //We have our solution\\n        if(index>=candidates.size() || sum>req_sum)return; // Just to check overflow conditions\\n        for(int i=index;i<l;i++){\\n            if(i>index && candidates[i]==candidates[i-1])continue; //Avoiding Duplicates as array is sorted prev like [1,1,6,7] index C[0]==C[1] so we should leave this.\\n            v.push_back(candidates[i]);\\n            helper(candidates,i+1,sum+candidates[i],v); // Recursive Call with the next index\\n            \\n            v.pop_back();  // Backtracking simply if we return from above statement then we will pop_back as last inserted element must be in either of these conditions i>c.size() || sum>req_sum \\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        req_sum=target;\\n        vector<int> v;\\n        l=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,0,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737513,
                "title": "c-easy-solution-easytounderstand",
                "content": "```\\n/*\\nRuntime: 12 ms, faster than 66.49% of C++ online submissions for Combination Sum II.\\nMemory Usage: 10.7 MB, less than 80.44% of C++ online submissions for Combination Sum II.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> combination;\\n    vector<vector<int>> finalAnswer;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        if(candidates.size()==0){return finalAnswer;}\\n        sort(candidates.begin(),candidates.end()); //[1,1,2,5,6,7,10] target = 8\\n        int currentIndex = 0;\\n        CheckForSum(candidates, target, currentIndex);\\n        return finalAnswer;\\n    }\\n\\n    void CheckForSum(vector<int>& candidates, int target, int idx){\\n        if(target==0){\\n            if(isPresentIn2dArray(finalAnswer,combination)==true){\\n                return;\\n            }else{\\n                finalAnswer.push_back(combination);\\n            return;\\n            }\\n\\n\\n        }\\n        for(int i = idx; i<candidates.size();i++){\\n            if(target<candidates[i]) break;\\n            combination.push_back(candidates[i]);\\n            CheckForSum(candidates,target-candidates[i], i+1);\\n            combination.pop_back();\\n        } \\n    }\\n\\n    bool isPresentIn2dArray( vector<vector<int>>& finalAnswer, vector<int>& combination ){\\n        bool isPresent = find(finalAnswer.begin(), finalAnswer.end(), combination) != finalAnswer.end();\\n        return isPresent;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\nRuntime: 12 ms, faster than 66.49% of C++ online submissions for Combination Sum II.\\nMemory Usage: 10.7 MB, less than 80.44% of C++ online submissions for Combination Sum II.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> combination;\\n    vector<vector<int>> finalAnswer;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        if(candidates.size()==0){return finalAnswer;}\\n        sort(candidates.begin(),candidates.end()); //[1,1,2,5,6,7,10] target = 8\\n        int currentIndex = 0;\\n        CheckForSum(candidates, target, currentIndex);\\n        return finalAnswer;\\n    }\\n\\n    void CheckForSum(vector<int>& candidates, int target, int idx){\\n        if(target==0){\\n            if(isPresentIn2dArray(finalAnswer,combination)==true){\\n                return;\\n            }else{\\n                finalAnswer.push_back(combination);\\n            return;\\n            }\\n\\n\\n        }\\n        for(int i = idx; i<candidates.size();i++){\\n            if(target<candidates[i]) break;\\n            combination.push_back(candidates[i]);\\n            CheckForSum(candidates,target-candidates[i], i+1);\\n            combination.pop_back();\\n        } \\n    }\\n\\n    bool isPresentIn2dArray( vector<vector<int>>& finalAnswer, vector<int>& combination ){\\n        bool isPresent = find(finalAnswer.begin(), finalAnswer.end(), combination) != finalAnswer.end();\\n        return isPresent;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632658,
                "title": "java-2-ms-faster-than-98-12-recursive-backtrack",
                "content": "same as [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/632645/Java-2-ms-faster-than-99.46) and [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/632691/Java-0-ms-faster-than-100.00-RecursiveandBacktrack).\\n```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<>();\\n    if (candidates.length == 0 || candidates[0] > target) {\\n        return res;\\n    }\\n    res = recursive(candidates, target, 0);\\n    return res;\\n}\\n\\npublic List<List<Integer>> recursive(int[] arr, int target, int start) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    if (start >= arr.length || arr[start] > target) {\\n        return res;\\n    }\\n    if (target == arr[start]) {\\n        List<Integer> t = new ArrayList<>();\\n        t.add(arr[start]);\\n        res.add(t);\\n        return res;\\n    }\\n\\n    for (int j = start; j < arr.length; j++) {\\n        if (target == arr[j]) {\\n            List<Integer> t = new ArrayList<>();\\n            t.add(arr[j]);\\n            res.add(t);\\n            break;\\n        }\\n        List<List<Integer>> temp = recursive(arr, target - arr[j], j + 1);\\n        if (!temp.isEmpty()) {\\n            for (List<Integer> t : temp) {\\n                t.add(0, arr[j]);\\n                res.add(t);\\n            }\\n            //remove the same res\\n            while(j + 1 < arr.length && arr[j] == arr[j + 1]){\\n                j++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<>();\\n    if (candidates.length == 0 || candidates[0] > target) {\\n        return res;\\n    }\\n    res = recursive(candidates, target, 0);\\n    return res;\\n}\\n\\npublic List<List<Integer>> recursive(int[] arr, int target, int start) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    if (start >= arr.length || arr[start] > target) {\\n        return res;\\n    }\\n    if (target == arr[start]) {\\n        List<Integer> t = new ArrayList<>();\\n        t.add(arr[start]);\\n        res.add(t);\\n        return res;\\n    }\\n\\n    for (int j = start; j < arr.length; j++) {\\n        if (target == arr[j]) {\\n            List<Integer> t = new ArrayList<>();\\n            t.add(arr[j]);\\n            res.add(t);\\n            break;\\n        }\\n        List<List<Integer>> temp = recursive(arr, target - arr[j], j + 1);\\n        if (!temp.isEmpty()) {\\n            for (List<Integer> t : temp) {\\n                t.add(0, arr[j]);\\n                res.add(t);\\n            }\\n            //remove the same res\\n            while(j + 1 < arr.length && arr[j] == arr[j + 1]){\\n                j++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 631916,
                "title": "c-easy-solution-pattern-in-combination-sum-1-2-and-3",
                "content": "Try to think of it as a graph with `n` nodes and `O(n^2)` edges. Then, all we need to do is do dfs and see what branches are satisfying the condition that question is asking for. \\nIf you are facing problem in following the dfs approach (_recursion fear_), try creating a graph for the the `candidates` array and write a bfs to find the sum. Once you get the hang of how the branches of graph are playing out, try writing the recursive dfs for it.\\n\\n**Combination Sum 1:**\\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\\n\\n\\n**Combination Sum 2:**\\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n        \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\\n\\n**Combination Sum 3:**\\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState, int k) {\\n        if (t==0) {if (currentState.size() ==k) finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState, k);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int> > res;\\n        vector<int> candidates;\\n        for (int i = 1; i <= 9; i++) candidates.push_back(i);\\n        vector<int> temp;\\n        recurse(n, candidates, 0, temp, res, k);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n        \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState, int k) {\\n        if (t==0) {if (currentState.size() ==k) finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState, k);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int> > res;\\n        vector<int> candidates;\\n        for (int i = 1; i <= 9; i++) candidates.push_back(i);\\n        vector<int> temp;\\n        recurse(n, candidates, 0, temp, res, k);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615729,
                "title": "java-dfs-solution-beat-98-with-clear-explanations",
                "content": "We illustrate the depth first search (DFS) method to enumerate all possible combinations that satisfy the sum requirement using the example:\\ncandidates =\\xA0[2,5,2,1,2], target =\\xA05\\n1. We first sort the array and it becomes candidates =\\xA0[1, 2, 2, 2, 5]. This is needed because one can easily get rid of redundant answers while searching.\\n2.   Generate the search tree by adding one element at a time to the current list (in the order dictated by the order of the array candidates). Also, to avoid duplicates, each distinct number is allowed to be used only once for each level. In our example, this means the left graph is correct, not the right one.\\n<img src=\"https://assets.leetcode.com/users/jzhao0105/image_1589212751.png\" width=\"600\"/>\\n3. To implement the DFS recursive solution,  we need to traverse all nodes of the tree above and check if the sum of the elements in the list is equal to target. Once a solution is found (e.g. curList = [1, 2, 2]), we (deep) copy it and add it to the answer list. Also, we backtrack (i.e. remove the last element from curList [1, 2, 2] -> [1, 2] so that in the next step of recursion [1, 2, 5] will be considered too.)\\n4. Time complexity: O(S*N), where S = the number of answers (= length of ans array = 2 in our example) and N = the (average) time that is needed to construct each answer. (e.g. time to traverse the tree and find the list [1, 2, 2]).\\t\\n\\t\\n\\t\\n\\t\\t// Key observation: To eliminate all possible duplicate answers, we only need to\\n\\t\\t// remove all the duplicate candidates at the same level of the search tree\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\t\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\n\\t\\t\\t\\tArrays.sort(candidates);\\n\\t\\t\\t\\tdfs(candidates, target, 0, new ArrayList<Integer>(), ans);\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate void dfs(int[] candidates, int target, int index, \\n\\t\\t\\t\\t\\t\\t\\t List<Integer> curList, List<List<Integer>> ans) {\\n\\t\\t\\t\\tif (target == 0) {\\n\\t\\t\\t\\t\\t// Deep copy curList to ans\\n\\t\\t\\t\\t\\tans.add(new ArrayList<Integer>(curList));\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor (int i = index; i < candidates.length; i++) {\\n\\t\\t\\t\\t\\tif (candidates[i] > target) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Remove duplicate candidates at the same level of the tree\\n\\t\\t\\t\\t\\tif (i > index && candidates[i] == candidates[i - 1]) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurList.add(candidates[i]);\\n\\t\\t\\t\\t\\tdfs(candidates, target - candidates[i], i + 1, curList, ans);\\n\\t\\t\\t\\t\\tcurList.remove(curList.size() - 1); // Backtrack\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\t\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\n\\t\\t\\t\\tArrays.sort(candidates);\\n\\t\\t\\t\\tdfs(candidates, target, 0, new ArrayList<Integer>(), ans);\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 543026,
                "title": "go-backtrack",
                "content": "```\\nvar res [][]int\\nvar candis []int\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n\\tres = nil\\n\\tcandis = candidates\\n\\n\\tsort.Ints(candidates)\\n\\tbacktrack(target, nil, 0)\\n\\treturn res\\n}\\n\\nfunc backtrack(target int, cur []int, index int) {\\n\\tif target == 0 {\\n\\t\\tres = append(res, append([]int{}, cur...))\\n\\t\\treturn\\n\\t}\\n\\n\\tif target < 0 {\\n\\t\\treturn\\n\\t}\\n\\n    for i := index; i < len(candis); i++ {\\n        if i > index && candis[i] == candis[i-1] {\\n            continue \\n        }\\n\\t\\tbacktrack(target-candis[i], append(cur, candis[i]), i+1)\\n\\t}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar res [][]int\\nvar candis []int\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n\\tres = nil\\n\\tcandis = candidates\\n\\n\\tsort.Ints(candidates)\\n\\tbacktrack(target, nil, 0)\\n\\treturn res\\n}\\n\\nfunc backtrack(target int, cur []int, index int) {\\n\\tif target == 0 {\\n\\t\\tres = append(res, append([]int{}, cur...))\\n\\t\\treturn\\n\\t}\\n\\n\\tif target < 0 {\\n\\t\\treturn\\n\\t}\\n\\n    for i := index; i < len(candis); i++ {\\n        if i > index && candis[i] == candis[i-1] {\\n            continue \\n        }\\n\\t\\tbacktrack(target-candis[i], append(cur, candis[i]), i+1)\\n\\t}\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 511148,
                "title": "javascript-es6-without-push-pop",
                "content": "```\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    let results = [];\\n    candidates.sort((a,b) => a-b);\\n    \\n    const helper = (start, target, combinations=[]) => {\\n        if(target === 0){\\n            results.push([...combinations]);\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length && target-candidates[i] >= 0; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n\\n            helper(i+1, target-candidates[i], [...combinations, candidates[i]]);\\n        }\\n    }\\n    \\n    helper(0, target)\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    let results = [];\\n    candidates.sort((a,b) => a-b);\\n    \\n    const helper = (start, target, combinations=[]) => {\\n        if(target === 0){\\n            results.push([...combinations]);\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length && target-candidates[i] >= 0; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n\\n            helper(i+1, target-candidates[i], [...combinations, candidates[i]]);\\n        }\\n    }\\n    \\n    helper(0, target)\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481687,
                "title": "python3-backtracking-dp",
                "content": "**Approach 1 -- backtracking**\\nKeep track of a list of existing numbers and residual. When residual drops to 0, add list to answer. Similar to this [thread](https://leetcode.com/problems/combination-sum/discuss/481569/Python3-use-a-stack-to-traverse-the-solution-space-through-backtracking). \\n\\nImplementation :\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        \\n        def fn(i, val): \\n            \"\"\"Populate ans via stack.\"\"\"\\n            if val == 0: ans.append(stack.copy())\\n            elif val > 0: \\n                for ii in range(i, len(candidates)): \\n                    if i == ii or candidates[ii-1] != candidates[ii]: \\n                        stack.append(candidates[ii])\\n                        fn(ii+1, val - candidates[ii])\\n                        stack.pop()\\n            \\n        ans, stack = [], []\\n        fn(0, target)\\n        return ans\\n```\\nAnalysis:\\nTime complexity `O(2^N)`\\nSpace complexity `O(2^N)`\\n\\n**Approach 2 -- dp**\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target+1)]\\n        dp[0].add(())\\n        for x in candidates: \\n            for i in reversed(range(target)): \\n                if x + i <= target: \\n                    for seq in dp[i]: \\n                        dp[i+x].add(seq + (x,))\\n        return dp[-1]\\n```\\n\\nComment: \\nNote the similarity to that of [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/481569/Python3-A-concise-implementation-of-backtracking-algo).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        \\n        def fn(i, val): \\n            \"\"\"Populate ans via stack.\"\"\"\\n            if val == 0: ans.append(stack.copy())\\n            elif val > 0: \\n                for ii in range(i, len(candidates)): \\n                    if i == ii or candidates[ii-1] != candidates[ii]: \\n                        stack.append(candidates[ii])\\n                        fn(ii+1, val - candidates[ii])\\n                        stack.pop()\\n            \\n        ans, stack = [], []\\n        fn(0, target)\\n        return ans\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target+1)]\\n        dp[0].add(())\\n        for x in candidates: \\n            for i in reversed(range(target)): \\n                if x + i <= target: \\n                    for seq in dp[i]: \\n                        dp[i+x].add(seq + (x,))\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415202,
                "title": "java-2ms-99-99-faster-100-less-memory",
                "content": "```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<List<Integer>>();\\n    helper(candidates, target, 0, res, new ArrayList<Integer>());\\n    return res;\\n}\\n    \\nprivate void helper(int[] candidates, int target, int startId, List<List<Integer>> res, List<Integer> curRes) {\\n\\tif (target == 0) {\\n        res.add(new ArrayList<Integer>(curRes));\\n    } else {\\n        for (int i = startId; i < candidates.length && candidates[i] <= target; i++) {\\n            if (i > startId && candidates[i] == candidates[i - 1]) { // to avoid duplicates skip all equal numbers except the first\\n                continue;\\n            }\\n            curRes.add(candidates[i]);\\n            helper(candidates, target - candidates[i], i + 1, res, curRes);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<List<Integer>>();\\n    helper(candidates, target, 0, res, new ArrayList<Integer>());\\n    return res;\\n}\\n    \\nprivate void helper(int[] candidates, int target, int startId, List<List<Integer>> res, List<Integer> curRes) {\\n\\tif (target == 0) {\\n        res.add(new ArrayList<Integer>(curRes));\\n    } else {\\n        for (int i = startId; i < candidates.length && candidates[i] <= target; i++) {\\n            if (i > startId && candidates[i] == candidates[i - 1]) { // to avoid duplicates skip all equal numbers except the first\\n                continue;\\n            }\\n            curRes.add(candidates[i]);\\n            helper(candidates, target - candidates[i], i + 1, res, curRes);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350011,
                "title": "python-generator-solution",
                "content": "```python\\nclass Solution:\\n    def backtrack(self, candidates, remaining, idx=0, got=[]):\\n        if remaining < 0:\\n            return\\n        \\n        if idx == len(candidates):\\n            if remaining == 0:\\n                yield tuple(got)\\n            return\\n\\n        got.append(candidates[idx])\\n        yield from self.backtrack(candidates, remaining - got[-1], idx + 1)\\n        got.pop()\\n        yield from self.backtrack(candidates, remaining, idx + 1)\\n            \\n        \\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        return set(self.backtrack(candidates, target))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def backtrack(self, candidates, remaining, idx=0, got=[]):\\n        if remaining < 0:\\n            return\\n        \\n        if idx == len(candidates):\\n            if remaining == 0:\\n                yield tuple(got)\\n            return\\n\\n        got.append(candidates[idx])\\n        yield from self.backtrack(candidates, remaining - got[-1], idx + 1)\\n        got.pop()\\n        yield from self.backtrack(candidates, remaining, idx + 1)\\n            \\n        \\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        return set(self.backtrack(candidates, target))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338279,
                "title": "java-backtracking-without-for-loop-bounded-knapsack-pattern",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n         List<List<Integer>> result = new ArrayList<>(); \\n        combinationSumHelper(candidates, target, 0, result, new LinkedList<>());\\n        return result;\\n    }\\n    \\n        public void combinationSumHelper(int[] candidates, int target, int index, List<List<Integer>> result, LinkedList<Integer> temp){\\n       //if you have met the target the add result from temp     \\n       if( target == 0){\\n           result.add(new ArrayList<>(temp));\\n           return;\\n       } \\n        \\n       //coundlnt find the target and exit     \\n       if(index >= candidates.length){\\n           return;\\n       }  \\n        \\n        //case 1: you include the number. for bounded knapsack u can include only once.\\n            //hence increment the index\\n       if(candidates[index] <= target){\\n           temp.add(candidates[index]);\\n           combinationSumHelper(candidates, target-candidates[index], index+1, result, temp);\\n           temp.removeLast();\\n       }  \\n        \\n       //skip duplicate starting points     \\n       while(index+1 < candidates.length && candidates[index]==candidates[index+1]) {\\n           index++;     \\n       }\\n\\n    //case 2: you  dont include the number. same for bounded and unbounded knapsack\\n       combinationSumHelper(candidates,target, index+1, result,temp ); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n         List<List<Integer>> result = new ArrayList<>(); \\n        combinationSumHelper(candidates, target, 0, result, new LinkedList<>());\\n        return result;\\n    }\\n    \\n        public void combinationSumHelper(int[] candidates, int target, int index, List<List<Integer>> result, LinkedList<Integer> temp){\\n       //if you have met the target the add result from temp     \\n       if( target == 0){\\n           result.add(new ArrayList<>(temp));\\n           return;\\n       } \\n        \\n       //coundlnt find the target and exit     \\n       if(index >= candidates.length){\\n           return;\\n       }  \\n        \\n        //case 1: you include the number. for bounded knapsack u can include only once.\\n            //hence increment the index\\n       if(candidates[index] <= target){\\n           temp.add(candidates[index]);\\n           combinationSumHelper(candidates, target-candidates[index], index+1, result, temp);\\n           temp.removeLast();\\n       }  \\n        \\n       //skip duplicate starting points     \\n       while(index+1 < candidates.length && candidates[index]==candidates[index+1]) {\\n           index++;     \\n       }\\n\\n    //case 2: you  dont include the number. same for bounded and unbounded knapsack\\n       combinationSumHelper(candidates,target, index+1, result,temp ); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310039,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 302616,
                "title": "swift-70-beat-intuitive-solution-using-modified-dfs-smarty-logix",
                "content": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        \\n        var candidates = candidates.sorted()\\n        var res = [[Int]]()\\n        var temp = [Int]()\\n        \\n        helper(&res, &temp, candidates, 0, target)\\n        \\n        return res\\n    }\\n    \\n    func helper(_ res: inout [[Int]], _ temp: inout [Int], _ candidates: [Int], _ index: Int, _ target: Int) {\\n        \\n        if target == 0 { res.append(temp); return }\\n        if target < 0 { return }\\n        \\n        for i in index..<candidates.count {\\n            \\n            //Avoid dupes.\\n            if i > index && candidates[i] == candidates[i - 1] { \\n                continue\\n            }\\n            temp.append(candidates[i])\\n            helper(&res, &temp, candidates, i + 1, target - candidates[i])\\n            temp.removeLast()\\n        }\\n    }\\n}\\n```\\n\\nThe trick is to skip the dupes in such a way where you will still get the first \"run\" of the dupes...",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        \\n        var candidates = candidates.sorted()\\n        var res = [[Int]]()\\n        var temp = [Int]()\\n        \\n        helper(&res, &temp, candidates, 0, target)\\n        \\n        return res\\n    }\\n    \\n    func helper(_ res: inout [[Int]], _ temp: inout [Int], _ candidates: [Int], _ index: Int, _ target: Int) {\\n        \\n        if target == 0 { res.append(temp); return }\\n        if target < 0 { return }\\n        \\n        for i in index..<candidates.count {\\n            \\n            //Avoid dupes.\\n            if i > index && candidates[i] == candidates[i - 1] { \\n                continue\\n            }\\n            temp.append(candidates[i])\\n            helper(&res, &temp, candidates, i + 1, target - candidates[i])\\n            temp.removeLast()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302609,
                "title": "c-95-beat-modified-dfs-requires-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        \\n        vector<vector<int>> aResult;\\n        vector<int> aTemp;\\n        \\n        helper(aResult, aTemp, candidates, 0, target);\\n        \\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<int>> &pRes, vector<int> &pTemp, vector<int> &pCandidates, int pIndex, int pTarget) {\\n        \\n        if (pTarget < 0) { return; }\\n        if (pTarget == 0) {\\n            pRes.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int i=pIndex;i<pCandidates.size();i++) {\\n            \\n            if (i > pIndex && pCandidates[i - 1] == pCandidates[i]) { continue; }\\n            \\n            pTemp.push_back(pCandidates[i]);\\n            helper(pRes, pTemp, pCandidates, i + 1, pTarget - pCandidates[i]);\\n            pTemp.pop_back();\\n        }\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        \\n        vector<vector<int>> aResult;\\n        vector<int> aTemp;\\n        \\n        helper(aResult, aTemp, candidates, 0, target);\\n        \\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<int>> &pRes, vector<int> &pTemp, vector<int> &pCandidates, int pIndex, int pTarget) {\\n        \\n        if (pTarget < 0) { return; }\\n        if (pTarget == 0) {\\n            pRes.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int i=pIndex;i<pCandidates.size();i++) {\\n            \\n            if (i > pIndex && pCandidates[i - 1] == pCandidates[i]) { continue; }\\n            \\n            pTemp.push_back(pCandidates[i]);\\n            helper(pRes, pTemp, pCandidates, i + 1, pTarget - pCandidates[i]);\\n            pTemp.pop_back();\\n        }\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170901,
                "title": "python-solution",
                "content": "Recursion:\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            return res\\n        \\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```\\nRecursion with memoization:\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            elif (j, target) in dic:\\n                return dic[(j, target)]\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            dic[(j,target)] = res\\n            return res\\n        \\n        dic = {}\\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            return res\\n        \\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            elif (j, target) in dic:\\n                return dic[(j, target)]\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            dic[(j,target)] = res\\n            return res\\n        \\n        dic = {}\\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16863,
                "title": "java-18-lines-solution",
                "content": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtracing(res, new ArrayList<>(), candidates, target, 0);\\n        return res;\\n    }\\n    private void backtracing(List<List<Integer>> res, List<Integer> tempList, int[] candidates, int target, int pos) {\\n        if (target == 0) res.add(new ArrayList<Integer>(tempList)); \\n        else if (target < 0) return;\\n        else {\\n            for (int i = pos; i < candidates.length; i++) {\\n                if (i > pos && candidates[i] == candidates[i - 1]) continue;\\n                tempList.add(candidates[i]);\\n                backtracing(res, tempList, candidates, target - candidates[i], i + 1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtracing(res, new ArrayList<>(), candidates, target, 0);\\n        return res;\\n    }\\n    private void backtracing(List<List<Integer>> res, List<Integer> tempList, int[] candidates, int target, int pos) {\\n        if (target == 0) res.add(new ArrayList<Integer>(tempList)); \\n        else if (target < 0) return;\\n        else {\\n            for (int i = pos; i < candidates.length; i++) {\\n                if (i > pos && candidates[i] == candidates[i - 1]) continue;\\n                tempList.add(candidates[i]);\\n                backtracing(res, tempList, candidates, target - candidates[i], i + 1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16893,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Combination Sum II** https://leetcode.com/problems/combination-sum-ii/\\n\\n**Algorithm**\\n* Recursion tree will help you solve this problem. https://goo.gl/photos/vEDezZoWctf7CgfM8\\n* Combination Sum I allowed duplicates. To avoid those, in the recursive call, use i + 1.\\n* Now other duplicates are also possible. Imagine [1,2,5, 7, 1] and target as 8. If we use DFS we will get [1,7] and then [7,1]. How do we avoid this?\\n* Sort candidates: [1,1,2,5,7]. Now when you start with index 0, your first element will be 1. It will allow you to pick the second element as 1 too. You will be able to pick [1,7]. But during recursion, when you reach the next start index as 1, your recursion tree will again start from 1. This will lead to a duplicate [1,7]. You want to avoid this.\\n\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result = []\\n        candidates.sort()\\n        self.helper(0, candidates, target, [], result, 0)\\n        return result\\n\\n    def helper(self, idx, candidates, target, so_far, result, sum_so_far):\\n        if sum_so_far == target:\\n            result.append([x for x in so_far])\\n        else:\\n            for i in range(idx, len(candidates)):\\n                if i == idx or candidates[i] != candidates[i-1]:\\n                    if sum_so_far + candidates[i] <= target:\\n                        so_far.append(candidates[i])\\n                        self.helper(i+1, candidates, target, so_far, result, sum_so_far + candidates[i])\\n                        so_far.pop()\\n        return\\n```\\n\\n**Another Implementation**\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        all_solns = []\\n        self.helper([], 0, sorted(candidates), target, all_solns)        \\n        return all_solns\\n\\n    def helper(self, so_far, k, nums, target, all_solns):        \\n        sum_so_far = sum(so_far)\\n        if sum_so_far == target:\\n            all_solns.append([x for x in so_far])\\n        else:\\n            for i in range(k, len(nums)):\\n                if i > k and nums[i] == nums[i-1]:\\n                    continue\\n                if (sum_so_far + nums[i] <= target):\\n                    so_far.append(nums[i])\\n                    self.helper(so_far, i+1, nums, target, all_solns)\\n                    so_far.pop()\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result = []\\n        candidates.sort()\\n        self.helper(0, candidates, target, [], result, 0)\\n        return result\\n\\n    def helper(self, idx, candidates, target, so_far, result, sum_so_far):\\n        if sum_so_far == target:\\n            result.append([x for x in so_far])\\n        else:\\n            for i in range(idx, len(candidates)):\\n                if i == idx or candidates[i] != candidates[i-1]:\\n                    if sum_so_far + candidates[i] <= target:\\n                        so_far.append(candidates[i])\\n                        self.helper(i+1, candidates, target, so_far, result, sum_so_far + candidates[i])\\n                        so_far.pop()\\n        return\\n```\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        all_solns = []\\n        self.helper([], 0, sorted(candidates), target, all_solns)        \\n        return all_solns\\n\\n    def helper(self, so_far, k, nums, target, all_solns):        \\n        sum_so_far = sum(so_far)\\n        if sum_so_far == target:\\n            all_solns.append([x for x in so_far])\\n        else:\\n            for i in range(k, len(nums)):\\n                if i > k and nums[i] == nums[i-1]:\\n                    continue\\n                if (sum_so_far + nums[i] <= target):\\n                    so_far.append(nums[i])\\n                    self.helper(so_far, i+1, nums, target, all_solns)\\n                    so_far.pop()\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16976,
                "title": "19-lines-concise-and-easy-understand-c-solution-backtracking",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, candidates, tmp, 0, target);\\n            return res;\\n        }\\n        void backtracking(vector<vector<int>>& res, vector<int>& candidates, vector<int> tmp, int index, int target){\\n            if(target < 0 )return;\\n            if(target == 0){\\n                res.push_back(tmp);\\n                return;\\n            }\\n            for(int i = index; i < candidates.size(); i++){\\n                if(i == index || candidates[i] != candidates[i - 1]){\\n                    tmp.push_back(candidates[i]);\\n                    backtracking(res, candidates, tmp, i + 1, target - candidates[i]);\\n                    tmp.pop_back();\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, candidates, tmp, 0, target);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17060,
                "title": "my-thoughts-and-solution-to-the-problem-java",
                "content": "Hello, I've solve the problem and I am here to give back to the community. Basically the question is pretty straight forward. I've approached the problem with sorting the array first, and keeping the current value and make recursive call to check for target - current value. Any suggestion on how I can make this code better is much appreciated. Thank you.\\n\\n    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] num, int target) {\\n            if(num.length==0) return new ArrayList<List<Integer>>();\\n            Arrays.sort(num); //sort the array of num so it's easier to manage\\n            List<List<Integer>> result = helper(num,target,0);\\n            if(result==null) return new ArrayList<List<Integer>>();\\n            return result;\\n        }\\n        public List<List<Integer>> helper(int[] num, int target, int index)\\n        {\\n            if(index>=num.length||num[index]>target) return null; //return null if you hit the end\\n            ArrayList<List<Integer>> result = new ArrayList<List<Integer>>();\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            Set<List<Integer>> s = new HashSet<List<Integer>>(); //check if there is no duplicates\\n            for(int i = index;i<num.length;i++)\\n            {\\n                 //if num[i]> target you dont need to check the rest. \\n                 //but it's break here because you still want to keep the rest of the result.\\n                if(num[i]>target) break; \\n                temp = new ArrayList<Integer>();\\n                //if it's found the rest of the numbers can be trimed, save some time on complexity\\n                if(num[i]==target) \\n                {\\n                    temp.add(num[i]);\\n                    result.add(temp);\\n                    return result;\\n                }\\n                ArrayList<List<Integer>> t = (ArrayList)helper(num,target-num[i],i+1);\\n                //t is the temporary ArrayList of the result of your recursion call\\n                // you want to add the value of your current num[i] in the beginning of each\\n                // returned List<Integer> and add it to result if it's not duplicated.\\n                if(t!=null)\\n                {\\n                    for(List<Integer> a:t)\\n                    {\\n                        a.add(0,num[i]);\\n                        if(!s.contains(a)) //make sure there is no duplicates\\n                        {\\n                            s.add(a);\\n                            result.add(a);\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] num, int target) {\\n            if(num.length==0) return new ArrayList<List<Integer>>();\\n            Arrays.sort(num); //sort the array of num so it's easier to manage\\n            List<List<Integer>> result = helper(num,target,0);\\n            if(result==null) return new ArrayList<List<Integer>>();\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4029177,
                "title": "java-easy-100-backtracking-solution",
                "content": "```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        Arrays.sort(candidates);\\n\\n        this.backTrack(candidates, target, 0, new ArrayList<>(), result);\\n\\n        return result;\\n    }\\n\\n    private void backTrack(int[] candidates, int target, int start, List<Integer> curr, List<List<Integer>> result) {\\n        if(target == 0) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n\\n        for(int i = start; i < candidates.length; ++i) {\\n            if(i > start && candidates[i] == candidates[i - 1])\\n                continue;\\n\\n            if(candidates[i] > target)\\n                break;\\n\\n            curr.add(candidates[i]);\\n            backTrack(candidates, target - candidates[i], i + 1, curr, result);\\n            curr.remove(curr.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        Arrays.sort(candidates);\\n\\n        this.backTrack(candidates, target, 0, new ArrayList<>(), result);\\n\\n        return result;\\n    }\\n\\n    private void backTrack(int[] candidates, int target, int start, List<Integer> curr, List<List<Integer>> result) {\\n        if(target == 0) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n\\n        for(int i = start; i < candidates.length; ++i) {\\n            if(i > start && candidates[i] == candidates[i - 1])\\n                continue;\\n\\n            if(candidates[i] > target)\\n                break;\\n\\n            curr.add(candidates[i]);\\n            backTrack(candidates, target - candidates[i], i + 1, curr, result);\\n            curr.remove(curr.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998318,
                "title": "c-recursion-backtracking-two-approaches",
                "content": "# Approach 1: Extended Solution to [Combination Sum 1 ](https://leetcode.com/problems/combination-sum/discuss/3994292/C%2B%2B-or-Cpp-or-Cpp-Solution-or-Recursion-%2B-Backtracking) but will give TLE\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int i, int target, vector<int> &comb, set<vector<int>> &result)\\n    { \\n        if(i>=nums.size())\\n        {\\n            if(target==0)\\n            {\\n                result.insert(comb);\\n            }\\n            return;\\n        }\\n\\n        comb.push_back(nums[i]); \\n        helper(nums,i+1,target-nums[i],comb,result); //pick up an element\\n        comb.pop_back();\\n\\t\\t\\n        helper(nums,i+1,target,comb,result); //non pick up an element\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        set<vector<int>> temp;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,temp);\\n        for(auto x:temp)\\n        {\\n            result.push_back(x);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n# Approach 2: Most Optimized Solution \\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int indx, int target,  vector<int> &comb, vector<vector<int>> &result)\\n    {\\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        for(int i=indx;i<nums.size();i++)\\n        {\\n            if(i>indx && nums[i]==nums[i-1])\\n                continue;\\n            \\n            if(nums[i]>target)\\n                break;\\n            \\n            comb.push_back(nums[i]);\\n            helper(nums,i+1,target-nums[i],comb,result);\\n            comb.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int i, int target, vector<int> &comb, set<vector<int>> &result)\\n    { \\n        if(i>=nums.size())\\n        {\\n            if(target==0)\\n            {\\n                result.insert(comb);\\n            }\\n            return;\\n        }\\n\\n        comb.push_back(nums[i]); \\n        helper(nums,i+1,target-nums[i],comb,result); //pick up an element\\n        comb.pop_back();\\n\\t\\t\\n        helper(nums,i+1,target,comb,result); //non pick up an element\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        set<vector<int>> temp;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,temp);\\n        for(auto x:temp)\\n        {\\n            result.push_back(x);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int indx, int target,  vector<int> &comb, vector<vector<int>> &result)\\n    {\\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        for(int i=indx;i<nums.size();i++)\\n        {\\n            if(i>indx && nums[i]==nums[i-1])\\n                continue;\\n            \\n            if(nums[i]>target)\\n                break;\\n            \\n            comb.push_back(nums[i]);\\n            helper(nums,i+1,target-nums[i],comb,result);\\n            comb.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966330,
                "title": "cpp-solution-easy-to-understand",
                "content": "# Intuition\\nThe problem requires finding all unique combinations of numbers from the \\'candidates\\' array that sum up to the \\'target\\' value. However, each number in the \\'candidates\\' array can only be used once in each combination. To solve this efficiently and avoid duplicates, we can use a depth-first search (DFS) algorithm. We will also sort the \\'candidates\\' array to group identical elements together.\\n\\n# Approach\\n1. Initialize an empty vector of vectors \\'res\\' to store the combinations.\\n2. Initialize an empty vector \\'curr\\' to store the current combination being constructed.\\n3. Sort the \\'candidates\\' vector to group identical elements together.\\n4. Call the DFS function \\'dfs\\' with the following parameters: \\'candidates\\', \\'0\\' as the starting index, \\'target\\', \\'0\\' as the initial sum, \\'curr\\', and \\'res\\'.\\n5. In the \\'dfs\\' function:\\n   a. Check if \\'sum\\' is equal to \\'target\\'. If they are equal, it means the current combination in \\'curr\\' is a valid combination that sums up to the \\'target\\'. Therefore, add \\'curr\\' to \\'res\\'.\\n   b. Check if \\'sum\\' is greater than \\'target\\'. If it is, return to avoid further exploration of this branch.\\n   c. Start a loop from the \\'start\\' index to the end of the \\'candidates\\' vector.\\n   d. Inside the loop:\\n      i. Check if \\'i\\' is greater than \\'start\\' and if the current element \\'candidates[i]\\' is the same as the previous element \\'candidates[i-1]\\'. If both conditions are true, skip the current iteration to avoid duplicate combinations.\\n      ii. Add the current element \\'candidates[i]\\' to \\'curr\\'.\\n      iii. Recursively call \\'dfs\\' with the updated \\'candidates\\', \\'i+1\\' as the new starting index to avoid reusing the same element, \\'target\\', \\'sum+candidates[i]\\' as the new sum, \\'curr\\', and \\'res\\'.\\n      iv. Remove the last element from \\'curr\\' to backtrack and explore other possibilities.\\n6. After the DFS is complete, \\'res\\' will contain all unique combinations.\\n7. Return \\'res\\' as the final result.\\n\\n# Complexity\\n- Time complexity: O(2^n * n), where \\'n\\' is the number of elements in \\'candidates\\'. In the worst case, there can be 2^n combinations to generate, and for each combination, we perform sorting with a maximum of \\'n\\' elements.\\n- Space complexity: O(2^n * n) for the \\'res\\' vector to store all combinations and O(n) for the \\'curr\\' vector. The overall space complexity is dominated by the \\'res\\' vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>>res;\\n        vector<int> curr;\\n        sort(candidates.begin(),candidates.end());\\n        dfs(candidates,0,target,0,curr,res);\\n        return res;\\n        \\n    }\\n    void dfs(vector<int> candidates, int start,int target,int sum, vector<int> &curr, vector<vector<int>> &res)\\n    {\\n        if(sum==target)\\n        {\\n            res.push_back(curr);\\n            return;\\n        }\\n        if(sum>target){\\n            return;\\n        }\\n        for(int i=start;i<candidates.size();i++)\\n        {\\n            if(i>start && candidates[i]==candidates[i-1])\\n            continue;\\n            curr.push_back(candidates[i]);\\n            dfs(candidates,i+1,target,sum+candidates[i],curr,res);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>>res;\\n        vector<int> curr;\\n        sort(candidates.begin(),candidates.end());\\n        dfs(candidates,0,target,0,curr,res);\\n        return res;\\n        \\n    }\\n    void dfs(vector<int> candidates, int start,int target,int sum, vector<int> &curr, vector<vector<int>> &res)\\n    {\\n        if(sum==target)\\n        {\\n            res.push_back(curr);\\n            return;\\n        }\\n        if(sum>target){\\n            return;\\n        }\\n        for(int i=start;i<candidates.size();i++)\\n        {\\n            if(i>start && candidates[i]==candidates[i-1])\\n            continue;\\n            curr.push_back(candidates[i]);\\n            dfs(candidates,i+1,target,sum+candidates[i],curr,res);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853451,
                "title": "easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The combinationSum2 method first sorts the candidates array in ascending order. Sorting helps in avoiding duplicates and optimizing the combination generation process.\\n\\n2. It initializes an empty vector ans to store the resulting combinations and an empty vector v to temporarily store a combination during the generation process.\\n\\n3. It calls the combinationSum_helper function with the sorted candidates array, the target value, the empty v vector, ans, and an initial index of 0.\\n\\n4. The combinationSum_helper function is a recursive function that generates combinations. It takes the current index, candidates, the remaining target, the temporary vector v, and the ans vector as parameters.\\n\\n5. In the combinationSum_helper function, the base cases are:\\n\\n   If target becomes 0, it means a valid combination is found. The current v vector is added to the ans vector.\\n   If target becomes negative, it means the current combination is not valid, so it returns.\\n\\n6. The function then iterates through the candidates array, starting from the given index. It avoids duplicates by checking if the current element is the same as the previous element and the current index is greater than the starting index. If this condition is met, the loop continues to the next iteration.\\n\\n7. For each valid candidate, it adds the candidate to the temporary vector v, subtracts the candidate from the remaining target, and makes a recursive call to combinationSum_helper with the updated parameters.\\n\\n8. After the recursive call returns, the last added candidate is removed from the temporary vector v (backtracking).\\n\\n9. The process continues until all combinations are generated.\\n\\n10. The sorted nature of the candidates array helps in avoiding duplicates and optimizing the combination generation process.\\n\\n11. The combinationSum2 method returns the ans vector containing all unique combinations.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void combinationSum_helper(vector<int>&candidates,int target,vector<int>&v,vector<vector<int>>&ans,int index){\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n    if(target<0){\\n        return;\\n    }\\n\\n    for(int i=index;i<candidates.size();i++){\\n        if(i>index && candidates[i]==candidates[i-1]){\\n            continue;\\n        }\\n        v.push_back(candidates[i]);\\n        combinationSum_helper(candidates,target-candidates[i],v,ans,i+1);\\n        v.pop_back();\\n    }\\n\\n\\n\\n\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        combinationSum_helper(candidates,target,v, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combinationSum_helper(vector<int>&candidates,int target,vector<int>&v,vector<vector<int>>&ans,int index){\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n    if(target<0){\\n        return;\\n    }\\n\\n    for(int i=index;i<candidates.size();i++){\\n        if(i>index && candidates[i]==candidates[i-1]){\\n            continue;\\n        }\\n        v.push_back(candidates[i]);\\n        combinationSum_helper(candidates,target-candidates[i],v,ans,i+1);\\n        v.pop_back();\\n    }\\n\\n\\n\\n\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        combinationSum_helper(candidates,target,v, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851424,
                "title": "c-easy-killer-solution-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> refer combination sum solution and combination and subset for more clearity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans={};\\n        vector<int> v;\\n        comb(0,nums,v,ans,target);\\n        return ans;\\n    }\\n    void comb(int start,vector<int>& nums,vector<int>& v,vector<vector<int>>&ans,int target)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n        for(int i=start;i<nums.size();i++)\\n        {\\n            if(i>start&&nums[i]==nums[i-1])continue;\\n            v.push_back(nums[i]);\\n            comb(i+1,nums,v,ans,target-nums[i]);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans={};\\n        vector<int> v;\\n        comb(0,nums,v,ans,target);\\n        return ans;\\n    }\\n    void comb(int start,vector<int>& nums,vector<int>& v,vector<vector<int>>&ans,int target)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n        for(int i=start;i<nums.size();i++)\\n        {\\n            if(i>start&&nums[i]==nums[i-1])continue;\\n            v.push_back(nums[i]);\\n            comb(i+1,nums,v,ans,target-nums[i]);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847301,
                "title": "python-99-53-faster-backtracking-easy",
                "content": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def solve(ind,target):\\n            if target==0:\\n                ans.append(op[:])\\n                return \\n            for i in range(ind,len(candidates)):\\n                if i>ind and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                op.append(candidates[i])\\n                solve(i+1,target-candidates[i])\\n                op.pop()\\n        candidates.sort()\\n        ans=[]\\n        op=[]\\n        solve(0,target)\\n        return ans\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def solve(ind,target):\\n            if target==0:\\n                ans.append(op[:])\\n                return \\n            for i in range(ind,len(candidates)):\\n                if i>ind and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                op.append(candidates[i])\\n                solve(i+1,target-candidates[i])\\n                op.pop()\\n        candidates.sort()\\n        ans=[]\\n        op=[]\\n        solve(0,target)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718563,
                "title": "c-super-easy-clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void solver(int i, int target, vector<int>& candi, vector<int>& res, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(res);\\n            return;\\n        }\\n        if(i == candi.size()){\\n            return;\\n        }\\n\\n        if(candi[i] <= target){\\n            res.push_back(candi[i]);\\n            solver(i+1,target-candi[i],candi,res,ans);\\n            res.pop_back();\\n        }\\n\\n        while(i+1<candi.size() && candi[i] == candi[i+1]){\\n            i++;\\n        }\\n        // 1,1,1,2,2,3,4,5,6\\n        solver(i+1,target,candi,res,ans);\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> res;\\n        solver(0,target,candidates,res,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solver(int i, int target, vector<int>& candi, vector<int>& res, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(res);\\n            return;\\n        }\\n        if(i == candi.size()){\\n            return;\\n        }\\n\\n        if(candi[i] <= target){\\n            res.push_back(candi[i]);\\n            solver(i+1,target-candi[i],candi,res,ans);\\n            res.pop_back();\\n        }\\n\\n        while(i+1<candi.size() && candi[i] == candi[i+1]){\\n            i++;\\n        }\\n        // 1,1,1,2,2,3,4,5,6\\n        solver(i+1,target,candi,res,ans);\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> res;\\n        solver(0,target,candidates,res,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473396,
                "title": "easy-java-solution-2ms-beats-99-69",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> finalList = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        helper(0, candidates, target,new ArrayList<Integer>(),finalList );\\n        return finalList;\\n    }\\n    public void helper(int index, int[] arr, int target, ArrayList<Integer> list, List<List<Integer>> finalList){\\n        \\n            if(target == 0){\\n                finalList.add(new ArrayList<>(list));\\n                return;\\n            }\\n            \\n        \\n        for(int i = index;i<arr.length;i++){\\n            if(i != index && arr[i] == arr[i-1]){\\n                continue;\\n            }\\n            if(arr[i] > target){break;}\\n            list.add(arr[i]);\\n            helper(i+1,arr,target-arr[i],list,finalList);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> finalList = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        helper(0, candidates, target,new ArrayList<Integer>(),finalList );\\n        return finalList;\\n    }\\n    public void helper(int index, int[] arr, int target, ArrayList<Integer> list, List<List<Integer>> finalList){\\n        \\n            if(target == 0){\\n                finalList.add(new ArrayList<>(list));\\n                return;\\n            }\\n            \\n        \\n        for(int i = index;i<arr.length;i++){\\n            if(i != index && arr[i] == arr[i-1]){\\n                continue;\\n            }\\n            if(arr[i] > target){break;}\\n            list.add(arr[i]);\\n            helper(i+1,arr,target-arr[i],list,finalList);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373591,
                "title": "pyhton3-backtrack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res=[]\\n        currset=[]\\n        subset=[]\\n        def helper(i,candidates,currset,subset):\\n            if sum(currset)==target:\\n                subset.append(currset.copy())\\n                return \\n\\n            if(sum(currset)>target) or i>=len(candidates) :\\n                return\\n            currset.append(candidates[i])\\n            helper(i+1,candidates,currset,subset)\\n\\n            currset.pop()\\n\\n            while i+1<len(candidates) and candidates[i]==candidates[i+1]:\\n                i+=1\\n\\n            helper(i+1,candidates,currset,subset)\\n\\n        helper(0,candidates,currset,subset)\\n        return subset\\n\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res=[]\\n        currset=[]\\n        subset=[]\\n        def helper(i,candidates,currset,subset):\\n            if sum(currset)==target:\\n                subset.append(currset.copy())\\n                return \\n\\n            if(sum(currset)>target) or i>=len(candidates) :\\n                return\\n            currset.append(candidates[i])\\n            helper(i+1,candidates,currset,subset)\\n\\n            currset.pop()\\n\\n            while i+1<len(candidates) and candidates[i]==candidates[i+1]:\\n                i+=1\\n\\n            helper(i+1,candidates,currset,subset)\\n\\n        helper(0,candidates,currset,subset)\\n        return subset\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346744,
                "title": "efficient-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo make combination we need to use the \"Pick\" and \"Not pick\" method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe entire approach is same as Combination I.\\nBut, to ignore duplicate combination -->\\n- First we need to sort the given vector, so that all the duplicate elements of the given vector will be consecutively placed.\\n- Then, When we are about to \"Not pick\" an element we need to ignore all the similar consecutive elements. Which job is done by this block of code -->\\n```\\nwhile(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSame as Combination I\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSame as Combination I\\n\\nMy Combination I solution link \\uD83D\\uDC47\\nhttps://leetcode.com/problems/combination-sum/solutions/3344753/100-beats-easy-to-understand-c-code/\\n\\nPlease upvote if you find it helpful \\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void help(int i,int t,vector<int>& c,vector<int>&temp){\\n        if(t==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(t<0){\\n            return;\\n        }\\n        if(i==c.size()){\\n            return;\\n        }\\n        temp.push_back(c[i]);\\n        help(i+1,t-c[i],c,temp);\\n        temp.pop_back();\\n        while(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n        help(i+1,t,c,temp);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& c, int t) {\\n        vector<int>temp;\\n        sort(c.begin(),c.end());\\n        help(0,t,c,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nwhile(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void help(int i,int t,vector<int>& c,vector<int>&temp){\\n        if(t==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(t<0){\\n            return;\\n        }\\n        if(i==c.size()){\\n            return;\\n        }\\n        temp.push_back(c[i]);\\n        help(i+1,t-c[i],c,temp);\\n        temp.pop_back();\\n        while(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n        help(i+1,t,c,temp);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& c, int t) {\\n        vector<int>temp;\\n        sort(c.begin(),c.end());\\n        help(0,t,c,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294871,
                "title": "recursion-java-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,target,candidates,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    public void solve(int ind,int target,int[]candidates,List<List<Integer>>ans,ArrayList<Integer>temp){\\n        if(target==0){\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\n        for(int i=ind;i<candidates.length;i++){\\n            if(i!=ind && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n\\n            temp.add(candidates[i]);\\n            solve(i+1,target-candidates[i],candidates,ans,temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,target,candidates,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    public void solve(int ind,int target,int[]candidates,List<List<Integer>>ans,ArrayList<Integer>temp){\\n        if(target==0){\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\n        for(int i=ind;i<candidates.length;i++){\\n            if(i!=ind && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n\\n            temp.add(candidates[i]);\\n            solve(i+1,target-candidates[i],candidates,ans,temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248311,
                "title": "java-simple-powerfull",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        combination2( 0,candidates, target, res, list);\\n        return res;\\n    }\\n    public void combination2(int index, int[] arr, int target, List<List<Integer>> res, List<Integer> list){\\n        if(target == 0){\\n            Collections.sort(list);\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i = index;i < arr.length;i++){\\n            if(i > index && arr[i] == arr[i - 1]) continue;\\n            if(target < arr[i]) break;\\n\\n            list.add(arr[i]);\\n            combination2(i + 1, arr, target - arr[i], res, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        combination2( 0,candidates, target, res, list);\\n        return res;\\n    }\\n    public void combination2(int index, int[] arr, int target, List<List<Integer>> res, List<Integer> list){\\n        if(target == 0){\\n            Collections.sort(list);\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i = index;i < arr.length;i++){\\n            if(i > index && arr[i] == arr[i - 1]) continue;\\n            if(target < arr[i]) break;\\n\\n            list.add(arr[i]);\\n            combination2(i + 1, arr, target - arr[i], res, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224015,
                "title": "optimized-solution-2ms-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:2n*k\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:k*x\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList());\\n        return ans;\\n    }\\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if(target == 0) {\\n            ans.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        for(int i = ind; i < arr.length;i++) {\\n            if(i > ind && arr[i] == arr[i-1]) continue; \\n            if(arr[i]>target) break; \\n            \\n            ds.add(arr[i]); \\n            findCombinations(i+1, arr, target - arr[i], ans, ds); \\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList());\\n        return ans;\\n    }\\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if(target == 0) {\\n            ans.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        for(int i = ind; i < arr.length;i++) {\\n            if(i > ind && arr[i] == arr[i-1]) continue; \\n            if(arr[i]>target) break; \\n            \\n            ds.add(arr[i]); \\n            findCombinations(i+1, arr, target - arr[i], ans, ds); \\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185178,
                "title": "python-backtracking-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()                      \\n        result = []\\n        def combine_sum_2(nums, start, path, result, target):\\n            if not target:\\n                result.append(path)\\n                return\\n            for i in range(start, len(nums)):\\n                if i > start and nums[i] == nums[i - 1]:\\n                    continue\\n                if nums[i] > target:\\n                    break\\n                combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i])\\n        combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()                      \\n        result = []\\n        def combine_sum_2(nums, start, path, result, target):\\n            if not target:\\n                result.append(path)\\n                return\\n            for i in range(start, len(nums)):\\n                if i > start and nums[i] == nums[i - 1]:\\n                    continue\\n                if nums[i] > target:\\n                    break\\n                combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i])\\n        combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182108,
                "title": "java-sol-2ms-beats-99-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> arr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        func (candidates, arr, 0, target, new ArrayList<>());\\n        return arr;\\n    }\\n    void func (int[] candi, List<List<Integer>> arr, int idx, int target, List<Integer> temp) {\\n        if (target==0) {\\n            arr.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i=idx; i<candi.length; i++) {\\n            if (i>idx && candi[i]==candi[i-1]) continue;\\n            if (candi[i]>target) break;\\n            temp.add(candi[i]);\\n            func (candi, arr, i+1, target-candi[i], temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> arr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        func (candidates, arr, 0, target, new ArrayList<>());\\n        return arr;\\n    }\\n    void func (int[] candi, List<List<Integer>> arr, int idx, int target, List<Integer> temp) {\\n        if (target==0) {\\n            arr.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i=idx; i<candi.length; i++) {\\n            if (i>idx && candi[i]==candi[i-1]) continue;\\n            if (candi[i]>target) break;\\n            temp.add(candi[i]);\\n            func (candi, arr, i+1, target-candi[i], temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177752,
                "title": "go-solution-recursive-dfs",
                "content": "#### Recursive DFS\\n\\n```go\\nimport (\\n    \"sort\"\\n)\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n    sort.Ints(candidates)\\n    combos := make([][]int, 0)\\n    \\n    var dfs func([]int, int, []int)\\n    dfs = func(nums []int, targ int, path []int) {\\n        if targ < 0 {\\n            return\\n        }\\n        if targ == 0 {\\n            combos = append(combos, path)\\n            return\\n        }\\n        \\n        for i, n := range nums {\\n            if i > 0 && nums[i] == nums[i-1] {\\n                continue\\n            }\\n            newPath := make([]int, len(path))\\n            copy(newPath, path)\\n            dfs(nums[i+1:], targ-n, append(newPath, n))\\n        }\\n        return\\n    }\\n    \\n    dfs(candidates, target, []int{})\\n    return combos\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```go\\nimport (\\n    \"sort\"\\n)\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n    sort.Ints(candidates)\\n    combos := make([][]int, 0)\\n    \\n    var dfs func([]int, int, []int)\\n    dfs = func(nums []int, targ int, path []int) {\\n        if targ < 0 {\\n            return\\n        }\\n        if targ == 0 {\\n            combos = append(combos, path)\\n            return\\n        }\\n        \\n        for i, n := range nums {\\n            if i > 0 && nums[i] == nums[i-1] {\\n                continue\\n            }\\n            newPath := make([]int, len(path))\\n            copy(newPath, path)\\n            dfs(nums[i+1:], targ-n, append(newPath, n))\\n        }\\n        return\\n    }\\n    \\n    dfs(candidates, target, []int{})\\n    return combos\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3158498,
                "title": "runtime-beats-97-33-combination-sum-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the candidates list in ascending order.\\nDefine a backtracking function that takes in 3 parameters: start index, a list path to store each combination, and the target value.\\nIf the target value is 0, append the path list to the result res list.\\nLoop through the candidates list starting from the given start index.\\nIf the current index i is greater than start and the current candidate is the same as the previous candidate, continue to the next iteration.\\nIf the current candidate is greater than the target value, break the loop.\\nAdd the current candidate to the path list and call the backtracking function with i + 1 as the start index, the updated path list, and the target minus the current candidate.\\nReturn the result res list after the backtracking function is finished.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(start, path, target):\\n            if target == 0:\\n                res.append(path)\\n                return\\n            for i in range(start, len(candidates)):\\n                if i > start and candidates[i] == candidates[i - 1]:\\n                    continue\\n                if candidates[i] > target:\\n                    break\\n                backtrack(i + 1, path + [candidates[i]], target - candidates[i])\\n\\n        candidates.sort()\\n        res = []\\n        backtrack(0, [], target)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(start, path, target):\\n            if target == 0:\\n                res.append(path)\\n                return\\n            for i in range(start, len(candidates)):\\n                if i > start and candidates[i] == candidates[i - 1]:\\n                    continue\\n                if candidates[i] > target:\\n                    break\\n                backtrack(i + 1, path + [candidates[i]], target - candidates[i])\\n\\n        candidates.sort()\\n        res = []\\n        backtrack(0, [], target)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124204,
                "title": "2k-views-easy-to-understand-concise-and-precise-100-efficient-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void Ps(int ind,int target,vector<int> &v,vector<vector<int>> &ans , vector<int> &arr){\\n        if(target==0){\\n            ans.push_back(v);\\n            return ;\\n        }\\n        for(int i=ind;i<arr.size();i++){\\n            if(i>ind && arr[i]==arr[i-1]) continue;\\n            if(arr[i]>target) break;\\n            v.push_back(arr[i]);\\n            Ps(i+1,target-arr[i],v,ans,arr);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        Ps(0,target,v,ans,arr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void Ps(int ind,int target,vector<int> &v,vector<vector<int>> &ans , vector<int> &arr){\\n        if(target==0){\\n            ans.push_back(v);\\n            return ;\\n        }\\n        for(int i=ind;i<arr.size();i++){\\n            if(i>ind && arr[i]==arr[i-1]) continue;\\n            if(arr[i]>target) break;\\n            v.push_back(arr[i]);\\n            Ps(i+1,target-arr[i],v,ans,arr);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        Ps(0,target,v,ans,arr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105204,
                "title": "java-backtracking-explained",
                "content": "# Intuition\\n- Before starting the recursive call make sure to sort the elements because the ans should contain the combinations in sorted order and should not be repeated.\\n\\n- Initially, We start with the index 0, At index 0 we have n \\u2013 1 way to pick the first element of our subsequence.\\n\\n- Check if the current index value can be added to our ds. If yes add it to the ds and move the index by 1. while moving the index skip the consecutive repeated elements because they will form duplicate sequences.\\n\\n- Reduce the target by arr[i],call the recursive call for f(idx + 1,target \\u2013 1,ds,ans) after the call make sure to pop the element from the ds.\\n\\n- - if(arr[i] > target) then terminate the recursive call because there is no use to check as the array is sorted in the next recursive call the index will be moving by 1 all the elements to its right will be in increasing order.\\n\\n# Base Condition:\\n\\n- Whenever the target value is zero add the ds to the ans return.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(2^n*k)$$ \\n- - Assume if all the elements in the array are unique then the no. of subsequence you will get will be O(2^n). we also add the ds to our ans when we reach the base case that will take \\u201Ck\\u201D//average space for the ds.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        findCombiantions(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    void findCombiantions(int ind, int[] nums, int target, List<List<Integer>> ans, ArrayList<Integer> ds) {\\n        if (target==0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for (int i = ind; i < nums.length ; i++) {\\n            if (i>ind && nums[i]==nums[i-1] ) continue;\\n            if (nums[i]>target) break;\\n            ds.add(nums[i]);\\n            findCombiantions(i+1,nums,target-nums[i],ans,ds);\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        findCombiantions(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    void findCombiantions(int ind, int[] nums, int target, List<List<Integer>> ans, ArrayList<Integer> ds) {\\n        if (target==0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for (int i = ind; i < nums.length ; i++) {\\n            if (i>ind && nums[i]==nums[i-1] ) continue;\\n            if (nums[i]>target) break;\\n            ds.add(nums[i]);\\n            findCombiantions(i+1,nums,target-nums[i],ans,ds);\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100921,
                "title": "super-easily-understandable-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->https://www.youtube.com/watch?v=G1fRTGRxXU8&list=PLgUwDviBIf0rGlzIn_7rsaR2FQ5e6ZOL9&index=9\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void findcombination(int ind, int target,vector<int> &candidates,vector<vector<int>> &ans,vector<int> &ds){\\n        if(target==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<candidates.size();i++){\\n            if(i>ind && candidates[i]==candidates[i-1])continue;\\n            if(candidates[i]>target)break;\\n            ds.push_back(candidates[i]);\\n            findcombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n        }\\n        \\n    }\\nvector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n    sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findcombination(0,target,candidates,ans,ds);\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findcombination(int ind, int target,vector<int> &candidates,vector<vector<int>> &ans,vector<int> &ds){\\n        if(target==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<candidates.size();i++){\\n            if(i>ind && candidates[i]==candidates[i-1])continue;\\n            if(candidates[i]>target)break;\\n            ds.push_back(candidates[i]);\\n            findcombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n        }\\n        \\n    }\\nvector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n    sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findcombination(0,target,candidates,ans,ds);\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088912,
                "title": "c-striver-approach-easy-explained",
                "content": "# Approach\\n- So Here Sort The Vector , Because We Are Having A Logic Of Not Using Extra Space\\n- Lets Deep Dive Into Our Recursive Code And I Will Explain It Line By Line\\n- So First Of All We Have Our Base Case , That Is If(target == 0) , we push the vector in our ans , which is vector<vector<int>> and we return\\n- After That As We Know The Question States We Need Lexicographical Answers Only , Means We Cannot Pick [1,2,1] , We Can Only Pick Answers Which Are Sorted In I.e [1,1,2] or [2,2]\\n- So Inorder To Avoid The Same Sequences We Keep A Check , That Is If We Are Picking The Element For First Time We Allow It , If The Same Number Comes Again , That Will Generate Same Answer\\n- So We Keep A Check By Using This  if(i > index && arr[i] == arr[i-1]) , If This Satisfies We Skip And Move To Next Index\\n- After That We Keep A Check If The arr[i] > Target that means we cannot have any combination , as after this all values will be high as we have the vector sorted\\n- After That We Add The ith Element In Our Temp Vector And We Again Call Recursion\\n- We Have To Also Do Backtracking For Removing The ith Element , So We Also Pop Back The Element\\n- Check Given Recursion Tree , And You Will Get What I am Trying To Explain\\n\\n# Recursion Tree \\n\\n```\\nInput: candidates = [1,1,1,2,2], target = 4\\nOutput: [[1,1,2],[2,2]]\\n```\\n\\n![WhatsApp Image 2023-01-23 at 11.28.03 AM.jpeg](https://assets.leetcode.com/users/images/42c631cb-fb47-4a1a-b6ba-1a7a98c486ae_1674453532.080475.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(2^n * k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n * k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nvoid solve(int index,int target,vector<int> &arr,vector<vector<int>> &ans,vector<int> &ds)\\n{\\n    if(target == 0)\\n    {\\n        ans.push_back(ds);\\n        return;\\n    }\\n\\n    for(int i = index; i< arr.size();i++)\\n    {\\n       if(i > index && arr[i] == arr[i-1])\\n       continue;\\n\\n       if(arr[i] > target)\\n       break;\\n\\n       ds.push_back(arr[i]);\\n       solve(i+1,target-arr[i],arr,ans,ds);\\n       ds.pop_back();\\n    }\\n\\n    return;\\n}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nInput: candidates = [1,1,1,2,2], target = 4\\nOutput: [[1,1,2],[2,2]]\\n```\n```\\nclass Solution {\\nprivate:\\nvoid solve(int index,int target,vector<int> &arr,vector<vector<int>> &ans,vector<int> &ds)\\n{\\n    if(target == 0)\\n    {\\n        ans.push_back(ds);\\n        return;\\n    }\\n\\n    for(int i = index; i< arr.size();i++)\\n    {\\n       if(i > index && arr[i] == arr[i-1])\\n       continue;\\n\\n       if(arr[i] > target)\\n       break;\\n\\n       ds.push_back(arr[i]);\\n       solve(i+1,target-arr[i],arr,ans,ds);\\n       ds.pop_back();\\n    }\\n\\n    return;\\n}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074701,
                "title": "c-backtracking",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\u9700\\u8981\\u526A\\u679D\\uFF0C\\u5982\\u679C\\u4E00\\u4E2A\\u8282\\u70B9\\u6709\\u591A\\u6761\\u503C\\u76F8\\u540C\\u7684\\u6811\\u679D\\u76F8\\u90BB\\uFF0C\\u5219\\u53EA\\u904D\\u5386\\u7B2C\\u4E00\\u6761\\uFF0C\\u5269\\u4E0B\\u7684\\u90FD\\u526A\\u6389\\uFF0C\\u4E0D\\u8981\\u53BB\\u904D\\u5386.\\u4F53\\u73B0\\u5728\\u4EE3\\u7801\\u4E0A\\uFF0C\\u9700\\u8981\\u5148\\u8FDB\\u884C\\u6392\\u5E8F\\uFF0C\\u8BA9\\u76F8\\u540C\\u7684\\u5143\\u7D20\\u9760\\u5728\\u4E00\\u8D77\\uFF0C\\u5982\\u679C\\u53D1\\u73B0candidates[i] == candidates[i-1]\\uFF0C\\u5219\\u8DF3\\u8FC7.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    vector<int> path;\\n    int sum = 0;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        // if(candidates.size() == 0) return res;\\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, 0);\\n        return res;\\n    }\\n    void backtrack(vector<int>& candidates, int target, int u){\\n        if(sum == target){\\n            res.push_back(path);\\n            return;\\n        }\\n        if(sum > target) return;\\n        \\n        for(int i = u; i < candidates.size(); i ++){\\n            if(i > u && candidates[i] == candidates[i - 1]) continue;\\n            path.push_back(candidates[i]);\\n            sum += candidates[i];\\n            backtrack(candidates, target, i + 1);\\n            path.pop_back();\\n            sum -= candidates[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    vector<int> path;\\n    int sum = 0;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        // if(candidates.size() == 0) return res;\\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, 0);\\n        return res;\\n    }\\n    void backtrack(vector<int>& candidates, int target, int u){\\n        if(sum == target){\\n            res.push_back(path);\\n            return;\\n        }\\n        if(sum > target) return;\\n        \\n        for(int i = u; i < candidates.size(); i ++){\\n            if(i > u && candidates[i] == candidates[i - 1]) continue;\\n            path.push_back(candidates[i]);\\n            sum += candidates[i];\\n            backtrack(candidates, target, i + 1);\\n            path.pop_back();\\n            sum -= candidates[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040453,
                "title": "c-java-python-easiest-solution-detailed-explanation-code",
                "content": "\\n# Approach\\nThe code is a solution to the problem of finding all combinations of a given set of candidates that add up to a given target. The solution uses a recursive function Solve() that takes the candidates, target, current sum, an array to store the combinations, an array to store the current combination, and the current index being processed as input. The function checks if the current sum is equal to the target, if so it adds the current combination to the output. If the current sum is greater than the target, it returns.\\nIf the current index is equal to the size of the candidates, it returns.\\n\\nOne difference from the previous code is that it also skips any duplicates candidates by using a while loop after a recursive call using the current candidate. This will prevent the function from generating duplicate subsets.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O((2^n)*k)**, where 2^n is distribution of n elements, k is average length of every combination(mainly k for this -> ans.push_back(ds);)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(x)**, where x is length of longest combinations \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nClass Solution {\\npublic:\\n    void Solve(vector<int>& candidates, int target, int sum, vector<vector<int>>& output, vector<int>& ans, int index){\\n        if(target == sum){\\n            output.push_back(ans);\\n            return;\\n        }\\n        if(candidates.size() == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.push_back(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.pop_back();\\n        while(index < candidates.size()-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> ans;\\n        sort(candidates.begin(), candidates.end());\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public void Solve(int[] candidates, int target, int sum, List<List<Integer>> output, List<Integer> ans, int index){\\n        if(target == sum){\\n            output.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        if(candidates.length == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.add(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.remove(ans.size()-1);\\n        while(index < candidates.length-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> output = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def Solve(self, candidates, target, sum, output, ans, index):\\n        if target == sum:\\n            output.append(list(ans))\\n            return\\n        if len(candidates) == index:\\n            return\\n        if sum > target:\\n            return\\n        ans.append(candidates[index])\\n        self.Solve(candidates, target, sum + candidates[index], output, ans, index + 1)\\n        ans.pop()\\n        while index < len(candidates)-1 and candidates[index] == candidates[index + 1]:\\n            index += 1\\n        self.Solve(candidates, target, sum, output, ans, index + 1)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        output = []\\n        ans = []\\n        candidates.sort()\\n        self.Solve(candidates, target, 0, output, ans, 0)\\n        return output\\n\\n\\n```\\n**Note 0 : Also Recommend to see \"Combination Sum\" which is available in leetcode.** https://leetcode.com/problems/combination-sum/solutions/3027804/c-java-python-detailed-explanation-recursive-solution/\\n\\n**Note 1: Code for Java and Python might be wrong due to syntax error bcz Java and Python Solution is just the exact coversion of C++ code but logic is 100 % correct.**\\n\\n***Note 2: with the help of hashset we will get time limit exceeded error with this test case.**\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget = 30\\nclass Solution {\\npublic:\\n    void Solve(vector<int>& candidates, int target, int sum, set<vector<int>>& s, vector<int>& ans, int index){\\n        if(target == sum){\\n            s.insert(ans);\\n            return;\\n        }\\n        if(candidates.size() == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        if(sum + candidates[index] > target) \\n            return;\\n        ans.push_back(candidates[index]); \\n        Solve(candidates, target, sum + candidates[index], s, ans, index + 1);\\n        ans.pop_back();\\n        Solve(candidates, target, sum, s, ans, index + 1);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        vector<int> ans;\\n        sort(candidates.begin(), candidates.end());\\n        Solve(candidates, target, 0, s, ans, 0);\\n        for(auto vec : s)\\n            output.push_back(vec);\\n        return output;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```C++ []\\nClass Solution {\\npublic:\\n    void Solve(vector<int>& candidates, int target, int sum, vector<vector<int>>& output, vector<int>& ans, int index){\\n        if(target == sum){\\n            output.push_back(ans);\\n            return;\\n        }\\n        if(candidates.size() == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.push_back(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.pop_back();\\n        while(index < candidates.size()-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> ans;\\n        sort(candidates.begin(), candidates.end());\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public void Solve(int[] candidates, int target, int sum, List<List<Integer>> output, List<Integer> ans, int index){\\n        if(target == sum){\\n            output.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        if(candidates.length == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.add(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.remove(ans.size()-1);\\n        while(index < candidates.length-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> output = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def Solve(self, candidates, target, sum, output, ans, index):\\n        if target == sum:\\n            output.append(list(ans))\\n            return\\n        if len(candidates) == index:\\n            return\\n        if sum > target:\\n            return\\n        ans.append(candidates[index])\\n        self.Solve(candidates, target, sum + candidates[index], output, ans, index + 1)\\n        ans.pop()\\n        while index < len(candidates)-1 and candidates[index] == candidates[index + 1]:\\n            index += 1\\n        self.Solve(candidates, target, sum, output, ans, index + 1)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        output = []\\n        ans = []\\n        candidates.sort()\\n        self.Solve(candidates, target, 0, output, ans, 0)\\n        return output\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010879,
                "title": "backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n\\n    void findCombination(int index, int target, vector<int>& candidates, vector<vector<int>>& ans, vector<int>& ds ){\\n\\n        if(target==0)\\n        {\\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n            ds.push_back(candidates[i]);\\n            findCombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n\\n\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n\\n    void findCombination(int index, int target, vector<int>& candidates, vector<vector<int>>& ans, vector<int>& ds ){\\n\\n        if(target==0)\\n        {\\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n            ds.push_back(candidates[i]);\\n            findCombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n\\n\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860265,
                "title": "c-faster-than-100-concept-of-pick-subsequence",
                "content": "# Complexity\\n- Time complexity:\\nO(2^n)+k\\n\\n- Space complexity:\\nk*x (ignoring auxilary space used by recursion)\\n\\npls upvote if you like the solution.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind, int target, vector <int>& arr, vector<vector<int>>&ans,vector<int>&ds){\\n    if(target==0){\\n        ans.push_back(ds);\\n        return;\\n    }\\n    for(int i=ind; i<arr.size();i++){\\n        if(i>ind&& arr[i]==arr[i-1]) continue;\\n        if(arr[i]>target) break;\\n\\n        ds.push_back(arr[i]);\\n        findCombination(i+1, target-arr[i],arr, ans, ds);\\n        ds.pop_back();\\n    }\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector <int>ds;\\n        findCombination(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind, int target, vector <int>& arr, vector<vector<int>>&ans,vector<int>&ds){\\n    if(target==0){\\n        ans.push_back(ds);\\n        return;\\n    }\\n    for(int i=ind; i<arr.size();i++){\\n        if(i>ind&& arr[i]==arr[i-1]) continue;\\n        if(arr[i]>target) break;\\n\\n        ds.push_back(arr[i]);\\n        findCombination(i+1, target-arr[i],arr, ans, ds);\\n        ds.pop_back();\\n    }\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector <int>ds;\\n        findCombination(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1761591,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1569334,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1625415,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571097,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572732,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571098,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1782494,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1761589,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1825165,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1948051,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1761591,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1569334,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1625415,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571097,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572732,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571098,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1782494,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1761589,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1825165,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1948051,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1773550,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct👍\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 1708453,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct👍\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 1572711,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct👍\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2052618,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct👍\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2049804,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct👍\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2046354,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct👍\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2027816,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct👍\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2027069,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct👍\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2014335,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct👍\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2011007,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct👍\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2004828,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1997800,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1984747,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1957769,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1948099,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1937812,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1930902,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1925393,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1922337,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1818568,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1808121,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1806997,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1800119,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1788823,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1777795,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1775087,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1767902,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1752615,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1740987,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1735773,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            }
        ]
    },
    {
        "title": "Word Break II",
        "question_content": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]\n<strong>Output:</strong> [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]\n<strong>Output:</strong> [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]\n<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n\t<li>Input is generated in a way that the length of the answer doesn&#39;t exceed&nbsp;10<sup>5</sup>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 44167,
                "title": "my-concise-java-solution-based-on-memorized-dfs",
                "content": "**Explanation**\\n\\nUsing DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches, as the following:\\n \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        return DFS(s, wordDict, new HashMap<String, LinkedList<String>>());\\n    }       \\n    \\n    // DFS function returns an array including all substrings derived from s.\\n    List<String> DFS(String s, Set<String> wordDict, HashMap<String, LinkedList<String>>map) {\\n        if (map.containsKey(s)) \\n            return map.get(s);\\n            \\n        LinkedList<String>res = new LinkedList<String>();     \\n        if (s.length() == 0) {\\n            res.add(\"\");\\n            return res;\\n        }               \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                List<String>sublist = DFS(s.substring(word.length()), wordDict, map);\\n                for (String sub : sublist) \\n                    res.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);               \\n            }\\n        }       \\n        map.put(s, res);\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nUsing DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches, as the following:\\n \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        return DFS(s, wordDict, new HashMap<String, LinkedList<String>>());\\n    }       \\n    \\n    // DFS function returns an array including all substrings derived from s.\\n    List<String> DFS(String s, Set<String> wordDict, HashMap<String, LinkedList<String>>map) {\\n        if (map.containsKey(s)) \\n            return map.get(s);\\n            \\n        LinkedList<String>res = new LinkedList<String>();     \\n        if (s.length() == 0) {\\n            res.add(\"\");\\n            return res;\\n        }               \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                List<String>sublist = DFS(s.substring(word.length()), wordDict, map);\\n                for (String sub : sublist) \\n                    res.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);               \\n            }\\n        }       \\n        map.put(s, res);\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44311,
                "title": "python-easy-to-understand-solution",
                "content": "    class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.helper(s, wordDict, {})\\n        \\n    def helper(self, s, wordDict, memo):\\n        if s in memo: return memo[s]\\n        if not s: return []\\n        \\n        res = []\\n        for word in wordDict:\\n            if not s.startswith(word):\\n                continue\\n            if len(word) == len(s):\\n                res.append(word)\\n            else:\\n                resultOfTheRest = self.helper(s[len(word):], wordDict, memo)\\n                for item in resultOfTheRest:\\n                    item = word + ' ' + item\\n                    res.append(item)\\n        memo[s] = res\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.helper(s, wordDict, {}",
                "codeTag": "Java"
            },
            {
                "id": 2996989,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void solve(string s, vector<string>& res, unordered_set<string>& st, vector<string>&temp){\\n        if(s.length() == 0){\\n            string str = \"\";\\n            for(auto it:temp){\\n                str += it + \" \";\\n            }\\n            str.pop_back();\\n            res.push_back(str);\\n            return;\\n        }\\n        for(int i=0;i<s.length(); i++){\\n            if(st.count(s.substr(0, i+1))){\\n                temp.push_back(s.substr(0, i+1));\\n                solve(s.substr(i+1), res, st, temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string>res, temp;\\n        unordered_set<string>st(wordDict.begin(), wordDict.end());\\n        \\n        solve(s, res, st, temp);\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```\\n\\n```Java []\\nclass Solution {\\n    private void helper(String s, int i, Set<String> dict, List<String> cur, List<String> res) {\\n        if (i == s.length()) {\\n            if (cur.size() > 0) {\\n                StringBuilder sb = new StringBuilder();\\n                for (int j = 0; j < cur.size(); j++) {\\n                    if (j > 0) {\\n                        sb.append(\\' \\');\\n                    }\\n                    sb.append(cur.get(j));\\n                }\\n                res.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\n        for (int j = i+1; j <= s.length(); j++) {\\n            if (dict.contains(s.substring(i, j))) {\\n                cur.add(s.substring(i, j));\\n                helper(s, j, dict, cur, res);\\n                cur.remove(cur.size() - 1);\\n            }\\n        }\\n    }\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Set<String> dict = new HashSet<>(wordDict);\\n        List<String> res = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        helper(s, 0, dict, cur, res);\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void solve(string s, vector<string>& res, unordered_set<string>& st, vector<string>&temp){\\n        if(s.length() == 0){\\n            string str = \"\";\\n            for(auto it:temp){\\n                str += it + \" \";\\n            }\\n            str.pop_back();\\n            res.push_back(str);\\n            return;\\n        }\\n        for(int i=0;i<s.length(); i++){\\n            if(st.count(s.substr(0, i+1))){\\n                temp.push_back(s.substr(0, i+1));\\n                solve(s.substr(i+1), res, st, temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string>res, temp;\\n        unordered_set<string>st(wordDict.begin(), wordDict.end());\\n        \\n        solve(s, res, st, temp);\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```\n```Java []\\nclass Solution {\\n    private void helper(String s, int i, Set<String> dict, List<String> cur, List<String> res) {\\n        if (i == s.length()) {\\n            if (cur.size() > 0) {\\n                StringBuilder sb = new StringBuilder();\\n                for (int j = 0; j < cur.size(); j++) {\\n                    if (j > 0) {\\n                        sb.append(\\' \\');\\n                    }\\n                    sb.append(cur.get(j));\\n                }\\n                res.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\n        for (int j = i+1; j <= s.length(); j++) {\\n            if (dict.contains(s.substring(i, j))) {\\n                cur.add(s.substring(i, j));\\n                helper(s, j, dict, cur, res);\\n                cur.remove(cur.size() - 1);\\n            }\\n        }\\n    }\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Set<String> dict = new HashSet<>(wordDict);\\n        List<String> res = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        helper(s, 0, dict, cur, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44178,
                "title": "11ms-c-solution-concise",
                "content": "    class Solution {\\n        unordered_map<string, vector<string>> m;\\n    \\n        vector<string> combine(string word, vector<string> prev){\\n            for(int i=0;i<prev.size();++i){\\n                prev[i]+=\" \"+word;\\n            }\\n            return prev;\\n        }\\n    \\n    public:\\n        vector<string> wordBreak(string s, unordered_set<string>& dict) {\\n            if(m.count(s)) return m[s]; //take from memory\\n            vector<string> result;\\n            if(dict.count(s)){ //a whole string is a word\\n                result.push_back(s);\\n            }\\n            for(int i=1;i<s.size();++i){\\n                string word=s.substr(i);\\n                if(dict.count(word)){\\n                    string rem=s.substr(0,i);\\n                    vector<string> prev=combine(word,wordBreak(rem,dict));\\n                    result.insert(result.end(),prev.begin(), prev.end());\\n                }\\n            }\\n            m[s]=result; //memorize\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        unordered_map<string, vector<string>> m;\\n    \\n        vector<string> combine(string word, vector<string> prev){\\n            for(int i=0;i<prev.size();++i){\\n                prev[i]+=\" \"+word;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 44169,
                "title": "9-lines-python-10-lines-c",
                "content": "`sentences(i)` returns a list of all sentences that can be built from the suffix `s[i:]`.\\n\\n**Python:**\\n\\n    def wordBreak(self, s, wordDict):\\n        memo = {len(s): ['']}\\n        def sentences(i):\\n            if i not in memo:\\n                memo[i] = [s[i:j] + (tail and ' ' + tail)\\n                           for j in range(i+1, len(s)+1)\\n                           if s[i:j] in wordDict\\n                           for tail in sentences(j)]\\n            return memo[i]\\n        return sentences(0)\\n\\n**C++:**\\n\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        unordered_map<int, vector<string>> memo {{s.size(), {\"\"}}};\\n        function<vector<string>(int)> sentences = [&](int i) {\\n            if (!memo.count(i))\\n                for (int j=i+1; j<=s.size(); j++)\\n                    if (wordDict.count(s.substr(i, j-i)))\\n                        for (string tail : sentences(j))\\n                            memo[i].push_back(s.substr(i, j-i) + (tail==\"\" ? \"\" : ' ' + tail));\\n            return memo[i];\\n        };\\n        return sentences(0);\\n    }",
                "solutionTags": [
                    "Python"
                ],
                "code": "`sentences(i)` returns a list of all sentences that can be built from the suffix `s[i:]`.\\n\\n**Python:**\\n\\n    def wordBreak(self, s, wordDict):\\n        memo = {len(s): ['']}\\n        def sentences(i):\\n            if i not in memo:\\n                memo[i] = [s[i:j] + (tail and ' ' + tail)\\n                           for j in range(i+1, len(s)+1)\\n                           if s[i:j] in wordDict\\n                           for tail in sentences(j)]\\n            return memo[i]\\n        return sentences(0)\\n\\n**C++:**\\n\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        unordered_map<int, vector<string>> memo {{s.size(), {\"\"}}};\\n        function<vector<string>(int)> sentences = [&](int i) {\\n            if (!memo.count(i))\\n                for (int j=i+1; j<=s.size(); j++)\\n                    if (wordDict.count(s.substr(i, j-i)))\\n                        for (string tail : sentences(j))\\n                            memo[i].push_back(s.substr(i, j-i) + (tail==\"\" ? \"\" : ' ' + tail));\\n            return memo[i];\\n        };\\n        return sentences(0);\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 1241504,
                "title": "c-0ms-solution-commented-fully",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        //insert all the words in the set\\n        unordered_set<string> set;\\n        vector<string> res;\\n        for(auto word:wordDict)\\n            set.insert(word);\\n        //to store the current string \\n        string curr=\"\";\\n        findHelper(0,s,curr,set,res);\\n        return res;\\n    }\\n    \\n    void findHelper(int ind,string s,string curr,unordered_set<string> set,vector<string>& res)\\n    {\\n        if(ind==s.length())\\n        {\\n            //we have reached end\\n            curr.pop_back(); //remove the trailing space\\n            res.push_back(curr);\\n        }\\n        string str=\"\";\\n        for(int i=ind;i<s.length();i++)\\n        {\\n            //get every substring and check if it exists in set\\n            str.push_back(s[i]);\\n            if(set.count(str))\\n            {\\n                //we have got a word in dict \\n                //explore more and get other substrings\\n                findHelper(i+1,s,curr+str+\" \",set,res);\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        //insert all the words in the set\\n        unordered_set<string> set;\\n        vector<string> res;\\n        for(auto word:wordDict)\\n            set.insert(word);\\n        //to store the current string \\n        string curr=\"\";\\n        findHelper(0,s,curr,set,res);\\n        return res;\\n    }\\n    \\n    void findHelper(int ind,string s,string curr,unordered_set<string> set,vector<string>& res)\\n    {\\n        if(ind==s.length())\\n        {\\n            //we have reached end\\n            curr.pop_back(); //remove the trailing space\\n            res.push_back(curr);\\n        }\\n        string str=\"\";\\n        for(int i=ind;i<s.length();i++)\\n        {\\n            //get every substring and check if it exists in set\\n            str.push_back(s[i]);\\n            if(set.count(str))\\n            {\\n                //we have got a word in dict \\n                //explore more and get other substrings\\n                findHelper(i+1,s,curr+str+\" \",set,res);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44243,
                "title": "java-dp-dfs-memoization-dfs-and-dp-pruning-solutions-with-analysis",
                "content": "I've been struggling with this problem for a long time, and I'd love to share three different strategies I have tried to solve it. All of them are ACed. \\n\\nMethod 1: DP + DFS. Very similar to Word Break I, but instead of using a boolean dp array, I used an array of Lists to maintain all of the valid start positions for every end position. Then just do classic backtracking to find all solutions. The time complexity is O(n*m) + O(n * number of solutions), where n is the length of the input string, m is the length of the longest word in the dictionary. The run time was 6ms. It is very efficient because DP is used to find out all the valid answers, and no time is wasted on doing the backtracking. \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        List<Integer>[] starts = new List[s.length() + 1]; // valid start positions\\n        starts[0] = new ArrayList<Integer>();\\n        \\n        int maxLen = getMaxLen(wordDict);\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = i - 1; j >= i - maxLen && j >= 0; j--) {\\n                if (starts[j] == null) continue;\\n                String word = s.substring(j, i);\\n                if (wordDict.contains(word)) {\\n                    if (starts[i] == null) {\\n                        starts[i] = new ArrayList<Integer>();\\n                    }\\n                    starts[i].add(j);\\n                }\\n            }\\n        }\\n        \\n        List<String> rst = new ArrayList<>();\\n        if (starts[s.length()] == null) {\\n            return rst;\\n        }\\n        \\n        dfs(rst, \"\", s, starts, s.length());\\n        return rst;\\n    }\\n\\n  \\n    private void dfs(List<String> rst, String path, String s, List<Integer>[] starts, int end) {\\n        if (end == 0) {\\n            rst.add(path.substring(1));\\n            return;\\n        }\\n        \\n        for (Integer start: starts[end]) {\\n            String word = s.substring(start, end);\\n            dfs(rst, \" \" + word + path, s, starts, start);\\n        }\\n    }\\n\\n    private int getMaxLen(Set<String> wordDict) {\\n        int max = 0;\\n        for (String s : wordDict) {\\n            max = Math.max(max, s.length());\\n        }\\n        return max;\\n    }\\n\\n\\nMethod 2: Memoization + Backtracking. Before I came up with Method 1, I also tried using a HashMap to memoize all the possible strings that can be formed starting from index i. I referred to this post from [@Pixel_][1] \\nThe time complexity is O(len(wordDict) ^ len(s / minWordLenInDict)) as @Pixel_ mentioned. The space complexity would be larger than other methods though. Here is my code: \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        HashMap<Integer, List<String>> memo = new HashMap<>(); // <Starting index, rst list>\\n        return dfs(s, 0, wordDict, memo);\\n    }\\n    \\n    private List<String> dfs(String s, int start, Set<String> dict, HashMap<Integer, List<String>> memo) {\\n        if (memo.containsKey(start)) {\\n            return memo.get(start);\\n        }\\n        \\n        List<String> rst = new ArrayList<>();\\n        if (start == s.length()) {\\n            rst.add(\"\");\\n            return rst;\\n        }\\n        \\n        String curr = s.substring(start);\\n        for (String word: dict) {\\n            if (curr.startsWith(word)) {\\n                List<String> sublist = dfs(s, start + word.length(), dict, memo);\\n                for (String sub : sublist) {\\n                    rst.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);\\n                }\\n            }\\n        }\\n        \\n        memo.put(start, rst);\\n        return rst;\\n    }\\n\\nMethod 3: DP Prunning + Backtracking. My very first solution is like this: using a boolean array to memoize whether a substring starting from position i to the end is breakable. This works well for worst cases like: s = \"aaaaaaaaaaaab\", dict = [\"a\", \"aa\", \"aaa\", \"aaaa\"]. However, for cases like: s = \"aaaaaaaaaaaaa\", dict = [\"a\", \"aa\", \"aaa\", \"aaaa\"], the time complexity is still O(2^n). Here is the code: \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        List<String> rst = new ArrayList<>();\\n        if (s == null || s.length() == 0 || wordDict == null) {\\n            return rst;\\n        }\\n        \\n        boolean[] canBreak = new boolean[s.length()];\\n        Arrays.fill(canBreak, true);\\n        StringBuilder sb = new StringBuilder();\\n        dfs(rst, sb, s, wordDict, canBreak, 0);\\n        return rst;\\n    }\\n    \\n    private void dfs(List<String> rst, StringBuilder sb, String s, Set<String> dict, \\n        boolean[] canBreak, int start) {\\n        if (start == s.length()) {\\n            rst.add(sb.substring(1));\\n            return;\\n        }\\n        \\n        if (!canBreak[start]) {\\n            return;\\n        }\\n        \\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String word = s.substring(start, i);\\n            if (!dict.contains(word)) continue;\\n            \\n            int sbBeforeAdd = sb.length();\\n            sb.append(\" \" + word);\\n            \\n            int rstBeforeDFS = rst.size();\\n            dfs(rst, sb, s, dict, canBreak, i);\\n            if (rst.size() == rstBeforeDFS) {\\n                canBreak[i] = false;\\n            }\\n            sb.delete(sbBeforeAdd, sb.length());\\n        }\\n    }\\n    \\n    private int getMaxLen(Set<String> wordDict) {\\n        int max = 0;\\n        for (String s : wordDict) {\\n            max = Math.max(max, s.length());\\n        }\\n        return max;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/65692/my-concise-java-solution-based-on-memorized-dfs",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "I've been struggling with this problem for a long time, and I'd love to share three different strategies I have tried to solve it. All of them are ACed. \\n\\nMethod 1: DP + DFS. Very similar to Word Break I, but instead of using a boolean dp array, I used an array of Lists to maintain all of the valid start positions for every end position. Then just do classic backtracking to find all solutions. The time complexity is O(n*m) + O(n * number of solutions), where n is the length of the input string, m is the length of the longest word in the dictionary. The run time was 6ms. It is very efficient because DP is used to find out all the valid answers, and no time is wasted on doing the backtracking. \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        List<Integer>[] starts = new List[s.length() + 1]; // valid start positions\\n        starts[0] = new ArrayList<Integer>();\\n        \\n        int maxLen = getMaxLen(wordDict);\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = i - 1; j >= i - maxLen && j >= 0; j--) {\\n                if (starts[j] == null) continue;\\n                String word = s.substring(j, i);\\n                if (wordDict.contains(word)) {\\n                    if (starts[i] == null) {\\n                        starts[i] = new ArrayList<Integer>();\\n                    }\\n                    starts[i].add(j);\\n                }\\n            }\\n        }\\n        \\n        List<String> rst = new ArrayList<>();\\n        if (starts[s.length()] == null) {\\n            return rst;\\n        }\\n        \\n        dfs(rst, \"\", s, starts, s.length());\\n        return rst;\\n    }\\n\\n  \\n    private void dfs(List<String> rst, String path, String s, List<Integer>[] starts, int end) {\\n        if (end == 0) {\\n            rst.add(path.substring(1));\\n            return;\\n        }\\n        \\n        for (Integer start: starts[end]) {\\n            String word = s.substring(start, end);\\n            dfs(rst, \" \" + word + path, s, starts, start);\\n        }\\n    }\\n\\n    private int getMaxLen(Set<String> wordDict) {\\n        int max = 0;\\n        for (String s : wordDict) {\\n            max = Math.max(max, s.length());\\n        }\\n        return max;\\n    }\\n\\n\\nMethod 2: Memoization + Backtracking. Before I came up with Method 1, I also tried using a HashMap to memoize all the possible strings that can be formed starting from index i. I referred to this post from [@Pixel_][1] \\nThe time complexity is O(len(wordDict) ^ len(s / minWordLenInDict)) as @Pixel_ mentioned. The space complexity would be larger than other methods though. Here is my code: \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        HashMap<Integer, List<String>> memo = new HashMap<>(); // <Starting index, rst list>\\n        return dfs(s, 0, wordDict, memo);\\n    }\\n    \\n    private List<String> dfs(String s, int start, Set<String> dict, HashMap<Integer, List<String>> memo) {\\n        if (memo.containsKey(start)) {\\n            return memo.get(start);\\n        }\\n        \\n        List<String> rst = new ArrayList<>();\\n        if (start == s.length()) {\\n            rst.add(\"\");\\n            return rst;\\n        }\\n        \\n        String curr = s.substring(start);\\n        for (String word: dict) {\\n            if (curr.startsWith(word)) {\\n                List<String> sublist = dfs(s, start + word.length(), dict, memo);\\n                for (String sub : sublist) {\\n                    rst.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);\\n                }\\n            }\\n        }\\n        \\n        memo.put(start, rst);\\n        return rst;\\n    }\\n\\nMethod 3: DP Prunning + Backtracking. My very first solution is like this: using a boolean array to memoize whether a substring starting from position i to the end is breakable. This works well for worst cases like: s = \"aaaaaaaaaaaab\", dict = [\"a\", \"aa\", \"aaa\", \"aaaa\"]. However, for cases like: s = \"aaaaaaaaaaaaa\", dict = [\"a\", \"aa\", \"aaa\", \"aaaa\"], the time complexity is still O(2^n). Here is the code: \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        List<String> rst = new ArrayList<>();\\n        if (s == null || s.length() == 0 || wordDict == null) {\\n            return rst;\\n        }\\n        \\n        boolean[] canBreak = new boolean[s.length()];\\n        Arrays.fill(canBreak, true);\\n        StringBuilder sb = new StringBuilder();\\n        dfs(rst, sb, s, wordDict, canBreak, 0);\\n        return rst;\\n    }\\n    \\n    private void dfs(List<String> rst, StringBuilder sb, String s, Set<String> dict, \\n        boolean[] canBreak, int start) {\\n        if (start == s.length()) {\\n            rst.add(sb.substring(1));\\n            return;\\n        }\\n        \\n        if (!canBreak[start]) {\\n            return;\\n        }\\n        \\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String word = s.substring(start, i);\\n            if (!dict.contains(word)) continue;\\n            \\n            int sbBeforeAdd = sb.length();\\n            sb.append(\" \" + word);\\n            \\n            int rstBeforeDFS = rst.size();\\n            dfs(rst, sb, s, dict, canBreak, i);\\n            if (rst.size() == rstBeforeDFS) {\\n                canBreak[i] = false;\\n            }\\n            sb.delete(sbBeforeAdd, sb.length());\\n        }\\n    }\\n    \\n    private int getMaxLen(Set<String> wordDict) {\\n        int max = 0;\\n        for (String s : wordDict) {\\n            max = Math.max(max, s.length());\\n        }\\n        return max;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/65692/my-concise-java-solution-based-on-memorized-dfs",
                "codeTag": "Java"
            },
            {
                "id": 44368,
                "title": "python-easy-to-understand-solutions-memorization-dfs-dp-dfs",
                "content": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        return self.dfs(s, set(wordDict), {})\\n    \\n    def dfs(self, s, d, m):\\n        if s in m: # memorize\\n            return m[s]\\n        if not s:\\n            return [\"\"]\\n        res = []\\n        for i in range(1, len(s)+1):\\n            if s[:i] in d:\\n                for word in self.dfs(s[i:], d, m):\\n                    res.append(s[:i] + (\" \" if word else \"\") + word)\\n        m[s] = res\\n        return res\\n    \\n    def wordBreak1(self, s, wordDict):\\n        res = []\\n        self.dfs(s, set(wordDict), \"\", res)\\n        return res\\n    \\n    def dfs1(self, s, dic, path, res):\\n        if self.check(s, dic):\\n            if not s:\\n                res.append(path[1:])\\n            for i in range(1, len(s)+1):\\n                if s[:i] in d:\\n                    self.dfs(s[i:], dic, path+\" \"+s[:i], res)\\n                \\n    def check(self, s, dic):\\n        dp = [False] * (1+len(s))\\n        dp[0] = True\\n        for j in range(1, len(s)+1):\\n            for i in range(j):\\n                if dp[i] and s[i:j] in dic:\\n                    dp[j] = True\\n                    break\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        return self.dfs(s, set(wordDict), {})\\n    \\n    def dfs(self, s, d, m):\\n        if s in m: # memorize\\n            return m[s]\\n        if not s:\\n            return [\"\"]\\n        res = []\\n        for i in range(1, len(s)+1):\\n            if s[:i] in d:\\n                for word in self.dfs(s[i:], d, m):\\n                    res.append(s[:i] + (\" \" if word else \"\") + word)\\n        m[s] = res\\n        return res\\n    \\n    def wordBreak1(self, s, wordDict):\\n        res = []\\n        self.dfs(s, set(wordDict), \"\", res)\\n        return res\\n    \\n    def dfs1(self, s, dic, path, res):\\n        if self.check(s, dic):\\n            if not s:\\n                res.append(path[1:])\\n            for i in range(1, len(s)+1):\\n                if s[:i] in d:\\n                    self.dfs(s[i:], dic, path+\" \"+s[:i], res)\\n                \\n    def check(self, s, dic):\\n        dp = [False] * (1+len(s))\\n        dp[0] = True\\n        for j in range(1, len(s)+1):\\n            for i in range(j):\\n                if dp[i] and s[i:j] in dic:\\n                    dp[j] = True\\n                    break\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44179,
                "title": "slightly-modified-dp-java-solution",
                "content": "Hi guys!\\n\\nThere's a lot of concern in other posts about \"aaaa...aab\" test case that causes TLE when we run through our string not in reverse but from start to end. I've thought a bit on how to add a tiny modification and make just the whole thing more effective, not only pass the TLE case. \\n\\nThe approach is the same as before: we loop through all possible prefixes checking if it in the dictionary and caching the results. \\n\\nBut just before jumping into recursion we could also check that the right reminder has a prefix from the dictionary, because if it hasn't then there's no sense in splitting the reminder into sub-strings. It's just a linear check, which I think also could be optimized with some caching but even without optimization the solution is accepted. And also the code looks quite understandable.\\n\\n    public class Solution {\\n\\n        private final Map<String, List<String>> cache = new HashMap<>();\\n    \\n        private boolean containsSuffix(Set<String> dict, String str) {\\n            for (int i = 0; i < str.length(); i++) {\\n                if (dict.contains(str.substring(i))) return true;\\n            }\\n            return false;\\n        }\\n    \\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            if (cache.containsKey(s)) return cache.get(s);\\n            List<String> result = new LinkedList<>();\\n            if (dict.contains(s)) result.add(s);\\n            for (int i = 1; i < s.length(); i++) {\\n                String left = s.substring(0,i), right = s.substring(i);\\n                if (dict.contains(left) && containsSuffix(dict, right)) {\\n                    for (String ss : wordBreak(right, dict)) {\\n                        result.add(left + \" \" + ss);\\n                    }\\n                }\\n            }\\n            cache.put(s, result);\\n            return result;\\n        }\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n        private final Map<String, List<String>> cache = new HashMap<>();\\n    \\n        private boolean containsSuffix(Set<String> dict, String str) {\\n            for (int i = 0; i < str.length(); i++) {\\n                if (dict.contains(str.substring(i))) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 763221,
                "title": "python-dp-solution-explained",
                "content": "First of all, this problem is extention of problem 139. Word Break, where we need just to check if word can be broken into other words. Here we need to give all possible splits. Let us first put all words into `set` and create two lists:\\n\\n1. `dp_solution[i]` is all possible splits for first `i` symbols of `s`\\n2. `dp[i]` is indicator if we can split word or not.\\n\\nAlso we create this two lists with size `(n+1)` to handle border cases, in `dp[-1]` we will keep result for empty string `\"\"`.\\n\\n1. First step is to check if our string can be splitted at all, using problem 139. We need to do it, to candle strings like `aaaaa...aaab`, with `wordDict = [a, aa, aaa, ..., aa..aa]`. In this case answer will be `no`, but if we try to build solution directly we will get MLE. Try to remove this lines of code from solution and you will see.\\n2. Now, we do one more pass over data and start to build solutions: if we found that `s[j: k + 1] in wordSet`, then for every already built solution `sol in dp_solution[j-1]` we can add it to `dp_solution[k]`. \\n3. Finally, we have some extraspaces in the beginning of each solution, and instead of last element `[-1]` we need to return previous `[-2]`, so we return return `[s[1:] for s in dp_solution[-2]]`\\n\\n**Complexity**: to create `dp` we need `O(n^2m)` time, where `m` is average length of word and `O(n^2)` space. However for `dp_solution` part we can have potentially exponential number of solutions, for example even for `s = aa.....aa`, `wordDict = [a, aa]`. I think leetcode just will not give you tests, where memory will exceed some limit.\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        wordSet = set(wordDict)\\n        n = len(s)\\n        dp_solution = [[] for _ in range(n)] + [[\"\"]]\\n        dp = [0] * n + [1]\\n        \\n        for k in range(n):\\n            for j in range(k,-1,-1):\\n                if s[j: k + 1] in wordSet:\\n                    dp[k] = max(dp[k], dp[j-1])\\n\\n        if dp[-2] == 0: return []\\n\\n        for k in range(n):\\n            for j in range(k,-1,-1):\\n                if s[j: k + 1] in wordSet:\\n                    for sol in dp_solution[j-1]:\\n                        dp_solution[k].append(sol + \" \" + s[j: k + 1])\\n                        \\n        return [s[1:] for s in dp_solution[-2]]\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        wordSet = set(wordDict)\\n        n = len(s)\\n        dp_solution = [[] for _ in range(n)] + [[\"\"]]\\n        dp = [0] * n + [1]\\n        \\n        for k in range(n):\\n            for j in range(k,-1,-1):\\n                if s[j: k + 1] in wordSet:\\n                    dp[k] = max(dp[k], dp[j-1])\\n\\n        if dp[-2] == 0: return []\\n\\n        for k in range(n):\\n            for j in range(k,-1,-1):\\n                if s[j: k + 1] in wordSet:\\n                    for sol in dp_solution[j-1]:\\n                        dp_solution[k].append(sol + \" \" + s[j: k + 1])\\n                        \\n        return [s[1:] for s in dp_solution[-2]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44255,
                "title": "my-concise-answer",
                "content": "    public class Solution {\\n    public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> result = new ArrayList<String>();\\n        for(int j = s.length() - 1; j >= 0; j--){\\n            if(dict.contains(s.substring(j)))\\n                break;\\n            else{\\n                if(j == 0)\\n                    return result;\\n            }\\n        }\\n        for(int i = 0; i < s.length()-1; i++)\\n        {\\n            if(dict.contains(s.substring(0,i+1)))\\n            {\\n                List<String> strs = wordBreak(s.substring(i+1,s.length()),dict);\\n                if(strs.size() != 0)\\n                    for(Iterator<String> it = strs.iterator();it.hasNext();)\\n                    {\\n                        result.add(s.substring(0,i+1)+\" \"+it.next());\\n                    }\\n            }\\n        }\\n        if(dict.contains(s)) result.add(s);\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> result = new ArrayList<String>();\\n        for(int j = s.length() - 1; j >= 0; j--){\\n            if(dict.contains(s.substring(j)))\\n                break;\\n            else{\\n                if(j == 0)\\n                    return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 194615,
                "title": "dp-solution-with-detailed-text-and-video-explanation",
                "content": "## LeetCode 140. Word Break II\\n### Note\\nIf you prefer video over text, please check out this link: https://www.youtube.com/watch?v=xun6zHlX8kI\\nwhich has the same content as follows.\\n### Explanation\\n```cpp\\nExample 1:\\ns = \"catsanddog\"\\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\\n\\n// The basic idea for solving this problem is\\nThe result of a string can be generated from the results of its substrings.\\n\\n// Like, for string \"catsanddog\" (S) and one of its substrings \"catsand\" (T).\\n// Suppose we\\'ve known T can be broken into [\"cat\", \"sand\"] or [\"cats\", \"and\"],\\n// and \"catsanddog\"(S) = \"catsand\"(T) + \"dog\".\\n// We only need to check if \"dog\" is in the wordDict, which is true in this case.\\n// Let dp(S) denote the result of S.\\ndp(T) = \\n[\"cat\", \"sand\"], \\n[\"apple\", \"pen\"]\\n\\ndp(S) <= dp(T) + \"apple\" = \\n[\"cat\", \"sand\", \"apple\"], \\n[\"cats\", \"and\", \"apple\"] \\n\\n// Thus, we can have\\n>> state: Let dp[i] denote all valid breaks for s(0, i)\\nE.g. in the above case,\\ns(0, 6) = \"catsand\"\\ndp[6] = [\"cat\", \"sand\"], [\"cats\", \"and\"]\\n\\n// The way we solve this problem is like this:\\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\\nindex:    0   1   2   3   4   5   6   7   8   9\\n        +---------------------------------------+\\ns:      | c | a | t | s | a | n | d | d | o | g |\\n        +---------------------------------------+\\n          i   \\n          j\\n\\ndp[0] = []\\ndp[1] = []\\ndp[2] = [\"cat\"]\\ndp[3] = [\"cats\"]\\ndp[4] = []\\ndp[5] = []\\ndp[6] = [\"cat sand\",\"cats and\"]\\ndp[7] = []\\ndp[8] = []\\ndp[9] = [\"cat sand dog\",\"cats and dog\"]\\n\\n>> recurrence relation:\\ndp[i] = \\nfor (int j = 0; j < i; j++) {\\n\\tsubstr = s[j, i];\\n  if (dp[j].size() > 0 && wordDict.contains(substr)) {\\n      for (String l : dp[j]) {\\n          dp[i].add(l + substr);\\n      }\\n  }\\n}\\n```\\n### Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int N = s.size();\\n        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());\\n        \\n        vector<vector<string>> dp(N + 1, vector<string>());\\n        dp[0].emplace_back(\"\");\\n        for(int i = 1; i <= N; ++i){\\n            for(int j = 0; j < i; ++j){\\n                string substr = s.substr(j, i - j);\\n                if(dp[j].size() > 0 && wordSet.find(substr) != wordSet.end()){\\n                    for(string& l : dp[j]){\\n                        dp[i].emplace_back(l + (l == \"\" ? \"\" : \" \") + substr);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nExample 1:\\ns = \"catsanddog\"\\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\\n\\n// The basic idea for solving this problem is\\nThe result of a string can be generated from the results of its substrings.\\n\\n// Like, for string \"catsanddog\" (S) and one of its substrings \"catsand\" (T).\\n// Suppose we\\'ve known T can be broken into [\"cat\", \"sand\"] or [\"cats\", \"and\"],\\n// and \"catsanddog\"(S) = \"catsand\"(T) + \"dog\".\\n// We only need to check if \"dog\" is in the wordDict, which is true in this case.\\n// Let dp(S) denote the result of S.\\ndp(T) = \\n[\"cat\", \"sand\"], \\n[\"apple\", \"pen\"]\\n\\ndp(S) <= dp(T) + \"apple\" = \\n[\"cat\", \"sand\", \"apple\"], \\n[\"cats\", \"and\", \"apple\"] \\n\\n// Thus, we can have\\n>> state: Let dp[i] denote all valid breaks for s(0, i)\\nE.g. in the above case,\\ns(0, 6) = \"catsand\"\\ndp[6] = [\"cat\", \"sand\"], [\"cats\", \"and\"]\\n\\n// The way we solve this problem is like this:\\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\\nindex:    0   1   2   3   4   5   6   7   8   9\\n        +---------------------------------------+\\ns:      | c | a | t | s | a | n | d | d | o | g |\\n        +---------------------------------------+\\n          i   \\n          j\\n\\ndp[0] = []\\ndp[1] = []\\ndp[2] = [\"cat\"]\\ndp[3] = [\"cats\"]\\ndp[4] = []\\ndp[5] = []\\ndp[6] = [\"cat sand\",\"cats and\"]\\ndp[7] = []\\ndp[8] = []\\ndp[9] = [\"cat sand dog\",\"cats and dog\"]\\n\\n>> recurrence relation:\\ndp[i] = \\nfor (int j = 0; j < i; j++) {\\n\\tsubstr = s[j, i];\\n  if (dp[j].size() > 0 && wordDict.contains(substr)) {\\n      for (String l : dp[j]) {\\n          dp[i].add(l + substr);\\n      }\\n  }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int N = s.size();\\n        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());\\n        \\n        vector<vector<string>> dp(N + 1, vector<string>());\\n        dp[0].emplace_back(\"\");\\n        for(int i = 1; i <= N; ++i){\\n            for(int j = 0; j < i; ++j){\\n                string substr = s.substr(j, i - j);\\n                if(dp[j].size() > 0 && wordSet.find(substr) != wordSet.end()){\\n                    for(string& l : dp[j]){\\n                        dp[i].emplace_back(l + (l == \"\" ? \"\" : \" \") + substr);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507365,
                "title": "c-short-fast-dfs-hash-map-for-dp-speed-95-mem-94",
                "content": "```\\nclass Solution {\\n    public:\\n        vector<string> wordBreak(string s, vector<string>& wordDict) \\n        {\\n            int max_len = 0;\\n            unordered_set<string> dict;\\n            for(string& str : wordDict)\\n            {\\n                dict.insert(str);\\n                max_len = max(max_len, (int)str.length());\\n            }\\n\\n            unordered_map<int, vector<string>> mp;\\n            return break_word(s, 0, dict, max_len, mp);\\n        }\\n\\n    protected:\\n        vector<string> break_word(  const string& s, int n, unordered_set<string>& dict, \\n                                    int max_len, unordered_map<int, vector<string>>& mp)\\n        {\\n            if(mp.count(n)) return mp[n];\\n\\n            string str;\\n            for(int i = n; i < s.length() && str.length() <= max_len; ++i)\\n            {\\n                str += s[i];\\n                if(dict.count(str))\\n                {\\n                    if(i == s.length()-1)\\n                        mp[n].push_back(str);\\n                    else\\n                    {\\n                        vector<string> vs = break_word(s, i+1, dict, max_len, mp);\\n                        for(auto& a : vs) mp[n].push_back(str + \" \" + a);\\n                    }\\n                }\\n            }\\n            return mp[n];\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n        vector<string> wordBreak(string s, vector<string>& wordDict) \\n        {\\n            int max_len = 0;\\n            unordered_set<string> dict;\\n            for(string& str : wordDict)\\n            {\\n                dict.insert(str);\\n                max_len = max(max_len, (int)str.length());\\n            }\\n\\n            unordered_map<int, vector<string>> mp;\\n            return break_word(s, 0, dict, max_len, mp);\\n        }\\n\\n    protected:\\n        vector<string> break_word(  const string& s, int n, unordered_set<string>& dict, \\n                                    int max_len, unordered_map<int, vector<string>>& mp)\\n        {\\n            if(mp.count(n)) return mp[n];\\n\\n            string str;\\n            for(int i = n; i < s.length() && str.length() <= max_len; ++i)\\n            {\\n                str += s[i];\\n                if(dict.count(str))\\n                {\\n                    if(i == s.length()-1)\\n                        mp[n].push_back(str);\\n                    else\\n                    {\\n                        vector<string> vs = break_word(s, i+1, dict, max_len, mp);\\n                        for(auto& a : vs) mp[n].push_back(str + \" \" + a);\\n                    }\\n                }\\n            }\\n            return mp[n];\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764120,
                "title": "easy-to-understand-trie-solution-beats-100",
                "content": "**Intuition:**\\n* We need a DS to handle characters in a way that we can search for a particular word easily. (My choice was Trie).\\n* We should find all combinations of words in the given string s. (Hence I decided to solve it using dynamic programming/ recursion)\\n\\n**Explanation**\\n* If you are new to TRIE data structure, please go through [this problem.](https://leetcode.com/problems/implement-trie-prefix-tree/). We are going to implement a variant of the TRIE data structure.\\n* We only have to implement the `add` function of the Trie DS as we will be searching for the combinations of words using dp technique.\\n* This solution will involve two steps of preprocessing to reduce the time complexity.\\n\\t* First step is to form a TRIE with the given dictionary.\\n\\t* Second step is to check if all the letters in the string `s` are present in the dictionary. We will be using an int array `exists` which will be set to `1` whenever a letter is added to our TRIE. So, if there is any letter whose corresponding `exists` value is not `1`, then there is no way to form a combination with the given words, so we return an empty list.\\n* Now, how do we find the result?\\n* I have used DP technique to accomplish that. I have added comments wherever required in the below code so that you guys understand better.\\n* PS: I found the search method i implemented in this similar to this[question](https://leetcode.com/problems/all-paths-from-source-to-target/description/\\n\\n*Please upvote if you found this post useful and do post your questions down below if you have any.\\nCheers!*\\n\\n**Code**\\n```\\nclass Solution {\\n\\n    int[] exists;\\n    Trie root;\\n    \\n    public void search(List<String> ans, Trie curr, StringBuilder temp, char[] given, int index){\\n        if(index==given.length){\\n            return;\\n        } \\n        if(curr.children[given[index]-\\'a\\'] == null)return;\\n        \\n        Trie next = curr.children[given[index] - \\'a\\'];\\n        temp.append(given[index]);\\n        \\n        //If the word is present in the dictionary, we can either add a space or we continue going down in the trie\\n        if(next.isWord){\\n            //If we have reached the end of the string, add the value to Answer and terminate\\n            if(index+1 == given.length){\\n                ans.add(temp.toString());\\n                temp.deleteCharAt(temp.length()-1); \\n                return;\\n                }\\n            else{\\n                //We are adding space\\n                temp.append(\" \");\\n                //Since after adding space, the next letter should be the beginning of a new word from the dictionary, we pass in the ROOT trie node\\n                search(ans, root, temp, given, index+1);\\n                //remove the space we added in the above line.\\n                temp.deleteCharAt(temp.length()-1);      \\n            }\\n        }\\n        \\n        //since we have not added a space, we are technically going down in the same trie block. So we are moving the NEXT node in the CURR trie node.\\n        search(ans, next, temp, given, index+1);\\n            \\n        //Deleting the added character\\n        temp.deleteCharAt(temp.length()-1);            \\n\\n    }\\n    \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        root = new Trie();\\n        exists = new int[26];\\n        List<String> ans = new ArrayList();\\n        for(String word : wordDict){\\n            root.addWord(word);\\n        }\\n        \\n        for(char c : s.toCharArray()){\\n            if(exists[c-\\'a\\']!=1)\\n                return new ArrayList();\\n        }\\n        search(ans, root, new StringBuilder(), s.toCharArray(), 0);\\n        return ans;\\n    }\\n\\n    \\n    class Trie{\\n        boolean isWord;\\n        Trie[] children;\\n        Trie(){\\n            isWord=false;\\n            children = new Trie[26];\\n        }\\n        public void addWord(String w){\\n            Trie curr = this;\\n            int index = 0;\\n            char[] word = w.toCharArray();\\n            while(index<word.length){   \\n                exists[word[index]-\\'a\\']=1;\\n                if(curr.children[word[index]-\\'a\\'] == null){\\n                    curr.children[word[index]-\\'a\\'] = new Trie();\\n                }  \\n                curr = curr.children[word[index]-\\'a\\'];\\n                index++;\\n            }\\n            curr.isWord = true;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[] exists;\\n    Trie root;\\n    \\n    public void search(List<String> ans, Trie curr, StringBuilder temp, char[] given, int index){\\n        if(index==given.length){\\n            return;\\n        } \\n        if(curr.children[given[index]-\\'a\\'] == null)return;\\n        \\n        Trie next = curr.children[given[index] - \\'a\\'];\\n        temp.append(given[index]);\\n        \\n        //If the word is present in the dictionary, we can either add a space or we continue going down in the trie\\n        if(next.isWord){\\n            //If we have reached the end of the string, add the value to Answer and terminate\\n            if(index+1 == given.length){\\n                ans.add(temp.toString());\\n                temp.deleteCharAt(temp.length()-1); \\n                return;\\n                }\\n            else{\\n                //We are adding space\\n                temp.append(\" \");\\n                //Since after adding space, the next letter should be the beginning of a new word from the dictionary, we pass in the ROOT trie node\\n                search(ans, root, temp, given, index+1);\\n                //remove the space we added in the above line.\\n                temp.deleteCharAt(temp.length()-1);      \\n            }\\n        }\\n        \\n        //since we have not added a space, we are technically going down in the same trie block. So we are moving the NEXT node in the CURR trie node.\\n        search(ans, next, temp, given, index+1);\\n            \\n        //Deleting the added character\\n        temp.deleteCharAt(temp.length()-1);            \\n\\n    }\\n    \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        root = new Trie();\\n        exists = new int[26];\\n        List<String> ans = new ArrayList();\\n        for(String word : wordDict){\\n            root.addWord(word);\\n        }\\n        \\n        for(char c : s.toCharArray()){\\n            if(exists[c-\\'a\\']!=1)\\n                return new ArrayList();\\n        }\\n        search(ans, root, new StringBuilder(), s.toCharArray(), 0);\\n        return ans;\\n    }\\n\\n    \\n    class Trie{\\n        boolean isWord;\\n        Trie[] children;\\n        Trie(){\\n            isWord=false;\\n            children = new Trie[26];\\n        }\\n        public void addWord(String w){\\n            Trie curr = this;\\n            int index = 0;\\n            char[] word = w.toCharArray();\\n            while(index<word.length){   \\n                exists[word[index]-\\'a\\']=1;\\n                if(curr.children[word[index]-\\'a\\'] == null){\\n                    curr.children[word[index]-\\'a\\'] = new Trie();\\n                }  \\n                curr = curr.children[word[index]-\\'a\\'];\\n                index++;\\n            }\\n            curr.isWord = true;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44299,
                "title": "java-6ms-simple-solution-beating-88",
                "content": "    public class Solution {\\n        HashMap<Integer, List<String>> dp = new HashMap<>();\\n\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            int maxLength = -1;\\n            for(String ss : wordDict) maxLength = Math.max(maxLength, ss.length());\\n            return addSpaces(s, wordDict, 0, maxLength);\\n        }\\n        \\n        private List<String> addSpaces(String s, Set<String> wordDict, int start, int max){\\n            List<String> words = new ArrayList<>();\\n            if(start == s.length()) {\\n                words.add(\"\");\\n                return words;\\n            }\\n            for(int i = start + 1; i <= max + start && i <= s.length(); i++){\\n                String temp = s.substring(start, i);\\n                if(wordDict.contains(temp)){\\n                    List<String> ll;\\n                    if(dp.containsKey(i)) ll = dp.get(i);\\n                    else ll = addSpaces(s, wordDict, i, max);\\n                    for(String ss : ll) words.add(temp + (ss.equals(\"\") ? \"\" : \" \") + ss);\\n                }\\n                \\n            }\\n            dp.put(start, words);\\n            return words;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        HashMap<Integer, List<String>> dp = new HashMap<>();\\n\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            int maxLength = -1;\\n            for(String ss : wordDict) maxLength = Math.max(maxLength, ss.length());\\n            return addSpaces(s, wordDict, 0, maxLength);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 44262,
                "title": "my-c-dp-dfs-solution-4ms",
                "content": "The basic idea is to use DP to create an array isBreakable[i] to indicate whether s[i..sSize-1] is breakable. Then we can use such information to help us speed up the DFS path build process (buildPath). Learned from other posts, I first calculated minlen and maxlen to speed up the process.\\n  \\n\\n    class Solution {\\n    private: //DFS path build function\\n        void buildPath(bool isBreakable[], string &s, int pos, vector<string> &res, string curP, unordered_set<string>& wordDict, int minlen, int maxlen)\\n        {\\n            int i, len = s.size();\\n            for(i =minlen; i<= min(maxlen, len - pos); ++i)\\n                if( isBreakable[pos+i] && wordDict.count(s.substr(pos,i)) ) \\n                    if(pos+i == len) res.push_back(curP + s.substr(pos,i));\\n                    else buildPath(isBreakable, s, pos+i, res, curP + s.substr(pos,i) + \" \", wordDict, minlen, maxlen);\\n        }\\n        \\n    public:\\n        vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n            int sSize = s.size(), len, i, minlen = INT_MAX, maxlen = INT_MIN;\\n            vector<string> res;\\n            bool isBreakable[sSize+1];\\n            fill_n(isBreakable, sSize+1, false);\\n                \\n            for (string word : wordDict) { // find the minimum and maximum word length \\n                minlen = min(minlen, (int)word.length());\\n                maxlen = max(maxlen, (int)word.length()); \\n            }        \\n            //DP to build isBreakable\\n            for(i=sSize-minlen, isBreakable[sSize]= true; i>=0; --i)\\n                for(len=minlen; len<=min(maxlen, sSize-i); ++len)\\n                {\\n                    if(isBreakable[i+len] && wordDict.count(s.substr(i,len)) ) {isBreakable[i] = true; break;}\\n                }\\n            //if breakable, do DFS path building\\n            if(isBreakable[0]) buildPath(isBreakable, s, 0, res, \"\", wordDict, minlen, maxlen);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private: //DFS path build function\\n        void buildPath(bool isBreakable[], string &s, int pos, vector<string> &res, string curP, unordered_set<string>& wordDict, int minlen, int maxlen)\\n        {\\n            int i, len = s.size();\\n            for(i =minlen; i<= min(maxlen, len - pos); ++i)\\n                if( isBreakable[pos+i] && wordDict.count(s.substr(pos,i)) ) \\n                    if(pos+i == len) res.push_back(curP + s.substr(pos,i));\\n                    else buildPath(isBreakable, s, pos+i, res, curP + s.substr(pos,i) + \" \", wordDict, minlen, maxlen);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 44264,
                "title": "java-dfs-dp-clean-solution",
                "content": "The basic backtracking idea is straightforward, find a possible break point and then recursively call the suffix of the original string.  The trick is that we use a map to keep the previous result which will terminate the recursion early to make sure we don't get TLE.\\n\\n\\n    public class Solution {\\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            return dfs(s, dict, new HashMap<>());\\n        }\\n    \\n        public List<String> dfs(String s, Set<String> dict, Map<String, List<String>> memo){\\n            if(memo.containsKey(s)) {\\n                return memo.get(s);\\n            }\\n            List<String> res = new ArrayList<>();\\n            if(s == null || s.length() == 0) {\\n                return res;\\n            }\\n            int n = s.length();\\n            \\n            for(String w : dict) {\\n                if(!s.startsWith(w)) {\\n                    continue;\\n                }\\n                int end = w.length();\\n                if(end == n) {\\n                    res.add(w);\\n                } else {\\n                    List<String> sublist = dfs(s.substring(end), dict, memo);\\n                    for(String item : sublist) {\\n                        item = w + \" \" + item;\\n                        res.add(item);\\n                    }\\n                }\\n            }\\n            \\n            memo.put(s, res);\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            return dfs(s, dict, new HashMap<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1175903,
                "title": "c-backtracking-simple-code",
                "content": "```\\nvector<string> sentences;\\nvector<string> wordBreak(string s, vector<string>& wordDict)\\n{\\n    unordered_set<string> setting;\\n    setting.insert(wordDict.begin(), wordDict.end());\\n    dfs(s, \"\", setting);\\n    return sentences;\\n}\\n\\nvoid dfs(string s, string sentence, unordered_set<string>& setting)\\n{\\n    if(s.empty())\\n    {\\n        sentence.pop_back();\\n        sentences.push_back(sentence);\\n        return;\\n    }\\n    int n = s.size();\\n    for(int i = 1; i <= n; i++)\\n    {\\n        if(!setting.count(s.substr(0, i)))\\n            continue;\\n        dfs(s.substr(i), sentence + s.substr(0, i) + \" \", setting);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<string> sentences;\\nvector<string> wordBreak(string s, vector<string>& wordDict)\\n{\\n    unordered_set<string> setting;\\n    setting.insert(wordDict.begin(), wordDict.end());\\n    dfs(s, \"\", setting);\\n    return sentences;\\n}\\n\\nvoid dfs(string s, string sentence, unordered_set<string>& setting)\\n{\\n    if(s.empty())\\n    {\\n        sentence.pop_back();\\n        sentences.push_back(sentence);\\n        return;\\n    }\\n    int n = s.size();\\n    for(int i = 1; i <= n; i++)\\n    {\\n        if(!setting.count(s.substr(0, i)))\\n            continue;\\n        dfs(s.substr(i), sentence + s.substr(0, i) + \" \", setting);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 978368,
                "title": "backtracking-memo-explanation-3-visuals-python",
                "content": "***TL;DR (Visuals  + Explanation below code snippet)*** This code follows the standard [backtracking template](https://leetcode.com/problems/subsets/discuss/973667/backtracking-template-explanation-visual-python). We keep track of indexes that cannot lead to valid solution and make sure we do not visit them. We do this by keeping a memo (memoization)\\n\\n\\n```python\\n def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res = []\\n        self.backtrack(0, len(s), [], res, s, wordDict, set()) \\n        return res\\n    \\n    def backtrack(self, start, end, sentence, result, string, wordDict, bad):\\n        # seen this prefix before, path did not lead to valid answer\\n        if start in bad: \\n            return  \\n        \\n        if start == end:\\n            result.append(\\' \\'.join(sentence))\\n            return\\n        \\n        before = len(result)\\n        for w in wordDict:\\n            if string[start:].startswith(w):\\n                sentence.append(w)\\n                self.backtrack(start + len(w), end, sentence, result, string, wordDict, bad)\\n                sentence.pop()\\n                \\n        after = len(result)\\n        # no result has been added bad path. \\n\\t\\t# the this index will never lead to a feasible solution\\n        if before == after: bad.add(start)\\n\\n```\\n### Explanation\\nThe goal of this problem is to return all possible sentences that meet the constraints of the problem. We need to be exaushtive (collect all possibilities). This is an indication the problem can be solved with backtracking. \\n\\nthe constraints for this problem as follows \\n1. we must construct words for our sentence from string ```s``` by adding spaces \\n2. every word in the sentence must be valid dictionary word \\n\\nsince we can construct sentences by adding spaces, all the characters in our original string ```s``` must be used. \\n\\nif we manage to use all characters we have found a solution.\\n\\nwe can mimick inserting spaces by looking at prefixes of substrings. \\n```python\\n\\ts[start:].startswith(w)\\n```\\n\\n### Optimization\\nfor some examples there are many combinations that fail to produce a solution.  this can lead to an enormous amount of unecessary recursive calls, wreaking havoc on the time complexity. \\n\\n***the key observation for optimization*** is that if a prefix starting from index ```start```does not lead to a feasible solution, any time that same index is visited again it will also will fail to lead to feasible solution. \\n\\n* The initial examples could have been better selected as they do not show the need for memoization and it is not immediately obvious.\\n\\n* to help the reader fully understand the code above and the reason why memoization must be used for an efficient solution 3 visuals have been included below \\n\\n### Visual Example 1\\nregardless of whether memiozation is used our not, this example performs the same.\\nwhen ```try ``` is used, it is to denote each word that is being looped through, the last word denotes the selected word. in the below examole ```applepen``` is the selected word. \\n```try: apple,  pen, applepen```\\n\\n![image](https://assets.leetcode.com/users/images/b9138d01-ef38-4e50-bf97-7c34dc6f5e36_1608427761.2446313.png)\\n\\n\\n### Visual Example 2 \\n\\nan example where memiozation is not used. nodes of the same color are repeating indexes. note this problem no sentences are generated. no path leads to a feasible solution. \\n![image](https://assets.leetcode.com/users/images/4eb795eb-faf2-428a-88e2-9bc6194749f3_1608427409.9636602.png)\\n\\n\\n\\n### Visual Example 3 \\n\\nThe same as example 2. This time memoization is used. indexes that lead to unfeasible solutions are cached. if index is in cache, no need to explore any further. the red ```X``` on a node in the recursion tree symbolizes that a index has been found in the cache. all nodes below a red ```X``` node in this diagram actually dont exist. no recursive call was made for these nodes. included them for a more complete visual\\n\\n\\n![image](https://assets.leetcode.com/users/images/6f21790a-74d1-4f5f-a567-0bd3898ed267_1608427614.8162823.png)\\n\\n\\n\\n\\n\\n[code courtesy of serdes\\n ](https://leetcode.com/problems/word-break-ii/discuss/973144/Python3-Recursive-Backtracking-w-Pruning.-O(S)-extra-space)",
                "solutionTags": [
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```python\\n def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res = []\\n        self.backtrack(0, len(s), [], res, s, wordDict, set()) \\n        return res\\n    \\n    def backtrack(self, start, end, sentence, result, string, wordDict, bad):\\n        # seen this prefix before, path did not lead to valid answer\\n        if start in bad: \\n            return  \\n        \\n        if start == end:\\n            result.append(\\' \\'.join(sentence))\\n            return\\n        \\n        before = len(result)\\n        for w in wordDict:\\n            if string[start:].startswith(w):\\n                sentence.append(w)\\n                self.backtrack(start + len(w), end, sentence, result, string, wordDict, bad)\\n                sentence.pop()\\n                \\n        after = len(result)\\n        # no result has been added bad path. \\n\\t\\t# the this index will never lead to a feasible solution\\n        if before == after: bad.add(start)\\n\\n```\n```s```\n```s```\n```python\\n\\ts[start:].startswith(w)\\n```\n```start```\n```try ```\n```applepen```\n```try: apple,  pen, applepen```\n```X```\n```X```",
                "codeTag": "Python3"
            },
            {
                "id": 1087111,
                "title": "clean-simple-javascript-with-explanation-walkthrough-100-100",
                "content": "![image](https://assets.leetcode.com/users/images/376b4b3d-7499-45be-9fa8-0baeb4f8c47e_1615591486.3132093.png)\\n\\nEDIT: This problem came up for me again recently and I couldn\\'t remember my exact code when I solved it the first time.  I think the code I wrote the second time around is easier to understand, so I\\'m including it right below this edit.  I slightly overcomplicated this one on the first go with the .forEach stuff.  Knowing the basic approach let me write a simpler solution this time around.  There\\'s also a one-liner at the very bottom because I was bored. lol\\n\\n```\\nconst wordBreak = (s, wordDict, cur = [], res = []) => {\\n  if (!s.length) return res.push(cur.join(\\' \\'));\\n  for (let word of wordDict) {\\n    if (!s.startsWith(word)) continue;\\n    cur.push(word);\\n    wordBreak(s.slice(word.length), wordDict, cur, res);\\n    cur.pop();\\n  }\\n  return res;\\n}\\n```\\n\\nTestCase: s = \\'catsanddog\\', wordDict = [\\'cat\\', \\'cats\\', \\'and\\', \\'sand\\', \\'dog\\']\\n\\nWe begin by initializing a new hash map in the arguments.  From there, algorithm checks to see if current string is in hashmap.  First time it runs, it\\'s obviously empty.  In fact, the first time a word is added, it will be the last word.  In this case -> {\\'dog\\': [\\'dog\\']} will be first entry.  This entry seems pointless, but from here, it will pop back up to last call \\'sanddog\\'.  Sand was the word found on this round of iterations, so {\\'sanddog\\': [\\'sand dog\\']} is the next entry, and so on back up until the initial call.  In this way, it will take the initial input string and recursively build up the hash map from smallest components until eventually {\\'catsanddog\\': [\\'cat sand dog\\', \\'cats and dog\\'].\\n\\nIn order to do this recursively, we take the initial string and loop through the dictionary.  We check the first word in the dictionary - cat and check if \\'catsanddog\\' starts with that word.  It does, so we initialize a new variable to equal what is left of the string - \\'sanddog\\'.  We then check if this new leftAfter string\\'s length is === 0 (Or !leftAfter.length.  This is the same as leftAfter.length === 0 since 0 is a false-y value).  If it is, we know we have matched the entire string.  If not, we call the function again on the new string.  This time the \\'leftAfter\\' string = \\'sanddog\\'.  Loop matches \\'sand\\', leftAfter is dog.  Function runs again with \\'dog\\' as the argument.  \\'Dog\\' matches in loop, leftAfter.length === 0.  {\\'dog\\':[\\'dog\\']} is set.  On the \\'sanddog\\' level of the recursion call (back on this one since dog found the end of the string and fully finished its execution) \\'sand\\' is the current word. else wordBreak(\\'dog\\', wordDict, cache) runs and returns [\\'dog\\']. For each loop runs on this array and pushes \\'sand\\' + \\' \\' + \\'dog\\' to result.  cache is set with \\'sanddog\\': [\\'sand dog\\'].  In this way, we recurse down to the smallest word and build the combinations up until the full string has been constructed in this manner.  \\n```\\nconst wordBreak = (s, wordDict, cache = new Map()) => {\\n    if(cache.has(s)) return cache.get(s);\\n\\t    \\n    const result = [];\\n    for(const word of wordDict){\\n        if (s.startsWith(word)){\\n            const leftAfter = s.slice(word.length);\\n            if(!leftAfter.length) result.push(word);\\n            else wordBreak(leftAfter, wordDict, cache).forEach(val => result.push(word + \\' \\' + val));\\n        }\\n    }\\n    \\n    cache.set(s, result);\\n    return result;\\n};\\n```\\n\\nFirst function call:  \\'catsanddog\\'  loop through dictionary finds two matches. \\'cat\\' and \\'cats\\'.\\n\\tLeftovers = \\'sanddog\\' and \\'anddog\\'.\\n\\nFunction runs on both of these in first level of recursive calls.  \\n\\t\\'sanddog\\' matches \\'sand\\'.  leftAfter = \\'dog\\' \\n\\t\\'anddog\\' matches \\'and\\'.  leftAfter = \\'dog\\'\\n\\t\\nFunction runs on \\'dog\\' twice in next level of recursive calls.\\n\\t\\'dog\\' matches \\'dog\\'.  results = [dog]. leftAfter = \\'\\'.  dog is added to memo and the second time this recursive call is ran, it is found.\\n\\t[\\'dog\\'] returned to call above.\\n\\t\\nAbove \\'sanddog\\' call with \\'sand\\' as current word and [\\'dog\\'] returned as potential matches for leftAfter.  ForEach loop runs on [\\'dog\\'].\\n\\'sand dog\\' is pushed to results.\\n\\nIn same fashion, \\'anddog\\' pushes [\\'and dog\\'] to results.  Both of these are added to memo and returned to calls above.\\n\\nBack on first call - words matched were \\'cat\\' and \\'cats\\'. \\n\\t[\\'sand dog\\'] is returned from recursive (sanddog) call.  forEach runs and adds \\'cat sand dog\\' to results.\\n\\t[\\'and dog\\'] is returned from recursive (anddog) call.  forEach runs and adds \\'cats and dog\\' to results.\\n\\t\\nResults are returned.\\n\\n\\nOne-liner:\\n```\\nconst wordBreak=(s,w,c,a=[])=>s?!(w.forEach(n=>s.startsWith(n)&&wordBreak(s.slice(n.length),w,c?`${c} ${n}`:n,a)))&&a:a.push(c)\\n```\\n\\nCool trie solution just because I\\'ve been practicing trie problems lately:\\n```\\nconst wordBreak = (s, words) => {\\n  const trie = words.reduce((trie, word) => {\\n    let runner = trie\\n    for (let char of word) {\\n      runner = runner[char] = runner[char] || {}\\n    }\\n    runner.end = word\\n    return trie\\n  }, {})\\n  \\n  const ans = new Array(s.length + 1).fill(false)\\n  ans[0] = [\\'\\']\\n  for (let i = 0; i < s.length + 1; i++) {\\n    if (!ans[i]) continue\\n    let runner = trie, runIdx = i + 1\\n    while (runner) {\\n      const char = s[runIdx - 1]\\n      runner = runner[char]\\n      if (runner && runner.end) {\\n        ans[runIdx] = ans[runIdx] || []\\n        ans[i].forEach(arr => ans[runIdx].push([...arr, runner.end]))\\n      }\\n      runIdx++\\n    }\\n  }\\n  return ans[s.length] ? ans[s.length].map(words => words.join(\\' \\')) : []\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nconst wordBreak = (s, wordDict, cur = [], res = []) => {\\n  if (!s.length) return res.push(cur.join(\\' \\'));\\n  for (let word of wordDict) {\\n    if (!s.startsWith(word)) continue;\\n    cur.push(word);\\n    wordBreak(s.slice(word.length), wordDict, cur, res);\\n    cur.pop();\\n  }\\n  return res;\\n}\\n```\n```\\nconst wordBreak = (s, wordDict, cache = new Map()) => {\\n    if(cache.has(s)) return cache.get(s);\\n\\t    \\n    const result = [];\\n    for(const word of wordDict){\\n        if (s.startsWith(word)){\\n            const leftAfter = s.slice(word.length);\\n            if(!leftAfter.length) result.push(word);\\n            else wordBreak(leftAfter, wordDict, cache).forEach(val => result.push(word + \\' \\' + val));\\n        }\\n    }\\n    \\n    cache.set(s, result);\\n    return result;\\n};\\n```\n```\\nconst wordBreak=(s,w,c,a=[])=>s?!(w.forEach(n=>s.startsWith(n)&&wordBreak(s.slice(n.length),w,c?`${c} ${n}`:n,a)))&&a:a.push(c)\\n```\n```\\nconst wordBreak = (s, words) => {\\n  const trie = words.reduce((trie, word) => {\\n    let runner = trie\\n    for (let char of word) {\\n      runner = runner[char] = runner[char] || {}\\n    }\\n    runner.end = word\\n    return trie\\n  }, {})\\n  \\n  const ans = new Array(s.length + 1).fill(false)\\n  ans[0] = [\\'\\']\\n  for (let i = 0; i < s.length + 1; i++) {\\n    if (!ans[i]) continue\\n    let runner = trie, runIdx = i + 1\\n    while (runner) {\\n      const char = s[runIdx - 1]\\n      runner = runner[char]\\n      if (runner && runner.end) {\\n        ans[runIdx] = ans[runIdx] || []\\n        ans[i].forEach(arr => ans[runIdx].push([...arr, runner.end]))\\n      }\\n      runIdx++\\n    }\\n  }\\n  return ans[s.length] ? ans[s.length].map(words => words.join(\\' \\')) : []\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44353,
                "title": "my-dp-solution-in-java",
                "content": "    public class Solution {\\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            Map<Integer, List<String>> validMap = new HashMap<Integer, List<String>>();\\n    \\n            // initialize the valid values\\n            List<String> l = new ArrayList<String>();\\n            l.add(\"\");\\n            validMap.put(s.length(), l);\\n    \\n            // generate solutions from the end\\n            for(int i = s.length() - 1; i >= 0; i--) {\\n                List<String> values = new ArrayList<String>();\\n                for(int j = i + 1; j <= s.length(); j++) {\\n                    if (dict.contains(s.substring(i, j))) {\\n                        for(String word : validMap.get(j)) {\\n                            values.add(s.substring(i, j) + (word.isEmpty() ? \"\" : \" \") + word);\\n                        }\\n                    }\\n                }\\n                validMap.put(i, values);\\n            }\\n            return validMap.get(0);\\n        }\\n    }\\n\\nBasically my idea is the following:\\n\\n 1. Scan the the string from the tail\\n 2. Build possible solution for the current index based on DP results\\n 3. Return the solution when index==0",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            Map<Integer, List<String>> validMap = new HashMap<Integer, List<String>>();\\n    \\n            // initialize the valid values\\n            List<String> l = new ArrayList<String>();\\n            l.add(\"\");\\n            validMap.put(s.length(), l);\\n    \\n            // generate solutions from the end\\n            for(int i = s.length() - 1; i >= 0; i--) {\\n                List<String> values = new ArrayList<String>();\\n                for(int j = i + 1; j <= s.length(); j++) {\\n                    if (dict.contains(s.substring(i, j))) {\\n                        for(String word : validMap.get(j)) {\\n                            values.add(s.substring(i, j) + (word.isEmpty() ? \"\" : \" \") + word);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2617582,
                "title": "0-ms-efficient-c-solution-simple-recursion",
                "content": "```\\n\\tvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> ans;\\n        set<string> dict (wordDict.begin(), wordDict.end());\\n        f(0, s, \"\", ans, dict);\\n        return ans;\\n    }\\n\\n\\tvoid f(int ind, string &s, string temp, vector<string>& ans, set<string>& dict) {\\n        if(ind == s.length()) {\\n            temp.pop_back(); // pop the trailing space\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        string cur = \"\";\\n        for(int i = ind; i < s.length(); i++) {\\n            cur.push_back(s[i]);\\n            if(dict.find(cur) != dict.end()) {\\n                f(i+1, s, temp + cur + \" \", ans, dict); // adding current substring \\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\tvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> ans;\\n        set<string> dict (wordDict.begin(), wordDict.end());\\n        f(0, s, \"\", ans, dict);\\n        return ans;\\n    }\\n\\n\\tvoid f(int ind, string &s, string temp, vector<string>& ans, set<string>& dict) {\\n        if(ind == s.length()) {\\n            temp.pop_back(); // pop the trailing space\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        string cur = \"\";\\n        for(int i = ind; i < s.length(); i++) {\\n            cur.push_back(s[i]);\\n            if(dict.find(cur) != dict.end()) {\\n                f(i+1, s, temp + cur + \" \", ans, dict); // adding current substring \\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279443,
                "title": "python-40ms-beating-98-4-thoroughly-commented-re-post",
                "content": "Apologies for being unable to find the code of which this is a re-post (I searched a fair few but couldn\\'t find it again). \\n\\nThis is similar to other solutions (esp. similar given that it\\'s a re-post), however this version is thoroughly commented to aid in your understanding. I have also adjusted the structure of the code & variable names for this same purpose. For noobies, understand that we are defining dfs within the first function, which means that the dfs function can use the non-local variable `result` because it\\'s defined previously in the same namespace. \\n\\nLet me know if you find the original code so that I can post a link here!\\n\\n**Second Solution**: I also added a second solution that uses a `deque` (double ended que) for O(1) adding to the path, but this doesn\\'t change the Leetcode performance. Its performance difference depends on (a) the number of possible paths (O(b^d) where `d` = len(s) / average length of sub-words and `b` is the number of matching sub-words at each point) because this impacts the number of times we use operations to add to the path, and (b) the difference in speed between those operations that we use to add to our path. It also depends on (c) the performance difference between the final append in the first solution and the performance of `\" \".join(path)` and the number of times we execute that operation (which equals the number of solutions for a given input).\\n\\n**Path Joining Operations**: Python\\'s normal string concatenation for all of those possible paths (O(n)) vs the speed of `.appendleft(str)` + `.popleft()` for a `deque` for those same possible paths + the time for all of the `\" \".join(path)`s to execute (each takes O(n) and it only occurs once for each solution).  Correct me if this has changed, but string concatenation in Python occurs in O(n+m) (where `n` and `m` are the lengths of the strings being added), which is obviously slower than the two constant time (O(1)) operations that are `deque`\\'s popleft and appendleft, thus for large inputs the `deque` solution should be faster.\\n\\n**First Solution that uses String Concatenation**\\n```python\\nclass Solution:\\n    def wordBreak(self, s, words):\\n        \"\"\"40ms, beating 98.4%. Uses DP to determine reachable locations\\n        in the word, then a DFS to explore paths from the start to the \\n        end of the word.\\n        \\n        Uses varying string concatenation to add to path.\\n        \"\"\"\\n        result = []\\n             \\n        def dfs(dp, end, path):\\n            \"\"\"A DFS to add paths that reach from the end of the word\\n            to the start.\\n            \"\"\"\\n            # If we have reached the start of the word, add to result\\n            if 0 == end:\\n                result.append(path)\\n                return\\n                \\n            # Otherwise consider each possible path from the end\\n            for word in dp[end]:\\n\\n                # If we already have a word in the path, add a space in between\\n                if path:\\n                    dfs(dp, end - len(word), word + \" \" + path)\\n                else:\\n                    dfs(dp, end - len(word), word)\\n        \\n        # Used for O(1) lookup\\n        word_set = set(words)\\n        \\n        # Used for limiting the search for substrings (words) ending at each position\\n        max_len = max([len(w) for w in words + [\\'\\']])\\n        \\n        # Stores whether a combination of words from `words` can reach the position\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[0] = True\\n        \\n        # Words ending at i\\n        for i in range(1, len(s) + 1):\\n            \\n            # j defines a reachable location & start of a word ending at i\\n            for j in range(max(0, i - max_len), i):\\n            \\n                # If j is a reachable position & j to i defines a dictionary word\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i].append(s[j:i])\\n    \\n        # For each word in dp[len(s)], explore if it\\'s possible to reach the start of s.\\n        # If so, append a joining of the path to our output\\n        dfs(dp, len(s), \"\")\\n        return result\\n```\\n\\n**Second Solution using `deque`**:\\n```python\\nfrom collections import deque\\nclass Solution:\\n    def wordBreak(self, s, words):\\n        \"\"\"40ms, beating 98.4%. Uses DP to determine reachable locations\\n        in the word, then a DFS to explore paths from the start to the \\n        end of the word.\\n        \\n        Uses a deque() to append to and pop from left of list in O(1),\\n        and uses \" \".join(path) to add to result.\\n        \"\"\"\\n        result = []\\n             \\n        def dfs(dp, end, path):\\n            \"\"\"A DFS to add paths that reach from the end of the word\\n            to the start.\\n            \"\"\"\\n            # If we have reached the start of the word, add to result\\n            if 0 == end:\\n                result.append(\" \".join(path))\\n                return\\n                \\n            # Otherwise consider each possible path from the end\\n            for word in dp[end]:\\n                path.appendleft(word)\\n                dfs(dp, end-len(word), path)\\n                path.popleft()\\n\\n        # Used for O(1) lookup\\n        word_set = set(words)\\n        \\n        # Used for limiting the search for substrings (words) ending at each position\\n        max_len = max([len(w) for w in words + [\\'\\']])\\n        \\n        # Stores whether a combination of words from `words` can reach the position\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[0] = True\\n        \\n        # Words ending at i\\n        for i in range(1, len(s) + 1):\\n            \\n            # j defines a reachable location & start of a word ending at i\\n            for j in range(max(0, i - max_len), i):\\n            \\n                # If j is a reachable position & j to i defines a dictionary word\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i].append(s[j:i])\\n    \\n        # For each word in dp[len(s)], explore if it\\'s possible to reach the start of s.\\n        # If so, append a joining of the path to our output\\n        dfs(dp, len(s), deque())\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def wordBreak(self, s, words):\\n        \"\"\"40ms, beating 98.4%. Uses DP to determine reachable locations\\n        in the word, then a DFS to explore paths from the start to the \\n        end of the word.\\n        \\n        Uses varying string concatenation to add to path.\\n        \"\"\"\\n        result = []\\n             \\n        def dfs(dp, end, path):\\n            \"\"\"A DFS to add paths that reach from the end of the word\\n            to the start.\\n            \"\"\"\\n            # If we have reached the start of the word, add to result\\n            if 0 == end:\\n                result.append(path)\\n                return\\n                \\n            # Otherwise consider each possible path from the end\\n            for word in dp[end]:\\n\\n                # If we already have a word in the path, add a space in between\\n                if path:\\n                    dfs(dp, end - len(word), word + \" \" + path)\\n                else:\\n                    dfs(dp, end - len(word), word)\\n        \\n        # Used for O(1) lookup\\n        word_set = set(words)\\n        \\n        # Used for limiting the search for substrings (words) ending at each position\\n        max_len = max([len(w) for w in words + [\\'\\']])\\n        \\n        # Stores whether a combination of words from `words` can reach the position\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[0] = True\\n        \\n        # Words ending at i\\n        for i in range(1, len(s) + 1):\\n            \\n            # j defines a reachable location & start of a word ending at i\\n            for j in range(max(0, i - max_len), i):\\n            \\n                # If j is a reachable position & j to i defines a dictionary word\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i].append(s[j:i])\\n    \\n        # For each word in dp[len(s)], explore if it\\'s possible to reach the start of s.\\n        # If so, append a joining of the path to our output\\n        dfs(dp, len(s), \"\")\\n        return result\\n```\n```python\\nfrom collections import deque\\nclass Solution:\\n    def wordBreak(self, s, words):\\n        \"\"\"40ms, beating 98.4%. Uses DP to determine reachable locations\\n        in the word, then a DFS to explore paths from the start to the \\n        end of the word.\\n        \\n        Uses a deque() to append to and pop from left of list in O(1),\\n        and uses \" \".join(path) to add to result.\\n        \"\"\"\\n        result = []\\n             \\n        def dfs(dp, end, path):\\n            \"\"\"A DFS to add paths that reach from the end of the word\\n            to the start.\\n            \"\"\"\\n            # If we have reached the start of the word, add to result\\n            if 0 == end:\\n                result.append(\" \".join(path))\\n                return\\n                \\n            # Otherwise consider each possible path from the end\\n            for word in dp[end]:\\n                path.appendleft(word)\\n                dfs(dp, end-len(word), path)\\n                path.popleft()\\n\\n        # Used for O(1) lookup\\n        word_set = set(words)\\n        \\n        # Used for limiting the search for substrings (words) ending at each position\\n        max_len = max([len(w) for w in words + [\\'\\']])\\n        \\n        # Stores whether a combination of words from `words` can reach the position\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[0] = True\\n        \\n        # Words ending at i\\n        for i in range(1, len(s) + 1):\\n            \\n            # j defines a reachable location & start of a word ending at i\\n            for j in range(max(0, i - max_len), i):\\n            \\n                # If j is a reachable position & j to i defines a dictionary word\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i].append(s[j:i])\\n    \\n        # For each word in dp[len(s)], explore if it\\'s possible to reach the start of s.\\n        # If so, append a joining of the path to our output\\n        dfs(dp, len(s), deque())\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44271,
                "title": "java-recursive-dp-solution",
                "content": "    public class Solution {\\n        HashMap<String,List<String>> map = new HashMap<String,List<String>>();\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            List<String> res = new ArrayList<String>();\\n            if(s.isEmpty())\\n                return res; // return empty list upon empty string\\n            \\n            if(map.containsKey(s))\\n                return map.get(s);\\n            \\n            for(int i=0; i<s.length(); i++) {\\n                String firstWord = s.substring(0,i+1);\\n                if(wordDict.contains(firstWord)) {\\n                    List<String> rest = wordBreak(s.substring(i+1),wordDict);\\n                    if(rest.isEmpty()) {\\n                        if(i==s.length()-1)\\n                            res.add(firstWord);\\n                    } else {\\n                        for(String str : rest)\\n                            res.add(firstWord + \" \" + str);\\n                    }\\n                }\\n            }\\n            \\n            map.put(s,res);\\n            \\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        HashMap<String,List<String>> map = new HashMap<String,List<String>>();\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            List<String> res = new ArrayList<String>();\\n            if(s.isEmpty())\\n                return res; // return empty list upon empty string\\n            \\n            if(map.containsKey(s))\\n                return map.get(s);\\n            \\n            for(int i=0; i<s.length(); i++) {\\n                String firstWord = s.substring(0,i+1);\\n                if(wordDict.contains(firstWord)) {\\n                    List<String> rest = wordBreak(s.substring(i+1),wordDict);\\n                    if(rest.isEmpty()) {\\n                        if(i==s.length()-1)\\n                            res.add(firstWord);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3107049,
                "title": "c-template-for-word-break-i-ii-concatenated-words",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition for all the problems:\\nAll the three given problems  can be divided into sub-problems .And  If these subproblems individually satisfy the required conditions, then  complete problem will also satisfy the same. And hence we can say whether it is true to find the word in the dictionary or not.\\n\\n# Approach\\n- **Naive Approach**: Use recursion and backtracking. For finding the solution, we check every prefix of the string in the word_dict of words, if it is found , then the recursive function is called for the remaining portion of that string. But this will be$$ 2^n$$ so will give tle . SO we can optimize using memoization or dp.\\n- **DP**: So as we can see that in recurion we call for evrery prefix substring and check if its presnt and like this the we check the whole is present or not .So similarly we can store the same ,like upto certain index whether the substring upto that index is present or not . In this way our dp array will be filled with 0\\'s and 1\\'s representing whether the substring upto that index is present or not . And at last if last index is true i.e dp[n] is true this means whole string is presnt .\\n- So applying this logic we can do all the three problems with a little modification based on requirements.\\n<!-- Describe your approach to solving the problem. -->\\n# **For Word Break I**\\n\\n# Code\\n\\n```\\n bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **For Word Break II**\\n```\\nvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n    \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \\n                    }\\n                }\\n            }\\n        }\\n         return dp[n];\\n    }\\n```\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **For concatenated Words**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:$$O(N*W^3)$$\\n    - where `N=word.length and W = words[i].length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N*W)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\n```\\nvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n    \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \\n                    }\\n                }\\n            }\\n        }\\n         return dp[n];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44195,
                "title": "accepted-java-solution-backtracking-but-what-s-the-difference-with-front-tracking",
                "content": "This is the accepted solution, which might be the \"backtracking\" algorithm. It starts to try the word from the backend.\\n\\n\\tpublic static List<String> wordBreak(String s, Set<String> dict) {\\n\\t\\tList<String> words = new ArrayList<String>();\\n\\t\\tint len = s.length();\\n\\t\\tfor (int i = len -1; i >= 0; i--) {\\n\\t\\t\\tString last = s.substring(i, len);\\n\\t\\t\\tif (dict.contains(last)) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\twords.add(last);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tString remain = s.substring(0, i);\\n\\t\\t\\t\\t\\tList<String> remainSet = wordBreak(remain, dict);\\n\\t\\t\\t\\t\\tif (remainSet != null) {\\n\\t\\t\\t\\t\\t\\tfor (String item : remainSet) {\\n\\t\\t\\t\\t\\t\\t\\twords.add(item + \" \" + last);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn words;\\n\\t}\\n\\n\\nIt should be the same if it starts from the front, like following. (front-tracking is my invented word, maybe)\\n\\n\\tpublic static List<String> wordBreakFront(String s, Set<String> dict) {\\n\\t\\tList<String> words = new ArrayList<String>();\\n\\t\\t\\n\\t\\tint len = s.length();\\n\\t\\tfor (int i = 1; i <= len; i++) {\\n\\t\\t\\tString front = s.substring(0, i);\\n\\t\\t\\tif (dict.contains(front)) {\\n\\t\\t\\t\\tif (i == len) {\\n\\t\\t\\t\\t\\twords.add(front);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tString remain = s.substring(i, len);\\n\\t\\t\\t\\t\\tList<String> remainSet = wordBreak(remain, dict);\\n\\t\\t\\t\\t\\tif (remainSet != null) {\\n\\t\\t\\t\\t\\t\\tfor (String item : remainSet) {\\n\\t\\t\\t\\t\\t\\t\\twords.add(front + \" \" + item);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn words;\\n\\t}\\n\\nBut actually it is not!!!\\nThe later is not accepted for lower efficiency.\\n\\nBut Why?",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "This is the accepted solution, which might be the \"backtracking\" algorithm. It starts to try the word from the backend.\\n\\n\\tpublic static List<String> wordBreak(String s, Set<String> dict) {\\n\\t\\tList<String> words = new ArrayList<String>();\\n\\t\\tint len = s.length();\\n\\t\\tfor (int i = len -1; i >= 0; i--) {\\n\\t\\t\\tString last = s.substring(i, len);\\n\\t\\t\\tif (dict.contains(last)) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\twords.add(last);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tString remain = s.substring(0, i);\\n\\t\\t\\t\\t\\tList<String> remainSet = wordBreak(remain, dict);\\n\\t\\t\\t\\t\\tif (remainSet != null) {\\n\\t\\t\\t\\t\\t\\tfor (String item : remainSet) {\\n\\t\\t\\t\\t\\t\\t\\twords.add(item + \" \" + last);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn words;\\n\\t}\\n\\n\\nIt should be the same if it starts from the front, like following. (front-tracking is my invented word, maybe)\\n\\n\\tpublic static List<String> wordBreakFront(String s, Set<String> dict) {\\n\\t\\tList<String> words = new ArrayList<String>();\\n\\t\\t\\n\\t\\tint len = s.length();\\n\\t\\tfor (int i = 1; i <= len; i++) {\\n\\t\\t\\tString front = s.substring(0, i);\\n\\t\\t\\tif (dict.contains(front)) {\\n\\t\\t\\t\\tif (i == len) {\\n\\t\\t\\t\\t\\twords.add(front);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tString remain = s.substring(i, len);\\n\\t\\t\\t\\t\\tList<String> remainSet = wordBreak(remain, dict);\\n\\t\\t\\t\\t\\tif (remainSet != null) {\\n\\t\\t\\t\\t\\t\\tfor (String item : remainSet) {\\n\\t\\t\\t\\t\\t\\t\\twords.add(front + \" \" + item);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn words;\\n\\t}\\n\\nBut actually it is not!!!\\nThe later is not accepted for lower efficiency.\\n\\nBut Why?",
                "codeTag": "Unknown"
            },
            {
                "id": 1947487,
                "title": "c-dp-100-0ms",
                "content": "\\t vector<string> wordBreak(string s, vector<string>& dict) {\\n        \\n        int n = s.size();\\n        unordered_map<string,int> map;\\n        \\n        for(int i=0;i<dict.size();i++)\\n        {\\n            map[dict[i]]++;\\n        }\\n        \\n        vector<vector<string>> dp(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j>=0;j--)\\n            {\\n                string temp = s.substr(j,i-j+1);\\n                if(map.count(temp))\\n                {\\n                    if(j==0)\\n                    {\\n                        dp[i].push_back(temp);\\n                    }\\n                    else\\n                    {\\n                        for(int k=0;k<dp[j-1].size();k++)\\n                        {\\n                            dp[i].push_back(dp[j-1][k]+\" \"+temp);\\n                        }   \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n\\nevery index of the dp array will store a vector which will store all possible strings which can be formed using the word and the dictionary till ith index.\\n\\nLet we are working on a string temp, we will start checking all the possible break points and at each break point we will check whether it is a valid break point or not.\\nA breakpoint is valid if string before break point can be broken down into words present in dictionary and string after the break point is a word in the dictionary.\\n\\nAt a valid break point , at the previous index there is a vector which has all the valid strings which can be made using the word starting from 0th index to that index , so we just have to append string after the breakpoint to all those strings, and by doing so you will get all possible strings in which the word (till the ith index) can be broken.",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t vector<string> wordBreak(string s, vector<string>& dict) {\\n        \\n        int n = s.size();\\n        unordered_map<string,int> map;\\n        \\n        for(int i=0;i<dict.size();i++)\\n        {\\n            map[dict[i]]++;\\n        }\\n        \\n        vector<vector<string>> dp(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j>=0;j--)\\n            {\\n                string temp = s.substr(j,i-j+1);\\n                if(map.count(temp))\\n                {\\n                    if(j==0)\\n                    {\\n                        dp[i].push_back(temp);\\n                    }\\n                    else\\n                    {\\n                        for(int k=0;k<dp[j-1].size();k++)\\n                        {\\n                            dp[i].push_back(dp[j-1][k]+\" \"+temp);\\n                        }   \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n\\nevery index of the dp array will store a vector which will store all possible strings which can be formed using the word and the dictionary till ith index.\\n\\nLet we are working on a string temp, we will start checking all the possible break points and at each break point we will check whether it is a valid break point or not.\\nA breakpoint is valid if string before break point can be broken down into words present in dictionary and string after the break point is a word in the dictionary.\\n\\nAt a valid break point , at the previous index there is a vector which has all the valid strings which can be made using the word starting from 0th index to that index , so we just have to append string after the breakpoint to all those strings, and by doing so you will get all possible strings in which the word (till the ith index) can be broken.",
                "codeTag": "Unknown"
            },
            {
                "id": 1474977,
                "title": "c-trie-dfs",
                "content": "**Time : O(N*M + 2^X)**\\nwhere,\\nN = No. of word in Dict.\\nM = length of longest word\\nX = length of string (s);\\n\\n**Prerequisite:** You should have basic knowledge of Trie.\\nFirst solve this *leetcode-208 [https://leetcode.com/problems/implement-trie-prefix-tree/](http://)*\\nthen, *leetcode-139 [https://leetcode.com/problems/word-break/](http://)*\\nthen try this **(Word Break II)** question.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    class Trie{\\n      public:\\n        Trie* child[26];\\n        bool isEnd=false;\\n    };\\n    \\n    void insert(string& word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(cur->child[ch-\\'a\\']==NULL) cur->child[ch-\\'a\\'] = new Trie();\\n            cur = cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string& word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(cur->child[ch-\\'a\\']==NULL) return false;\\n            cur = cur->child[ch-\\'a\\'];\\n        }\\n        return cur->isEnd;\\n    }\\n    \\n    void dfs(string &s, int idx, Trie *root, string curStr){\\n        if(idx == s.size()){\\n            ans.push_back(curStr.substr(0,0+curStr.size()-1));   //before pushing in vector remove the extra-space in the last of the string \\n            return;\\n        }\\n        string str=\"\";\\n        for(int i=idx; i<s.size(); ++i){\\n            str.push_back(s[i]);\\n            if(search(str,root)) dfs(s,i+1,root, curStr+str+\" \");\\n        }\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        Trie *root = new Trie();\\n        for(auto &word : wordDict){\\n            insert(word,root);\\n        }\\n        dfs(s,0,root,\"\");\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    class Trie{\\n      public:\\n        Trie* child[26];\\n        bool isEnd=false;\\n    };\\n    \\n    void insert(string& word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(cur->child[ch-\\'a\\']==NULL) cur->child[ch-\\'a\\'] = new Trie();\\n            cur = cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string& word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(cur->child[ch-\\'a\\']==NULL) return false;\\n            cur = cur->child[ch-\\'a\\'];\\n        }\\n        return cur->isEnd;\\n    }\\n    \\n    void dfs(string &s, int idx, Trie *root, string curStr){\\n        if(idx == s.size()){\\n            ans.push_back(curStr.substr(0,0+curStr.size()-1));   //before pushing in vector remove the extra-space in the last of the string \\n            return;\\n        }\\n        string str=\"\";\\n        for(int i=idx; i<s.size(); ++i){\\n            str.push_back(s[i]);\\n            if(search(str,root)) dfs(s,i+1,root, curStr+str+\" \");\\n        }\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        Trie *root = new Trie();\\n        for(auto &word : wordDict){\\n            insert(word,root);\\n        }\\n        dfs(s,0,root,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870172,
                "title": "python-simple-dp-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        cache={}\\n        def wordbr(s):\\n            if s not in cache: \\n                result=[]\\n                for w in wordDict:\\n                    if s[:len(w)]==w:\\n                        if len(s)==len(w):\\n                            result.append(w)\\n                        else:\\n                            for word in wordbr(s[len(w):]):\\n                                result.append(w+\" \"+word)\\n                cache[s]=result\\n            return cache[s]\\n        \\n        return wordbr(s)\\n```\\nplease upvote if you like..!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        cache={}\\n        def wordbr(s):\\n            if s not in cache: \\n                result=[]\\n                for w in wordDict:\\n                    if s[:len(w)]==w:\\n                        if len(s)==len(w):\\n                            result.append(w)\\n                        else:\\n                            for word in wordbr(s[len(w):]):\\n                                result.append(w+\" \"+word)\\n                cache[s]=result\\n            return cache[s]\\n        \\n        return wordbr(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163697,
                "title": "4ms-c-solution-based-on-word-break-i",
                "content": "Word Break I solution:\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> words(wordDict.begin(), wordDict.end());\\n        int n = s.size();\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j]) {\\n                    if (words.count(s.substr(j, i - j))) {\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\nWord Break II solution based on Word Break I dynamic programming solution, search results by backtracking\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_set<string> words;\\n\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        words.clear();\\n        copy(wordDict.begin(), wordDict.end(), inserter(words, words.end()));\\n\\n        int n = s.size();\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j]) {\\n                    if (words.count(s.substr(j, i - j))) {\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n        if (dp[n]) {\\n            constructSentence(s, dp, 0, res, \"\");\\n        }\\n        return res;\\n    }\\n\\n    void constructSentence(const string& s,\\n                           const vector<int>& dp,\\n                           int pos,\\n                           vector<string>& res,\\n                           string temp) {\\n        for (int i = pos + 1; i < dp.size(); ++i) {\\n            if (dp[i]) {\\n                string new_word = s.substr(pos, i - pos);\\n                if (words.count(new_word)) {\\n                    if (i + 1 == dp.size()) {\\n                        res.push_back(temp + new_word);\\n                        return;\\n                    }\\n                    constructSentence(s, dp, i, res, temp + new_word + \" \");\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> words(wordDict.begin(), wordDict.end());\\n        int n = s.size();\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j]) {\\n                    if (words.count(s.substr(j, i - j))) {\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    unordered_set<string> words;\\n\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        words.clear();\\n        copy(wordDict.begin(), wordDict.end(), inserter(words, words.end()));\\n\\n        int n = s.size();\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j]) {\\n                    if (words.count(s.substr(j, i - j))) {\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n        if (dp[n]) {\\n            constructSentence(s, dp, 0, res, \"\");\\n        }\\n        return res;\\n    }\\n\\n    void constructSentence(const string& s,\\n                           const vector<int>& dp,\\n                           int pos,\\n                           vector<string>& res,\\n                           string temp) {\\n        for (int i = pos + 1; i < dp.size(); ++i) {\\n            if (dp[i]) {\\n                string new_word = s.substr(pos, i - pos);\\n                if (words.count(new_word)) {\\n                    if (i + 1 == dp.size()) {\\n                        res.push_back(temp + new_word);\\n                        return;\\n                    }\\n                    constructSentence(s, dp, i, res, temp + new_word + \" \");\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44232,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Word Break II** https://leetcode.com/problems/word-break-ii/\\n\\n**Memoization**\\n* We parameterize the problem with a single variable k. helper(k, s, ....) returns all the solns to the problem for input string s[k:].\\n* Given a s and k, we divide the string into left and right half by running a loop i from k to len(s). left = s[k:i+1]. If left is a valid word, we call the sub-problem helper(i+1, s...). The output of the sub-problem is combined with left to produce all results.\\n* Corner case: left = s[k:len(s)]. The remainder for this problem is empty. So we return left as an answer given left is a valid word.\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.helper(0, s, set(wordDict), {})\\n\\n    def helper(self, k, s, wordDict, cache):\\n        if k == len(s):\\n            return []\\n        elif k in cache:\\n            return cache[k]\\n        else:\\n            cache[k] = []\\n            for i in range(k, len(s)):\\n                left = s[k:i+1]\\n                if left in wordDict:\\n                    remainder = self.helper(i+1, s, wordDict, cache)\\n                    if remainder:\\n                        for x in remainder:\\n                            cache[k].append(left + \" \" + x)\\n                    elif (i == len(s)-1):\\n                        cache[k].append(left)\\n            return cache[k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.helper(0, s, set(wordDict), {})\\n\\n    def helper(self, k, s, wordDict, cache):\\n        if k == len(s):\\n            return []\\n        elif k in cache:\\n            return cache[k]\\n        else:\\n            cache[k] = []\\n            for i in range(k, len(s)):\\n                left = s[k:i+1]\\n                if left in wordDict:\\n                    remainder = self.helper(i+1, s, wordDict, cache)\\n                    if remainder:\\n                        for x in remainder:\\n                            cache[k].append(left + \" \" + x)\\n                    elif (i == len(s)-1):\\n                        cache[k].append(left)\\n            return cache[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938504,
                "title": "100-fastest-swift-solution-time-o-2-n-space-o-2-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(2 ^ n), where n is the length of the wordDict.\\n    //   - space: O(2 ^ n), where n is the length of the wordDict.\\n\\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var dict = [String: [String]]()\\n        return dfs(s, wordDict, &dict)\\n    }\\n\\n\\n    private func dfs(_ s: String, _ wordDict: [String], _ dict: inout [String: [String]]) -> [String] {\\n        if let val = dict[s] { return val }\\n        guard !s.isEmpty else { return [\"\"] }\\n        var ans = [String]()\\n\\n        for word in wordDict {\\n            guard s.hasPrefix(word) else { continue }\\n            let sublist = dfs(String(s.dropFirst(word.count)), wordDict, &dict)\\n            for sub in sublist {\\n                ans.append(\"\\\\(word)\\\\(sub.isEmpty ? \"\" : \" \")\\\\(sub)\")\\n            }\\n        }\\n\\n        dict[s] = ans\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(2 ^ n), where n is the length of the wordDict.\\n    //   - space: O(2 ^ n), where n is the length of the wordDict.\\n\\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var dict = [String: [String]]()\\n        return dfs(s, wordDict, &dict)\\n    }\\n\\n\\n    private func dfs(_ s: String, _ wordDict: [String], _ dict: inout [String: [String]]) -> [String] {\\n        if let val = dict[s] { return val }\\n        guard !s.isEmpty else { return [\"\"] }\\n        var ans = [String]()\\n\\n        for word in wordDict {\\n            guard s.hasPrefix(word) else { continue }\\n            let sublist = dfs(String(s.dropFirst(word.count)), wordDict, &dict)\\n            for sub in sublist {\\n                ans.append(\"\\\\(word)\\\\(sub.isEmpty ? \"\" : \" \")\\\\(sub)\")\\n            }\\n        }\\n\\n        dict[s] = ans\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763803,
                "title": "python-simple-dp-solution",
                "content": "The idea of the solution is to have a dictionary `dp` with keys as `start`, where `start` can be any value from 0 to `len(s) - 1`. The value of `dp` is a list of all valid sentences that make up `s[start:]`. This will take a top-down dynamic programming approach.\\n\\n**Example**\\nLet\\'s use example 1, where we are given `s = \"catsanddog\"` and `wordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]`. The following will be the `dp` dict after our program has run:\\n\\n`dp[7] = [\"dog\"]`\\n`dp[4] = [\"and dog\"]`\\n`dp[3] = [\"sand dog\"]`\\n`dp[0] = [\"cats and dog\", \"cat sand dog\"]`\\n\\n```\\nindex : 0 1 2 3 4 5 6 7 8 9\\ns     : c a t s a n d d o g\\n```\\n\\n**Code**\\nTo construct `dp`,  we will use a helper function. `start` is the beginning index of the substring. We first check that `dp[start]` has not been created, if it has been, just return it. \\n\\nThen for each word `w` in `wordDict`, we want to check if the substring starts with the word `w`. If so, then there are two cases. *Case 1* is if `w` is the end of `s`, in our example, that is \"dog\". We don\\'t want to keep searching deeper and we don\\'t want to add a space after \"dog\". *Case 2* is if we should keep searching deeper, in this case we will add future results. In our example, if `w = \"and\"`, we will add \"dog\" to create \"and dog\".\\n\\nFinally, we return `dp[start]`. Since `dp` is a defaultdict, it will return `[]` if we don\\'t append any items to it, which is the case of no valid sentences for the substring `s[start:]`.\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dp = defaultdict(list)\\n        \\n        def helper(start: int) -> List[str]:\\n            if start not in dp:\\n                for w in wordDict:\\n                    if start + len(w) <= len(s) and w == s[start:start+len(w)]:\\n                        if start + len(w) == len(s):\\n\\t\\t\\t\\t\\t\\t\\t# Case 1: No need to go deeper because we are at the end of s\\n                            dp[start].append(w)\\n                        else:\\n\\t\\t\\t\\t\\t\\t\\t# Case 2: Keep searching deeper\\n                            for suffix in helper(start + len(w)):\\n                                dp[start].append(w + \" \" + suffix)\\n            return dp[start]\\n        \\n        return helper(0)\\n```",
                "solutionTags": [],
                "code": "```\\nindex : 0 1 2 3 4 5 6 7 8 9\\ns     : c a t s a n d d o g\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dp = defaultdict(list)\\n        \\n        def helper(start: int) -> List[str]:\\n            if start not in dp:\\n                for w in wordDict:\\n                    if start + len(w) <= len(s) and w == s[start:start+len(w)]:\\n                        if start + len(w) == len(s):\\n\\t\\t\\t\\t\\t\\t\\t# Case 1: No need to go deeper because we are at the end of s\\n                            dp[start].append(w)\\n                        else:\\n\\t\\t\\t\\t\\t\\t\\t# Case 2: Keep searching deeper\\n                            for suffix in helper(start + len(w)):\\n                                dp[start].append(w + \" \" + suffix)\\n            return dp[start]\\n        \\n        return helper(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744674,
                "title": "diagrammatic-python-intuitive-solution-with-example",
                "content": "\\nLets start with a simple version of the problem.\\n\\nAssume you had a function `wordsEndingWith(i)` which gave you all possible strings which end with `s[i:]` i.e; `wordsEndingWith(0)`  would give you all words ending with \"CATSANDDOG\".\\n\\nSo, for example, you know CAT is in your dictionary, you need to know how \"SANDDOG\" could be broken, You\\'d call `wordsEndingWith(3)` which would return you `[\"SAND DOG\"]`. If your dictionary had \"SAN\" and \"DDOG\" too, this function would instead return `[\"SAND DOG\", \"SAN DDOG\"]` (_It returns all possibilities_)\\n\\nSo, all you need to do is call this function bottom up, right:\\n\\n<img src=\"https://assets.leetcode.com/users/images/20686d18-9101-4a89-8a48-adaaa12f44ef_1595190114.0389073.png\" width=400/>\\n\\n```python\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def wordsEndingIn(i):\\n            if i == len(s):\\n                return [\"\"]\\n            ans = []\\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] in wordDict:\\n                    for tail in wordsEndingIn(j):\\n                        if tail != \\'\\':\\n                            ans.append(s[i:j] + \" \" + tail) \\n                        else:\\n                            ans.append(s[i:j])\\n            return ans\\n        return wordsEndingIn(0)\\n```\\n\\n\\n<img src=\"https://assets.leetcode.com/users/images/50decb13-7f51-4cc7-9c93-50d41cc6bfcd_1595190815.615007.png\" width=400/>\\n\\n```\\n0 , catsanddog, []\\n\\t s[0:3] or cat is in wordDict, calling sentences(3)\\n3 , sanddog, []\\n\\t s[3:7] or sand is in wordDict, calling sentences(7)\\n7 , dog, []\\n\\t s[7:10] or dog is in wordDict, calling sentences(10)\\n10 , , []\\n----\\n\\t s[0:4] or cats is in wordDict, calling sentences(4)\\n4 , anddog, [[u\\'dog\\'], [u\\'sand dog\\']]\\n\\t s[4:7] or and is in wordDict, calling sentences(7)\\n7 , dog, [[u\\'dog\\'], [u\\'sand dog\\']]\\n\\t s[7:10] or dog is in wordDict, calling sentences(10)\\n10 , , [[u\\'dog\\'], [u\\'sand dog\\']]\\n----\\n\\n\\n\\n\\nAnother example:\\n\\n0 , pineapplepenapple, []\\n\\t s[0:4] or pine is in wordDict, calling sentences(4)\\n4 , applepenapple, []\\n\\t s[4:9] or apple is in wordDict, calling sentences(9)\\n9 , penapple, []\\n\\t s[9:12] or pen is in wordDict, calling sentences(12)\\n12 , apple, []\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , []\\n----\\n\\t s[4:12] or applepen is in wordDict, calling sentences(12)\\n12 , apple, [[u\\'apple\\'], [u\\'pen apple\\']]\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , [[u\\'apple\\'], [u\\'pen apple\\']]\\n----\\n\\t s[0:9] or pineapple is in wordDict, calling sentences(9)\\n9 , penapple, [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n\\t s[9:12] or pen is in wordDict, calling sentences(12)\\n12 , apple, [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n----\\n```\\n\\nAs you can see, the parts in blue are actually done repeatedly:\\n\\n<img src=\"https://assets.leetcode.com/users/images/e7a4c4de-52d4-4d30-aaf5-81f8693f9af2_1595190922.2887342.png\" width=400/>\\n\\nThey\\'ve already been computed. \\n\\nThus, we can save such expensive computations and reduce calls to this recursive function by maintaining a hashmap with results of previous calls.\\n\\n```python\\n\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        memo = {}\\n        def wordsEndingIn(i):\\n            if i == len(s):\\n                return [\"\"]\\n            if i in memo:\\n                return memo[i]\\n            ans = []\\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] in wordDict:\\n                    for tail in wordsEndingIn(j):\\n                        if tail != \\'\\':\\n                            ans.append(s[i:j] + \" \" + tail) \\n                        else:\\n                            ans.append(s[i:j])\\n            memo[i] = ans\\n            return ans\\n        return wordsEndingIn(0)\\n        \\n\\t\\t```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def wordsEndingIn(i):\\n            if i == len(s):\\n                return [\"\"]\\n            ans = []\\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] in wordDict:\\n                    for tail in wordsEndingIn(j):\\n                        if tail != \\'\\':\\n                            ans.append(s[i:j] + \" \" + tail) \\n                        else:\\n                            ans.append(s[i:j])\\n            return ans\\n        return wordsEndingIn(0)\\n```\n```\\n0 , catsanddog, []\\n\\t s[0:3] or cat is in wordDict, calling sentences(3)\\n3 , sanddog, []\\n\\t s[3:7] or sand is in wordDict, calling sentences(7)\\n7 , dog, []\\n\\t s[7:10] or dog is in wordDict, calling sentences(10)\\n10 , , []\\n----\\n\\t s[0:4] or cats is in wordDict, calling sentences(4)\\n4 , anddog, [[u\\'dog\\'], [u\\'sand dog\\']]\\n\\t s[4:7] or and is in wordDict, calling sentences(7)\\n7 , dog, [[u\\'dog\\'], [u\\'sand dog\\']]\\n\\t s[7:10] or dog is in wordDict, calling sentences(10)\\n10 , , [[u\\'dog\\'], [u\\'sand dog\\']]\\n----\\n\\n\\n\\n\\nAnother example:\\n\\n0 , pineapplepenapple, []\\n\\t s[0:4] or pine is in wordDict, calling sentences(4)\\n4 , applepenapple, []\\n\\t s[4:9] or apple is in wordDict, calling sentences(9)\\n9 , penapple, []\\n\\t s[9:12] or pen is in wordDict, calling sentences(12)\\n12 , apple, []\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , []\\n----\\n\\t s[4:12] or applepen is in wordDict, calling sentences(12)\\n12 , apple, [[u\\'apple\\'], [u\\'pen apple\\']]\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , [[u\\'apple\\'], [u\\'pen apple\\']]\\n----\\n\\t s[0:9] or pineapple is in wordDict, calling sentences(9)\\n9 , penapple, [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n\\t s[9:12] or pen is in wordDict, calling sentences(12)\\n12 , apple, [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n----\\n```\n```python\\n\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        memo = {}\\n        def wordsEndingIn(i):\\n            if i == len(s):\\n                return [\"\"]\\n            if i in memo:\\n                return memo[i]\\n            ans = []\\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] in wordDict:\\n                    for tail in wordsEndingIn(j):\\n                        if tail != \\'\\':\\n                            ans.append(s[i:j] + \" \" + tail) \\n                        else:\\n                            ans.append(s[i:j])\\n            memo[i] = ans\\n            return ans\\n        return wordsEndingIn(0)\\n        \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 44369,
                "title": "my-simple-c-dp-15ms-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> wordBreak(string s, unordered_set<string> &dict) {\\n            vector<string> res;\\n            if (dict.size() == 0) return res;\\n            \\n            vector<vector<int> > spaceIdx;\\n            spaceIdx.resize(s.size() + 1);\\n            spaceIdx[0].push_back(-1);\\n            \\n            for (int i = 1; i <= s.size(); i++) {\\n                for (int j = 0; j < i; j++) {\\n                    if (spaceIdx[j].size() && dict.count(s.substr(j, i - j))) {\\n                            spaceIdx[i].push_back(j);\\n                    }\\n                }\\n            }\\n            \\n            return backTrack(s, spaceIdx, s.size());\\n        }\\n        \\n        vector<string> backTrack(string& s, vector<vector<int> >& spaceIdx, int idx) {\\n            vector<string> res;\\n            if (idx <= 0) {res.push_back(\"\"); return res;}\\n            \\n            for (int i = 0; i < spaceIdx[idx].size(); i++) {\\n                string str = s.substr(spaceIdx[idx][i], idx - spaceIdx[idx][i]);\\n                vector<string> subRes = backTrack(s, spaceIdx, spaceIdx[idx][i]);\\n                for (int j = 0; j < subRes.size(); j++) {\\n                    if (subRes[j] != \"\") subRes[j] = subRes[j] + \" \" + str;\\n                    else subRes[j] = str;\\n                    res.push_back(subRes[j]);\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    };\\n\\nThe idea is that for each index i of string s, for each j < i check if 1) s.substr(0, j) has valid solution and 2) s.substr(j, i - j + 1) is a valid word. If so then mark j as a sub-solution of i. At the end we trace back from the last index and construct valid word breaks using DFS.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> wordBreak(string s, unordered_set<string> &dict) {\\n            vector<string> res;\\n            if (dict.size() == 0) return res;\\n            \\n            vector<vector<int> > spaceIdx;\\n            spaceIdx.resize(s.size() + 1);\\n            spaceIdx[0].push_back(-1);\\n            \\n            for (int i = 1; i <= s.size(); i++) {\\n                for (int j = 0; j < i; j++) {\\n                    if (spaceIdx[j].size() && dict.count(s.substr(j, i - j))) {\\n                            spaceIdx[i].push_back(j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 764151,
                "title": "javascript-75-80ms-heavily-commented-dp",
                "content": "```javascript\\nvar wordBreak = function(s, wordDict) {\\n    const memo = new Map();\\n    \\n    function run(str) {\\n        if(memo.has(str)) return memo.get(str);\\n        if(!str.length) return [];\\n        \\n        const result = [];\\n        \\n        for(let word of wordDict) {\\n            \\n            // find words in the dict that match the start of str\\n            if(str.startsWith(word)) {\\n                // remove the current word from the start of the str\\n                const next = str.slice(word.length);\\n                const paths = run(next); \\n                \\n                // if \\'paths\\' is empty arr, and \\'next\\' is empty str\\n                // current word will be the last one in the sequence\\n                if(!paths.length && !next.length) result.push(word);\\n                \\n                // else map the current word to the start of every path\\n                // and push each path to result\\n                result.push(...paths.map(rest => word + \\' \\' + rest));\\n            }\\n        }\\n        // cache result\\n        memo.set(str, result);\\n        return result;\\n    }\\n    return run(s);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```javascript\\nvar wordBreak = function(s, wordDict) {\\n    const memo = new Map();\\n    \\n    function run(str) {\\n        if(memo.has(str)) return memo.get(str);\\n        if(!str.length) return [];\\n        \\n        const result = [];\\n        \\n        for(let word of wordDict) {\\n            \\n            // find words in the dict that match the start of str\\n            if(str.startsWith(word)) {\\n                // remove the current word from the start of the str\\n                const next = str.slice(word.length);\\n                const paths = run(next); \\n                \\n                // if \\'paths\\' is empty arr, and \\'next\\' is empty str\\n                // current word will be the last one in the sequence\\n                if(!paths.length && !next.length) result.push(word);\\n                \\n                // else map the current word to the start of every path\\n                // and push each path to result\\n                result.push(...paths.map(rest => word + \\' \\' + rest));\\n            }\\n        }\\n        // cache result\\n        memo.set(str, result);\\n        return result;\\n    }\\n    return run(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 587053,
                "title": "problem-is-not-correctly-defined",
                "content": "After solving Word Break problem I was quick to come up with dynamic approach for Word Break II, which is identical to official **Approach 3**. \\nAnd for many of you this approach failed with TLE or Out of memory just like it failed for me for the following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nWhat did I do? Looked up the best rated problem with neat DFS approach\\nhttps://leetcode.com/problems/word-break-ii/discuss/44167/My-concise-JAVA-solution-based-on-memorized-DFS\\n\\nThe only reason it succeeds because the way DFS works ... goes deep, go-go-go ... encounter a problem, return empty list early compared with dynamic approach. Basically it \\'short-circuits\\' in this case.\\n\\nBUT if input with s.length() == 151 is a valid input string, then I can construct test case by replacing \\'b\\' with \\'a\\'. Then neither DFS nor dynamic approach would succeed in time/memory limit. Given that test case can have input s with 151 characters and there is no limit on wordDict size this is perfectly valid test case ... or many other similar test cases one can construt to \\'fail\\' both DFS and DP solutions.\\n\\nProblem needs to specify proper restrictions/limit on input size, e.g.\\na <= s.length() <= b\\nc <= wordDict.size() <= d\\nonlyl lower-case or any characters etc.",
                "solutionTags": [],
                "code": "After solving Word Break problem I was quick to come up with dynamic approach for Word Break II, which is identical to official **Approach 3**. \\nAnd for many of you this approach failed with TLE or Out of memory just like it failed for me for the following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nWhat did I do? Looked up the best rated problem with neat DFS approach\\nhttps://leetcode.com/problems/word-break-ii/discuss/44167/My-concise-JAVA-solution-based-on-memorized-DFS\\n\\nThe only reason it succeeds because the way DFS works ... goes deep, go-go-go ... encounter a problem, return empty list early compared with dynamic approach. Basically it \\'short-circuits\\' in this case.\\n\\nBUT if input with s.length() == 151 is a valid input string, then I can construct test case by replacing \\'b\\' with \\'a\\'. Then neither DFS nor dynamic approach would succeed in time/memory limit. Given that test case can have input s with 151 characters and there is no limit on wordDict size this is perfectly valid test case ... or many other similar test cases one can construt to \\'fail\\' both DFS and DP solutions.\\n\\nProblem needs to specify proper restrictions/limit on input size, e.g.\\na <= s.length() <= b\\nc <= wordDict.size() <= d\\nonlyl lower-case or any characters etc.",
                "codeTag": "Unknown"
            },
            {
                "id": 296870,
                "title": "simple-javascript-solution",
                "content": "```\\nvar wordBreak = function(s, wordDict, cache = new Map()) {\\n    if(cache.has(s))\\n        return cache.get(s);\\n    \\n    if(s.length === 0){\\n        cache.set(s, []);\\n        return [];\\n    }\\n    \\n    const result = [];\\n    for(let word of wordDict){\\n        const index = s.indexOf(word);\\n        if(index === 0){\\n            const newStr = s.slice(word.length);\\n            const values = wordBreak(newStr, wordDict, cache);\\n            if(values.length === 0 && newStr.length === 0)\\n                result.push(word);\\n            else{\\n                values.forEach(val => {\\n                    result.push(word + \\' \\' + val);\\n                });\\n            }\\n        }\\n    }\\n    \\n    cache.set(s, result);\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar wordBreak = function(s, wordDict, cache = new Map()) {\\n    if(cache.has(s))\\n        return cache.get(s);\\n    \\n    if(s.length === 0){\\n        cache.set(s, []);\\n        return [];\\n    }\\n    \\n    const result = [];\\n    for(let word of wordDict){\\n        const index = s.indexOf(word);\\n        if(index === 0){\\n            const newStr = s.slice(word.length);\\n            const values = wordBreak(newStr, wordDict, cache);\\n            if(values.length === 0 && newStr.length === 0)\\n                result.push(word);\\n            else{\\n                values.forEach(val => {\\n                    result.push(word + \\' \\' + val);\\n                });\\n            }\\n        }\\n    }\\n    \\n    cache.set(s, result);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 175737,
                "title": "python-solution-continuation-to-word-break",
                "content": "After the DP solution of Word Break, simply use Backtrack to get the valid words that can form a sentence.\\n\\n```\\n  def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        dp = [False]*(len(s)+1)\\n        dp[0] = True\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if dp[j] == True and s[j:i] in wordDict:\\n                    dp[i] = True\\n        \\n        if dp[-1] == False:\\n            return []\\n        \\n        pos = []\\n        \\n        for i in range(len(dp)):\\n            if dp[i] == True:\\n                pos.append(i-1)\\n        pos.pop(0)\\n        res = []\\n        self.build(pos, s, \"\", res, wordDict, 0)\\n        return res\\n    \\n    def build(self, pos, s, choice, res, wordDict, start):\\n        if start > pos[-1]:\\n            res.append(choice[:-1])\\n            return \\n        \\n        for i in range(len(pos)):\\n            if s[start: pos[i]+1] in wordDict:\\n                self.build(pos, s, choice+s[start:pos[i]+1]+\" \", res, wordDict, pos[i]+1)\\n```",
                "solutionTags": [],
                "code": "```\\n  def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        dp = [False]*(len(s)+1)\\n        dp[0] = True\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if dp[j] == True and s[j:i] in wordDict:\\n                    dp[i] = True\\n        \\n        if dp[-1] == False:\\n            return []\\n        \\n        pos = []\\n        \\n        for i in range(len(dp)):\\n            if dp[i] == True:\\n                pos.append(i-1)\\n        pos.pop(0)\\n        res = []\\n        self.build(pos, s, \"\", res, wordDict, 0)\\n        return res\\n    \\n    def build(self, pos, s, choice, res, wordDict, start):\\n        if start > pos[-1]:\\n            res.append(choice[:-1])\\n            return \\n        \\n        for i in range(len(pos)):\\n            if s[start: pos[i]+1] in wordDict:\\n                self.build(pos, s, choice+s[start:pos[i]+1]+\" \", res, wordDict, pos[i]+1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 44191,
                "title": "java-dp-solution",
                "content": "    public class Solution {\\n        \\n      public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> res = new ArrayList<String>();\\n        // Do a fast check and see if we can break the input string\\n        if (!canBreak(s, dict))\\n          return res;\\n        \\n        helper(s, dict, 0, \"\", res);\\n        return res;\\n      }\\n      \\n      void helper(String s, Set<String> dict, int start, String sol, List<String> res) {\\n        if (start == s.length()) {\\n          res.add(sol);\\n          return;\\n        }\\n        \\n        for (int i = start; i < s.length(); i++) {\\n          String sub = s.substring(start, i + 1);\\n          \\n          if (dict.contains(sub))\\n            helper(s, dict, i + 1, sol + (sol.length() == 0 ? \"\" : \" \") + sub, res);\\n        }\\n      }\\n      \\n      // Solution from \"Word Break\"\\n      boolean canBreak(String s, Set<String> dict) {\\n          if (s == null || s.length() == 0) return false;\\n          \\n          int n = s.length();\\n          \\n          // dp[i] represents whether s[0...i] can be formed by dict\\n          boolean[] dp = new boolean[n];\\n          \\n          for (int i = 0; i < n; i++) {\\n              for (int j = 0; j <= i; j++) {\\n                  String sub = s.substring(j, i + 1);\\n                  \\n                  if (dict.contains(sub) && (j == 0 || dp[j - 1])) {\\n                      dp[i] = true;\\n                      break;\\n                  }\\n              }\\n          }\\n          \\n          return dp[n - 1];\\n      }\\n    \\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        \\n      public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> res = new ArrayList<String>();\\n        // Do a fast check and see if we can break the input string\\n        if (!canBreak(s, dict))\\n          return res;\\n        \\n        helper(s, dict, 0, \"\", res);\\n        return res;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2191120,
                "title": "trie-dp-100-faster-c",
                "content": "\\tstruct Node{\\n\\t\\tbool end=false;\\n\\t\\tNode* charset[26];\\n\\n\\t\\tbool containsChar(char ch){\\n\\t\\t\\treturn charset[ch-\\'a\\']!= NULL;\\n\\t\\t}\\n\\n\\t\\tNode* getNode(char ch){\\n\\t\\t\\treturn charset[ch-\\'a\\'];\\n\\t\\t}\\n\\n\\t\\tvoid putChar(char ch, Node* node){\\n\\t\\t\\tcharset[ch-\\'a\\']= node;\\n\\t\\t}\\n\\n\\t};\\n\\n\\n\\tclass Trie{\\n\\t\\tpublic:\\n\\t\\t\\tNode* root;\\n\\t\\tpublic: \\n\\t\\t\\tTrie(){\\n\\t\\t\\t\\troot = new Node();\\n\\t\\t\\t}\\n\\t\\tpublic:\\n\\t\\t\\tvoid insertNode(string s){\\n\\t\\t\\t\\tNode* node = root;\\n\\t\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\t\\tif(!node->containsChar(s[i])){\\n\\t\\t\\t\\t\\t\\t\\tnode->putChar(s[i], new Node());\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnode = node->getNode(s[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnode->end = true;\\n\\t\\t\\t}\\n\\t};\\n\\n\\n\\n\\tclass Solution {\\n\\n\\t\\t// sentences function returns the possible sentences as vector of its words,\\n\\t\\t// using words from wordDict and considering the substring\\n\\t\\t// of s  from position pos to end of s .\\n\\n\\n\\tpublic:\\n\\t\\tvector<vector<string>> sentences(string &s,int pos,Node* root,unordered_map<int,vector<vector<string>>> &mem){\\n\\t\\t\\tif(pos>=s.size())\\n\\t\\t\\t\\treturn {{\"\"}};\\n\\n\\t\\t\\tif(mem.find(pos) != mem.end())\\n\\t\\t\\t\\treturn mem[pos];\\n\\n\\t\\t\\tvector<vector<string>> ans,subans;\\n\\t\\t\\tstring temp=\"\";\\n\\n\\t\\t\\t// from pos we iterate and try to find a word in wordDict if exists then move to next substring \\n\\t\\t\\t// and get the possible sentences from it, then append the word found in current call to it.\\n\\t\\t\\t// say we found that cat is a word from wordDict, \\n\\t\\t\\t// again if we find cats is also a word from wordDict, checking it will take O(1) if we use trie\\n\\t\\t\\t// we don\\'t have to check for cats once we found cat , we only check for s after cat\\n\\t\\t\\tNode* node = root;\\n\\t\\t\\tfor(int i=pos; i<s.size(); i++){\\n\\t\\t\\t\\ttemp += s[i];\\n\\t\\t\\t\\tnode= node->getNode(s[i]);\\n\\t\\t\\t\\t// if cats doesn\\'t exist catsa won\\'t exist. \\n\\t\\t\\t\\tif(!node)\\n\\t\\t\\t\\t\\treturn ans;\\n\\n\\t\\t\\t\\tif(node->end){\\n\\n\\t\\t\\t\\t\\tsubans = sentences(s,i+1, root,mem);\\n\\n\\t\\t\\t\\t\\tif(subans.size()>0){\\n\\t\\t\\t\\t\\t\\tfor(int i=0; i<subans.size(); i++){\\n\\t\\t\\t\\t\\t\\t\\tif(subans[i][0].size()==0)\\n\\t\\t\\t\\t\\t\\t\\t\\tsubans[i][0]= temp;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tsubans[i].push_back(temp);\\n\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(subans[i]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tmem[pos]= ans;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvector<string> wordBreak(string s, vector<string>& wordDict) {\\n\\t\\t\\tTrie trie;\\n\\t\\t\\tfor(string s: wordDict){\\n\\t\\t\\t\\ttrie.insertNode(s);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<vector<string>> ans;\\n\\t\\t\\tunordered_map<int,vector<vector<string>>> mem;\\n\\t\\t\\tans= sentences(s,0,trie.root,mem);\\n\\n\\t\\t\\tvector<string> sentences;\\n\\n\\t\\t\\t// make the possible sentences from words of each possible string\\n\\t\\t\\tfor(vector<string> v: ans){\\n\\t\\t\\t\\tstring temp= v.back();\\n\\t\\t\\t\\tfor(int i=v.size()-2; i>=0; i--){\\n\\t\\t\\t\\t\\ttemp += \" \"+v[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsentences.push_back(temp);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn sentences;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "class Solution {\\n\\n\\t\\t// sentences function returns the possible sentences as vector of its words,\\n\\t\\t// using words from wordDict and considering the substring\\n\\t\\t// of s  from position pos to end of s .\\n\\n\\n\\tpublic:\\n\\t\\tvector<vector<string>> sentences(string &s,int pos,Node* root,unordered_map<int,vector<vector<string>>> &mem){\\n\\t\\t\\tif(pos>=s.size())\\n\\t\\t\\t\\treturn {{\"\"}",
                "codeTag": "Java"
            },
            {
                "id": 44287,
                "title": "java-beating-95-13-with-explanation-dfs-memoization-to-avoid-tle",
                "content": "Basically the idea is to use a boolean array to avoid repeated computation.\\nboolean[] invalid = new boolean[s.length()+1]\\ninvalid[i] means whether s.substring(i) is \"not breakable\"\\nThe helper function will return a boolean value whether the substring is \"breakable\" or not.\\nFor each call to helper function, denote current substring as [left, s.length()). Iterate right pointer i from left+1 to s.length(). If [left, i) can be found in the dict, and [i, s.length()) is \"breakable\", then the whole [left, s.length()) is \"breakable\".\\n\\n     /**\\n     * Leetcode 140. Word Break II.\\n     * https://leetcode.com/problems/word-break-ii/\\n     * Keyword: DFS, backtracking\\n     *\\n     * @param s        string to break\\n     * @param wordDict word dictionary\\n     * @return all the possible ways to break the string into words in the dictionary\\n     */\\n    public List<String> wordBreak2(String s, Set<String> wordDict) {\\n        List<String> res = new ArrayList<>();\\n        wordBreak2(s, 0, wordDict, \"\", new boolean[s.length() + 1], res);\\n        return res;\\n    }\\n\\n    /**\\n     * Helper function for Leetcode 140. Word Break II.\\n     *\\n     * @param s        string to break\\n     * @param left     start point\\n     * @param wordDict dictionary\\n     * @param prev     previous word found\\n     * @param invalid  invalid[i] means whether [i, s.length()) is unbreakable\\n     * @param res      list to store results\\n     * @return true if s.substring(left) is breakable.\\n     */\\n    private boolean wordBreak2(String s, int left, Set<String> wordDict, String prev, boolean[] invalid, List<String> res) {\\n        // Base case: successfully moved to the end, add result to the list.\\n        if (left == s.length()) {\\n            res.add(prev.trim());\\n            return true;\\n        }\\n        // whether s.substring(left) is breakable\\n        boolean possible = false;\\n        // iterate the pointer from left+1 to the end, find whether [left, i) is valid\\n        for (int i = left + 1; i <= s.length(); i++) {\\n            // if s.substring(i) is unbreakable, continue\\n            if (invalid[i]) {\\n                continue;\\n            }\\n            String sub = s.substring(left, i);\\n            // if substring [left,i) is valid, move on and break from i\\n            if (wordDict.contains(sub)) {\\n                boolean flag = wordBreak2(s, i, wordDict, prev.concat(\" \").concat(sub), invalid, res);\\n                // as long as at least one valid substring [i, end), possible is true\\n                possible = flag || possible;\\n            }\\n        }\\n        // update invalid array\\n        invalid[left] = !possible;\\n        return possible;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Basically the idea is to use a boolean array to avoid repeated computation.\\nboolean[] invalid = new boolean[s.length()+1]\\ninvalid[i] means whether s.substring(i) is \"not breakable\"\\nThe helper function will return a boolean value whether the substring is \"breakable\" or not.\\nFor each call to helper function, denote current substring as [left, s.length()). Iterate right pointer i from left+1 to s.length(). If [left, i) can be found in the dict, and [i, s.length()) is \"breakable\", then the whole [left, s.length()) is \"breakable\".\\n\\n     /**\\n     * Leetcode 140. Word Break II.\\n     * https://leetcode.com/problems/word-break-ii/\\n     * Keyword: DFS, backtracking\\n     *\\n     * @param s        string to break\\n     * @param wordDict word dictionary\\n     * @return all the possible ways to break the string into words in the dictionary\\n     */\\n    public List<String> wordBreak2(String s, Set<String> wordDict) {\\n        List<String> res = new ArrayList<>();\\n        wordBreak2(s, 0, wordDict, \"\", new boolean[s.length() + 1], res);\\n        return res;\\n    }\\n\\n    /**\\n     * Helper function for Leetcode 140. Word Break II.\\n     *\\n     * @param s        string to break\\n     * @param left     start point\\n     * @param wordDict dictionary\\n     * @param prev     previous word found\\n     * @param invalid  invalid[i] means whether [i, s.length()) is unbreakable\\n     * @param res      list to store results\\n     * @return true if s.substring(left) is breakable.\\n     */\\n    private boolean wordBreak2(String s, int left, Set<String> wordDict, String prev, boolean[] invalid, List<String> res) {\\n        // Base case: successfully moved to the end, add result to the list.\\n        if (left == s.length()) {\\n            res.add(prev.trim());\\n            return true;\\n        }\\n        // whether s.substring(left) is breakable\\n        boolean possible = false;\\n        // iterate the pointer from left+1 to the end, find whether [left, i) is valid\\n        for (int i = left + 1; i <= s.length(); i++) {\\n            // if s.substring(i) is unbreakable, continue\\n            if (invalid[i]) {\\n                continue;\\n            }\\n            String sub = s.substring(left, i);\\n            // if substring [left,i) is valid, move on and break from i\\n            if (wordDict.contains(sub)) {\\n                boolean flag = wordBreak2(s, i, wordDict, prev.concat(\" \").concat(sub), invalid, res);\\n                // as long as at least one valid substring [i, end), possible is true\\n                possible = flag || possible;\\n            }\\n        }\\n        // update invalid array\\n        invalid[left] = !possible;\\n        return possible;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44291,
                "title": "concise-java-solution-recursion-memoization",
                "content": "    public class Solution {\\n    Map<String, List<String>> mem = new HashMap<>();\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        if (mem.get(s) != null) return mem.get(s);\\n        List<String> result = new ArrayList<>();\\n        if (wordDict.contains(s)) result.add(s);\\n        for (int i = 1; i < s.length(); i++) {\\n            String word = s.substring(0, i);\\n            if (wordDict.contains(word)) {\\n                List<String> tmp = wordBreak(s.substring(i), wordDict);\\n                for (String str : tmp) {\\n                    result.add(word + \" \" + str);\\n                }\\n            }\\n        }\\n        mem.put(s, result);\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "class Solution {\\n    Map<String, List<String>> mem = new HashMap<>();\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        if (mem.get(s) != null) return mem.get(s);\\n        List<String> result = new ArrayList<>();\\n        if (wordDict.contains(s)) result.add(s);\\n        for (int i = 1; i < s.length(); i++) {\\n            String word = s.substring(0, i);\\n            if (wordDict.contains(word)) {\\n                List<String> tmp = wordBreak(s.substring(i), wordDict);\\n                for (String str : tmp) {\\n                    result.add(word + \" \" + str);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 44446,
                "title": "this-is-my-accepted-java-version-program-is-there-any-better-solution",
                "content": "This is my solution. I use DP- with a hashmap recording all the strings that are computed before. \\nMy idea is simple, just partition the string from the first character until the last character. Each time the string is divided into two parts: left and right. Only if the left string exists in the dict, we will try to get all of the combinations of the right string. And then form the list of combinations of the left and right.\\n\\nThe time complexity is O(n^2). Is there any better run time solution?\\n\\n    public class Solution {\\n    HashMap<String, List<String>> map= new HashMap<String, List<String>>();\\n    public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> list=new ArrayList<String>();\\n                \\n        if(map.containsKey(s)) return map.get(s);\\n        \\n        for(int i=1; i<=s.length();i++){\\n            String left=s.substring(0,i);\\n            String right=s.substring(i);\\n            if(dict.contains(left)){\\n                List<String> a=wordBreak(right, dict);\\n                for(String b:a){\\n                    list.add(left+\" \"+b);\\n                }\\n                if(right.length()==0) list.add(left);\\n            }\\n            \\n        }\\n   \\n        map.put(s, list);\\n        return list;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    HashMap<String, List<String>> map= new HashMap<String, List<String>>();\\n    public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> list=new ArrayList<String>();\\n                \\n        if(map.containsKey(s)) return map.get(s);\\n        \\n        for(int i=1; i<=s.length();i++){\\n            String left=s.substring(0,i);\\n            String right=s.substring(i);\\n            if(dict.contains(left)){\\n                List<String> a=wordBreak(right, dict);\\n                for(String b:a){\\n                    list.add(left+\" \"+b);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3106566,
                "title": "beats-100-c-dp-very-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust like word break I here we just have to check prefix substrings are prsnt or not if yes keep adding them uo and graudaully it keeps growing downwards and atlast dp[n] will store the all the strings mad efrom dictionary. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**DP**\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n        \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(dp[i].size() > 0 && word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n         return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n        \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(dp[i].size() > 0 && word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n         return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246823,
                "title": "c-0ms-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>> memo; //using for memoization (though only recurssive solution can get accepted but for the sake of learning dp)\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        if(memo.find(s) != memo.end()) return memo[s]; //if the target string found in memo, return the vector;\\n        \\n        vector<string> ans; \\n        \\n        //Base case: s = empty string\\n        if(s == \"\"){\\n            ans.push_back(\"\");\\n            return ans;\\n        }\\n        \\n        //else check for every possiblility in wordDict\\n        //which is found in our target string s\\n        \\n        for(const auto word: wordDict){\\n            \\n            //the word which is found at start will only lead to valid possiblities further\\n            if(s.find(word) == 0){\\n                \\n                string remain = s.substr(word.length()); //get the remaining substring \\n                \\n                vector<string> remainAns;\\n                \\n                remainAns = wordBreak(remain , wordDict); //vector<string1,string2, ...>\\n\\n                for(int i=0; i<remainAns.size(); i++){\\n                    \\n                    //add the word to the output string\\n                    if(remainAns[i] == \"\"){     \\n                        remainAns[i] = word;    // e.g 1) remainAns[i] = \"dog\"\\n                    }\\n                    else{\\n                        remainAns[i] = word + \" \" + remainAns[i];  //e.g 2) remainAns[i] = \"and dog\"\\n                    }\\n                    ans.push_back(remainAns[i]);\\n                }\\n            }\\n        }\\n        memo[s] = ans; //storing it in memo for future help\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>> memo; //using for memoization (though only recurssive solution can get accepted but for the sake of learning dp)\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        if(memo.find(s) != memo.end()) return memo[s]; //if the target string found in memo, return the vector;\\n        \\n        vector<string> ans; \\n        \\n        //Base case: s = empty string\\n        if(s == \"\"){\\n            ans.push_back(\"\");\\n            return ans;\\n        }\\n        \\n        //else check for every possiblility in wordDict\\n        //which is found in our target string s\\n        \\n        for(const auto word: wordDict){\\n            \\n            //the word which is found at start will only lead to valid possiblities further\\n            if(s.find(word) == 0){\\n                \\n                string remain = s.substr(word.length()); //get the remaining substring \\n                \\n                vector<string> remainAns;\\n                \\n                remainAns = wordBreak(remain , wordDict); //vector<string1,string2, ...>\\n\\n                for(int i=0; i<remainAns.size(); i++){\\n                    \\n                    //add the word to the output string\\n                    if(remainAns[i] == \"\"){     \\n                        remainAns[i] = word;    // e.g 1) remainAns[i] = \"dog\"\\n                    }\\n                    else{\\n                        remainAns[i] = word + \" \" + remainAns[i];  //e.g 2) remainAns[i] = \"and dog\"\\n                    }\\n                    ans.push_back(remainAns[i]);\\n                }\\n            }\\n        }\\n        memo[s] = ans; //storing it in memo for future help\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526377,
                "title": "accepted-c-backtracking-solution-memoization",
                "content": "```\\n    public class Solution\\n    {\\n        private IList<string> Helper(ref string s, int idx, IList<string>[] cache, ISet<string> set)\\n        {\\n            if (cache[idx] != null)\\n            {\\n                return cache[idx];\\n            }\\n\\n            IList<string> res = new List<string>();\\n\\n            for (int l = 1; l <= s.Length - idx; l++)\\n            {\\n                var word = s.Substring(idx, l);\\n                if (set.Contains(word))\\n                {\\n                    var next = idx + l;\\n                    if (next == s.Length)\\n                    {\\n                        res.Add(word);\\n                    }\\n                    else\\n                    {\\n                        var inner = Helper(ref s, next, cache, set);\\n                        foreach (var subsentence in inner)\\n                        {\\n                            res.Add($\"{word} {subsentence}\");\\n                        }\\n                    }\\n                }\\n            }\\n\\n            cache[idx] = res;\\n            return res;\\n        }\\n\\n        public IList<string> WordBreak(string s, IList<string> wordDict)\\n        {\\n            IList<string>[] cache = new IList<string>[s.Length];\\n            ISet<string> set = wordDict.ToHashSet();\\n            var res = Helper(ref s, 0, cache, set);\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private IList<string> Helper(ref string s, int idx, IList<string>[] cache, ISet<string> set)\\n        {\\n            if (cache[idx] != null)\\n            {\\n                return cache[idx];\\n            }\\n\\n            IList<string> res = new List<string>();\\n\\n            for (int l = 1; l <= s.Length - idx; l++)\\n            {\\n                var word = s.Substring(idx, l);\\n                if (set.Contains(word))\\n                {\\n                    var next = idx + l;\\n                    if (next == s.Length)\\n                    {\\n                        res.Add(word);\\n                    }\\n                    else\\n                    {\\n                        var inner = Helper(ref s, next, cache, set);\\n                        foreach (var subsentence in inner)\\n                        {\\n                            res.Add($\"{word} {subsentence}\");\\n                        }\\n                    }\\n                }\\n            }\\n\\n            cache[idx] = res;\\n            return res;\\n        }\\n\\n        public IList<string> WordBreak(string s, IList<string> wordDict)\\n        {\\n            IList<string>[] cache = new IList<string>[s.Length];\\n            ISet<string> set = wordDict.ToHashSet();\\n            var res = Helper(ref s, 0, cache, set);\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482162,
                "title": "java-bruteforce-memorized-dfs-approach-clean-code-9ms",
                "content": "**Apprach 1: Bruteforce - TLE**\\n```java\\nclass Solution {\\n    List<String> result = new LinkedList<>();\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        result.clear();\\n        backtracking(s, 0, new HashSet<>(wordDict), new LinkedList<>(), \"\");\\n        return result;\\n    }\\n\\n    private void backtracking(String s, int step, HashSet<String> wordDict, LinkedList<String> output, String temp) {\\n        if (step == s.length()) {\\n            if (output.size() > 0) {\\n                result.add(String.join(\" \", output));\\n            }\\n            return;\\n        }\\n\\n        for (int i = step; i < s.length(); i++) {\\n            temp += s.charAt(i);\\n            if (wordDict.contains(temp)) { // existed in the wordDict\\n                output.add(temp);\\n                backtracking(s, i + 1, wordDict, output, \"\");\\n                output.removeLast();\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Approach 2: DFS + Memorized - 9ms**\\n```java\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return DFS(s, wordDict, new HashMap<>());\\n    }\\n\\n    private List<String> DFS(String s, List<String> wordDict, Map<String, List<String>> cache) {\\n        if (cache.containsKey(s)) return cache.get(s);\\n        List<String> res = new LinkedList<>();\\n        if (s.length() == 0) { // found an answer\\n            res.add(\"\");\\n        } else {\\n            for (String word : wordDict) {\\n                if (s.startsWith(word)) {\\n                    List<String> subList = DFS(s.substring(word.length()), wordDict, cache);\\n                    for (String sub : subList) {\\n                        if (sub.isEmpty())\\n                            res.add(word);\\n                        else\\n                            res.add(word + \" \" + sub);\\n                    }\\n                }\\n            }\\n        }\\n        cache.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    List<String> result = new LinkedList<>();\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        result.clear();\\n        backtracking(s, 0, new HashSet<>(wordDict), new LinkedList<>(), \"\");\\n        return result;\\n    }\\n\\n    private void backtracking(String s, int step, HashSet<String> wordDict, LinkedList<String> output, String temp) {\\n        if (step == s.length()) {\\n            if (output.size() > 0) {\\n                result.add(String.join(\" \", output));\\n            }\\n            return;\\n        }\\n\\n        for (int i = step; i < s.length(); i++) {\\n            temp += s.charAt(i);\\n            if (wordDict.contains(temp)) { // existed in the wordDict\\n                output.add(temp);\\n                backtracking(s, i + 1, wordDict, output, \"\");\\n                output.removeLast();\\n            }\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return DFS(s, wordDict, new HashMap<>());\\n    }\\n\\n    private List<String> DFS(String s, List<String> wordDict, Map<String, List<String>> cache) {\\n        if (cache.containsKey(s)) return cache.get(s);\\n        List<String> res = new LinkedList<>();\\n        if (s.length() == 0) { // found an answer\\n            res.add(\"\");\\n        } else {\\n            for (String word : wordDict) {\\n                if (s.startsWith(word)) {\\n                    List<String> subList = DFS(s.substring(word.length()), wordDict, cache);\\n                    for (String sub : subList) {\\n                        if (sub.isEmpty())\\n                            res.add(word);\\n                        else\\n                            res.add(word + \" \" + sub);\\n                    }\\n                }\\n            }\\n        }\\n        cache.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44258,
                "title": "python-dfs-solution-o-mn-n-running-time",
                "content": "    class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        #running time: O(mn^2), n = len(s), m = len(wordDict)\\n        \"\"\"\\n        Let\\u2018s say the average word length in wordDict is k, so it takes n/k times to reach end.\\n        Each time, the helper function would be called and it's running time is O(m*n)\\n        So the whole runinng time  would be O( m*n*n/k), which is O(m*n^2)\\n        \"\"\"\\n        dic=collections.defaultdict(list)\\n        \\n        def helper(s):\\n            if not s: return [None]\\n            if s in dic: return dic[s]\\n            res =[]\\n            for word in wordDict:\\n                n = len(word)\\n                if word == s[:n]:\\n                    for each in helper(s[n:]):\\n                        if each:res.append(word+\" \"+each)\\n                        else: res.append(word)\\n                dic[s] = res\\n            return res\\n        \\n        return helper(s)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "    class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        #running time: O(mn^2), n = len(s), m = len(wordDict)\\n        \"\"\"\\n        Let\\u2018s say the average word length in wordDict is k, so it takes n/k times to reach end.\\n        Each time, the helper function would be called and it's running time is O(m*n)\\n        So the whole runinng time  would be O( m*n*n/k), which is O(m*n^2)\\n        \"\"\"\\n        dic=collections.defaultdict(list)\\n        \\n        def helper(s):\\n            if not s: return [None]\\n            if s in dic: return dic[s]\\n            res =[]\\n            for word in wordDict:\\n                n = len(word)\\n                if word == s[:n]:\\n                    for each in helper(s[n:]):\\n                        if each:res.append(word+\" \"+each)\\n                        else: res.append(word)\\n                dic[s] = res\\n            return res\\n        \\n        return helper(s)",
                "codeTag": "Java"
            },
            {
                "id": 3332872,
                "title": "c-memoization-trie-well-explained-solution-faster-than-100",
                "content": "**Intuition :**\\n\\nAs we can see, this problem invoves **forward partitioning**, i.e., we have to create partitions at all the gaps between letters and check for the condition:\\n* If the substring generated by partitioning is present in the dictionary, we can continue from the next letter and store the created string in a temporary variable. While returning, concatenate the generated strings with the stored temporary one. \\n\\n\\n* e.g., ![image](https://assets.leetcode.com/users/images/55459ded-54f5-4d25-9574-7839f4560a63_1679586683.848477.jpeg)\\n\\nThus, as we have to search for every partition, we can do DP here for minimising the **outer Time Complexity** to be O(n^2) instead of O(2^n) by normal recursive approach.\\n\\nAlso, as we have to search for words in the dict, we can use set or map but **trie** is a better option according to the time needed.\\n\\nSo, at first, all the words of dictiionary are stored in the trie. \\nNow, a recursive function is called with the **string s**, root of the trie and the index (initially 0).\\n\\nInternally, it is checked if after a partition (rather traversing the trie), we reach at the end of a word, we store it in temp variable and call from the next index and the root of the trie itself (as shown in the figure).\\n\\n**The code :**\\n```\\nstruct Node {\\n    Node * links[26];\\n    bool flag=false;\\n    \\n    bool containsKey (char ch){\\n        return (links[ch-\\'a\\']!=NULL);\\n    }\\n    \\n    void put (char ch, Node * node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    \\n    Node * get (char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    \\n    void setEnd() {\\n        flag=true;\\n    }\\n    \\n    bool isEnd () {\\n        return flag;\\n    }\\n};\\n\\n\\nclass Trie { \\n    \\npublic:\\n    \\n    Node * root;\\n    \\n    Trie() {\\n        root= new Node();\\n    }\\n    \\n    void insert(string word) {\\n        Node * node=root;\\n        for (int i=0;i<word.length();i++){\\n            if (! node->containsKey(word[i])){\\n                node->put(word[i], new Node());\\n            }\\n            //pointing to reference node\\n            node=node->get(word[i]);\\n        }\\n        // marking done\\n        node->setEnd();\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<string> solve (string s, int start, unordered_map <int, vector<string>> &mp, Node * root){\\n        \\n        if (mp.find(start)!=mp.end()) return mp[start];\\n        \\n        int n = s.length();\\n        vector<string> res;\\n        \\n        if (start==n){\\n            res.push_back(\"\");\\n            return mp[start]=res;\\n        }\\n        \\n        Node * cur=root;\\n        \\n        for (int i=start;i<n;i++){\\n            if (! cur->containsKey(s[i])) break;\\n            \\n            cur=cur->get(s[i]);\\n            if (cur->isEnd()){\\n                string temp= s.substr(start, i-start+1);\\n                if (i<s.length()-1){\\n                    temp+=\" \";\\n                }\\n                \\n                vector<string> temp2= solve(s,i+1,mp,root);\\n                for (string a:temp2){\\n                    string temp3=temp+a;\\n                    res.push_back(temp3);\\n                }\\n            }\\n        }\\n        return mp[start]=res;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        Trie trie;\\n        for (auto &temp : wordDict){\\n            trie.insert(temp);\\n        }\\n        unordered_map <int, vector<string>> mp;\\n        return solve (s,0,mp,trie.root);\\n    }\\n};\\n```\\nNote :\\n```\\ns.substr(i,j)= substring of s starting from index i and length j.\\n```\\n\\n**If you like the solution, do upvote.**",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nstruct Node {\\n    Node * links[26];\\n    bool flag=false;\\n    \\n    bool containsKey (char ch){\\n        return (links[ch-\\'a\\']!=NULL);\\n    }\\n    \\n    void put (char ch, Node * node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    \\n    Node * get (char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    \\n    void setEnd() {\\n        flag=true;\\n    }\\n    \\n    bool isEnd () {\\n        return flag;\\n    }\\n};\\n\\n\\nclass Trie { \\n    \\npublic:\\n    \\n    Node * root;\\n    \\n    Trie() {\\n        root= new Node();\\n    }\\n    \\n    void insert(string word) {\\n        Node * node=root;\\n        for (int i=0;i<word.length();i++){\\n            if (! node->containsKey(word[i])){\\n                node->put(word[i], new Node());\\n            }\\n            //pointing to reference node\\n            node=node->get(word[i]);\\n        }\\n        // marking done\\n        node->setEnd();\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<string> solve (string s, int start, unordered_map <int, vector<string>> &mp, Node * root){\\n        \\n        if (mp.find(start)!=mp.end()) return mp[start];\\n        \\n        int n = s.length();\\n        vector<string> res;\\n        \\n        if (start==n){\\n            res.push_back(\"\");\\n            return mp[start]=res;\\n        }\\n        \\n        Node * cur=root;\\n        \\n        for (int i=start;i<n;i++){\\n            if (! cur->containsKey(s[i])) break;\\n            \\n            cur=cur->get(s[i]);\\n            if (cur->isEnd()){\\n                string temp= s.substr(start, i-start+1);\\n                if (i<s.length()-1){\\n                    temp+=\" \";\\n                }\\n                \\n                vector<string> temp2= solve(s,i+1,mp,root);\\n                for (string a:temp2){\\n                    string temp3=temp+a;\\n                    res.push_back(temp3);\\n                }\\n            }\\n        }\\n        return mp[start]=res;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        Trie trie;\\n        for (auto &temp : wordDict){\\n            trie.insert(temp);\\n        }\\n        unordered_map <int, vector<string>> mp;\\n        return solve (s,0,mp,trie.root);\\n    }\\n};\\n```\n```\\ns.substr(i,j)= substring of s starting from index i and length j.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144682,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    void find(string s, unordered_set<string> st, int ind, string cur)\\n    {\\n        if(ind==s.size())\\n        {\\n            cur.pop_back();\\n            res.push_back(cur);\\n        }\\n        string a=\"\";\\n        for(int i=ind; i<s.size();i++)\\n        {\\n            string sub=s.substr(ind, i-ind+1);\\n            if(st.find(sub)!=st.end())\\n            {\\n                find(s, st, i+1, cur+sub+\" \");\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> st;\\n        for(string a:dict)\\n        st.insert(a);\\n        find(s, st, 0, \"\");\\n        return res;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    void find(string s, unordered_set<string> st, int ind, string cur)\\n    {\\n        if(ind==s.size())\\n        {\\n            cur.pop_back();\\n            res.push_back(cur);\\n        }\\n        string a=\"\";\\n        for(int i=ind; i<s.size();i++)\\n        {\\n            string sub=s.substr(ind, i-ind+1);\\n            if(st.find(sub)!=st.end())\\n            {\\n                find(s, st, i+1, cur+sub+\" \");\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> st;\\n        for(string a:dict)\\n        st.insert(a);\\n        find(s, st, 0, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679588,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<int,vector<string>> hm;\\n        unordered_set<string> hs(wordDict.begin(),wordDict.end());\\n        return wordBreakHelper(s, 0, hs, hm);\\n    }\\n\\t\\n    vector<string> wordBreakHelper(string s, int start, unordered_set<string> dict, unordered_map<int,vector<string>> hm ){\\n    if (hm.find(start)!=hm.end())\\n        return hm[start]; \\n\\n    vector<string> validSubstr;\\n\\n    if (start == s.size())\\n        validSubstr.push_back(\"\");\\n\\n    for (int end = start + 1; end <= s.size(); end++) {\\n        string prefix = s.substr(start, end-start);\\n        if (dict.find(prefix)!=dict.end()) //check if prefix is present in dict\\n\\t\\t{\\n            vector<string> suffixes = wordBreakHelper(s, end, dict, hm); //calculate valid sentences for remaining part\\n            for (string suffix : suffixes)\\n               validSubstr.push_back(prefix + (suffix==\"\" ? \"\" : \" \") + suffix);  //combine with prefixe\\n        }\\n    }\\n \\n    hm.insert({start, validSubstr}); //store the result\\n    return validSubstr;\\n }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<int,vector<string>> hm;\\n        unordered_set<string> hs(wordDict.begin(),wordDict.end());\\n        return wordBreakHelper(s, 0, hs, hm);\\n    }\\n\\t\\n    vector<string> wordBreakHelper(string s, int start, unordered_set<string> dict, unordered_map<int,vector<string>> hm ){\\n    if (hm.find(start)!=hm.end())\\n        return hm[start]; \\n\\n    vector<string> validSubstr;\\n\\n    if (start == s.size())\\n        validSubstr.push_back(\"\");\\n\\n    for (int end = start + 1; end <= s.size(); end++) {\\n        string prefix = s.substr(start, end-start);\\n        if (dict.find(prefix)!=dict.end()) //check if prefix is present in dict\\n\\t\\t{\\n            vector<string> suffixes = wordBreakHelper(s, end, dict, hm); //calculate valid sentences for remaining part\\n            for (string suffix : suffixes)\\n               validSubstr.push_back(prefix + (suffix==\"\" ? \"\" : \" \") + suffix);  //combine with prefixe\\n        }\\n    }\\n \\n    hm.insert({start, validSubstr}); //store the result\\n    return validSubstr;\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602252,
                "title": "time-beats-99-83-space-beats-88-35",
                "content": "**Explanation**: Whenever I say \"path\", I mean the sequence of words that can be spaced out and appended to our answer. I will be using the word \"path\" a lot to illustrate how this problem is pretty much the combination of [257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) and [139. Word Break](https://leetcode.com/problems/word-break/). Before continuing, I recommend solving the 2 problems that I linked. Essentially, we are constructing all valid \"paths\" that \"might\" lead us to a solution. When we reach the base case, we know that we constructed a valid \"path\", and we therefore append the \"path\" to the result.\\n\\nBelow is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def _wordBreak(self, s, wordDict, start, cur, res):\\n        # Base Case\\n        if start == len(s) and cur:\\n            res.append(\\' \\'.join(cur))\\n            \\n        for i in range(start, len(s)):\\n            word = s[start: i+1]\\n            \\n            if word in wordDict:\\n                \\n                # Append the word since it is in the dictionary\\n                cur.append(word)\\n                \\n                # Recursive Step\\n                self._wordBreak(s, wordDict, i+1, cur, res)\\n                \\n                # Backtracking / Post-processing / Pop the word we appended\\n                cur.pop()\\n        \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res = []\\n        self._wordBreak(s, set(wordDict), 0, [], res)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def _wordBreak(self, s, wordDict, start, cur, res):\\n        # Base Case\\n        if start == len(s) and cur:\\n            res.append(\\' \\'.join(cur))\\n            \\n        for i in range(start, len(s)):\\n            word = s[start: i+1]\\n            \\n            if word in wordDict:\\n                \\n                # Append the word since it is in the dictionary\\n                cur.append(word)\\n                \\n                # Recursive Step\\n                self._wordBreak(s, wordDict, i+1, cur, res)\\n                \\n                # Backtracking / Post-processing / Pop the word we appended\\n                cur.pop()\\n        \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res = []\\n        self._wordBreak(s, set(wordDict), 0, [], res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260118,
                "title": "c-easy-backtracking",
                "content": "```\\nvoid wb(vector<string>& res, vector<string>& dict, string s, int idx, int n, string str)\\n   {\\n       if(idx == n)\\n        {\\n            str.pop_back();\\n            res.push_back(str);\\n        }\\n        else\\n        {\\n            for(int k = idx; k < n; k++)\\n            {\\n                string temp = s.substr(idx, k - idx + 1);\\n                if(find(dict.begin(), dict.end(), temp) != dict.end())\\n                   wb(res, dict, s, k + 1, n, str + temp + \\' \\');\\n             }\\n        }\\n   }\\n\\n   vector<string> wordBreak(string s, vector<string>& dict) \\n    {\\n        vector<string> res;\\n        wb(res, dict, s, 0, s.size(), \"\");\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid wb(vector<string>& res, vector<string>& dict, string s, int idx, int n, string str)\\n   {\\n       if(idx == n)\\n        {\\n            str.pop_back();\\n            res.push_back(str);\\n        }\\n        else\\n        {\\n            for(int k = idx; k < n; k++)\\n            {\\n                string temp = s.substr(idx, k - idx + 1);\\n                if(find(dict.begin(), dict.end(), temp) != dict.end())\\n                   wb(res, dict, s, k + 1, n, str + temp + \\' \\');\\n             }\\n        }\\n   }\\n\\n   vector<string> wordBreak(string s, vector<string>& dict) \\n    {\\n        vector<string> res;\\n        wb(res, dict, s, 0, s.size(), \"\");\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 763538,
                "title": "java-dp-backtracking",
                "content": "```\\nclass Solution {\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n        List<String>[] str = DP(s, wordDict, dp);\\n        if(!dp[n]) return Collections.emptyList();\\n\\n        List<String> result = new LinkedList<>();\\n        StringBuilder builder = new StringBuilder();\\n        backtracking(result, builder, 0, str);\\n        return result;\\n    }\\n\\n    private void backtracking(List<String> result, StringBuilder builder, int index, List<String>[] str) {\\n\\n        if(index == str.length - 1) {\\n            result.add(builder.deleteCharAt(builder.length() - 1).toString());\\n            return;\\n        }\\n        List<String> list = str[index];\\n        for(String next : list) {\\n            int size = builder.length();\\n            builder.append(next);\\n            builder.append(\" \");\\n            backtracking(result, builder, index + next.length(), str);\\n            builder.delete(size, builder.length());\\n        }\\n\\n    }\\n\\n    private List<String>[] DP(String s, List<String> wordDict, boolean[] dp) {\\n\\n        List<String>[] str = new List[dp.length];\\n        for(int i = 0; i < dp.length - 1; i++) {\\n            if(dp[i]) {\\n                List<String> list = new LinkedList<>();\\n                for (String word: wordDict) {\\n                    if(s.indexOf(word, i) == i) {\\n                        dp[i + word.length()] = true;\\n                        list.add(word);\\n                    }\\n                }\\n                str[i] = list;\\n            }\\n        }\\n        return str;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n        List<String>[] str = DP(s, wordDict, dp);\\n        if(!dp[n]) return Collections.emptyList();\\n\\n        List<String> result = new LinkedList<>();\\n        StringBuilder builder = new StringBuilder();\\n        backtracking(result, builder, 0, str);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 44286,
                "title": "java-solution-with-memorization",
                "content": "```\\nprivate Map<String, List<String>> map = new HashMap<>();\\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        List<String> list = new ArrayList<>();\\n        if (wordDict.contains(s)) {\\n            list.add(s);\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            String word = s.substring(i);\\n            if (wordDict.contains(word)) {\\n                List<String> prior = wordBreak(s.substring(0, i), wordDict);\\n                for (String s1 : prior) {\\n                    list.add(s1 + \" \" + word);\\n                }\\n            }\\n        }\\n        map.put(s, list);\\n        return list;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\nprivate Map<String, List<String>> map = new HashMap<>();\\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        List<String> list = new ArrayList<>();\\n        if (wordDict.contains(s)) {\\n            list.add(s);\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            String word = s.substring(i);\\n            if (wordDict.contains(word)) {\\n                List<String> prior = wordBreak(s.substring(0, i), wordDict);\\n                for (String s1 : prior) {\\n                    list.add(s1 + \" \" + word);\\n                }\\n            }\\n        }\\n        map.put(s, list);\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44314,
                "title": "10ms-java-solution-with-dp-and-trie",
                "content": "    public List<String> wordBreak(String s, Set<String> wordDict) {\\n            Trie trie = new Trie();\\n            for(String word : wordDict) trie.put(word);\\n            List<String> res = new ArrayList<String>();\\n            List[] dp = new List[s.length()]; // store all the possible legal results of the substring of s starts from index i\\n            char[] c = s.toCharArray();\\n            getDP(c, 0, trie, dp);\\n            for (StringBuilder sb : (List<StringBuilder>)dp[0]) res.add(sb.toString());\\n            return res;\\n        }\\n        // get dp[start]\\n        private List<StringBuilder> getDP(char[] c, int start, Trie trie, List[] dp){\\n            List<Integer> ends = trie.getLegalEnds(c, start);// get all legal end indices starts from index \"start\"\\n            dp[start] = new ArrayList<StringBuilder>();\\n            for (int end : ends){\\n                if (end == c.length - 1) dp[start].add(new StringBuilder().append(c, start, end - start + 1));\\n                else{\\n                    if (dp[end + 1] == null) dp[end + 1] = getDP(c, end + 1, trie, dp);// if don't have dp[i], get it first\\n                    for (StringBuilder sb : (List<StringBuilder>)dp[end + 1]) // combine\\n                        dp[start].add(new StringBuilder().append(c, start, end - start + 1).append(\" \").append(sb));\\n                }\\n            }\\n            return dp[start];\\n        }\\n        \\n        //trie implementation with a little adjustment\\n        private class Trie{\\n            private class Node{\\n                boolean exist = false;\\n                Node[] next = new Node[26];\\n            }\\n            Node root = new Node();\\n            private void put(String word){\\n                put(word, root, 0);\\n            }\\n            private Node put(String word, Node root, int p){\\n                if (root == null) root = new Node();\\n                if (p == word.length()) {\\n                    root.exist = true;\\n                    return root;\\n                }\\n                root.next[word.charAt(p) - 'a'] = put(word, root.next[word.charAt(p) - 'a'], p + 1);\\n                return root;\\n            }\\n            private List<Integer> getLegalEnds(char[] c, int start){\\n                List<Integer> res = new ArrayList<Integer>();\\n                get(c, root, start, res);\\n                return res;\\n            }\\n            private void get(char[] c, Node root, int p, List<Integer> res){\\n                if (root == null) return;\\n                if (root.exist) res.add(p - 1); \\n                if (p == c.length) return;\\n                get(c, root.next[c[p] - 'a'], p + 1, res);\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public List<String> wordBreak(String s, Set<String> wordDict) {\\n            Trie trie = new Trie();\\n            for(String word : wordDict) trie.put(word);\\n            List<String> res = new ArrayList<String>();\\n            List[] dp = new List[s.length()]; // store all the possible legal results of the substring of s starts from index i\\n            char[] c = s.toCharArray();\\n            getDP(c, 0, trie, dp);\\n            for (StringBuilder sb : (List<StringBuilder>)dp[0]) res.add(sb.toString());\\n            return res;\\n        }\\n        // get dp[start]\\n        private List<StringBuilder> getDP(char[] c, int start, Trie trie, List[] dp){\\n            List<Integer> ends = trie.getLegalEnds(c, start);// get all legal end indices starts from index \"start\"\\n            dp[start] = new ArrayList<StringBuilder>();\\n            for (int end : ends){\\n                if (end == c.length - 1) dp[start].add(new StringBuilder().append(c, start, end - start + 1));\\n                else{\\n                    if (dp[end + 1] == null) dp[end + 1] = getDP(c, end + 1, trie, dp);// if don't have dp[i], get it first\\n                    for (StringBuilder sb : (List<StringBuilder>)dp[end + 1]) // combine\\n                        dp[start].add(new StringBuilder().append(c, start, end - start + 1).append(\" \").append(sb));\\n                }\\n            }\\n            return dp[start];\\n        }\\n        \\n        //trie implementation with a little adjustment\\n        private class Trie{\\n            private class Node{\\n                boolean exist = false;\\n                Node[] next = new Node[26];\\n            }\\n            Node root = new Node();\\n            private void put(String word){\\n                put(word, root, 0);\\n            }\\n            private Node put(String word, Node root, int p){\\n                if (root == null) root = new Node();\\n                if (p == word.length()) {\\n                    root.exist = true;\\n                    return root;\\n                }\\n                root.next[word.charAt(p) - 'a'] = put(word, root.next[word.charAt(p) - 'a'], p + 1);\\n                return root;\\n            }\\n            private List<Integer> getLegalEnds(char[] c, int start){\\n                List<Integer> res = new ArrayList<Integer>();\\n                get(c, root, start, res);\\n                return res;\\n            }\\n            private void get(char[] c, Node root, int p, List<Integer> res){\\n                if (root == null) return;\\n                if (root.exist) res.add(p - 1); \\n                if (p == c.length) return;\\n                get(c, root.next[c[p] - 'a'], p + 1, res);\\n            }\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 44332,
                "title": "my-python-56ms-solution",
                "content": "    class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            \"\"\"\\n            :type s: str\\n            :type wordDict: Set[str]\\n            :rtype: List[str]\\n            \"\"\"\\n            return findWords(0, len(s), s, wordDict, {})\\n    \\n    def findWords(start, end, s, wordDict, cache):\\n        if start in cache:\\n            return cache[start]\\n        cache[start] = []\\n        candidate = ''\\n        current = start\\n        while current < end:\\n            candidate += s[current]\\n            current += 1\\n            if candidate in wordDict:\\n                if current == end:\\n                    cache[start].append(candidate)\\n                else:\\n                    for x in findWords(current, end, s, wordDict, cache):\\n                        cache[start].append(candidate + ' ' + x)\\n        return cache[start]",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            \"\"\"\\n            :type s: str\\n            :type wordDict: Set[str]\\n            :rtype: List[str]\\n            \"\"\"\\n            return findWords(0, len(s), s, wordDict, {}",
                "codeTag": "Java"
            },
            {
                "id": 44364,
                "title": "an-elegant-python-solution-with-dp",
                "content": "Basic idea is starting from left most character of string, increase the index, if s[:idx+1] is a valid word, try generate all combinations of s[idx+1:]. Continue doing this until index reaches the end of string. This is a recursive solution, so each time all word break options are calculated, cache them.\\n\\n    class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a list of strings\\n        def wordBreak(self, s, dict):\\n            self.dict = dict\\n            self.cache = {}\\n            return self.break_helper(s)\\n            \\n        def break_helper(self, s):\\n            combs = []\\n            if s in self.cache:\\n                return self.cache[s]\\n            if len(s) == 0:\\n                return []\\n                \\n            for i in range(len(s)):\\n                if s[:i+1] in self.dict:\\n                    if i == len(s) - 1:\\n                        combs.append(s[:i+1])\\n                    else:\\n                        sub_combs = self.break_helper(s[i+1:])\\n                        for sub_comb in sub_combs:\\n                            combs.append(s[:i+1] + ' ' + sub_comb)\\n                        \\n            self.cache[s] = combs\\n            return combs",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a list of strings\\n        def wordBreak(self, s, dict):\\n            self.dict = dict\\n            self.cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 3110612,
                "title": "java-hashset-backtracking-simple-concise",
                "content": "```\\nclass Solution {\\n    private List<String> sentences;\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Set<String> words = new HashSet<>(wordDict);\\n        sentences = new ArrayList<>();\\n        wordBreak(words, s, 0, \"\");\\n        return sentences;\\n    }\\n\\n    private void wordBreak(Set<String> words, String s, int i, String sentence) {\\n        if (i == s.length()) {\\n            sentences.add(sentence);\\n            return;\\n        }\\n\\n        for (int j = i; j < s.length(); j++) {\\n            String word = s.substring(i, j + 1);\\n            if (words.contains(word)) {\\n                if (sentence.length() == 0) {\\n                    wordBreak(words, s, j + 1, sentence + word);\\n                } else {\\n                    wordBreak(words, s, j + 1, sentence + \" \" + word);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    private List<String> sentences;\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Set<String> words = new HashSet<>(wordDict);\\n        sentences = new ArrayList<>();\\n        wordBreak(words, s, 0, \"\");\\n        return sentences;\\n    }\\n\\n    private void wordBreak(Set<String> words, String s, int i, String sentence) {\\n        if (i == s.length()) {\\n            sentences.add(sentence);\\n            return;\\n        }\\n\\n        for (int j = i; j < s.length(); j++) {\\n            String word = s.substring(i, j + 1);\\n            if (words.contains(word)) {\\n                if (sentence.length() == 0) {\\n                    wordBreak(words, s, j + 1, sentence + word);\\n                } else {\\n                    wordBreak(words, s, j + 1, sentence + \" \" + word);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714550,
                "title": "c-dfs-faster-easy-to-understand",
                "content": "* ***DFS***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    unordered_set<string> s;\\n\\n    vector<string> res;\\n\\n    void helper(string& str, int i, int n, string curr)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            curr.pop_back();\\n\\n            res.push_back(curr);\\n\\n            return;\\n        }\\n        \\n        // partition str at j and if substring is present int set then call for next\\n\\n        for(int j = i; j < n; j++)\\n        {\\n            if(s.count(str.substr(i, j - i + 1)))\\n            {\\n                helper(str, j + 1, n, curr + str.substr(i, j - i + 1) + \\' \\');\\n            }\\n        }\\n    }\\n    \\n    vector<string> wordBreak(string str, vector<string>& wordDict) {\\n\\n        int n = str.size();\\n        \\n        // insert all the words into set\\n\\n        for(auto word : wordDict)\\n        {\\n            s.insert(word);\\n        }\\n\\n        helper(str, 0, n, \"\");\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    unordered_set<string> s;\\n\\n    vector<string> res;\\n\\n    void helper(string& str, int i, int n, string curr)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            curr.pop_back();\\n\\n            res.push_back(curr);\\n\\n            return;\\n        }\\n        \\n        // partition str at j and if substring is present int set then call for next\\n\\n        for(int j = i; j < n; j++)\\n        {\\n            if(s.count(str.substr(i, j - i + 1)))\\n            {\\n                helper(str, j + 1, n, curr + str.substr(i, j - i + 1) + \\' \\');\\n            }\\n        }\\n    }\\n    \\n    vector<string> wordBreak(string str, vector<string>& wordDict) {\\n\\n        int n = str.size();\\n        \\n        // insert all the words into set\\n\\n        for(auto word : wordDict)\\n        {\\n            s.insert(word);\\n        }\\n\\n        helper(str, 0, n, \"\");\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588753,
                "title": "simple-backtracking-solution-with-path-taken",
                "content": "```\\ndef wordBreak(s, wordDict):\\n\\tresult = []\\n\\tdef backtrack(start, path):\\n\\t\\t# base case/constraint\\n\\t\\tif start == len(s):\\n\\t\\t\\tresult.append(\\' \\'.join(path))\\n\\t\\t\\treturn\\n\\t\\t# iterate through remaining characters\\n\\t\\tfor i in range(start, len(s) + 1):\\n\\t\\t\\t# if the remaning characters form a valid word, only then try to backtrack \\n\\t\\t\\t# with the starting index being the end index of the previous valid word\\n\\t\\t\\tif start[start: i] in wordDict:\\n\\t\\t\\t\\tbacktrack(i, path + [s[start: i]])\\n\\tbacktrack(0, [])\\n\\treturn result\\n```\\nI had not come accross any solution in this discussion thread that used a similart solution to how you would find all permutations of a list. It is easy to understand and doesnt require memoization.",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\ndef wordBreak(s, wordDict):\\n\\tresult = []\\n\\tdef backtrack(start, path):\\n\\t\\t# base case/constraint\\n\\t\\tif start == len(s):\\n\\t\\t\\tresult.append(\\' \\'.join(path))\\n\\t\\t\\treturn\\n\\t\\t# iterate through remaining characters\\n\\t\\tfor i in range(start, len(s) + 1):\\n\\t\\t\\t# if the remaning characters form a valid word, only then try to backtrack \\n\\t\\t\\t# with the starting index being the end index of the previous valid word\\n\\t\\t\\tif start[start: i] in wordDict:\\n\\t\\t\\t\\tbacktrack(i, path + [s[start: i]])\\n\\tbacktrack(0, [])\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2369047,
                "title": "c-100-faster-backtracking-easy-to-understand",
                "content": "# Please UpVote if this solution helps you\\n\\n```\\nvoid solve(string &s,vector<string> &wordDict,string op,int index, vector<string> &ans)\\n    {\\n        if(index == s.length())\\n        {\\n            op.pop_back();    //We pop back here to remove space from the last\\n            ans.push_back(op);\\n            return;\\n        }\\n        string temp = \"\";\\n        for(int i = index;i<s.length();i++)\\n        {\\n            temp += s[i];\\n            if(find(wordDict.begin(),wordDict.end(),temp) != wordDict.end())\\n            {\\n                 solve(s,wordDict,op+temp+\" \",i+1,ans);    //If word find then check for next word\\n            } \\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n       vector<string> ans;\\n       string op = \"\";\\n       solve(s,wordDict,op,0,ans);\\n       return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "# Please UpVote if this solution helps you\\n\\n```\\nvoid solve(string &s,vector<string> &wordDict,string op,int index, vector<string> &ans)\\n    {\\n        if(index == s.length())\\n        {\\n            op.pop_back();    //We pop back here to remove space from the last\\n            ans.push_back(op);\\n            return;\\n        }\\n        string temp = \"\";\\n        for(int i = index;i<s.length();i++)\\n        {\\n            temp += s[i];\\n            if(find(wordDict.begin(),wordDict.end(),temp) != wordDict.end())\\n            {\\n                 solve(s,wordDict,op+temp+\" \",i+1,ans);    //If word find then check for next word\\n            } \\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n       vector<string> ans;\\n       string op = \"\";\\n       solve(s,wordDict,op,0,ans);\\n       return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1377390,
                "title": "c-100-faster-dp-solution-with-explanation-and-comments",
                "content": "This question is similar to word break 1. The only difference here is that here when we get a true (dictionary match), we add the strings to the anwser using the previously calculated strings. This is a bottom up DP solution.\\n\\nWe do this by building answers and store them in a dp vector where dp[i] stores answer for a string ending at the ith index.\\n* dp[i].first -> A boolean stores if the substring can be partitioned\\n* dp[i].second -> A set that stores all strings created till now for a string ending at the ith index\\n```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        \\n        int n = s.size();\\n        \\n        //First we make a dictionary set to fetch words in O(1)\\n        unordered_set<string> dictionary;\\n        for(int i=0; i<wordDict.size(); i++){\\n            dictionary.insert(wordDict[i]);\\n        }\\n        \\n        //Here we store values. dp[i].first stores if the substring can be partitioned\\n        //We create a vector of n+1 size and initialize the first index to true\\n        vector<pair<bool,unordered_set<string>>> dp(n+1);\\n        for(int i=1; i<=n; i++){\\n            dp[i].first = false;\\n        }\\n        \\n        //We initilaize this to true for the case that a dictionary word is the entire string\\n        dp[0].first = true;\\n        \\n        for(int i=1; i<=n; i++){\\n    \\n            //If dp[i-1] was true, we can start building possible words from the (i-1)st index that are in the dictionary\\n            if(dp[i-1].first){\\n                string str = \"\";\\n                for(int j=i-1; j<n; j++){\\n                    str += s[j];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//Check if the string from (i-1)st index to jth index exists in dictionary\\n                    if(dictionary.count(str)==1){\\n                        \\n                        //If we find a matching word, this means that the entire string till j can be partitioned\\n                        //So we mark it as true and get string possibilities till here using the previous answer\\n                        dp[j+1].first = true;\\n    \\n                        //If the earlier index did not have any string present (Case where first word in string)\\n                        if(dp[i-1].second.size()==0)\\n                            dp[j+1].second.insert(str);\\n                        \\n                        //Build strings for all possibilities using the last answer\\n                        else{\\n                            for(auto& tempS : dp[i-1].second){\\n                                string newS = tempS + \" \" + str;\\n                                dp[j+1].second.insert(newS);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<string> ans;\\n        \\n        //Return all strings for the string ending at (n-1)st index\\n        for(auto& str : dp[n].second){\\n            ans.push_back(str);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease feel free to suggest improvements to this code if any!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        \\n        int n = s.size();\\n        \\n        //First we make a dictionary set to fetch words in O(1)\\n        unordered_set<string> dictionary;\\n        for(int i=0; i<wordDict.size(); i++){\\n            dictionary.insert(wordDict[i]);\\n        }\\n        \\n        //Here we store values. dp[i].first stores if the substring can be partitioned\\n        //We create a vector of n+1 size and initialize the first index to true\\n        vector<pair<bool,unordered_set<string>>> dp(n+1);\\n        for(int i=1; i<=n; i++){\\n            dp[i].first = false;\\n        }\\n        \\n        //We initilaize this to true for the case that a dictionary word is the entire string\\n        dp[0].first = true;\\n        \\n        for(int i=1; i<=n; i++){\\n    \\n            //If dp[i-1] was true, we can start building possible words from the (i-1)st index that are in the dictionary\\n            if(dp[i-1].first){\\n                string str = \"\";\\n                for(int j=i-1; j<n; j++){\\n                    str += s[j];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//Check if the string from (i-1)st index to jth index exists in dictionary\\n                    if(dictionary.count(str)==1){\\n                        \\n                        //If we find a matching word, this means that the entire string till j can be partitioned\\n                        //So we mark it as true and get string possibilities till here using the previous answer\\n                        dp[j+1].first = true;\\n    \\n                        //If the earlier index did not have any string present (Case where first word in string)\\n                        if(dp[i-1].second.size()==0)\\n                            dp[j+1].second.insert(str);\\n                        \\n                        //Build strings for all possibilities using the last answer\\n                        else{\\n                            for(auto& tempS : dp[i-1].second){\\n                                string newS = tempS + \" \" + str;\\n                                dp[j+1].second.insert(newS);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<string> ans;\\n        \\n        //Return all strings for the string ending at (n-1)st index\\n        for(auto& str : dp[n].second){\\n            ans.push_back(str);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251729,
                "title": "python-trie-no-dp",
                "content": "```python\\nclass Solution:\\n    class Trie:\\n        def __init__(self):\\n            self.root = {}\\n            self.WORD_DELIM = \\'$\\'\\n            \\n        def addWord(self, word):\\n            cur = self.root\\n            for char in word:\\n                if char not in cur:\\n                    cur[char] = {}\\n                cur = cur[char]\\n            cur[self.WORD_DELIM] = word\\n            \\n        def addWords(self, words):\\n            for word in words:\\n                self.addWord(word)\\n                \\n        def getValidSentences(self, word, res = \\'\\'):            \\n            res = []\\n            def dfs(word=word, temp=[]):\\n                cur = self.root\\n                for i,char in enumerate(word):\\n                    if self.WORD_DELIM in cur:\\n                        dfs(word[i:], temp + [cur[self.WORD_DELIM]])\\n                    if char not in cur:\\n                        break\\n                    cur = cur[char]\\n                else:\\n                    if self.WORD_DELIM in cur:\\n                        res.append(\\' \\'.join(temp + [cur[self.WORD_DELIM]]))\\n            dfs()\\n            return res\\n                \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        trie = self.Trie()\\n        trie.addWords(wordDict)\\n        return trie.getValidSentences(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```python\\nclass Solution:\\n    class Trie:\\n        def __init__(self):\\n            self.root = {}\\n            self.WORD_DELIM = \\'$\\'\\n            \\n        def addWord(self, word):\\n            cur = self.root\\n            for char in word:\\n                if char not in cur:\\n                    cur[char] = {}\\n                cur = cur[char]\\n            cur[self.WORD_DELIM] = word\\n            \\n        def addWords(self, words):\\n            for word in words:\\n                self.addWord(word)\\n                \\n        def getValidSentences(self, word, res = \\'\\'):            \\n            res = []\\n            def dfs(word=word, temp=[]):\\n                cur = self.root\\n                for i,char in enumerate(word):\\n                    if self.WORD_DELIM in cur:\\n                        dfs(word[i:], temp + [cur[self.WORD_DELIM]])\\n                    if char not in cur:\\n                        break\\n                    cur = cur[char]\\n                else:\\n                    if self.WORD_DELIM in cur:\\n                        res.append(\\' \\'.join(temp + [cur[self.WORD_DELIM]]))\\n            dfs()\\n            return res\\n                \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        trie = self.Trie()\\n        trie.addWords(wordDict)\\n        return trie.getValidSentences(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204725,
                "title": "c-0-ms-solution-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        string op=\"\";\\n        solve(s, op, wordDict, 0);\\n        return ans;\\n    }\\n    \\n    void solve(string ip, string op, vector<string>mp, int start) {\\n        if(start == ip.size()){\\n            op.pop_back();\\n            ans.push_back(op);\\n            op.push_back(\\' \\');\\n            return;\\n        }\\n        \\n       for(int i=start; i<ip.length(); i++){\\n\\t   //check if the substring is present in the dictionary\\n\\t   \\n           if(find(mp.begin(), mp.end(), ip.substr(start, i-start+1)) != mp.end()) {\\n\\t\\t   //if the above substring is present in the dictionary, add it to the output string\\n\\t\\t   //also add a space after adding the word\\n\\t\\t   \\n               string prev = op;\\n               op += (ip.substr(start, i-start+1));\\n               op.push_back(\\' \\');\\n               solve(ip, op, mp, i+1);\\n\\t\\t\\t   \\n\\t\\t\\t   //backtrack step\\n               op = prev;\\n           }\\n       }\\n    return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        string op=\"\";\\n        solve(s, op, wordDict, 0);\\n        return ans;\\n    }\\n    \\n    void solve(string ip, string op, vector<string>mp, int start) {\\n        if(start == ip.size()){\\n            op.pop_back();\\n            ans.push_back(op);\\n            op.push_back(\\' \\');\\n            return;\\n        }\\n        \\n       for(int i=start; i<ip.length(); i++){\\n\\t   //check if the substring is present in the dictionary\\n\\t   \\n           if(find(mp.begin(), mp.end(), ip.substr(start, i-start+1)) != mp.end()) {\\n\\t\\t   //if the above substring is present in the dictionary, add it to the output string\\n\\t\\t   //also add a space after adding the word\\n\\t\\t   \\n               string prev = op;\\n               op += (ip.substr(start, i-start+1));\\n               op.push_back(\\' \\');\\n               solve(ip, op, mp, i+1);\\n\\t\\t\\t   \\n\\t\\t\\t   //backtrack step\\n               op = prev;\\n           }\\n       }\\n    return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765548,
                "title": "javascript-python3-c-top-down-bottom-up-partial",
                "content": "**Synopsis:**\\n\\nWe can use [\\uD83C\\uDFA8 The ART of Dynamic Programming ](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/) to construct the answer from right-to-left as the recursive stack unwinds by returning the list of words which can be created at each i-th index based upon the suffix at `S[i]` which is the substring `S[i:N)`, ie. the characters in `S` from `i` inclusive to `N` non-inclusive.\\n\\n**Note:** for the bottom-up solutions, only the JS solution is AC.  Both Python and C++ result in TLE.  This is really strange, I\\'m probably missing something basic, I\\'ll come back and revisit those another time.\\n\\n---\\n\\n**Step 0:** Start with a naive DFS + BT solution.  These solutions TLE as expected, and we cannot add a memo to these solutions because the path is constructed as a parameter passed into the recursive function.  In order to use memoization, we need to return the path as the recursive stack unwinds.\\n\\n*Javascript*\\n```\\nlet wordBreak = (S, A, words = new Set(), ans = []) => {\\n    let N = S.length;\\n    A.forEach(word => words.add(word));\\n    let go = (i = 0, path = []) => {\\n        if (i == N) {\\n            ans.push(path.join(\\' \\'));\\n            return;\\n        }\\n        for (let j = i + 1; j <= N; ++j) { // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (words.has(cand))\\n                go(j, path.concat(cand));  // \\uD83D\\uDE80 DFS + BT\\n        }\\n    };\\n    go();\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        words = []\\n        N = len(S)\\n        dict = set(A)\\n        def go(i = 0, path = []):\\n            if i == N:\\n                words.append(path.copy())\\n                return\\n            for j in range(i + 1, N + 1): # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    path.append(cand)\\n                    go(j, path)           # \\uD83D\\uDE80 DFS + BT\\n                    path.pop()\\n        go()\\n        return list(map(lambda row: \\' \\'.join(row), words))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using func = function<void(int, VS&&)>;\\n    VS wordBreak(string S, VS& A, VS words = {}) {\\n        int N = S.size();\\n        Set dict{ A.begin(), A.end() };\\n        func go = [&](int i, VS&& path = {}) {\\n            if (i == N) {\\n                stringstream ss; copy(path.begin(), path.end(), ostream_iterator<string>(ss, \" \"));\\n                auto ans = ss.str();\\n                ans.pop_back(); // remove trailing whitespace\\n                words.emplace_back(ans);\\n                return;\\n            }\\n            for (auto j{ i + 1 }; j <= N; ++j) { // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                auto cand = S.substr(i, j - i);\\n                if (dict.find(cand) != dict.end()) {\\n                    path.push_back(cand);\\n                    go(j, move(path));           // \\uD83D\\uDE80 DFS + BT\\n                    path.pop_back();\\n                }\\n            }\\n        };\\n        go(0, {});\\n        return words;\\n    }\\n};\\n```\\n\\n---\\n\\n**Step 1: Brute-Force** (TLE)\\n\\nAs mentioned in the previous step, \"In order to use memoization, we need to return the path as the recursive stack unwinds.\"  So let\\'s first create a brute-force solution which returns the answer as the recursive stack unwinds, then we\\'ll add memoization to this brute-force solution in the next step.\\n\\n*Javascript*\\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    A.forEach(word => dict.add(word));\\n    let go = (i = 0, words = []) => {\\n        if (i == N)                                  // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n            return [[]];\\n        for (let j = i + 1; j <= N; ++j) {           // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (let tail of go(j))\\n                    words.push([cand].concat(tail)); // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        }\\n        return words;\\n    };\\n    return go().map(a => a.join(\\' \\'));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        dict = set(A)\\n        def go(i = 0):\\n            words = []\\n            if i == N:                              # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n                return [[]]\\n            for j in range(i + 1, N + 1):           # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for last in go(j):\\n                        words.append([cand] + last) # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n            return words\\n        return list(map(lambda row: \\' \\'.join(row), go()))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n\\tusing VS = vector<string>;\\n\\tusing Set = unordered_set<string>;\\n\\tusing func = function<VS(int)>;\\n\\tVS wordBreak(string S, VS& A, Set dict = {}) {\\n\\t\\tint N = S.size();\\n\\t\\tfor (auto& word: A)\\n\\t\\t\\tdict.insert(word);\\n\\t\\tfunc go = [&](int i, VS words = {}) {\\n\\t\\t\\tif (i == N)                             // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n\\t\\t\\t\\treturn VS{\"\"};\\n\\t\\t\\tfor (auto j{ i + 1 }; j <= N; ++j) {    // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n\\t\\t\\t\\tauto cand = S.substr(i, j - i);\\n\\t\\t\\t\\tif (dict.find(cand) != dict.end())\\n\\t\\t\\t\\t\\tfor (auto& tail: go(j))         // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n\\t\\t\\t\\t\\t\\twords.emplace_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n\\t\\t\\t}\\n\\t\\t\\treturn words;\\n\\t\\t};\\n\\t\\treturn go(0);\\n\\t}\\n};\\n```\\n\\n---\\n\\n**Step 2: Memo** (AC)\\n\\nSimply add a memo onto the previous brute-force solutions for AC.\\n\\n*Javascript*\\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    let m = Array(N + 1).fill(null);\\n    A.forEach(word => dict.add(word));\\n    let go = (i = 0, words = []) => {\\n        if (m[i] != null)                            // \\uD83E\\uDD14 memo\\n            return m[i];\\n        if (i == N)                                  // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n            return m[i] = [[]];\\n        for (let j = i + 1; j <= N; ++j) {           // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (let tail of go(j))\\n                    words.push([cand].concat(tail)); // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        }\\n        return m[i] = words;\\n    };\\n    return go().map(a => a.join(\\' \\'));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        m = [None] * (N + 1)\\n        dict = set(A)\\n        def go(i = 0):\\n            if m[i] != None:                        # \\uD83E\\uDD14 memo\\n                return m[i]\\n            words = []\\n            if i == N:                              # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n                return [[]]\\n            for j in range(i + 1, N + 1):           # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for last in go(j):\\n                        words.append([cand] + last) # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n            m[i] = words\\n            return m[i]\\n        return list(map(lambda row: \\' \\'.join(row), go()))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n\\tusing VS = vector<string>;\\n\\tusing Set = unordered_set<string>;\\n\\tusing func = function<VS(int)>;\\n\\tusing Map = unordered_map<int, VS>;\\n\\tVS wordBreak(string S, VS& A, Set dict = {}, Map m = {}) {\\n\\t\\tint N = S.size();\\n\\t\\tfor (auto& word: A)\\n\\t\\t\\tdict.insert(word);\\n\\t\\tfunc go = [&](int i, VS words = {}) {\\n\\t\\t\\tif (m.find(i) != m.end())               // \\uD83E\\uDD14 memo\\n\\t\\t\\t\\treturn m[i];\\n\\t\\t\\tif (i == N)                             // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n\\t\\t\\t\\treturn m[i] = VS{\"\"};\\n\\t\\t\\tfor (auto j{ i + 1 }; j <= N; ++j) {    // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n\\t\\t\\t\\tauto cand = S.substr(i, j - i);\\n\\t\\t\\t\\tif (dict.find(cand) != dict.end())\\n\\t\\t\\t\\t\\tfor (auto& tail: go(j))         // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n\\t\\t\\t\\t\\t\\twords.emplace_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n\\t\\t\\t}\\n\\t\\t\\treturn m[i] = words;\\n\\t\\t};\\n\\t\\treturn go(0);\\n\\t}\\n};\\n```\\n\\n---\\n\\n**Step 3: Bottom-Up**\\n\\n**Note:** only the JS solution is AC.  Both Python and C++ result in TLE.  This is really strange, I\\'m probably missing something basic, I\\'ll come back and revisit those another time.\\n\\n*Javascript*\\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    let dp = [...Array(N + 1)].map(_ => []);         // \\uD83E\\uDD14 memo\\n    dp[N] = [[]];                                    // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n    A.forEach(word => dict.add(word));\\n    for (let i = N - 1; 0 <= i; --i) {               // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n        for (let j = i + 1; j <= N; ++j) {\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (tail of dp[j])\\n                    dp[i].push([cand].concat(tail)); // \\uD83D\\uDE80 concat each tail onto the current candidate, \\uD83D\\uDC48 ie. build the answer from right to left \\n        }\\n    }\\n    return dp[0].map(words => words.join(\\' \\'));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        dp = list(map(lambda _: [], [None] * (N + 1)))         # \\uD83E\\uDD14 memo\\n        dp[N] = [[]]                                           # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n        dict = set(A)\\n        for i in range(N - 1, -1, -1):                         # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            for j in range(i + 1, N + 1):\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for tail in dp[j]:\\n                        dp[i].append([cand] + tail)            # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        return list(map(lambda words: \\' \\'.join(words), dp[0]))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using VVS = vector<VS>;\\n    using Set = unordered_set<string>;\\n    VS wordBreak(string S, VS& A) {\\n        int N = S.size();\\n        VVS dp(N + 1);                              // \\uD83E\\uDD14 memo\\n        dp.back().push_back(\"\");                    // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n        Set dict{ A.begin(), A.end() };\\n        for (auto i{ N - 1 }; 0 <= i; --i) {        // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            for (auto j{ i + 1 }; j <= N; ++j) {\\n                auto cand = S.substr(i, j - i);\\n                if (dict.find(cand) != dict.end())\\n                    for (auto& tail: dp[j])         // \\uD83D\\uDE80 concat each tail onto the current candidate, \\uD83D\\uDC48 ie. build the answer from right to left\\n                        dp[i].push_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet wordBreak = (S, A, words = new Set(), ans = []) => {\\n    let N = S.length;\\n    A.forEach(word => words.add(word));\\n    let go = (i = 0, path = []) => {\\n        if (i == N) {\\n            ans.push(path.join(\\' \\'));\\n            return;\\n        }\\n        for (let j = i + 1; j <= N; ++j) { // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (words.has(cand))\\n                go(j, path.concat(cand));  // \\uD83D\\uDE80 DFS + BT\\n        }\\n    };\\n    go();\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        words = []\\n        N = len(S)\\n        dict = set(A)\\n        def go(i = 0, path = []):\\n            if i == N:\\n                words.append(path.copy())\\n                return\\n            for j in range(i + 1, N + 1): # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    path.append(cand)\\n                    go(j, path)           # \\uD83D\\uDE80 DFS + BT\\n                    path.pop()\\n        go()\\n        return list(map(lambda row: \\' \\'.join(row), words))\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using func = function<void(int, VS&&)>;\\n    VS wordBreak(string S, VS& A, VS words = {}) {\\n        int N = S.size();\\n        Set dict{ A.begin(), A.end() };\\n        func go = [&](int i, VS&& path = {}) {\\n            if (i == N) {\\n                stringstream ss; copy(path.begin(), path.end(), ostream_iterator<string>(ss, \" \"));\\n                auto ans = ss.str();\\n                ans.pop_back(); // remove trailing whitespace\\n                words.emplace_back(ans);\\n                return;\\n            }\\n            for (auto j{ i + 1 }; j <= N; ++j) { // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                auto cand = S.substr(i, j - i);\\n                if (dict.find(cand) != dict.end()) {\\n                    path.push_back(cand);\\n                    go(j, move(path));           // \\uD83D\\uDE80 DFS + BT\\n                    path.pop_back();\\n                }\\n            }\\n        };\\n        go(0, {});\\n        return words;\\n    }\\n};\\n```\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    A.forEach(word => dict.add(word));\\n    let go = (i = 0, words = []) => {\\n        if (i == N)                                  // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n            return [[]];\\n        for (let j = i + 1; j <= N; ++j) {           // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (let tail of go(j))\\n                    words.push([cand].concat(tail)); // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        }\\n        return words;\\n    };\\n    return go().map(a => a.join(\\' \\'));\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        dict = set(A)\\n        def go(i = 0):\\n            words = []\\n            if i == N:                              # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n                return [[]]\\n            for j in range(i + 1, N + 1):           # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for last in go(j):\\n                        words.append([cand] + last) # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n            return words\\n        return list(map(lambda row: \\' \\'.join(row), go()))\\n```\n```\\nclass Solution {\\npublic:\\n\\tusing VS = vector<string>;\\n\\tusing Set = unordered_set<string>;\\n\\tusing func = function<VS(int)>;\\n\\tVS wordBreak(string S, VS& A, Set dict = {}) {\\n\\t\\tint N = S.size();\\n\\t\\tfor (auto& word: A)\\n\\t\\t\\tdict.insert(word);\\n\\t\\tfunc go = [&](int i, VS words = {}) {\\n\\t\\t\\tif (i == N)                             // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n\\t\\t\\t\\treturn VS{\"\"};\\n\\t\\t\\tfor (auto j{ i + 1 }; j <= N; ++j) {    // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n\\t\\t\\t\\tauto cand = S.substr(i, j - i);\\n\\t\\t\\t\\tif (dict.find(cand) != dict.end())\\n\\t\\t\\t\\t\\tfor (auto& tail: go(j))         // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n\\t\\t\\t\\t\\t\\twords.emplace_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n\\t\\t\\t}\\n\\t\\t\\treturn words;\\n\\t\\t};\\n\\t\\treturn go(0);\\n\\t}\\n};\\n```\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    let m = Array(N + 1).fill(null);\\n    A.forEach(word => dict.add(word));\\n    let go = (i = 0, words = []) => {\\n        if (m[i] != null)                            // \\uD83E\\uDD14 memo\\n            return m[i];\\n        if (i == N)                                  // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n            return m[i] = [[]];\\n        for (let j = i + 1; j <= N; ++j) {           // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (let tail of go(j))\\n                    words.push([cand].concat(tail)); // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        }\\n        return m[i] = words;\\n    };\\n    return go().map(a => a.join(\\' \\'));\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        m = [None] * (N + 1)\\n        dict = set(A)\\n        def go(i = 0):\\n            if m[i] != None:                        # \\uD83E\\uDD14 memo\\n                return m[i]\\n            words = []\\n            if i == N:                              # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n                return [[]]\\n            for j in range(i + 1, N + 1):           # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for last in go(j):\\n                        words.append([cand] + last) # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n            m[i] = words\\n            return m[i]\\n        return list(map(lambda row: \\' \\'.join(row), go()))\\n```\n```\\nclass Solution {\\npublic:\\n\\tusing VS = vector<string>;\\n\\tusing Set = unordered_set<string>;\\n\\tusing func = function<VS(int)>;\\n\\tusing Map = unordered_map<int, VS>;\\n\\tVS wordBreak(string S, VS& A, Set dict = {}, Map m = {}) {\\n\\t\\tint N = S.size();\\n\\t\\tfor (auto& word: A)\\n\\t\\t\\tdict.insert(word);\\n\\t\\tfunc go = [&](int i, VS words = {}) {\\n\\t\\t\\tif (m.find(i) != m.end())               // \\uD83E\\uDD14 memo\\n\\t\\t\\t\\treturn m[i];\\n\\t\\t\\tif (i == N)                             // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n\\t\\t\\t\\treturn m[i] = VS{\"\"};\\n\\t\\t\\tfor (auto j{ i + 1 }; j <= N; ++j) {    // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n\\t\\t\\t\\tauto cand = S.substr(i, j - i);\\n\\t\\t\\t\\tif (dict.find(cand) != dict.end())\\n\\t\\t\\t\\t\\tfor (auto& tail: go(j))         // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n\\t\\t\\t\\t\\t\\twords.emplace_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n\\t\\t\\t}\\n\\t\\t\\treturn m[i] = words;\\n\\t\\t};\\n\\t\\treturn go(0);\\n\\t}\\n};\\n```\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    let dp = [...Array(N + 1)].map(_ => []);         // \\uD83E\\uDD14 memo\\n    dp[N] = [[]];                                    // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n    A.forEach(word => dict.add(word));\\n    for (let i = N - 1; 0 <= i; --i) {               // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n        for (let j = i + 1; j <= N; ++j) {\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (tail of dp[j])\\n                    dp[i].push([cand].concat(tail)); // \\uD83D\\uDE80 concat each tail onto the current candidate, \\uD83D\\uDC48 ie. build the answer from right to left \\n        }\\n    }\\n    return dp[0].map(words => words.join(\\' \\'));\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        dp = list(map(lambda _: [], [None] * (N + 1)))         # \\uD83E\\uDD14 memo\\n        dp[N] = [[]]                                           # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n        dict = set(A)\\n        for i in range(N - 1, -1, -1):                         # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            for j in range(i + 1, N + 1):\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for tail in dp[j]:\\n                        dp[i].append([cand] + tail)            # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        return list(map(lambda words: \\' \\'.join(words), dp[0]))\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using VVS = vector<VS>;\\n    using Set = unordered_set<string>;\\n    VS wordBreak(string S, VS& A) {\\n        int N = S.size();\\n        VVS dp(N + 1);                              // \\uD83E\\uDD14 memo\\n        dp.back().push_back(\"\");                    // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n        Set dict{ A.begin(), A.end() };\\n        for (auto i{ N - 1 }; 0 <= i; --i) {        // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            for (auto j{ i + 1 }; j <= N; ++j) {\\n                auto cand = S.substr(i, j - i);\\n                if (dict.find(cand) != dict.end())\\n                    for (auto& tail: dp[j])         // \\uD83D\\uDE80 concat each tail onto the current candidate, \\uD83D\\uDC48 ie. build the answer from right to left\\n                        dp[i].push_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763825,
                "title": "python-short-recursion-99-5",
                "content": "I\\'m sure the timings are variable but that\\'s what it yielded for me. Also, although I\\'ve called the function DFS the tree structure is perhaps not immediately obvious. \\n\\nThis problem seems oddly easy if you rule out the pathological cases of the form `s=\\'aa...aba...aa\\'` where the words are all `a` string and the like. In the below solution this is done by creating a set of all letters in the words `wordLets` and all letters in the string `stringLets` and returning the empty list if the set difference is non-empty. After that we perform a DFS for the remaining cases. \\n\\nThe DFS takes two arguments `so_far` is a list of the words found so far and `ind` is the start index, which will be right after the last word added to the list. If `ind == n` that means we managed to progress all the way to the end of the string, in which case, wejoin the list of words we\\'ve found and append it to the solution list. Otherwise, if we find a slice `s[ind:i]` which is in the word dictionary, then we call the DFS function recursively with this word added to `so_far` and restarting our scan from position `ind = i` in the string.\\n\\nWe also change the list of input words into a set for faster lookup.\\n\\n\\t\\n\\t\\n\\t\\n\\tdef wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n\\n        wordLets = set(\\'\\'.join(wordDict))\\n        wordDict = set(wordDict) #Fast lookup\\n        stringLets = set(s)\\n        \\n        if stringLets - wordLets:\\n            return []\\n        \\n        word_list_list = []\\n        n = len(s)\\n        \\n        def DFS(so_far = [], ind = 0):\\n            if ind == n:\\n                word_list_list.append(\\' \\'.join(so_far))\\n                return\\n            for i in range(ind, n+1):\\n                if s[ind:i] in wordDict:\\n                    DFS(so_far+[s[ind:i]], i)\\n                    \\n        DFS()\\n        \\n        return word_list_list",
                "solutionTags": [],
                "code": "I\\'m sure the timings are variable but that\\'s what it yielded for me. Also, although I\\'ve called the function DFS the tree structure is perhaps not immediately obvious. \\n\\nThis problem seems oddly easy if you rule out the pathological cases of the form `s=\\'aa...aba...aa\\'` where the words are all `a` string and the like. In the below solution this is done by creating a set of all letters in the words `wordLets` and all letters in the string `stringLets` and returning the empty list if the set difference is non-empty. After that we perform a DFS for the remaining cases. \\n\\nThe DFS takes two arguments `so_far` is a list of the words found so far and `ind` is the start index, which will be right after the last word added to the list. If `ind == n` that means we managed to progress all the way to the end of the string, in which case, wejoin the list of words we\\'ve found and append it to the solution list. Otherwise, if we find a slice `s[ind:i]` which is in the word dictionary, then we call the DFS function recursively with this word added to `so_far` and restarting our scan from position `ind = i` in the string.\\n\\nWe also change the list of input words into a set for faster lookup.\\n\\n\\t\\n\\t\\n\\t\\n\\tdef wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n\\n        wordLets = set(\\'\\'.join(wordDict))\\n        wordDict = set(wordDict) #Fast lookup\\n        stringLets = set(s)\\n        \\n        if stringLets - wordLets:\\n            return []\\n        \\n        word_list_list = []\\n        n = len(s)\\n        \\n        def DFS(so_far = [], ind = 0):\\n            if ind == n:\\n                word_list_list.append(\\' \\'.join(so_far))\\n                return\\n            for i in range(ind, n+1):\\n                if s[ind:i] in wordDict:\\n                    DFS(so_far+[s[ind:i]], i)\\n                    \\n        DFS()\\n        \\n        return word_list_list",
                "codeTag": "Python3"
            },
            {
                "id": 763397,
                "title": "simple-dp-swift-solution",
                "content": "It\\'s not hard\\n```\\nclass Solution {\\n    \\n    var cache: [String: [String]] = [:]\\n    \\n    func wordBreak(_ str: String, _ wordDict: [String]) -> [String] {\\n        if let ans = cache[str] {\\n            return ans\\n        }\\n        var ans: [String] = []\\n        for word in wordDict {\\n            if str.hasPrefix(word) {\\n                if str.count == word.count {\\n                    ans.append(word)\\n                } else {\\n                    let substr = str.substring(from: word.endIndex)\\n                    var subwords = wordBreak(substr, wordDict)\\n                    for substr in subwords {\\n                        ans.append(word + \" \" + substr)\\n                    }\\n                }\\n            } \\n        }\\n        cache[str] = ans\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    \\n    var cache: [String: [String]] = [:]\\n    \\n    func wordBreak(_ str: String, _ wordDict: [String]) -> [String] {\\n        if let ans = cache[str] {\\n            return ans\\n        }\\n        var ans: [String] = []\\n        for word in wordDict {\\n            if str.hasPrefix(word) {\\n                if str.count == word.count {\\n                    ans.append(word)\\n                } else {\\n                    let substr = str.substring(from: word.endIndex)\\n                    var subwords = wordBreak(substr, wordDict)\\n                    for substr in subwords {\\n                        ans.append(word + \" \" + substr)\\n                    }\\n                }\\n            } \\n        }\\n        cache[str] = ans\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534028,
                "title": "cpp-dfs-memo-to-speed-up",
                "content": "```\\n\\nclass Solution { // dfs + memo\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        map<int, vector<string>> memo;\\n        return dfs(s, dict, 0, memo);\\n    }\\n    vector<string> dfs(string s, set<string> &wordDict, int index, map<int, vector<string>> &memo) {\\n        if(memo.count(index)) return memo[index];\\n        vector<string> ret;\\n        for(int i = index; i < s.size(); i++) {\\n            string cur = s.substr(index, i - index + 1);\\n            if(wordDict.count(cur)) {\\n                if(i == s.size() - 1) ret.push_back(cur);\\n                vector<string> tmp = dfs(s, wordDict, i + 1, memo);\\n                for(string e :tmp) ret.push_back(cur + \" \" + e);\\n            }\\n        }\\n        memo[index] = ret;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution { // dfs + memo\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        map<int, vector<string>> memo;\\n        return dfs(s, dict, 0, memo);\\n    }\\n    vector<string> dfs(string s, set<string> &wordDict, int index, map<int, vector<string>> &memo) {\\n        if(memo.count(index)) return memo[index];\\n        vector<string> ret;\\n        for(int i = index; i < s.size(); i++) {\\n            string cur = s.substr(index, i - index + 1);\\n            if(wordDict.count(cur)) {\\n                if(i == s.size() - 1) ret.push_back(cur);\\n                vector<string> tmp = dfs(s, wordDict, i + 1, memo);\\n                for(string e :tmp) ret.push_back(cur + \" \" + e);\\n            }\\n        }\\n        memo[index] = ret;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481615,
                "title": "python-dfs-memo",
                "content": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        return self.helper(s, memo, wordDict)\\n    def helper(self, s, memo, wordDict):\\n        if s in memo:\\n            return memo[s]\\n        ans = []\\n        if s in wordDict:\\n            ans.append(s)\\n            \\n        for i in range(1, len(s)):  \\n            right = s[i:]\\n            if right not in wordDict:\\n                continue\\n            left = s[:i]\\n            ans += [w + \" \" + right for w in self.helper(left, memo, wordDict)]\\n            \\n        memo[s] = ans\\n        return memo[s]\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        return self.helper(s, memo, wordDict)\\n    def helper(self, s, memo, wordDict):\\n        if s in memo:\\n            return memo[s]\\n        ans = []\\n        if s in wordDict:\\n            ans.append(s)\\n            \\n        for i in range(1, len(s)):  \\n            right = s[i:]\\n            if right not in wordDict:\\n                continue\\n            left = s[:i]\\n            ans += [w + \" \" + right for w in self.helper(left, memo, wordDict)]\\n            \\n        memo[s] = ans\\n        return memo[s]\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 437669,
                "title": "c-trie-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        bool isWord;\\n        unordered_map<char,TrieNode*> children;\\n        TrieNode(){\\n            isWord=false;\\n        }\\n    };\\n    \\n    void buildTrie(string &s){\\n        TrieNode* cur=root;\\n        for(int i=0;i<s.size();i++){\\n            if(cur->children.find(s[i])==cur->children.end()){\\n                cur->children[s[i]]=new TrieNode();\\n            }\\n            cur=cur->children[s[i]];\\n        }\\n        cur->isWord=true;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        root=new TrieNode();\\n        for(string &word:wordDict){\\n            buildTrie(word);\\n        }\\n        unordered_map<int,vector<string>> memo;\\n        return dfs(s,0,memo);\\n    }\\n    \\n    vector<string> dfs(string &s,int pos,unordered_map<int,vector<string>> &memo){\\n        vector<string> res;\\n        if(pos==s.size()){\\n            res.push_back(\"\");\\n            return res;\\n        }\\n        \\n        if(memo.count(pos)){\\n            return memo[pos];\\n        }\\n        \\n        TrieNode *cur=root;\\n        \\n        for(int i=pos;i<s.size();i++){\\n            if(cur->children.find(s[i])==cur->children.end()){\\n                break;\\n            }\\n            cur=cur->children[s[i]];\\n            if(cur->isWord){\\n                int len=i-pos+1;\\n                string tmp=s.substr(pos,len);\\n                if(i<s.size()-1){\\n                    tmp+=\" \";\\n                }\\n                auto next=dfs(s,i+1,memo);\\n                for(string &n:next){\\n                    string t=tmp+n;\\n                    res.push_back(t);\\n                }                \\n            }\\n        }\\n        \\n        memo[pos]=res;\\n        return res;\\n    }\\n    \\nprivate:\\n    TrieNode* root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        bool isWord;\\n        unordered_map<char,TrieNode*> children;\\n        TrieNode(){\\n            isWord=false;\\n        }\\n    };\\n    \\n    void buildTrie(string &s){\\n        TrieNode* cur=root;\\n        for(int i=0;i<s.size();i++){\\n            if(cur->children.find(s[i])==cur->children.end()){\\n                cur->children[s[i]]=new TrieNode();\\n            }\\n            cur=cur->children[s[i]];\\n        }\\n        cur->isWord=true;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        root=new TrieNode();\\n        for(string &word:wordDict){\\n            buildTrie(word);\\n        }\\n        unordered_map<int,vector<string>> memo;\\n        return dfs(s,0,memo);\\n    }\\n    \\n    vector<string> dfs(string &s,int pos,unordered_map<int,vector<string>> &memo){\\n        vector<string> res;\\n        if(pos==s.size()){\\n            res.push_back(\"\");\\n            return res;\\n        }\\n        \\n        if(memo.count(pos)){\\n            return memo[pos];\\n        }\\n        \\n        TrieNode *cur=root;\\n        \\n        for(int i=pos;i<s.size();i++){\\n            if(cur->children.find(s[i])==cur->children.end()){\\n                break;\\n            }\\n            cur=cur->children[s[i]];\\n            if(cur->isWord){\\n                int len=i-pos+1;\\n                string tmp=s.substr(pos,len);\\n                if(i<s.size()-1){\\n                    tmp+=\" \";\\n                }\\n                auto next=dfs(s,i+1,memo);\\n                for(string &n:next){\\n                    string t=tmp+n;\\n                    res.push_back(t);\\n                }                \\n            }\\n        }\\n        \\n        memo[pos]=res;\\n        return res;\\n    }\\n    \\nprivate:\\n    TrieNode* root;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322400,
                "title": "standard-python-dp-solutions-bottom-up-top-down",
                "content": "Please see and vote for my Python DP solutions for\\n[139. Word Break](https://leetcode.com/problems/word-break/discuss/322388/Standard-DP-solutions-(Bottom-up-Top-down))\\n[140. Word Break II](https://leetcode.com/problems/word-break-ii/discuss/322400/Standard-Python-DP-solutions-(Bottom-up-Top-down))\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n\\nMethod 1: standard DP\\n```\\nLet dp[i] = a list of all possible segmentations of s[:i], i=0,1,2,...,len(s).\\nInitially set dp = [[] for _ in range(len(s) + 1)].\\nBase case: dp[0] = [\\'\\'].\\nRecursive relationship for dp[i]:\\nfor j = i-1, i-2, ..., 0,\\n     if dp[j] != [] and s[j:i] in wordDict: \\n\\t     for each s_break in dp[j]: append s_break + \\' \\' + s[j:i] to dp[i].\\n```\\n\\nSolution 1: bottom-up approach with time O(W + n^3 + 2^n) and **space O(W + n * 2^n)** (Memory Limit Exceeded, 31 / 39 test cases passed)\\n(space complexity: dp: O(n), each dp[i]: O(n), each word in dp[i]: O(n) )\\n```\\n    def wordBreak(self, s, wordDict):\\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0] = [\\'\\']\\n        for i in range(1, n + 1):\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and dp[j] != []:\\n                    for s_break in dp[j]:\\n                        dp[i].append(s_break + (\\' \\' if s_break != \\'\\' else \\'\\') + s[j:i])\\n                j -= 1\\n        return dp[n]\\n```\\n\\nSolution 2:  top-down approach with time O(W + n^3 + 2^n) and **space O(W + n * 2 ^ n)** (56 ms, beat 44%)\\n(dp[i] will be calculated only if it is necessary. In some test cases, not all d[i] are calculated)\\n```\\n    def wordBreak(self, s, wordDict):\\n        def recursive(i):\\n            if i in dp:\\n                return dp[i]\\n            dp[i] = []\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and recursive(j) != []:\\n                    for s_break in dp[j]:\\n                        dp[i].append(s_break + (\\' \\' if s_break != \\'\\' else \\'\\') + s[j:i])\\n                j -= 1\\n            return dp[i]\\n            \\n        word_set = set(wordDict)\\n        dp = {0: [\\'\\']}\\n        return recursive(len(s))\\n```\\n\\nMethod 2: standard DP + DFS reconstruction\\n```\\nLet dp[i] = a list of all possible last positions of segmentations of s[:i], i=0,1,2,...,len(s).\\nInitially set dp = [[] for _ in range(len(s) + 1)].\\nBase case: dp[0] = [0].\\nRecursive relationship for dp[i]:\\nfor j = i -1, i-2, ..., 0,\\n     if dp[j] != [] and s[j:i] in wordDict: \\n\\t     dp[i].append(j)\\nUse DFS to reconstruct all possible segmentations from the end to the start.\\n```\\n\\nSolution 3: bottom-up approach with time O(W + n^3 + 2^n) and **space O(W + n^2 + n * 2^n)** (52 ms, beat 59.98%)\\ncreate a set of words:  time: O(W), space: O(W)\\n\\ndynamic programming: \\ntime: O(n^3) ((O(n) subproblems, O(n) steps in the nested loop, and O(n) for substring slicing s[j:i]\\nspace: O(n^2)\\n\\nDFS reconstruction: time: O(2^n), space: O(n * 2^n)\\n\\n```\\n    def wordBreak(self, s, wordDict):\\n        def dfs(i, path):\\n            if i == 0:\\n                path.append(0)\\n                paths.append(path[::-1])\\n            else:\\n                for j in dp[i]:\\n                    dfs(j, path + [i])\\n                \\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0] = [0]\\n        for i in range(1, n + 1):\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and dp[j] != []:\\n                    dp[i].append(j)\\n                j -= 1\\n        paths = []\\n        dfs(n, [])\\n        res = []\\n        for path in paths:\\n            s_break = \\' \\'.join([s[path[k]:path[k+1]] for k in range(len(path) - 1)])\\n            res.append(s_break)\\n        return res\\n```\\n\\nSolution 4: top-down approach with time O(W + n^3 + 2^n) and **space O(W + n^2 + n*2^n)** (44 ms, 87.26%)\\n(dp[i] will be calculated only if it is necessary. In some test cases, not all d[i] are calculated)\\ncreate a set of words:  time: O(W), space: O(W)\\n\\ndynamic programming: \\ntime: O(n^3) ((O(n) subproblems, O(n) steps in the nested loop, and O(n) for substring slicing s[j:i]\\nspace: O(n^2)\\n\\nDFS reconstruction: time: O(2^n), space: O(n * 2^n)\\n```\\n    def wordBreak(self, s, wordDict):\\n        def dfs(i, path):\\n            if i == 0:\\n                path.append(0)\\n                paths.append(path[::-1])\\n            else:\\n                for j in dp[i]:\\n                    dfs(j, path + [i])\\n        \\n        def recursive(i):\\n            if i in dp:\\n                return dp[i]\\n            dp[i] = []\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and recursive(j) != []:\\n                    dp[i].append(j)\\n                j -= 1\\n            return dp[i]\\n            \\n        word_set = set(wordDict)\\n        dp = {0: 0}\\n        recursive(len(s))\\n        paths = []\\n        dfs(len(s), [])\\n        res = []\\n        for path in paths:\\n            s_break = \\' \\'.join([s[path[k]:path[k+1]] for k in range(len(path) - 1)])\\n            res.append(s_break)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nLet dp[i] = a list of all possible segmentations of s[:i], i=0,1,2,...,len(s).\\nInitially set dp = [[] for _ in range(len(s) + 1)].\\nBase case: dp[0] = [\\'\\'].\\nRecursive relationship for dp[i]:\\nfor j = i-1, i-2, ..., 0,\\n     if dp[j] != [] and s[j:i] in wordDict: \\n\\t     for each s_break in dp[j]: append s_break + \\' \\' + s[j:i] to dp[i].\\n```\n```\\n    def wordBreak(self, s, wordDict):\\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0] = [\\'\\']\\n        for i in range(1, n + 1):\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and dp[j] != []:\\n                    for s_break in dp[j]:\\n                        dp[i].append(s_break + (\\' \\' if s_break != \\'\\' else \\'\\') + s[j:i])\\n                j -= 1\\n        return dp[n]\\n```\n```\\n    def wordBreak(self, s, wordDict):\\n        def recursive(i):\\n            if i in dp:\\n                return dp[i]\\n            dp[i] = []\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and recursive(j) != []:\\n                    for s_break in dp[j]:\\n                        dp[i].append(s_break + (\\' \\' if s_break != \\'\\' else \\'\\') + s[j:i])\\n                j -= 1\\n            return dp[i]\\n            \\n        word_set = set(wordDict)\\n        dp = {0: [\\'\\']}\\n        return recursive(len(s))\\n```\n```\\nLet dp[i] = a list of all possible last positions of segmentations of s[:i], i=0,1,2,...,len(s).\\nInitially set dp = [[] for _ in range(len(s) + 1)].\\nBase case: dp[0] = [0].\\nRecursive relationship for dp[i]:\\nfor j = i -1, i-2, ..., 0,\\n     if dp[j] != [] and s[j:i] in wordDict: \\n\\t     dp[i].append(j)\\nUse DFS to reconstruct all possible segmentations from the end to the start.\\n```\n```\\n    def wordBreak(self, s, wordDict):\\n        def dfs(i, path):\\n            if i == 0:\\n                path.append(0)\\n                paths.append(path[::-1])\\n            else:\\n                for j in dp[i]:\\n                    dfs(j, path + [i])\\n                \\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0] = [0]\\n        for i in range(1, n + 1):\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and dp[j] != []:\\n                    dp[i].append(j)\\n                j -= 1\\n        paths = []\\n        dfs(n, [])\\n        res = []\\n        for path in paths:\\n            s_break = \\' \\'.join([s[path[k]:path[k+1]] for k in range(len(path) - 1)])\\n            res.append(s_break)\\n        return res\\n```\n```\\n    def wordBreak(self, s, wordDict):\\n        def dfs(i, path):\\n            if i == 0:\\n                path.append(0)\\n                paths.append(path[::-1])\\n            else:\\n                for j in dp[i]:\\n                    dfs(j, path + [i])\\n        \\n        def recursive(i):\\n            if i in dp:\\n                return dp[i]\\n            dp[i] = []\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and recursive(j) != []:\\n                    dp[i].append(j)\\n                j -= 1\\n            return dp[i]\\n            \\n        word_set = set(wordDict)\\n        dp = {0: 0}\\n        recursive(len(s))\\n        paths = []\\n        dfs(len(s), [])\\n        res = []\\n        for path in paths:\\n            s_break = \\' \\'.join([s[path[k]:path[k+1]] for k in range(len(path) - 1)])\\n            res.append(s_break)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 309369,
                "title": "java-95-11-runtime-4ms-99-77-memory-36-2-mb-human-readable",
                "content": "```\\nclass Solution {\\n    public List<String> wordBreak(String wordToBreak, List<String> wordDict) {        \\n        return findSolutions(wordToBreak, wordDict, new HashMap<>());\\n    }\\n    \\n    public List<String> findSolutions(String wordToBreak, List<String> wordDict, Map<String, List<String>> wordBrokenDict){\\n        if(wordBrokenDict.containsKey(wordToBreak)){\\n            return wordBrokenDict.get(wordToBreak);\\n        }\\n        \\n        List<String> solutions = new ArrayList<>();\\n        for(String word: wordDict){\\n            if(!wordToBreak.startsWith(word)){\\n                continue;\\n            }\\n            \\n            if(wordToBreak.length() == word.length()){\\n                solutions.add(word);\\n                continue;\\n            }\\n            \\n            List<String> subSolutions = findSolutions(wordToBreak.substring(word.length()), wordDict, wordBrokenDict);\\n            for(String subSolution: subSolutions) {\\n                StringBuilder strBuilder = new StringBuilder();\\n                strBuilder.append(word).append(\\' \\').append(subSolution);\\n                solutions.add(strBuilder.toString());\\n            }\\n        }\\n        \\n        wordBrokenDict.put(wordToBreak, solutions);\\n        return solutions;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String wordToBreak, List<String> wordDict) {        \\n        return findSolutions(wordToBreak, wordDict, new HashMap<>());\\n    }\\n    \\n    public List<String> findSolutions(String wordToBreak, List<String> wordDict, Map<String, List<String>> wordBrokenDict){\\n        if(wordBrokenDict.containsKey(wordToBreak)){\\n            return wordBrokenDict.get(wordToBreak);\\n        }\\n        \\n        List<String> solutions = new ArrayList<>();\\n        for(String word: wordDict){\\n            if(!wordToBreak.startsWith(word)){\\n                continue;\\n            }\\n            \\n            if(wordToBreak.length() == word.length()){\\n                solutions.add(word);\\n                continue;\\n            }\\n            \\n            List<String> subSolutions = findSolutions(wordToBreak.substring(word.length()), wordDict, wordBrokenDict);\\n            for(String subSolution: subSolutions) {\\n                StringBuilder strBuilder = new StringBuilder();\\n                strBuilder.append(word).append(\\' \\').append(subSolution);\\n                solutions.add(strBuilder.toString());\\n            }\\n        }\\n        \\n        wordBrokenDict.put(wordToBreak, solutions);\\n        return solutions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222797,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def dfs(i):\\n            if i == len(s):\\n                return [\"\"]\\n            if i in dic:\\n                return dic[i]\\n            res = []\\n            for j in range(i, len(s)):\\n                head = s[i:j+1]\\n                if head in wordSet:\\n                    tmp = dfs(j+1)\\n                    for string in tmp:\\n                        string = head +\" \"+string\\n                        res.append(string.strip())\\n            dic[i] = res\\n            return res\\n        \\n        dic = {}\\n        wordSet = set(wordDict)\\n        return dfs(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def dfs(i):\\n            if i == len(s):\\n                return [\"\"]\\n            if i in dic:\\n                return dic[i]\\n            res = []\\n            for j in range(i, len(s)):\\n                head = s[i:j+1]\\n                if head in wordSet:\\n                    tmp = dfs(j+1)\\n                    for string in tmp:\\n                        string = head +\" \"+string\\n                        res.append(string.strip())\\n            dic[i] = res\\n            return res\\n        \\n        dic = {}\\n        wordSet = set(wordDict)\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190915,
                "title": "c-neat",
                "content": "```\nclass Solution {\npublic:\n    unordered_map<int, vector<string>> umap;\n    \n    vector<string> helper(string &s, unordered_set<string> &dict, int pos) {\n        if (umap.find(pos) != umap.end())\n            return umap[pos];\n        \n        vector<string> res;\n\n        if (dict.find(s.substr(pos)) != dict.end())\n            res.push_back(s.substr(pos));\n        \n        for (int end = pos + 1; end < s.size(); ++end) {\n            string subs = s.substr(pos, end-pos);\n            if (dict.find(subs) != dict.end()) {\n                vector<string> nextlist = helper(s, dict, end);\n                for (auto list_string : nextlist) {\n                    res.push_back(subs + \" \" + list_string);\n                }\n            }\n        }\n        umap[pos] = res;\n        return umap[pos];\n    } \n    \n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\n        return helper(s, dict, 0);\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    unordered_map<int, vector<string>> umap;\n    \n    vector<string> helper(string &s, unordered_set<string> &dict, int pos) {\n        if (umap.find(pos) != umap.end())\n            return umap[pos];\n        \n        vector<string> res;\n\n        if (dict.find(s.substr(pos)) != dict.end())\n            res.push_back(s.substr(pos));\n        \n        for (int end = pos + 1; end < s.size(); ++end) {\n            string subs = s.substr(pos, end-pos);\n            if (dict.find(subs) != dict.end()) {\n                vector<string> nextlist = helper(s, dict, end);\n                for (auto list_string : nextlist) {\n                    res.push_back(subs + \" \" + list_string);\n                }\n            }\n        }\n        umap[pos] = res;\n        return umap[pos];\n    } \n    \n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\n        return helper(s, dict, 0);\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 116479,
                "title": "solution-using-bfs-idea-from-word-break-i",
                "content": "  This solution is inspired by BFS from Word Break I. Exact same code, just modifying a little bit. First,\tget rid of `visited[]` array. Second, and another queue, this queue will go along with the index queue to store the substrings level by level of the tree.\n\n\tpublic List<String> wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet = new HashSet(wordDict);\n        Queue<Integer> queue = new LinkedList<>();        \n        Queue<String> queueStr = new LinkedList<>();\n        List<String> list = new ArrayList<>();        \n        \n        queue.add(0);\n        queueStr.offer(\"\");\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String currentStr = queueStr.poll();\n                int start = queue.poll();          \n                for (int end = start + 1; end <= s.length(); end++) {\n                    String subStr = s.substring(start, end);\n                    if (wordDictSet.contains(subStr)) {\n                        String newStr = currentStr + subStr;\n                        if (end == s.length())\n                            list.add(newStr);\n                        else {\n                            queueStr.add(newStr + \" \");\n                            queue.add(end);\n                        }\n                    }\n                }\n            }\n        }                                        \n        return list;            \n    }",
                "solutionTags": [],
                "code": "\tpublic List<String> wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet = new HashSet(wordDict);\n        Queue<Integer> queue = new LinkedList<>();        \n        Queue<String> queueStr = new LinkedList<>();\n        List<String> list = new ArrayList<>();        \n        queue.add(0);\n        queueStr.offer(\"\");\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String currentStr = queueStr.poll();\n                int start = queue.poll();          \n                for (int end = start + 1; end <= s.length(); end++) {\n                    String subStr = s.substring(start, end);\n                    if (wordDictSet.contains(subStr)) {\n                        String newStr = currentStr + subStr;\n                        if (end == s.length())\n                            list.add(newStr);\n                        else {\n                            queueStr.add(newStr + \" \");\n                            queue.add(end);\n                        }\n                    }\n                }\n            }\n        }                                        \n        return list;            \n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44301,
                "title": "c-12ms-dp-solution",
                "content": "The flag can be used to save repetitive examinations of of bad substrs.\\n\\n    class Solution {\\n    public:\\n    void helper(vector<bool>& flag, string s, int n, string pre, vector<string> &res, unordered_set<string>& wordDict){\\n        if (n>=s.size()) {res.push_back(pre);return;}\\n        for (int i=n;i<s.size();i++){\\n            if (flag[i+1] && wordDict.find(s.substr(n,i-n+1))!=wordDict.end()){\\n                helper(flag,s,i+1,pre+s.substr(n,i-n+1)+\" \",res,wordDict);\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        vector<string> res;\\n        if (s.empty()) {res.push_back(\"\");return res;}\\n        int k=s.size();\\n        vector<bool> flag(k+1,0);\\n        flag[k] = 1;\\n        for (int i=k-1;i>=0;i--){\\n            int j=i;\\n            while(j<=k-1){\\n                if (flag[j+1] && wordDict.find(s.substr(i,j-i+1))!=wordDict.end()){\\n                    flag[i] = 1;break;\\n                }\\n                j++;\\n            }\\n        }\\n        if (flag[0]==0) return res;   // no possible solution if flag[0]==false\\n        helper(flag,s,0, \"\",res,wordDict);\\n        for (auto &s:res){\\n            s.pop_back();\\n        }\\n        return res;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    void helper(vector<bool>& flag, string s, int n, string pre, vector<string> &res, unordered_set<string>& wordDict){\\n        if (n>=s.size()) {res.push_back(pre);return;}",
                "codeTag": "Java"
            },
            {
                "id": 44323,
                "title": "8-ms-c-solution-with-explanation-dp-no-recursion",
                "content": "This solution is a two-stage dynamic program.  First: we use the solution from the Word Break problem to find all the break points -- the positions where we might possibly insert a space.  The second dynamic program then builds up the actual solution by skipping through the break-points.\\n\\nNote: comments use python-like notation to indicate substrings.  That is: s[:i] is the substring of s from position 0 up to, but not including, position j.\\n\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        if (n == 0)\\n            return {};\\n            \\n        // First: identify the break points (and that there exists at least one way to break it).\\n        // D[i] = True if it is possible to break up s[:i] in at least one way.\\n        vector<bool> D(n+1, false);\\n        D[0] = true;\\n        for (int i=1; i <= n; i++) {\\n            for (int j=i-1; j >= 0 && D[i] == false; j--) {\\n                D[i] = D[j] && wordDict.find(s.substr(j, i-j)) != wordDict.end();\\n            }\\n        }\\n        \\n        if (!D[n])  // There is no solution.\\n            return {};\\n            \\n        // Find the i such that D[i] is true.\\n        // In given example: break_points = [0,3,4,7,10].\\n        vector<int> break_points;\\n        for (int i=0; i < D.size(); i++) {\\n            if (D[i]) {\\n                break_points.push_back(i);\\n            }\\n        }\\n        \\n        int m = break_points.size();\\n\\n        // Now find the solution based on the breakpoints.\\n        // E[i]: Set of all strings we can create using s[:break_points[i]].\\n        // In the example: E[0] = [\"\"], E[1] = [\"cat\"], E[2] = [\"cats\"], E[3] = [\"cats and\", cat sand\"]\\n        vector<vector<string>> E(m); \\n        E[0] = {\"\"};\\n        for (int i = 0; i < m; i++) {\\n            for (int j=i-1; j >=0; j--) {  // Will now compute E\\n                // t is the string defined from breakpoints i to j\\n                string t = s.substr(break_points[j], break_points[i] - break_points[j]);  \\n                if (wordDict.find(t) != wordDict.end()) {\\n                    for (auto& u : E[j]) \\n                        E[i].push_back(u + \" \" + t);\\n                }\\n            }\\n        }\\n        \\n        // Need to chop off the extra \" \" at the start of each string in E[m-1]\\n        vector<string> R;\\n        transform(E[m-1].begin(), E[m-1].end(), back_inserter(R), [](string& s) {return s.substr(1,s.size()-1);});\\n        return R;\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "This solution is a two-stage dynamic program.  First: we use the solution from the Word Break problem to find all the break points -- the positions where we might possibly insert a space.  The second dynamic program then builds up the actual solution by skipping through the break-points.\\n\\nNote: comments use python-like notation to indicate substrings.  That is: s[:i] is the substring of s from position 0 up to, but not including, position j.\\n\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        if (n == 0)\\n            return {};\\n            \\n        // First: identify the break points (and that there exists at least one way to break it).\\n        // D[i] = True if it is possible to break up s[:i] in at least one way.\\n        vector<bool> D(n+1, false);\\n        D[0] = true;\\n        for (int i=1; i <= n; i++) {\\n            for (int j=i-1; j >= 0 && D[i] == false; j--) {\\n                D[i] = D[j] && wordDict.find(s.substr(j, i-j)) != wordDict.end();\\n            }\\n        }\\n        \\n        if (!D[n])  // There is no solution.\\n            return {};\\n            \\n        // Find the i such that D[i] is true.\\n        // In given example: break_points = [0,3,4,7,10].\\n        vector<int> break_points;\\n        for (int i=0; i < D.size(); i++) {\\n            if (D[i]) {\\n                break_points.push_back(i);\\n            }\\n        }\\n        \\n        int m = break_points.size();\\n\\n        // Now find the solution based on the breakpoints.\\n        // E[i]: Set of all strings we can create using s[:break_points[i]].\\n        // In the example: E[0] = [\"\"], E[1] = [\"cat\"], E[2] = [\"cats\"], E[3] = [\"cats and\", cat sand\"]\\n        vector<vector<string>> E(m); \\n        E[0] = {\"\"};\\n        for (int i = 0; i < m; i++) {\\n            for (int j=i-1; j >=0; j--) {  // Will now compute E\\n                // t is the string defined from breakpoints i to j\\n                string t = s.substr(break_points[j], break_points[i] - break_points[j]);  \\n                if (wordDict.find(t) != wordDict.end()) {\\n                    for (auto& u : E[j]) \\n                        E[i].push_back(u + \" \" + t);\\n                }\\n            }\\n        }\\n        \\n        // Need to chop off the extra \" \" at the start of each string in E[m-1]\\n        vector<string> R;\\n        transform(E[m-1].begin(), E[m-1].end(), back_inserter(R), [](string& s) {return s.substr(1,s.size()-1);});\\n        return R;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44321,
                "title": "16ms-java-dp-dfs-solution",
                "content": "    public class Solution {\\n        List<String> result;\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            result = new ArrayList<String>();\\n            int n = s.length();\\n            List<Integer>[] pointer = new List[n];\\n            for(int i=0;i<n;i++) pointer[i]=new ArrayList<Integer>();\\n            //DP to record break point\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(wordDict.contains(s.substring(j,i+1))&&(j==0||pointer[j-1].size()>0))\\n                        pointer[i].add(j);\\n                }\\n            }\\n            helper(pointer, s, n-1, \"\");\\n            return result;\\n        }\\n        //DFS to retrieve results\\n        public void helper(List<Integer>[] pointer, String s, int i, String pattern){\\n            if(i<0){\\n                result.add(pattern);\\n                return;\\n            }\\n            for(Integer item:pointer[i]){\\n                String nextPattern = pattern.length()==0?s.substring(item,i+1):s.substring(item,i+1)+\" \"+pattern;\\n                helper(pointer, s, item-1, nextPattern);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        List<String> result;\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            result = new ArrayList<String>();\\n            int n = s.length();\\n            List<Integer>[] pointer = new List[n];\\n            for(int i=0;i<n;i++) pointer[i]=new ArrayList<Integer>();\\n            //DP to record break point\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(wordDict.contains(s.substring(j,i+1))&&(j==0||pointer[j-1].size()>0))\\n                        pointer[i].add(j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 44386,
                "title": "my-concise-c-solution",
                "content": "It seems we have to have another round of getting result after the DP search (to not exceed memory limit). Here I inserted spaces to the original string instead of constructing strings.\\n\\n    vector<string> wordBreak(string s, unordered_set<string> &dict)\\n    {\\n    \\tvector<vector<int>> flag(s.size() + 1, vector<int>());\\n    \\tflag[0].push_back(0);\\n    \\tfor (int i = 1; i <= s.size(); i++)\\n    \\t{\\n    \\t\\tfor (int j = 0; j < i; j++)\\n    \\t\\t{\\n    \\t\\t\\tif (!flag[j].empty() && dict.find(s.substr(j, i - j)) != dict.end())\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tflag[i].push_back(j);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\tvector<string> result;\\n    \\tgetResult(result, flag, s, s.size());\\n    \\treturn result;\\n    }\\n    \\n    void getResult(vector<string> &result, vector<vector<int>> &flag, string s, int n)\\n    {\\n    \\tfor (int i : flag[n])\\n    \\t{\\n    \\t\\tif (i == 0)\\n    \\t\\t{\\n    \\t\\t\\tresult.push_back(s);\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\ts.insert(s.begin() + i, ' ');\\n    \\t\\tgetResult(result, flag, s, i);\\n    \\t\\ts.erase(i, 1);\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "It seems we have to have another round of getting result after the DP search (to not exceed memory limit). Here I inserted spaces to the original string instead of constructing strings.\\n\\n    vector<string> wordBreak(string s, unordered_set<string> &dict)\\n    {\\n    \\tvector<vector<int>> flag(s.size() + 1, vector<int>());\\n    \\tflag[0].push_back(0);\\n    \\tfor (int i = 1; i <= s.size(); i++)\\n    \\t{\\n    \\t\\tfor (int j = 0; j < i; j++)\\n    \\t\\t{\\n    \\t\\t\\tif (!flag[j].empty() && dict.find(s.substr(j, i - j)) != dict.end())\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tflag[i].push_back(j);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\tvector<string> result;\\n    \\tgetResult(result, flag, s, s.size());\\n    \\treturn result;\\n    }\\n    \\n    void getResult(vector<string> &result, vector<vector<int>> &flag, string s, int n)\\n    {\\n    \\tfor (int i : flag[n])\\n    \\t{\\n    \\t\\tif (i == 0)\\n    \\t\\t{\\n    \\t\\t\\tresult.push_back(s);\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\ts.insert(s.begin() + i, ' ');\\n    \\t\\tgetResult(result, flag, s, i);\\n    \\t\\ts.erase(i, 1);\\n    \\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44428,
                "title": "my-solution-using-python",
                "content": "I used a *Trie* to store all the dict words, and then for every position *i* in s, find those position(s) *ed* so that [st, ed) is a dict word. \\n\\nAfter that is basiclly a search problem, simply using dfs (or you can call it memorized search) to check  whether from position *i* we can divide s[i:] with dict words.(say this array is called v, and v[i] = True if s[i:] is dividable.\\n\\nIf v[0] is True, then find all the solutions using recurse.\\n\\nHere is my code using Python.\\n\\n\\n    class Node:\\n    \\tdef __init__(self):\\n    \\t\\tself.next = [ None for i in range(26) ]\\n    \\t\\tself.mark = False\\n    \\n    class Solution:\\n    \\t# @param s, a string\\n    \\t# @param dict, a set of string\\n    \\t# @return a list of strings\\n    \\tdef insert(self, word):\\n    \\t\\tp = self.root\\n    \\t\\tfor s in word:\\n    \\t\\t\\tk = ord(s) - ord('a')\\n    \\t\\t\\tif p.next[k] == None:\\n    \\t\\t\\t\\tp.next[k] = Node()\\n    \\t\\t\\tp = p.next[k]\\n    \\t\\tp.mark = True\\n    \\n    \\tdef build(self, s, st):\\n    \\t\\tn = len(s)\\n    \\t\\tp = self.root\\n    \\t\\tfor i in range(st, n):\\n    \\t\\t\\tif p == None:\\n    \\t\\t\\t\\treturn \\n    \\t\\t\\tk = ord(s[i]) - ord('a')\\n    \\t\\t\\tif p.next[k] == None:\\n    \\t\\t\\t\\treturn\\n    \\t\\t\\tp = p.next[k]\\n    \\t\\t\\tif p.mark:\\n    \\t\\t\\t\\tself.g[st].append(i + 1)    # [st, i + 1) is a word in dict\\n    \\tdef path(self, st):\\n    \\t\\tif st == self.n:\\n    \\t\\t\\tself.v[st] = 1\\n    \\t\\t\\treturn 1\\n    \\t\\tif self.v[st] != -1:\\n    \\t\\t\\treturn self.v[st]\\n    \\t\\tfor ed in self.g[st]:\\n    \\t\\t\\tif self.path(ed):\\n    \\t\\t\\t\\tself.v[st] = 1\\n    \\t\\tif self.v[st] == -1:\\n    \\t\\t\\tself.v[st] = 0\\n    \\t\\treturn self.v[st]\\n    \\n    \\tdef get(self, st):\\n    \\t\\tif st == self.n:\\n    \\t\\t\\treturn []\\n    \\t\\tres = []\\n    \\t\\tfor ed in self.g[st]:\\n    \\t\\t\\tif self.v[ed] == 1:\\n    \\t\\t\\t\\ttmp = self.get(ed)\\n    \\t\\t\\t\\tss = self.s[st:ed]\\n    \\t\\t\\t\\tfor sp in tmp:\\n    \\t\\t\\t\\t\\tres.append(ss + ' ' + sp)\\n    \\t\\t\\t\\tif tmp == []:\\n    \\t\\t\\t\\t\\tres.append(ss)\\n    \\t\\treturn res\\n    \\n    \\tdef wordBreak(self, s, dict):\\n    \\t\\tn = len(s)\\n    \\t\\tself.root = Node()\\n    \\t\\tself.n = n\\n    \\t\\tself.s = s\\n    \\t\\t#self.dict = dict\\n    \\t\\tself.g = [ [] for i in range(n + 1) ]\\n    \\t\\tself.v = [ -1 for i in range(n + 1) ]\\n    \\t\\tfor word in dict:\\n    \\t\\t\\tself.insert(word)\\n    \\t\\tfor i in range(n):\\n    \\t\\t\\tself.build(s, i)\\n    \\t\\tok = self.path(0)\\n    \\t\\tret = []\\n    \\t\\tif ok == 1:\\n    \\t\\t\\tret = self.get(0)\\n    \\t\\treturn ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "I used a *Trie* to store all the dict words, and then for every position *i* in s, find those position(s) *ed* so that [st, ed) is a dict word. \\n\\nAfter that is basiclly a search problem, simply using dfs (or you can call it memorized search) to check  whether from position *i* we can divide s[i:] with dict words.(say this array is called v, and v[i] = True if s[i:] is dividable.\\n\\nIf v[0] is True, then find all the solutions using recurse.\\n\\nHere is my code using Python.\\n\\n\\n    class Node:\\n    \\tdef __init__(self):\\n    \\t\\tself.next = [ None for i in range(26) ]\\n    \\t\\tself.mark = False\\n    \\n    class Solution:\\n    \\t# @param s, a string\\n    \\t# @param dict, a set of string\\n    \\t# @return a list of strings\\n    \\tdef insert(self, word):\\n    \\t\\tp = self.root\\n    \\t\\tfor s in word:\\n    \\t\\t\\tk = ord(s) - ord('a')\\n    \\t\\t\\tif p.next[k] == None:\\n    \\t\\t\\t\\tp.next[k] = Node()\\n    \\t\\t\\tp = p.next[k]\\n    \\t\\tp.mark = True\\n    \\n    \\tdef build(self, s, st):\\n    \\t\\tn = len(s)\\n    \\t\\tp = self.root\\n    \\t\\tfor i in range(st, n):\\n    \\t\\t\\tif p == None:\\n    \\t\\t\\t\\treturn \\n    \\t\\t\\tk = ord(s[i]) - ord('a')\\n    \\t\\t\\tif p.next[k] == None:\\n    \\t\\t\\t\\treturn\\n    \\t\\t\\tp = p.next[k]\\n    \\t\\t\\tif p.mark:\\n    \\t\\t\\t\\tself.g[st].append(i + 1)    # [st, i + 1) is a word in dict\\n    \\tdef path(self, st):\\n    \\t\\tif st == self.n:\\n    \\t\\t\\tself.v[st] = 1\\n    \\t\\t\\treturn 1\\n    \\t\\tif self.v[st] != -1:\\n    \\t\\t\\treturn self.v[st]\\n    \\t\\tfor ed in self.g[st]:\\n    \\t\\t\\tif self.path(ed):\\n    \\t\\t\\t\\tself.v[st] = 1\\n    \\t\\tif self.v[st] == -1:\\n    \\t\\t\\tself.v[st] = 0\\n    \\t\\treturn self.v[st]\\n    \\n    \\tdef get(self, st):\\n    \\t\\tif st == self.n:\\n    \\t\\t\\treturn []\\n    \\t\\tres = []\\n    \\t\\tfor ed in self.g[st]:\\n    \\t\\t\\tif self.v[ed] == 1:\\n    \\t\\t\\t\\ttmp = self.get(ed)\\n    \\t\\t\\t\\tss = self.s[st:ed]\\n    \\t\\t\\t\\tfor sp in tmp:\\n    \\t\\t\\t\\t\\tres.append(ss + ' ' + sp)\\n    \\t\\t\\t\\tif tmp == []:\\n    \\t\\t\\t\\t\\tres.append(ss)\\n    \\t\\treturn res\\n    \\n    \\tdef wordBreak(self, s, dict):\\n    \\t\\tn = len(s)\\n    \\t\\tself.root = Node()\\n    \\t\\tself.n = n\\n    \\t\\tself.s = s\\n    \\t\\t#self.dict = dict\\n    \\t\\tself.g = [ [] for i in range(n + 1) ]\\n    \\t\\tself.v = [ -1 for i in range(n + 1) ]\\n    \\t\\tfor word in dict:\\n    \\t\\t\\tself.insert(word)\\n    \\t\\tfor i in range(n):\\n    \\t\\t\\tself.build(s, i)\\n    \\t\\tok = self.path(0)\\n    \\t\\tret = []\\n    \\t\\tif ok == 1:\\n    \\t\\t\\tret = self.get(0)\\n    \\t\\treturn ret",
                "codeTag": "Java"
            },
            {
                "id": 3567048,
                "title": "brute-force-c-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvoid solve(int i,int &n,string s1,string s2,string &s,unordered_set<string> &st,vector<string> &ans){\\n    if(i>=n){\\n        cout<<s2<<\" \"<<s1<<endl;\\n        if(st.count(s1)){\\n            s2 += s1;\\n            ans.push_back(s2);\\n        }\\n        return;\\n    }\\n    string str = \"\";\\n    if(st.count(s1)){\\n        solve(i+1,n,str+s[i],s2+s1+\" \",s,st,ans);\\n    }\\n    solve(i+1,n,str+s1+s[i],s2,s,st,ans);\\n}\\n    vector<string> wordBreak(string str, vector<string>& wordDict) {\\n        unordered_set<string> s;\\n        for(auto &i: wordDict){\\n            s.insert(i);\\n        }\\n        vector<string> ans;\\n        int n = str.length();\\n        solve(0,n,\"\",\"\",str,s,ans);\\n        // for(auto &i: ans)i.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(int i,int &n,string s1,string s2,string &s,unordered_set<string> &st,vector<string> &ans){\\n    if(i>=n){\\n        cout<<s2<<\" \"<<s1<<endl;\\n        if(st.count(s1)){\\n            s2 += s1;\\n            ans.push_back(s2);\\n        }\\n        return;\\n    }\\n    string str = \"\";\\n    if(st.count(s1)){\\n        solve(i+1,n,str+s[i],s2+s1+\" \",s,st,ans);\\n    }\\n    solve(i+1,n,str+s1+s[i],s2,s,st,ans);\\n}\\n    vector<string> wordBreak(string str, vector<string>& wordDict) {\\n        unordered_set<string> s;\\n        for(auto &i: wordDict){\\n            s.insert(i);\\n        }\\n        vector<string> ans;\\n        int n = str.length();\\n        solve(0,n,\"\",\"\",str,s,ans);\\n        // for(auto &i: ans)i.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3000934,
                "title": "backtracking-5ms",
                "content": "# Intuition\\nThe phrase \"all possible solutions\" suggests a backtracking approach. Using DP doesn\\'t save time here. The reason that DP can reduce an exponential running time to polynomial running time is that it doesn\\'t requires explicit enumeration of all cases as long as we are certain we have the optimal value for each subproblem. The cases that aren\\'t optimal can be ignored in DP, but not in backtracking.\\n\\n# Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: $$O(2^n)$$. It\\'s proportional to the number of nodes in the recursion tree. And it\\'s the same as total number of ways to partition a string to all combinations of substrings.\\n\\n- Space complexity: $$O(n)$$. Only the StringBuilder requires extra memory.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> results = new LinkedList<>();\\n        StringBuilder tempHolder = new StringBuilder();\\n        findNextWord(results, tempHolder, s, wordDict, 0);\\n        return results;\\n    }\\n\\n    private void findNextWord(List<String> results, StringBuilder tempHolder, String s, List<String> wordDict, int start) {\\n        if (start == s.length()) {\\n            results.add(tempHolder.toString().trim());\\n            return;\\n        }\\n\\n        for (int end = start; end < s.length(); end++) {\\n            String word = s.substring(start, end + 1);\\n            if (wordDict.contains(word)) {\\n                tempHolder.append(word + \" \");\\n                findNextWord(results, tempHolder, s, wordDict, end + 1);\\n                tempHolder.delete(tempHolder.length() - word.length() - 1, tempHolder.length());\\n            }\\n        }\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> results = new LinkedList<>();\\n        StringBuilder tempHolder = new StringBuilder();\\n        findNextWord(results, tempHolder, s, wordDict, 0);\\n        return results;\\n    }\\n\\n    private void findNextWord(List<String> results, StringBuilder tempHolder, String s, List<String> wordDict, int start) {\\n        if (start == s.length()) {\\n            results.add(tempHolder.toString().trim());\\n            return;\\n        }\\n\\n        for (int end = start; end < s.length(); end++) {\\n            String word = s.substring(start, end + 1);\\n            if (wordDict.contains(word)) {\\n                tempHolder.append(word + \" \");\\n                findNextWord(results, tempHolder, s, wordDict, end + 1);\\n                tempHolder.delete(tempHolder.length() - word.length() - 1, tempHolder.length());\\n            }\\n        }\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987454,
                "title": "c-simple-recursive-approach-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(string s, unordered_set<string>& dict,int start, int index,string current,vector<string>& ans){\\n        if(start==s.size()){\\n            ans.push_back(current);\\n            return;\\n        }\\n        if(index==s.size()) return;\\n\\n        string sub=s.substr(start,index-start+1);\\n\\n        if(dict.count(sub)>0){\\n            string recursion;\\n            if(current.size()==0) recursion=sub;\\n            else recursion=current+\" \"+sub; \\n            helper(s,dict,index+1,index+1,recursion,ans);\\n        }\\n        helper(s,dict,start,index+1,current,ans);\\n        return;\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict;\\n        for(int i=0;i<wordDict.size();i++){\\n                dict.insert(wordDict[i]);\\n        }\\n        vector<string> ans;\\n        helper(s,dict,0,0,\"\",ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(string s, unordered_set<string>& dict,int start, int index,string current,vector<string>& ans){\\n        if(start==s.size()){\\n            ans.push_back(current);\\n            return;\\n        }\\n        if(index==s.size()) return;\\n\\n        string sub=s.substr(start,index-start+1);\\n\\n        if(dict.count(sub)>0){\\n            string recursion;\\n            if(current.size()==0) recursion=sub;\\n            else recursion=current+\" \"+sub; \\n            helper(s,dict,index+1,index+1,recursion,ans);\\n        }\\n        helper(s,dict,start,index+1,current,ans);\\n        return;\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict;\\n        for(int i=0;i<wordDict.size();i++){\\n                dict.insert(wordDict[i]);\\n        }\\n        vector<string> ans;\\n        helper(s,dict,0,0,\"\",ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778161,
                "title": "recursion-dp-always-does-the-job",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursive approach\\n# Complexity\\n- Time complexity:n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:high\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726138,
                "title": "easy-to-understand-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> st;\\n    void f(int ind,string str,string s,vector<string>& ans){\\n\\t\\n        if(ind==s.length()){\\n            ans.push_back(str);\\n            return ;\\n        }\\n\\t\\t\\n        string temp = \"\";                              //temporary string for finding string in dictionary from ind\\n\\t\\t\\n        for(int i=ind;i<s.length();i++){\\n            temp += s[i];\\n            if(st.count(temp)){\\n                string k = str;                         //By initialising str to k then we don\\'t need to do backtrack\\n                if(str.size()!=0) k += \" \";         // Edge Case \\n                k += temp;\\n                f(i+1,k,s,ans);\\n            }\\n        }\\n    }\\n\\t\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        for(auto i:wordDict) st.insert(i);\\n        int ind=0;\\n        vector<string> ans;\\n        string str = \"\";\\n        f(ind,str,s,ans);                  //Function Call\\n        return ans;\\n    }\\n};\\n```\\n\\n# ****PLease Upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> st;\\n    void f(int ind,string str,string s,vector<string>& ans){\\n\\t\\n        if(ind==s.length()){\\n            ans.push_back(str);\\n            return ;\\n        }\\n\\t\\t\\n        string temp = \"\";                              //temporary string for finding string in dictionary from ind\\n\\t\\t\\n        for(int i=ind;i<s.length();i++){\\n            temp += s[i];\\n            if(st.count(temp)){\\n                string k = str;                         //By initialising str to k then we don\\'t need to do backtrack\\n                if(str.size()!=0) k += \" \";         // Edge Case \\n                k += temp;\\n                f(i+1,k,s,ans);\\n            }\\n        }\\n    }\\n\\t\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        for(auto i:wordDict) st.insert(i);\\n        int ind=0;\\n        vector<string> ans;\\n        string str = \"\";\\n        f(ind,str,s,ans);                  //Function Call\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288246,
                "title": "diagram-explanation-dp-backtracking-trie-solution",
                "content": "## Code is at the bottom in C++\\nLets understand this with the first example. Consider making a trie to store words for relatively faster lookup.\\n![image](https://assets.leetcode.com/users/images/9ff5e4ec-6db6-40eb-ba09-3281696025b8_1657941546.7179804.png)\\nNow suppose we are at \\'d\\' of \"catsand\", are there possible breaks till here?\\n![image](https://assets.leetcode.com/users/images/85680f03-064a-42dd-8e41-01abaae1b129_1657941962.613613.png)\\nAll we need to store there is the indices of beginning of suffixes so that later on when we need to choose where to do the slicing, we have our index with us.\\nIntuitively enough, if there are no possible indexes that made a suffix to form the string, we can\\'t form any permutation. Now, onto the code.\\n```c++\\nstruct trie {\\n    trie *ch[26];\\n    bool isEnd;\\n    trie()\\n    {\\n        for(int i=0;i<26;i++) ch[i]=NULL;\\n        isEnd=false;\\n    }\\n};\\nvoid insert(trie *head,string &s)\\n{\\n    int n=s.length();\\n    trie *curr=head;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(!curr->ch[s[i]-\\'a\\']) curr->ch[s[i]-\\'a\\']=new trie();\\n        curr=curr->ch[s[i]-\\'a\\'];\\n    }\\n    curr->isEnd=true;\\n}\\nbool search(trie *head,string &str,int l,int r)\\n{\\n    trie *curr=head;\\n    for(int i=l;i<=r;i++)\\n    {\\n        if(!curr->ch[str[i]-\\'a\\']) return false;\\n        curr=curr->ch[str[i]-\\'a\\'];\\n    }\\n    return curr->isEnd;\\n}\\nclass Solution {\\npublic:\\n    void stringMaker(string &s,vector<string> &ans,vector<vector<int>> &index,int ind,string buff)\\n    {\\n        if(ind==-1)\\n        {\\n            buff.pop_back();\\n            reverse(buff.begin(),buff.end());\\n            ans.push_back(buff);\\n            return;\\n        }\\n        \\n        for(auto i:index[ind])\\n        {\\n            string temp=\"\";\\n            for(int j=ind;j>=i;j--)\\n            {\\n                temp+=s[j];\\n            }\\n            stringMaker(s,ans,index,i-1,buff+temp+\" \");\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        trie *head=new trie();\\n        for(string &s:wordDict) insert(head,s);\\n        int n=s.length();\\n        //possible to make this by slicing [..]  [i....j]\\n        //just before index i. If i=0, there was no space\\n        vector<vector<int>> dp(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(search(head,s,0,i)) dp[i].push_back(0);\\n            for(int j=1;j<=i;j++)\\n            {\\n                if(dp[j-1].size() && search(head,s,j,i))\\n                    dp[i].push_back(j);\\n            }\\n        }\\n        vector<string> ans;\\n        if(dp[n-1].size()==0) return ans;\\n        stringMaker(s,ans,dp,n-1,\"\");\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```c++\\nstruct trie {\\n    trie *ch[26];\\n    bool isEnd;\\n    trie()\\n    {\\n        for(int i=0;i<26;i++) ch[i]=NULL;\\n        isEnd=false;\\n    }\\n};\\nvoid insert(trie *head,string &s)\\n{\\n    int n=s.length();\\n    trie *curr=head;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(!curr->ch[s[i]-\\'a\\']) curr->ch[s[i]-\\'a\\']=new trie();\\n        curr=curr->ch[s[i]-\\'a\\'];\\n    }\\n    curr->isEnd=true;\\n}\\nbool search(trie *head,string &str,int l,int r)\\n{\\n    trie *curr=head;\\n    for(int i=l;i<=r;i++)\\n    {\\n        if(!curr->ch[str[i]-\\'a\\']) return false;\\n        curr=curr->ch[str[i]-\\'a\\'];\\n    }\\n    return curr->isEnd;\\n}\\nclass Solution {\\npublic:\\n    void stringMaker(string &s,vector<string> &ans,vector<vector<int>> &index,int ind,string buff)\\n    {\\n        if(ind==-1)\\n        {\\n            buff.pop_back();\\n            reverse(buff.begin(),buff.end());\\n            ans.push_back(buff);\\n            return;\\n        }\\n        \\n        for(auto i:index[ind])\\n        {\\n            string temp=\"\";\\n            for(int j=ind;j>=i;j--)\\n            {\\n                temp+=s[j];\\n            }\\n            stringMaker(s,ans,index,i-1,buff+temp+\" \");\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        trie *head=new trie();\\n        for(string &s:wordDict) insert(head,s);\\n        int n=s.length();\\n        //possible to make this by slicing [..]  [i....j]\\n        //just before index i. If i=0, there was no space\\n        vector<vector<int>> dp(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(search(head,s,0,i)) dp[i].push_back(0);\\n            for(int j=1;j<=i;j++)\\n            {\\n                if(dp[j-1].size() && search(head,s,j,i))\\n                    dp[i].push_back(j);\\n            }\\n        }\\n        vector<string> ans;\\n        if(dp[n-1].size()==0) return ans;\\n        stringMaker(s,ans,dp,n-1,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739705,
                "title": "solution-swift-word-break-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    private var memo: [String:[String]] = [:]\\n    private var words: [String] = []\\n    \\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var wChars: Set<Character> = []\\n        \\n        for w in wordDict { w.forEach { wChars.insert($0) } }\\n        \\n        self.words = wordDict\\n        \\n        guard Set<Character>(s).isSubset(of: wChars) else {\\n            return []\\n        }\\n        return dfs(s)\\n    }\\n    \\n    private func dfs(_ s: String) -> [String] {\\n        guard memo[s] == nil else { return memo[s]! }\\n        \\n        var arr: [String] = []\\n        \\n        guard !s.isEmpty else {\\n            arr.append(\"\")\\n            return arr\\n        }\\n        \\n        for w in words where s.hasPrefix(w) {\\n            let subList = dfs(String(s[s.index(s.startIndex, offsetBy: w.count)...]))\\n            for s in subList { arr.append(w + (s.isEmpty ? \"\" : \" \") + s) }\\n        }\\n        memo[s] = arr\\n        return arr\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.029 (0.031) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.wordBreak(\"catsanddog\", [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"])\\n        XCTAssertEqual(value.sorted(), [\"cats and dog\",\"cat sand dog\"].sorted())\\n    }\\n    \\n    // Note that you are allowed to reuse a dictionary word.\\n    func test1() {\\n        let value = solution.wordBreak(\"pineapplepenapple\", [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"])\\n        XCTAssertEqual(value.sorted(), [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"].sorted())\\n    }\\n    \\n    func test2() {\\n        let value = solution.wordBreak(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\\n        XCTAssertEqual(value, [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    private var memo: [String:[String]] = [:]\\n    private var words: [String] = []\\n    \\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var wChars: Set<Character> = []\\n        \\n        for w in wordDict { w.forEach { wChars.insert($0) } }\\n        \\n        self.words = wordDict\\n        \\n        guard Set<Character>(s).isSubset(of: wChars) else {\\n            return []\\n        }\\n        return dfs(s)\\n    }\\n    \\n    private func dfs(_ s: String) -> [String] {\\n        guard memo[s] == nil else { return memo[s]! }\\n        \\n        var arr: [String] = []\\n        \\n        guard !s.isEmpty else {\\n            arr.append(\"\")\\n            return arr\\n        }\\n        \\n        for w in words where s.hasPrefix(w) {\\n            let subList = dfs(String(s[s.index(s.startIndex, offsetBy: w.count)...]))\\n            for s in subList { arr.append(w + (s.isEmpty ? \"\" : \" \") + s) }\\n        }\\n        memo[s] = arr\\n        return arr\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.wordBreak(\"catsanddog\", [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"])\\n        XCTAssertEqual(value.sorted(), [\"cats and dog\",\"cat sand dog\"].sorted())\\n    }\\n    \\n    // Note that you are allowed to reuse a dictionary word.\\n    func test1() {\\n        let value = solution.wordBreak(\"pineapplepenapple\", [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"])\\n        XCTAssertEqual(value.sorted(), [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"].sorted())\\n    }\\n    \\n    func test2() {\\n        let value = solution.wordBreak(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\\n        XCTAssertEqual(value, [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426014,
                "title": "python-interview-friendly-simple-recursion",
                "content": "Not the best or the fastest, but definitely more interview friendly version. Good old recursion. \\n\\nSplit the string at all indexes. Then basically there is always two parts - the first part (word) and rest of the string. If word is in the wordDict, take the second part, and do the same thing until there is no string left. At that point, simply join the path with space and append to the output. \\n\\nConvert wordDict to hashset for O(1) lookup time. \\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        def recur(s, path):\\n            if not s:\\n                out.append(\\' \\'.join(path))\\n                return\\n            for i in range(1,len(s)+1):\\n                w,new_s = s[:i], s[i:]\\n                if w in wordDict:\\n                    recur(new_s, path + [w])\\n        wordDict, out = set(wordDict), []\\n        recur(s,[])\\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        def recur(s, path):\\n            if not s:\\n                out.append(\\' \\'.join(path))\\n                return\\n            for i in range(1,len(s)+1):\\n                w,new_s = s[:i], s[i:]\\n                if w in wordDict:\\n                    recur(new_s, path + [w])\\n        wordDict, out = set(wordDict), []\\n        recur(s,[])\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325635,
                "title": "trie-dfs-java",
                "content": "```\\nclass Solution {\\n    \\n    Trie root = new Trie();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        for(String word : wordDict) {\\n            addWord(word, root);\\n        }\\n        List<String> res = new ArrayList<>();\\n        List<String> current = new ArrayList<>();\\n        dfs(s, 0, root, current, res);\\n        return res;\\n    }\\n    private void dfs(String s, int index, Trie node, List<String> current, List<String> res) {\\n        if(index == s.length()) {\\n            if(node == root) {\\n                res.add(String.join(\" \", current));\\n            }\\n            return;\\n        }\\n        if(node == null) return;//invalid\\n        Trie trie = node.next[s.charAt(index) - \\'a\\'];\\n        if(trie != null && trie.isWord) {\\n            current.add(trie.word);\\n            dfs(s, index + 1, root, current, res);\\n            current.remove(current.size() - 1);\\n        }\\n        dfs(s, index + 1, trie, current, res);\\n    }\\n    private void addWord(String word, Trie dic) {\\n        Trie ptr = root;\\n        for(int i = 0; i < word.length(); ++i) {\\n            int idx = word.charAt(i) - \\'a\\';\\n            if(ptr.next[idx] == null) ptr.next[idx] = new Trie();\\n            ptr = ptr.next[idx];\\n        }\\n        ptr.isWord = true;\\n        ptr.word = word;\\n    }\\n    \\n    class Trie {\\n        boolean isWord;\\n        String word;\\n        Trie[] next;\\n        Trie() {\\n            next = new Trie[26];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Trie root = new Trie();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        for(String word : wordDict) {\\n            addWord(word, root);\\n        }\\n        List<String> res = new ArrayList<>();\\n        List<String> current = new ArrayList<>();\\n        dfs(s, 0, root, current, res);\\n        return res;\\n    }\\n    private void dfs(String s, int index, Trie node, List<String> current, List<String> res) {\\n        if(index == s.length()) {\\n            if(node == root) {\\n                res.add(String.join(\" \", current));\\n            }\\n            return;\\n        }\\n        if(node == null) return;//invalid\\n        Trie trie = node.next[s.charAt(index) - \\'a\\'];\\n        if(trie != null && trie.isWord) {\\n            current.add(trie.word);\\n            dfs(s, index + 1, root, current, res);\\n            current.remove(current.size() - 1);\\n        }\\n        dfs(s, index + 1, trie, current, res);\\n    }\\n    private void addWord(String word, Trie dic) {\\n        Trie ptr = root;\\n        for(int i = 0; i < word.length(); ++i) {\\n            int idx = word.charAt(i) - \\'a\\';\\n            if(ptr.next[idx] == null) ptr.next[idx] = new Trie();\\n            ptr = ptr.next[idx];\\n        }\\n        ptr.isWord = true;\\n        ptr.word = word;\\n    }\\n    \\n    class Trie {\\n        boolean isWord;\\n        String word;\\n        Trie[] next;\\n        Trie() {\\n            next = new Trie[26];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325222,
                "title": "simple-backtracking-solution",
                "content": "1. create a set for constant time O(1) lookup\\n2. iterate over string to expand the substring. \\n3. if a substring appears within `wordDict` \\n\\t3.1 we will explore this permutation by adding the substring to the path and backtracking on the remainder of the string\\n\\t3.2 if all the characters in the string are used up (`s.length === 0`) that means we have a valid permutation, so add it to the results\\n4. after the base case is reached (`s.length === 0` or no substrings found in `wordDict` remove the prior substring from `path` and continue expanding the current substring\\n\\ntime complexity: `O(n^2)` where `n` is the length of the string `s`\\n- for each recursive backtracking call we iterate through the remaining string. the `substring()` and `slice()` methods are linear operations `O(n)` in themselves, so it seems this may degrade to `O(n^3)`, thoughts? \\n\\nspace complexity: `O(n + m)` where `n` is the length of string `s` and `m` is the amount of words in `wordDict`\\n\\n```\\nconst backtrack = (s, words, path, result) => {\\n    if (s.length === 0) {\\n        result.push(path.join(\\' \\'))\\n        return\\n    }\\n    for (let i = 1; i <= s.length; i++) {\\n        const substring = s.substring(0, i)\\n        if (words.has(substring)) {\\n            path.push(substring)\\n            backtrack(s.slice(i), words, path, result)\\n            path.pop()\\n        }\\n    }\\n}\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {string[]}\\n */\\nconst wordBreak = (s, wordDict) => {\\n    const result = []\\n    const words = new Set(wordDict)\\n    backtrack(s, words, [], result)\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nconst backtrack = (s, words, path, result) => {\\n    if (s.length === 0) {\\n        result.push(path.join(\\' \\'))\\n        return\\n    }\\n    for (let i = 1; i <= s.length; i++) {\\n        const substring = s.substring(0, i)\\n        if (words.has(substring)) {\\n            path.push(substring)\\n            backtrack(s.slice(i), words, path, result)\\n            path.pop()\\n        }\\n    }\\n}\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {string[]}\\n */\\nconst wordBreak = (s, wordDict) => {\\n    const result = []\\n    const words = new Set(wordDict)\\n    backtrack(s, words, [], result)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1176760,
                "title": "0ms-c-easy-trie-solution",
                "content": "Scan given string char by char. If char exists in current trie node, \\n1) continue with next node. \\n``` find(s, i+1, r, temp->child[ch], root, sen + s[i]);```\\n2) additionally, if node is \"end node\", put a space and restart from the root node\\n``` find(s, i+1, r, root, root, sen + s[i] + \\' \\');```\\n\\nPlease check the code . You might find it easier to understand than my explanantion :P\\n\\n```\\nclass Solution {\\n    class TRIENODE{\\n    public:\\n        TRIENODE* child[26];\\n        bool isEnd;\\n        \\n        TRIENODE(){\\n          for(int i=0;i<26;i++){\\n              child[i] = 0;\\n          }\\n          isEnd = false;\\n        }\\n    };\\n    \\n    class TRIE{\\n    public:\\n        TRIENODE* root;\\n        \\n        TRIE(){\\n          root = new TRIENODE;\\n        }\\n        \\n        void insert(string s){\\n            TRIENODE* temp = root;\\n            for(auto ch:s){\\n                if(!temp->child[ch-\\'a\\']){\\n                    temp->child[ch-\\'a\\'] = new TRIENODE;\\n                }\\n                temp = temp->child[ch-\\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }    \\n    };\\n    \\n    vector<string> ans;\\n    \\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        TRIE* trie = new TRIE;\\n        for(auto s:wordDict){\\n            trie->insert(s);\\n        }\\n        \\n        find(s,0,s.size()-1,trie->root,trie->root,\"\");\\n        return ans;\\n    }\\n    \\n    void find(string s, int i, int r, TRIENODE* temp, TRIENODE* root,string sen){\\n        if(i>r){           \\n            if(temp->isEnd){\\n                ans.push_back(sen);                \\n            }\\n            return;\\n        }\\n        \\n        int ch = s[i]-\\'a\\';\\n        if(temp->child[ch]){\\n            find(s, i+1, r, temp->child[ch], root, sen + s[i]);            \\n            if(temp->child[ch]->isEnd){\\n                find(s, i+1, r, root, root, sen + s[i] + \\' \\');\\n            }            \\n        }\\n    }\\n};\\n```\\n\\nPS: This solution gives TLE for https://leetcode.com/problems/word-break/ where strings can be much longer.",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "``` find(s, i+1, r, temp->child[ch], root, sen + s[i]);```\n``` find(s, i+1, r, root, root, sen + s[i] + \\' \\');```\n```\\nclass Solution {\\n    class TRIENODE{\\n    public:\\n        TRIENODE* child[26];\\n        bool isEnd;\\n        \\n        TRIENODE(){\\n          for(int i=0;i<26;i++){\\n              child[i] = 0;\\n          }\\n          isEnd = false;\\n        }\\n    };\\n    \\n    class TRIE{\\n    public:\\n        TRIENODE* root;\\n        \\n        TRIE(){\\n          root = new TRIENODE;\\n        }\\n        \\n        void insert(string s){\\n            TRIENODE* temp = root;\\n            for(auto ch:s){\\n                if(!temp->child[ch-\\'a\\']){\\n                    temp->child[ch-\\'a\\'] = new TRIENODE;\\n                }\\n                temp = temp->child[ch-\\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }    \\n    };\\n    \\n    vector<string> ans;\\n    \\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        TRIE* trie = new TRIE;\\n        for(auto s:wordDict){\\n            trie->insert(s);\\n        }\\n        \\n        find(s,0,s.size()-1,trie->root,trie->root,\"\");\\n        return ans;\\n    }\\n    \\n    void find(string s, int i, int r, TRIENODE* temp, TRIENODE* root,string sen){\\n        if(i>r){           \\n            if(temp->isEnd){\\n                ans.push_back(sen);                \\n            }\\n            return;\\n        }\\n        \\n        int ch = s[i]-\\'a\\';\\n        if(temp->child[ch]){\\n            find(s, i+1, r, temp->child[ch], root, sen + s[i]);            \\n            if(temp->child[ch]->isEnd){\\n                find(s, i+1, r, root, root, sen + s[i] + \\' \\');\\n            }            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034185,
                "title": "very-easy-backtracking-solution",
                "content": "public class Solution {\\n\\n    List<String> answer = new ArrayList();\\n    \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n\\t    \\n        Set<String> set = new HashSet<>(wordDict);\\n        \\n        backtrack(s, \"\", answer, set);\\n        \\n        return answer;\\n    \\n    }\\n    \\n    public void backtrack(String s, String temp, List<String> answer, Set<String> set) {\\n        \\n        if(s.length()==0) {\\n            answer.add(temp);\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++) {\\n            \\n            String left = s.substring(0,i+1);\\n            \\n            if(set.contains(left)) {\\n                String right = s.substring(i+1);\\n                backtrack(right, temp + left + \" \", answer, set);\\n            }\\n        }\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    List<String> answer = new ArrayList();\\n    \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n\\t    \\n        Set<String> set = new HashSet<>(wordDict);\\n        \\n        backtrack(s, \"\", answer, set);\\n        \\n        return answer;\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 908609,
                "title": "java-dsf-memo-5ms",
                "content": "Time complexity: O(n * 2^n) \\nSpace complexity: O(n * 2^n) \\n\\nHere a good explaination: \\nhttps://medium.com/@salonikaurone/leetcode-word-break-ii-explained-d41ecfbe8fc5#:~:text=because%20we%20have%20memoisation%2C%20we,of%20characters%20in%20the%20input\\n\\n```\\nclass Solution {\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        \\n        return dsf(s, 0, wordDict, new HashMap<>());\\n    }\\n    \\n    \\n    private List<String> dsf(String str, int startIndex, List<String> words, \\n                        Map<Integer, List<String>> map){\\n        \\n        if (map.containsKey(startIndex)) {\\n            return map.get(startIndex);\\n        }\\n        \\n        List<String> strs = new ArrayList<>();\\n        for (String word : words) {\\n            if (str.startsWith(word, startIndex)) {\\n                \\n                if (str.length() == startIndex + word.length()) {\\n                    strs.add(word);\\n                } else {\\n                    List<String> strings = dsf(str, startIndex + word.length(), words, map);\\n                    for (String ss : strings) {\\n                        strs.add(word + \" \" + ss);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        map.put(startIndex, strs);\\n        return map.get(startIndex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        \\n        return dsf(s, 0, wordDict, new HashMap<>());\\n    }\\n    \\n    \\n    private List<String> dsf(String str, int startIndex, List<String> words, \\n                        Map<Integer, List<String>> map){\\n        \\n        if (map.containsKey(startIndex)) {\\n            return map.get(startIndex);\\n        }\\n        \\n        List<String> strs = new ArrayList<>();\\n        for (String word : words) {\\n            if (str.startsWith(word, startIndex)) {\\n                \\n                if (str.length() == startIndex + word.length()) {\\n                    strs.add(word);\\n                } else {\\n                    List<String> strings = dsf(str, startIndex + word.length(), words, map);\\n                    for (String ss : strings) {\\n                        strs.add(word + \" \" + ss);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        map.put(startIndex, strs);\\n        return map.get(startIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809872,
                "title": "c-memoization-solution-fast-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>> vis;\\n    vector<string> merge(string s, vector<string> vec){\\n        vector<string> ret;\\n        for(string i:vec) ret.push_back(s+\" \"+i);\\n        return ret;\\n    }\\n    vector<string> dfs(string s, unordered_set<string>& wordDict){\\n        vector<string> res;\\n        if(vis.count(s)) return vis[s];\\n        if(wordDict.count(s)) res.push_back(s);\\n        for(int i=1;i<=s.size();++i){\\n            string cur = s.substr(0,i);\\n            if(wordDict.count(cur)){\\n                vector<string> vec = merge(cur,dfs(s.substr(i),wordDict));\\n                res.insert(res.end(),vec.begin(),vec.end());\\n            }\\n        }\\n        vis[s] = res;\\n        return res;\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDic) {\\n        unordered_set<string> wordDict(wordDic.begin(),wordDic.end());\\n        return dfs(s,wordDict);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>> vis;\\n    vector<string> merge(string s, vector<string> vec){\\n        vector<string> ret;\\n        for(string i:vec) ret.push_back(s+\" \"+i);\\n        return ret;\\n    }\\n    vector<string> dfs(string s, unordered_set<string>& wordDict){\\n        vector<string> res;\\n        if(vis.count(s)) return vis[s];\\n        if(wordDict.count(s)) res.push_back(s);\\n        for(int i=1;i<=s.size();++i){\\n            string cur = s.substr(0,i);\\n            if(wordDict.count(cur)){\\n                vector<string> vec = merge(cur,dfs(s.substr(i),wordDict));\\n                res.insert(res.end(),vec.begin(),vec.end());\\n            }\\n        }\\n        vis[s] = res;\\n        return res;\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDic) {\\n        unordered_set<string> wordDict(wordDic.begin(),wordDic.end());\\n        return dfs(s,wordDict);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763391,
                "title": "java-using-trie",
                "content": "```\\nclass Solution {\\n    private Tries root;\\n    private List<String> wordList;\\n    private char[] input;\\n    private Set<Character> lookup;\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        this.wordList = new LinkedList<>();\\n        if(s.length() == 0) \\n            return this.wordList;\\n        this.lookup = new HashSet<>();\\n        this.root = new Tries();\\n        this.input = s.toCharArray();\\n        for(String word : wordDict) {\\n            addWord(word.toCharArray());\\n        }\\n        if(isValid()) \\n            splitWord(new StringBuilder(), 0, root);\\n        return wordList;\\n    }\\n    \\n    private void splitWord(StringBuilder sb, int i, Tries cur) {\\n        if(i == input.length) {\\n            wordList.add(sb.toString());\\n            return;\\n        }\\n        // System.out.println(\"\\\\n\" + input[i]);\\n        if(sb.length() > 0) sb.append(\" \");\\n        while(i < input.length && cur != null) {\\n            // System.out.print(input[i] + \" > \");\\n            cur = cur.children.get(input[i]);\\n            sb.append(input[i]);\\n            if(cur != null && cur.end) {\\n                splitWord(new StringBuilder(sb), i + 1, root);\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    class Tries {\\n        Map<Character, Tries> children;\\n        boolean end;\\n        Tries() {\\n            children = new HashMap<>();\\n        }\\n    }\\n    \\n    private void addWord(char[] s) {\\n        Tries cur = root;\\n        for(int i = 0; i < s.length; i++) {\\n            this.lookup.add(s[i]);\\n            if(cur.children.containsKey(s[i]) == false) {\\n                cur.children.put(s[i], new Tries());\\n            }\\n            cur = cur.children.get(s[i]);\\n        }\\n        cur.end = true;\\n    } \\n    \\n    private boolean isValid() {\\n        for(int i = 0; i < input.length; i++) {\\n            if(lookup.contains(input[i])) continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    private Tries root;\\n    private List<String> wordList;\\n    private char[] input;\\n    private Set<Character> lookup;\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        this.wordList = new LinkedList<>();\\n        if(s.length() == 0) \\n            return this.wordList;\\n        this.lookup = new HashSet<>();\\n        this.root = new Tries();\\n        this.input = s.toCharArray();\\n        for(String word : wordDict) {\\n            addWord(word.toCharArray());\\n        }\\n        if(isValid()) \\n            splitWord(new StringBuilder(), 0, root);\\n        return wordList;\\n    }\\n    \\n    private void splitWord(StringBuilder sb, int i, Tries cur) {\\n        if(i == input.length) {\\n            wordList.add(sb.toString());\\n            return;\\n        }\\n        // System.out.println(\"\\\\n\" + input[i]);\\n        if(sb.length() > 0) sb.append(\" \");\\n        while(i < input.length && cur != null) {\\n            // System.out.print(input[i] + \" > \");\\n            cur = cur.children.get(input[i]);\\n            sb.append(input[i]);\\n            if(cur != null && cur.end) {\\n                splitWord(new StringBuilder(sb), i + 1, root);\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    class Tries {\\n        Map<Character, Tries> children;\\n        boolean end;\\n        Tries() {\\n            children = new HashMap<>();\\n        }\\n    }\\n    \\n    private void addWord(char[] s) {\\n        Tries cur = root;\\n        for(int i = 0; i < s.length; i++) {\\n            this.lookup.add(s[i]);\\n            if(cur.children.containsKey(s[i]) == false) {\\n                cur.children.put(s[i], new Tries());\\n            }\\n            cur = cur.children.get(s[i]);\\n        }\\n        cur.end = true;\\n    } \\n    \\n    private boolean isValid() {\\n        for(int i = 0; i < input.length; i++) {\\n            if(lookup.contains(input[i])) continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763261,
                "title": "python-sol-by-dfs-with-prefix-matching-w-comment",
                "content": "Python sol by DFS with prefix matching\\n\\n---\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        solution = []\\n        \\n        word_pool = set(wordDict)\\n        \\n        \\n        if set(s) > set(\\'\\'.join(wordDict)):\\n            \\n            # Quick response if it is impossible to make s\\n            return []        \\n        \\n        #----------------------------------------\\n        \\n        def helper(s, words):\\n            # find all possible generation of s from word pool in DFS\\n            \\n            if s == \"\":\\n                # base case also known as stop condition\\n                # s can be generated from word pool\\n                solution.append(\\' \\'.join(words))\\n                return\\n            \\n            \\n            for prefix in word_pool:\\n                # general case\\n                \\n                if len(prefix) > len(s):\\n                    \\n                    # Skip when prefix is longer than s\\n                    continue\\n                \\n                if s.startswith(prefix):\\n                    \\n                    # Keep finding in DFS\\n                    helper(s[len(prefix):], words[:] + [prefix])\\n                    \\n            return\\n        \\n        #----------------------------------------\\n        \\n        helper(s, words=[])\\n        \\n        return solution\\n```\\n\\n---\\n\\nShare another **Implemetation** by DFS with postfix matching\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        wordSet = set(wordDict)\\n        \\n        @cache\\n        def dp(s):\\n            \\n            ## Base case on empty string\\n            if not s:\\n                return []\\n            \\n            ## General case\\n            res = []\\n            \\n            # Type_1: Current s is in wordSet\\n            if s in wordSet:\\n                res.append( s ) \\n            \\n            # Type_2: Decompose s into smaller words in wordSet\\n            for k in range(1, len(s)):\\n                \\n                postfix = s[k:]\\n                if postfix not in wordSet: continue\\n                \\n                res += [ prefix + \" \" + postfix for prefix in dp(s[:k])]\\n            \\n            return res\\n        \\n        # ---------------------------------\\n        return dp( s )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        solution = []\\n        \\n        word_pool = set(wordDict)\\n        \\n        \\n        if set(s) > set(\\'\\'.join(wordDict)):\\n            \\n            # Quick response if it is impossible to make s\\n            return []        \\n        \\n        #----------------------------------------\\n        \\n        def helper(s, words):\\n            # find all possible generation of s from word pool in DFS\\n            \\n            if s == \"\":\\n                # base case also known as stop condition\\n                # s can be generated from word pool\\n                solution.append(\\' \\'.join(words))\\n                return\\n            \\n            \\n            for prefix in word_pool:\\n                # general case\\n                \\n                if len(prefix) > len(s):\\n                    \\n                    # Skip when prefix is longer than s\\n                    continue\\n                \\n                if s.startswith(prefix):\\n                    \\n                    # Keep finding in DFS\\n                    helper(s[len(prefix):], words[:] + [prefix])\\n                    \\n            return\\n        \\n        #----------------------------------------\\n        \\n        helper(s, words=[])\\n        \\n        return solution\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        wordSet = set(wordDict)\\n        \\n        @cache\\n        def dp(s):\\n            \\n            ## Base case on empty string\\n            if not s:\\n                return []\\n            \\n            ## General case\\n            res = []\\n            \\n            # Type_1: Current s is in wordSet\\n            if s in wordSet:\\n                res.append( s ) \\n            \\n            # Type_2: Decompose s into smaller words in wordSet\\n            for k in range(1, len(s)):\\n                \\n                postfix = s[k:]\\n                if postfix not in wordSet: continue\\n                \\n                res += [ prefix + \" \" + postfix for prefix in dp(s[:k])]\\n            \\n            return res\\n        \\n        # ---------------------------------\\n        return dp( s )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557592,
                "title": "javascript-accepted-solution",
                "content": "Runtime: 52 ms, faster than 99.23% of JavaScript online submissions for Word Break II.\\nMemory Usage: 37.2 MB, less than 100.00% of JavaScript online submissions for Word Break II.\\n\\n```\\nconst dfs = (s, set, memo) => {\\n    if (memo.has(s)) {\\n        return memo.get(s);\\n    }\\n    \\n    let i = 1;\\n    const result = [];\\n    \\n    while ( i < s.length + 1 ) {\\n        const thisWord = s.substring(0, i);\\n        \\n        if (set.has(thisWord)) {\\n            if (i === s.length) {\\n                result.push(thisWord);\\n                break;\\n            }\\n            \\n            const nextCombos = dfs(s.substring(i), set, memo);\\n            nextCombos.forEach(combo => {\\n                result.push(`${thisWord} ${combo}`);    \\n            })\\n        }\\n        \\n        i++;\\n    }\\n    \\n    memo.set(s, result);\\n    \\n    return result;\\n}\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {string[]}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    return dfs(s, new Set(wordDict), new Map);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst dfs = (s, set, memo) => {\\n    if (memo.has(s)) {\\n        return memo.get(s);\\n    }\\n    \\n    let i = 1;\\n    const result = [];\\n    \\n    while ( i < s.length + 1 ) {\\n        const thisWord = s.substring(0, i);\\n        \\n        if (set.has(thisWord)) {\\n            if (i === s.length) {\\n                result.push(thisWord);\\n                break;\\n            }\\n            \\n            const nextCombos = dfs(s.substring(i), set, memo);\\n            nextCombos.forEach(combo => {\\n                result.push(`${thisWord} ${combo}`);    \\n            })\\n        }\\n        \\n        i++;\\n    }\\n    \\n    memo.set(s, result);\\n    \\n    return result;\\n}\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {string[]}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    return dfs(s, new Set(wordDict), new Map);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 496272,
                "title": "dfs-trie-python",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def getRoot(self):\\n        return self.root\\n    \\n    def insertWord(self, word: str):\\n\\n        nextNode = self.root\\n        for c in word:\\n            if c not in nextNode.children:\\n                nextNode.children[c] = TrieNode()\\n            nextNode = nextNode.children[c]\\n        nextNode.isWord = True\\n\\nclass Solution:\\n    trieNode = None\\n    s = None\\n    memoize = None\\n    \\n    def checkConnection(self, prevNode, currentChar: chr) -> TrieNode:\\n        if currentChar in prevNode.children:\\n            return prevNode.children[currentChar]\\n        return None\\n\\n    def wordBreakHelper(self, index: int, node) -> List[List[str]]:\\n        \\n        if index in self.memoize:\\n            return self.memoize[index][:]\\n\\n        result = []\\n        current = []\\n        \\n        start = index\\n        while index < len(self.s):\\n            node = self.checkConnection(node, self.s[index])\\n            \\n            if node is None:\\n                break\\n            \\n            # valid path\\n            current.append(self.s[index])\\n\\n            if node.isWord:\\n                current_word = \\'\\'.join(current)\\n                \\n                if index+1 < len(self.s):\\n                    tempResult = self.wordBreakHelper(index+1, self.trieNode.getRoot())\\n\\n                    #print(tempResult, current_word)\\n                    for val in tempResult:\\n                        result.append([current_word] + val)\\n                else:\\n                    result.append([current_word])\\n\\n            index += 1\\n            \\n        self.memoize[start] = result\\n        return self.memoize[start][:]\\n\\n\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n\\n        self.trieNode = Trie()\\n        self.s = s\\n        self.memoize = {}\\n        # creating a Trie\\n        \\n        for s in wordDict:\\n            self.trieNode.insertWord(s)\\n        \\n        \\n        final_result = self.wordBreakHelper(0, self.trieNode.getRoot())\\n        \\n        \\n        #print(self.memoize)\\n        return [\\' \\'.join(word_list) for word_list in final_result]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def getRoot(self):\\n        return self.root\\n    \\n    def insertWord(self, word: str):\\n\\n        nextNode = self.root\\n        for c in word:\\n            if c not in nextNode.children:\\n                nextNode.children[c] = TrieNode()\\n            nextNode = nextNode.children[c]\\n        nextNode.isWord = True\\n\\nclass Solution:\\n    trieNode = None\\n    s = None\\n    memoize = None\\n    \\n    def checkConnection(self, prevNode, currentChar: chr) -> TrieNode:\\n        if currentChar in prevNode.children:\\n            return prevNode.children[currentChar]\\n        return None\\n\\n    def wordBreakHelper(self, index: int, node) -> List[List[str]]:\\n        \\n        if index in self.memoize:\\n            return self.memoize[index][:]\\n\\n        result = []\\n        current = []\\n        \\n        start = index\\n        while index < len(self.s):\\n            node = self.checkConnection(node, self.s[index])\\n            \\n            if node is None:\\n                break\\n            \\n            # valid path\\n            current.append(self.s[index])\\n\\n            if node.isWord:\\n                current_word = \\'\\'.join(current)\\n                \\n                if index+1 < len(self.s):\\n                    tempResult = self.wordBreakHelper(index+1, self.trieNode.getRoot())\\n\\n                    #print(tempResult, current_word)\\n                    for val in tempResult:\\n                        result.append([current_word] + val)\\n                else:\\n                    result.append([current_word])\\n\\n            index += 1\\n            \\n        self.memoize[start] = result\\n        return self.memoize[start][:]\\n\\n\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n\\n        self.trieNode = Trie()\\n        self.s = s\\n        self.memoize = {}\\n        # creating a Trie\\n        \\n        for s in wordDict:\\n            self.trieNode.insertWord(s)\\n        \\n        \\n        final_result = self.wordBreakHelper(0, self.trieNode.getRoot())\\n        \\n        \\n        #print(self.memoize)\\n        return [\\' \\'.join(word_list) for word_list in final_result]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424750,
                "title": "simplified-word-break-1-and-2-java-based-on-dp-one-dimensional-array-and-dfs",
                "content": "Idea is to use one dimensional DP array and keep updating it until we reach to the end. \\n\\nWord break 1: result is in the last index.\\nWord break 2: result will be built by dfs on dp array.\\n\\n**Word Break 1**\\n![image](https://assets.leetcode.com/users/tyr1on/image_1573326539.png)\\n\\n\\n```\\n\\tpublic static boolean wordBreak(String s, List<String> wordDict) {\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                String check = s.substring(j, i);\\n                if (dp[j] && wordDict.contains(check)) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```\\n\\n**Word Break 2**\\n![image](https://assets.leetcode.com/users/tyr1on/image_1573326566.png)\\n\\n\\n```\\n\\tpublic static List<String> wordBreakII(String word, List<String> dict) {\\n        if (null == word || word.isEmpty() ||\\n                null == dict || dict.isEmpty()) {\\n            return Collections.emptyList();\\n        }\\n\\n        // dp array\\n        List<String>[] dp = new ArrayList[word.length() + 1];\\n        dp[0] = new ArrayList<>();\\n\\n        for (int i = 1; i <= word.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                // form a word and check if it is in dict\\n                String check = word.substring(j, i);\\n                if (null != dp[j] && dict.contains(check)) {\\n                    if (null == dp[i]) {\\n                        dp[i] = new ArrayList<>();\\n                    }\\n                    dp[i].add(check);\\n                }\\n            }\\n        }\\n\\n        // if dictionary words cannot join to given word\\n        if (null == dp[word.length()]) {\\n            return Collections.emptyList();\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n        // start dfs from back\\n        dfs(dp, result, \"\", word.length());\\n        return result;\\n    }\\n\\n    // perform dfs from the end of the dp array to form the result list\\n    public static void dfs(List<String>[] dp, List<String> result, String current, int i) {\\n        if (i == 0) {\\n            result.add(current.trim());\\n            return;\\n        }\\n\\n        for (String s : dp[i]) {\\n            // append string to previous result\\n            String combined = s + \" \" + current;\\n            dfs(dp, result, combined, i - s.length());\\n        }\\n    }\\n```\\n\\nA lannister always pays his debt!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tpublic static boolean wordBreak(String s, List<String> wordDict) {\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                String check = s.substring(j, i);\\n                if (dp[j] && wordDict.contains(check)) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```\n```\\n\\tpublic static List<String> wordBreakII(String word, List<String> dict) {\\n        if (null == word || word.isEmpty() ||\\n                null == dict || dict.isEmpty()) {\\n            return Collections.emptyList();\\n        }\\n\\n        // dp array\\n        List<String>[] dp = new ArrayList[word.length() + 1];\\n        dp[0] = new ArrayList<>();\\n\\n        for (int i = 1; i <= word.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                // form a word and check if it is in dict\\n                String check = word.substring(j, i);\\n                if (null != dp[j] && dict.contains(check)) {\\n                    if (null == dp[i]) {\\n                        dp[i] = new ArrayList<>();\\n                    }\\n                    dp[i].add(check);\\n                }\\n            }\\n        }\\n\\n        // if dictionary words cannot join to given word\\n        if (null == dp[word.length()]) {\\n            return Collections.emptyList();\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n        // start dfs from back\\n        dfs(dp, result, \"\", word.length());\\n        return result;\\n    }\\n\\n    // perform dfs from the end of the dp array to form the result list\\n    public static void dfs(List<String>[] dp, List<String> result, String current, int i) {\\n        if (i == 0) {\\n            result.add(current.trim());\\n            return;\\n        }\\n\\n        for (String s : dp[i]) {\\n            // append string to previous result\\n            String combined = s + \" \" + current;\\n            dfs(dp, result, combined, i - s.length());\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327441,
                "title": "c-98-beaten-o-n-m-m-max-word-len-hot-stinger-solution",
                "content": "This seems to work. Basically just solving word-break-1, only continuing to explore the solution space even if we get a match. Use sets to make sure you aren\\'t exploring the same branch twice. Otherwise the program will be slow and you will have many duplicate answers for some test cases.\\n\\nIf you have done all the problems up to this point, you have have the tools to solve this. If you can\\'t then you are an idiot. Plain and simple. A simpleton who is no better than a vegetable. And you should be served on a plate to a race of feasting giants.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int mMaxLength;\\n    int mMinLength;\\n    unordered_set<string> mDictionary;\\n    vector<unordered_set<string>> mMatchSets;\\n    vector<string> mTemp;\\n    char *mAnsStr;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        \\n        vector<string> aResult;\\n        if (wordDict.size() <= 0) { return aResult; }\\n        \\n        for (int i=0;i<s.size();i++) {\\n            unordered_set<string> aSet;\\n            mMatchSets.push_back(aSet);\\n        }\\n        \\n        mAnsStr = new char[s.size() + s.size() + 2]; //some space to write to...\\n        \\n        mMaxLength = 0;\\n        mMinLength = -1;\\n        for (auto aWord : wordDict) {\\n            \\n            mDictionary.insert(aWord);\\n            if (aWord.size() > mMaxLength) {\\n                mMaxLength = aWord.size();\\n            }\\n            if (mMinLength == -1 || aWord.size() < mMinLength) {\\n                mMinLength = aWord.size();\\n            }\\n        }\\n        \\n        wordBreakExplorer(s, wordDict, s.size() - 1); //Find all the answers.\\n        wordBreakSolutionBuilder(aResult, s, 0); //Build all the solutions.\\n        \\n        return aResult;\\n    }\\n\\n    void wordBreakExplorer(string &pString, vector<string>& pDict, int pStart) {\\n        if (pStart < 0) { return; }\\n        \\n        int aInd1 = pStart - mMinLength + 1;\\n        int aInd2 = pStart - mMaxLength + 1;\\n        \\n        if (aInd1 < 0) { return; }\\n        if (aInd2 < 0) { aInd2 = 0; }\\n        \\n        int aLength = mMinLength;\\n        for (int i=aInd1;i>=aInd2;i--) {\\n            \\n            string aChunk = pString.substr(i, aLength);\\n            if (mMatchSets[i].count(aChunk) == 0) {\\n\\n                if (mDictionary.count(aChunk) > 0) {\\n                    mMatchSets[i].insert(aChunk);\\n                    wordBreakExplorer(pString, pDict, i - 1);\\n                }\\n            }\\n            aLength++;\\n        }\\n    }\\n    \\n    \\n    void wordBreakSolutionBuilder(vector<string> &pResult, string &pString, int pStart) {\\n        \\n        if (pStart == pString.size()) {\\n            //Turn the answer into a space-separated word.\\n            int aIndex = 0;\\n            for (auto aString : mTemp) {\\n                for (int i=0;i<aString.size();i++) {\\n                    mAnsStr[aIndex++] = aString[i]; \\n                }\\n                mAnsStr[aIndex++] = \\' \\';\\n            }\\n            mAnsStr[aIndex - 1] = 0;\\n            pResult.push_back(string(mAnsStr));\\n            return;\\n        }\\n        \\n        for (auto aWord : mMatchSets[pStart]) {\\n            //Crawl the solution space. Like a baby crawls for milk bottles.\\n            mTemp.push_back(aWord);\\n            wordBreakSolutionBuilder(pResult, pString, pStart + aWord.size());   \\n            mTemp.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mMaxLength;\\n    int mMinLength;\\n    unordered_set<string> mDictionary;\\n    vector<unordered_set<string>> mMatchSets;\\n    vector<string> mTemp;\\n    char *mAnsStr;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        \\n        vector<string> aResult;\\n        if (wordDict.size() <= 0) { return aResult; }\\n        \\n        for (int i=0;i<s.size();i++) {\\n            unordered_set<string> aSet;\\n            mMatchSets.push_back(aSet);\\n        }\\n        \\n        mAnsStr = new char[s.size() + s.size() + 2]; //some space to write to...\\n        \\n        mMaxLength = 0;\\n        mMinLength = -1;\\n        for (auto aWord : wordDict) {\\n            \\n            mDictionary.insert(aWord);\\n            if (aWord.size() > mMaxLength) {\\n                mMaxLength = aWord.size();\\n            }\\n            if (mMinLength == -1 || aWord.size() < mMinLength) {\\n                mMinLength = aWord.size();\\n            }\\n        }\\n        \\n        wordBreakExplorer(s, wordDict, s.size() - 1); //Find all the answers.\\n        wordBreakSolutionBuilder(aResult, s, 0); //Build all the solutions.\\n        \\n        return aResult;\\n    }\\n\\n    void wordBreakExplorer(string &pString, vector<string>& pDict, int pStart) {\\n        if (pStart < 0) { return; }\\n        \\n        int aInd1 = pStart - mMinLength + 1;\\n        int aInd2 = pStart - mMaxLength + 1;\\n        \\n        if (aInd1 < 0) { return; }\\n        if (aInd2 < 0) { aInd2 = 0; }\\n        \\n        int aLength = mMinLength;\\n        for (int i=aInd1;i>=aInd2;i--) {\\n            \\n            string aChunk = pString.substr(i, aLength);\\n            if (mMatchSets[i].count(aChunk) == 0) {\\n\\n                if (mDictionary.count(aChunk) > 0) {\\n                    mMatchSets[i].insert(aChunk);\\n                    wordBreakExplorer(pString, pDict, i - 1);\\n                }\\n            }\\n            aLength++;\\n        }\\n    }\\n    \\n    \\n    void wordBreakSolutionBuilder(vector<string> &pResult, string &pString, int pStart) {\\n        \\n        if (pStart == pString.size()) {\\n            //Turn the answer into a space-separated word.\\n            int aIndex = 0;\\n            for (auto aString : mTemp) {\\n                for (int i=0;i<aString.size();i++) {\\n                    mAnsStr[aIndex++] = aString[i]; \\n                }\\n                mAnsStr[aIndex++] = \\' \\';\\n            }\\n            mAnsStr[aIndex - 1] = 0;\\n            pResult.push_back(string(mAnsStr));\\n            return;\\n        }\\n        \\n        for (auto aWord : mMatchSets[pStart]) {\\n            //Crawl the solution space. Like a baby crawls for milk bottles.\\n            mTemp.push_back(aWord);\\n            wordBreakSolutionBuilder(pResult, pString, pStart + aWord.size());   \\n            mTemp.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44210,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var cache = [String: [String]]()\\n        return DFS(s, wordDict, &cache)\\n    }\\n    \\n    func DFS(_ s: String, _ wordDict: [String], _ cache: inout [String: [String]]) -> [String] {\\n        if s.characters.count == 0 {\\n            return [\"\"]\\n        }\\n        if let value = cache[s] {\\n            return value\\n        }\\n        \\n        var result = [String]()\\n        \\n        for word in wordDict {\\n            if s.hasPrefix(word) {\\n                let subWordBreaks = DFS(s.substring(from: word.endIndex), wordDict, &cache)\\n                for subWordBreak in subWordBreaks {\\n                    if subWordBreak.isEmpty {\\n                        result.append(word)\\n                    } else {\\n                        result.append(word + \" \" + subWordBreak)\\n                    }\\n                }\\n            }\\n        }\\n        cache[s] = result;\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var cache = [String: [String]]()\\n        return DFS(s, wordDict, &cache)\\n    }\\n    \\n    func DFS(_ s: String, _ wordDict: [String], _ cache: inout [String: [String]]) -> [String] {\\n        if s.characters.count == 0 {\\n            return [\"\"]\\n        }\\n        if let value = cache[s] {\\n            return value\\n        }\\n        \\n        var result = [String]()\\n        \\n        for word in wordDict {\\n            if s.hasPrefix(word) {\\n                let subWordBreaks = DFS(s.substring(from: word.endIndex), wordDict, &cache)\\n                for subWordBreak in subWordBreaks {\\n                    if subWordBreak.isEmpty {\\n                        result.append(word)\\n                    } else {\\n                        result.append(word + \" \" + subWordBreak)\\n                    }\\n                }\\n            }\\n        }\\n        cache[s] = result;\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44225,
                "title": "golang-3ms-solution",
                "content": "```\\nimport \"strings\"\\n\\nfunc wordBreak(s string, wordDict []string) []string {\\n    mp := make(map[string][]string)\\n    return dfs(s, wordDict, mp)    \\n}\\n\\nfunc dfs(s string, wordDict []string, mp map[string][]string) []string {\\n    _, ok := mp[s]\\n    if ok {\\n        return mp[s]\\n    }\\n    \\n    res := make([]string, 0)\\n    if len(s) == 0 {\\n        res = append(res, \"\")\\n        return res\\n    }\\n    for _,word:= range wordDict {\\n        if strings.HasPrefix(s, word) {\\n            sublist := dfs(s[len(word):], wordDict, mp)\\n            for _, sub:= range sublist {\\n                a := \" \"\\n                if len(sub) == 0 {\\n                    a = \"\"\\n                }\\n                res = append(res, word + a + sub)\\n            }\\n        }        \\n    }\\n    mp[s] = res\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport \"strings\"\\n\\nfunc wordBreak(s string, wordDict []string) []string {\\n    mp := make(map[string][]string)\\n    return dfs(s, wordDict, mp)    \\n}\\n\\nfunc dfs(s string, wordDict []string, mp map[string][]string) []string {\\n    _, ok := mp[s]\\n    if ok {\\n        return mp[s]\\n    }\\n    \\n    res := make([]string, 0)\\n    if len(s) == 0 {\\n        res = append(res, \"\")\\n        return res\\n    }\\n    for _,word:= range wordDict {\\n        if strings.HasPrefix(s, word) {\\n            sublist := dfs(s[len(word):], wordDict, mp)\\n            for _, sub:= range sublist {\\n                a := \" \"\\n                if len(sub) == 0 {\\n                    a = \"\"\\n                }\\n                res = append(res, word + a + sub)\\n            }\\n        }        \\n    }\\n    mp[s] = res\\n    return res\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 44308,
                "title": "c-dfs-caching",
                "content": "    public class Solution {\\n        Dictionary<string, List<string>> dp = new Dictionary<string, List<string>>();\\n    \\n        public IList<string> WordBreak(string s, ISet<string> wordDict)\\n        {\\n            return WordBreak(s, 0, s.Length - 1, wordDict);\\n        }\\n    \\n        public IList<string> WordBreak(string s, int start, int end, ISet<string> wordDict)\\n        {\\n            string key = start + \"_\" + end;\\n            if (dp.ContainsKey(key))\\n            {\\n                return dp[key];\\n            }\\n    \\n            List<string> sentences = new List<string>();\\n            for (int sub = start ; sub < end ; sub++)\\n            {\\n                int subLength = sub - start + 1;\\n                string subStr = s.Substring(start, subLength);\\n                if (wordDict.Contains(subStr))\\n                {\\n                    IList<string> rest = WordBreak(s, sub + 1, end, wordDict);\\n                    if (rest.Any())\\n                    {\\n                        sentences.AddRange(rest.Select(ss => subStr + \" \" + ss));\\n                    }\\n                }\\n            }\\n    \\n            string curSentence = s.Substring(start, end - start + 1);\\n            if (wordDict.Contains(curSentence))\\n            {\\n                sentences.Add(curSentence);\\n            }\\n    \\n            dp[key] = sentences;\\n            return sentences;\\n        }\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        Dictionary<string, List<string>> dp = new Dictionary<string, List<string>>();\\n    \\n        public IList<string> WordBreak(string s, ISet<string> wordDict)\\n        {\\n            return WordBreak(s, 0, s.Length - 1, wordDict);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 44345,
                "title": "python-dp-solution-in-11-lines",
                "content": "    \\n\\n\\n    \\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        M = {}\\n        def dfs(remain_str):\\n            if not remain_str: return ['']\\n            if remain_str in M: return M[remain_str]\\n            ret = []    \\n            for i in xrange(1,len(remain_str)+1):\\n                if remain_str[:i] in wordDict: \\n                    for r in dfs(remain_str[i:]): \\n                        ret.append( (remain_str[:i]+' '+r).strip() )\\n            M[remain_str] = tuple(ret)\\n            return ret\\n        return dfs(s)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    \\n\\n\\n    \\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        M = {}\\n        def dfs(remain_str):\\n            if not remain_str: return ['']\\n            if remain_str in M: return M[remain_str]\\n            ret = []    \\n            for i in xrange(1,len(remain_str)+1):\\n                if remain_str[:i] in wordDict: \\n                    for r in dfs(remain_str[i:]): \\n                        ret.append( (remain_str[:i]+' '+r).strip() )\\n            M[remain_str] = tuple(ret)\\n            return ret\\n        return dfs(s)",
                "codeTag": "Python3"
            },
            {
                "id": 44322,
                "title": "c-solution-using-dp-and-backtrace-8ms",
                "content": "1. using dp to just like \"work break\".\\n2. backtrace with dp.\\n\\n    class Solution {\\n    \\n        vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n            if(s.empty() || wordDict.empty()) return vector<string>();\\n            int n = s.size();\\n            vector<bool> dp(n+1, false);\\n            dp[n] = true;\\n            \\n            for(int i=n-1; i >= 0; --i)\\n                for(int j=i+1; j <= n; ++j)\\n                    if(dp[j] && wordDict.find(s.substr(i, j-i)) != wordDict.end()) {\\n                        dp[i] = true;\\n                        break;\\n                    }\\n            if(!dp[0]) return vector<string>();\\n            \\n            vector<string> ret;\\n            bt(s, 0, wordDict, dp, ret);\\n            return ret;\\n        }\\n    \\n        void bt(string &s, int idx, unordered_set<string> &dict, vector<bool> &dp, vector<string> &ret) {\\n            static string tmp;\\n            if(idx == s.size()) {\\n                ret.push_back(tmp);\\n                return ;\\n            }\\n            for(int i=idx+1; i <= s.size(); ++i) {\\n                string str(s, idx, i-idx);\\n                if(dp[i] && dict.find(str) != dict.end()) {\\n                    if(idx != 0) tmp += \" \";\\n                    tmp += str;\\n                    cout << tmp << endl;\\n                    \\n                    bt(s, i, dict, dp, ret);\\n                    \\n                    if(idx == 0) tmp.erase(tmp.size()-str.size());\\n                    else tmp.erase(tmp.size()-str.size()-1);\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    \\n        vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n            if(s.empty() || wordDict.empty()) return vector<string>();\\n            int n = s.size();\\n            vector<bool> dp(n+1, false);\\n            dp[n] = true;\\n            \\n            for(int i=n-1; i >= 0; --i)\\n                for(int j=i+1; j <= n; ++j)\\n                    if(dp[j] && wordDict.find(s.substr(i, j-i)) != wordDict.end()) {\\n                        dp[i] = true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3457927,
                "title": "java-backtraking-easy-to-understand-4ms",
                "content": "4 ms, faster than 61.24% of Java online submissions for Word Break II.\\n```\\nclass Solution {\\n    List<String> wordDict;\\n    String s;\\n    Set<String> res = new HashSet<String>();\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        this.wordDict = wordDict;\\n        this.s = s;\\n        helper(0, 0, new ArrayList<String>());\\n        return new ArrayList<String>(res);\\n    }\\n    public void helper(int i, int j, List<String> arr) {\\n        if(j == s.length()) {\\n            int size = 0;\\n            for(String c : arr) size += c.length();\\n            if(size == s.length()) {\\n                res.add(arr.stream().map(Object::toString)\\n                          .collect(Collectors.joining(\" \")));\\n            }\\n            return;\\n        }\\n        while(j < s.length()) {\\n            if(wordDict.contains(s.substring(i, j + 1))) {\\n                arr.add(s.substring(i, j + 1));\\n                helper(j + 1, j + 1, arr);\\n                helper(i, j + 1, arr);\\n                arr.remove(arr.size() - 1);\\n            }\\n            j++;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<String> wordDict;\\n    String s;\\n    Set<String> res = new HashSet<String>();\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        this.wordDict = wordDict;\\n        this.s = s;\\n        helper(0, 0, new ArrayList<String>());\\n        return new ArrayList<String>(res);\\n    }\\n    public void helper(int i, int j, List<String> arr) {\\n        if(j == s.length()) {\\n            int size = 0;\\n            for(String c : arr) size += c.length();\\n            if(size == s.length()) {\\n                res.add(arr.stream().map(Object::toString)\\n                          .collect(Collectors.joining(\" \")));\\n            }\\n            return;\\n        }\\n        while(j < s.length()) {\\n            if(wordDict.contains(s.substring(i, j + 1))) {\\n                arr.add(s.substring(i, j + 1));\\n                helper(j + 1, j + 1, arr);\\n                helper(i, j + 1, arr);\\n                arr.remove(arr.size() - 1);\\n            }\\n            j++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205780,
                "title": "140-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe time complexity of this algorithm is O(n^3), where n is the length of the input string s. The space complexity is also O(n^3), due to the memoization dictionary. However, in practice, the space complexity will be much lower, as the memoization dictionary will only contain results for a small subset of all possible substrings of s.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        # Create a set of words for fast lookup\\n        word_set = set(wordDict)\\n        # Create a memoization dictionary to store previously calculated results\\n        memo = {}\\n        \\n        # Define a recursive function to find all possible sentences\\n        def dfs(s):\\n            # If the current string s has already been calculated, return the result\\n            if s in memo:\\n                return memo[s]\\n            \\n            # If the string s is empty, return an empty list\\n            if not s:\\n                return []\\n            \\n            # Initialize the result list\\n            res = []\\n            \\n            # Iterate over all possible splits of the string s\\n            for i in range(1, len(s) + 1):\\n                # If the left part of the split is a valid word\\n                if s[:i] in word_set:\\n                    # Recursively find all possible sentences for the right part of the split\\n                    right_sents = dfs(s[i:])\\n                    # If there are any possible sentences for the right part of the split\\n                    if right_sents:\\n                        # Append the current word and all possible sentences for the right part of the split\\n                        for right_sent in right_sents:\\n                            res.append(s[:i] + \" \" + right_sent)\\n                    # If there are no possible sentences for the right part of the split, but the right part is empty\\n                    elif not s[i:]:\\n                        # Append just the current word\\n                        res.append(s[:i])\\n            \\n            # Store the result for the current string s in the memoization dictionary and return it\\n            memo[s] = res\\n            return res\\n        \\n        # Call the recursive function to find all possible sentences for the input string s\\n        return dfs(s)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        # Create a set of words for fast lookup\\n        word_set = set(wordDict)\\n        # Create a memoization dictionary to store previously calculated results\\n        memo = {}\\n        \\n        # Define a recursive function to find all possible sentences\\n        def dfs(s):\\n            # If the current string s has already been calculated, return the result\\n            if s in memo:\\n                return memo[s]\\n            \\n            # If the string s is empty, return an empty list\\n            if not s:\\n                return []\\n            \\n            # Initialize the result list\\n            res = []\\n            \\n            # Iterate over all possible splits of the string s\\n            for i in range(1, len(s) + 1):\\n                # If the left part of the split is a valid word\\n                if s[:i] in word_set:\\n                    # Recursively find all possible sentences for the right part of the split\\n                    right_sents = dfs(s[i:])\\n                    # If there are any possible sentences for the right part of the split\\n                    if right_sents:\\n                        # Append the current word and all possible sentences for the right part of the split\\n                        for right_sent in right_sents:\\n                            res.append(s[:i] + \" \" + right_sent)\\n                    # If there are no possible sentences for the right part of the split, but the right part is empty\\n                    elif not s[i:]:\\n                        # Append just the current word\\n                        res.append(s[:i])\\n            \\n            # Store the result for the current string s in the memoization dictionary and return it\\n            memo[s] = res\\n            return res\\n        \\n        # Call the recursive function to find all possible sentences for the input string s\\n        return dfs(s)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107035,
                "title": "c-dp-solution-with-explanation-0ms-100-faster-runtime",
                "content": "# Intuition\\n\\nThe first observation to make out from the given description is that this problem involves the concept of subproblem within a problem - i.e. DP; meaning, the problem can be broken down into smaller fractions and the final answer can be found by combining the answers to these subproblems.\\n\\n# Approach\\n\\nWe will first insert the list of words into an unordered set (unsorted) so that finding the strings within the set takes negligible time.\\n\\nNext, we declare an array of array of strings (2D vector) of size one more than the size of the given original string. This two-dimensional array of strings stores in each index \\'i\\' the list of strings that upon concatenation result in a prefix string of length \\'i\\'.\\n\\nNow we iterate from index i = 0 to the size of the string and for each \\'i\\', from j = i + 1 to the end of the string and check if the resultant substring from position \\'i\\' of length \\'j - i\\' is contained in the list of words in wordDict.\\n\\nIf it is contained in the list of words, the from index \\'i\\', we obtain all the strings that lead up to the prefix string of length \\'i\\' and we append the string of length \\'j - i\\' and push the list in the position \\'j\\' (dp[j]).\\n\\nThe final answer is obtained at the last position of the dp array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set <string> st;\\n\\n        for(auto x: wordDict)\\n            st.insert(x);\\n        \\n        int n = s.size();\\n        vector <vector <string> > dp(n + 1);\\n        dp[0] = {\"\"};\\n\\n        for(int i = 0; i < n; i++) {\\n            if(dp[i].size() == 0)\\n                continue;\\n            \\n            for(int j = i + 1; j <= n; j++) {\\n                string tmp = s.substr(i, j - i);\\n\\n                if(st.count(tmp)) {\\n                    for(auto x: dp[i]) {\\n                        string str = x;\\n                        str += tmp;\\n                        str.push_back(\\' \\');\\n                        dp[j].push_back(str);\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(auto &x: dp[n]) // for the elimination of terminal space characters\\n            x.pop_back();\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set <string> st;\\n\\n        for(auto x: wordDict)\\n            st.insert(x);\\n        \\n        int n = s.size();\\n        vector <vector <string> > dp(n + 1);\\n        dp[0] = {\"\"};\\n\\n        for(int i = 0; i < n; i++) {\\n            if(dp[i].size() == 0)\\n                continue;\\n            \\n            for(int j = i + 1; j <= n; j++) {\\n                string tmp = s.substr(i, j - i);\\n\\n                if(st.count(tmp)) {\\n                    for(auto x: dp[i]) {\\n                        string str = x;\\n                        str += tmp;\\n                        str.push_back(\\' \\');\\n                        dp[j].push_back(str);\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(auto &x: dp[n]) // for the elimination of terminal space characters\\n            x.pop_back();\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801907,
                "title": "fast",
                "content": "```\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```",
                "solutionTags": [],
                "code": "```\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749473,
                "title": "recursion-beats-100-cpp",
                "content": "```\\nclass Solution {\\n     void solve(int index,string &s,unordered_set<string> &hashset,int &n,string sub_ans,vector<string> &ans){\\n        if(index==n){\\n            sub_ans=sub_ans.substr(1); //to remove leading space\\n            ans.push_back(sub_ans);\\n            return;\\n        }\\n        string temp=\"\"; \\n*         //tring every possible partition \\n        for(int i=index;i<n;i++){\\n            //temp is the word formed by partition\\n            temp+=s[i];\\n            //if word before partition exist in hashset then check for remaining word\\n            if(hashset.find(temp)!=hashset.end()){\\n               solve(i+1,s,hashset,n,sub_ans+\" \"+temp,ans);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> ans; //answer vector\\n        //storing all the words in hashset\\n        unordered_set<string> hashset; \\n        for(auto i:wordDict){\\n            hashset.insert(i);\\n        }\\n        int n=s.length();\\n        string sub_ans=\"\"; //empty string to store sentence\\n        solve(0,s,hashset,n,sub_ans,ans); //helpercode call\\n        return ans; \\n        \\n    }\\n};\\n## //please upvote if it was helpfull\\n",
                "solutionTags": [],
                "code": "class Solution {\\n     void solve(int index,string &s,unordered_set<string> &hashset,int &n,string sub_ans,vector<string> &ans){\\n        if(index==n){\\n            sub_ans=sub_ans.substr(1); //to remove leading space\\n            ans.push_back(sub_ans);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2739918,
                "title": "very-easy-and-simple-recursive-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        helper(s, dictionary, ans, \"\");\\n        return ans;\\n    }\\n\\n    void helper(String s, List<String> d, List<String> ans, String temp){\\n        if(s.length() == 0){\\n            ans.add(temp.trim());\\n            return;\\n        }\\n    \\n        for(int i = s.length() - 1; i >= 0; i--){\\n            String right = s.substring(i, s.length());\\n            if(d.contains(right)){\\n                String left = s.substring(0, i);\\n                helper(left, d, ans, right + \" \" + temp);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        helper(s, dictionary, ans, \"\");\\n        return ans;\\n    }\\n\\n    void helper(String s, List<String> d, List<String> ans, String temp){\\n        if(s.length() == 0){\\n            ans.add(temp.trim());\\n            return;\\n        }\\n    \\n        for(int i = s.length() - 1; i >= 0; i--){\\n            String right = s.substring(i, s.length());\\n            if(d.contains(right)){\\n                String left = s.substring(0, i);\\n                helper(left, d, ans, right + \" \" + temp);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671659,
                "title": "java-backtracking-faster-than-100-short-code",
                "content": "Unlike the Dynamic programming solution mentioned in the solution, a backtracking approach gives the same time complexity on an asymptotic case.\\n```\\nclass Solution {\\n    List<String> ans;\\n    public void breakWord(String s, int start, Set<String> dict, List<String> curr){\\n        for(int i=start+1;i<=s.length();i++){\\n            String f = s.substring(start, i);\\n            if(dict.contains(f)){\\n                curr.add(f);\\n                if(i==s.length()){\\n                    String[] stringparts = curr.toArray(String[]::new);\\n                    ans.add(String.join(\" \", stringparts));\\n                }    \\n                else breakWord(s, i, dict, curr);\\n                curr.remove(curr.size()-1);\\n            }\\n        }\\n    }\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        ans = new ArrayList<String>();\\n        Set<String> dict = new HashSet();\\n        for(String w:wordDict) dict.add(w);\\n        breakWord(s, 0, dict, new ArrayList<String>());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> ans;\\n    public void breakWord(String s, int start, Set<String> dict, List<String> curr){\\n        for(int i=start+1;i<=s.length();i++){\\n            String f = s.substring(start, i);\\n            if(dict.contains(f)){\\n                curr.add(f);\\n                if(i==s.length()){\\n                    String[] stringparts = curr.toArray(String[]::new);\\n                    ans.add(String.join(\" \", stringparts));\\n                }    \\n                else breakWord(s, i, dict, curr);\\n                curr.remove(curr.size()-1);\\n            }\\n        }\\n    }\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        ans = new ArrayList<String>();\\n        Set<String> dict = new HashSet();\\n        for(String w:wordDict) dict.add(w);\\n        breakWord(s, 0, dict, new ArrayList<String>());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627035,
                "title": "short-and-standard-backtracking-solution-java",
                "content": "```\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<List<String>> res = new ArrayList<>();\\n        dfs(s, wordDict, res, 0, new ArrayList<>());\\n        return res.stream().map(list -> String.join(\" \", list)).collect(Collectors.toList());\\n    }\\n    // classical backtracking - performance better compare with below solution-2\\n    public static void dfs(String s, List<String> wordDict, List<List<String>> res,\\n                           int start, List<String> track) {\\n        if (start == s.length()) {\\n            res.add(new ArrayList<>(track));\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            String next = s.substring(start, i + 1); // catch: substring from start\\n            if (wordDict.contains(next)) {\\n                track.add(next);\\n                dfs(s, wordDict, res, i + 1, track);\\n                track.remove(track.size()-1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<List<String>> res = new ArrayList<>();\\n        dfs(s, wordDict, res, 0, new ArrayList<>());\\n        return res.stream().map(list -> String.join(\" \", list)).collect(Collectors.toList());\\n    }\\n    // classical backtracking - performance better compare with below solution-2\\n    public static void dfs(String s, List<String> wordDict, List<List<String>> res,\\n                           int start, List<String> track) {\\n        if (start == s.length()) {\\n            res.add(new ArrayList<>(track));\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            String next = s.substring(start, i + 1); // catch: substring from start\\n            if (wordDict.contains(next)) {\\n                track.add(next);\\n                dfs(s, wordDict, res, i + 1, track);\\n                track.remove(track.size()-1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375696,
                "title": "java-concise-and-simple-code-with-comments",
                "content": "Runtime: 4 ms, faster than 61.76% of Java online submissions for Word Break II.\\nMemory Usage: 40.5 MB, less than 93.93% of Java online submissions for Word Break II.\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> words) {\\n        List<String> ans = new ArrayList<>();\\n        helper(\"\", s, words, ans);\\n        return ans;\\n    }\\n    \\n    void helper(String curr, String s, List<String> words, List<String> ans) {\\n        if(s.length() == 0) {\\n            ans.add(curr.trim()); // Remove any whitespace at the end\\n            return;\\n        }\\n        for(String word : words) {\\n            if(s.indexOf(word) == 0) { // Check if s starts with current word\\n               helper(curr + \" \" + word, s.substring(word.length()), words, ans); // Call helper for remaining s\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> words) {\\n        List<String> ans = new ArrayList<>();\\n        helper(\"\", s, words, ans);\\n        return ans;\\n    }\\n    \\n    void helper(String curr, String s, List<String> words, List<String> ans) {\\n        if(s.length() == 0) {\\n            ans.add(curr.trim()); // Remove any whitespace at the end\\n            return;\\n        }\\n        for(String word : words) {\\n            if(s.indexOf(word) == 0) { // Check if s starts with current word\\n               helper(curr + \" \" + word, s.substring(word.length()), words, ans); // Call helper for remaining s\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302827,
                "title": "c-simple-c-code-100-time-83-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n![image](https://assets.leetcode.com/users/images/e0c05b38-fafa-41a9-b1d8-98c3c09a6133_1658213884.0128381.png)\\n\\n```\\nclass Solution {\\n    vector<string> ans;\\n    unordered_map<string, int> um;\\n    void dfs(string &s, string &comb, int i)\\n    {\\n        if(i == s.size())\\n        {\\n            if(comb.size() != 0)\\n            {\\n                string f = comb.substr(0,comb.size()-1);\\n                ans.push_back(f);   \\n            }\\n            return;\\n        }\\n        string tmp = \"\";\\n        for(int j = i; j < s.size(); j++)\\n        {\\n            tmp += s[j];\\n            if(um.count(tmp))\\n            {\\n                string store = comb;\\n                comb += tmp + \\' \\';\\n                dfs(s, comb, j+1);\\n                comb = store;\\n            }\\n        }\\n        return;\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        string combs = \"\";\\n        for(string &str : wordDict)\\n            um[str]++;\\n        dfs(s, combs, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> ans;\\n    unordered_map<string, int> um;\\n    void dfs(string &s, string &comb, int i)\\n    {\\n        if(i == s.size())\\n        {\\n            if(comb.size() != 0)\\n            {\\n                string f = comb.substr(0,comb.size()-1);\\n                ans.push_back(f);   \\n            }\\n            return;\\n        }\\n        string tmp = \"\";\\n        for(int j = i; j < s.size(); j++)\\n        {\\n            tmp += s[j];\\n            if(um.count(tmp))\\n            {\\n                string store = comb;\\n                comb += tmp + \\' \\';\\n                dfs(s, comb, j+1);\\n                comb = store;\\n            }\\n        }\\n        return;\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        string combs = \"\";\\n        for(string &str : wordDict)\\n            um[str]++;\\n        dfs(s, combs, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252707,
                "title": "c-easy-to-understand-simple-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    set<string> dict;\\n    int n;\\n    void backtrack(string &s,vector<string> &ans,string str)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(str);\\n            return;\\n        }\\n        for(int j=1;j<=s.size();j++)\\n        {\\n            string left=s.substr(0,j);\\n            string right=s.substr(j);\\n            if(dict.find(left)!=dict.end())\\n            {\\n                string z=str;\\n                str+=left;\\n                str+=\\' \\';\\n                backtrack(right,ans,str);\\n                str=z;\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        n=s.length();\\n        for(auto &word:wordDict)\\n        {\\n            dict.insert(word);\\n        }\\n        \\n        vector<string> ans;\\n        backtrack(s,ans,\"\");\\n        for(auto &x:ans)\\n        {\\n            x.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string> dict;\\n    int n;\\n    void backtrack(string &s,vector<string> &ans,string str)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(str);\\n            return;\\n        }\\n        for(int j=1;j<=s.size();j++)\\n        {\\n            string left=s.substr(0,j);\\n            string right=s.substr(j);\\n            if(dict.find(left)!=dict.end())\\n            {\\n                string z=str;\\n                str+=left;\\n                str+=\\' \\';\\n                backtrack(right,ans,str);\\n                str=z;\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        n=s.length();\\n        for(auto &word:wordDict)\\n        {\\n            dict.insert(word);\\n        }\\n        \\n        vector<string> ans;\\n        backtrack(s,ans,\"\");\\n        for(auto &x:ans)\\n        {\\n            x.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915607,
                "title": "python-faster-than-95-explanation-simple-code",
                "content": "# \\t<----- IF YOU LIKE THE SOLUTION UPVOTE HERE\\n\\t\\nApproach : \\n1. \\t find the sequences of word from the wordDict which will exactly equal to  our orignal s string.\\n2. \\t After finding the sequences of word just add them using space between each word.\\n\\t\\n\\tclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n            lst  = []\\n            def rec(start,sentence):\\n                if start >= len(s):\\n                    lst.append(sentence[:-1]) #[:-1] bcz at last of the sentence there is space to not incluide it I use last index\\n\\n                for i in range(start,len(s)):      # evert time I am going in forwad directon if the below IF condition satisfy\\n                    if s[start:i+1] in wordDict:\\n                        rec(i+1,sentence + s[start:i+1] + \" \")  # In question they have mension that give space between each word\\n                        \\n            rec(0,\\'\\')\\n            return lst",
                "solutionTags": [
                    "Python"
                ],
                "code": "# \\t<----- IF YOU LIKE THE SOLUTION UPVOTE HERE\\n\\t\\nApproach : \\n1. \\t find the sequences of word from the wordDict which will exactly equal to  our orignal s string.\\n2. \\t After finding the sequences of word just add them using space between each word.\\n\\t\\n\\tclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n            lst  = []\\n            def rec(start,sentence):\\n                if start >= len(s):\\n                    lst.append(sentence[:-1]) #[:-1] bcz at last of the sentence there is space to not incluide it I use last index\\n\\n                for i in range(start,len(s)):      # evert time I am going in forwad directon if the below IF condition satisfy\\n                    if s[start:i+1] in wordDict:\\n                        rec(i+1,sentence + s[start:i+1] + \" \")  # In question they have mension that give space between each word\\n                        \\n            rec(0,\\'\\')\\n            return lst",
                "codeTag": "Java"
            },
            {
                "id": 1764843,
                "title": "python-trie",
                "content": "```\\nclass Solution:\\n    \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        trie = {}\\n\\t\\t#filling the trie\\n        for word in wordDict:\\n            currentDict = trie\\n            for letter in word:\\n                if letter in currentDict:\\n                    currentDict = currentDict[letter]\\n                else:\\n                    currentDict[letter] = {}\\n                    currentDict = currentDict[letter]\\n            currentDict[\\'_\\'] = 0\\n\\t\\t\\t\\n        #function to go through the trie    \\n        def iterate(st, final_res, current, currentTrie):\\n            for i in range(len(st)):       \\n                if \\'_\\' in currentTrie: #found the end of the word, start new search branch\\n                    iterate(st[i:], final_res, current + [st[:i]], trie)\\n                    \\n                if st[i] in currentTrie:\\n                    currentTrie = currentTrie[st[i]]\\n                else: #no possible to fit the word, end this search branch\\n                    return\\n\\n            #last symbol check   \\n            if \\'_\\' in currentTrie:\\n                final_res.append(current + [st])\\n\\n        res = []\\n        iterate(s, res, [], trie)\\n        return [\\' \\'.join(r) for r in res]\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        trie = {}\\n\\t\\t#filling the trie\\n        for word in wordDict:\\n            currentDict = trie\\n            for letter in word:\\n                if letter in currentDict:\\n                    currentDict = currentDict[letter]\\n                else:\\n                    currentDict[letter] = {}\\n                    currentDict = currentDict[letter]\\n            currentDict[\\'_\\'] = 0\\n\\t\\t\\t\\n        #function to go through the trie    \\n        def iterate(st, final_res, current, currentTrie):\\n            for i in range(len(st)):       \\n                if \\'_\\' in currentTrie: #found the end of the word, start new search branch\\n                    iterate(st[i:], final_res, current + [st[:i]], trie)\\n                    \\n                if st[i] in currentTrie:\\n                    currentTrie = currentTrie[st[i]]\\n                else: #no possible to fit the word, end this search branch\\n                    return\\n\\n            #last symbol check   \\n            if \\'_\\' in currentTrie:\\n                final_res.append(current + [st])\\n\\n        res = []\\n        iterate(s, res, [], trie)\\n        return [\\' \\'.join(r) for r in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703604,
                "title": "java-evolve-from-139-word-break",
                "content": "//Problem is very similar to \"139. Word Break\"\\n\\n//Here is the solution built on top of \"139. Word Break\" that uses bfs like approach\\n\\n\\tpublic  List<String>  wordBreak(String s, List<String> wordDict) \\n    {\\n        List<String> ans=new LinkedList<>();\\n        Set<String> wordDictSet = new HashSet<>(wordDict);\\n\\n        Queue<Pair<Integer, StringBuilder>> queue = new LinkedList<>();     \\n        queue.add(new Pair(0, new StringBuilder()));\\n    \\n        while (!queue.isEmpty()) \\n        {\\n            Pair<Integer, StringBuilder> cpair=queue.poll();\\n            int start=cpair.getKey();\\n            StringBuilder sb=cpair.getValue();\\n            \\n            for (int end=start+1; end<=s.length(); end++) \\n            {\\n                if (wordDictSet.contains(s.substring(start, end))) \\n                {\\n                    StringBuilder sbu=new StringBuilder(sb);\\n                    sbu.append(s.substring(start, end) + \" \");\\n                    \\n                    if (end == s.length())\\n                    {\\n                        ans.add(sbu.toString().trim());\\n                        continue;\\n                    }\\n                    queue.add(new Pair(end, sbu));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t\\n//\\tAnd here is actual solution for \"139. Word Break\"\\n   \\n\\tpublic boolean wordBreak(String s, List<String> wordDict) \\n    {\\n        Set<String> wordDictSet = new HashSet<>(wordDict);\\n        boolean[] visited = new boolean[s.length()];\\n        \\n        Queue<Integer> queue = new LinkedList<>(); //keeps index    \\n        queue.add(0);\\n    \\n        while (!queue.isEmpty()) \\n        {\\n            int start = queue.poll();\\n            if (visited[start]) \\n                continue;\\n    \\n            for (int end=start+1; end<=s.length(); end++) \\n            {\\n                if (wordDictSet.contains(s.substring(start, end))) \\n                {\\n                    queue.add(end);\\n                    if (end == s.length()) \\n                        return true;\\n                }\\n            }\\n            visited[start] = true;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "//Problem is very similar to \"139. Word Break\"\\n\\n//Here is the solution built on top of \"139. Word Break\" that uses bfs like approach\\n\\n\\tpublic  List<String>  wordBreak(String s, List<String> wordDict) \\n    {\\n        List<String> ans=new LinkedList<>();\\n        Set<String> wordDictSet = new HashSet<>(wordDict);\\n\\n        Queue<Pair<Integer, StringBuilder>> queue = new LinkedList<>();     \\n        queue.add(new Pair(0, new StringBuilder()));\\n    \\n        while (!queue.isEmpty()) \\n        {\\n            Pair<Integer, StringBuilder> cpair=queue.poll();\\n            int start=cpair.getKey();\\n            StringBuilder sb=cpair.getValue();\\n            \\n            for (int end=start+1; end<=s.length(); end++) \\n            {\\n                if (wordDictSet.contains(s.substring(start, end))) \\n                {\\n                    StringBuilder sbu=new StringBuilder(sb);\\n                    sbu.append(s.substring(start, end) + \" \");\\n                    \\n                    if (end == s.length())\\n                    {\\n                        ans.add(sbu.toString().trim());\\n                        continue;\\n                    }\\n                    queue.add(new Pair(end, sbu));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t\\n//\\tAnd here is actual solution for \"139. Word Break\"\\n   \\n\\tpublic boolean wordBreak(String s, List<String> wordDict) \\n    {\\n        Set<String> wordDictSet = new HashSet<>(wordDict);\\n        boolean[] visited = new boolean[s.length()];\\n        \\n        Queue<Integer> queue = new LinkedList<>(); //keeps index    \\n        queue.add(0);\\n    \\n        while (!queue.isEmpty()) \\n        {\\n            int start = queue.poll();\\n            if (visited[start]) \\n                continue;\\n    \\n            for (int end=start+1; end<=s.length(); end++) \\n            {\\n                if (wordDictSet.contains(s.substring(start, end))) \\n                {\\n                    queue.add(end);\\n                    if (end == s.length()) \\n                        return true;\\n                }\\n            }\\n            visited[start] = true;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1683301,
                "title": "trie-runtime-0ms-100-faster",
                "content": "**Don\\'t Forget to Upvote!**\\n```\\nclass Solution {\\npublic:\\n\\n    class TrieNode{\\n    public:\\n        bool end;\\n        vector<TrieNode*> child;\\n\\n        TrieNode(){\\n            end = false;\\n            child.assign(26,nullptr);\\n        }\\n    };\\n\\n    class Trie{\\n    public:\\n        TrieNode* root;\\n\\n        Trie(){\\n            root = new TrieNode();\\n        }\\n\\n        void insert(string s){\\n            TrieNode* curr = root;\\n            for(auto& c:s){\\n                if(!curr->child[c-\\'a\\'])\\n                    curr->child[c-\\'a\\'] = new TrieNode();\\n                curr = curr->child[c-\\'a\\'];\\n            }\\n            curr->end = true;\\n        }\\n\\n        bool search(string s){\\n            TrieNode* curr = root;\\n            for(auto& c:s){\\n                if(!curr->child[c-\\'a\\'])\\n                    return false;\\n                curr = curr->child[c-\\'a\\'];\\n            }\\n            return curr->end;\\n        }\\n    };\\n\\n    Trie trie;\\n    vector<string> ans;\\n\\n    void recurse(int index,string curr,string sentence,string s){\\n        if(index==s.length()){\\n            sentence.erase(sentence.begin());\\n            ans.push_back(sentence);\\n            return;\\n        }\\n\\n        for(int i=index;i<s.length();i++){\\n            curr.push_back(s[i]);\\n            if(trie.search(curr))\\n                recurse(i+1,\"\",sentence+\" \"+curr,s);\\n        }\\n    }\\n\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        for(auto& str:wordDict){\\n            trie.insert(str);\\n        }\\n        recurse(0,\"\",\"\",s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    class TrieNode{\\n    public:\\n        bool end;\\n        vector<TrieNode*> child;\\n\\n        TrieNode(){\\n            end = false;\\n            child.assign(26,nullptr);\\n        }\\n    };\\n\\n    class Trie{\\n    public:\\n        TrieNode* root;\\n\\n        Trie(){\\n            root = new TrieNode();\\n        }\\n\\n        void insert(string s){\\n            TrieNode* curr = root;\\n            for(auto& c:s){\\n                if(!curr->child[c-\\'a\\'])\\n                    curr->child[c-\\'a\\'] = new TrieNode();\\n                curr = curr->child[c-\\'a\\'];\\n            }\\n            curr->end = true;\\n        }\\n\\n        bool search(string s){\\n            TrieNode* curr = root;\\n            for(auto& c:s){\\n                if(!curr->child[c-\\'a\\'])\\n                    return false;\\n                curr = curr->child[c-\\'a\\'];\\n            }\\n            return curr->end;\\n        }\\n    };\\n\\n    Trie trie;\\n    vector<string> ans;\\n\\n    void recurse(int index,string curr,string sentence,string s){\\n        if(index==s.length()){\\n            sentence.erase(sentence.begin());\\n            ans.push_back(sentence);\\n            return;\\n        }\\n\\n        for(int i=index;i<s.length();i++){\\n            curr.push_back(s[i]);\\n            if(trie.search(curr))\\n                recurse(i+1,\"\",sentence+\" \"+curr,s);\\n        }\\n    }\\n\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        for(auto& str:wordDict){\\n            trie.insert(str);\\n        }\\n        recurse(0,\"\",\"\",s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666710,
                "title": "5-ms-simple-c-backtracking-solution-with-explanation-easy-to-understand-code",
                "content": "We have to look it as a dfs problem. We loop through our string from left to right and divide it each time. If we have the left substring in the dictionary then we add this string in the curr vector and call recursively for the right substring.\\n```Base case``` if empty string then we loop over our curr vector and form the sentence and return\\n\\nHope this helps. \\n\\n```\\nvector<string> ans;\\n    unordered_set<string> hash;\\n    \\n    void helper(string s, vector<string> &curr){\\n        if(s.length() == 0){\\n            string res;\\n            for(int i=0;i<curr.size(); ++i){\\n                res += curr[i];\\n                if(i != curr.size() - 1) res+= \" \";\\n            }\\n            ans.push_back(res);\\n            return;\\n        }\\n        \\n        for(int i=1;i<=s.length(); ++i){\\n            string left = s.substr(0, i);\\n            if(hash.count(left)) {\\n                curr.push_back(left);\\n                helper(s.substr(i), curr);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> curr;\\n        for(auto x: wordDict) hash.insert(x);\\n        helper(s, curr);\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```Base case```\n```\\nvector<string> ans;\\n    unordered_set<string> hash;\\n    \\n    void helper(string s, vector<string> &curr){\\n        if(s.length() == 0){\\n            string res;\\n            for(int i=0;i<curr.size(); ++i){\\n                res += curr[i];\\n                if(i != curr.size() - 1) res+= \" \";\\n            }\\n            ans.push_back(res);\\n            return;\\n        }\\n        \\n        for(int i=1;i<=s.length(); ++i){\\n            string left = s.substr(0, i);\\n            if(hash.count(left)) {\\n                curr.push_back(left);\\n                helper(s.substr(i), curr);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> curr;\\n        for(auto x: wordDict) hash.insert(x);\\n        helper(s, curr);\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1532818,
                "title": "python-beats-88-37",
                "content": "Super easy solution with naive approach of simply building word character by character and then backtracking if out of bounds\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res, end = [], len(s)\\n        def helper(start, curr):\\n            if start == end:\\n                res.append(\" \".join(curr))\\n                return\\n            tmp = \"\"\\n            for i in range(start, end):\\n                tmp += s[i]\\n                if tmp in wordDict:\\n                    curr.append(tmp)\\n                    helper(i + 1, curr)\\n                    curr.pop()\\n        helper(0, [])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res, end = [], len(s)\\n        def helper(start, curr):\\n            if start == end:\\n                res.append(\" \".join(curr))\\n                return\\n            tmp = \"\"\\n            for i in range(start, end):\\n                tmp += s[i]\\n                if tmp in wordDict:\\n                    curr.append(tmp)\\n                    helper(i + 1, curr)\\n                    curr.pop()\\n        helper(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437714,
                "title": "python-clean-iterative-dfs-backtracking",
                "content": "### Iterative DFS\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:        \\n        \\n        N = len(s)    \\n        queue, sentences = deque([(0, \\'\\')]), []\\n        while queue:\\n            i, sentence = queue.pop()\\n            if i == N: \\n                sentences.append(sentence[1:])\\n                continue\\n            for word in wordDict:\\n                index = i+len(word)\\n                if index <= N and s[i:index] == word: \\n                    queue.append((index, sentence+\\' \\'+word))\\n        return sentences\\n```    \\n### Backtracking\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n    \\n        def backtrack(i = 0, sentence = \\'\\'):\\n            nonlocal N\\n            if i == N: \\n                sentences.append(sentence[1:])\\n                return\\n            for word in wordDict:\\n                index = i+len(word)\\n                if index <= N and s[i:index] == word and i not in visited:\\n                    visited.add(i)\\n                    backtrack(index, sentence+\\' \\'+word)\\n                    visited.remove(i)\\n            \\n        N = len(s)\\n        sentences, visited = [], set()\\n        backtrack()\\n        return sentences\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:        \\n        \\n        N = len(s)    \\n        queue, sentences = deque([(0, \\'\\')]), []\\n        while queue:\\n            i, sentence = queue.pop()\\n            if i == N: \\n                sentences.append(sentence[1:])\\n                continue\\n            for word in wordDict:\\n                index = i+len(word)\\n                if index <= N and s[i:index] == word: \\n                    queue.append((index, sentence+\\' \\'+word))\\n        return sentences\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n    \\n        def backtrack(i = 0, sentence = \\'\\'):\\n            nonlocal N\\n            if i == N: \\n                sentences.append(sentence[1:])\\n                return\\n            for word in wordDict:\\n                index = i+len(word)\\n                if index <= N and s[i:index] == word and i not in visited:\\n                    visited.add(i)\\n                    backtrack(index, sentence+\\' \\'+word)\\n                    visited.remove(i)\\n            \\n        N = len(s)\\n        sentences, visited = [], set()\\n        backtrack()\\n        return sentences\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400590,
                "title": "c-fastest-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>v;\\n    void solve(string s,unordered_set<string>set,string res,int pos)\\n    {\\n        if(pos==s.size())\\n        {\\n            res.pop_back();\\n            v.push_back(res);\\n            return;\\n        }\\n        for(int i=pos+1;i<=s.size();++i)\\n        {\\n            string ss=s.substr(pos,i-pos);\\n            if(set.find(ss)!=set.end())\\n            {\\n                solve(s,set,res+ss+\\' \\',i);\\n            }\\n        }\\n      \\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set;\\n        for(auto x:wordDict)\\n            set.insert(x);\\n        string res;\\n        solve(s,set,res,0);\\n        return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>v;\\n    void solve(string s,unordered_set<string>set,string res,int pos)\\n    {\\n        if(pos==s.size())\\n        {\\n            res.pop_back();\\n            v.push_back(res);\\n            return;\\n        }\\n        for(int i=pos+1;i<=s.size();++i)\\n        {\\n            string ss=s.substr(pos,i-pos);\\n            if(set.find(ss)!=set.end())\\n            {\\n                solve(s,set,res+ss+\\' \\',i);\\n            }\\n        }\\n      \\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set;\\n        for(auto x:wordDict)\\n            set.insert(x);\\n        string res;\\n        solve(s,set,res,0);\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384083,
                "title": "simple-java-backtracking-solution-with-explaination-0ms-100-no-tle",
                "content": "Add all words in WordDict to a hash set for O(1) access.\\n\\nIterate through every character of the string and check if the substring is present in the set. If the substirng is present in the dictionary set, it means the substring could be one of the broken parts of the string. So, add it to the temporary list and then similarly recurse to check more words from next index.\\n\\nThe termination condition will be, if we have reached to the end of string. Then, format the temporary list into the desired space separated string.\\n\\n\\n\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> list = new ArrayList<>();\\n        Set<String> set = new HashSet<>(wordDict);\\n        wordBreak(list, new ArrayList<>(), 0, set,s);\\n        return list;\\n    }\\n    \\n    private void wordBreak(List<String> list, List<String> temp, int index, Set<String> set, String s) {\\n        if(index==s.length()) { //  reached at the end of string\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0; i<temp.size()-1; i++) {\\n                sb.append(temp.get(i)).append(\" \");\\n            }\\n            sb.append(temp.get(temp.size()-1));\\n            list.add(sb.toString());\\n            return;\\n        }\\n        \\n        for(int i=index; i<s.length(); i++) {\\n            String str = s.substring(index, i+1);\\n            if(!set.contains(str)) continue;\\n            temp.add(str); // add to the temporary list\\n            wordBreak(list, temp, i+1, set,s); // recurse to check every word from next index\\n            temp.remove(temp.size()-1); //backtrack\\n        }\\n    }\\n}\\n```\\n\\n\\nI think TC is 2^n, the string of length has (n+1) ways to be broken into two parts. Then at each step we have two options to further split or not.In worst case, when all choices are made,time complexity will be 2^n.  Feel free to point out if I am misssing anything. \\n\\nI have actually a query, I think it is a brute force approach. Even then why the running time is 0ms and is better than 100% solutions. Am i missing anything?",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> list = new ArrayList<>();\\n        Set<String> set = new HashSet<>(wordDict);\\n        wordBreak(list, new ArrayList<>(), 0, set,s);\\n        return list;\\n    }\\n    \\n    private void wordBreak(List<String> list, List<String> temp, int index, Set<String> set, String s) {\\n        if(index==s.length()) { //  reached at the end of string\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0; i<temp.size()-1; i++) {\\n                sb.append(temp.get(i)).append(\" \");\\n            }\\n            sb.append(temp.get(temp.size()-1));\\n            list.add(sb.toString());\\n            return;\\n        }\\n        \\n        for(int i=index; i<s.length(); i++) {\\n            String str = s.substring(index, i+1);\\n            if(!set.contains(str)) continue;\\n            temp.add(str); // add to the temporary list\\n            wordBreak(list, temp, i+1, set,s); // recurse to check every word from next index\\n            temp.remove(temp.size()-1); //backtrack\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340887,
                "title": "java-trie",
                "content": "```\\nclass Solution {\\n    class Trie{\\n        Trie children[] = new Trie[26];\\n        boolean isEndOfWord;\\n        public Trie(){\\n            for(int i=0;i<26;i++)\\n                children[i] = null;\\n            isEndOfWord = false;\\n        }\\n    }\\n    public void addWord(Trie root,String s){\\n        Trie node = root;\\n        for(int i=0;i<s.length();i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            if(node.children[ch]==null)\\n                node.children[ch] = new Trie();\\n            node = node.children[ch];\\n        }\\n        node.isEndOfWord = true;\\n    }\\n    public boolean search(Trie root, String s){\\n        Trie node = root;\\n        for(int i=0;i<s.length();i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            if(node.children[ch]==null)\\n                return false;\\n            node = node.children[ch];\\n        }\\n        return node.isEndOfWord;\\n    }\\n    \\n    List<String> list;\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Trie root = new Trie();\\n        for(String st:wordDict){\\n            addWord(root,st);\\n        }\\n        list = new ArrayList();\\n        findRemainingSubString(root,\"\",s,s.length());\\n        return list;\\n    }\\n    public boolean findRemainingSubString(Trie root,String str,String s,int total){\\n        if(s==null || s.length()==0)\\n            return true;\\n        for(int i=0;i<=s.length();i++){\\n            String st = str;\\n            if(search(root,s.substring(0,i))){\\n                st = st + s.substring(0,i)+ \" \";\\n                if(!findRemainingSubString(root,st,s.substring(i),total+1))\\n                    return false;\\n                if(st.trim().length()==total)\\n                    list.add(st.trim());\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    class Trie{\\n        Trie children[] = new Trie[26];\\n        boolean isEndOfWord;\\n        public Trie(){\\n            for(int i=0;i<26;i++)\\n                children[i] = null;\\n            isEndOfWord = false;\\n        }\\n    }\\n    public void addWord(Trie root,String s){\\n        Trie node = root;\\n        for(int i=0;i<s.length();i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            if(node.children[ch]==null)\\n                node.children[ch] = new Trie();\\n            node = node.children[ch];\\n        }\\n        node.isEndOfWord = true;\\n    }\\n    public boolean search(Trie root, String s){\\n        Trie node = root;\\n        for(int i=0;i<s.length();i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            if(node.children[ch]==null)\\n                return false;\\n            node = node.children[ch];\\n        }\\n        return node.isEndOfWord;\\n    }\\n    \\n    List<String> list;\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Trie root = new Trie();\\n        for(String st:wordDict){\\n            addWord(root,st);\\n        }\\n        list = new ArrayList();\\n        findRemainingSubString(root,\"\",s,s.length());\\n        return list;\\n    }\\n    public boolean findRemainingSubString(Trie root,String str,String s,int total){\\n        if(s==null || s.length()==0)\\n            return true;\\n        for(int i=0;i<=s.length();i++){\\n            String st = str;\\n            if(search(root,s.substring(0,i))){\\n                st = st + s.substring(0,i)+ \" \";\\n                if(!findRemainingSubString(root,st,s.substring(i),total+1))\\n                    return false;\\n                if(st.trim().length()==total)\\n                    list.add(st.trim());\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163512,
                "title": "backtracking-javascript",
                "content": "```\\nvar wordBreak = function(s, wordDict) {\\n    /*\\n        1) create a hashmap and store words of dict by first\\n        letter\\n        2) iterate though the given string and if we found\\n        start letter in hashmap, we will get all the words in it\\n        and try to create a sentance starting from each of them\\n        3) for example, if we got c: [cat, cats] -> we take cat\\n        and see if this is a substring of the string, if it is,\\n        call recursion on the rest of the string, now the first letter is\\n        s -> check if we have any words starting from s\\n        4) add the path to an array and if the str is empty add to res and rturn\\n    */\\n    let dict = new Map();\\n    for (let word of wordDict) {\\n        if (!dict.has(word[0])) dict.set(word[0], []);\\n        dict.get(word[0]).push(word);\\n    }\\n    \\n    let sentences = [];\\n    function recurse(sentence, string) {\\n        if (string === \\'\\') {\\n            sentences.push(sentence.join(\\' \\'));\\n            return;\\n        }\\n        if (dict.has(string[0])) {\\n            let words = dict.get(string[0]);\\n            for (let word of words) {\\n                let len = word.length;\\n                let substring = string.substring(0, len);\\n                if (substring === word) {\\n                         sentence.push(word);\\n                         recurse([...sentence], string.substring(len));\\n                         sentence.pop();\\n                }\\n            }\\n        }\\n    }\\n    \\n    recurse([], s);\\n    return sentences;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar wordBreak = function(s, wordDict) {\\n    /*\\n        1) create a hashmap and store words of dict by first\\n        letter\\n        2) iterate though the given string and if we found\\n        start letter in hashmap, we will get all the words in it\\n        and try to create a sentance starting from each of them\\n        3) for example, if we got c: [cat, cats] -> we take cat\\n        and see if this is a substring of the string, if it is,\\n        call recursion on the rest of the string, now the first letter is\\n        s -> check if we have any words starting from s\\n        4) add the path to an array and if the str is empty add to res and rturn\\n    */\\n    let dict = new Map();\\n    for (let word of wordDict) {\\n        if (!dict.has(word[0])) dict.set(word[0], []);\\n        dict.get(word[0]).push(word);\\n    }\\n    \\n    let sentences = [];\\n    function recurse(sentence, string) {\\n        if (string === \\'\\') {\\n            sentences.push(sentence.join(\\' \\'));\\n            return;\\n        }\\n        if (dict.has(string[0])) {\\n            let words = dict.get(string[0]);\\n            for (let word of words) {\\n                let len = word.length;\\n                let substring = string.substring(0, len);\\n                if (substring === word) {\\n                         sentence.push(word);\\n                         recurse([...sentence], string.substring(len));\\n                         sentence.pop();\\n                }\\n            }\\n        }\\n    }\\n    \\n    recurse([], s);\\n    return sentences;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158796,
                "title": "my-concise-java-solution-memorized-dfs-backtracking-easy-to-understand",
                "content": "- iterate all the words in the wordDict, find if the prefix of the current string matches a word in the dictionary\\n- current string = prefix + suffix\\n- if true, we do the same operation to the suffix, and find its list of word break ==> **sublist**\\n- return the final list of word break of the original string by concating **prefix + sublist**\\n\\nThe time complexity is O(len(wordDict) ^ len(s / minWordLenInDict)) \\n\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        // dfs with memorization\\n        return dfs(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n    \\n    private List<String> dfs(String s, List<String> wordDict, HashMap<String, List<String>> memo) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                String next = s.substring(word.length());\\n                List<String> sublist = dfs(s.substring(word.length()), wordDict, memo);\\n                if (next.isEmpty()) res.add(word);\\n                else {\\n                    for(String sub: sublist) {\\n                        res.add(word + \" \" + sub);\\n                    }\\n                }            \\n            }\\n        } \\n        memo.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        // dfs with memorization\\n        return dfs(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n    \\n    private List<String> dfs(String s, List<String> wordDict, HashMap<String, List<String>> memo) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                String next = s.substring(word.length());\\n                List<String> sublist = dfs(s.substring(word.length()), wordDict, memo);\\n                if (next.isEmpty()) res.add(word);\\n                else {\\n                    for(String sub: sublist) {\\n                        res.add(word + \" \" + sub);\\n                    }\\n                }            \\n            }\\n        } \\n        memo.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984991,
                "title": "my-java-solution-backtracking-6ms",
                "content": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return backtrack(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n    \\n    private List<String> backtrack(String s, List<String> wordDict, HashMap<String, List<String>> mem) {\\n        if (mem.containsKey(s)) {\\n            return mem.get(s);\\n        }\\n        \\n        List<String> res = new ArrayList<String>();\\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                String next = s.substring(word.length());\\n                if (next.isEmpty()) res.add(word);\\n                else {\\n                    for(String sub: backtrack(next, wordDict, mem)) {\\n                        res.add(word + \" \" + sub);\\n                    }\\n                }\\n            }\\n        }\\n        mem.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return backtrack(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n    \\n    private List<String> backtrack(String s, List<String> wordDict, HashMap<String, List<String>> mem) {\\n        if (mem.containsKey(s)) {\\n            return mem.get(s);\\n        }\\n        \\n        List<String> res = new ArrayList<String>();\\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                String next = s.substring(word.length());\\n                if (next.isEmpty()) res.add(word);\\n                else {\\n                    for(String sub: backtrack(next, wordDict, mem)) {\\n                        res.add(word + \" \" + sub);\\n                    }\\n                }\\n            }\\n        }\\n        mem.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964708,
                "title": "java-simple-line-by-line-explanation-extra-optimization-over-cache-5ms",
                "content": "```\\nclass Solution {\\n    \\n    // initialize cache - given a string -> holds possible combinations of valid sentences with spaces\\n    Map < String, List < String >> cache = new HashMap < > ();\\n    \\n    public List < String > wordBreak(String s, List < String > wordDict) {\\n        int maxLen = 0;\\n        \\n        // initialize dictionary in hashset (!remember lookup in list is O(n) not O(1))\\n        Set < String > dict = new HashSet < > (wordDict);\\n        \\n        // optimization - find the largest word length in dictionary\\n        for (String word: wordDict) {\\n            maxLen = Math.max(word.length(), maxLen);\\n        }\\n\\n        return findValidSentences(s, dict, maxLen);\\n    }\\n\\n    public List < String > findValidSentences(String s, Set < String > dict, int maxLen) {\\n        \\n        // if cache already has possibilities with the string return list\\n        if (cache.containsKey(s)) {\\n            return cache.get(s);\\n        }\\n        \\n        // else build\\n        List < String > result = new ArrayList < > ();\\n        \\n        // if string itself a valid word add - helps avoiding extra space for last iteration like \"cats and dogs \" - notice extra space at end\\n        if (dict.contains(s)) {\\n            result.add(s);\\n        }\\n        \\n        /* find from len 1 till n-1 length (full word already added)\\n        \\n           break word = left + right parts\\n           \\n           notice in for loop below: we are only checking for left part to a max of maxLen in dictionary since\\n           \\n           if dict = [car,rabbit,bus]\\n           \\n           word = rabbitcarbus\\n           \\n           word = [rabbit]carbus - iterating window limited to maxLen\\n           \\n           iterating beyond this is useless, since maximum length word that can be formed is rabbit in dict,\\n           there cant be a word greater than longest word in dictionary - doubles the overall performance as input scales\\n      \\n        */\\n\\t\\t\\n        for (int i = 1; i <= maxLen && i < s.length(); i++) {\\n            \\n            // find left part\\n            String left = s.substring(0, i);\\n            \\n            // if left already in dictionary - find combinations with right part\\n            if (dict.contains(left)) {\\n                \\n                // find all possible valid combinations with right part\\n                List < String > rightSentences = findValidSentences(s.substring(i, s.length()), dict, maxLen);\\n\\n                // combine both left + right = valid sentence combinations for give String s\\n                for (String right: rightSentences) {\\n                    result.add(left + \" \" + right);\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        // cache it for repeated usage\\n        cache.put(s, result);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // initialize cache - given a string -> holds possible combinations of valid sentences with spaces\\n    Map < String, List < String >> cache = new HashMap < > ();\\n    \\n    public List < String > wordBreak(String s, List < String > wordDict) {\\n        int maxLen = 0;\\n        \\n        // initialize dictionary in hashset (!remember lookup in list is O(n) not O(1))\\n        Set < String > dict = new HashSet < > (wordDict);\\n        \\n        // optimization - find the largest word length in dictionary\\n        for (String word: wordDict) {\\n            maxLen = Math.max(word.length(), maxLen);\\n        }\\n\\n        return findValidSentences(s, dict, maxLen);\\n    }\\n\\n    public List < String > findValidSentences(String s, Set < String > dict, int maxLen) {\\n        \\n        // if cache already has possibilities with the string return list\\n        if (cache.containsKey(s)) {\\n            return cache.get(s);\\n        }\\n        \\n        // else build\\n        List < String > result = new ArrayList < > ();\\n        \\n        // if string itself a valid word add - helps avoiding extra space for last iteration like \"cats and dogs \" - notice extra space at end\\n        if (dict.contains(s)) {\\n            result.add(s);\\n        }\\n        \\n        /* find from len 1 till n-1 length (full word already added)\\n        \\n           break word = left + right parts\\n           \\n           notice in for loop below: we are only checking for left part to a max of maxLen in dictionary since\\n           \\n           if dict = [car,rabbit,bus]\\n           \\n           word = rabbitcarbus\\n           \\n           word = [rabbit]carbus - iterating window limited to maxLen\\n           \\n           iterating beyond this is useless, since maximum length word that can be formed is rabbit in dict,\\n           there cant be a word greater than longest word in dictionary - doubles the overall performance as input scales\\n      \\n        */\\n\\t\\t\\n        for (int i = 1; i <= maxLen && i < s.length(); i++) {\\n            \\n            // find left part\\n            String left = s.substring(0, i);\\n            \\n            // if left already in dictionary - find combinations with right part\\n            if (dict.contains(left)) {\\n                \\n                // find all possible valid combinations with right part\\n                List < String > rightSentences = findValidSentences(s.substring(i, s.length()), dict, maxLen);\\n\\n                // combine both left + right = valid sentence combinations for give String s\\n                for (String right: rightSentences) {\\n                    result.add(left + \" \" + right);\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        // cache it for repeated usage\\n        cache.put(s, result);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906710,
                "title": "4-ms-c-1-d-dp-solution-easy-approach",
                "content": "* Store dictionary words in set for quick access\\n* Helper function solves for the subproblems of the main problem\\n* vdp array to check if the dp value is available or not\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> dict;\\n    int n;\\n    string str;\\n    \\n    vector<string> helper(int i, vector<vector<string>> &dp, bool vdp[])\\n    {\\n        vector<string> tv;\\n        if(i==n)\\n        {\\n            return tv;\\n        }\\n        if(vdp[i])\\n        {\\n            return dp[i];\\n        }\\n        string ts = \"\";\\n        for(int k = i; k<n; k++)\\n        {\\n            ts+=str[k];\\n            if(dict.find(ts) == dict.end())\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                \\n                if(k+1==n)\\n                {\\n                    tv.push_back(ts);\\n                    continue;\\n                }\\n                vector<string> hv = helper(k+1, dp, vdp);\\n                for(int x = 0; x<hv.size(); x++)\\n                {\\n                    tv.push_back(ts+\" \"+hv[x]);\\n                }\\n            }\\n        }\\n        dp[i] = tv;\\n        vdp[i] = 1;\\n        return tv;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        n = s.length();\\n        str = s;\\n        for(int i =0; i<wordDict.size(); i++)\\n        {\\n            dict.insert(wordDict[i]);\\n        }\\n        vector<vector<string>> dp(n);\\n        bool vdp[n];\\n        memset(vdp,0,sizeof(vdp));\\n        return helper(0,dp,vdp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> dict;\\n    int n;\\n    string str;\\n    \\n    vector<string> helper(int i, vector<vector<string>> &dp, bool vdp[])\\n    {\\n        vector<string> tv;\\n        if(i==n)\\n        {\\n            return tv;\\n        }\\n        if(vdp[i])\\n        {\\n            return dp[i];\\n        }\\n        string ts = \"\";\\n        for(int k = i; k<n; k++)\\n        {\\n            ts+=str[k];\\n            if(dict.find(ts) == dict.end())\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                \\n                if(k+1==n)\\n                {\\n                    tv.push_back(ts);\\n                    continue;\\n                }\\n                vector<string> hv = helper(k+1, dp, vdp);\\n                for(int x = 0; x<hv.size(); x++)\\n                {\\n                    tv.push_back(ts+\" \"+hv[x]);\\n                }\\n            }\\n        }\\n        dp[i] = tv;\\n        vdp[i] = 1;\\n        return tv;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        n = s.length();\\n        str = s;\\n        for(int i =0; i<wordDict.size(); i++)\\n        {\\n            dict.insert(wordDict[i]);\\n        }\\n        vector<vector<string>> dp(n);\\n        bool vdp[n];\\n        memset(vdp,0,sizeof(vdp));\\n        return helper(0,dp,vdp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780244,
                "title": "top-down-very-clean-memo-code-java",
                "content": "```\\nclass Solution { //TOP DOWN, VERY CLEAN MEMO CODE\\n    Map<String, List<String>> memo = new HashMap<>();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                if (s.length() == word.length())\\n                    res.add(word);\\n                else {\\n                    List<String> sub = wordBreak(s.substring(word.length()), wordDict);\\n                    for (String w : sub)\\n                        res.add(word + \" \" + w);\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, res);\\n        return memo.get(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution { //TOP DOWN, VERY CLEAN MEMO CODE\\n    Map<String, List<String>> memo = new HashMap<>();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                if (s.length() == word.length())\\n                    res.add(word);\\n                else {\\n                    List<String> sub = wordBreak(s.substring(word.length()), wordDict);\\n                    for (String w : sub)\\n                        res.add(word + \" \" + w);\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, res);\\n        return memo.get(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769290,
                "title": "go-0-ms-dp-solution-beats-100-time",
                "content": "```\\nfunc wordBreak(s string, wordDict []string) []string {\\n    dp := make(map[string][]string)    \\n    set := make(map[string]bool)\\n    for _, v := range wordDict {\\n        set[v] = true\\n    }\\n    return generate(s, dp, set)\\n}\\n\\nfunc generate(s string, dp map[string][]string, set map[string]bool) []string{\\n    \\n    if val , ok := dp[s]; ok {\\n        return val\\n    }\\n    \\n    var output []string\\n    \\n    if len(s) == 0 {\\n        output = append(output, \"\")\\n        return output\\n    }\\n    \\n    var prefix string\\n    \\n    for i := 0; i < len(s); i++ {\\n        prefix += string(s[i])\\n        \\n        if _, ok := set[prefix]; ok {        \\n            var smallOutput []string = generate(s[i + 1 : ], dp, set)\\n            for _, val := range smallOutput {\\n                if len(val) > 0 {\\n                    output = append(output, prefix + \" \" + val)   \\n                }else {\\n                    output = append(output, prefix)\\n                }\\n            }\\n        }\\n    }\\n    \\n    dp[s] = output\\n    return output\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc wordBreak(s string, wordDict []string) []string {\\n    dp := make(map[string][]string)    \\n    set := make(map[string]bool)\\n    for _, v := range wordDict {\\n        set[v] = true\\n    }\\n    return generate(s, dp, set)\\n}\\n\\nfunc generate(s string, dp map[string][]string, set map[string]bool) []string{\\n    \\n    if val , ok := dp[s]; ok {\\n        return val\\n    }\\n    \\n    var output []string\\n    \\n    if len(s) == 0 {\\n        output = append(output, \"\")\\n        return output\\n    }\\n    \\n    var prefix string\\n    \\n    for i := 0; i < len(s); i++ {\\n        prefix += string(s[i])\\n        \\n        if _, ok := set[prefix]; ok {        \\n            var smallOutput []string = generate(s[i + 1 : ], dp, set)\\n            for _, val := range smallOutput {\\n                if len(val) > 0 {\\n                    output = append(output, prefix + \" \" + val)   \\n                }else {\\n                    output = append(output, prefix)\\n                }\\n            }\\n        }\\n    }\\n    \\n    dp[s] = output\\n    return output\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764419,
                "title": "java-recursive-memoized-solution-w-video-explanation",
                "content": "https://www.youtube.com/watch?v=9-grHHGUVls\\n```\\nclass Solution {\\n    Map<String, List<String>> memo = new HashMap<>();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                if (s.length() == word.length())\\n                    res.add(word);\\n                else {\\n                    List<String> sub = wordBreak(s.substring(word.length()), wordDict);\\n                    for (String w : sub)\\n                        res.add(word + \" \" + w);\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, res);\\n        return memo.get(s);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, List<String>> memo = new HashMap<>();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                if (s.length() == word.length())\\n                    res.add(word);\\n                else {\\n                    List<String> sub = wordBreak(s.substring(word.length()), wordDict);\\n                    for (String w : sub)\\n                        res.add(word + \" \" + w);\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, res);\\n        return memo.get(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764113,
                "title": "kotlin-concise-solution",
                "content": "```\\nclass Solution {\\n\\n    fun wordBreak(s: String, wordDict: List<String>): List<String> {\\n        return buildWord(s, wordDict, hashMapOf())\\n    }\\n\\n    private fun buildWord(\\n        text: String,\\n        wordDict: List<String>,\\n        map: HashMap<String, LinkedList<String>>\\n    ): List<String> {\\n        if (map.containsKey(text)) return map[text]!!\\n\\n        val result = LinkedList<String>()\\n        if (text.isEmpty()) return result.apply { add(\"\") }\\n\\n        for (word in wordDict) {\\n            if (text.startsWith(word)) {\\n                buildWord(text.substring(word.length), wordDict, map)\\n                    .forEach { subWord -> result.add(\"$word${if (subWord.isEmpty()) \"\" else \" \"}$subWord\") }\\n            }\\n        }\\n\\n        map[text] = result\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    fun wordBreak(s: String, wordDict: List<String>): List<String> {\\n        return buildWord(s, wordDict, hashMapOf())\\n    }\\n\\n    private fun buildWord(\\n        text: String,\\n        wordDict: List<String>,\\n        map: HashMap<String, LinkedList<String>>\\n    ): List<String> {\\n        if (map.containsKey(text)) return map[text]!!\\n\\n        val result = LinkedList<String>()\\n        if (text.isEmpty()) return result.apply { add(\"\") }\\n\\n        for (word in wordDict) {\\n            if (text.startsWith(word)) {\\n                buildWord(text.substring(word.length), wordDict, map)\\n                    .forEach { subWord -> result.add(\"$word${if (subWord.isEmpty()) \"\" else \" \"}$subWord\") }\\n            }\\n        }\\n\\n        map[text] = result\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763711,
                "title": "java-backtrackig-memoization",
                "content": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n    \\n        Set<String> dict = new HashSet<>(wordDict);\\n        Map<String,List<String>> memo = new HashMap<>();\\n          \\n       return helper(dict, s , memo);\\n    }\\n    \\n    \\n    private List<String> helper(Set<String> dict , String s , Map<String,List<String>> memo){\\n        \\n        if(memo.containsKey(s))\\n            return memo.get(s);\\n         \\n        List<String> ans = new ArrayList<>();\\n        \\n        if(s == null || s.isEmpty()){\\n            return ans;\\n          }\\n  \\n        int N = s.length();    \\n      \\n        for(String word : dict){\\n         \\n            if(!s.startsWith(word)){\\n               continue;\\n            } \\n            int len = word.length();\\n           if(N == len){\\n               ans.add(word);\\n           }else{\\n               List<String> res = helper(dict , s.substring(len),memo );\\n               for(String str : res){\\n                   ans.add( word + \" \" + str);\\n               }\\n           }\\n        }\\n        memo.put(s,ans);\\n      return ans;  \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n    \\n        Set<String> dict = new HashSet<>(wordDict);\\n        Map<String,List<String>> memo = new HashMap<>();\\n          \\n       return helper(dict, s , memo);\\n    }\\n    \\n    \\n    private List<String> helper(Set<String> dict , String s , Map<String,List<String>> memo){\\n        \\n        if(memo.containsKey(s))\\n            return memo.get(s);\\n         \\n        List<String> ans = new ArrayList<>();\\n        \\n        if(s == null || s.isEmpty()){\\n            return ans;\\n          }\\n  \\n        int N = s.length();    \\n      \\n        for(String word : dict){\\n         \\n            if(!s.startsWith(word)){\\n               continue;\\n            } \\n            int len = word.length();\\n           if(N == len){\\n               ans.add(word);\\n           }else{\\n               List<String> res = helper(dict , s.substring(len),memo );\\n               for(String str : res){\\n                   ans.add( word + \" \" + str);\\n               }\\n           }\\n        }\\n        memo.put(s,ans);\\n      return ans;  \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763410,
                "title": "java-80-fast-explained-code",
                "content": "If you found the solution helpful, kindly like and upvote. :)\\n\\n**MAIN IDEA**\\n1. Take the words from the dictionary, and check if the target String starts with that.\\n2. If it does, we will generate all the valid substrings, and simply add that to our result.\\n\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return wordHelper(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n\\n\\tprivate List<String> wordHelper(String s, List<String> wordDict, Map<String, List<String>> cache) {\\n\\t\\tif(cache.containsKey(s))\\n\\t\\t\\treturn cache.get(s);\\n\\t\\tList<String> res= new ArrayList<String>();\\n\\t\\tif(s.length()==0) \\n\\t\\t{\\n\\t\\t\\tres.add(\"\");\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tfor(String word:wordDict)\\n\\t\\t{\\n\\t\\t\\t//Check if the word starts with the dictionary word\\n\\t\\t\\tif(s.startsWith(word))\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Now we need to find all the subsets of in the String from the dict\\n\\t\\t\\t\\t//and add them to a List\\n\\t\\t\\t\\tList<String> subStr= wordHelper(s.substring(word.length()), wordDict, cache);\\n\\t\\t\\t\\t//Now we have all the subsets, we will now start making our results\\n\\t\\t\\t\\tfor(String subs: subStr)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString space= subs.isEmpty()? \"\":\" \";\\n\\t\\t\\t\\t\\tres.add(word+space+subs);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcache.put(s, res);\\n\\t\\treturn res;       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return wordHelper(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n\\n\\tprivate List<String> wordHelper(String s, List<String> wordDict, Map<String, List<String>> cache) {\\n\\t\\tif(cache.containsKey(s))\\n\\t\\t\\treturn cache.get(s);\\n\\t\\tList<String> res= new ArrayList<String>();\\n\\t\\tif(s.length()==0) \\n\\t\\t{\\n\\t\\t\\tres.add(\"\");\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tfor(String word:wordDict)\\n\\t\\t{\\n\\t\\t\\t//Check if the word starts with the dictionary word\\n\\t\\t\\tif(s.startsWith(word))\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Now we need to find all the subsets of in the String from the dict\\n\\t\\t\\t\\t//and add them to a List\\n\\t\\t\\t\\tList<String> subStr= wordHelper(s.substring(word.length()), wordDict, cache);\\n\\t\\t\\t\\t//Now we have all the subsets, we will now start making our results\\n\\t\\t\\t\\tfor(String subs: subStr)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString space= subs.isEmpty()? \"\":\" \";\\n\\t\\t\\t\\t\\tres.add(word+space+subs);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcache.put(s, res);\\n\\t\\treturn res;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763317,
                "title": "word-break-2-c-solution-with-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<string>> word_map;\\n    vector<vector<string>> dp;\\n    vector<bool> visited;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        n = s.length();\\n        word_map = vector<vector<string>> (n);\\n        dp = vector<vector<string>>(n);\\n        visited = vector<bool>(n, false);\\n        \\n        populate_word_map(s, wordDict);\\n        create_sentences(0);\\n        \\n        return dp[0];\\n    }\\n    \\n    void populate_word_map(const string& s, vector<string>& wordDict) {\\n        int pos, l;\\n        for (auto& word : wordDict) {\\n            pos = 0;\\n            l = word.length();\\n            while ((pos = s.find(word, pos)) != string::npos) {\\n                word_map[pos].push_back(word);\\n                pos ++;\\n            }\\n        }\\n    }\\n    \\n    void create_sentences(int pos) {\\n        for (auto& word : word_map[pos]) {\\n            int new_pos = pos + word.length();\\n            \\n            if (new_pos == n) {\\n                dp[pos].push_back(word);\\n            } else {\\n                if (!visited[new_pos])\\n                    create_sentences(new_pos);\\n                for (auto& sentence : dp[new_pos])\\n                    dp[pos].push_back(word + \" \" + sentence);\\n            }\\n        }\\n        \\n        visited[pos] = true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<string>> word_map;\\n    vector<vector<string>> dp;\\n    vector<bool> visited;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        n = s.length();\\n        word_map = vector<vector<string>> (n);\\n        dp = vector<vector<string>>(n);\\n        visited = vector<bool>(n, false);\\n        \\n        populate_word_map(s, wordDict);\\n        create_sentences(0);\\n        \\n        return dp[0];\\n    }\\n    \\n    void populate_word_map(const string& s, vector<string>& wordDict) {\\n        int pos, l;\\n        for (auto& word : wordDict) {\\n            pos = 0;\\n            l = word.length();\\n            while ((pos = s.find(word, pos)) != string::npos) {\\n                word_map[pos].push_back(word);\\n                pos ++;\\n            }\\n        }\\n    }\\n    \\n    void create_sentences(int pos) {\\n        for (auto& word : word_map[pos]) {\\n            int new_pos = pos + word.length();\\n            \\n            if (new_pos == n) {\\n                dp[pos].push_back(word);\\n            } else {\\n                if (!visited[new_pos])\\n                    create_sentences(new_pos);\\n                for (auto& sentence : dp[new_pos])\\n                    dp[pos].push_back(word + \" \" + sentence);\\n            }\\n        }\\n        \\n        visited[pos] = true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763276,
                "title": "c-dfs-with-cache",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n       \\tunordered_set<string> dict;\\n       \\tfor (auto w : wordDict) {\\n       \\t\\tdict.insert(w);\\n       \\t}\\n\\n       \\tvector<string> sentences;\\n       \\tunordered_map<int, vector<string>> cache;\\n       \\tdfs(s, 0, dict, sentences, cache);\\n       \\treturn sentences;\\n    }\\n\\n    void dfs(string &s, int idx, unordered_set<string> &dict, vector<string> &sentences, unordered_map<int, vector<string>> &cache) {\\n    \\tint n = s.length();\\n    \\tif (n == idx) {\\n    \\t\\tsentences.push_back(\"\");\\n    \\t\\treturn;\\n    \\t}\\n\\n    \\tstring word;\\n    \\tfor (int i = idx; i < n; ++i) {\\n    \\t\\tword.push_back(s[i]);\\n    \\t\\tif (dict.count(word)) {\\n    \\t\\t\\tvector<string> sents;\\n                if (cache.count(i + 1)) {\\n                    sents = cache[i + 1];\\n                } else {\\n    \\t\\t\\t    dfs(s, i + 1, dict, sents, cache);\\n                    cache[i + 1] = sents;\\n                }\\n    \\t\\t\\tfor (auto s : sents) {\\n    \\t\\t\\t\\tsentences.push_back(word);\\n    \\t\\t\\t\\tif (!s.empty()) {\\n    \\t\\t\\t\\t\\tsentences.back() += \" \" + s;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n       \\tunordered_set<string> dict;\\n       \\tfor (auto w : wordDict) {\\n       \\t\\tdict.insert(w);\\n       \\t}\\n\\n       \\tvector<string> sentences;\\n       \\tunordered_map<int, vector<string>> cache;\\n       \\tdfs(s, 0, dict, sentences, cache);\\n       \\treturn sentences;\\n    }\\n\\n    void dfs(string &s, int idx, unordered_set<string> &dict, vector<string> &sentences, unordered_map<int, vector<string>> &cache) {\\n    \\tint n = s.length();\\n    \\tif (n == idx) {\\n    \\t\\tsentences.push_back(\"\");\\n    \\t\\treturn;\\n    \\t}\\n\\n    \\tstring word;\\n    \\tfor (int i = idx; i < n; ++i) {\\n    \\t\\tword.push_back(s[i]);\\n    \\t\\tif (dict.count(word)) {\\n    \\t\\t\\tvector<string> sents;\\n                if (cache.count(i + 1)) {\\n                    sents = cache[i + 1];\\n                } else {\\n    \\t\\t\\t    dfs(s, i + 1, dict, sents, cache);\\n                    cache[i + 1] = sents;\\n                }\\n    \\t\\t\\tfor (auto s : sents) {\\n    \\t\\t\\t\\tsentences.push_back(word);\\n    \\t\\t\\t\\tif (!s.empty()) {\\n    \\t\\t\\t\\t\\tsentences.back() += \" \" + s;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706993,
                "title": "python3-top-down-dp",
                "content": "Algo: \\nDefine `fn(i)` to be the sentences formed by `s[i:]`. Then, the recursion satisfies \\n\\n`fn(i) = [[word] + x for x in fn(i + len(word)] for word in wordDict if s[i:].startswith(word)` \\n\\n(56ms, 38.79%)\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        wordDict = set(wordDict) #edit: better performance \\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return sentences of s[i:]\"\"\"\\n            if i == len(s): return [[]]\\n            ans = []\\n            for ii in range(i+1, len(s)+1):\\n                if s[i:ii] in wordDict: \\n                    ans.extend([s[i:ii]] + x for x in fn(ii))\\n            return ans \\n        \\n        return [\" \".join(x) for x in fn(0)]\\n```\\n\\nAlternatively one could go forward path (40ms, 84.72%) like below \\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return sentences from s[:i]\"\"\"\\n            if i == 0: return [[]] #boundary condition \\n            ans = []\\n            for word in wordDict: \\n                if s[i-len(word):i] == word:\\n                    ans.extend([x + [word] for x in fn(i-len(word))])\\n            return ans \\n            \\n        return [\" \".join(x) for x in fn(len(s))]\\n```\\n\\nThe bottom-up implementation is very easy to go TLE. The reason is that it doesn\\'t a lot of unnecessary calculations while top-down only does what\\'s required.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        wordDict = set(wordDict) #edit: better performance \\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return sentences of s[i:]\"\"\"\\n            if i == len(s): return [[]]\\n            ans = []\\n            for ii in range(i+1, len(s)+1):\\n                if s[i:ii] in wordDict: \\n                    ans.extend([s[i:ii]] + x for x in fn(ii))\\n            return ans \\n        \\n        return [\" \".join(x) for x in fn(0)]\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return sentences from s[:i]\"\"\"\\n            if i == 0: return [[]] #boundary condition \\n            ans = []\\n            for word in wordDict: \\n                if s[i-len(word):i] == word:\\n                    ans.extend([x + [word] for x in fn(i-len(word))])\\n            return ans \\n            \\n        return [\" \".join(x) for x in fn(len(s))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670116,
                "title": "java-backtrack-solusion-with-detail-comments-and-thoughts-step-by-step",
                "content": "This is kind of  a String-Problem. So the idea first come up to my mind is BackTrack!!\\nBackTrack is an useful method to traverse all the combinations of string-like brute force. \\nAlso the solusion is really easy to come up with!\\n\\n```\\n public List<String> wordBreak1(String s, List<String> wordDict) {     \\n        List<String> res = new ArrayList<>();\\n        int n=s.length();\\n        if(n<=0) return res; \\n        Set<String> dic = new HashSet<>(wordDict);\\n        \\n        backTrack1(res,\"\",s,dic,0);\\n        \\n        return res;\\n    }\\n    //TLE \\n    void backTrack1(List<String> res, String path, String s, Set<String> dic, int idx ){\\n        if(idx==s.length()){\\n            res.add(path);\\n            return;\\n        }\\n        for(int i=idx;i<s.length();i++){\\n            String cur=s.substring(idx,i+1);\\n            if(dic.contains(cur)){\\n                if(idx==0)  backTrack1(res, cur,s,dic,i+1);\\n                else backTrack1(res, path+\" \"+ cur,s,dic,i+1);\\n            }\\n        }   \\n    }\\n```\\nThis solusion works correctly! But, in some extremely conditions, it will TLE. \\nWe know the Time Complexity of BackTrack algorithm is **expotional**( O(N^M) N is the longth of string).\\n\\nNext step is to improve our solution. \\nLets see the parameters of the method, everytime we use a string to concatenate with other string.\\nSo we can use StringBuilder to replace it. However, only change this, still TLE.\\n\\nNext, we thought to use some extra memory to improve the running time. It not difficult to come up with the strategy-- **Space exchange Time**!\\n\\nThat is why I thought to use a HashMap to store all the sub-problem results. Each time we get the sub-result only use O(1) time.  Here is the code!\\n\\n```\\n  public List<String> wordBreak(String s, List<String> wordDict) {\\n        \\n        List<String> res = new ArrayList<>();\\n        int n=s.length();\\n\\t\\t//This is the conner case\\n        if(n<=0) return res;\\n        \\n\\t\\t//change the List to the Set, becasue we always want to check with it.\\n        Set<String> dic = new HashSet<>(wordDict);\\n        \\n        res =backTrack(s,dic);\\n        \\n        return res;\\n    }\\n\\t\\n    //Using hashMap to store the sub-problem results\\n    HashMap<String,List<String>> map = new HashMap<>();\\n    \\n    List<String> backTrack(String s, Set<String> dic){\\n       \\n        List<String> res  = new ArrayList<>();\\n\\t\\t//this is the conner case\\n        if(s.length()<=0){\\n            res.add(\"\");\\n            return res;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n\\t\\t\\t//we get cur split string\\n            String cur=s.substring(0,i+1);\\n            \\n            if(dic.contains(cur)){  \\n                \\n                String next=s.substring(i+1);\\n                List<String> subans =new ArrayList<>();\\n\\t\\t\\t\\t//here our map used\\n                if(map.containsKey(next)){\\n                    subans=map.get(next);\\n                }else{\\n                    subans = backTrack(next,dic);\\n                } \\n\\t\\t\\t\\t//combine the total answer\\n                for(String str:subans){            \\n                    if(str.equals(\"\")) res.add(cur);\\n                    else res.add(cur+\" \"+str);\\n                }\\n            }\\n        }\\n\\t\\t//add this level result to the map\\n        map.put(s,res);\\n        return res;  \\n   }\\n```\\nIf you like my idea, please vote it!!",
                "solutionTags": [],
                "code": "```\\n public List<String> wordBreak1(String s, List<String> wordDict) {     \\n        List<String> res = new ArrayList<>();\\n        int n=s.length();\\n        if(n<=0) return res; \\n        Set<String> dic = new HashSet<>(wordDict);\\n        \\n        backTrack1(res,\"\",s,dic,0);\\n        \\n        return res;\\n    }\\n    //TLE \\n    void backTrack1(List<String> res, String path, String s, Set<String> dic, int idx ){\\n        if(idx==s.length()){\\n            res.add(path);\\n            return;\\n        }\\n        for(int i=idx;i<s.length();i++){\\n            String cur=s.substring(idx,i+1);\\n            if(dic.contains(cur)){\\n                if(idx==0)  backTrack1(res, cur,s,dic,i+1);\\n                else backTrack1(res, path+\" \"+ cur,s,dic,i+1);\\n            }\\n        }   \\n    }\\n```\n```\\n  public List<String> wordBreak(String s, List<String> wordDict) {\\n        \\n        List<String> res = new ArrayList<>();\\n        int n=s.length();\\n\\t\\t//This is the conner case\\n        if(n<=0) return res;\\n        \\n\\t\\t//change the List to the Set, becasue we always want to check with it.\\n        Set<String> dic = new HashSet<>(wordDict);\\n        \\n        res =backTrack(s,dic);\\n        \\n        return res;\\n    }\\n\\t\\n    //Using hashMap to store the sub-problem results\\n    HashMap<String,List<String>> map = new HashMap<>();\\n    \\n    List<String> backTrack(String s, Set<String> dic){\\n       \\n        List<String> res  = new ArrayList<>();\\n\\t\\t//this is the conner case\\n        if(s.length()<=0){\\n            res.add(\"\");\\n            return res;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n\\t\\t\\t//we get cur split string\\n            String cur=s.substring(0,i+1);\\n            \\n            if(dic.contains(cur)){  \\n                \\n                String next=s.substring(i+1);\\n                List<String> subans =new ArrayList<>();\\n\\t\\t\\t\\t//here our map used\\n                if(map.containsKey(next)){\\n                    subans=map.get(next);\\n                }else{\\n                    subans = backTrack(next,dic);\\n                } \\n\\t\\t\\t\\t//combine the total answer\\n                for(String str:subans){            \\n                    if(str.equals(\"\")) res.add(cur);\\n                    else res.add(cur+\" \"+str);\\n                }\\n            }\\n        }\\n\\t\\t//add this level result to the map\\n        map.put(s,res);\\n        return res;  \\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 627264,
                "title": "simple-c-solution-dp-and-dfs",
                "content": "Base On Word Break I , I will use  vector<vector<string>> dp to keep the possible candidates\\n\\n```\\nvector<string> wordBreak(string s, vector<string>& dict) {\\n        vector<string> res;\\n        if (dict.size() == 0) return res;\\n        int n = s.size();\\n        vector<vector<string>> dp(n+1, vector<string>());\\n        dp[0] = {\" \"};\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >=0; --j) {\\n                if (!dp[j].empty()) {\\n                    string word = s.substr(j, i-j);\\n                    if (find(dict.begin(), dict.end(), word) != dict.end()) {\\n                        dp[i].push_back(word);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        dfs(n, dp, \"\", res);\\n        \\n        return res;\\n    }\\n    \\n    void dfs(int loc, vector<vector<string>> dp, string word, vector<string> &res) {\\n        if (loc == 0) {\\n            res.push_back(word);\\n            return;\\n        }\\n        \\n        for (auto subword : dp[loc]) {\\n            int len = subword.size();\\n            string updateword = subword + (word.empty() ? \"\" : \" \")  + word;\\n            dfs(loc - len, dp, updateword, res);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> wordBreak(string s, vector<string>& dict) {\\n        vector<string> res;\\n        if (dict.size() == 0) return res;\\n        int n = s.size();\\n        vector<vector<string>> dp(n+1, vector<string>());\\n        dp[0] = {\" \"};\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >=0; --j) {\\n                if (!dp[j].empty()) {\\n                    string word = s.substr(j, i-j);\\n                    if (find(dict.begin(), dict.end(), word) != dict.end()) {\\n                        dp[i].push_back(word);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        dfs(n, dp, \"\", res);\\n        \\n        return res;\\n    }\\n    \\n    void dfs(int loc, vector<vector<string>> dp, string word, vector<string> &res) {\\n        if (loc == 0) {\\n            res.push_back(word);\\n            return;\\n        }\\n        \\n        for (auto subword : dp[loc]) {\\n            int len = subword.size();\\n            string updateword = subword + (word.empty() ? \"\" : \" \")  + word;\\n            dfs(loc - len, dp, updateword, res);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 627065,
                "title": "java-6-ms-faster-than-92-33-trie-based-dfs-approach",
                "content": "I implemented a Trie based DP approach to generate all combinations of words from the dictionary of words using the input String.\\n```\\npublic List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if(s.isEmpty())\\n            return res;\\n        \\n        Trie root = new Trie();\\n        buildTrie(wordDict, root);\\n        Map<String, List<String>> map = new HashMap<>();\\n        buildWord(s, root, map);\\n        \\n        return map.get(s);\\n    }\\n    \\n    List<String> buildWord(String s, Trie root, Map<String, List<String>> map){\\n        if(map.containsKey(s)){\\n            return map.get(s);\\n        }\\n        \\n       List<String> res = new ArrayList<>();\\n        if(s.isEmpty()){\\n            res.add(\"\");\\n        }else{\\n            Trie node = root;\\n            for(int i=0;i<s.length();i++){\\n                \\n                char c = s.charAt(i);    \\n                if(node.next.containsKey(c)){\\n                    node = node.next.get(c);\\n                    \\n                    if(node.word != null){\\n                        String str = i == s.length() ? \"\" : s.substring(i+1);\\n                        List<String> data = buildWord(str, root, map );\\n                        \\n                        for(String s1: data){\\n                            res.add(node.word + (s1.isEmpty() ? \"\" : \" \" + s1));\\n                        }\\n                    }\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        map.put(s, res);\\n        return res;  \\n    }\\n    \\n    void buildTrie(List<String> wordDict, Trie root){ \\n        for(String w: wordDict){\\n            Trie node = root;   \\n            for(char c: w.toCharArray()){\\n                Trie n = null;\\n                if(!node.next.containsKey(c)){\\n                    n = new Trie();\\n                    node.next.put(c, n);\\n                }else{\\n                    n = node.next.get(c);\\n                }\\n                \\n                node = n; \\n            }\\n            node.word = w;\\n        }\\n    }\\n    \\n    class Trie{\\n        Map<Character, Trie> next = new HashMap<>();\\n        String word;\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "I implemented a Trie based DP approach to generate all combinations of words from the dictionary of words using the input String.\\n```\\npublic List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if(s.isEmpty())\\n            return res;\\n        \\n        Trie root = new Trie();\\n        buildTrie(wordDict, root);\\n        Map<String, List<String>> map = new HashMap<>();\\n        buildWord(s, root, map);\\n        \\n        return map.get(s);\\n    }\\n    \\n    List<String> buildWord(String s, Trie root, Map<String, List<String>> map){\\n        if(map.containsKey(s)){\\n            return map.get(s);\\n        }\\n        \\n       List<String> res = new ArrayList<>();\\n        if(s.isEmpty()){\\n            res.add(\"\");\\n        }else{\\n            Trie node = root;\\n            for(int i=0;i<s.length();i++){\\n                \\n                char c = s.charAt(i);    \\n                if(node.next.containsKey(c)){\\n                    node = node.next.get(c);\\n                    \\n                    if(node.word != null){\\n                        String str = i == s.length() ? \"\" : s.substring(i+1);\\n                        List<String> data = buildWord(str, root, map );\\n                        \\n                        for(String s1: data){\\n                            res.add(node.word + (s1.isEmpty() ? \"\" : \" \" + s1));\\n                        }\\n                    }\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        map.put(s, res);\\n        return res;  \\n    }\\n    \\n    void buildTrie(List<String> wordDict, Trie root){ \\n        for(String w: wordDict){\\n            Trie node = root;   \\n            for(char c: w.toCharArray()){\\n                Trie n = null;\\n                if(!node.next.containsKey(c)){\\n                    n = new Trie();\\n                    node.next.put(c, n);\\n                }else{\\n                    n = node.next.get(c);\\n                }\\n                \\n                node = n; \\n            }\\n            node.word = w;\\n        }\\n    }\\n    \\n    class Trie{\\n        Map<Character, Trie> next = new HashMap<>();\\n        String word;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 609287,
                "title": "c-dp-memoisation-20-lines-61-on-time-70-on-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string& s, int idx, unordered_set<string>& words, unordered_map<int, vector<string>>& dp) {\\n        if (dp.count(idx) == 0) {\\n            for (int i = idx-1; i >= 0; i--) {\\n                string tail = s.substr(i, idx-i);\\n                if (words.count(tail) == 0) continue;\\n                for (string sol : wordBreak(s, i, words, dp)) {\\n                    dp[idx].push_back(sol.append(tail).append(\" \"));\\n                }\\n            }\\n        }\\n        \\n        return dp[idx];\\n    }\\n    \\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> words(wordDict.cbegin(), wordDict.cend());\\n        unordered_map<int, vector<string>> dp;\\n        dp[0] = {\"\"};\\n\\n        vector<string> result = wordBreak(s, s.length(), words, dp);\\n        for (string& sentence : result) sentence.pop_back();\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string& s, int idx, unordered_set<string>& words, unordered_map<int, vector<string>>& dp) {\\n        if (dp.count(idx) == 0) {\\n            for (int i = idx-1; i >= 0; i--) {\\n                string tail = s.substr(i, idx-i);\\n                if (words.count(tail) == 0) continue;\\n                for (string sol : wordBreak(s, i, words, dp)) {\\n                    dp[idx].push_back(sol.append(tail).append(\" \"));\\n                }\\n            }\\n        }\\n        \\n        return dp[idx];\\n    }\\n    \\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> words(wordDict.cbegin(), wordDict.cend());\\n        unordered_map<int, vector<string>> dp;\\n        dp[0] = {\"\"};\\n\\n        vector<string> result = wordBreak(s, s.length(), words, dp);\\n        for (string& sentence : result) sentence.pop_back();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606894,
                "title": "python-solution-and-thought-process",
                "content": "**Step 1: Identify Subproblems:**\\n```\\ndp[i] = all possible sentences in s[i:]\\ndp[i] =\\n    res = []\\n    for word in wordDict:\\n        if word != s[i:i+len(word)]:\\n            continue\\n        elif len(word) == len(s)-i:\\n            res.append(word)\\n        else:\\n            for sentence in dp[i+len(word)]:\\n                res.append(word + \\' \\' + sentence)\\n    return res\\n```\\n\\n**2. Analyze options for implementation**\\nTop down recursive solution time complexity:\\n```\\nN = len(wordDict)\\nM = min([len(word) for word in wordDict])\\nS = len(sentence)\\nO(N*N^S*S/M) = O(NN^2S/M)\\n```\\n**Note:** I\\'m not 100% sure if the top down time complexity analysis I did was correct when taking memoization into account. If someone could chime in here?\\n\\nBottom up iterative solution time complexity:\\n```\\nN = len(wordDict)\\nM = min([len(word) for word in wordDict])\\nS = len(sentence)\\nO(S*N*N^S) = O(NN^2S)\\n```\\n\\nChoose top down recursive solution to avoid TLE.\\n\\n**3. Python Code**\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        @lru_cache(maxsize=None)\\n        def dp(i):\\n            res = []\\n            for word in wordDict:\\n                if word != s[i:i+len(word)]:\\n                    continue\\n                elif len(word) == len(s)-i:\\n                    res.append(word)\\n                else:\\n                    for sentence in dp(i+len(word)):\\n                        res.append(word + \\' \\' + sentence)        \\n            return res\\n        \\n        return dp(0)\\n```\\n\\nNote:\\n* Code is based on https://leetcode.com/problems/word-break-ii/discuss/44311/Python-easy-to-understand-solution",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndp[i] = all possible sentences in s[i:]\\ndp[i] =\\n    res = []\\n    for word in wordDict:\\n        if word != s[i:i+len(word)]:\\n            continue\\n        elif len(word) == len(s)-i:\\n            res.append(word)\\n        else:\\n            for sentence in dp[i+len(word)]:\\n                res.append(word + \\' \\' + sentence)\\n    return res\\n```\n```\\nN = len(wordDict)\\nM = min([len(word) for word in wordDict])\\nS = len(sentence)\\nO(N*N^S*S/M) = O(NN^2S/M)\\n```\n```\\nN = len(wordDict)\\nM = min([len(word) for word in wordDict])\\nS = len(sentence)\\nO(S*N*N^S) = O(NN^2S)\\n```\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        @lru_cache(maxsize=None)\\n        def dp(i):\\n            res = []\\n            for word in wordDict:\\n                if word != s[i:i+len(word)]:\\n                    continue\\n                elif len(word) == len(s)-i:\\n                    res.append(word)\\n                else:\\n                    for sentence in dp(i+len(word)):\\n                        res.append(word + \\' \\' + sentence)        \\n            return res\\n        \\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533512,
                "title": "javascript-dfs-memo",
                "content": "```\\nvar wordBreak = function(s, wordDict) {\\n    \\n    const dictSet = new Set(wordDict);\\n    const memo = {};\\n\\n    function dfs(start) {\\n        \\n        if(start > s.length-1) { \\n            return [[]];\\n        }\\n        \\n        if(memo[start] !== undefined) {\\n            return memo[start];\\n        }\\n        \\n        const out = [];\\n        \\n        for(let i = start; i < s.length; i++) {\\n            const substr = s.substring(start, i+1);\\n            if(dictSet.has(substr)) {\\n                let next = dfs(i+1); \\n                for(let n of next) {\\n                    out.push([substr, ...n]);\\n                }\\n            }\\n        }  \\n        return memo[start] = out;\\n        \\n    }\\n    \\n    const res = dfs(0)\\n\\n    return res.filter(a => a.join(\\'\\') === s).map(a => a.join(\\' \\'));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar wordBreak = function(s, wordDict) {\\n    \\n    const dictSet = new Set(wordDict);\\n    const memo = {};\\n\\n    function dfs(start) {\\n        \\n        if(start > s.length-1) { \\n            return [[]];\\n        }\\n        \\n        if(memo[start] !== undefined) {\\n            return memo[start];\\n        }\\n        \\n        const out = [];\\n        \\n        for(let i = start; i < s.length; i++) {\\n            const substr = s.substring(start, i+1);\\n            if(dictSet.has(substr)) {\\n                let next = dfs(i+1); \\n                for(let n of next) {\\n                    out.push([substr, ...n]);\\n                }\\n            }\\n        }  \\n        return memo[start] = out;\\n        \\n    }\\n    \\n    const res = dfs(0)\\n\\n    return res.filter(a => a.join(\\'\\') === s).map(a => a.join(\\' \\'));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508994,
                "title": "c-straightforward-dfs-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string, vector<string>> memo;\\n        return dfs(s, memo, wordDict);\\n    }\\n    \\n    vector<string> dfs(string s, unordered_map<string, vector<string>>& memo, vector<string>& wordDict) {\\n        if (memo.find(s) != memo.end()) {\\n            return memo[s];\\n        }\\n        \\n        vector<string> results;\\n        if (s.size() == 0) {\\n            return {\"\"};\\n        }\\n        \\n        for (string word : wordDict) {\\n            int len = word.size();\\n            if (len <= s.size()) {\\n                if (s.substr(0, len) != word) continue;\\n                string suffix = s.substr(len);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//build results from suffix partition results - solve based on subproblems\\n                vector<string> segs = dfs(suffix, memo, wordDict);\\n                for (string seg : segs) {\\n                    results.push_back(seg.empty() ? word + seg : word + \" \" + seg);\\n                }\\n            }\\n        }\\n        \\n        memo[s] = results; //memoization\\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string, vector<string>> memo;\\n        return dfs(s, memo, wordDict);\\n    }\\n    \\n    vector<string> dfs(string s, unordered_map<string, vector<string>>& memo, vector<string>& wordDict) {\\n        if (memo.find(s) != memo.end()) {\\n            return memo[s];\\n        }\\n        \\n        vector<string> results;\\n        if (s.size() == 0) {\\n            return {\"\"};\\n        }\\n        \\n        for (string word : wordDict) {\\n            int len = word.size();\\n            if (len <= s.size()) {\\n                if (s.substr(0, len) != word) continue;\\n                string suffix = s.substr(len);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//build results from suffix partition results - solve based on subproblems\\n                vector<string> segs = dfs(suffix, memo, wordDict);\\n                for (string seg : segs) {\\n                    results.push_back(seg.empty() ? word + seg : word + \" \" + seg);\\n                }\\n            }\\n        }\\n        \\n        memo[s] = results; //memoization\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469507,
                "title": "c-dp-dfs-solution-95",
                "content": "We first construct a dp array for the original string. If `s[:k]` is breakable (i.e. can be broken into valid words), there must be a position `l`, where `s[:k-l]` is also breakable and `s[k-l:]` is a valid word. There can be multiple valid `l` for a given `k`. \\n\\nTo implement dp, we store all possible `k-l` positions as a set in `dp[k]`. For a given `k` we scan all possible word length `l` in the dictionary, and insert `k-l` into `dp[k]` if `l == k` or `dp[k-l]` is non-empty.\\n\\nAfter consturcting `dp` array, we use DFS to reconstruct result vector and return.\\n\\nTo increase the performance, we preprocess `dictWords` to get all possible word lengths in the dictionary.\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(const vector<unordered_set<int>>& dp, int k, vector<string>& rst, string& s) {\\n\\t\\t// function to reconstruct result string vector from dp array\\n        if (k < s.size()) {\\n             s.insert(k, 1, \\' \\');\\n        }\\n        for (int knext : dp[k]) {\\n            if (knext == 0) {\\n                rst.push_back(s);\\n            }\\n            else {\\n                dfs(dp, knext, rst, s);   \\n            }\\n        }\\n        if (k < s.size()) {\\n            s.erase(k, 1);\\n        }\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        // preprocess wordDict, generate hash table for possible lengths and words\\n        unordered_set<int> lens;\\n        unordered_set<string> dict;\\n           for (int i(0); i < wordDict.size(); ++i) {\\n            lens.insert(wordDict[i].size());\\n            dict.insert(wordDict[i]);\\n        }\\n        // DP: dp[k] stores all possible last space positions for substring s[:k]\\n        //  i.e. if l is in dp[k], it means s[:l] can be broken into valid words and s[l:k] is a valid word\\n        const int N = s.size();\\n        vector<unordered_set<int>> dp(N+1, unordered_set<int>());\\n        for (int k(1); k <= N; ++k) {\\n            for (int l : lens) {\\n               if (l <= k) {\\n                   const string seg(s.begin() + k-l, s.begin() + k);\\n                   if (dict.count(seg)) {\\n                       if (l == k or !dp[k-l].empty()) {\\n                           dp[k].insert(k-l);\\n                       }\\n                   }\\n               }\\n            }\\n        }\\n        // generate recult with DFS\\n        vector<string> rst;\\n        dfs(dp, N, rst, s);\\n        return rst;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(const vector<unordered_set<int>>& dp, int k, vector<string>& rst, string& s) {\\n\\t\\t// function to reconstruct result string vector from dp array\\n        if (k < s.size()) {\\n             s.insert(k, 1, \\' \\');\\n        }\\n        for (int knext : dp[k]) {\\n            if (knext == 0) {\\n                rst.push_back(s);\\n            }\\n            else {\\n                dfs(dp, knext, rst, s);   \\n            }\\n        }\\n        if (k < s.size()) {\\n            s.erase(k, 1);\\n        }\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        // preprocess wordDict, generate hash table for possible lengths and words\\n        unordered_set<int> lens;\\n        unordered_set<string> dict;\\n           for (int i(0); i < wordDict.size(); ++i) {\\n            lens.insert(wordDict[i].size());\\n            dict.insert(wordDict[i]);\\n        }\\n        // DP: dp[k] stores all possible last space positions for substring s[:k]\\n        //  i.e. if l is in dp[k], it means s[:l] can be broken into valid words and s[l:k] is a valid word\\n        const int N = s.size();\\n        vector<unordered_set<int>> dp(N+1, unordered_set<int>());\\n        for (int k(1); k <= N; ++k) {\\n            for (int l : lens) {\\n               if (l <= k) {\\n                   const string seg(s.begin() + k-l, s.begin() + k);\\n                   if (dict.count(seg)) {\\n                       if (l == k or !dp[k-l].empty()) {\\n                           dp[k].insert(k-l);\\n                       }\\n                   }\\n               }\\n            }\\n        }\\n        // generate recult with DFS\\n        vector<string> rst;\\n        dfs(dp, N, rst, s);\\n        return rst;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564947,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564626,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564923,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566021,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566968,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566945,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1567520,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1568130,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566752,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1567887,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564947,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564626,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564923,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566021,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566968,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566945,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1567520,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1568130,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566752,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1567887,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1570691,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1569464,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1567212,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1766491,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1576594,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1575746,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1571304,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1571305,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1571306,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 2027607,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 2018427,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 2001030,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1999468,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1999390,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1977737,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1975487,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1926529,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1919580,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1911042,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1812430,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Search a 2D Matrix II",
        "question_content": "<p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p>\n\n<ul>\n\t<li>Integers in each row are sorted in ascending from left to right.</li>\n\t<li>Integers in each column are sorted in ascending from top to bottom.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>All the integers in each row are <strong>sorted</strong> in ascending order.</li>\n\t<li>All the integers in each column are <strong>sorted</strong> in ascending order.</li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 66140,
                "title": "my-concise-o-m-n-java-solution",
                "content": "We start search the matrix from top right corner, initialize the current position to top right corner, if the target is greater than the value in current position, then the target can not be in entire row of current position because the row is sorted, if the target is less than the value in current position, then the target can not in the entire column because the column is sorted too. We can rule out one row or one column each time, so the time complexity is O(m+n).\\n\\n    public class Solution {\\n        public boolean searchMatrix(int[][] matrix, int target) {\\n            if(matrix == null || matrix.length < 1 || matrix[0].length <1) {\\n                return false;\\n            }\\n            int col = matrix[0].length-1;\\n            int row = 0;\\n            while(col >= 0 && row <= matrix.length-1) {\\n                if(target == matrix[row][col]) {\\n                    return true;\\n                } else if(target < matrix[row][col]) {\\n                    col--;\\n                } else if(target > matrix[row][col]) {\\n                    row++;\\n                }\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean searchMatrix(int[][] matrix, int target) {\\n            if(matrix == null || matrix.length < 1 || matrix[0].length <1) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 66139,
                "title": "c-search-from-top-right",
                "content": "Search from the **top-right** element and reduce the search space by one row or column at each time.\\n\\n```\\n[[ 1,  4,  7, 11, 15],\\n [ 2,  5,  8, 12, 19], \\n [ 3,  6,  9, 16, 22],\\n [10, 13, 14, 17, 24],\\n [18, 21, 23, 26, 30]]\\n```\\n\\nSuppose we want to search for `12` in the above matrix. compare `12` with the top-right element `nums[0][4] = 15`. Since `12 < 15`, `12` cannot appear in the column of `15` since all elements in that column are greater than or equal to `15`. Now we reduce the search space by one column (the last column).\\n\\nWe further compare `12` with the top-right element of the remaining matrix, which is `nums[0][3] = 11`. Since `12 > 11`, `12` cannot appear in the row of `11` since all elements in this row are less than or equal to `11` (the last column has been discarded). Now we reduce the search space by one row (the first row).\\n\\nWe move on to compare `12` with the top-right element of the remaining matrix, which is `nums[1][3] = 12`. Since it is equal to `12`, we return `true`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, r = 0, c = n - 1;\\n        while (r < m && c >= 0) {\\n            if (matrix[r][c] == target) {\\n                return true;\\n            }\\n            matrix[r][c] > target ? c-- : r++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\n[[ 1,  4,  7, 11, 15],\\n [ 2,  5,  8, 12, 19], \\n [ 3,  6,  9, 16, 22],\\n [10, 13, 14, 17, 24],\\n [18, 21, 23, 26, 30]]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, r = 0, c = n - 1;\\n        while (r < m && c >= 0) {\\n            if (matrix[r][c] == target) {\\n                return true;\\n            }\\n            matrix[r][c] > target ? c-- : r++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66142,
                "title": "c-with-o-m-n-complexity",
                "content": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        if (m == 0) return false;\\n        int n = matrix[0].size();\\n\\n        int i = 0, j = n - 1;\\n        while (i < m && j >= 0) {\\n            if (matrix[i][j] == target)\\n                return true;\\n            else if (matrix[i][j] > target) {\\n                j--;\\n            } else \\n                i++;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        if (m == 0) return false;\\n        int n = matrix[0].size();\\n\\n        int i = 0, j = n - 1;\\n        while (i < m && j >= 0) {\\n            if (matrix[i][j] == target)\\n                return true;\\n            else if (matrix[i][j] > target) {\\n                j--;\\n            } else \\n                i++;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 66147,
                "title": "java-an-easy-to-understand-divide-and-conquer-method",
                "content": "The coding seems to be much more complex than those smart methods such as [this one][1], but the idea behind is actually quite straightforward. `Unfortunately, it is not as fast as the smart ones.`\\n\\nFirst, we divide the matrix into four quarters as shown below:\\n\\n      zone 1      zone 2\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    -----------------------\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n      zone 3      zone 4\\n\\nWe then compare the element in the center of the matrix with the target. There are three possibilities:\\n\\n\\n - center < target. In this case, we discard zone 1 because all elements in zone 1 are less than target.\\n\\n - center > target. In this case, we discard zone 4.\\n\\n - center == target. return true.\\n\\nFor time complexity, if the matrix is a square matrix of size `nxn`, then for the worst case, \\n\\n    T(nxn) = 3T(n/2 x n/2)\\n\\nwhich makes \\n  \\n    T(nxn) = O(n^log3)\\n\\nCode in Java:\\n\\n     public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        if(m<1) return false;\\n        int n = matrix[0].length;\\n        \\n        return searchMatrix(matrix, new int[]{0,0}, new int[]{m-1, n-1}, target);\\n    }\\n    \\n    private boolean searchMatrix(int[][] matrix, int[] upperLeft, int[] lowerRight, int target) {\\n    \\tif(upperLeft[0]>lowerRight[0] || upperLeft[1]>lowerRight[1]\\n    \\t\\t\\t|| lowerRight[0]>=matrix.length || lowerRight[1]>=matrix[0].length) \\n    \\t\\treturn false;\\n    \\tif(lowerRight[0]-upperLeft[0]==0 && lowerRight[1]-upperLeft[1]==0)\\n    \\t\\treturn matrix[upperLeft[0]][upperLeft[1]] == target;\\n    \\tint rowMid = (upperLeft[0] + lowerRight[0]) >> 1;\\n    \\tint colMid = (upperLeft[1] + lowerRight[1]) >> 1;\\n    \\tint diff = matrix[rowMid][colMid] - target;\\n    \\tif(diff > 0) {\\n    \\t\\treturn searchMatrix(matrix, upperLeft, new int[]{rowMid, colMid}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{upperLeft[0],colMid+1}, new int[]{rowMid, lowerRight[1]}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{rowMid+1,upperLeft[1]}, new int[]{lowerRight[0], colMid}, target);\\n    \\t}\\n    \\telse if(diff < 0) {\\n     \\t\\treturn searchMatrix(matrix, new int[]{upperLeft[0], colMid+1}, new int[]{rowMid, lowerRight[1]}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{rowMid+1, upperLeft[1]}, new int[]{lowerRight[0], colMid}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{rowMid+1, colMid+1}, lowerRight, target);\\n    \\t}\\n    \\telse return true;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/48852/my-concise-o-m-n-java-solution",
                "solutionTags": [],
                "code": "The coding seems to be much more complex than those smart methods such as [this one][1], but the idea behind is actually quite straightforward. `Unfortunately, it is not as fast as the smart ones.`\\n\\nFirst, we divide the matrix into four quarters as shown below:\\n\\n      zone 1      zone 2\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    -----------------------\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n      zone 3      zone 4\\n\\nWe then compare the element in the center of the matrix with the target. There are three possibilities:\\n\\n\\n - center < target. In this case, we discard zone 1 because all elements in zone 1 are less than target.\\n\\n - center > target. In this case, we discard zone 4.\\n\\n - center == target. return true.\\n\\nFor time complexity, if the matrix is a square matrix of size `nxn`, then for the worst case, \\n\\n    T(nxn) = 3T(n/2 x n/2)\\n\\nwhich makes \\n  \\n    T(nxn) = O(n^log3)\\n\\nCode in Java:\\n\\n     public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        if(m<1) return false;\\n        int n = matrix[0].length;\\n        \\n        return searchMatrix(matrix, new int[]{0,0}, new int[]{m-1, n-1}, target);\\n    }\\n    \\n    private boolean searchMatrix(int[][] matrix, int[] upperLeft, int[] lowerRight, int target) {\\n    \\tif(upperLeft[0]>lowerRight[0] || upperLeft[1]>lowerRight[1]\\n    \\t\\t\\t|| lowerRight[0]>=matrix.length || lowerRight[1]>=matrix[0].length) \\n    \\t\\treturn false;\\n    \\tif(lowerRight[0]-upperLeft[0]==0 && lowerRight[1]-upperLeft[1]==0)\\n    \\t\\treturn matrix[upperLeft[0]][upperLeft[1]] == target;\\n    \\tint rowMid = (upperLeft[0] + lowerRight[0]) >> 1;\\n    \\tint colMid = (upperLeft[1] + lowerRight[1]) >> 1;\\n    \\tint diff = matrix[rowMid][colMid] - target;\\n    \\tif(diff > 0) {\\n    \\t\\treturn searchMatrix(matrix, upperLeft, new int[]{rowMid, colMid}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{upperLeft[0],colMid+1}, new int[]{rowMid, lowerRight[1]}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{rowMid+1,upperLeft[1]}, new int[]{lowerRight[0], colMid}, target);\\n    \\t}\\n    \\telse if(diff < 0) {\\n     \\t\\treturn searchMatrix(matrix, new int[]{upperLeft[0], colMid+1}, new int[]{rowMid, lowerRight[1]}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{rowMid+1, upperLeft[1]}, new int[]{lowerRight[0], colMid}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{rowMid+1, colMid+1}, lowerRight, target);\\n    \\t}\\n    \\telse return true;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/48852/my-concise-o-m-n-java-solution",
                "codeTag": "Unknown"
            },
            {
                "id": 66160,
                "title": "ac-clean-java-solution",
                "content": "If we stand on the top-right corner of the matrix and look diagonally, it's kind of like a BST, we can go through this matrix to find the target like how we traverse the BST.\\n\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return false;\\n\\n        int n = matrix.length, m = matrix[0].length;\\n        int i = 0, j = m - 1;\\n        \\n        while (i < n && j >= 0) {\\n            int num = matrix[i][j];\\n            \\n            if (num == target)\\n                return true;\\n            else if (num > target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "If we stand on the top-right corner of the matrix and look diagonally, it's kind of like a BST, we can go through this matrix to find the target like how we traverse the BST.\\n\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return false;\\n\\n        int n = matrix.length, m = matrix[0].length;\\n        int i = 0, j = m - 1;\\n        \\n        while (i < n && j >= 0) {\\n            int num = matrix[i][j];\\n            \\n            if (num == target)\\n                return true;\\n            else if (num > target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 332356,
                "title": "python-o-m-n-linear-search-from-top-right-corner",
                "content": "Starting from Top-Right corner:\\nIf current grid ```M[r][c]``` is smaller than target ```x```, there is no need to consider ```M[r][ :c] ``` since all the grids on the left must be smaller as well. So, ```x``` must be in the rows below and we can safely make ``` r += 1```.\\nWe keep moving ```M[r][c]``` downwards until it\\'s larger ```x```, then we can safely move leftwards and make ```c -= 1``` since all the grids in ```M[ :r][c ]``` would be larger than ```x```.\\nDuring the search, if ```x``` is found, we return ```True```. Otherwise, we can either move downwards or leftwards safely.\\nIf we reach left-bottom corner without hitting ```x```, then target is not in the matrix.\\n```\\ndef searchMatrix(matrix, target):\\n\\tm, n = len(matrix), len(matrix) and len(matrix[0])\\n\\tr, c = 0, n-1\\n\\twhile r < m and c >= 0:\\n\\t\\tif target > matrix[r][c]:\\n\\t\\t\\tr += 1\\n\\t\\telif target < matrix[r][c]:\\n\\t\\t\\tc -= 1\\n\\t\\telse: return True\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```M[r][c]```\n```x```\n```M[r][ :c] ```\n```x```\n``` r += 1```\n```M[r][c]```\n```x```\n```c -= 1```\n```M[ :r][c ]```\n```x```\n```x```\n```True```\n```x```\n```\\ndef searchMatrix(matrix, target):\\n\\tm, n = len(matrix), len(matrix) and len(matrix[0])\\n\\tr, c = 0, n-1\\n\\twhile r < m and c >= 0:\\n\\t\\tif target > matrix[r][c]:\\n\\t\\t\\tr += 1\\n\\t\\telif target < matrix[r][c]:\\n\\t\\t\\tc -= 1\\n\\t\\telse: return True\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2324616,
                "title": "java-c-full-visuall-explanation",
                "content": "Hello, **Ladies-N-Gentlemen** today we are going to solve a another easy-peasy question.\\n\\nI hope so, that questions is clear what it is all are talking about. Because, question statement is very clear!!\\n\\n```\\n# Brute Force Approach\\n```\\nSo, let\\'s talk about what will be **`Brute Force approach` to solve this problem.**\\n\\nThe very brute-force approach is, we will traverse it\\'s every row & column of the matrix.\\n\\n**Let\\'s understand it visually,**\\n\\n![image](https://assets.leetcode.com/users/images/01f6dc7a-0662-47d6-ab59-a9c196f332a8_1658635775.4245615.gif)\\n\\n\\n**JAVA**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                if(matrix[i][j] == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nANALYSIS :-\\nAs, you are seeing we are traversing it\\'s all row and column therefore the **Time Complexity** will be **`O(N^2)`** And the **Space Complexity** will be **`O(1)`**\\n\\n```\\n# Better Approach\\n```\\nLet\\'s take an example to understand this approach,\\n\\n![image](https://assets.leetcode.com/users/images/17612fa0-eaeb-4e73-bf78-e65c2c87bf09_1658633211.0689182.png)\\n\\nSo, what we gonna do is we will start traversing from **`top-right corner`** or you can even start from **`bottom-left corner`**. Now you\\'ll ask why not from **top-left OR bottom-right?** Well, there\\'s a reason why not from there, we\\'ll come to this point later on.\\n\\n**`Now, let\\'s start traversing and understand it\\'s visaully`**\\n\\n**`Note :-`** \\n\\n![image](https://assets.leetcode.com/users/images/b6e5483e-07e9-4200-9a5e-9a3d38307ae1_1658634345.6110325.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a424696-79ea-47f1-82fe-836a00afa034_1658634181.3804603.gif)\\n\\n\\nSo, what we are doing you got the idea,\\n* If value is **`>`** then target, then move to **left i.e. j--**\\n\\n\\n* If value is **`<`** then target, then move **down i.e. i++** \\n* If value is **`==`** to target, **return true**\\n* Else **return false**\\n\\nNow, let\\'s code it up:-\\n**Java**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int i = 0;\\n        int j = matrix[0].length - 1;\\n        \\n        while(i >= 0 && i < matrix.length && j >= 0 && j < matrix[0].length){\\n            if(matrix[i][j] == target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else if(matrix[i][j] < target) i++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i = 0;\\n        int j = matrix[0].size() - 1;\\n        \\n        while(i >= 0 && i < matrix.size() && j >= 0 && j < matrix[0].size()){\\n            if(matrix[i][j] == target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else if(matrix[i][j] < target) i++;\\n        }\\n        return false;\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** It will be **`O(row + column)`** because we are traversing every row & column only once\\n\\n* **Space Complexity :-** It will be **`O(1)`** as we are not using any extra memory OR space",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n# Brute Force Approach\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                if(matrix[i][j] == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\n# Better Approach\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int i = 0;\\n        int j = matrix[0].length - 1;\\n        \\n        while(i >= 0 && i < matrix.length && j >= 0 && j < matrix[0].length){\\n            if(matrix[i][j] == target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else if(matrix[i][j] < target) i++;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i = 0;\\n        int j = matrix[0].size() - 1;\\n        \\n        while(i >= 0 && i < matrix.size() && j >= 0 && j < matrix[0].size()){\\n            if(matrix[i][j] == target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else if(matrix[i][j] < target) i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079154,
                "title": "python-o-m-n-solution-explained",
                "content": "Let us consider the following example and discuss the algorithm.\\n\\n| 1  | 4  | 7  | 11 | 15 |\\n|----|----|----|----|----|\\n| **2**  | **5**  | **8**  | **12** | **19** |\\n| **3**  | **6**  | **9**  | **16** | **22** |\\n| **10** | **13** | **14** | **17** | **24** |\\n| **18** | **21** | **23** | **26** | **30** |\\n\\nLet us start with element on the top right corner and on each step we decide where we can go.\\n\\n1. Current number is equal to **15**, and `target = 5`, where can we go? All numbers above `15` is more than `15`, so we can eliminate last column and go to the left.\\n2. Current number is equal to **11** and again it is bigger than `target = 5`, so we eliminate column and go to the left\\n3. Current number is equal to **7**, go to the left.\\n4. Current number is **4**, now it is smaller than target, so we can eliminate first row: elements to the left is smaller than `4` and elements to the right already eliminated in columns.\\n5. Current number is **5** and we found our target.\\n\\nIt also can happen, that we do not found number, in this case we need to terminate, when we can not move anymore.\\n\\n**Complexity**: time complexity is `O(m + n)`, where `m, n` are number of columns and rows: on each step we eliminate either row or column. Space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        x, y = len(matrix[0]) - 1, 0\\n        while x >= 0 and y < len(matrix):\\n            if matrix[y][x] > target:\\n                x -= 1\\n            elif matrix[y][x] < target:\\n                y += 1\\n            else:\\n                return True\\n        return False\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        x, y = len(matrix[0]) - 1, 0\\n        while x >= 0 and y < len(matrix):\\n            if matrix[y][x] > target:\\n                x -= 1\\n            elif matrix[y][x] < target:\\n                y += 1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66168,
                "title": "4-lines-c-6-lines-ruby-7-lines-python-1-liners",
                "content": "Same O(m+n) method as most, just a bit different style/languages.\\n\\n---\\n\\n**C**\\n\\nCheck the top-right corner. If it's not the target, then remove the top row or rightmost column.\\n\\n    bool searchMatrix(int** A, int m, int n, int target) {\\n        int x = ~target;\\n        while (m && n && (x = A[0][n-1]) != target)\\n            x < target ? A++, m-- : n--;\\n        return x == target;\\n    }\\n\\n**Ruby**\\n\\n    def search_matrix(matrix, target)\\n        j = -1\\n        matrix.each { |row|\\n            j -= 1 while row[j] && row[j] > target\\n            return true if row[j] == target\\n        }\\n        false\\n    end\\n\\n**Python**\\n\\n    def searchMatrix(self, matrix, target):\\n        j = -1\\n        for row in matrix:\\n            while j + len(row) and row[j] > target:\\n                j -= 1\\n            if row[j] == target:\\n                return True\\n        return False\\n\\n**1-liners**\\n\\nRelax, I know they're O(mn). This is just for fun (although they did get accepted):\\n\\nPython (204 ms):\\n\\n    def searchMatrix(self, matrix, target):\\n        return any(target in row for row in matrix)\\n\\nRuby (828 ms):\\n\\n    def search_matrix(matrix, target)\\n        matrix.any? { |row| row.include? target }\\n    end",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "Same O(m+n) method as most, just a bit different style/languages.\\n\\n---\\n\\n**C**\\n\\nCheck the top-right corner. If it's not the target, then remove the top row or rightmost column.\\n\\n    bool searchMatrix(int** A, int m, int n, int target) {\\n        int x = ~target;\\n        while (m && n && (x = A[0][n-1]) != target)\\n            x < target ? A++, m-- : n--;\\n        return x == target;\\n    }\\n\\n**Ruby**\\n\\n    def search_matrix(matrix, target)\\n        j = -1\\n        matrix.each { |row|\\n            j -= 1 while row[j] && row[j] > target\\n            return true if row[j] == target\\n        }\\n        false\\n    end\\n\\n**Python**\\n\\n    def searchMatrix(self, matrix, target):\\n        j = -1\\n        for row in matrix:\\n            while j + len(row) and row[j] > target:\\n                j -= 1\\n            if row[j] == target:\\n                return True\\n        return False\\n\\n**1-liners**\\n\\nRelax, I know they're O(mn). This is just for fun (although they did get accepted):\\n\\nPython (204 ms):\\n\\n    def searchMatrix(self, matrix, target):\\n        return any(target in row for row in matrix)\\n\\nRuby (828 ms):\\n\\n    def search_matrix(matrix, target)\\n        matrix.any? { |row| row.include? target }\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 2324351,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**EFFICIENT APPROACH -> O ( M + N )**\\n\\nAs the rows are sorted **->** ```matrix[i][j] < matrix[i][j+1]```\\nAs the columns are sorted **->** ```matrix[i][j] >matrix[i-1][j]```\\n\\nHence it can be said that :\\n* any element right to ```matrix[i][j]``` will be greater than it.\\n* any element to the top of ```matrix[i][j]``` will be less than it.\\n\\nSo we start searching from **BOTTOM_LEFT**:\\n* if element found -> return **TRUE**\\n* if ```matrix[i][j] > target``` -> move **UP**.\\n* if ```matrix[i][j] < target``` -> move **RIGHT**.\\n\\n![image](https://assets.leetcode.com/users/images/ffcde87b-6220-4e61-a2ec-498abc7fd28d_1658626864.8423152.png)\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:\\n        \\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        i=m-1\\n        j=0\\n        \\n        while i>=0 and j<n:\\n            if mat[i][j]==target:\\n                return True\\n            elif mat[i][j]<target:\\n                j+=1\\n            else:\\n                i-=1\\n                \\n        return False\\n```\\n\\n**EFFICIENT APPROACH -> O ( M LOG N )**\\nAs all the rows are sorted , an element can be clearly searched using *BINARY-SEARCH* for each row.\\n\\nFor each row -> O ( M )\\nBinary search -> O ( LOG N )\\n\\n**UPVOTE IF HELPFuuL**\\n\\n**BINARY SEARCH SOLUTION**\\n```\\nclass Solution:\\n    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:\\n        \\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        for i in range(m):\\n            if mat[i][0]<=target and mat[i][-1]>=target:\\n                lo=0\\n                hi=n\\n                while (lo<hi):\\n                    mid=(lo+hi)//2\\n                    \\n                    if mat[i][mid]==target:\\n                        return True\\n                    elif mat[i][mid]<target:\\n                        lo = mid + 1\\n                    else:\\n                        hi = mid\\n                        \\n        return False\\n```\\n![image](https://assets.leetcode.com/users/images/ae27af7f-fbb5-4d4a-be95-2faab90e51b9_1658629526.2394886.webp)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```matrix[i][j] < matrix[i][j+1]```\n```matrix[i][j] >matrix[i-1][j]```\n```matrix[i][j]```\n```matrix[i][j]```\n```matrix[i][j] > target```\n```matrix[i][j] < target```\n```\\nclass Solution:\\n    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:\\n        \\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        i=m-1\\n        j=0\\n        \\n        while i>=0 and j<n:\\n            if mat[i][j]==target:\\n                return True\\n            elif mat[i][j]<target:\\n                j+=1\\n            else:\\n                i-=1\\n                \\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:\\n        \\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        for i in range(m):\\n            if mat[i][0]<=target and mat[i][-1]>=target:\\n                lo=0\\n                hi=n\\n                while (lo<hi):\\n                    mid=(lo+hi)//2\\n                    \\n                    if mat[i][mid]==target:\\n                        return True\\n                    elif mat[i][mid]<target:\\n                        lo = mid + 1\\n                    else:\\n                        hi = mid\\n                        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66247,
                "title": "java-short-code-o-m-n",
                "content": "    public class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m=matrix.length, n=matrix[0].length, i=0, j=n-1;\\n        while (i<m && j>=0) {\\n            if (matrix[i][j]==target) return true;\\n            else if (matrix[i][j]<target) i++;\\n            else j--;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m=matrix.length, n=matrix[0].length, i=0, j=n-1;\\n        while (i<m && j>=0) {\\n            if (matrix[i][j]==target) return true;\\n            else if (matrix[i][j]<target) i++;\\n            else j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 66163,
                "title": "c-two-solutions-o-m-n-o-mlogn",
                "content": "1. O(m+n) solution\\n\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i = 0;\\n        int j = matrix[0].size() - 1;\\n        \\n        while(i < matrix.size() && j >= 0) {\\n            if(matrix[i][j] == target)\\n                return true;\\n            \\n            if(matrix[i][j] < target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        \\n        return false;\\n        }\\n\\n\\n\\n\\n2. O(mlogn) solution\\n\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\t\\treturn searchMatrix(matrix, target, 0, matrix.size() - 1);\\n\\t    }\\n\\n\\t    bool searchMatrix(vector<vector<int>>& matrix, int target, int top, int bottom) {\\n\\t\\tif (top > bottom)\\n\\t\\t\\treturn false;\\n\\n\\t\\tint mid = top + (bottom - top) / 2;\\n\\t\\tif (matrix[mid].front() <= target && target <= matrix[mid].back())\\n\\t\\t\\tif (searchVector(matrix[mid], target)) return true;\\n\\n\\t\\tif (searchMatrix(matrix, target, top, mid - 1)) return true;\\n\\t\\tif (searchMatrix(matrix, target, mid + 1, bottom)) return true;\\n\\n\\t\\treturn false;\\n\\t    }\\n\\n\\t    bool searchVector(vector<int>& v, int target) {\\n\\t\\tint left = 0, right = v.size() - 1;\\n\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tint mid = left + (right - left) / 2;\\n\\t\\t\\tif (v[mid] == target)\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif (v[mid] < target)\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t    }",
                "solutionTags": [],
                "code": "1. O(m+n) solution\\n\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i = 0;\\n        int j = matrix[0].size() - 1;\\n        \\n        while(i < matrix.size() && j >= 0) {\\n            if(matrix[i][j] == target)\\n                return true;\\n            \\n            if(matrix[i][j] < target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        \\n        return false;\\n        }\\n\\n\\n\\n\\n2. O(mlogn) solution\\n\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\t\\treturn searchMatrix(matrix, target, 0, matrix.size() - 1);\\n\\t    }\\n\\n\\t    bool searchMatrix(vector<vector<int>>& matrix, int target, int top, int bottom) {\\n\\t\\tif (top > bottom)\\n\\t\\t\\treturn false;\\n\\n\\t\\tint mid = top + (bottom - top) / 2;\\n\\t\\tif (matrix[mid].front() <= target && target <= matrix[mid].back())\\n\\t\\t\\tif (searchVector(matrix[mid], target)) return true;\\n\\n\\t\\tif (searchMatrix(matrix, target, top, mid - 1)) return true;\\n\\t\\tif (searchMatrix(matrix, target, mid + 1, bottom)) return true;\\n\\n\\t\\treturn false;\\n\\t    }\\n\\n\\t    bool searchVector(vector<int>& v, int target) {\\n\\t\\tint left = 0, right = v.size() - 1;\\n\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tint mid = left + (right - left) / 2;\\n\\t\\t\\tif (v[mid] == target)\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif (v[mid] < target)\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1079514,
                "title": "c-binary-search-2-variations-o-m-n-explanation-with-example-diagram",
                "content": "**EXPLANATION**\\nConsider the below diagram.\\n\\n![image](https://assets.leetcode.com/users/images/9d344366-1ff3-4fbe-930d-3aaff907f204_1614093877.1058805.png)\\n\\n**Target** : Green (13), **Starting point** : Yellow (15).\\n **Traversal Path** : Orange (15 -> 11, 12, 16, 9, 14 ->13).\\n\\n- Start iterating the `matrix` from **top right corner** of the `matrix`, that is `matrix[0][size of column -1]`.\\n- If `matrix[i][j]==target`, return **true**.\\n- If the `target` is less than `matrix[i][j]`, then move **leftwards** (*decrease the column*), that is `--j`.\\n- If the `target` is greater than `matrix[i][j]`, then move **downwards** (*increase the row*), that is `++i`.\\n\\n- If the `target` element is *not found* then after *exiting* the above loop, return **false**.\\n\\n**CODE IMPLEMENTATION (Variation 1)**\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        // start from the [first row, last column] element\\n        int i=0;\\n        int j=m-1;\\n        while(i<n && j>=0){\\n            if(matrix[i][j]==target) // target found\\n                return true;\\n            else if(matrix[i][j]>target) //target is smaller, go leftwards\\n                --j; // decrease the column index\\n            else // target is larger, go downwards\\n                ++i; // increase the row index\\n        }\\n        return false; // target not found\\n    }\\n};\\n```\\n\\nConsidering, *m* = length of column and *n* =  length of row.\\n\\n**TIME COMPLEXITY: O(m+n)**\\nFor any case, the path traversed will be the shortest path from the top right corner to the target element. Say target element is at `[ti, tj]` and top right corner (*starting index*) is `[0,m - 1]`, so the total path traversed will be `[ti - 0, (m - 1) - tj]`, so the time taken is `O(ti + m - 1 - tj)`. Now, according to the constraints given in question, the worst case will be when `ti = n-1` and `tj = 0`, that is target element is at `matrix[n-1, 0]`. So, the worst-case time complexity will be `O(n - 1 + m  - 1 - 0)`, that is `O(n + m)` (asymptotically).\\n\\n**SPACE COMPLEXITY: O(1)**\\nNo extra space is used.\\n\\n\\n**CODE IMPLEMENTATION (Variation 2)**\\nAs suggested by [@Niks291](https://leetcode.com/Niks291), we can also start from the **bottom left corner** of the `matrix`, that is from `matrix[size of row - 1][0]` along with changing some conditions within the loop.\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        // start from the [last row, first column] element\\n        int i=n-1;\\n        int j=0;\\n        while(j<m && i>=0){\\n            if(matrix[i][j]==target) // target found\\n                return true;\\n            else if(matrix[i][j]>target) //target is smaller go upwards\\n                --i; // decrease the row index\\n            else // target is larger go rightwards\\n                ++j; // increase the column index\\n        }\\n        return false; // target not found\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        // start from the [first row, last column] element\\n        int i=0;\\n        int j=m-1;\\n        while(i<n && j>=0){\\n            if(matrix[i][j]==target) // target found\\n                return true;\\n            else if(matrix[i][j]>target) //target is smaller, go leftwards\\n                --j; // decrease the column index\\n            else // target is larger, go downwards\\n                ++i; // increase the row index\\n        }\\n        return false; // target not found\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        // start from the [last row, first column] element\\n        int i=n-1;\\n        int j=0;\\n        while(j<m && i>=0){\\n            if(matrix[i][j]==target) // target found\\n                return true;\\n            else if(matrix[i][j]>target) //target is smaller go upwards\\n                --i; // decrease the row index\\n            else // target is larger go rightwards\\n                ++j; // increase the column index\\n        }\\n        return false; // target not found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66207,
                "title": "my-c-soluation-using-binary-search-tree-model-beats-100",
                "content": "at first i use binary search method, but i found it's hard to pruning Redundant situation,and i just found we can treat the left bottom as a root of a BST so we only need o(m+N) to find the target.\\n\\n    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int row = matrix.size();\\n            int col = matrix[0].size();\\n            int i = row-1,j =0;\\n            while(i>=0&&j<=col-1)\\n            {\\n                if(target>matrix[i][j])\\n                {\\n                    j++;\\n                }\\n                else if(target<matrix[i][j])\\n                {\\n                    i--;\\n                }\\n                else\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int row = matrix.size();\\n            int col = matrix[0].size();\\n            int i = row-1,j =0;\\n            while(i>=0&&j<=col-1)\\n            {\\n                if(target>matrix[i][j])\\n                {\\n                    j++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 148444,
                "title": "java-solution-using-binary-search-with-comments-96",
                "content": "```\\nclass Solution {\\n    int[][] matrix;\\n    int target;\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        this.matrix = matrix;\\n        this.target = target;\\n        if(matrix.length==0)\\n            return false;\\n        return helper(0, 0, matrix.length-1, matrix[0].length-1);\\n    }\\n    /**\\n    * @param x1, row coordinate of top left element of the matrix\\n    * @param y1, column coordinate of top left elemeent of the matrix\\n    * @param x2, row coordinate of bottom right element of the matrix\\n    * @param y2, column coordinate of bottom right element of the matrix\\n    */\\n    private boolean helper(int x1, int y1, int x2, int y2){\\n        if(x2<x1 || y2<y1 || x1>=matrix.length || y1>=matrix[0].length || x2<0 || y2<0)\\n            return false;\\n        int mx = (x2-x1)/2+x1;\\n        int my = (y2-y1)/2+y1;\\n        // Check the middle element of the matrix, if not found, \\n        // recursively call on sub matrices where\\n        // the value could still exist. \\n        // You will realize that the resultant possible places will\\n        // form a L shape on the original matrix.\\n        // This L shape can be broken down into 2 matrices.\\n        // If number found in any of the 2 matrices, we return true.\\n        if(matrix[mx][my]==target)\\n            return true;\\n        else if(matrix[mx][my]<target){\\n            return helper(x1,my+1,x2,y2) || helper(mx+1,y1,x2,my);\\n        }else if(matrix[mx][my]>target){\\n            return helper(x1,y1,x2,my-1) || helper(x1,my,mx-1,y2);\\n        }else\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] matrix;\\n    int target;\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        this.matrix = matrix;\\n        this.target = target;\\n        if(matrix.length==0)\\n            return false;\\n        return helper(0, 0, matrix.length-1, matrix[0].length-1);\\n    }\\n    /**\\n    * @param x1, row coordinate of top left element of the matrix\\n    * @param y1, column coordinate of top left elemeent of the matrix\\n    * @param x2, row coordinate of bottom right element of the matrix\\n    * @param y2, column coordinate of bottom right element of the matrix\\n    */\\n    private boolean helper(int x1, int y1, int x2, int y2){\\n        if(x2<x1 || y2<y1 || x1>=matrix.length || y1>=matrix[0].length || x2<0 || y2<0)\\n            return false;\\n        int mx = (x2-x1)/2+x1;\\n        int my = (y2-y1)/2+y1;\\n        // Check the middle element of the matrix, if not found, \\n        // recursively call on sub matrices where\\n        // the value could still exist. \\n        // You will realize that the resultant possible places will\\n        // form a L shape on the original matrix.\\n        // This L shape can be broken down into 2 matrices.\\n        // If number found in any of the 2 matrices, we return true.\\n        if(matrix[mx][my]==target)\\n            return true;\\n        else if(matrix[mx][my]<target){\\n            return helper(x1,my+1,x2,y2) || helper(mx+1,y1,x2,my);\\n        }else if(matrix[mx][my]>target){\\n            return helper(x1,y1,x2,my-1) || helper(x1,my,mx-1,y2);\\n        }else\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66194,
                "title": "python-o-m-n-with-clear-search-strategy",
                "content": "\\n\\n    class Solution:\\n        # @param {integer[][]} matrix\\n        # @param {integer} target\\n        # @return {boolean}\\n        def searchMatrix(self, matrix, target):\\n            if matrix:\\n                row,col,width=len(matrix)-1,0,len(matrix[0])\\n                while row>=0 and col<width:\\n                    if matrix[row][col]==target:\\n                        return True\\n                    elif matrix[row][col]>target:\\n                        row=row-1\\n                    else:\\n                        col=col+1\\n                return False",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[][]}",
                "codeTag": "Java"
            },
            {
                "id": 2324496,
                "title": "java-simple-and-easy-solution",
                "content": "PLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length, m=matrix[0].length;\\n        int i=0, j=m-1;\\n        while(i<n&&j>=0){\\n            if(target==matrix[i][j])\\n                return true;\\n            if(target>matrix[i][j])\\n                i+=1;\\n            else\\n                j-=1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length, m=matrix[0].length;\\n        int i=0, j=m-1;\\n        while(i<n&&j>=0){\\n            if(target==matrix[i][j])\\n                return true;\\n            if(target>matrix[i][j])\\n                i+=1;\\n            else\\n                j-=1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526439,
                "title": "c-simple-solution-100-faster",
                "content": "**C++ :**\\n\\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\tint row = 0;\\n\\tint col = matrix[0].size() - 1;\\n\\n\\twhile(row < matrix.size() && col >= 0)\\n\\t{\\n\\t\\tif(matrix[row][col] == target)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif(matrix[row][col] < target)\\n\\t\\t\\t++row;\\n\\n\\t\\telse\\n\\t\\t\\t--col;\\n\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\tint row = 0;\\n\\tint col = matrix[0].size() - 1;\\n\\n\\twhile(row < matrix.size() && col >= 0)\\n\\t{\\n\\t\\tif(matrix[row][col] == target)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif(matrix[row][col] < target)\\n\\t\\t\\t++row;\\n\\n\\t\\telse\\n\\t\\t\\t--col;\\n\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934056,
                "title": "binary-search-in-a-2d-matrix-with-explanation",
                "content": "Hello!\\n\\nI\\'ve just looked through a bunch of solutions and most of them were brute force. \\nSo I\\'ve decided post a solution with the binary search approach with explantion.\\n\\n```\\nvar searchMatrix = function(matrix, target) {\\n     if(!matrix || !matrix.length) return false;\\n    \\n    const rows = matrix.length;\\n    const cols = matrix[0].length;\\n    \\n    function hasTarget(startRow, endRow, startCol, endCol) {\\n\\t\\t// recursion base case\\n        if(startRow > endRow || startCol > endCol) return false;\\n        \\n\\t\\t// find middle of the matrix\\n        const middleRow = Math.floor((endRow - startRow) / 2) + startRow;\\n        const middleCol = Math.floor((endCol - startCol) / 2) + startCol;\\n        \\n\\t\\t// if we found the target we solve the problem, so return true  \\n        if(matrix[middleRow][middleCol] === target) return true;\\n        \\n\\t\\t// it is the \"devide\" step, basically, we define the recurrence relation for the recursion function.\\n        if (matrix[middleRow][middleCol] < target) {\\n\\t\\t\\t// let m - is our middle point.\\n\\t\\t\\t// if m less than the target than all points before m also less tha target (marked by x)\\n\\t\\t\\t// so we only need look through cells marked by 1 and 2\\n\\t\\t\\t// x x x 2 2\\n\\t\\t\\t// x x x 2 2\\n\\t\\t\\t// x x m 2 2\\n\\t\\t\\t// 1 1 1 1 1\\n\\t\\t\\t// 1 1 1 1 1\\n            return hasTarget(middleRow + 1, endRow, startCol, endCol) ||\\n                   hasTarget(startRow, middleRow, middleCol + 1, endCol);\\n        } else {\\n\\t\\t\\t// let m - is our middle point.\\n\\t\\t\\t// if m more than the target than all points after m also bigger than the target (marked by x)\\n\\t\\t\\t// so we only need look through cells marked by 1 and 2\\n\\t\\t\\t// 1 1 2 2 2\\n\\t\\t\\t// 1 1 2 2 2\\n\\t\\t\\t// 1 1 m x x\\n\\t\\t\\t// 1 1 x x x\\n\\t\\t\\t// 1 1 x x x\\n            return hasTarget(startRow, endRow, startCol, middleCol - 1) ||\\n                   hasTarget(startRow, middleRow - 1, middleCol, endCol);\\n        }\\n    }\\n    \\n    return hasTarget(0, rows - 1, 0, cols - 1);\\n}\\n```\\n\\nHappy coding!\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nvar searchMatrix = function(matrix, target) {\\n     if(!matrix || !matrix.length) return false;\\n    \\n    const rows = matrix.length;\\n    const cols = matrix[0].length;\\n    \\n    function hasTarget(startRow, endRow, startCol, endCol) {\\n\\t\\t// recursion base case\\n        if(startRow > endRow || startCol > endCol) return false;\\n        \\n\\t\\t// find middle of the matrix\\n        const middleRow = Math.floor((endRow - startRow) / 2) + startRow;\\n        const middleCol = Math.floor((endCol - startCol) / 2) + startCol;\\n        \\n\\t\\t// if we found the target we solve the problem, so return true  \\n        if(matrix[middleRow][middleCol] === target) return true;\\n        \\n\\t\\t// it is the \"devide\" step, basically, we define the recurrence relation for the recursion function.\\n        if (matrix[middleRow][middleCol] < target) {\\n\\t\\t\\t// let m - is our middle point.\\n\\t\\t\\t// if m less than the target than all points before m also less tha target (marked by x)\\n\\t\\t\\t// so we only need look through cells marked by 1 and 2\\n\\t\\t\\t// x x x 2 2\\n\\t\\t\\t// x x x 2 2\\n\\t\\t\\t// x x m 2 2\\n\\t\\t\\t// 1 1 1 1 1\\n\\t\\t\\t// 1 1 1 1 1\\n            return hasTarget(middleRow + 1, endRow, startCol, endCol) ||\\n                   hasTarget(startRow, middleRow, middleCol + 1, endCol);\\n        } else {\\n\\t\\t\\t// let m - is our middle point.\\n\\t\\t\\t// if m more than the target than all points after m also bigger than the target (marked by x)\\n\\t\\t\\t// so we only need look through cells marked by 1 and 2\\n\\t\\t\\t// 1 1 2 2 2\\n\\t\\t\\t// 1 1 2 2 2\\n\\t\\t\\t// 1 1 m x x\\n\\t\\t\\t// 1 1 x x x\\n\\t\\t\\t// 1 1 x x x\\n            return hasTarget(startRow, endRow, startCol, middleCol - 1) ||\\n                   hasTarget(startRow, middleRow - 1, middleCol, endCol);\\n        }\\n    }\\n    \\n    return hasTarget(0, rows - 1, 0, cols - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1079051,
                "title": "c-super-simple-and-easy-concise-6-lines-o-n-m-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = 0, col = matrix[0].size()-1;\\n        \\n        while (row < matrix.size() && col >= 0) {\\n            \\n            if (target == matrix[row][col])\\n                return true;\\n            \\n            target > matrix[row][col] ? row++ : col--;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = 0, col = matrix[0].size()-1;\\n        \\n        while (row < matrix.size() && col >= 0) {\\n            \\n            if (target == matrix[row][col])\\n                return true;\\n            \\n            target > matrix[row][col] ? row++ : col--;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513112,
                "title": "java-tc-o-r-c-sc-o-1-optimal-solution-using-elimination-strategy",
                "content": "```java\\n/**\\n * Search from Top left corner.\\n *\\n * If target is less than top left corner, then we can safely reduce the column\\n * index as all the below values in column will be greater than the target.\\n *\\n * Similarly if the target is more than the top left corner, then we can safely\\n * increase the row index as all the left values in the row will be smaller than\\n * the target.\\n *\\n * Time Complexity: O(R + C)\\n *\\n * Space Complexity: O(1)\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n\\n        int row = 0;\\n        int col = matrix[0].length - 1;\\n\\n        while (row < matrix.length && col >= 0) {\\n            if (matrix[row][col] == target) {\\n                return true;\\n            }\\n            if (target < matrix[row][col]) {\\n                col--;\\n            } else {\\n                row++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Search a 2D Matrix question on LeetCode:\\n- [74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/discuss/1511703/Java-or-TC:-O(log(R*C))-or-SC:-O(1)-or-Optimized-binary-search-solution)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Search from Top left corner.\\n *\\n * If target is less than top left corner, then we can safely reduce the column\\n * index as all the below values in column will be greater than the target.\\n *\\n * Similarly if the target is more than the top left corner, then we can safely\\n * increase the row index as all the left values in the row will be smaller than\\n * the target.\\n *\\n * Time Complexity: O(R + C)\\n *\\n * Space Complexity: O(1)\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n\\n        int row = 0;\\n        int col = matrix[0].length - 1;\\n\\n        while (row < matrix.length && col >= 0) {\\n            if (matrix[row][col] == target) {\\n                return true;\\n            }\\n            if (target < matrix[row][col]) {\\n                col--;\\n            } else {\\n                row++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552311,
                "title": "binary-search-the-easiest-to-understand-approach",
                "content": "We are given that the rows of the matrix are sorted  and so are the columns. We make use of this.\\n\\ne.g. \\n\\t\\t\\t\\n\\t\\t   1  3  5  7\\n\\t\\t   10 11 16 20\\n\\t\\t   23 30 34 60\\n\\t\\t   \\nThis means, we can start searching from the top rightmost element in this matrix, which currently is = 7.\\n\\nWhy top rightmost only? Because if you see carefully, all elements on the bottom of it are bigger than it. And all elements to the left of it are smaller than it. We can use this property and apply Binary Search.\\n\\nLets say our target element is  = 11\\n\\nWe are at element = 7. We see that 11 is > 7 so that means we can discard all the cells that are on left of 7 because we will never find 11 on that side. So we will move to bottom i.e, we go to next row. \\n\\nNow we are at 20. Here we see that 11 is less than 20. This means we can discard all the cells on the bottom side as the elements on the bottom of 20 are greater than 20 and hence greater than 11. We we move to left side i.e., go to previous column.\\n\\nNow we are at 16. Again, since 16 > 11, we have to move to left. So we come to previous column.\\n\\nNow we reach 11. And this is our target value so we return True since we found 11.\\n\\nSuppose we had to find 40. It is not present in this matrix.  SO first, we start from 7, since 7 < 40, we move to bottom side. Since 20 < 40 we again move to bottom. Since 60 > 40, we move to left. Since 34 < 40, we should move to bottom again. But wait! We are already at the last row and so we cannot move to bottom anymore\\n\\n\\nThis will be one of the conditions for our Binary Search. If the row number exceeds the maximum possible row number in the matrix, then we have to come out of our loop.\\n\\nNow take another example - Lets say we want to search 4.\\n\\nThe sequences will be like this - \\n\\nWe start from 7, since 7 > 4, we move to left of 7. \\nWe reach 5. Since 5 > 4, we move to left of 5.\\nWe reach 3. Since 3 < 4, we move to bottom side.\\nWe reach 11. Since 11 > 4, we move to left side\\nWe reach 10. Since 10 > 4, we move to left.\\n\\nBut wait! Our column became -1 because we were already at 0th column when we were at 10. So that means, if our column index becomes less than 0, then we have to stop.\\n\\nAnd well, that\\'s it. \\n\\n# **CODE**\\n\\n```\\ndef searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix)\\n        \\n        #We start from the top right corner of the matrix.\\n        row = 0\\n        col = len(matrix[0])-1\\n        \\n        # In this way, on the bottom side, all elements are bigger than current element\\n        # At left side, all elements are smaller than the current element\\n        \\n        while(row < n and col >= 0):\\n            mid = matrix[row][col]\\n            \\n            #If the element at this position is the target element we return True\\n            if(mid == target): return True\\n            \\n            # If the element is smaller than this position that means, we need to go to left side of current element\\n            if(mid > target): col -= 1\\n            #Otherwise we need to move to bottom side\\n            else: row += 1\\n        \\n        return False\\n```\\n\\nThis same approach also works for the \"Search a 2D Matrix\" problem because while in that problem it is not explicitly mentioned that columns are sorted, they are sorted because each row is sorted and the first element of each row is greater than last element of previous row. Here is the problem - https://leetcode.com/problems/search-a-2d-matrix/\\n\\n## **GOING ONE STEP FURTHER**\\n\\nJust like how we can start searching from top rightmost element, we can start searching from bottom leftmost element too. Because in case of bottom left most element, all elements above it are smaller than it and all elements on the right of it are bigger than it.\\n\\nBut what if we combine both these approaches?\\n\\n```\\ndef searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n\\t\\t\\n        #Top rightmost corner\\n        row1 = 0\\n        col1 = m-1\\n        \\n        #Bottom leftmost corner\\n        row2 = n - 1\\n        col2 = 0\\n        \\n        #The last condition is to avoid again going to the rows and columns that are already covered\\n        while(row1 < n and col1 >= 0 and row2 >= 0 and col2 < m and (col2 <= col1 and row2 >= row1)):\\n            mid1 = matrix[row1][col1]\\n            mid2 = matrix[row2][col2]\\n            \\n            # If the element is smaller than mid1 that means we need to move to left side\\n            if(mid1 > target): col1 -= 1\\n            #Otherwise we need to move to bottom side\\n            elif (mid1 < target): row1 += 1\\n            \\n            # If the element is smaller than mid2 that means we need to move to top side\\n            elif(mid2 > target): row2 -= 1\\n            #Otherwise we need to move to right side\\n            elif(mid2 < target): col2 += 1\\n            \\n            else: return True\\n                \\n        \\n        return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix)\\n        \\n        #We start from the top right corner of the matrix.\\n        row = 0\\n        col = len(matrix[0])-1\\n        \\n        # In this way, on the bottom side, all elements are bigger than current element\\n        # At left side, all elements are smaller than the current element\\n        \\n        while(row < n and col >= 0):\\n            mid = matrix[row][col]\\n            \\n            #If the element at this position is the target element we return True\\n            if(mid == target): return True\\n            \\n            # If the element is smaller than this position that means, we need to go to left side of current element\\n            if(mid > target): col -= 1\\n            #Otherwise we need to move to bottom side\\n            else: row += 1\\n        \\n        return False\\n```\n```\\ndef searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n\\t\\t\\n        #Top rightmost corner\\n        row1 = 0\\n        col1 = m-1\\n        \\n        #Bottom leftmost corner\\n        row2 = n - 1\\n        col2 = 0\\n        \\n        #The last condition is to avoid again going to the rows and columns that are already covered\\n        while(row1 < n and col1 >= 0 and row2 >= 0 and col2 < m and (col2 <= col1 and row2 >= row1)):\\n            mid1 = matrix[row1][col1]\\n            mid2 = matrix[row2][col2]\\n            \\n            # If the element is smaller than mid1 that means we need to move to left side\\n            if(mid1 > target): col1 -= 1\\n            #Otherwise we need to move to bottom side\\n            elif (mid1 < target): row1 += 1\\n            \\n            # If the element is smaller than mid2 that means we need to move to top side\\n            elif(mid2 > target): row2 -= 1\\n            #Otherwise we need to move to right side\\n            elif(mid2 < target): col2 += 1\\n            \\n            else: return True\\n                \\n        \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2324412,
                "title": "python3-9-lines-w-explanation-t-m-84-82",
                "content": "```\\nclass Solution:         # Here\\'s the plan:\\n                        #   \\u2022 We start in the bottom-left corner, which is \\n                        #     matrix[-1][0]. Obviously, the target cell cannot\\n                        #     be either below or to the left of this corner cell\\n                        #  \\n                        #   \\u2022 We move incrementally from the corner such that we \\n                        #     do not pass to right of the target\\'s column or above\\n                        #     its row; we can ensure this by exploiting the sorted \\n                        #     rows and columns. For example (below), the target \\n                        #     is 8 and and the corner is 18. So:\\n                        #               -- 18 > 8 =>  move up    to 10,\\n                        #               -- 10 > 8 =>  move up    to  3,\\n                        #               --  3 < 8 =>  move right to  6,\\n                        #               --  6 < 8 =>  move right to  9,\\n                        #               --  9 > 8 =>  move up    to  8.\\n```\\n![image](https://assets.leetcode.com/users/images/9e8737fd-576b-47a6-8f22-026b209f0181_1658626054.8534317.jpeg)\\n\\n```\\n\\n\\n        def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\\n        \\n            row, col =   len(matrix)-1, 0        # <-- start at corner\\n\\n            while row >=0 and col <= len(matrix[0])-1:  \\n                cell = matrix[row][col]\\n\\n                if cell > target:               # <-- go up \\n                    row-= 1\\n                elif cell < target:             # <-- go right\\n                    col+= 1\\n                else: return True               # <-- target found\\n\\n            return  False\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:         # Here\\'s the plan:\\n                        #   \\u2022 We start in the bottom-left corner, which is \\n                        #     matrix[-1][0]. Obviously, the target cell cannot\\n                        #     be either below or to the left of this corner cell\\n                        #  \\n                        #   \\u2022 We move incrementally from the corner such that we \\n                        #     do not pass to right of the target\\'s column or above\\n                        #     its row; we can ensure this by exploiting the sorted \\n                        #     rows and columns. For example (below), the target \\n                        #     is 8 and and the corner is 18. So:\\n                        #               -- 18 > 8 =>  move up    to 10,\\n                        #               -- 10 > 8 =>  move up    to  3,\\n                        #               --  3 < 8 =>  move right to  6,\\n                        #               --  6 < 8 =>  move right to  9,\\n                        #               --  9 > 8 =>  move up    to  8.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204059,
                "title": "python-solution",
                "content": "Starting with the bottom left corner of the matrix, if the current element `curr` equals `target`, we return `True`. If `curr` is larger than `target`, than since any element to the right of `curr` (in the same row) is larger than `curr`, we don\\'t need to consider them, so we deduct the row index by 1 (move up by 1 row). By the same token, if `curr` is smaller than `target`, we increase the column index by 1 (move right by 1 column). Repeat the above steps until we find `target` in which case we return `True` or move out of `matrix` in which case we return `False`.\\n\\nTime complexity: O(m+n), space complexity: O(1).\\n```\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        m = len(matrix)\\n        if m == 0:\\n            return False\\n        n = len(matrix[0])\\n        if n == 0:\\n            return False\\n        y = m-1\\n        x = 0\\n        while x < n and y >= 0:\\n            if matrix[y][x] == target:\\n                return True\\n            elif matrix[y][x] < target:\\n                x += 1\\n            else:\\n                y -= 1\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        m = len(matrix)\\n        if m == 0:\\n            return False\\n        n = len(matrix[0])\\n        if n == 0:\\n            return False\\n        y = m-1\\n        x = 0\\n        while x < n and y >= 0:\\n            if matrix[y][x] == target:\\n                return True\\n            elif matrix[y][x] < target:\\n                x += 1\\n            else:\\n                y -= 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66277,
                "title": "so-clear-solve-for-c",
                "content": "    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            if(matrix.size() == 0)return false;\\n            return searchMatrix(matrix, 0, matrix[0].size() - 1, target);\\n        }\\n        bool searchMatrix(vector<vector<int>>& matrix, int x, int y, int target) {\\n            if(x >= matrix.size() || y < 0)return false;\\n            if(matrix[x][y] == target)return true;\\n            else if(matrix[x][y] < target) return searchMatrix(matrix, x + 1, y, target);\\n            else if(matrix[x][y] > target) return searchMatrix(matrix, x, y - 1, target);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            if(matrix.size() == 0)return false;\\n            return searchMatrix(matrix, 0, matrix[0].size() - 1, target);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 693908,
                "title": "python-explained-simple-solution-100-faster",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        ## Similar to Leetcode: 74. Search A 2D Matrix ##\\n        \\n        # 1. First, we initialize a (row, col) pointer to the bottom-left of the matrix.\\n        # 2. If the currently-pointed-to value is larger than target we can move one row \"up\". \\n        # 3. Otherwise, if the currently-pointed-to value is smaller than target, we can move one column \"right\".\\n        \\n\\t\\t## TIME COMPLEXITY : O(N + M) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n                \\n        i, j = len(matrix) - 1, 0\\n        while(i >= 0 and i < len(matrix) and j >=0 and j < len(matrix[0])):\\n            if(matrix[i][j] == target): return True\\n            if(matrix[i][j] > target):  i -= 1\\n            if(matrix[i][j] < target):  j += 1              \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        ## Similar to Leetcode: 74. Search A 2D Matrix ##\\n        \\n        # 1. First, we initialize a (row, col) pointer to the bottom-left of the matrix.\\n        # 2. If the currently-pointed-to value is larger than target we can move one row \"up\". \\n        # 3. Otherwise, if the currently-pointed-to value is smaller than target, we can move one column \"right\".\\n        \\n\\t\\t## TIME COMPLEXITY : O(N + M) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n                \\n        i, j = len(matrix) - 1, 0\\n        while(i >= 0 and i < len(matrix) and j >=0 and j < len(matrix[0])):\\n            if(matrix[i][j] == target): return True\\n            if(matrix[i][j] > target):  i -= 1\\n            if(matrix[i][j] < target):  j += 1              \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321439,
                "title": "awesome-logic-with-time-complexity-o-n",
                "content": "\\n\\n# Normal Approach---->O(N)\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row,col=len(matrix),len(matrix[0])\\n        r,c=0,col-1\\n        while r<row and c>=0:\\n            if matrix[r][c]==target:\\n                return True\\n            if matrix[r][c]>target:\\n                c-=1\\n            else:\\n                r+=1\\n        return False\\n    //please upvote me it would encourage me alot\\n\\n```\\n# Binary Search Approach--->O(NLogN)\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows,col=len(matrix),len(matrix[0])\\n        for row in matrix:\\n            left,right=0,len(row)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if row[mid]==target:\\n                    return True\\n                if row[mid]>target:\\n                    right=mid-1\\n                else:\\n                    left=mid+1\\n        return False\\n    //please upvote me it would encourage me alot\\n\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row,col=len(matrix),len(matrix[0])\\n        r,c=0,col-1\\n        while r<row and c>=0:\\n            if matrix[r][c]==target:\\n                return True\\n            if matrix[r][c]>target:\\n                c-=1\\n            else:\\n                r+=1\\n        return False\\n    //please upvote me it would encourage me alot\\n\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows,col=len(matrix),len(matrix[0])\\n        for row in matrix:\\n            left,right=0,len(row)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if row[mid]==target:\\n                    return True\\n                if row[mid]>target:\\n                    right=mid-1\\n                else:\\n                    left=mid+1\\n        return False\\n    //please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760056,
                "title": "binary-search-time-complexity-space-complexity-explanation",
                "content": "Another version of this problem: https://leetcode.com/problems/search-a-2d-matrix/\\nSolution: https://leetcode.com/problems/search-a-2d-matrix/discuss/2760040/Binary-Search-Time-Complexity-%2B-Space-Complexity-%2B-Explanation\\n\\nTime Complexity - At most, we can traverse the length of 0 to row and col to 0. Thus time taken is O(row + col).\\nSpace Complexity - Space taken is O(1).\\nExplanation - We start at the top right corner of the matrix, and move left/right according to whether the current value is greater or lesser than target. This uses the property of each row and column being sorted.\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), col = matrix[0].size(), i = 0, j = col - 1;\\n        while(i < row && j >= 0){\\n            if(matrix[i][j] == target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nKindly upvote if you found the solution helpful :)\\n**For more such explanations of LeetCode problems along with their C++ solutions:**\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search",
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), col = matrix[0].size(), i = 0, j = col - 1;\\n        while(i < row && j >= 0){\\n            if(matrix[i][j] == target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326445,
                "title": "240-search-a-2d-matrix-ii-c-three-approach-best-and-concise",
                "content": "**240. Search a 2D Matrix II**\\n\\n![image](https://assets.leetcode.com/users/images/5282d569-2c24-4068-9179-fa4fdd7617be_1658655205.7487211.jpeg)\\n![image](https://assets.leetcode.com/users/images/37279826-90a1-40f7-82bf-1e520ef617e2_1658655283.2490494.jpeg)\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target)\\n    {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        // start from the [last row, first column] element\\n        int i = n - 1;\\n        //set j to \\'0\\' initially\\n        int j = 0;\\n        while (j < m && i >= 0)\\n        {\\n            //if target is found\\n            if (matrix[i][j] == target)\\n            {\\n                return true;\\n            }\\n            //in else if we checj that target is less than matrix value\\n            else if (matrix[i][j] > target)\\n            {\\n                --i;\\n                // decrease the row index\\n            }\\n            else\\n            {\\n                ++j;\\n                // increase the column index\\n            }\\n        }\\n        return false;\\n        // target not found\\n        // return false\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target)\\n    {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        // start from the [last row, first column] element\\n        int i = n - 1;\\n        //set j to \\'0\\' initially\\n        int j = 0;\\n        while (j < m && i >= 0)\\n        {\\n            //if target is found\\n            if (matrix[i][j] == target)\\n            {\\n                return true;\\n            }\\n            //in else if we checj that target is less than matrix value\\n            else if (matrix[i][j] > target)\\n            {\\n                --i;\\n                // decrease the row index\\n            }\\n            else\\n            {\\n                ++j;\\n                // increase the column index\\n            }\\n        }\\n        return false;\\n        // target not found\\n        // return false\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383965,
                "title": "javascript-concise-solution-64ms",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n    if(matrix.length === 0){\\n        return false;\\n    }\\n    //start with top-right element\\n    var i = 0;\\n    var j = matrix[0].length - 1;\\n    \\n    //loop till row and column number are within bounds\\n    while(i <= matrix.length - 1 && j >= 0){\\n        \\n        if(matrix[i][j] > target){\\n            //current element is greater than target\\n            //means this row might have the target element\\n            //change column\\n            j--;\\n        }else if(matrix[i][j] === target){\\n            //element found\\n            return true;\\n        }else if(matrix[i][j] < target){\\n            //current element is lesser than target\\n            //means this column might have the target element\\n            //change rows\\n            i++;\\n        }\\n    }\\n    return false;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n    if(matrix.length === 0){\\n        return false;\\n    }\\n    //start with top-right element\\n    var i = 0;\\n    var j = matrix[0].length - 1;\\n    \\n    //loop till row and column number are within bounds\\n    while(i <= matrix.length - 1 && j >= 0){\\n        \\n        if(matrix[i][j] > target){\\n            //current element is greater than target\\n            //means this row might have the target element\\n            //change column\\n            j--;\\n        }else if(matrix[i][j] === target){\\n            //element found\\n            return true;\\n        }else if(matrix[i][j] < target){\\n            //current element is lesser than target\\n            //means this column might have the target element\\n            //change rows\\n            i++;\\n        }\\n    }\\n    return false;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 66246,
                "title": "java-solution-worst-case-o-m-n",
                "content": "    public boolean searchMatrix(int[][] matrix, int target) {\\n        if(matrix==null ||matrix.length==0 ||matrix[0].length==0)\\n            return false;\\n        int i=0,j=matrix[0].length-1;\\n        while(i<matrix.length && j>=0){\\n            if(matrix[i][j] == target)\\n                return true;\\n            else if(matrix[i][j] < target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    public boolean searchMatrix(int[][] matrix, int target) {\\n        if(matrix==null ||matrix.length==0 ||matrix[0].length==0)\\n            return false;\\n        int i=0,j=matrix[0].length-1;\\n        while(i<matrix.length && j>=0){\\n            if(matrix[i][j] == target)\\n                return true;\\n            else if(matrix[i][j] < target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3231791,
                "title": "240-time-91-4-and-space-98-52-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem can be solved using a divide and conquer approach. We start from the top right corner and move towards the bottom left corner of the matrix. At each position, we check if the current element is equal to the target value. If it is equal, we return True. If it is less than the target value, we move down one row because all the elements in the current row are smaller than the current element. If it is greater than the target value, we move left one column because all the elements in the current column are greater than the current element.\\n\\nThe time complexity of this algorithm is O(m+n) because in the worst case scenario we traverse all rows and columns. The space complexity is O(1) because we are not using any extra data structure.\\n\\n# Complexity\\n- Time complexity:\\n91.4%\\n\\n- Space complexity:\\n98.52%\\n\\n# Code\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        # set initial position to top right corner\\n        row, col = 0, len(matrix[0])-1\\n        \\n        while row < len(matrix) and col >= 0:\\n            if matrix[row][col] == target:\\n                # target found\\n                return True\\n            elif matrix[row][col] < target:\\n                # current element is smaller than target, move down one row\\n                row += 1\\n            else:\\n                # current element is greater than target, move left one column\\n                col -= 1\\n                \\n        # target not found\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        # set initial position to top right corner\\n        row, col = 0, len(matrix[0])-1\\n        \\n        while row < len(matrix) and col >= 0:\\n            if matrix[row][col] == target:\\n                # target found\\n                return True\\n            elif matrix[row][col] < target:\\n                # current element is smaller than target, move down one row\\n                row += 1\\n            else:\\n                # current element is greater than target, move left one column\\n                col -= 1\\n                \\n        # target not found\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079178,
                "title": "python-super-simple-o-m-n-faster-than-93-65",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row, col, num_row = 0, len(matrix[0]) - 1, len(matrix)\\n        while col >= 0 and row < num_row:\\n            if matrix[row][col] > target:\\n                col -= 1\\n            elif matrix[row][col] < target:\\n                row += 1\\n            else:\\n                return True\\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row, col, num_row = 0, len(matrix[0]) - 1, len(matrix)\\n        while col >= 0 and row < num_row:\\n            if matrix[row][col] > target:\\n                col -= 1\\n            elif matrix[row][col] < target:\\n                row += 1\\n            else:\\n                return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 768488,
                "title": "java-o-n-m",
                "content": "We can take advantage of the fact that our given input input grid is sorted. So if we are at a particular element we are guranteed that all the element to it\\'s right and to it\\'s bottom will be larger that the current element.\\nAnd we also know that all the element to it\\'s left and to it\\'s top will be less than the current element;\\n\\nSo this potentially allow us to eliminte :\\n\\tEither all the element below and to the right if our target is less that the current elemet `target < grid[i][j]`\\n\\tOr we can eliminate all the elements to the left and top if our target is greater that the current     element `target > grid[i][j]`\\n\\nLet\\'s say out target is 6, then: \\n![image](https://assets.leetcode.com/users/images/b8b8731d-9862-4d9a-a9fd-5edc47a1a269_1629074320.0377576.png)\\n\\n\\nWe start at first row\\'s last index because thats the max possible number that we can get in that row and the least possible element in the last colums. We keep on traversing until we reach the bottom left index and at that point if we have not yet found the taget val we simply return false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n\\n\\tclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        if(matrix.length == 0 || matrix[0].length == 0) return false;\\n        \\n        int col = matrix[0].length -1;\\n        \\n        int row = 0;\\n        \\n        \\n        while( row < matrix.length && col >=0){\\n            \\n            int num = matrix[row][col];\\n            \\n            if(num == target) return true;\\n            \\n            else if( num > target){\\n                col--;\\n            }\\n            else row++;\\n        }\\n        \\n        \\n        return false;\\n        \\n        \\n    }}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        if(matrix.length == 0 || matrix[0].length == 0) return false;\\n        \\n        int col = matrix[0].length -1;\\n        \\n        int row = 0;\\n        \\n        \\n        while( row < matrix.length && col >=0){\\n            \\n            int num = matrix[row][col];\\n            \\n            if(num == target) return true;\\n            \\n            else if( num > target){\\n                col--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 66235,
                "title": "2-clean-c-implementation-with-detailed-complexity-analysis",
                "content": " Here is the O(M+N) solution, It is important to make it clear we choose the position\\n\\n         right-up-corner-position : can help us to exclude a column or a row\\n\\nSo by judging the right-up-corner-value, we can exclude a column or a row one loop, so the loop is \\nO(M+N) time complexity.\\n\\n    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int m=matrix.size();\\n            if(m==0)  return false;\\n            int n=matrix[0].size();\\n            /*** start from the right-up-position ***/\\n            int i=0, j=n-1;\\n            while(i<m && j>=0){\\n                if(matrix[i][j]==target)  return true;\\n                /*** the element-of-column-j >= matrix[i][j] > target ***/\\n                else if(matrix[i][j]>target)  j--;\\n                /*** the element-of-row-i <= matrix[i][j] < target ***/\\n                else   i++;\\n            }\\n            return false;\\n        }\\n    };\\n\\n\\nHere is a recursion-version-implementation, by analyzing the time complexity \\n\\n      T(N)=3*(T(N/4)) + O(1)\\n\\nBased the master theory, \\n\\n     f(n) = O(1) = O(log(4, 3-e))    with e=2   \\n\\nSo\\n\\n     T(n) = O(N ^ log(4, 3) )    <  O(N)\\n\\nhere is the C++ implementation:\\n\\n\\n       class Solution {\\n        public:\\n            bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n                if(matrix.size()==0) return false;\\n                int row=matrix.size(), col=matrix[0].size();\\n                return help(matrix, 0, row-1, 0, col-1, target);\\n            }\\n            \\n            bool help(vector<vector<int>>& matrix, int row_start, int row_end, int col_start, int col_end, int target) {\\n                if(row_start>row_end || col_start>col_end)  return false;\\n                int row_mid=(row_start+row_end)/2, col_mid=(col_start+col_end)/2;\\n                if(matrix[row_mid][col_mid]==target)    return true;\\n                else if(matrix[row_mid][col_mid]>target){\\n                    /*** left-up || left-down || right-up ***/\\n                    return help(matrix, row_start, row_mid-1, col_start, col_mid-1, target) ||\\n                        help(matrix, row_mid, row_end, col_start, col_mid-1, target) ||\\n                        help(matrix, row_start, row_mid-1, col_mid, col_end, target);\\n                }\\n                else{\\n                    /*** right-down || left-down || right-up ***/\\n                    return help(matrix, row_mid+1, row_end, col_mid+1, col_end, target) ||\\n                        help(matrix, row_mid+1, row_end, col_start, col_mid, target) ||\\n                        help(matrix, row_start, row_mid, col_mid+1, col_end, target);\\n                }\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int m=matrix.size();\\n            if(m==0)  return false;\\n            int n=matrix[0].size();\\n            /*** start from the right-up-position ***/\\n            int i=0, j=n-1;\\n            while(i<m && j>=0){\\n                if(matrix[i][j]==target)  return true;\\n                /*** the element-of-column-j >= matrix[i][j] > target ***/\\n                else if(matrix[i][j]>target)  j--;\\n                /*** the element-of-row-i <= matrix[i][j] < target ***/\\n                else   i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1080050,
                "title": "js-python-java-c-binary-search-solution-w-visual-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to check every cell at a **time complexity** of **O(m * n)**. The obvious improvement on this would be to use a **binary search** on each row to shorten this to **O(m * log n)**. But since the matrix (**M**) is sorted both by row and by column, we can actually think of each **cell** (**M[i][j]**) as being a midpoint in a longer \"row\", including all the cells to the left as well as below the current cell.\\n\\nIf we start from the top right corner of **M** and treat this like a modified binary search, we can eliminate an entire row or an entire column each time we check a **cell**:\\n\\n![Visual 1](https://i.imgur.com/HG6ZPns.png)\\n\\nWe\\'ll then just need to adjust our **i** or **j** value to move to the top right corner \"midpoint\" of the remaining matrix each time to narrow in on our target (**T**):\\n\\n![Visual 2](https://i.imgur.com/b1gvHg0.png)\\n\\nThis will drop the time complexity to **O(m + n)**.\\n\\n(*Note: This works just as well when starting from the bottom left corner.*)\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor all except Java we can use the **bitwise NOT** operator (**~**) to check for boundary condition of **j** because it will return a falsy value (**0**) only when **j** is **-1**.\\n\\n(*Note: Some people are achieving \"faster\" results by exploiting a design flaw in the testing suite. It appears that the test includes one or more loops of the same matrix input and people have had the idea to clear the matrix before returning the answer, which will make the rest of said loop easier to process, as the mutated matrix will be used in subsequent iterations of the test.*)\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **280ms / 41.8MB** (beats 98% / 78%).\\n```javascript\\nvar searchMatrix = function(M, T) {\\n    let y = M.length, i = 0, j = M[0].length - 1\\n    while (i < y && ~j) {\\n        let cell = M[i][j]\\n        if (cell === T) return true\\n        else if (cell > T) j--\\n        else i++\\n    }\\n    return false\\n};\\n\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **148ms / 20.4MB** (beats 99% / 98%).\\n```python\\nclass Solution:\\n    def searchMatrix(self, M: List[List[int]], T: int) -> bool:\\n        y, i, j = len(M), 0, len(M[0]) - 1\\n        while i < y and ~j:\\n            cell = M[i][j]\\n            if cell == T: return True\\n            elif cell > T: j -= 1\\n            else: i += 1\\n        return False\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **4ms / 44.2MB** (beats 100% / 96%).\\n```java\\nclass Solution {\\n    public boolean searchMatrix(int[][] M, int T) {\\n        int y = M.length, i = 0, j = M[0].length - 1;\\n        while (i < y && j >= 0) {\\n            int cell = M[i][j];\\n            if (cell == T) return true;\\n            else if (cell > T) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **60ms / 14.6MB** (beats 96% / 92%).\\n```c++\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& M, int T) {\\n        int y = M.size(), i = 0, j = M[0].size() - 1;\\n        while (i < y && ~j) {\\n            int cell = M[i][j];\\n            if (cell == T) return true;\\n            else if (cell > T) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar searchMatrix = function(M, T) {\\n    let y = M.length, i = 0, j = M[0].length - 1\\n    while (i < y && ~j) {\\n        let cell = M[i][j]\\n        if (cell === T) return true\\n        else if (cell > T) j--\\n        else i++\\n    }\\n    return false\\n};\\n\\n```\n```python\\nclass Solution:\\n    def searchMatrix(self, M: List[List[int]], T: int) -> bool:\\n        y, i, j = len(M), 0, len(M[0]) - 1\\n        while i < y and ~j:\\n            cell = M[i][j]\\n            if cell == T: return True\\n            elif cell > T: j -= 1\\n            else: i += 1\\n        return False\\n```\n```java\\nclass Solution {\\n    public boolean searchMatrix(int[][] M, int T) {\\n        int y = M.length, i = 0, j = M[0].length - 1;\\n        while (i < y && j >= 0) {\\n            int cell = M[i][j];\\n            if (cell == T) return true;\\n            else if (cell > T) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& M, int T) {\\n        int y = M.size(), i = 0, j = M[0].size() - 1;\\n        while (i < y && ~j) {\\n            int cell = M[i][j];\\n            if (cell == T) return true;\\n            else if (cell > T) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697281,
                "title": "python3-o-n-m-with-explanation-proof",
                "content": "Consider the submatrix whose upper right corner is index i, j (row, column) and whose bottom left corner is the bottom left of the original matrix.  Suppose we know that the element we are searching for is either in this submatrix, or it is not in the matrix at all.  If the target is greater than matrix[i][j] then we know the target is not in row i and we can now consider the submatrix whose upper right corner is i - 1, j .  If the target is less than matrix[i][j] then we know that the target is not in column j and we can now consider the submatrix whose upper right corner is i, j-1.  Initially we know that the element we are searching for is either in the matrix or it is not.  In other words, we initially know that the element we are searching for is either in the submatrix whose upper right corner is at 0, m - 1 (where m is the number of columns) or it is not in the matrix at all.  The idea of the algorithm is to maintain with each iteration the condition that the target is in the submatrix whose upper right corner is index i, j.\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        if matrix == None or len(matrix) == 0 or len(matrix[0]) == 0: \\n            return False\\n        n, m = len(matrix), len(matrix[0])\\n        i, j = 0, m - 1\\n        while i < n and j >= 0:\\n            if matrix[i][j] == target:\\n                return True\\n            elif matrix[i][j] < target:\\n                i += 1\\n            else:\\n                j -= 1\\n        return False\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        if matrix == None or len(matrix) == 0 or len(matrix[0]) == 0: \\n            return False\\n        n, m = len(matrix), len(matrix[0])\\n        i, j = 0, m - 1\\n        while i < n and j >= 0:\\n            if matrix[i][j] == target:\\n                return True\\n            elif matrix[i][j] < target:\\n                i += 1\\n            else:\\n                j -= 1\\n        return False\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 133253,
                "title": "javascript-solution",
                "content": "Search from top right corner\\n\\n```js\\n// Time O(m + n), rule out one row or one column each time\\n// Space O(1)\\n\\nconst searchMatrix = (matrix, target) => {\\n  if (matrix == null || matrix.length === 0) return false;\\n  const h = matrix.length;\\n  const w = matrix[0].length;\\n\\n  let i = 0;\\n  let j = w - 1;\\n  while (j >= 0 && i < h) {\\n    if (target === matrix[i][j]) return true;\\n    else if (target < matrix[i][j]) j--;\\n    else i++;\\n  }\\n  return false;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```js\\n// Time O(m + n), rule out one row or one column each time\\n// Space O(1)\\n\\nconst searchMatrix = (matrix, target) => {\\n  if (matrix == null || matrix.length === 0) return false;\\n  const h = matrix.length;\\n  const w = matrix[0].length;\\n\\n  let i = 0;\\n  let j = w - 1;\\n  while (j >= 0 && i < h) {\\n    if (target === matrix[i][j]) return true;\\n    else if (target < matrix[i][j]) j--;\\n    else i++;\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66296,
                "title": "clear-c-solution-illustrating-how-to-use-binary-search-accordingly",
                "content": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), col = row ? matrix[0].size() : 0;\\n        int start = 0, end = row, mid, endRow, startRow;\\n        // first we determine the first row the target might occurs.\\n        // notice that here we implement the lower_bound binary search.\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (matrix[mid][col-1] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        startRow = start;\\n        //then we caclulate the end row (not included) the target might occurs\\n        // here is for upper_bound binary search.\\n        start = 0, end = row;\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (matrix[mid][0] > target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        endRow = start;\\n        //finally, iterate through each row until we find the target\\n        // and here is also lower_bound binary search.\\n        for (int i = startRow;i < endRow;++i) {\\n            start = 0, end = col;\\n            while (start < end) {\\n                mid = (start + end) / 2;\\n                if (matrix[i][mid] >= target) {\\n                    end = mid;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            }\\n            if (start < col && matrix[i][start] == target)\\n                return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), col = row ? matrix[0].size() : 0;\\n        int start = 0, end = row, mid, endRow, startRow;\\n        // first we determine the first row the target might occurs.\\n        // notice that here we implement the lower_bound binary search.\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (matrix[mid][col-1] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        startRow = start;\\n        //then we caclulate the end row (not included) the target might occurs\\n        // here is for upper_bound binary search.\\n        start = 0, end = row;\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (matrix[mid][0] > target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        endRow = start;\\n        //finally, iterate through each row until we find the target\\n        // and here is also lower_bound binary search.\\n        for (int i = startRow;i < endRow;++i) {\\n            start = 0, end = col;\\n            while (start < end) {\\n                mid = (start + end) / 2;\\n                if (matrix[i][mid] >= target) {\\n                    end = mid;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            }\\n            if (start < col && matrix[i][start] == target)\\n                return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2057102,
                "title": "c-100-faster-solution-with-explanation-binary-search-easy",
                "content": "**Approach:**\\n1. We will start iterate from m[0][m] or m[n][0]   where m = no. of colums and n =no. of rows.\\n2. then we have have left element is always smaller and down element is bigger then current in whole matrix (Given rows are sorted).\\n3. Then we will loop from` (r < row && r >=0)` and ` (c < col && c >= 0)` this prevent overflow.\\n4. Then if current element is smaller then will we go down ( `r++;` ).\\n5. Then if current element is bigger then will we go left ( `c--;` ).\\n6. If element found we will return true else false.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int c = col-1;\\n        int r =0;\\n        while((r < row && r >=0)  && (c < col && c >= 0)){\\n            \\n            int element = matrix[r][c];\\n            \\n            if(element == target){\\n                return true;\\n            }\\n             else if(element > target){\\n                  c--;\\n            }else{\\n                 r++;\\n             }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```\\n\\n**UPVOTE IF UNDERSTAND**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int c = col-1;\\n        int r =0;\\n        while((r < row && r >=0)  && (c < col && c >= 0)){\\n            \\n            int element = matrix[r][c];\\n            \\n            if(element == target){\\n                return true;\\n            }\\n             else if(element > target){\\n                  c--;\\n            }else{\\n                 r++;\\n             }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222060,
                "title": "c-fast-and-easy-approach-binary-search",
                "content": "class Solution {\\npublic:\\n    **We will start from top right corner of the matrix.\\n    If target is greater then index element then we shift index to bottom.\\n    But If target is smaller then index element we shift index to left.\\n    If target is not present in matrix then we will go bound.**\\n    \\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int i=0,j=col-1;\\n        while(matrix[i][j]!=target){\\n            if(i<0 or j<0 or i>row-1 or j>col-1) //if out of bond then return false\\n                return false;\\n            if(matrix[i][j]<target){\\n                i=i+1;\\n                if(i>row-1)\\n                    return false;\\n            }\\n            else{\\n                j=j-1;\\n                if(j<0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t**Upvote if you find useful**\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    **We will start from top right corner of the matrix.\\n    If target is greater then index element then we shift index to bottom.\\n    But If target is smaller then index element we shift index to left.\\n    If target is not present in matrix then we will go bound.**\\n    \\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int i=0,j=col-1;\\n        while(matrix[i][j]!=target){\\n            if(i<0 or j<0 or i>row-1 or j>col-1) //if out of bond then return false\\n                return false;\\n            if(matrix[i][j]<target){\\n                i=i+1;\\n                if(i>row-1)\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1079974,
                "title": "java-all-approach-regular-and-modified-binary-search-comment-explained",
                "content": "**Regular Binary Search - O(m * logn)**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        for (int i=0;i<matrix.length;i++){\\n                int left  = 0;\\n                int right = matrix[i].length-1;\\n                while (left <= right){\\n                        int cMid = left + (right - left) / 2; // find mid\\n                        if (matrix[i][cMid] == target) return true; // if target matches then return true\\n                        else if (matrix[i][cMid] < target) left = cMid+1; // if the value is less than target then increment the left pointer\\n                        else right = cMid-1; // otherwise decrement the right pointer\\n                } \\n        }\\n        return false;\\n    }\\n}\\n```\\n**Modified Binary Search - O(m + n)**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        \\n        int i = 0;\\n        int j = col-1;\\n        while (i < row && j >= 0){\\n            if (matrix[i][j] == target) return true;\\n            else if (matrix[i][j] < target) i++; //everything in the previous row will be lesser so increment row pointer\\n            else j--;    //everything from the column will be greater so decrement the column pointer\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        for (int i=0;i<matrix.length;i++){\\n                int left  = 0;\\n                int right = matrix[i].length-1;\\n                while (left <= right){\\n                        int cMid = left + (right - left) / 2; // find mid\\n                        if (matrix[i][cMid] == target) return true; // if target matches then return true\\n                        else if (matrix[i][cMid] < target) left = cMid+1; // if the value is less than target then increment the left pointer\\n                        else right = cMid-1; // otherwise decrement the right pointer\\n                } \\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        \\n        int i = 0;\\n        int j = col-1;\\n        while (i < row && j >= 0){\\n            if (matrix[i][j] == target) return true;\\n            else if (matrix[i][j] < target) i++; //everything in the previous row will be lesser so increment row pointer\\n            else j--;    //everything from the column will be greater so decrement the column pointer\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240184,
                "title": "java-divide-and-conquer-approach",
                "content": "Find the middle element in matrix. Divide matrix to 4 parts:\\n\\nPart 1 | Part 2\\n.........O..........\\nPart 3 | Part4\\n\\nO - is the middle element.\\n\\nIf target is more than O - then we ignore Part1 otherwise we ignore Part 3 - and continue recursively to search in parts, to simplify code and speed up execution time - I merge neighbor parts.\\n\\n```\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        final int m = matrix.length;\\n        if (m == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n        final int n = matrix[0].length;\\n\\n        return searchMatrix(matrix, target, 0, m - 1, 0, n - 1);\\n    }\\n\\n    public boolean searchMatrix(int[][] matrix, int target, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int rowMiddle = rowStart + (rowEnd - rowStart) / 2;\\n        int colMiddle = colStart + (colEnd - colStart) / 2;\\n        if (rowStart > rowEnd || colStart > colEnd) {\\n            return false;\\n        }\\n        int valMiddle = matrix[rowMiddle][colMiddle];\\n        if (target == valMiddle) {\\n            return true;\\n        }\\n        if (target < valMiddle) {\\n            return searchMatrix(matrix, target, rowStart, rowEnd, colStart, colMiddle - 1)\\n                    || searchMatrix(matrix, target, rowStart, rowMiddle - 1, colMiddle, colEnd);\\n        } else {\\n            return searchMatrix(matrix, target, rowStart, rowEnd, colMiddle + 1, colEnd)\\n                    || searchMatrix(matrix, target, rowMiddle + 1, rowEnd, colStart, colMiddle);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        final int m = matrix.length;\\n        if (m == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n        final int n = matrix[0].length;\\n\\n        return searchMatrix(matrix, target, 0, m - 1, 0, n - 1);\\n    }\\n\\n    public boolean searchMatrix(int[][] matrix, int target, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int rowMiddle = rowStart + (rowEnd - rowStart) / 2;\\n        int colMiddle = colStart + (colEnd - colStart) / 2;\\n        if (rowStart > rowEnd || colStart > colEnd) {\\n            return false;\\n        }\\n        int valMiddle = matrix[rowMiddle][colMiddle];\\n        if (target == valMiddle) {\\n            return true;\\n        }\\n        if (target < valMiddle) {\\n            return searchMatrix(matrix, target, rowStart, rowEnd, colStart, colMiddle - 1)\\n                    || searchMatrix(matrix, target, rowStart, rowMiddle - 1, colMiddle, colEnd);\\n        } else {\\n            return searchMatrix(matrix, target, rowStart, rowEnd, colMiddle + 1, colEnd)\\n                    || searchMatrix(matrix, target, rowMiddle + 1, rowEnd, colStart, colMiddle);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66173,
                "title": "c-solution",
                "content": "```\\n        public bool SearchMatrix(int[,] matrix, int target)\\n        {\\n            int currentRow = 0, currentCol = matrix.GetLength(1) - 1;\\n\\n            while(currentRow <= matrix.GetLength(0) - 1 && currentCol >= 0)\\n                if (matrix[currentRow, currentCol] == target)\\n                    return true;\\n                else if (matrix[currentRow, currentCol] < target)\\n                    currentRow++;\\n                else if (matrix[currentRow, currentCol] > target)\\n                    currentCol--;\\n\\n            return false;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public bool SearchMatrix(int[,] matrix, int target)\\n        {\\n            int currentRow = 0, currentCol = matrix.GetLength(1) - 1;\\n\\n            while(currentRow <= matrix.GetLength(0) - 1 && currentCol >= 0)\\n                if (matrix[currentRow, currentCol] == target)\\n                    return true;\\n                else if (matrix[currentRow, currentCol] < target)\\n                    currentRow++;\\n                else if (matrix[currentRow, currentCol] > target)\\n                    currentCol--;\\n\\n            return false;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66232,
                "title": "share-my-c-o-m-n-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int row = matrix.size();\\n            if (row == 0)\\n                return false;\\n            int col = matrix[0].size();\\n            if (col == 0)\\n                return false;\\n            if (target < matrix[0][0] || target > matrix[row-1][col-1])\\n                return false;\\n            \\n            int i = 0, j = col - 1;\\n            while (i < row && j >=0)\\n            {\\n                if (target == matrix[i][j])\\n                    return true;\\n                //if target > matrix[i][j],then target must not appear in row-i\\n                else if (target > matrix[i][j])\\n                    ++i;\\n                //if target < matrix[i][j],then target must not appear in column-j\\n                else\\n                    --j;\\n            }\\n            \\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int row = matrix.size();\\n            if (row == 0)\\n                return false;\\n            int col = matrix[0].size();\\n            if (col == 0)\\n                return false;\\n            if (target < matrix[0][0] || target > matrix[row-1][col-1])\\n                return false;\\n            \\n            int i = 0, j = col - 1;\\n            while (i < row && j >=0)\\n            {\\n                if (target == matrix[i][j])\\n                    return true;\\n                //if target > matrix[i][j],then target must not appear in row-i\\n                else if (target > matrix[i][j])\\n                    ++i;\\n                //if target < matrix[i][j],then target must not appear in column-j\\n                else\\n                    --j;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 66322,
                "title": "o-m-n-c-solution",
                "content": "O(M+N) C++ solution for M*N matrix;\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       if(matrix.size() == 0) return false;\\n        int n = matrix[0].size()-1;\\n        int m = 0;\\n        while(m < matrix.size() && n >= 0) {\\n            if (matrix[m][n] == target) return true;\\n            else if (matrix[m][n] < target) ++m;\\n            else --n;\\n        }\\n        return false;\\n    }\\n\\nThe idea is: \\nstart from the upper right corner: \\n\\n - if the element is equal to target, return true;\\n - if the element is greater than target, that means the whole column is greater than target, we can delete a whole column\\n - else, we can delete a whole row",
                "solutionTags": [],
                "code": "O(M+N) C++ solution for M*N matrix;\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       if(matrix.size() == 0) return false;\\n        int n = matrix[0].size()-1;\\n        int m = 0;\\n        while(m < matrix.size() && n >= 0) {\\n            if (matrix[m][n] == target) return true;\\n            else if (matrix[m][n] < target) ++m;\\n            else --n;\\n        }\\n        return false;\\n    }\\n\\nThe idea is: \\nstart from the upper right corner: \\n\\n - if the element is equal to target, return true;\\n - if the element is greater than target, that means the whole column is greater than target, we can delete a whole column\\n - else, we can delete a whole row",
                "codeTag": "Unknown"
            },
            {
                "id": 3858488,
                "title": "space-optimized-solution",
                "content": "# **PLS UPVOTE MY SOLUTION IF YOU LIKE IT AND COMMENT FOR ANY DOUBTS **\\n# Approach\\nInitialize startrow to 0, representing the first row of the matrix.\\nInitialize startcol to m-1, representing the last column of the matrix. m is the number of columns in the matrix.\\nStart a while loop that continues until startrow is less than the number of rows (n) and startcol is greater than or equal to 0.\\nInside the loop, retrieve the element at the current position in the matrix using matrix[startrow][startcol] and store it in the variable ele.\\nCompare ele with the target value. If they are equal, the target is found, and the function returns true (1).\\nIf ele is less than the target, it means the target can only be present in a row below the current one (since the matrix is sorted in non-decreasing order). So, we increment startrow to move to the next row.\\nIf ele is greater than the target, it means the target can only be present in a column to the left of the current one. So, we decrement startcol to move to the previous column.\\nIf the target is not found after the while loop, the function returns false (0).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(m+n) WORST CASE\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int startrow=0;\\n        int startcol= m-1;\\n        while(startrow < n && startcol >= 0)\\n        {\\n            int ele = matrix[startrow][startcol];\\n            if(ele==target)\\n            {\\n                return 1;\\n            }\\n            else if(ele<target)\\n            {\\n                startrow++;\\n            }\\n            else\\n            {\\n                startcol--;\\n            }\\n\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int startrow=0;\\n        int startcol= m-1;\\n        while(startrow < n && startcol >= 0)\\n        {\\n            int ele = matrix[startrow][startcol];\\n            if(ele==target)\\n            {\\n                return 1;\\n            }\\n            else if(ele<target)\\n            {\\n                startrow++;\\n            }\\n            else\\n            {\\n                startcol--;\\n            }\\n\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209331,
                "title": "c-easy-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       int n=matrix.size();\\n       int m=matrix[0].size();\\n       int i=0,j=m-1;\\n       while(i<n && j>=0){\\n           if(matrix[i][j]==target) return true;\\n           else if(matrix[i][j]<target)i++;\\n           else j--;\\n       }\\n       return false;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/3a830886-b93d-44bb-921f-c385552a3db0_1676886905.778097.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       int n=matrix.size();\\n       int m=matrix[0].size();\\n       int i=0,j=m-1;\\n       while(i<n && j>=0){\\n           if(matrix[i][j]==target) return true;\\n           else if(matrix[i][j]<target)i++;\\n           else j--;\\n       }\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326182,
                "title": "c-easy-to-understand",
                "content": "```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\t\\tint R = matrix.size();         //number of rows.\\n        int C = matrix[0].size();     //number of columns.\\n        int i = 0 , j = C - 1;           //choosing iterator i & j to search the target.\\n        while(i < R && j >= 0)\\n        {\\n            if(matrix[i][j] == target)   //if we find the target we return true.\\n                return true;\\n            else if(matrix[i][j] < target)     //if the value at position i & j is smaller than target then we move downward to next column. \\n                i ++;\\n            else                   // else if value at i & j is greater than target then we go leftward in same row.\\n                j --;\\n        }\\n        return false;       // if the target element is not present in the matrix then return false.\\n    }\\n```\\nif you find this helpful upvote please.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\t\\tint R = matrix.size();         //number of rows.\\n        int C = matrix[0].size();     //number of columns.\\n        int i = 0 , j = C - 1;           //choosing iterator i & j to search the target.\\n        while(i < R && j >= 0)\\n        {\\n            if(matrix[i][j] == target)   //if we find the target we return true.\\n                return true;\\n            else if(matrix[i][j] < target)     //if the value at position i & j is smaller than target then we move downward to next column. \\n                i ++;\\n            else                   // else if value at i & j is greater than target then we go leftward in same row.\\n                j --;\\n        }\\n        return false;       // if the target element is not present in the matrix then return false.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891722,
                "title": "c-6-line-simple-code-easy-to-understand-tc-o-n-m-sc-o-1",
                "content": "#### *Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(), m=matrix[0].size();\\n        int row=0,col=m-1;\\n        while(row<n && col>=0){\\n            if(matrix[row][col]==target) return 1;\\n            else if(matrix[row][col]>target) col--;\\n            else row++;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(), m=matrix[0].size();\\n        int row=0,col=m-1;\\n        while(row<n && col>=0){\\n            if(matrix[row][col]==target) return 1;\\n            else if(matrix[row][col]>target) col--;\\n            else row++;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 775465,
                "title": "4-different-solutions-in-c-with-different-time-complexities",
                "content": "Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\\n\\n    Integers in each row are sorted in ascending from left to right.\\n    Integers in each column are sorted in ascending from top to bottom.\\n\\nExample:\\n\\nConsider the following matrix:\\n\\n[\\n  [1,   4,  7, 11, 15],\\n  [2,   5,  8, 12, 19],\\n  [3,   6,  9, 16, 22],\\n  [10, 13, 14, 17, 24],\\n  [18, 21, 23, 26, 30]\\n]\\n\\nGiven target = 5, return true.\\n\\nGiven target = 20, return false.\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nDIVIDE AND CONQUER APPROACH: O(nlogn)\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n```\\nclass Solution {\\npublic:\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size()==0) return false;\\n        if(matrix[0].size()==0) return false;\\n        return searchRect(matrix,target,0,0,matrix.size()-1,matrix[0].size()-1);\\n    }\\n\\n    bool searchRect(vector<vector<int>>& matrix, int target, \\n                               int top, int left, int bottom, int right) {\\n        \\n        if(top>bottom || left>right)\\n            return false;\\n        \\n        int x = (top+bottom)/2;\\n        int y = (left+right)/2;\\n        int center = matrix[x][y];\\n        \\n        if(center > target){\\n            return\\n                searchRect(matrix,target,top,left,x-1,right) ||\\n                searchRect(matrix,target,x,left,bottom,y-1);\\n        }\\n        else if(center < target){\\n            return\\n                searchRect(matrix,target,x+1,left,bottom,right) ||\\n                searchRect(matrix,target,top,y+1,x,right);\\n        }\\n        else\\n            return true;\\n    }\\n};\\n```\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nGREEDY SOLUTION: O(n)\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, r = 0, c = n - 1;\\n        while (r < m && c >= 0) {\\n            if (matrix[r][c] == target) {\\n                return true;\\n            }\\n            matrix[r][c] > target ? c-- : r++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nBINARY SEARCH SOLUTION: O(nlogn)\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        if(m==0) return false;\\n        int n=matrix[0].size();\\n        if(n==0) return false;\\n        for(int i=0;i<m;i++){\\n            if(target<=matrix[i][n-1] and target>=matrix[i][0]){\\n                int left=0;\\n                int right=n-1;\\n                while(left<=right){\\n                    int mid=left +(right-left)/2;\\n                    if(matrix[i][mid]==target){\\n                        return true;\\n                    }\\n                    else if(target<matrix[i][mid]){\\n                        right=mid-1;\\n                    }\\n                    else left=mid+1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nBRUTE FORCE SOLUTION: (This method will get you a TLE, but the implementation is correct and is passing all the base cases). O(n^2)\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                if(matrix[i][j]==target)\\n                {\\n                      return true;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size()==0) return false;\\n        if(matrix[0].size()==0) return false;\\n        return searchRect(matrix,target,0,0,matrix.size()-1,matrix[0].size()-1);\\n    }\\n\\n    bool searchRect(vector<vector<int>>& matrix, int target, \\n                               int top, int left, int bottom, int right) {\\n        \\n        if(top>bottom || left>right)\\n            return false;\\n        \\n        int x = (top+bottom)/2;\\n        int y = (left+right)/2;\\n        int center = matrix[x][y];\\n        \\n        if(center > target){\\n            return\\n                searchRect(matrix,target,top,left,x-1,right) ||\\n                searchRect(matrix,target,x,left,bottom,y-1);\\n        }\\n        else if(center < target){\\n            return\\n                searchRect(matrix,target,x+1,left,bottom,right) ||\\n                searchRect(matrix,target,top,y+1,x,right);\\n        }\\n        else\\n            return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, r = 0, c = n - 1;\\n        while (r < m && c >= 0) {\\n            if (matrix[r][c] == target) {\\n                return true;\\n            }\\n            matrix[r][c] > target ? c-- : r++;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        if(m==0) return false;\\n        int n=matrix[0].size();\\n        if(n==0) return false;\\n        for(int i=0;i<m;i++){\\n            if(target<=matrix[i][n-1] and target>=matrix[i][0]){\\n                int left=0;\\n                int right=n-1;\\n                while(left<=right){\\n                    int mid=left +(right-left)/2;\\n                    if(matrix[i][mid]==target){\\n                        return true;\\n                    }\\n                    else if(target<matrix[i][mid]){\\n                        right=mid-1;\\n                    }\\n                    else left=mid+1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                if(matrix[i][j]==target)\\n                {\\n                      return true;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66229,
                "title": "clean-easy-solution-in-java",
                "content": "    public boolean searchMatrix(int[][] matrix, int target) {\\n\\t\\tint line=0;\\n\\t\\tint len=matrix.length;\\n\\t\\tint col=matrix[0].length;\\n\\t\\twhile (line<len && col>0){\\n\\t\\t\\tint num= matrix[line][col-1];\\n\\t\\t\\tif (num>target) col--;\\n\\t\\t\\tif (num<target) line++;\\n\\t\\t\\tif (num==target) return true;}\\n\\t\\t\\n        return false;\\n    }\\n\\nThe main idea of this solution is to compare the target with the number in the top-right corner and decrease the row number or the col number one by one. It's simple and efficient.",
                "solutionTags": [],
                "code": "    public boolean searchMatrix(int[][] matrix, int target) {\\n\\t\\tint line=0;\\n\\t\\tint len=matrix.length;\\n\\t\\tint col=matrix[0].length;\\n\\t\\twhile (line<len && col>0){\\n\\t\\t\\tint num= matrix[line][col-1];\\n\\t\\t\\tif (num>target) col--;\\n\\t\\t\\tif (num<target) line++;\\n\\t\\t\\tif (num==target) return true;}\\n\\t\\t\\n        return false;\\n    }\\n\\nThe main idea of this solution is to compare the target with the number in the top-right corner and decrease the row number or the col number one by one. It's simple and efficient.",
                "codeTag": "Unknown"
            },
            {
                "id": 66272,
                "title": "o-m-n-java-solution",
                "content": "        public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int x = 0;\\n        int y = n - 1;\\n        while (x < m && y >= 0) {\\n            if (target == matrix[x][y]) {\\n                return true;\\n            } else if (target > matrix[x][y]) {\\n                x++;\\n            } else {\\n                y--;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "        public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int x = 0;\\n        int y = n - 1;\\n        while (x < m && y >= 0) {\\n            if (target == matrix[x][y]) {\\n                return true;\\n            } else if (target > matrix[x][y]) {\\n                x++;\\n            } else {\\n                y--;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 66285,
                "title": "c-c-divide-and-conquer-solution",
                "content": "C++ version\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // check bad input\\n        int m = matrix.size();\\n        if(m == 0)\\n            return false;\\n        int n = matrix[0].size();\\n        if(n == 0)\\n            return false;\\n        return binarySearch(matrix, target, 0, m-1, 0, n-1);\\n    }\\n    \\n    bool binarySearch(vector<vector<int>>& matrix, int target, \\n    int min_i, int max_i, \\n    int min_j, int max_j){\\n        if(min_i > max_i)\\n            return false;\\n        if(min_j > max_j)\\n            return false;\\n        int i = (min_i + max_i)/2;\\n        int j = (min_j + max_j)/2;\\n        \\n        int value = matrix[i][j];\\n        if(value == target)\\n            return true;\\n        else if(value < target)\\n        {\\n            return binarySearch(matrix, target, min_i, max_i, j+1, max_j)\\n            || binarySearch(matrix, target, i+1, max_i, min_j, j);\\n        }\\n        else\\n        {\\n            return binarySearch(matrix, target, min_i, max_i, min_j, j-1)\\n            || binarySearch(matrix, target, min_i, i-1, j, max_j);            \\n        }\\n    }\\n\\nC# version\\n\\n    public bool SearchMatrix(int[,] matrix, int target) {\\n        if(matrix == null)\\n            return false;\\n        int m = matrix.GetLength(0);\\n        int n = matrix.GetLength(1);\\n        if(n == 0 && m == 0)\\n            return false;\\n        return BinarySearch(matrix, target, 0, m-1, 0, n-1);\\n    }\\n    \\n    bool BinarySearch(int[,] matrix, int target, \\n    int min_i, int max_i, \\n    int min_j, int max_j){\\n        if(min_i > max_i)\\n            return false;\\n        if(min_j > max_j)\\n            return false;\\n        int i = (min_i + max_i)/2;\\n        int j = (min_j + max_j)/2;\\n        \\n        int value = matrix[i,j];\\n        if(value == target)\\n            return true;\\n        else if(value < target)\\n        {\\n            return BinarySearch(matrix, target, min_i, max_i, j+1, max_j)\\n            || BinarySearch(matrix, target, i+1, max_i, min_j, j);\\n        }\\n        else\\n        {\\n            return BinarySearch(matrix, target, min_i, max_i, min_j, j-1)\\n            || BinarySearch(matrix, target, min_i, i-1, j, max_j);            \\n        }\\n    }",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "C++ version\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // check bad input\\n        int m = matrix.size();\\n        if(m == 0)\\n            return false;\\n        int n = matrix[0].size();\\n        if(n == 0)\\n            return false;\\n        return binarySearch(matrix, target, 0, m-1, 0, n-1);\\n    }\\n    \\n    bool binarySearch(vector<vector<int>>& matrix, int target, \\n    int min_i, int max_i, \\n    int min_j, int max_j){\\n        if(min_i > max_i)\\n            return false;\\n        if(min_j > max_j)\\n            return false;\\n        int i = (min_i + max_i)/2;\\n        int j = (min_j + max_j)/2;\\n        \\n        int value = matrix[i][j];\\n        if(value == target)\\n            return true;\\n        else if(value < target)\\n        {\\n            return binarySearch(matrix, target, min_i, max_i, j+1, max_j)\\n            || binarySearch(matrix, target, i+1, max_i, min_j, j);\\n        }\\n        else\\n        {\\n            return binarySearch(matrix, target, min_i, max_i, min_j, j-1)\\n            || binarySearch(matrix, target, min_i, i-1, j, max_j);            \\n        }\\n    }\\n\\nC# version\\n\\n    public bool SearchMatrix(int[,] matrix, int target) {\\n        if(matrix == null)\\n            return false;\\n        int m = matrix.GetLength(0);\\n        int n = matrix.GetLength(1);\\n        if(n == 0 && m == 0)\\n            return false;\\n        return BinarySearch(matrix, target, 0, m-1, 0, n-1);\\n    }\\n    \\n    bool BinarySearch(int[,] matrix, int target, \\n    int min_i, int max_i, \\n    int min_j, int max_j){\\n        if(min_i > max_i)\\n            return false;\\n        if(min_j > max_j)\\n            return false;\\n        int i = (min_i + max_i)/2;\\n        int j = (min_j + max_j)/2;\\n        \\n        int value = matrix[i,j];\\n        if(value == target)\\n            return true;\\n        else if(value < target)\\n        {\\n            return BinarySearch(matrix, target, min_i, max_i, j+1, max_j)\\n            || BinarySearch(matrix, target, i+1, max_i, min_j, j);\\n        }\\n        else\\n        {\\n            return BinarySearch(matrix, target, min_i, max_i, min_j, j-1)\\n            || BinarySearch(matrix, target, min_i, i-1, j, max_j);            \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3205428,
                "title": "a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical",
                "content": "# Intuition\\nAFAIK, people posted 2 types of solution:\\n- mostly people are reposting the same clever trick in O(m+n) (starting from top-right or bottom-left corner and moving accordingly)\\n- a suboptimal divide and conquer approach\\n\\nBoth methods leave me unsatisfied: you could easily miss the trick in an interview if your mind just doesn\\'t wander the right way. It feels too random to rely on a trick, and I prefer to have at least one more methodical approach available.\\nThe divide and conquer is the most methodical and you could more easily come up with it, eespecially by analogy with other problems you have solved before. However it is suboptimal\\n\\nHere, we explore an O(m+n) divide and conquer approach that you can methodically come up with if you know the binary search\\nIt is essentially a **2D binary search**\\nN.B: feel free to correct me if I got the complexity wrong, I am not 100% certain. \\n\\n\\n\\n# Approach\\nThe idea is the following:\\nTake your current matrix and select the middle row. In the middle row, look for the target with a binary search. If you find it, you\\'re done. If not, take note of the position of the last element smaller than the target and the first larger (represented by the < and > below)\\n```\\n|                                   |\\n|                                   |\\n|                                   |\\n|----------<>-----------------------| (binary search on middle row)\\n|                                   |\\n|                                   |\\n|                                   |\\n```\\nThis element, that we will call the pivot point yields precious information, because we know that we can discard all the elements in the top-left quadrant will be smaller, and all the elements in the bottom right quadrant will be larger than target by definition of the ordering of the matrix:\\n```\\n|          |                        |\\n|ELIMINATED|                        |\\n|          |                        |\\n|----------<>-----------------------|\\n|           |                       |\\n|           |      ELIMINATED!      |\\n|           |                       |\\n```\\nWe can the explore the 2 remaining matrices recursively.  This goes on until you\\'ve divided the submatrices into single rows, after which you can move on to the next submatrix in the recursive stack call. Here is what the search space might look like after the next iteration.\\n```\\n|          |    ELIM       |        |\\n|ELIMINATED|---------------<>-------|\\n|          |                | ELIM  |\\n|----------<>-----------------------|\\n|           |                       |\\n|           |      ELIMINATED!      |\\n|           |                       |\\n```\\nAs we see, the philosophy of this algorithm just builds on from the simple binary search. It basically uses a bin search in both dimensions of the matrix to divide it into submatrices and eliminating half of them each time, until only a single row remains\\n\\n# Complexity\\n- Time complexity:\\n**O(m+n)**\\n\\nOkay here is the tricky part. Calculating the complexity of this recursion is a bit complicated and if you think I did it wrong, please let me know.\\n\\nThis is a recursive algorithm. Let\\'s call $N=m*n$ the total number of elements in a submatrix. At each step of the recursion, we cut the size of the submatrix in half. More accurately, we divide it into four quadrants, and we only explore two of the quadrants, one with K elements and the other with L elements so that $K+L=N/2$. This subdivision is done in O(log(n)) thanks to a binary search\\nSo the master equation for this recursion could be written as:\\n\\n$$T(N)=T(K)+T(L)+O(log(n))$$, where $$K+L=N/2$$\\n\\n[The Akra-Bazzi theorem](https://en.wikipedia.org/wiki/Akra%E2%80%93Bazzi_method) tells us that we need to find the integer $p$ so that: \\n$$K^p+L^p=N^p$$\\nBad news, we can\\'t. It depends on how exactly the submatrix is split between K and L. **But we can get an upper bound for p**. Because the square root function is concave, we can write:\\n$$\\\\frac{\\\\sqrt K + \\\\sqrt L}{2}<\\\\sqrt{\\\\frac {K + L}{2}}$$\\n$$\\\\frac{\\\\sqrt K + \\\\sqrt L}{2}<\\\\sqrt{\\\\frac {N}{4}}$$\\n$$\\\\sqrt K + \\\\sqrt L< \\\\sqrt N$$\\n**therefore, 1/2 is an upper bound for p** (only smaller values of p could satisfy the equality)\\n\\nTherefore, the Akra Bazzi theorem tells us that our complexity will be bounded by:\\n$$T(N)< \\\\Theta \\\\left(\\\\sqrt N\\\\left(1+\\\\int _{1}^{N}{\\\\frac  {g(u)}{u^{{3/2}}}}du\\\\right)\\\\right)$$\\nWe can show with an integration by part that the integral is actually just O(1), so **our complexity is bounded by $O(\\\\sqrt N)$**\\n\\nWe note that, according to the [inequality of arithmetic and geometric means](https://en.wikipedia.org/wiki/Inequality_of_arithmetic_and_geometric_means),\\n$$\\\\sqrt N=\\\\sqrt{m*n}<=\\\\frac{m+n}{2}$$\\nSo $$T(N)<O(m+n)$$\\n\\n**Our complexity is at worst O(m+n). It is on-par with the \"trick\" solution in terms of time complexity**\\n\\n- Space complexity:\\nO(1) \\n\\n# Code\\n\\nThe code is probably ugly and could be written better but I tried to make it clear with comments. This is not the main point anyway, I mostly wanted to share the different approach, not so much the details of the implementation\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n       \\n        # helper function for binary search\\n        # inputs:   -row of the matrix that we are exploring\\n        #           -starting index of the row (based on the current submatrix)\\n        #           -final index of the row\\n        # returns True if target is found, otherwise, returns the largest value that is < target\\n        def bsearch(row,cstart,cend):\\n            left=cstart\\n            right=cend\\n            while left<=right:\\n                mid=(left+right)//2\\n                if matrix[row][mid]==target:\\n                    return True\\n                elif matrix[row][mid]<target:\\n                    if mid+1>cend or matrix[row][mid+1]>target: return mid\\n                    left=mid+1\\n                else:\\n                    if mid-1<cstart or matrix[row][mid-1]<target: return mid-1\\n                    right=mid-1\\n\\n\\n        # main function that does the matrix splitting based on the pivot point\\n        # input:    -rstart,rend : starting row and final row of current submatrix\\n        #           -cstart,cend : starting column and final column\\n        def dichotomy2D(rstart,rend,cstart,cend):\\n            # checking if we have reached some kind of stupid index that indicates end of search\\n            if cstart>cend or rstart<0 or rend >= len(matrix) or rstart>rend:\\n                return False\\n            #we select the middle row of the current submatrix\\n            row=(rstart+rend)//2\\n            #we perform the binary search on the middle row and retrun True if target is found\\n            split=bsearch(row,cstart,cend)\\n            if split is True:\\n                return True\\n            #otherwise, we subdivise the array into bottom left (from [row+1,cstart] to [rend,split]) and top right(from[row-1,split+1] to [rstart,cend]), and we check those recursively\\n            return dichotomy2D(max(row+1,rstart),rend,cstart,split) or dichotomy2D(rstart,min(row-1,rend),res+1,cend)\\n\\n        return dichotomy2D(0,len(matrix)-1,0,len(matrix[0])-1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Divide and Conquer",
                    "Matrix"
                ],
                "code": "```\\n|                                   |\\n|                                   |\\n|                                   |\\n|----------<>-----------------------| (binary search on middle row)\\n|                                   |\\n|                                   |\\n|                                   |\\n```\n```\\n|          |                        |\\n|ELIMINATED|                        |\\n|          |                        |\\n|----------<>-----------------------|\\n|           |                       |\\n|           |      ELIMINATED!      |\\n|           |                       |\\n```\n```\\n|          |    ELIM       |        |\\n|ELIMINATED|---------------<>-------|\\n|          |                | ELIM  |\\n|----------<>-----------------------|\\n|           |                       |\\n|           |      ELIMINATED!      |\\n|           |                       |\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n       \\n        # helper function for binary search\\n        # inputs:   -row of the matrix that we are exploring\\n        #           -starting index of the row (based on the current submatrix)\\n        #           -final index of the row\\n        # returns True if target is found, otherwise, returns the largest value that is < target\\n        def bsearch(row,cstart,cend):\\n            left=cstart\\n            right=cend\\n            while left<=right:\\n                mid=(left+right)//2\\n                if matrix[row][mid]==target:\\n                    return True\\n                elif matrix[row][mid]<target:\\n                    if mid+1>cend or matrix[row][mid+1]>target: return mid\\n                    left=mid+1\\n                else:\\n                    if mid-1<cstart or matrix[row][mid-1]<target: return mid-1\\n                    right=mid-1\\n\\n\\n        # main function that does the matrix splitting based on the pivot point\\n        # input:    -rstart,rend : starting row and final row of current submatrix\\n        #           -cstart,cend : starting column and final column\\n        def dichotomy2D(rstart,rend,cstart,cend):\\n            # checking if we have reached some kind of stupid index that indicates end of search\\n            if cstart>cend or rstart<0 or rend >= len(matrix) or rstart>rend:\\n                return False\\n            #we select the middle row of the current submatrix\\n            row=(rstart+rend)//2\\n            #we perform the binary search on the middle row and retrun True if target is found\\n            split=bsearch(row,cstart,cend)\\n            if split is True:\\n                return True\\n            #otherwise, we subdivise the array into bottom left (from [row+1,cstart] to [rend,split]) and top right(from[row-1,split+1] to [rstart,cend]), and we check those recursively\\n            return dichotomy2D(max(row+1,rstart),rend,cstart,split) or dichotomy2D(rstart,min(row-1,rend),res+1,cend)\\n\\n        return dichotomy2D(0,len(matrix)-1,0,len(matrix[0])-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325154,
                "title": "python-easy-o-n-m-two-pointer-apporach",
                "content": "**UPVOTE PLS :-)**\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        i=0\\n        j=len(matrix[0])-1\\n        while(i<len(matrix) and j>=0):\\n            if target<matrix[i][j]:\\n                j-=1\\n            elif target>matrix[i][j]:\\n                i+=1\\n            else:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        i=0\\n        j=len(matrix[0])-1\\n        while(i<len(matrix) and j>=0):\\n            if target<matrix[i][j]:\\n                j-=1\\n            elif target>matrix[i][j]:\\n                i+=1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010646,
                "title": "c-binary-search-best-optimized-approach",
                "content": "****upvote if it you find helpfull -> thanks****\\n\\n\\t\\tint rowstart = 0;\\n        int rowend = matrix.size();\\n        int colend = matrix[0].size()-1;\\n        while(rowstart<rowend && colend>=0)\\n        {\\n            int element = matrix[rowstart][colend];\\n            if(element == target) return true;\\n            else if(target < element){\\n                colend--;\\n            }\\n            else if(target > element)rowstart++;\\n        }\\n        return false;",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "****upvote if it you find helpfull -> thanks****\\n\\n\\t\\tint rowstart = 0;\\n        int rowend = matrix.size();\\n        int colend = matrix[0].size()-1;\\n        while(rowstart<rowend && colend>=0)\\n        {\\n            int element = matrix[rowstart][colend];\\n            if(element == target) return true;\\n            else if(target < element){\\n                colend--;\\n            }\\n            else if(target > element)rowstart++;\\n        }\\n        return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 1397287,
                "title": "c-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i = 0;\\n\\t    int j = matrix[0].size()-1;\\n\\t    while(i<matrix.size() && j>=0){\\n\\t        if(matrix[i][j]==target) return true;\\n\\t        else if(matrix[i][j]<target)  i++;\\n\\t        else  j--;\\n\\t    }\\n\\t    return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i = 0;\\n\\t    int j = matrix[0].size()-1;\\n\\t    while(i<matrix.size() && j>=0){\\n\\t        if(matrix[i][j]==target) return true;\\n\\t        else if(matrix[i][j]<target)  i++;\\n\\t        else  j--;\\n\\t    }\\n\\t    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227998,
                "title": "java-binary-search-solution-with-illustration-and-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/b889c8d3-22ec-4074-b9ef-70059424c92d_1621867186.9592545.png)\\n\\nGiven a (sub)matrix enclosed by `(lox, loy)` and `(hix, hiy)`, just recursively search any 3 of 4 quadrants (excluding the impossible one) after comparing the `target` value with the value of the middle point `(i, j)`.\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        return search(matrix, target, 0, 0, m-1, n-1);\\n    }\\n    \\n    private boolean search (\\n        int[][] mat,\\n        int t,\\n        int lox,\\n        int loy,\\n        int hix,\\n        int hiy\\n    ) {\\n        if (lox > hix || loy > hiy) return false;\\n        int i = lox + (hix - lox) / 2;\\n        int j = loy + (hiy - loy) / 2;\\n        if (mat[i][j] < t) {\\n            return search(mat, t, lox, j+1, i, hiy)    // q1\\n                || search(mat, t, i+1, loy, hix, j)    // q3\\n                || search(mat, t, i+1, j+1, hix, hiy); // q4\\n        } else if (mat[i][j] > t) {\\n            return search(mat, t, lox, j, i-1, hiy)    // q1\\n                || search(mat, t, i, loy, hix, j-1)    // q3\\n                || search(mat, t, lox, loy, i-1, j-1); // q2\\n        } else {\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        return search(matrix, target, 0, 0, m-1, n-1);\\n    }\\n    \\n    private boolean search (\\n        int[][] mat,\\n        int t,\\n        int lox,\\n        int loy,\\n        int hix,\\n        int hiy\\n    ) {\\n        if (lox > hix || loy > hiy) return false;\\n        int i = lox + (hix - lox) / 2;\\n        int j = loy + (hiy - loy) / 2;\\n        if (mat[i][j] < t) {\\n            return search(mat, t, lox, j+1, i, hiy)    // q1\\n                || search(mat, t, i+1, loy, hix, j)    // q3\\n                || search(mat, t, i+1, j+1, hix, hiy); // q4\\n        } else if (mat[i][j] > t) {\\n            return search(mat, t, lox, j, i-1, hiy)    // q1\\n                || search(mat, t, i, loy, hix, j-1)    // q3\\n                || search(mat, t, lox, loy, i-1, j-1); // q2\\n        } else {\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079113,
                "title": "rust-o-m-n-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let (mut i, mut j) = (0, matrix[0].len() - 1);\\n        while i < matrix.len() {\\n            match matrix[i][j].cmp(&target) {\\n                std::cmp::Ordering::Less => i += 1,\\n                std::cmp::Ordering::Equal => return true,\\n                std::cmp::Ordering::Greater if j > 0 => j -= 1,\\n                std::cmp::Ordering::Greater => break,\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let (mut i, mut j) = (0, matrix[0].len() - 1);\\n        while i < matrix.len() {\\n            match matrix[i][j].cmp(&target) {\\n                std::cmp::Ordering::Less => i += 1,\\n                std::cmp::Ordering::Equal => return true,\\n                std::cmp::Ordering::Greater if j > 0 => j -= 1,\\n                std::cmp::Ordering::Greater => break,\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1079082,
                "title": "python-c-o-m-n-explained-just-walk-from-top-right-corner",
                "content": "# Algorithm:\\nHere we do not want to be smart heads, because binary search is not very much faster and not easy to understand. Fastest one is **O(min(N, M) * log(max(N, M) / min(N, M)))**, which you can find here\\nhttp://twistedoakstudios.com/blog/Post5365_searching-a-sorted-matrix-faster\\n\\nWe going to solve it by **O(N + M)** complexity. \\nIdea is that if we go down, all number above and on the left are smaller, while if we go left all number under and on the right are larger, so we basically need to _go down_ if we need number _larger_ and _go left_ if we need _smaller_. Last question os where to start? If we will only go _down_ and _left_, we need to start _at most up and right_ spot, so we don\\'t miss enything. Here illustration how we will do that:\\n\\n# Illustrations:\\n### For target `5`:\\n![image](https://assets.leetcode.com/users/images/dfc2f727-bfb6-4098-8630-b7e7b8bb86e9_1614070035.582655.png)\\n\\n### For target 20:\\n![image](https://assets.leetcode.com/users/images/10a7c6a7-9f44-41c0-9e61-316f67273a54_1614070050.6790533.png)\\n\\n## Python code:\\n```\\nclass Solution:\\n  def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n    i, j = 0, len(matrix[0]) - 1\\n    while i < len(matrix) and j >= 0:\\n      if matrix[i][j] < target:\\n        i += 1\\n      elif matrix[i][j] > target:\\n        j -= 1\\n      else:\\n        return True\\n    return False\\n```\\n\\n## C++ Code:\\n```\\nclass Solution {\\n  public:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n    int i = 0, j = matrix[0].size() - 1;\\n    while (i < matrix.size() && j >= 0){\\n      if (matrix[i][j] < target){\\n        ++i; \\n      } else if (matrix[i][j] > target){\\n        --j;\\n      } else {\\n        return true;\\n      } \\n    }\\n    return false;\\n    }\\n};\\n```\\n\\n### Further reading:\\nIf you wonder how **O(min(N, M) * log(max(N, M) / min(N, M)))** looks like: \\n![image](https://i.imgur.com/USX7Qrl.gif)\\nMore details here: http://twistedoakstudios.com/blog/Post5365_searching-a-sorted-matrix-faster",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n  def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n    i, j = 0, len(matrix[0]) - 1\\n    while i < len(matrix) and j >= 0:\\n      if matrix[i][j] < target:\\n        i += 1\\n      elif matrix[i][j] > target:\\n        j -= 1\\n      else:\\n        return True\\n    return False\\n```\n```\\nclass Solution {\\n  public:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n    int i = 0, j = matrix[0].size() - 1;\\n    while (i < matrix.size() && j >= 0){\\n      if (matrix[i][j] < target){\\n        ++i; \\n      } else if (matrix[i][j] > target){\\n        --j;\\n      } else {\\n        return true;\\n      } \\n    }\\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642522,
                "title": "java-solution-with-explaination-faster-than-100",
                "content": "Two condition provided is \\n1. rows are sorted in ascending order\\n2. cols are sorted in ascending order\\n\\n*  We first start with first row and last column element in 2D matrix.\\n*  Idea here is we maintain two pointer\\'s.\\n    i) for row\\n   ii) for col\\njust like any 2D matrix problems\\n\\n* now we compare current Element pointed by rowIndex and colIndex with target, if it matches then return true.\\n* if it does not match then, two possibility, we can go down(rowIndex++) or go left(colIndex--)\\n* we compare if current Element is smaller than the target\\n   i) if it\\'s smaller, then we go down as all the elemnts on the left side of the current element is smaller(rows in ascending order).\\nii) if not, then we go left, as our solution doesnot lie in current column(because col is sorted in ascending, so all the elements below in current col are greater than current element.)\\n\\nTime Complexity:\\nassuming, \\nnum of rows = m\\nnum of cols = n\\n\\ncomplexity : O(m+n)\\n\\nSpace complexity: O(1)\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix.length == 0) return false;\\n       \\n        int rowIndex = 0;\\n        int colIndex = matrix[0].length - 1;\\n        \\n        while(rowIndex < matrix.length && colIndex >= 0) {\\n            if (matrix[rowIndex][colIndex] == target)\\n                return true;\\n            \\n            if(matrix[rowIndex][colIndex] < target)\\n                rowIndex++;\\n            else\\n                colIndex--;\\n        }\\n        \\n        return false;\\n    }    \\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix.length == 0) return false;\\n       \\n        int rowIndex = 0;\\n        int colIndex = matrix[0].length - 1;\\n        \\n        while(rowIndex < matrix.length && colIndex >= 0) {\\n            if (matrix[rowIndex][colIndex] == target)\\n                return true;\\n            \\n            if(matrix[rowIndex][colIndex] < target)\\n                rowIndex++;\\n            else\\n                colIndex--;\\n        }\\n        \\n        return false;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440400,
                "title": "all-four-approaches-in-c",
                "content": "The following are all the four approaches mentioned in the solution in C++,\\n\\n**1. Brute-Force:**\\n\\n```\\n//Vinayak Kukreja\\n//Time Complexity --> n x m matrix --> O(nm)\\n//Space Complexity --> O(1) if we do not consider input provided in the complexity\\n\\n//Approach #1 --> Brute Force\\n//Version --> 1.0\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rowLength = matrix.size(); \\n        if(rowLength == 0)  //Checking if there are no rows, then false\\n            return false;\\n        int colLength = matrix[0].size();\\n        \\n        //Iterating through every value and checking against the target\\n        for(int i = 0; i < rowLength; i++)\\n            for(int j = 0; j < colLength; j++)\\n                if(matrix[i][j] == target)\\n                    return true;    //Target Found\\n        \\n        return false;   //Target Not Found\\n    }\\n};\\n```\\n\\n**2. Binary-Search:**\\n\\n```\\n//Vinayak Kukreja\\n//Time Complexity --> O(lg(n!))\\n//Space Complexity --> O(1)\\n\\n//Approach #2 --> Via Binary Search\\n//Version --> 1.0\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rowLength = matrix.size();\\n        if(rowLength == 0)  //If the number of rows are zero, then returning false\\n            return false;\\n        int colLength = matrix[0].size();\\n        \\n        int shorterDimension = min(rowLength, colLength);   //Getting the shorter length between column and row size, it is necessary we take the shorter one or else index out of bound might occur\\n        \\n        for(int startPos = 0; startPos < shorterDimension; startPos++){\\n            //Searching first column slice and then row slice\\n            if(binarySearch(matrix, target, startPos, true) || binarySearch(matrix, target, startPos, false))\\n                return true;    //Target found\\n        }\\n        return false;   //Target not found\\n    }\\n    \\n    //Applying binary search to column or row slice of 2D matrix and searching for target\\n    bool binarySearch(vector<vector<int>>& matrix, int target, int startingPos, bool rowOrCol){\\n        int low = startingPos;  //This position changes via for loop implemented before\\n        //Therefore we go in an rotated L-shape kind of flow from left top to right bottom as the start\\n        //position increases\\n        //  |--------\\n        //  | |------\\n        //  | | |----\\n        int high = rowOrCol ? matrix[0].size()-1 : matrix.size()-1;     //Selecting high value based on searching column or row slice currently, if true then column, if not then row\\n              \\n        //The following is similar to how binary search works\\n        while(low <= high){\\n            int mid = (low + high) / 2;     //Calculating middle\\n            if(rowOrCol){\\n                //If searching columns\\n                if(matrix[startingPos][mid] > target)\\n                    high = mid - 1;\\n                else if(matrix[startingPos][mid] < target)\\n                    low = mid + 1;\\n                else\\n                    return true;\\n            }\\n            else{\\n                //If searching rows\\n                if(matrix[mid][startingPos] > target)\\n                    high = mid - 1;\\n                else if(matrix[mid][startingPos] < target)\\n                    low = mid + 1;\\n                else\\n                    return true;\\n            }\\n        }\\n        return false;   //When target now found in this iteration\\n    }\\n};\\n```\\n\\n**3. Divide and Conquer:**\\n\\n*I am unable to solve memory limit error in this. I think the solution should be working in each case and if someone finds the problem with the following, please do let me know, I would update the code. Sorry for the inconvenience,*\\n\\n```\\n//Vinayak Kukreja\\n//Time Complexity --> O(nlgn)\\n//Space Complexity --> O(lgn)\\n\\n//Approach #3 --> Divide And Conquer\\n//Version --> 1.0\\n\\nclass Solution {\\nprivate:\\n    vector<vector<int>> matrixLoc;\\n    int targLoc;\\n\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        //Transfering to local variables for less variables to pass during recursion\\n        matrixLoc = matrix;     \\n        targLoc = target;\\n        \\n        if(matrixLoc.size() == 0)   //Checking if no rows present, then returning false\\n            return false;\\n        \\n        //Starting search from top leftmost index to rightmost bottom index\\n        return recursiveSearch(0, 0, matrix.size()-1, matrix[0].size()-1);\\n    }\\n    \\n    bool recursiveSearch(int rowLow, int colLow, int rowHigh, int colHigh){\\n        \\n        //Checking if the matrix is having no height or width\\n        if(colLow > colHigh || rowLow > rowHigh)\\n            return false;\\n        \\n        //Checking if the values at extreme ends of given matrix are either bigger or smaller than target, then target would not be present in the matrix\\n        else if(matrixLoc[rowLow][colLow] > targLoc || matrixLoc[rowHigh][colHigh] < targLoc)\\n            return false;\\n        \\n        else{\\n            int colMid = colLow + (colHigh-colLow)/2;\\n        \\n            //To find such a row where,\\n            //matrixLoc[row-1][colMid] < targetLoc < matrixLoc[row][colMid]\\n            int row = rowLow;\\n            while(row <=  rowHigh && matrixLoc[row][colMid] <= targLoc){\\n                //checking middle column elements against target value\\n                if(matrixLoc[row][colMid] == targLoc)   \\n                    return true;\\n                \\n                ++row;\\n            }\\n            \\n            //Recursively now checking the bottom left and top right sub matrices formed\\n            return recursiveSearch(row, colLow, rowHigh, colMid-1) || recursiveSearch(rowLow, colMid+1, row-1, colHigh);\\n        }\\n    }\\n};\\n```\\n\\n**4. Search Space Reduction:**\\n\\n```\\n//Vinayak Kukreja\\n//Time Complexity --> O(m+n)\\n//Space Complexity --> O(1)\\n\\n//Approach #4 --> Search Space Reduction\\n//Version --> 1.0\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rowLength = matrix.size();\\n        //Checking if there are no rows and hence returning false \\n        if(rowLength == 0)\\n            return false;\\n        int colLength = matrix[0].size();\\n        \\n        int i = 0, j = colLength - 1;   //Starting from the top-right of the matrix\\n        //Moving left if the target is less than the value since column values below would be greater\\n        //Moving down if the target is greater than the value because all the values on the left would be smaller\\n        while( i < rowLength && j >= 0)\\n        {\\n            if(matrix[i][j] == target){\\n                return true;\\n            }\\n            else if(matrix[i][j] > target){     //If the current value is greater, then it means the values below this i.e. inside this column would be greater, therefore moving to the left\\n                j--;\\n            }\\n            else{   //Moving down, because all the values would be smaller on the left\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//Vinayak Kukreja\\n//Time Complexity --> n x m matrix --> O(nm)\\n//Space Complexity --> O(1) if we do not consider input provided in the complexity\\n\\n//Approach #1 --> Brute Force\\n//Version --> 1.0\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rowLength = matrix.size(); \\n        if(rowLength == 0)  //Checking if there are no rows, then false\\n            return false;\\n        int colLength = matrix[0].size();\\n        \\n        //Iterating through every value and checking against the target\\n        for(int i = 0; i < rowLength; i++)\\n            for(int j = 0; j < colLength; j++)\\n                if(matrix[i][j] == target)\\n                    return true;    //Target Found\\n        \\n        return false;   //Target Not Found\\n    }\\n};\\n```\n```\\n//Vinayak Kukreja\\n//Time Complexity --> O(lg(n!))\\n//Space Complexity --> O(1)\\n\\n//Approach #2 --> Via Binary Search\\n//Version --> 1.0\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rowLength = matrix.size();\\n        if(rowLength == 0)  //If the number of rows are zero, then returning false\\n            return false;\\n        int colLength = matrix[0].size();\\n        \\n        int shorterDimension = min(rowLength, colLength);   //Getting the shorter length between column and row size, it is necessary we take the shorter one or else index out of bound might occur\\n        \\n        for(int startPos = 0; startPos < shorterDimension; startPos++){\\n            //Searching first column slice and then row slice\\n            if(binarySearch(matrix, target, startPos, true) || binarySearch(matrix, target, startPos, false))\\n                return true;    //Target found\\n        }\\n        return false;   //Target not found\\n    }\\n    \\n    //Applying binary search to column or row slice of 2D matrix and searching for target\\n    bool binarySearch(vector<vector<int>>& matrix, int target, int startingPos, bool rowOrCol){\\n        int low = startingPos;  //This position changes via for loop implemented before\\n        //Therefore we go in an rotated L-shape kind of flow from left top to right bottom as the start\\n        //position increases\\n        //  |--------\\n        //  | |------\\n        //  | | |----\\n        int high = rowOrCol ? matrix[0].size()-1 : matrix.size()-1;     //Selecting high value based on searching column or row slice currently, if true then column, if not then row\\n              \\n        //The following is similar to how binary search works\\n        while(low <= high){\\n            int mid = (low + high) / 2;     //Calculating middle\\n            if(rowOrCol){\\n                //If searching columns\\n                if(matrix[startingPos][mid] > target)\\n                    high = mid - 1;\\n                else if(matrix[startingPos][mid] < target)\\n                    low = mid + 1;\\n                else\\n                    return true;\\n            }\\n            else{\\n                //If searching rows\\n                if(matrix[mid][startingPos] > target)\\n                    high = mid - 1;\\n                else if(matrix[mid][startingPos] < target)\\n                    low = mid + 1;\\n                else\\n                    return true;\\n            }\\n        }\\n        return false;   //When target now found in this iteration\\n    }\\n};\\n```\n```\\n//Vinayak Kukreja\\n//Time Complexity --> O(nlgn)\\n//Space Complexity --> O(lgn)\\n\\n//Approach #3 --> Divide And Conquer\\n//Version --> 1.0\\n\\nclass Solution {\\nprivate:\\n    vector<vector<int>> matrixLoc;\\n    int targLoc;\\n\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        //Transfering to local variables for less variables to pass during recursion\\n        matrixLoc = matrix;     \\n        targLoc = target;\\n        \\n        if(matrixLoc.size() == 0)   //Checking if no rows present, then returning false\\n            return false;\\n        \\n        //Starting search from top leftmost index to rightmost bottom index\\n        return recursiveSearch(0, 0, matrix.size()-1, matrix[0].size()-1);\\n    }\\n    \\n    bool recursiveSearch(int rowLow, int colLow, int rowHigh, int colHigh){\\n        \\n        //Checking if the matrix is having no height or width\\n        if(colLow > colHigh || rowLow > rowHigh)\\n            return false;\\n        \\n        //Checking if the values at extreme ends of given matrix are either bigger or smaller than target, then target would not be present in the matrix\\n        else if(matrixLoc[rowLow][colLow] > targLoc || matrixLoc[rowHigh][colHigh] < targLoc)\\n            return false;\\n        \\n        else{\\n            int colMid = colLow + (colHigh-colLow)/2;\\n        \\n            //To find such a row where,\\n            //matrixLoc[row-1][colMid] < targetLoc < matrixLoc[row][colMid]\\n            int row = rowLow;\\n            while(row <=  rowHigh && matrixLoc[row][colMid] <= targLoc){\\n                //checking middle column elements against target value\\n                if(matrixLoc[row][colMid] == targLoc)   \\n                    return true;\\n                \\n                ++row;\\n            }\\n            \\n            //Recursively now checking the bottom left and top right sub matrices formed\\n            return recursiveSearch(row, colLow, rowHigh, colMid-1) || recursiveSearch(rowLow, colMid+1, row-1, colHigh);\\n        }\\n    }\\n};\\n```\n```\\n//Vinayak Kukreja\\n//Time Complexity --> O(m+n)\\n//Space Complexity --> O(1)\\n\\n//Approach #4 --> Search Space Reduction\\n//Version --> 1.0\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rowLength = matrix.size();\\n        //Checking if there are no rows and hence returning false \\n        if(rowLength == 0)\\n            return false;\\n        int colLength = matrix[0].size();\\n        \\n        int i = 0, j = colLength - 1;   //Starting from the top-right of the matrix\\n        //Moving left if the target is less than the value since column values below would be greater\\n        //Moving down if the target is greater than the value because all the values on the left would be smaller\\n        while( i < rowLength && j >= 0)\\n        {\\n            if(matrix[i][j] == target){\\n                return true;\\n            }\\n            else if(matrix[i][j] > target){     //If the current value is greater, then it means the values below this i.e. inside this column would be greater, therefore moving to the left\\n                j--;\\n            }\\n            else{   //Moving down, because all the values would be smaller on the left\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344435,
                "title": "python3-search-a-2d-matrix-o-m-n",
                "content": "\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if len(matrix) == 0: return False\\n        # we initialize the pointer at the bottom-left of the matrix\\n        r,c = len(matrix)-1,0\\n        while r >=0 and c <len(matrix[0]):\\n            if matrix[r][c] == target:\\n                return True\\n            else:\\n                if matrix[r][c] < target:\\n                    c += 1\\n                else:\\n                    r -= 1\\n        return False\\n```\\n* Time complexity: O(m+n)\\n\\tm is the number of rows, and n is the number of columns.\\n    The worst-case here is that the algorithm needs to finish scan one row and one column.\\n* Space complexity: O(1)\\n    The algorithm only needs four integers : row, col, height, width, so the space complexity is constant.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if len(matrix) == 0: return False\\n        # we initialize the pointer at the bottom-left of the matrix\\n        r,c = len(matrix)-1,0\\n        while r >=0 and c <len(matrix[0]):\\n            if matrix[r][c] == target:\\n                return True\\n            else:\\n                if matrix[r][c] < target:\\n                    c += 1\\n                else:\\n                    r -= 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307132,
                "title": "o-log-m-log-n-double-directional-binary-search-in-java",
                "content": "**Idea:**\\n- Search from top-right corner of the matrix;\\n- If the current number is smaller than `target`, binary search row from `row + 1` to `rows - 1` given the current `col`;\\n- Else if the current number is greater than `target`, binary search col from `0` to `cols - 1` given the current `row`.\\n\\n**Code:**\\n```java\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int rows, cols;\\n        // Input check\\n        if (matrix == null || (rows = matrix.length) == 0 || (cols = matrix[0].length) == 0) {\\n            return false;\\n        }\\n        \\n        for (int row = 0, col = cols - 1; row >= 0 && row < rows && col >= 0 && col < cols;) {\\n            if (matrix[row][col] == target) {\\n                // Found target\\n                return true;\\n            }\\n            if (matrix[row][col] < target) {\\n                // Target is greater than current number, binary search row in [row + 1, rows - 1] in current column\\n                row = binarySearchInCol(matrix, target, rows, cols, col, row + 1, rows - 1);\\n            } else {\\n                // Target is smaller than current number, binary search col in [0, col - 1] in current row\\n                col = binarySearchInRow(matrix, target, rows, cols, row, 0, col - 1);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int binarySearchInRow(int[][] matrix, int target, int rows, int cols, int row, int low, int high) {\\n        if (low > high) {\\n            return cols;\\n        }\\n        while (low < high) {\\n            int mid = low + ((high - low) >> 1);\\n            if (matrix[row][mid] >= target) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    private int binarySearchInCol(int[][] matrix, int target, int rows, int cols, int col, int low, int high) {\\n        if (low > high) {\\n            return rows;\\n        }\\n        while (low < high) {\\n            int mid = low + ((high - low) >> 1);\\n            if (matrix[mid][col] >= target) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int rows, cols;\\n        // Input check\\n        if (matrix == null || (rows = matrix.length) == 0 || (cols = matrix[0].length) == 0) {\\n            return false;\\n        }\\n        \\n        for (int row = 0, col = cols - 1; row >= 0 && row < rows && col >= 0 && col < cols;) {\\n            if (matrix[row][col] == target) {\\n                // Found target\\n                return true;\\n            }\\n            if (matrix[row][col] < target) {\\n                // Target is greater than current number, binary search row in [row + 1, rows - 1] in current column\\n                row = binarySearchInCol(matrix, target, rows, cols, col, row + 1, rows - 1);\\n            } else {\\n                // Target is smaller than current number, binary search col in [0, col - 1] in current row\\n                col = binarySearchInRow(matrix, target, rows, cols, row, 0, col - 1);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int binarySearchInRow(int[][] matrix, int target, int rows, int cols, int row, int low, int high) {\\n        if (low > high) {\\n            return cols;\\n        }\\n        while (low < high) {\\n            int mid = low + ((high - low) >> 1);\\n            if (matrix[row][mid] >= target) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    private int binarySearchInCol(int[][] matrix, int target, int rows, int cols, int col, int low, int high) {\\n        if (low > high) {\\n            return rows;\\n        }\\n        while (low < high) {\\n            int mid = low + ((high - low) >> 1);\\n            if (matrix[mid][col] >= target) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173902,
                "title": "simple-easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if not matrix:\\n            return False\\n        i, j = 0, len(matrix[0]) - 1\\n        while 0 <= i < len(matrix) and 0 <= j < len(matrix[0]):\\n            if target < matrix[i][j]:\\n                j -= 1\\n            elif target > matrix[i][j]:\\n                i += 1\\n            else:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if not matrix:\\n            return False\\n        i, j = 0, len(matrix[0]) - 1\\n        while 0 <= i < len(matrix) and 0 <= j < len(matrix[0]):\\n            if target < matrix[i][j]:\\n                j -= 1\\n            elif target > matrix[i][j]:\\n                i += 1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66259,
                "title": "an-easy-understanding-solution",
                "content": "     // any comments are welcome\\n     bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i = 0, j = n - 1;\\n        \\n        // search target from up-right side to down-left side\\n        while (i <= m-1 && j >= 0) {\\n            if (matrix[i][j] == target)\\n                return true;\\n            else if (matrix[i][j] > target)\\n                --j;\\n            else // matrix[i][j] < target\\n                ++i;\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "     // any comments are welcome\\n     bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i = 0, j = n - 1;\\n        \\n        // search target from up-right side to down-left side\\n        while (i <= m-1 && j >= 0) {\\n            if (matrix[i][j] == target)\\n                return true;\\n            else if (matrix[i][j] > target)\\n                --j;\\n            else // matrix[i][j] < target\\n                ++i;\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3949622,
                "title": "best-o-m-n-solution",
                "content": "# Approach\\nTwo Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(m+n)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i = 0, j = n - 1;\\n        while (i < m && j >= 0) {\\n            if (matrix[i][j] == target)\\n                return true;\\n            else if (matrix[i][j] > target)\\n                j--;\\n            else\\n                i++;        \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i = 0, j = n - 1;\\n        while (i < m && j >= 0) {\\n            if (matrix[i][j] == target)\\n                return true;\\n            else if (matrix[i][j] > target)\\n                j--;\\n            else\\n                i++;        \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922848,
                "title": "most-optimal-solution-with-explanation-eliminating-the-rows-and-cols-concept-of-binary-search",
                "content": "\\n\\n# Approach\\n1. Start from the top-right corner of the matrix (row = 0, col = m-1), where n is the number of rows and m is the number of columns in the matrix.\\n2. Compare the element at the current position (matrix[row][col]) with the target value:\\n    - If the element is equal to the target, return true.\\n    - If the element is less than the target, move to the next row (row++) to explore larger elements.\\n    - If the element is greater than the target, move to the previous column (col--) to explore smaller elements.\\n3. Continue the process until either the target is found, or the search goes out of bounds (row >= n or col < 0).\\n4. If the target is not found in the matrix, return false.\\n\\n# Complexity\\n- Time complexity:\\nO(m+n)\\n\\n- Space complexity:\\nO(1)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int row = 0, col = m-1;\\n        while(row < n && col >= 0) {\\n            if (matrix[row][col] == target) return true;\\n            else if (matrix[row][col] < target) row++;\\n            else col--;\\n        }\\n        return false;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int row = 0, col = m - 1;\\n        \\n        while (row < n && col >= 0) {\\n            if (matrix[row][col] == target) {\\n                return true;\\n            } else if (matrix[row][col] < target) {\\n                row++;\\n            } else {\\n                col--;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        row, col = 0, m - 1\\n        \\n        while row < n and col >= 0:\\n            if matrix[row][col] == target:\\n                return True\\n            elif matrix[row][col] < target:\\n                row += 1\\n            else:\\n                col -= 1\\n        \\n        return False\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer",
                    "Matrix"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int row = 0, col = m-1;\\n        while(row < n && col >= 0) {\\n            if (matrix[row][col] == target) return true;\\n            else if (matrix[row][col] < target) row++;\\n            else col--;\\n        }\\n        return false;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int row = 0, col = m - 1;\\n        \\n        while (row < n && col >= 0) {\\n            if (matrix[row][col] == target) {\\n                return true;\\n            } else if (matrix[row][col] < target) {\\n                row++;\\n            } else {\\n                col--;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        row, col = 0, m - 1\\n        \\n        while row < n and col >= 0:\\n            if matrix[row][col] == target:\\n                return True\\n            elif matrix[row][col] < target:\\n                row += 1\\n            else:\\n                col -= 1\\n        \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916490,
                "title": "c-binary-search-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].size()-1;\\n\\n        while(i<matrix.size() && j>=0){\\n            if(matrix[i][j]==target)return true;\\n            else if(matrix[i][j]<target)i++;\\n            else j--;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].size()-1;\\n\\n        while(i<matrix.size() && j>=0){\\n            if(matrix[i][j]==target)return true;\\n            else if(matrix[i][j]<target)i++;\\n            else j--;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767522,
                "title": "java-easy-solution-with-comments",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].length-1;\\n        while(row<matrix.length && col>=0){\\n            if(matrix[row][col]==target) return true;\\n            else if(matrix[row][col]<target) row++; //if that element is lesser than target it mean that whole row is useless\\n            else col--; //if that element is greater than target it mean that column is useless \\n        }\\n        return false;\\n    }\\n}\\n\\n//In given example 1, it will start with 15, now 15>5 so all elements of last column will be greater than 5\\n//therefore col--;\\n//Now it will check 11... This way when 4 will come, 4<5 so all elements in that row will be smaller than 4\\n//so row++; \\n```\\n![upvoteCat.png](https://assets.leetcode.com/users/images/56e36cbe-69ab-4de9-a348-7f3e59bd6171_1689406643.5026598.png)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].length-1;\\n        while(row<matrix.length && col>=0){\\n            if(matrix[row][col]==target) return true;\\n            else if(matrix[row][col]<target) row++; //if that element is lesser than target it mean that whole row is useless\\n            else col--; //if that element is greater than target it mean that column is useless \\n        }\\n        return false;\\n    }\\n}\\n\\n//In given example 1, it will start with 15, now 15>5 so all elements of last column will be greater than 5\\n//therefore col--;\\n//Now it will check 11... This way when 4 will come, 4<5 so all elements in that row will be smaller than 4\\n//so row++; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553736,
                "title": "o-m-n-easy-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are two points from where we can start searching i.e - \\n1) From top right corner\\n2) From bottom left corner\\nIn this approach, I have explained throung top right corner, take a Starting position to top right corner value of matrix and compare if(position == target) return true, \\nor if(position < target) then jump to the position to next row of same column because the values below our position can caontains target vcalue;\\nor if(position > target) then jump to previous column of same row as only the values to the left of position can contains target value.\\nRepeat until you reach last row or first column.\\n\\n![Screenshot (501).png](https://assets.leetcode.com/users/images/4ce363ab-c62f-4597-8104-bd640c8d09dc_1684795370.9902685.png)\\n\\n# Complexity\\n- Time complexity: <b>O(n+m)</b>\\n- Auxillary Space complexity: <b>O(1)</b>\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int row = 0;\\n        int col = m-1;\\n        while(row < n && col >= 0)\\n        {\\n            if(matrix[row][col] == target) return true;\\n            else if(matrix[row][col] < target) row++;\\n            else    col--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Divide and Conquer",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int row = 0;\\n        int col = m-1;\\n        while(row < n && col >= 0)\\n        {\\n            if(matrix[row][col] == target) return true;\\n            else if(matrix[row][col] < target) row++;\\n            else    col--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932829,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int r=0,c=n-1;\\n        while(r<m && c>=0)\\n        {\\n            if(matrix[r][c]==target)\\n                return target;\\n            else if(matrix[r][c]>target)\\n                c--;\\n            else\\n                r++;\\n        }\\n        return false;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int r=0,c=n-1;\\n        while(r<m && c>=0)\\n        {\\n            if(matrix[r][c]==target)\\n                return target;\\n            else if(matrix[r][c]>target)\\n                c--;\\n            else\\n                r++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778034,
                "title": "240-search-a-2d-matrix-i",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolve it by using binary search on each row\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraversing each row from bottom and check if the target lies in the range of the first and last element of ith row.If the target lies in the range then search for target using binary search.If found then return true.If not,then continue the traversing.If the last element of any row is found to be less than the target then break the loop and return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <iostream>\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    bool searchMatrix(vector<vector<int>> &matrix, int target)\\n    {\\n        int row = matrix.size(), col = matrix[0].size();\\n        for (int i = row - 1; i >= 0; i--)\\n        {\\n            if (matrix[i][0] <= target && target <= matrix[i][col - 1])\\n            {\\n                int r = col - 1, l = 0, mid;\\n                while (l <= r)\\n                {\\n                    mid = (l + r) / 2;\\n                    if (matrix[i][mid] == target)\\n                    {\\n                        return true;\\n                    }\\n                    else if (matrix[i][mid] < target)\\n                    {\\n                        l = mid + 1;\\n                    }\\n                    else\\n                        r = mid - 1;\\n                    ;\\n                }\\n            }\\n            else if (target > matrix[i][col - 1])\\n            {\\n                break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <iostream>\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    bool searchMatrix(vector<vector<int>> &matrix, int target)\\n    {\\n        int row = matrix.size(), col = matrix[0].size();\\n        for (int i = row - 1; i >= 0; i--)\\n        {\\n            if (matrix[i][0] <= target && target <= matrix[i][col - 1])\\n            {\\n                int r = col - 1, l = 0, mid;\\n                while (l <= r)\\n                {\\n                    mid = (l + r) / 2;\\n                    if (matrix[i][mid] == target)\\n                    {\\n                        return true;\\n                    }\\n                    else if (matrix[i][mid] < target)\\n                    {\\n                        l = mid + 1;\\n                    }\\n                    else\\n                        r = mid - 1;\\n                    ;\\n                }\\n            }\\n            else if (target > matrix[i][col - 1])\\n            {\\n                break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2554392,
                "title": "search-in-a-2d-matrix-using-binary-search",
                "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n         int row= matrix.length;\\n        int column= matrix[0].length;\\n        \\n        int rowindex=0;\\n        int columnindex=column-1;\\n        \\n        while(rowindex<row && columnindex>=0){\\n            \\n            int element= matrix[rowindex][columnindex];\\n            \\n            if(element==target){\\n                return true;\\n            }\\n            else if(element<target){\\n                rowindex++;\\n                \\n            }\\n            else{\\n                columnindex--;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n         int row= matrix.length;\\n        int column= matrix[0].length;\\n        \\n        int rowindex=0;\\n        int columnindex=column-1;\\n        \\n        while(rowindex<row && columnindex>=0){\\n            \\n            int element= matrix[rowindex][columnindex];\\n            \\n            if(element==target){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2327323,
                "title": "golang-true-binary-search-two-pointers",
                "content": "\\n\\n**1.Diagonal binary search. Complexity O(ln(n) + ln(m))**\\n\\n```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\n\\tn, m := len(matrix), len(matrix[0])\\n\\n\\tmin := func(i1 int, i2 int) int {\\n\\t\\tif i1 < i2 {\\n\\t\\t\\treturn i1\\n\\t\\t}\\n\\t\\treturn i2\\n\\t}\\n\\t\\n\\tvar binarysearch func(x1 int, x2 int, y1 int, y2 int) bool\\n\\tbinarysearch = func(x1 int, x2 int, y1 int, y2 int) bool {\\n\\t\\tif x1 > x2 || y1 > y2 {\\n\\t\\t\\treturn false\\n\\t\\t}\\t\\n\\t\\tdelta := min(x2 - x1,  y2 - y1);\\n\\t\\tlo1, lo2, hi1, hi2 := x1, y1, x1 + delta, y1 + delta\\n\\n\\t\\tfor lo1 <= hi1 && lo2 <= hi2 {\\n\\t\\t\\tm1 := lo1 + (hi1 - lo1) / 2\\n\\t\\t\\tm2 := lo2 + (hi2 - lo2) / 2\\n\\t\\t\\tv := matrix[m1][m2]\\n\\t\\t\\tif v == target {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t} else if matrix[m1][m2] > target {\\n\\t\\t\\t\\thi1 = m1 - 1\\n\\t\\t\\t\\thi2 = m2 - 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlo1 = m1 + 1\\n\\t\\t\\t\\tlo2 = m2 + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn binarysearch(lo1, x2, y1, hi2) || binarysearch(x1, hi1, lo2, y2)\\t\\n\\t}\\n\\n\\treturn binarysearch(0, n-1, 0, m-1)\\n}\\n```\\n\\n**2. Two pointer approach. Complexity O(n + m)**\\n```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\n\\tn, m := len(matrix), len(matrix[0])\\n\\ti, j := 0, m-1\\n\\t\\n\\tfor i < n && j >= 0 {\\n\\t\\tv := matrix[i][j]\\n\\t\\tif v == target {\\n\\t\\t\\treturn true\\n\\t\\t} else if v > target {\\n\\t\\t\\tj -= 1\\n\\t\\t} else { \\n\\t\\t\\ti += 1\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\n\\tn, m := len(matrix), len(matrix[0])\\n\\n\\tmin := func(i1 int, i2 int) int {\\n\\t\\tif i1 < i2 {\\n\\t\\t\\treturn i1\\n\\t\\t}\\n\\t\\treturn i2\\n\\t}\\n\\t\\n\\tvar binarysearch func(x1 int, x2 int, y1 int, y2 int) bool\\n\\tbinarysearch = func(x1 int, x2 int, y1 int, y2 int) bool {\\n\\t\\tif x1 > x2 || y1 > y2 {\\n\\t\\t\\treturn false\\n\\t\\t}\\t\\n\\t\\tdelta := min(x2 - x1,  y2 - y1);\\n\\t\\tlo1, lo2, hi1, hi2 := x1, y1, x1 + delta, y1 + delta\\n\\n\\t\\tfor lo1 <= hi1 && lo2 <= hi2 {\\n\\t\\t\\tm1 := lo1 + (hi1 - lo1) / 2\\n\\t\\t\\tm2 := lo2 + (hi2 - lo2) / 2\\n\\t\\t\\tv := matrix[m1][m2]\\n\\t\\t\\tif v == target {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t} else if matrix[m1][m2] > target {\\n\\t\\t\\t\\thi1 = m1 - 1\\n\\t\\t\\t\\thi2 = m2 - 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlo1 = m1 + 1\\n\\t\\t\\t\\tlo2 = m2 + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn binarysearch(lo1, x2, y1, hi2) || binarysearch(x1, hi1, lo2, y2)\\t\\n\\t}\\n\\n\\treturn binarysearch(0, n-1, 0, m-1)\\n}\\n```\n```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\n\\tn, m := len(matrix), len(matrix[0])\\n\\ti, j := 0, m-1\\n\\t\\n\\tfor i < n && j >= 0 {\\n\\t\\tv := matrix[i][j]\\n\\t\\tif v == target {\\n\\t\\t\\treturn true\\n\\t\\t} else if v > target {\\n\\t\\t\\tj -= 1\\n\\t\\t} else { \\n\\t\\t\\ti += 1\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325012,
                "title": "using-two-pointer-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n         int n=matrix.size();\\n        int m=matrix[0].size()-1;\\n        int i=0;\\n        int j=m;\\n        while(i<n&&j>=0)\\n        {\\n            if(matrix[i][j]==target) // RETURN TRUE IF TARGET GOT FOUND\\n            return true;\\n            else if(matrix[i][j]>target)\\n            {\\n                j--;\\n            }\\n            else \\n            {\\n                i++;\\n            }\\n        }\\n        \\n        return false; // TARGET IS NOT PRESENT.SO RETURN FALSE\\n    }\\n};\\n```\\n**TIME COMPLEXITY;-O(M+N)**\\n**SPACE COMPLEXITY:-O(1)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n         int n=matrix.size();\\n        int m=matrix[0].size()-1;\\n        int i=0;\\n        int j=m;\\n        while(i<n&&j>=0)\\n        {\\n            if(matrix[i][j]==target) // RETURN TRUE IF TARGET GOT FOUND\\n            return true;\\n            else if(matrix[i][j]>target)\\n            {\\n                j--;\\n            }\\n            else \\n            {\\n                i++;\\n            }\\n        }\\n        \\n        return false; // TARGET IS NOT PRESENT.SO RETURN FALSE\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324229,
                "title": "daily-leetcoding-challenge-july-day-24",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-a-2d-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n**Approach 3:** Divide and Conquer\n\n  \n**Approach 4:** Search Space Reduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/search-a-2d-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1897489,
                "title": "c-short-and-fast-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int rows=matrix.size();\\n        \\n        int i=0;      //1st row\\n        int j=matrix[0].size()-1;  //last column\\n        \\n        if(matrix[0][0]==target)\\n            return true;\\n        \\n        while(j>=0 and i<rows) {\\n            if(matrix[i][j]==target)\\n                    return true;\\n                \\n            target<matrix[i][j] ? j-- : i++;\\n        }\\n        return false;\\n    }\\n};\\n\\nif(foundHelpful)\\n\\tupVote();",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int rows=matrix.size();\\n        \\n        int i=0;      //1st row\\n        int j=matrix[0].size()-1;  //last column\\n        \\n        if(matrix[0][0]==target)\\n            return true;\\n        \\n        while(j>=0 and i<rows) {\\n            if(matrix[i][j]==target)\\n                    return true;\\n                \\n            target<matrix[i][j] ? j-- : i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1079103,
                "title": "c-easy-works",
                "content": "```\\npublic class Solution {\\n    public bool SearchMatrix(int[][] matrix, int target) {\\n        \\n        int row = 0;\\n        int col = matrix[0].Length-1;\\n        \\n        while(row < matrix.Length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            } else if(target < matrix[row][col]){\\n                col--;\\n            } else {\\n                row++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool SearchMatrix(int[][] matrix, int target) {\\n        \\n        int row = 0;\\n        int col = matrix[0].Length-1;\\n        \\n        while(row < matrix.Length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            } else if(target < matrix[row][col]){\\n                col--;\\n            } else {\\n                row++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079067,
                "title": "search-a-2d-matrix-ii-c-easy-implementation",
                "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n       long int n=matrix[0].size();\\n      bool f=0;\\n            for(long int i=0,j=n-1;j>=0 && i<matrix.size();)\\n            {\\n                if(matrix[i][j]==target)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(matrix[i][j]>target)j--;\\n                else i++;\\n            }\\n        \\n       if(f)return true;\\n        else return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n       long int n=matrix[0].size();\\n      bool f=0;\\n            for(long int i=0,j=n-1;j>=0 && i<matrix.size();)\\n            {\\n                if(matrix[i][j]==target)\\n                {\\n                    f=1;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 701264,
                "title": "short-c-o-m-n-well-explained",
                "content": "```\\n/*\\n\\tThe idea is simple start from the top right corner of the matrix \\n\\t1. if the target is smaller than the present element at (i,j)\\n\\t\\t then it is also smaller than all the elements in the column j (because matrix is sorted coulmn wise also)\\n\\t\\t therefore we change the coulumn i.e j--;\\n\\t\\n\\t2. else if the target is greater than the present element at (i,j)\\n\\t\\t then it is also greater than all the elements in the row i (because matrix is sorted row wise also)\\n\\t\\t therefore we change the row i.e i++;\\n\\t\\n\\t3. else return true because we have found the element\\n\\t4. otherwise return false because target is not present\\n\\nBELOW is the implementation of this illustration.\\n\\n*/\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int m=mat.size(); if(m==0) return false;\\n        int n=mat[0].size(),i=0,j=n-1;\\n        while(i<m and j>=0)\\n        {\\n            if(target < mat[i][j]) j--;\\n            else if(target > mat[i][j]) i++;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tThe idea is simple start from the top right corner of the matrix \\n\\t1. if the target is smaller than the present element at (i,j)\\n\\t\\t then it is also smaller than all the elements in the column j (because matrix is sorted coulmn wise also)\\n\\t\\t therefore we change the coulumn i.e j--;\\n\\t\\n\\t2. else if the target is greater than the present element at (i,j)\\n\\t\\t then it is also greater than all the elements in the row i (because matrix is sorted row wise also)\\n\\t\\t therefore we change the row i.e i++;\\n\\t\\n\\t3. else return true because we have found the element\\n\\t4. otherwise return false because target is not present\\n\\nBELOW is the implementation of this illustration.\\n\\n*/\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int m=mat.size(); if(m==0) return false;\\n        int n=mat[0].size(),i=0,j=n-1;\\n        while(i<m and j>=0)\\n        {\\n            if(target < mat[i][j]) j--;\\n            else if(target > mat[i][j]) i++;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 567573,
                "title": "simple-python-o-m-n-and-o-mlg-n-solution",
                "content": "**O(mlog(n))**\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        m = len(matrix)\\n        if m < 1:\\n            return False\\n        n = len(matrix[0])\\n        if n < 1:\\n            return False\\n        i = 0\\n        while i < m and target >= matrix[i][0]:\\n            low, high = 0, n\\n            while low < high:\\n                mid = (low+high)//2\\n                if target > matrix[i][mid]:\\n                    low = mid + 1\\n                elif target < matrix[i][mid]:\\n                    high = mid\\n                else:\\n                    return True\\n            i += 1\\n        return False\\n```\\n**O(m+n)**\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        m = len(matrix)\\n        if m < 1:\\n            return False\\n        n = len(matrix[0])\\n        if n < 1:\\n            return False\\n        row, col = 0, n - 1\\n        while row < m and col >= 0:\\n            curr = matrix[row][col]\\n            if target > curr:\\n                row += 1\\n            elif target < curr:\\n                col -= 1\\n            else:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        m = len(matrix)\\n        if m < 1:\\n            return False\\n        n = len(matrix[0])\\n        if n < 1:\\n            return False\\n        i = 0\\n        while i < m and target >= matrix[i][0]:\\n            low, high = 0, n\\n            while low < high:\\n                mid = (low+high)//2\\n                if target > matrix[i][mid]:\\n                    low = mid + 1\\n                elif target < matrix[i][mid]:\\n                    high = mid\\n                else:\\n                    return True\\n            i += 1\\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        m = len(matrix)\\n        if m < 1:\\n            return False\\n        n = len(matrix[0])\\n        if n < 1:\\n            return False\\n        row, col = 0, n - 1\\n        while row < m and col >= 0:\\n            curr = matrix[row][col]\\n            if target > curr:\\n                row += 1\\n            elif target < curr:\\n                col -= 1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151818,
                "title": "start-from-bottom-left-top-right-time-o-m-n",
                "content": "The Brute Force solution takes time O(m * n).\\n\\nTo optimize,  let\\'s observe how we can take advantage of the matrix\\'s property.\\n```\\n1. if there is only one row, if curDigit \\n                >  target, we check digits to its left\\n                <  target, we check digits to its right\\n2. if there is only one col, if curDigit \\n                >  target, we check digits on its top\\n                <  target, we check digits on its bottom\\n3. if a curDigit is at the cross of a row and a col,\\n\\t    if curDigit \\n                >  target, we check digits to its left AND on its top\\n                <  target, we check digits to its right AND on its bottom\\n\\t\\t\\t\\t\\n        BUT if we traverse the matrix from the bottom-left corner, then we only have to move top / right, since other digits have been invalidated already, that is,\\n\\t    if curDigit\\n                >  target, we check digits to its top\\n                <  target, we check digits on its right\\n\\t\\t\\t\\t\\n        OR if we traverse the matrix from the top-right corner, then we only have to move bottom / left, since other digits have been invalidated already, that is,\\n\\t    if curDigit\\n                >  target, we check digits to its left\\n                <  target, we check digits on its bottom\\n```\\nThis approach takes time O(m + n).\\n\\n****\\n**Bottom-left**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) { \\n        int rows = matrix.length, cols = matrix[0].length; \\n        \\n        int i = rows - 1, j = 0; // Starts at bottom-left\\n        \\n        while (i >= 0 && j < cols) {\\n            if (matrix[i][j] == target) {\\n                return true;\\n            } else if (matrix[i][j] > target) {\\n                i--;\\n            } else {\\n                j++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n**Top-right**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) { \\n        int rows = matrix.length, cols = matrix[0].length; \\n        \\n        int i = 0, j = cols - 1; // Starts at top-right\\n        \\n        while (j >= 0 && i < rows) {\\n            if (matrix[i][j] == target) {\\n                return true;\\n            } else if (matrix[i][j] > target) {\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n1. if there is only one row, if curDigit \\n                >  target, we check digits to its left\\n                <  target, we check digits to its right\\n2. if there is only one col, if curDigit \\n                >  target, we check digits on its top\\n                <  target, we check digits on its bottom\\n3. if a curDigit is at the cross of a row and a col,\\n\\t    if curDigit \\n                >  target, we check digits to its left AND on its top\\n                <  target, we check digits to its right AND on its bottom\\n\\t\\t\\t\\t\\n        BUT if we traverse the matrix from the bottom-left corner, then we only have to move top / right, since other digits have been invalidated already, that is,\\n\\t    if curDigit\\n                >  target, we check digits to its top\\n                <  target, we check digits on its right\\n\\t\\t\\t\\t\\n        OR if we traverse the matrix from the top-right corner, then we only have to move bottom / left, since other digits have been invalidated already, that is,\\n\\t    if curDigit\\n                >  target, we check digits to its left\\n                <  target, we check digits on its bottom\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) { \\n        int rows = matrix.length, cols = matrix[0].length; \\n        \\n        int i = rows - 1, j = 0; // Starts at bottom-left\\n        \\n        while (i >= 0 && j < cols) {\\n            if (matrix[i][j] == target) {\\n                return true;\\n            } else if (matrix[i][j] > target) {\\n                i--;\\n            } else {\\n                j++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) { \\n        int rows = matrix.length, cols = matrix[0].length; \\n        \\n        int i = 0, j = cols - 1; // Starts at top-right\\n        \\n        while (j >= 0 && i < rows) {\\n            if (matrix[i][j] == target) {\\n                return true;\\n            } else if (matrix[i][j] > target) {\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145663,
                "title": "python-solution-using-divide-and-conquer",
                "content": "O(n^1.58), the formula is T(n) = 3T(n/2) + c.\\n```\\n\\tdef helper(matrix, rowStart, rowEnd, colStart, colEnd, target):\\n            if(rowStart > rowEnd) | (colStart > colEnd):\\n                return False\\n            rowMid = (rowStart + rowEnd) // 2\\n            colMid = (colStart + colEnd) // 2\\n            if(matrix[rowMid][colMid] == target):\\n                return True\\n            elif (matrix[rowMid][colMid] > target):\\n                return helper(matrix, rowStart, rowMid - 1, colStart, colMid - 1, target) | helper(matrix, rowMid, rowEnd, colStart, colMid - 1, target) | helper(matrix, rowStart, rowMid - 1, colMid - 1, colEnd, target)\\n            else:\\n                return helper(matrix, rowMid + 1, rowEnd, colMid + 1, colEnd, target) | helper(matrix, rowMid + 1, rowEnd, colStart, colMid, target)| helper(matrix, rowStart, rowMid, colMid + 1, colEnd, target)\\n\\n        if not matrix or len(matrix) < 1 or len(matrix[0]) < 1:\\n            return False\\n\\trow, col = len(matrix), len(matrix[0])\\n        return helper(matrix, 0, row - 1, 0, col - 1, target)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef helper(matrix, rowStart, rowEnd, colStart, colEnd, target):\\n            if(rowStart > rowEnd) | (colStart > colEnd):\\n                return False\\n            rowMid = (rowStart + rowEnd) // 2\\n            colMid = (colStart + colEnd) // 2\\n            if(matrix[rowMid][colMid] == target):\\n                return True\\n            elif (matrix[rowMid][colMid] > target):\\n                return helper(matrix, rowStart, rowMid - 1, colStart, colMid - 1, target) | helper(matrix, rowMid, rowEnd, colStart, colMid - 1, target) | helper(matrix, rowStart, rowMid - 1, colMid - 1, colEnd, target)\\n            else:\\n                return helper(matrix, rowMid + 1, rowEnd, colMid + 1, colEnd, target) | helper(matrix, rowMid + 1, rowEnd, colStart, colMid, target)| helper(matrix, rowStart, rowMid, colMid + 1, colEnd, target)\\n\\n        if not matrix or len(matrix) < 1 or len(matrix[0]) < 1:\\n            return False\\n\\trow, col = len(matrix), len(matrix[0])\\n        return helper(matrix, 0, row - 1, 0, col - 1, target)\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3820594,
                "title": "2-c-solutions-binary-search-approach-o-m-n-and-o-mlogn-time-complexity",
                "content": "# Code\\n```\\n// Solution 1 - O(m+n) TC\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size(), r = 0, c = n - 1;\\n        while (r < m && c >= 0){\\n            if (matrix[r][c] == target)\\n                return true;\\n            // matrix[r][c] > target ? c-- : r++;\\n            else if(matrix[r][c] > target)\\n                c--;\\n            else\\n                r++;\\n        }\\n        return false;\\n    }\\n};\\n\\n// Solution 2 - O(mlogn) TC\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n    if (matrix.size()==0) \\n        return false;\\n    for(int i=0; i<matrix.size(); i++){\\n        if( searchVector(matrix[i], target) ) \\n            return true;\\n    }\\n    return false;\\n }\\n\\nbool searchVector(vector<int>& v, int target){\\n    int left = 0, right = v.size() - 1;\\n\\n    while (left <= right) {\\n\\tint mid = left + (right - left) / 2;\\n\\tif (v[mid] == target)\\n\\t\\treturn true;\\n\\tif (v[mid] < target)\\n\\t\\tleft = mid + 1;\\n\\telse\\n\\t\\tright = mid - 1;\\n    }\\n\\n    return false;\\n }\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\n// Solution 1 - O(m+n) TC\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size(), r = 0, c = n - 1;\\n        while (r < m && c >= 0){\\n            if (matrix[r][c] == target)\\n                return true;\\n            // matrix[r][c] > target ? c-- : r++;\\n            else if(matrix[r][c] > target)\\n                c--;\\n            else\\n                r++;\\n        }\\n        return false;\\n    }\\n};\\n\\n// Solution 2 - O(mlogn) TC\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n    if (matrix.size()==0) \\n        return false;\\n    for(int i=0; i<matrix.size(); i++){\\n        if( searchVector(matrix[i], target) ) \\n            return true;\\n    }\\n    return false;\\n }\\n\\nbool searchVector(vector<int>& v, int target){\\n    int left = 0, right = v.size() - 1;\\n\\n    while (left <= right) {\\n\\tint mid = left + (right - left) / 2;\\n\\tif (v[mid] == target)\\n\\t\\treturn true;\\n\\tif (v[mid] < target)\\n\\t\\tleft = mid + 1;\\n\\telse\\n\\t\\tright = mid - 1;\\n    }\\n\\n    return false;\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237751,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n        \\n        int rows = matrix.size();\\n        int cols = matrix[0].size(); \\n\\n        int rowIndex = 0;\\n        int colIndex = cols - 1; \\n        \\n        int mid = 0;\\n\\n        while(rowIndex < rows && colIndex >= 0)\\n        {\\n            \\n            mid = matrix[rowIndex][colIndex];\\n            \\n            if(mid == target)\\n                return true;\\n            else if(mid > target)\\n                colIndex--;\\n            else\\n                rowIndex++;\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n        \\n        int rows = matrix.size();\\n        int cols = matrix[0].size(); \\n\\n        int rowIndex = 0;\\n        int colIndex = cols - 1; \\n        \\n        int mid = 0;\\n\\n        while(rowIndex < rows && colIndex >= 0)\\n        {\\n            \\n            mid = matrix[rowIndex][colIndex];\\n            \\n            if(mid == target)\\n                return true;\\n            else if(mid > target)\\n                colIndex--;\\n            else\\n                rowIndex++;\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594270,
                "title": "binary-search-c-solution-easy-to-understand-check-out",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int rowIdx = 0;\\n        int colIdx = col-1;\\n        while(rowIdx < row && colIdx >=0){\\n            int e = matrix[rowIdx][colIdx];\\n            if(e==target){\\n                return true;\\n            }\\n            if(e<target){\\n                rowIdx++;\\n            }\\n            else{\\n                colIdx--;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int rowIdx = 0;\\n        int colIdx = col-1;\\n        while(rowIdx < row && colIdx >=0){\\n            int e = matrix[rowIdx][colIdx];\\n            if(e==target){\\n                return true;\\n            }\\n            if(e<target){\\n                rowIdx++;\\n            }\\n            else{\\n                colIdx--;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452328,
                "title": "python-very-clear-explanation-with-drawing-o-m-n",
                "content": "Hello,\\n\\n**Time complexity: O(m+n), where m is the number of rows, n is the number of columns.\\nSpace complexity: O(1).**\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        rows, cols = len(matrix), len(matrix[0])\\n        \\n        top = 0\\n        right = cols-1\\n        \\n        bottom = rows-1\\n        left = 0\\n\\n        while bottom >= top and left <= right:\\n            if matrix[bottom][left] == target:\\n                return True\\n            if matrix[bottom][left] > target:\\n                bottom -= 1\\n            elif matrix[bottom][left] < target:\\n                left += 1\\n        return False\\n```\\n\\nThe idea is to start from **Bottom Left** and then go up or right depending on the current **Bottom Left**  value.\\n\\nIf the current **Bottom Left** value == target then return True.\\n\\nIf the current **Bottom Left** value is > target then go up by 1 (to ignore the whole row since this value is also samller than all the numbers on the right of it).\\n\\nIf the current **Bottom Left** value is < target then go right by 1 (because the value might still be in this row so we **do not** ignore it).\\n\\nThe current **Bottom Left** value changes everytime we go up or right.\\n\\nWe go up by doing **bottom-1**.\\nWe go right by doing **left+1**.\\n\\nBreak the loop when the **left is > right** (which is **cols-1**)\\nor\\nBreak the loop when the **bottom is < top** (which is **0**).\\n\\n**Examples with drawing:**\\n1. **matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5**\\n![image](https://assets.leetcode.com/users/images/8429db28-a5d5-4d31-ae66-8c8da6fca8cc_1660979929.5496066.jpeg)\\n\\n2. **matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20**\\n![dc25cd0e-b2ba-4f4d-8814-4383cf61e61b_1660981277.3080633.jpeg](https://assets.leetcode.com/users/images/7681ca72-0427-429e-8509-1bc61e1cc415_1665947254.116068.jpeg)\\n\\n\\n\\n3. **An example of the worst case which is O(m+n) (m: number of rows, n: number of columns)**\\n![image](https://assets.leetcode.com/users/images/5220ec80-ac24-4226-b744-9a92d4bd481c_1660981040.4934547.jpeg)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        rows, cols = len(matrix), len(matrix[0])\\n        \\n        top = 0\\n        right = cols-1\\n        \\n        bottom = rows-1\\n        left = 0\\n\\n        while bottom >= top and left <= right:\\n            if matrix[bottom][left] == target:\\n                return True\\n            if matrix[bottom][left] > target:\\n                bottom -= 1\\n            elif matrix[bottom][left] < target:\\n                left += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327142,
                "title": "c-two-easy-approach",
                "content": "# First Approach\\n**Time Comlexity: O(nlogm), where n is number of row and m is number of column **\\n```\\nclass Solution {\\npublic:\\n    bool binary_search(vector<int> &v1,int target){\\n        \\n        int low  = 0;\\n        int high = v1.size()-1;\\n       \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(v1[mid]<target){\\n                low = mid+1;\\n            }\\n            else if(v1[mid]>target){\\n                high = mid-1;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    \\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n\\t\\tint row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        for(int i=0;i<row;i++){\\n\\t\\t    // check if first element of each row is less than or equal to target or not..\\n            if(matrix[i][0]<=target){\\n               // do a binary search in this sorted array matrix[i]...\\n                if(binary_search(matrix[i],target)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n# Second Approach\\n**Time Comlexity: O(n+m), where n is number of row and m is number of column**\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int i=0,j=col-1;\\n        \\n        while(i<row && j>=0){\\n            if(matrix[i][j]==target){\\n                return true;\\n            }\\n\\t\\t\\telse if(matrix[i][j]>target){\\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool binary_search(vector<int> &v1,int target){\\n        \\n        int low  = 0;\\n        int high = v1.size()-1;\\n       \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(v1[mid]<target){\\n                low = mid+1;\\n            }\\n            else if(v1[mid]>target){\\n                high = mid-1;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    \\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n\\t\\tint row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        for(int i=0;i<row;i++){\\n\\t\\t    // check if first element of each row is less than or equal to target or not..\\n            if(matrix[i][0]<=target){\\n               // do a binary search in this sorted array matrix[i]...\\n                if(binary_search(matrix[i],target)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int i=0,j=col-1;\\n        \\n        while(i<row && j>=0){\\n            if(matrix[i][j]==target){\\n                return true;\\n            }\\n\\t\\t\\telse if(matrix[i][j]>target){\\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325029,
                "title": "4-line-code-c-fast-simple",
                "content": "class Solution {\\n```\\npublic:\\n    bool searchMatrix(vector<vector<int>>& m, int t) {\\n        for(int i=0, j=m[0].size()-1; i<m.size() && j>=0; ){\\n            if(m[i][j] < t)i++;\\n            else if(m[i][j] > t)j--;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    bool searchMatrix(vector<vector<int>>& m, int t) {\\n        for(int i=0, j=m[0].size()-1; i<m.size() && j>=0; ){\\n            if(m[i][j] < t)i++;\\n            else if(m[i][j] > t)j--;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282164,
                "title": "c-binary-search-bottom-left-top-right-approach",
                "content": "```\\n//Method -1 Apply Binary Search on every row\\nclass Solution {\\npublic:\\n    bool binarySearch(vector<int>&vec,int i,int j,int target)\\n    {\\n        if(i>j)return false;\\n        int mid=(i+j)/2;\\n        if(vec[mid]==target)return true;\\n        else if(vec[mid]>target)return binarySearch(vec,i,mid-1,target);\\n        else return binarySearch(vec,mid+1,j,target);\\n    }\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            if(binarySearch(matrix[i],0,matrix[i].size()-1,target))return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n```\\n//Method 2 start with bottom left and top right and update the pointers as per target\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int up=0;\\n        int left=0;\\n        int down=matrix.size()-1;\\n        int right=matrix[0].size()-1;        \\n        while(up<=down&&left<=right)\\n        {\\n            if(matrix[up][right]==target||matrix[down][left]==target)return true;\\n            if(matrix[up][right]<target){\\n                up++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n            if(matrix[down][left]<target){\\n                left++;\\n            }\\n            else\\n            {\\n                down--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n```\\n//Method-3 Just use top right or bottom left\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int up=0;\\n        int left=0;\\n        int down=matrix.size()-1;\\n        int right=matrix[0].size()-1;        \\n        while(up<=down&&left<=right)\\n        {\\n            if(matrix[up][right]==target)return true;\\n            if(matrix[up][right]<target){\\n                up++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "```\\n//Method -1 Apply Binary Search on every row\\nclass Solution {\\npublic:\\n    bool binarySearch(vector<int>&vec,int i,int j,int target)\\n    {\\n        if(i>j)return false;\\n        int mid=(i+j)/2;\\n        if(vec[mid]==target)return true;\\n        else if(vec[mid]>target)return binarySearch(vec,i,mid-1,target);\\n        else return binarySearch(vec,mid+1,j,target);\\n    }\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            if(binarySearch(matrix[i],0,matrix[i].size()-1,target))return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\n//Method 2 start with bottom left and top right and update the pointers as per target\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int up=0;\\n        int left=0;\\n        int down=matrix.size()-1;\\n        int right=matrix[0].size()-1;        \\n        while(up<=down&&left<=right)\\n        {\\n            if(matrix[up][right]==target||matrix[down][left]==target)return true;\\n            if(matrix[up][right]<target){\\n                up++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n            if(matrix[down][left]<target){\\n                left++;\\n            }\\n            else\\n            {\\n                down--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\n//Method-3 Just use top right or bottom left\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int up=0;\\n        int left=0;\\n        int down=matrix.size()-1;\\n        int right=matrix[0].size()-1;        \\n        while(up<=down&&left<=right)\\n        {\\n            if(matrix[up][right]==target)return true;\\n            if(matrix[up][right]<target){\\n                up++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243976,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int t) {\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n        int i=0,j=col-1;\\n        while(i>=0 && i<row && j>=0 && j<col){\\n            if(matrix[i][j]==t){\\n                return true;\\n            }\\n            else if(matrix[i][j]>t){\\n                j--;\\n            }else if(matrix[i][j]<t){\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/*class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            \\n            for(int j=0;j<matrix.length;j++)\\n            {\\n                \\n                if(matrix[i][j]==target)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}*/\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int t) {\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n        int i=0,j=col-1;\\n        while(i>=0 && i<row && j>=0 && j<col){\\n            if(matrix[i][j]==t){\\n                return true;\\n            }\\n            else if(matrix[i][j]>t){\\n                j--;\\n            }else if(matrix[i][j]<t){\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/*class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            \\n            for(int j=0;j<matrix.length;j++)\\n            {\\n                \\n                if(matrix[i][j]==target)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917568,
                "title": "java-efficient-o-row-col-binary-search",
                "content": "We will go in a Binary search kind of pattern i.e \\nif the elem **is** target we return it \\nelse if the elem is **less** than target we inc the row i.e go down\\nelse if the elem is **greater** we go left i.e dec the col\\n\\nand Bamm we are done \\nall the **hungryCoders** out there if it fulfilled your hunger hit the **UPVOTE** Button will take only 3secs \\u2764\\uD83D\\uDE1C\\n\\n```\\npublic boolean searchMatrix(int[][] matrix, int target) {\\nint col = matrix[0].length-1;\\n\\tint row=0;\\n\\twhile(row<matrix.length && col>=0){\\n\\t\\tif(matrix[row][col]==target)return true;\\n\\t\\telse if(matrix[row][col]>target)col--;\\n\\t\\telse if(matrix[row][col]<target)row++;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic boolean searchMatrix(int[][] matrix, int target) {\\nint col = matrix[0].length-1;\\n\\tint row=0;\\n\\twhile(row<matrix.length && col>=0){\\n\\t\\tif(matrix[row][col]==target)return true;\\n\\t\\telse if(matrix[row][col]>target)col--;\\n\\t\\telse if(matrix[row][col]<target)row++;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1723456,
                "title": "search-a-2d-matrix-ii-java-100-faster-and-simple-solution-using-binary-search",
                "content": "Please Upvote if you understood and like the solution\\nvery simple program nothing is hard...all the best ...keep going\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].length-1;\\n        while(row<matrix.length && col>=0)\\n        {\\n\\t\\t//check if matrix[row][col]==target\\n            if(matrix[row][col]==target)\\n            {\\n                return true;\\n            }\\n\\t\\t//if element is less than target we can eleminate whole row and check in next row but keeping column unchanged\\n            if(matrix[row][col]<target)\\n            {\\n                row++;\\n                continue;\\n            }\\n\\t//if element is greater than target we can eleminate whole column and check in previous column but keeping row unchanged\\n            if(matrix[row][col]>target)\\n            {\\n                col--;\\n                continue;\\n            }\\n        }\\n\\t//if element is not found in 2D array return false\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].length-1;\\n        while(row<matrix.length && col>=0)\\n        {\\n\\t\\t//check if matrix[row][col]==target\\n            if(matrix[row][col]==target)\\n            {\\n                return true;\\n            }\\n\\t\\t//if element is less than target we can eleminate whole row and check in next row but keeping column unchanged\\n            if(matrix[row][col]<target)\\n            {\\n                row++;\\n                continue;\\n            }\\n\\t//if element is greater than target we can eleminate whole column and check in previous column but keeping row unchanged\\n            if(matrix[row][col]>target)\\n            {\\n                col--;\\n                continue;\\n            }\\n        }\\n\\t//if element is not found in 2D array return false\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554706,
                "title": "simple-c-solution-with-o-m-n-complexity",
                "content": "```\\nbool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    int x = 0, y = *matrixColSize - 1;\\n    while(x < matrixSize && y >= 0)\\n        if(matrix[x][y] < target)\\n            x++;\\n        else if(matrix[x][y] > target)\\n            y--;\\n        else\\n            return true;\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    int x = 0, y = *matrixColSize - 1;\\n    while(x < matrixSize && y >= 0)\\n        if(matrix[x][y] < target)\\n            x++;\\n        else if(matrix[x][y] > target)\\n            y--;\\n        else\\n            return true;\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260261,
                "title": "zig-zag-search-recursive-approach-o-n-m-with-binary-search-logic",
                "content": "### Explanation\\n1. Starting from the top-right element of the array, \\n2. Since the array is sorted in both column-wise and row-wise, we are searching starting from 15(Discarding the column since all other elements are larger, moving column wise)---> 11(same as previous)---> 7(same as previous) ---> 4(element is samller than given element now we will move row wise)---> Discarding row(1,4) and going down----> **5 is found**\\nSame for other usecase..\\n\\n![image](https://assets.leetcode.com/users/images/b28a2582-48b5-4ade-838a-e9331c9edfa7_1623211370.8593428.jpeg)\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       return search(matrix,target,0,matrix[0].size()-1);        \\n    }\\n    bool search(vector<vector<int>>& matrix, int target, int i, int j){\\n         if(j<0 || i>matrix.size()-1)\\n             return false;\\n         if(matrix[i][j]==target)\\n            return true;\\n         else if(matrix[i][j]>target)\\n             return search(matrix,target,i,j-1);\\n         else\\n             return search(matrix,target,i+1,j);\\n         return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       return search(matrix,target,0,matrix[0].size()-1);        \\n    }\\n    bool search(vector<vector<int>>& matrix, int target, int i, int j){\\n         if(j<0 || i>matrix.size()-1)\\n             return false;\\n         if(matrix[i][j]==target)\\n            return true;\\n         else if(matrix[i][j]>target)\\n             return search(matrix,target,i,j-1);\\n         else\\n             return search(matrix,target,i+1,j);\\n         return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081298,
                "title": "python-3-6-solutions-1-line-o-n-log-m-n-140ms",
                "content": "# Linear search, 156ms\\n- Naive approach is to check all elements in `matrix`.\\n- Time complexity is `O(n*m)`. Space compexity is `O(1)`.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        return any(target in row for row in matrix)\\n```\\nIt is bored. Let us improve it.\\n# Row binary search, 160 ms\\n- Since every row is sorted in ascending we can use binary search to find `target`.\\n- Iteratively check all rows.\\n- Time complexity is `O(n*log(m)) = O(n*log(n*t))`. Space compexity is `O(1)`.\\n- Since time complexity is assymetric we need transpose `matrix` if m < n.\\n- Since all columns are sorted in ascending we can reduce right end of the next row.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n, m = len(matrix), len(matrix[0])\\n        if m < n: m, n = n, m; matrix = zip(*matrix)\\n        \\n        i = m\\n        for row in matrix:\\n            i = bisect_left(row, target, hi=i)\\n            if i < m and row[i] == target: return True\\n            \\n        return False\\n```\\nWhy not to implement 2D binary search? Let\\'s try.\\n# Divide and conquer, 176 ms\\n- Since both rows and columns are sorted in ascending we can find middle point in `matrix`, compare it with target and eliminate one (top left or bottom right) quadrant. \\n- Recursively divide remaining 3 quadrants.\\n- According to the third case of the Master theorem (`T(n) = 3*T(n/4) + 1`) time complexity is `O((n*m)**log4(3)) \\u2248 O((n*m)**0.79)`. Space compexity is `O(log(n) + log(m))`. \\n- We can combine 2 adjacent quadrants and make 2 recursive calls (`T(n) = T(n/2) + T(n/4) + 1`) but it gives a similar time complexity (and Master theorem is not applicable here).\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        \\n        def dq(loX, loY, hiX, hiY):\\n            if loX > hiX or loY > hiY: return False\\n            \\n            mX, mY = (loX+hiX) >> 1, (loY+hiY) >> 1\\n            \\n            if target < matrix[mX][mY]:\\n                return dq(loX, loY, mX-1, mY-1) or dq(loX, mY, mX-1, hiY) or dq(mX, loY, hiX, mY-1)\\n            elif target > matrix[mX][mY]:\\n                return dq(mX+1, mY+1, hiX, hiY) or dq(loX, mY+1, mX, hiY) or dq(mX+1, loY, hiX, mY)\\n            else:\\n                return True\\n        \\n        return dq(0, 0, len(matrix)-1, len(matrix[0])-1)\\n```\\nOops, time complexity is not what was expected (not log()). So let\\'s do search with linear approach.\\n# Saddleback linear search, 160ms\\n- Since both rows and columns are sorted in ascending then main and offset diagonals are sorted too, but we have no assumption for secondary and offset diagonals. Which means we can only use linear search in this direction.\\n- Imagine `matrix` contains mountain heights. Let\\'s start from far end of middle height (last element of first row). Climp up (go to next row) if current position is less than `target`. Climp down (go to previous column) if current position is greater than `target`. \\n- So we go through all the columns and rows along the saddleback path and check all potential elements.\\n- Time complexity is `O(n + m) = O(n*t)`. Space complexity is `O(1)`.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        i = len(matrix[0]) - 1\\n        for row in matrix:\\n            while row[i] > target: \\n                i -= 1\\n                if i < 0: return False\\n            if row[i] == target: return True\\n            \\n        return False\\n```\\nIt is good for near quadratic `matrix`. But for long rectangle `n < m / (log(m) - 1)` Row binary search approach is better. \\n# Hybrid linear + binary search, 172ms\\n- Saddleback linear search is optimal if matrix is quadratic `n = m`. Let\\'s do `n` steps along greater axis `m`. So our step should be `t = m//n`.\\n- Use binary search inside found step to find element.\\n- Time complexity is `O(n*log(m/n)) = O(n*log(t))`. Space complexity is `O(1)`.\\n- Since time complexity is assymetric we need transpose `matrix` if m < n.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n, m = len(matrix), len(matrix[0])\\n        if m < n: m,n = n,m; matrix = zip(*matrix)\\n        \\n        hi = m; t = m//n\\n        for row in matrix:\\n            for lo in range(hi-t, 0, -t):\\n                if row[lo] < target: break\\n                hi = lo\\n            else:\\n                lo = 0\\n                if row[lo] > target: break\\n                    \\n            hi = bisect_left(row, target, lo=lo, hi=hi)\\n            if hi < m and row[hi] == target: return True\\n            \\n        return False\\n```\\nPopular wrong estimation `O(log(n*m)) = O(log(n) + log(m))` is possible if all elements in `matrix` are sorted in ascending row by row (or column by column). To apply it in this task we need sort all elements because they are only partially sorted.\\n# Timsort, 140ms\\n- Brutal approach is to sort all elements and use binary search to find `target`.\\n- It could seem time complexity is `O(n*m*log(n*m))`. But Timsort (python\\'s standard sort) is optimized for partially sorted list, so I think time complexity for this task data is `O(n*m)`. Space complexity is `O(n*m)`.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        vector = sorted(chain.from_iterable(matrix))\\n        i = bisect_left(vector, target)\\n        \\n        return i < len(vector) and vector[i] == target\\n```\\nDue to weak tests we cannot admire best time complexity alghorithms. The worst one takes lowest runtime. \\\\<sadness>\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        return any(target in row for row in matrix)\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n, m = len(matrix), len(matrix[0])\\n        if m < n: m, n = n, m; matrix = zip(*matrix)\\n        \\n        i = m\\n        for row in matrix:\\n            i = bisect_left(row, target, hi=i)\\n            if i < m and row[i] == target: return True\\n            \\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        \\n        def dq(loX, loY, hiX, hiY):\\n            if loX > hiX or loY > hiY: return False\\n            \\n            mX, mY = (loX+hiX) >> 1, (loY+hiY) >> 1\\n            \\n            if target < matrix[mX][mY]:\\n                return dq(loX, loY, mX-1, mY-1) or dq(loX, mY, mX-1, hiY) or dq(mX, loY, hiX, mY-1)\\n            elif target > matrix[mX][mY]:\\n                return dq(mX+1, mY+1, hiX, hiY) or dq(loX, mY+1, mX, hiY) or dq(mX+1, loY, hiX, mY)\\n            else:\\n                return True\\n        \\n        return dq(0, 0, len(matrix)-1, len(matrix[0])-1)\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        i = len(matrix[0]) - 1\\n        for row in matrix:\\n            while row[i] > target: \\n                i -= 1\\n                if i < 0: return False\\n            if row[i] == target: return True\\n            \\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n, m = len(matrix), len(matrix[0])\\n        if m < n: m,n = n,m; matrix = zip(*matrix)\\n        \\n        hi = m; t = m//n\\n        for row in matrix:\\n            for lo in range(hi-t, 0, -t):\\n                if row[lo] < target: break\\n                hi = lo\\n            else:\\n                lo = 0\\n                if row[lo] > target: break\\n                    \\n            hi = bisect_left(row, target, lo=lo, hi=hi)\\n            if hi < m and row[hi] == target: return True\\n            \\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        vector = sorted(chain.from_iterable(matrix))\\n        i = bisect_left(vector, target)\\n        \\n        return i < len(vector) and vector[i] == target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079030,
                "title": "c-python-so-simple",
                "content": "c++\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size()-1;\\n        int col = 0;\\n\\n        while (row >= 0 && col < matrix[0].size()) {\\n            if (matrix[row][col] > target) {\\n                row--;\\n            } else if (matrix[row][col] < target) {\\n                col++;\\n            } else { \\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\nPython\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row = 0\\n        col = len(matrix[0]) - 1\\n        while row < len(matrix) and col >= 0:\\n          if matrix[row][col] > target:\\n            col -= 1\\n          elif matrix[row][col] < target:\\n            row += 1\\n          else:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size()-1;\\n        int col = 0;\\n\\n        while (row >= 0 && col < matrix[0].size()) {\\n            if (matrix[row][col] > target) {\\n                row--;\\n            } else if (matrix[row][col] < target) {\\n                col++;\\n            } else { \\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row = 0\\n        col = len(matrix[0]) - 1\\n        while row < len(matrix) and col >= 0:\\n          if matrix[row][col] > target:\\n            col -= 1\\n          elif matrix[row][col] < target:\\n            row += 1\\n          else:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021789,
                "title": "python-simple-divide-conquer-more-readable",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if ((len(matrix) == 1 and len(matrix[0]) == 1 and matrix[0][0] != target) or  # single element with number != target\\n            len(matrix) == 0 or                                                       # empty matrix\\n            matrix.count([]) == len(matrix)):                                         # [[],[],[]]\\n            return False\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        pivot_i = m // 2 \\n        pivot_j = n // 2\\n                \\n        top_left     = [x[0:pivot_j] for x in matrix[0:pivot_i]]\\n        top_right    = [x[pivot_j:]  for x in matrix[0:pivot_i]]\\n        bottom_left  = [x[0:pivot_j] for x in matrix[pivot_i:]]\\n        bottom_right = [x[pivot_j:]  for x in matrix[pivot_i:]]\\n\\n\\n        if matrix[pivot_i][pivot_j] == target:\\n            return True\\n        elif matrix[pivot_i][pivot_j] < target:\\n            return (\\n                self.searchMatrix(top_right, target) or\\n                self.searchMatrix(bottom_left, target) or\\n                self.searchMatrix(bottom_right, target))\\n        else:\\n            return (\\n                self.searchMatrix(top_left, target) or\\n                self.searchMatrix(top_right, target) or\\n                self.searchMatrix(bottom_left, target))\\n\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if ((len(matrix) == 1 and len(matrix[0]) == 1 and matrix[0][0] != target) or  # single element with number != target\\n            len(matrix) == 0 or                                                       # empty matrix\\n            matrix.count([]) == len(matrix)):                                         # [[],[],[]]\\n            return False\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        pivot_i = m // 2 \\n        pivot_j = n // 2\\n                \\n        top_left     = [x[0:pivot_j] for x in matrix[0:pivot_i]]\\n        top_right    = [x[pivot_j:]  for x in matrix[0:pivot_i]]\\n        bottom_left  = [x[0:pivot_j] for x in matrix[pivot_i:]]\\n        bottom_right = [x[pivot_j:]  for x in matrix[pivot_i:]]\\n\\n\\n        if matrix[pivot_i][pivot_j] == target:\\n            return True\\n        elif matrix[pivot_i][pivot_j] < target:\\n            return (\\n                self.searchMatrix(top_right, target) or\\n                self.searchMatrix(bottom_left, target) or\\n                self.searchMatrix(bottom_right, target))\\n        else:\\n            return (\\n                self.searchMatrix(top_left, target) or\\n                self.searchMatrix(top_right, target) or\\n                self.searchMatrix(bottom_left, target))\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1001740,
                "title": "java-o-m-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].length-1;\\n        \\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            } else if(target < matrix[row][col]){\\n                col--;\\n            } else {\\n                row++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].length-1;\\n        \\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            } else if(target < matrix[row][col]){\\n                col--;\\n            } else {\\n                row++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991518,
                "title": "javascript-o-m-n-solution",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nconst searchMatrix = (matrix, target) => {\\n    if(!matrix || matrix.length === 0 || matrix[0].length === 0) {\\n        return false;\\n    }    \\n    const rows = matrix.length;\\n    const cols = matrix[0].length;\\n    let row = 0, col = matrix[0].length - 1;\\n    while(row < rows && col >= 0) {\\n        if(matrix[row][col] === target) {\\n            return true;\\n        }\\n        if(matrix[row][col] < target) {\\n            row++;\\n        }else {\\n            col--;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nconst searchMatrix = (matrix, target) => {\\n    if(!matrix || matrix.length === 0 || matrix[0].length === 0) {\\n        return false;\\n    }    \\n    const rows = matrix.length;\\n    const cols = matrix[0].length;\\n    let row = 0, col = matrix[0].length - 1;\\n    while(row < rows && col >= 0) {\\n        if(matrix[row][col] === target) {\\n            return true;\\n        }\\n        if(matrix[row][col] < target) {\\n            row++;\\n        }else {\\n            col--;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 846343,
                "title": "c-solution-o-n-m-with-comment",
                "content": "start from top right\\nif the value equals target return 1\\nif value less than target, increase i(index of row) by 1\\nif value is greater than target, decrease j(index of column) by 1\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size()==0)\\n            return 0;\\n        int i=0,j=matrix[0].size()-1;\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        while(i<n&&j>=0)\\n        {\\n            if(matrix[i][j]==target)\\n                return 1;\\n            else if(matrix[i][j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size()==0)\\n            return 0;\\n        int i=0,j=matrix[0].size()-1;\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        while(i<n&&j>=0)\\n        {\\n            if(matrix[i][j]==target)\\n                return 1;\\n            else if(matrix[i][j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423453,
                "title": "c-beats-100-so-simple-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // Start our at a location where we have reduced search space. How do we know our search space\\n        // is reduced at the bottom left? Because at that location we can either go right, finding greater\\n        // numbers, or up, finding lower numbers. If we started at the bottom right, regardless of \\n        // where we go, (up or left), we are finding lower numbers, the computer would be confused\\n        // as to which direcction it should take, given that both directions lead to lower numbers.\\n        // Starting at the bottom left we force the computer to either go to a lower number or higher number.\\n        int x = matrix.size() - 1;\\n        int y = 0;\\n        while (x >= 0 && y >=0 && x != matrix.size() && y != matrix[0].size()) { // Don\\'t go off the grid\\n            if (matrix[x][y] == target) {\\n                return true;\\n            } else if (matrix[x][y] > target) { // If too big, we need to go down.\\n                x--;\\n            } else { // Too small? Go right.\\n                y++;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // Start our at a location where we have reduced search space. How do we know our search space\\n        // is reduced at the bottom left? Because at that location we can either go right, finding greater\\n        // numbers, or up, finding lower numbers. If we started at the bottom right, regardless of \\n        // where we go, (up or left), we are finding lower numbers, the computer would be confused\\n        // as to which direcction it should take, given that both directions lead to lower numbers.\\n        // Starting at the bottom left we force the computer to either go to a lower number or higher number.\\n        int x = matrix.size() - 1;\\n        int y = 0;\\n        while (x >= 0 && y >=0 && x != matrix.size() && y != matrix[0].size()) { // Don\\'t go off the grid\\n            if (matrix[x][y] == target) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 403521,
                "title": "javascript-solution-beats-90",
                "content": "Runtime: 75 ms, faster than 90.21% of JavaScript online submissions for Search a 2D Matrix II.\\nMemory Usage: 37.1 MB, less than 88.89% of JavaScript online submissions for Search a 2D Matrix II.\\n\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n  if (matrix.length === 0) return false\\n  let i = 0, j = matrix[i].length - 1\\n  while (i < matrix.length && j >= 0) {\\n    if (matrix[i][j] === target) { \\n        return true \\n    } else if (matrix[i][j] > target) {\\n        j--\\n    } else { \\n        i++ \\n    }\\n  }\\n  return false\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n  if (matrix.length === 0) return false\\n  let i = 0, j = matrix[i].length - 1\\n  while (i < matrix.length && j >= 0) {\\n    if (matrix[i][j] === target) { \\n        return true \\n    } else if (matrix[i][j] > target) {\\n        j--\\n    } else { \\n        i++ \\n    }\\n  }\\n  return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 401206,
                "title": "python-geeksforgeeks-link",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        if len(matrix) == 0: return False\\n        row, col = 0, len(matrix[0])-1\\n        \\n        while col >= 0 and row < len(matrix):\\n            if target < matrix[row][col]: col -= 1\\n            elif target > matrix[row][col]: row +=1\\n            else: return True\\n        \\n        return False\\n```\\n\\n* [**Simple to Understand Explanation Here**](https://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        if len(matrix) == 0: return False\\n        row, col = 0, len(matrix[0])-1\\n        \\n        while col >= 0 and row < len(matrix):\\n            if target < matrix[row][col]: col -= 1\\n            elif target > matrix[row][col]: row +=1\\n            else: return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365141,
                "title": "go-o-n-m-iterative-solution",
                "content": "```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\tif matrix == nil || len(matrix) == 0 || len(matrix[0]) == 0 {\\n\\t\\treturn false\\n\\t}\\n\\n\\trow, col := 0, len(matrix[0])-1\\n\\tfor row < len(matrix) && col >= 0 {\\n\\t\\tval :=  matrix[row][col]\\n\\t\\t if val > target {\\n\\t\\t\\tcol--\\n\\t\\t} else if val < target {\\n\\t\\t\\trow++\\n\\t\\t} else {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\tif matrix == nil || len(matrix) == 0 || len(matrix[0]) == 0 {\\n\\t\\treturn false\\n\\t}\\n\\n\\trow, col := 0, len(matrix[0])-1\\n\\tfor row < len(matrix) && col >= 0 {\\n\\t\\tval :=  matrix[row][col]\\n\\t\\t if val > target {\\n\\t\\t\\tcol--\\n\\t\\t} else if val < target {\\n\\t\\t\\trow++\\n\\t\\t} else {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222657,
                "title": "c-36ms-99-7-o-m-n-solution",
                "content": "The idea is to start from the bottom left corner, and then search up the rows until the row starts with element less than or equal to target. This is required since the row is sorted low to high, so if it is too high there is no point searching. Once we find the first row, we will go right, until either we find element, or the current element becomes too high again. If it becomes too high, we know that it can\\'t be in this row, so we move 1 row up, and then repeat. This is guaranteed to work, because each column is also sorted low to high, so from any element, we are guaranteed a lower element if we go up the rows. \\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.empty()) return false;\\n        int R = matrix.size()-1, C = matrix[0].size()-1, i = R, j = 0;\\n        while(i >= 0 && j <= C) {\\n            if(matrix[i][j] < target) ++j;\\n            else if(matrix[i][j] > target) --i;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.empty()) return false;\\n        int R = matrix.size()-1, C = matrix[0].size()-1, i = R, j = 0;\\n        while(i >= 0 && j <= C) {\\n            if(matrix[i][j] < target) ++j;\\n            else if(matrix[i][j] > target) --i;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 66237,
                "title": "o-m-n-solution-in-java-with-explanation",
                "content": "Basic idea is to start from the rightmost column of 0 row and gradually increase the row and decrease the column value to match with the target. As the matrix is sorted both in row and column, so if the target is smaller than matrix[0][0] or greater than matrix[row][column], then we will return false.\\n\\nNow we will start from matrix[0][column] and will compare the value with target. If target is greater than matrix[0][column], we can assume that the target is in same column but greater row. so we will increase row value by 1. Otherwise if the target is smaller than matrix[0][column] we can assume that the target is in same row but smaller column. So we will decrease the column. We will keep doing this unless we hit max row and min column. If we find the target, we will return true. \\n\\nFinally we will return false from outside the loop, as we didn't find the target in the matrix. My java implementation is given below:\\n\\n\\n    \\n        if(matrix == null || matrix.length == 0 || matrix[0] == 0)\\n            return false;\\n        int row = matrix.length;\\n        int column = matrix[0].length;\\n        \\n        if(target < matrix[0][0] || target > matrix[row - 1][column - 1])\\n            return false;\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = column - 1; j >= 0; j--){\\n                if(target == matrix[i][j])\\n                    return true;\\n                //else if(target < matrix[i][j]);\\n                    //do nothing, decrease column number\\n                else if(target > matrix[i][j])\\n                    break;\\n            }\\n        }\\n        \\n        return false;",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "Basic idea is to start from the rightmost column of 0 row and gradually increase the row and decrease the column value to match with the target. As the matrix is sorted both in row and column, so if the target is smaller than matrix[0][0] or greater than matrix[row][column], then we will return false.\\n\\nNow we will start from matrix[0][column] and will compare the value with target. If target is greater than matrix[0][column], we can assume that the target is in same column but greater row. so we will increase row value by 1. Otherwise if the target is smaller than matrix[0][column] we can assume that the target is in same row but smaller column. So we will decrease the column. We will keep doing this unless we hit max row and min column. If we find the target, we will return true. \\n\\nFinally we will return false from outside the loop, as we didn't find the target in the matrix. My java implementation is given below:\\n\\n\\n    \\n        if(matrix == null || matrix.length == 0 || matrix[0] == 0)\\n            return false;\\n        int row = matrix.length;\\n        int column = matrix[0].length;\\n        \\n        if(target < matrix[0][0] || target > matrix[row - 1][column - 1])\\n            return false;\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = column - 1; j >= 0; j--){\\n                if(target == matrix[i][j])\\n                    return true;\\n                //else if(target < matrix[i][j]);\\n                    //do nothing, decrease column number\\n                else if(target > matrix[i][j])\\n                    break;\\n            }\\n        }\\n        \\n        return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 66294,
                "title": "a-divide-and-conquer-solution",
                "content": "just like searching a sorted an array; find the middle element and recursively search the rest 3/4 matrix; a decrease (devide) and conquer solution; \\n\\nThe time complexity is T(m*n) = T(1/4 m*n) + T(1/2 m*n) + 1\\n\\n\\npublic class Solution {\\n    \\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        return(searchMatrixHelper(matrix, 0, 0, matrix.length-1, matrix[0].length-1, target));\\n    }\\n    \\n    private boolean searchMatrixHelper (int[][] matrix, int i, int j, int i_, int j_, int target){\\n        if(i > i_ || j> j_){\\n            return false;\\n        }\\n        int midRow= (i+i_)/2; int midCol=(j+j_)/2;\\n        if(matrix[midRow][midCol] == target){\\n            return true;\\n        }else if(matrix[midRow][midCol] > target){\\n            return (searchMatrixHelper(matrix, i ,j, i_, midCol-1, target) || searchMatrixHelper(matrix, i, midCol, midRow-1, j_, target));\\n        }else{\\n            return (searchMatrixHelper(matrix, midRow+1 ,j, i_, j_, target) || searchMatrixHelper(matrix, i, midCol+1, midRow, j_, target));\\n        }\\n    }\\n    \\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        return(searchMatrixHelper(matrix, 0, 0, matrix.length-1, matrix[0].length-1, target));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 66306,
                "title": "c-divide-and-conquer-solution",
                "content": "    class Solution {\\n    public:\\n    \\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            return searchRect(matrix,target,0,0,matrix.size()-1,matrix[0].size()-1);\\n        }\\n    \\n        bool searchRect(vector<vector<int>>& matrix, int target, \\n                                   int top, int left, int bottom, int right) {\\n            //search if the target is inside the rectangular matrix[top:bottom][left:right]\\n            //each time we discard 1/4 of all elements\\n            //time complexity O( log(mn)/log(4/3) ) = O(logm + logn)\\n            \\n            if(top>bottom || left>right)\\n                return false;\\n            \\n            int x = (top+bottom)/2;\\n            int y = (left+right)/2;\\n            int center = matrix[x][y];\\n            \\n            if(center > target){\\n                return\\n                    searchRect(matrix,target,top,left,x-1,right) ||\\n                    searchRect(matrix,target,x,left,bottom,y-1);\\n            }\\n            else if(center < target){\\n                return\\n                    searchRect(matrix,target,x+1,left,bottom,right) ||\\n                    searchRect(matrix,target,top,y+1,x,right);\\n            }\\n            else\\n                return true;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            return searchRect(matrix,target,0,0,matrix.size()-1,matrix[0].size()-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 66253,
                "title": "what-is-the-complexity-of-this-java-solution",
                "content": "The idea is to recursively compare target with the element in the middle of the matrix and eliminate the quarter of the matrix that can't contain the target. After the quarter is eliminated do searches in the remaining matrix elements. At first it seemed to me that the complexity is O(log N*M), but it looks like I'm wrong. Can anyone show how to calculate complexity of this algorithm?\\n\\n    public class Solution {\\n        public boolean searchMatrix(int[][] matrix, int target) {\\n            if (matrix.length == 0) return false;\\n            return search(matrix, target, 0, matrix.length-1, 0, matrix[0].length-1);\\n        }\\n        private boolean search(int[][]matrix, int target, int minRow, int maxRow, int minCol, int maxCol) {\\n            if (minRow>maxRow || minCol>maxCol) return false;\\n            int midRow = (minRow + maxRow) /2;\\n            int midCol = (minCol + maxCol) /2;\\n            int val = matrix[midRow][midCol];\\n            if (val == target) return true;\\n            if (target<val) {\\n                return search(matrix, target, minRow, maxRow, minCol, midCol - 1) || \\n                        search(matrix, target, minRow, midRow - 1, midCol, maxCol);\\n            } else {\\n                return search(matrix, target, midRow+1, maxRow, minCol, maxCol) ||\\n                        search(matrix, target, minRow, midRow, midCol+1, maxCol);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean searchMatrix(int[][] matrix, int target) {\\n            if (matrix.length == 0) return false;\\n            return search(matrix, target, 0, matrix.length-1, 0, matrix[0].length-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 66324,
                "title": "c-solutions-308ms",
                "content": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if (matrix.empty())\\n        {\\n            return false;\\n        }\\n        int siz0 = matrix.size();\\n        int siz1 = matrix[0].size();\\n        int x = siz0 - 1, y = 0;\\n        while (true)\\n        {\\n            if (matrix[x][y] > target)\\n            {\\n                x--;\\n            }\\n            else if (matrix[x][y] < target){\\n                y++;\\n            }\\n            else {\\n                return true;\\n            }\\n            if (x < 0 || y >= siz1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if (matrix.empty())\\n        {\\n            return false;\\n        }\\n        int siz0 = matrix.size();\\n        int siz1 = matrix[0].size();\\n        int x = siz0 - 1, y = 0;\\n        while (true)\\n        {\\n            if (matrix[x][y] > target)\\n            {\\n                x--;\\n            }\\n            else if (matrix[x][y] < target){\\n                y++;\\n            }\\n            else {\\n                return true;\\n            }\\n            if (x < 0 || y >= siz1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3732451,
                "title": "easy-to-understand-c-solution-o-n-m",
                "content": "# Intuition & Approach\\nStart your pointer pointer from first row and last column.Every time compare with the target if target is equals to the pointer value then return true and if target is less than the matrix value then (column--) and if target is greater than the matrix value then (row++) .\\n\\n\\n# Complexity\\n- Time complexity:O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int column=matrix[0].size()-1;\\n        int row=0;\\n        while(row<matrix.size() && column>=0)\\n        {\\n            if(matrix[row][column]==target)\\n            return true;\\n\\n            else if(matrix[row][column]>target)\\n            {\\n                --column;\\n            }\\n            else\\n            row++;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int column=matrix[0].size()-1;\\n        int row=0;\\n        while(row<matrix.size() && column>=0)\\n        {\\n            if(matrix[row][column]==target)\\n            return true;\\n\\n            else if(matrix[row][column]>target)\\n            {\\n                --column;\\n            }\\n            else\\n            row++;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565715,
                "title": "binary-search-easy-soln",
                "content": "# Intuition\\nSince it is given that array is sorted in non-increasing order both row-wise and column-wise, we wil start the traversal from the last row\\'s first element.\\n3 cases can occur:\\nCase 1: when the current element is greater than the target,then the whole row will be of greater numbers than target since its the smaleest in the row, so discard the row\\n\\nCase 2 :\\nwhen the current element is smaller than the target then move to the next column since it is column wise sorted the target might lie in the next column\\n\\nCase 3: When the current elemets is equal to the target,return true\\n# Approach\\n\\n# Complexity\\n- Time complexity:O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\nPlease Upvote :)\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        int r=matrix.length-1,c=0;\\n        while(r<matrix.length && c<matrix[0].length)\\n        {\\n            if(matrix[r][c]==target)\\n                 return true;//match found\\n            else if(r!=0 && matrix[r][c]>target)\\n                 r--; //discard row\\n            else\\n               c++;  //moving to the next column\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        int r=matrix.length-1,c=0;\\n        while(r<matrix.length && c<matrix[0].length)\\n        {\\n            if(matrix[r][c]==target)\\n                 return true;//match found\\n            else if(r!=0 && matrix[r][c]>target)\\n                 r--; //discard row\\n            else\\n               c++;  //moving to the next column\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464126,
                "title": "java-solution-for-search-2d-matrix-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a Java code for the \"Search a 2D Matrix II\" problem, where given an m x n matrix sorted in non-decreasing order, we need to check if a given integer target is present in the matrix\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this code is to start from the bottom left corner of the matrix and compare the target with the element at this position. If the target is smaller, we move one row up; if it is larger, we move one column right; and if it is equal, we return true. We repeat this process until we find the target or reach the top right corner of the matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m+n), since we traverse at most m rows and n columns of the matrix. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), since we use only a constant amount of extra space.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m=matrix.length-1;\\n        int n=matrix[0].length-1;\\n        int i=m;\\n        int j=0;\\n        while(i>=0 && j<=n)\\n        {\\n            if(target < matrix[i][j])\\n            {\\n                i--;\\n            }\\n            else if(target > matrix[i][j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m=matrix.length-1;\\n        int n=matrix[0].length-1;\\n        int i=m;\\n        int j=0;\\n        while(i>=0 && j<=n)\\n        {\\n            if(target < matrix[i][j])\\n            {\\n                i--;\\n            }\\n            else if(target > matrix[i][j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449918,
                "title": "c-best-explanation-with-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem asks to find whether an element is present in a matrix or not. Since the matrix is sorted, we can use binary search to solve this problem. To perform binary search, we can search each row of the matrix using binary search. If we find the target element in any row, we return true, otherwise, we return false.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe iterate over each row of the matrix using a for loop\\n\\nFor each row, we perform binary search by initializing two pointers l and r with the start and end indices of the row, respectively.\\n\\nWe repeat the following until l<=r:\\n\\na. We calculate the middle index of the row by using the formula mid=l+(r-l)/2.\\nb. If the element at the middle index is equal to the target element, we return true.\\nc. If the element at the middle index is less than the target element, we update l to mid+1.\\nd. If the element at the middle index is greater than the target element, we update r to mid-1.\\n\\nIf we do not find the target element in any row, we return false.\\n# Complexity\\n- Time complexity: $$O(mlog(n))$$, where m is the number of rows and n is the number of columns of the matrix. For each row, we perform binary search which takes log(n) time, so the total time complexity is O(mlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$, as we are using constant extra space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n     \\n        for(int i=0; i<m ; i++)\\n        {\\n        int l=0;\\n        int r=n-1;\\n        while(l<=r)\\n           {\\n                int mid=l + (r-l)/2;\\n                if (matrix[i][mid] == target) return true;\\n                if (matrix[i][mid] < target)\\n                {\\n                    l=mid+1;\\n                }\\n                else \\n                {\\n                    r=mid-1; \\n                }\\n            }\\n\\n        }\\n         return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n     \\n        for(int i=0; i<m ; i++)\\n        {\\n        int l=0;\\n        int r=n-1;\\n        while(l<=r)\\n           {\\n                int mid=l + (r-l)/2;\\n                if (matrix[i][mid] == target) return true;\\n                if (matrix[i][mid] < target)\\n                {\\n                    l=mid+1;\\n                }\\n                else \\n                {\\n                    r=mid-1; \\n                }\\n            }\\n\\n        }\\n         return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440654,
                "title": "c-simplified-solution-with-explanation-binary-search",
                "content": "**Intuition**\\nAt first i simply ran two loops and searched for the target and it gave tle with 3 failed cases. So to optimise this code ,it had to be solved at O(log m + n). This means that we need to apply binary search on each row or column respectively.\\n\\n*Approach*\\nIn this code, we are traversing through each element of the row through for loop,one by one.For each row we will apply binary search.  Applying algorithm we obtain a mid element through (int mid=low+(high-low)/2), till [ while(low<=high)] condition is satisfied for the respective row. \\n\\n [if(matrix[i][mid]==target) return true;] this condition means that the middle element is your target. \\n\\n[ else if(matrix[i][mid]>target)] this conditions means that element in the middle of row is greater than the target so obviously target has to lie between matrix[i][0] and matrix[i][mid-1], since middle element is not the target. so fix your high pointer before mid and loop with work accordingly.\\n \\nelse condition is just opposite to else if condition that is works on this loop. in this if target is greater than mid then obv it will be on the right of mid so your low will be mid+1.\\n\\nsame will be applied to all rows of the matrix or you can apply the same using columns\\n\\n\\n\\n **Complexity**\\n- Time complexity:\\nnlogn\\n\\n- Space complexity:\\nconstant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n         bool flag=true;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n           int low=0;\\n           int high=matrix[0].size()-1;\\n           while(low<=high) \\n           {\\n               int mid=low+(high-low)/2;\\n               if(matrix[i][mid]==target) return true;\\n               else if(matrix[i][mid]>target)\\n               {\\n                   high=mid-1;\\n               }\\n               else\\n               {\\n                   low=mid+1;\\n               }\\n           }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n         bool flag=true;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n           int low=0;\\n           int high=matrix[0].size()-1;\\n           while(low<=high) \\n           {\\n               int mid=low+(high-low)/2;\\n               if(matrix[i][mid]==target) return true;\\n               else if(matrix[i][mid]>target)\\n               {\\n                   high=mid-1;\\n               }\\n               else\\n               {\\n                   low=mid+1;\\n               }\\n           }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314783,
                "title": "easy-java-solution",
                "content": "#BInarysearch in 2d arrays....\\n\\n# java Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n      int rows=matrix.length;\\n      int cols=matrix[0].length;\\n      int r=0;\\n      int c=cols-1;\\n      while(r<rows && c>=0){\\n          if(matrix[r][c]==target){\\n              return true;\\n          }\\n          else if(matrix[r][c]<target){\\n              r++;\\n          }\\n          else{\\n              c--;\\n          }\\n      } \\n      return false;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n      int rows=matrix.length;\\n      int cols=matrix[0].length;\\n      int r=0;\\n      int c=cols-1;\\n      while(r<rows && c>=0){\\n          if(matrix[r][c]==target){\\n              return true;\\n          }\\n          else if(matrix[r][c]<target){\\n              r++;\\n          }\\n          else{\\n              c--;\\n          }\\n      } \\n      return false;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302721,
                "title": "easy-solution-beats-100-o-n-m-java",
                "content": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] mat, int t) {\\n        int r=0;\\n        int c=mat[0].length-1;\\n\\n        while(c>=0 && r<mat.length){\\n            if(mat[r][c]==t)return true;\\n            \\n            if(mat[r][c]<t)r++;\\n            else c--;\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] mat, int t) {\\n        int r=0;\\n        int c=mat[0].length-1;\\n\\n        while(c>=0 && r<mat.length){\\n            if(mat[r][c]==t)return true;\\n            \\n            if(mat[r][c]<t)r++;\\n            else c--;\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190066,
                "title": "faang-apporach-self-explanatory-code-well-commented",
                "content": "\\n# Code\\n```\\nclass Solution {\\n//Do Upvote if you like the Approach !!\\n\\n//NOW WE WILL START FROM THE TOP RIGHT CORNER OF THE MATRIX;\\n//IF THE VALUE IS SMALL THEN TARGET THEN WE WILL LEFT IN THE MATRIX\\n//AND IF HTE VALUE IS LARGET THEN TARGET THEN WE WILL MOVE RIGHT IN THE MATRIX\\n//AND THIS IS HOW WE WILL DO AND EFFICENT SEARCH IN THE MATRIX\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int i=0;\\n        int j=col-1;\\n        while(i<row and j>=0){\\n          if(matrix[i][j]==target){\\n              return true;\\n          }\\n          else if(matrix[i][j]>target){\\n                j--;\\n          }\\n          else{\\n              i++;\\n          }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n//Do Upvote if you like the Approach !!\\n\\n//NOW WE WILL START FROM THE TOP RIGHT CORNER OF THE MATRIX;\\n//IF THE VALUE IS SMALL THEN TARGET THEN WE WILL LEFT IN THE MATRIX\\n//AND IF HTE VALUE IS LARGET THEN TARGET THEN WE WILL MOVE RIGHT IN THE MATRIX\\n//AND THIS IS HOW WE WILL DO AND EFFICENT SEARCH IN THE MATRIX\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int i=0;\\n        int j=col-1;\\n        while(i<row and j>=0){\\n          if(matrix[i][j]==target){\\n              return true;\\n          }\\n          else if(matrix[i][j]>target){\\n                j--;\\n          }\\n          else{\\n              i++;\\n          }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023106,
                "title": "1ms-java-most-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int i=0,j=col-1;\\n        while(i<row && j>=0){\\n\\n            if(matrix[i][j]==target){\\n                return true;\\n            }\\n\\n            else if(matrix[i][j]>target){\\n                \\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int i=0,j=col-1;\\n        while(i<row && j>=0){\\n\\n            if(matrix[i][j]==target){\\n                return true;\\n            }\\n\\n            else if(matrix[i][j]>target){\\n                \\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006536,
                "title": "240-search-a-2d-matrix-ii-c-solution-100-all-test-case-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Binary Searching Approach**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Binary Searching Approach**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(nlogn)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(1)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        \\n        //indexis..\\n        int rowIndx=0;\\n        int colIndx=col-1;\\n\\n        while(rowIndx < row and colIndx >= 0){\\n             int element=matrix[rowIndx][colIndx];\\n             if(element==target)\\n             return true;\\n             else if(element < target)\\n               rowIndx++;\\n               else\\n               colIndx--;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        \\n        //indexis..\\n        int rowIndx=0;\\n        int colIndx=col-1;\\n\\n        while(rowIndx < row and colIndx >= 0){\\n             int element=matrix[rowIndx][colIndx];\\n             if(element==target)\\n             return true;\\n             else if(element < target)\\n               rowIndx++;\\n               else\\n               colIndx--;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779767,
                "title": "java-binary-search",
                "content": "\\n# Approach\\nBinary Search in every row until the element is found or we reach at the end of the matrix.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(m)) \\nwhere n is number of rows in matrix and m is number of column in matrix\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        for(int i = 0; i < matrix.length; i++){\\n            int low = 0;\\n            int high = matrix[0].length - 1;\\n\\n            while(low <= high){\\n                int mid = (low+high)/2;\\n                if(matrix[i][mid] == target)\\n                    return true;\\n                if(matrix[i][mid] > target)\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n# *** UP-VOTE IF HELPFUL ***",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        for(int i = 0; i < matrix.length; i++){\\n            int low = 0;\\n            int high = matrix[0].length - 1;\\n\\n            while(low <= high){\\n                int mid = (low+high)/2;\\n                if(matrix[i][mid] == target)\\n                    return true;\\n                if(matrix[i][mid] > target)\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776665,
                "title": "easy-c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n          int rows = matrix.size(),\\n\\t\\t\\tcols = matrix[0].size(),\\n            currow = 0, curcol = cols - 1;\\n\\t\\t\\t\\n        while (currow < rows && curcol >=0) {\\n            int cur = matrix[currow][curcol];\\n            if (target == cur) return true;\\n            else if (target > cur) currow++;\\n            else if (target < cur) curcol--;\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n          int rows = matrix.size(),\\n\\t\\t\\tcols = matrix[0].size(),\\n            currow = 0, curcol = cols - 1;\\n\\t\\t\\t\\n        while (currow < rows && curcol >=0) {\\n            int cur = matrix[currow][curcol];\\n            if (target == cur) return true;\\n            else if (target > cur) currow++;\\n            else if (target < cur) curcol--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2769913,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        // start from the [first row, last column] element\\n        int i=0;\\n        int j=m-1;\\n        while(i<n && j>=0){\\n            if(matrix[i][j]==target) // target found\\n                return true;\\n            else if(matrix[i][j]>target) //target is smaller, go leftwards\\n                --j; // decrease the column index\\n            else // target is larger, go downwards\\n                ++i; // increase the row index\\n        }\\n        return false; // target not found\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        // start from the [first row, last column] element\\n        int i=0;\\n        int j=m-1;\\n        while(i<n && j>=0){\\n            if(matrix[i][j]==target) // target found\\n                return true;\\n            else if(matrix[i][j]>target) //target is smaller, go leftwards\\n                --j; // decrease the column index\\n            else // target is larger, go downwards\\n                ++i; // increase the row index\\n        }\\n        return false; // target not found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328059,
                "title": "java-solution-with-solution-steps-in-image-o-n-m-time-o-1-space",
                "content": "Hey everyone,\\nSo, when I first saw this problem, it was obvious that it should be something like Binary Search or some kind of traversal of the matrix (matrix, sorted, you know..), but how to implement it, thats the real trick. \\n\\nThe brute force will work (although it will be TLE), so I started by thinking of BS of each row and column (vertical / horizontal) but again, time complexity will be high, and then I finally got the trick.\\n\\nWe were able to perform BS on our matrix, due to the fact its sorted, and that fact - we need to use when we iterating 2D matrix. So I played a little with the matrix in my iPad with 2D matrix in the size of `5x5` and `target=8`.\\n\\n#### So, the steps were: \\n\\n1. If I will start from bottom to up, with initiate state of `row = 4, col = 0`, I will know for sure that the `target` is bigger or lower than the current element, and if it equal to, return `True` (otherwise, `False`).\\n2. In each step I check, if the `first element` (and later on, the the `col` element) of row is bigger/lower than the `target`.\\n2.1. If `matrix[row][col]` is bigger, decrease `row`.\\nThe target will probably be in lower row index.\\n2.2. If `matrix[row][col]` is lower, increase `col`.\\nThe target will probably be in higher column index.\\n3. If none was found (loop constraints), so it will return `False`.\\nOtherwise the `matrix[row][col]` is equal to the target and return `True`.\\n4. With that matrix traversal, we increasing/decreasing the row/col index due to the constraints of the matrix and we will get O(n) + O(m) operations O(n+m), each operations is O(1) and we are not using additional space, so space complexity will be O(1).\\n\\nIn the image below, you can see how it possible to ignore all the unrelevant elements in the matrix.\\n\\n![image](https://assets.leetcode.com/users/images/7c93da94-a54c-42b4-a5a1-98885e020ab8_1658678638.0849197.png)\\n\\n#### The Solution\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] array, int target) {\\n        int row = array.length - 1;\\n        int col = 0;\\n        \\n        // o(n + m) operations + o(1) space\\n        while(row >= 0 && col < array[0].length) {\\n            int element = array[row][col];\\n            if(element > target) {\\n                row--;\\n            } else if(element < target) {\\n                col++;\\n            } else {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nHope it was helpful to you all!",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] array, int target) {\\n        int row = array.length - 1;\\n        int col = 0;\\n        \\n        // o(n + m) operations + o(1) space\\n        while(row >= 0 && col < array[0].length) {\\n            int element = array[row][col];\\n            if(element > target) {\\n                row--;\\n            } else if(element < target) {\\n                col++;\\n            } else {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327423,
                "title": "c-explained-faster-than-93",
                "content": "We start in the bottom-left corner, which is \\nmatrix[-1][0]. Obviously, the target cell cannot\\nbe either below or to the left of this corner cell\\n\\n\\u2022 We move incrementally from the corner such that we \\ndo not pass to right of the target\\'s column or above\\nits row; we can ensure this by exploiting the sorted \\nrows and columns. For example (below), the target \\nis 8 and and the corner is 18. So:\\n      -- 18 > 8 =>  move up    to 10,\\n      -- 10 > 8 =>  move up    to  3,\\n      --  3 < 8 =>  move right to  6,\\n      --  6 < 8 =>  move right to  9,\\n      --  9 > 8 =>  move up    to  8.\\n![image](https://assets.leetcode.com/users/images/dbdbb746-a46b-4d37-a6c5-8d6a03991830_1658670733.7791224.png)\\n\\n```\\nbool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    \\n    int row = matrixSize - 1;\\n    int col = 0;\\n    \\n    while (row >= 0 && col < *matrixColSize){\\n        if (matrix[row][col] > target) row--;\\n        else if (matrix[row][col] < target) col++;\\n        else return true;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    \\n    int row = matrixSize - 1;\\n    int col = 0;\\n    \\n    while (row >= 0 && col < *matrixColSize){\\n        if (matrix[row][col] > target) row--;\\n        else if (matrix[row][col] < target) col++;\\n        else return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326388,
                "title": "c-solution-and-explanation-with-diagram-o-m-n",
                "content": "***Intuition*** :\\nIt is given that all rows and columns are sorted i.e.\\n1. Along any row if we move right we\\'ll get bigger numbers and if we move left we\\'ll get smaller numbers.\\n2. Along any column if we move down we\\'ll get bigger numbers and if we move up we\\'ll get smaller numbers.\\n\\nSo we\\'ll start from TOP-RIGHT corner and cancel out a row or a column each time.\\n\\n***Example***\\n![image](https://assets.leetcode.com/users/images/0f5dfd7e-ce47-400b-9755-df832b71590c_1658652769.3947866.png)\\nWe are given this matrix and we need to find 5 i.e. **target = 5**\\nm = 5  and n = 5 \\nm is number of rows and n is number of columns\\n\\n***STEP 1***\\nStarting from TOP-RIGHT corner \\n***row = 0  and col = 4*** (Using 0 based indexing)\\n![image](https://assets.leetcode.com/users/images/3ab61e82-5ed8-4604-a9c5-1366ad41da7a_1658653179.2200706.png)\\nwe get 15 and ***15 > 5 (target)***\\nSo there is no chnace that we\\'ll get 5 if we go down in this column we neglect this column ***col--*** \\n\\n***STEP 2***\\n***row = 0  and col = 3***\\n![image](https://assets.leetcode.com/users/images/b8de2f87-e18b-4e03-aa52-758e942f96ea_1658653459.2397456.png)\\nwe get 11 and ***11 > 5 (target)***\\nAgain there is no chnace that we\\'ll get 5 if we go down in this column we neglect this column ***col--***\\n\\n***STEP 3***\\n***row = 0  and col = 2***\\n![image](https://assets.leetcode.com/users/images/5d032b08-a980-43b6-8875-e6e030b600a4_1658653626.3564353.png)\\nwe get 7 and ***7 > 5 (target)***\\nAgain there is no chnace that we\\'ll get 5 if we go down in this column we neglect this column ***col--***\\n\\n***STEP 4***\\n***row = 0  and col = 1***\\n![image](https://assets.leetcode.com/users/images/b5bb49b7-059e-447a-a487-6c8be552ef12_1658653713.5749893.png)\\nwe get 4 and ***4 < 5 (target)***\\nNow the current element is **smaller** than the target and we have already checked the right portion of this row so we have one possibality now i.e. go down along the column hence we neglect this row.  **row++**.\\n\\n***STEP 5***\\n***row = 1  and col = 1***\\n![image](https://assets.leetcode.com/users/images/210d4e7c-a2ed-4f55-9809-b3920731b590_1658654085.0564797.png)\\nWe get 5 now so we return true ans answer.\\n\\nNOT-FOUND cases\\n1. If col < 0\\n2. If row > totalRows - 1   (Using 0 based indexing)\\n\\n**C++ CODE**\\n```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        if(n < 1 || m < 1)\\n            return false;\\n        // Starting from TOP-RIGHT corner\\n        int row = 0;\\n        int col = n - 1;\\n        while((col >= 0) && (row < m)) {\\n            if(matrix[row][col] == target)\\n                return true;\\n            else if(matrix[row][col] > target)\\n                col--;\\n            else\\n                row++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        if(n < 1 || m < 1)\\n            return false;\\n        // Starting from TOP-RIGHT corner\\n        int row = 0;\\n        int col = n - 1;\\n        while((col >= 0) && (row < m)) {\\n            if(matrix[row][col] == target)\\n                return true;\\n            else if(matrix[row][col] > target)\\n                col--;\\n            else\\n                row++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325209,
                "title": "search-a-element-in-matrix-time-complexity-o-r-c",
                "content": "bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       int r=matrix.size();\\n        int i=0; \\n        int c=matrix[0].size();\\n        int j=c-1;\\n        while(i<r && j>=0){\\n            if(matrix[i][j]==target){\\n                return true ;\\n            }\\n           else if(matrix[i][j]>target){\\n               j--;\\n           }\\n            else{\\n                i++;\\n            }\\n        }\\n       return false; \\n    }",
                "solutionTags": [],
                "code": "bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       int r=matrix.size();\\n        int i=0; \\n        int c=matrix[0].size();\\n        int j=c-1;\\n        while(i<r && j>=0){\\n            if(matrix[i][j]==target){\\n                return true ;\\n            }\\n           else if(matrix[i][j]>target){\\n               j--;\\n           }\\n            else{\\n                i++;\\n            }\\n        }\\n       return false; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2127098,
                "title": "c-easy-3-line-code",
                "content": "```\\n\\n//if target>pivot -->r++;\\n//target<pivot-->c--;\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int n=mat.size(),m=mat[0].size();\\n        int i=0,j=m-1;\\n        while(i<n && j>=0)\\n        {\\n            if(mat[i][j]==target) return true;\\n            else if(mat[i][j]>target) j--;  \\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n//if target>pivot -->r++;\\n//target<pivot-->c--;\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int n=mat.size(),m=mat[0].size();\\n        int i=0,j=m-1;\\n        while(i<n && j>=0)\\n        {\\n            if(mat[i][j]==target) return true;\\n            else if(mat[i][j]>target) j--;  \\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107892,
                "title": "faster-than-others-easy-solution-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].size()-1;\\n        while(i<matrix.size() && j>=0){\\n            if(matrix[i][j]<target)i++;\\n            else if(matrix[i][j]>target)j--;\\n            else \\n                return true;\\n        }\\n        return false; \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].size()-1;\\n        while(i<matrix.size() && j>=0){\\n            if(matrix[i][j]<target)i++;\\n            else if(matrix[i][j]>target)j--;\\n            else \\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2087703,
                "title": "easy-cpp-solution",
                "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=matrix[0].size()-1,j=0;\\n        while(i>=0 && j<matrix.size()){\\n            if(matrix[j][i]==target) \\n                return true;\\n            else if(matrix[j][i]<target) \\n                j++;\\n            else \\n                i--;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=matrix[0].size()-1,j=0;\\n        while(i>=0 && j<matrix.size()){\\n            if(matrix[j][i]==target) \\n                return true;\\n            else if(matrix[j][i]<target) \\n                j++;\\n            else \\n                i--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1898816,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].size()-1;\\n        \\n        while(col>=0 && row<matrix.size())\\n        {\\n            if(matrix[row][col]==target)\\n            {\\n                return true;\\n                break;\\n            }\\n            else if(matrix[row][col]<target)\\n            {\\n                row++;\\n            }\\n            else\\n            {\\n                col--;\\n            }\\n        }\\n        return false;\\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].size()-1;\\n        \\n        while(col>=0 && row<matrix.size())\\n        {\\n            if(matrix[row][col]==target)\\n            {\\n                return true;\\n                break;\\n            }\\n            else if(matrix[row][col]<target)\\n            {\\n                row++;\\n            }\\n            else\\n            {\\n                col--;\\n            }\\n        }\\n        return false;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724015,
                "title": "python-search-space-pruning-o-m-n",
                "content": "I would not call this binary search, more like 2 pointers.\\n\\n```\\nclass Solution:\\n    \"\"\"\\n    \\n    Localize to the correct value by using the value of a cell\\n    starting at the top right.\\n    \\n    Either the top right (the maximum column, minmum row) and bottom left (maximum\\n    row, minimum column) can be used to minimize the search space.\\n    \\n    In our case we started from the top right. Because it is the max column, \\n    if the value at matrix[row][col] is > target, we shrink the column since \\n    the target must be to the left.\\n    \\n    Since we started in the min row, if the value at matrix[row][col] is < target,\\n    we expand the row, since the target must be at least in the next row.\\n    \\n    \\n    \\n    Time complexity: O(m + n). we need max m shrinks and n expands.\\n    \\n\\n    \"\"\"\\n    \\n    \\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        \\n        # start at top right\\n        row = 0\\n        col = cols - 1\\n        \\n        #print (col, cols)\\n        while row >= 0 and col >= 0 and row < rows and col < cols:\\n            #print(row, rows, col, cols)\\n            if matrix[row][col] > target:\\n                col = col - 1\\n            elif matrix[row][col] < target:\\n                row = row + 1\\n            else:\\n                return True\\n            \\n        return False```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    \\n    Localize to the correct value by using the value of a cell\\n    starting at the top right.\\n    \\n    Either the top right (the maximum column, minmum row) and bottom left (maximum\\n    row, minimum column) can be used to minimize the search space.\\n    \\n    In our case we started from the top right. Because it is the max column, \\n    if the value at matrix[row][col] is > target, we shrink the column since \\n    the target must be to the left.\\n    \\n    Since we started in the min row, if the value at matrix[row][col] is < target,\\n    we expand the row, since the target must be at least in the next row.\\n    \\n    \\n    \\n    Time complexity: O(m + n). we need max m shrinks and n expands.\\n    \\n\\n    \"\"\"\\n    \\n    \\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        \\n        # start at top right\\n        row = 0\\n        col = cols - 1\\n        \\n        #print (col, cols)\\n        while row >= 0 and col >= 0 and row < rows and col < cols:\\n            #print(row, rows, col, cols)\\n            if matrix[row][col] > target:\\n                col = col - 1\\n            elif matrix[row][col] < target:\\n                row = row + 1\\n            else:\\n                return True\\n            \\n        return False```",
                "codeTag": "Java"
            },
            {
                "id": 1707567,
                "title": "top-right-corner-explained",
                "content": "Check the top right corner element, \\n1. if it is less than target, target is not present in that row because top right corner is the greatest element in that row.\\n2. if it is greater than target, target is not present in that column because top right corner is the least element in that column.\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int i = 0, j = m-1;\\n        while(i < n  and j > -1){\\n            if (matrix[i][j] == target){\\n                return true;\\n            }\\n            else if (target < matrix[i][j]){\\n                j--;\\n            }\\n            else if (target > matrix[i][j]){\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int i = 0, j = m-1;\\n        while(i < n  and j > -1){\\n            if (matrix[i][j] == target){\\n                return true;\\n            }\\n            else if (target < matrix[i][j]){\\n                j--;\\n            }\\n            else if (target > matrix[i][j]){\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668132,
                "title": "c-solution-optimized-using-row-wise-and-column-wise-sorted-method",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int i=0;\\n        int j=m-1;\\n        while(i<n and j>=0)\\n        {\\n            if(matrix[i][j]==target)\\n                return true;\\n            else if(matrix[i][j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int i=0;\\n        int j=m-1;\\n        while(i<n and j>=0)\\n        {\\n            if(matrix[i][j]==target)\\n                return true;\\n            else if(matrix[i][j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610574,
                "title": "search-in-2d-matrix-ii-o-n-m",
                "content": "We\\'re just moving from top-right to bottom-left element in matrix, we can also do vice versa.\\n```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), i = 0, j = matrix[0].size() - 1;\\n        while (i < row && j >= 0) //i++ can exceed row & j-- can be < 0\\n        {\\n            if (matrix[i][j] == target) return true;\\n            else if (matrix[i][j] > target) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), i = 0, j = matrix[0].size() - 1;\\n        while (i < row && j >= 0) //i++ can exceed row & j-- can be < 0\\n        {\\n            if (matrix[i][j] == target) return true;\\n            else if (matrix[i][j] > target) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1591346,
                "title": "c-2-solutions",
                "content": "Solution 1:\\nO(m+n)\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int i = 0, j = m-1;\\n        while(j>=0 && i<n){\\n            if(matrix[i][j] == target)  return true;\\n            else if(matrix[i][j] > target){//delete a col\\n                j--;\\n            }  \\n            else{ //delete a row\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```\\n\\nSolution 2:\\nO(n*log(m))\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i=0; i <n; i++){\\n            if (target < matrix[i][0] || target > matrix[i][m-1]) continue;\\n            if(binary_search(matrix[i].begin(), matrix[i].end(), target))   return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int i = 0, j = m-1;\\n        while(j>=0 && i<n){\\n            if(matrix[i][j] == target)  return true;\\n            else if(matrix[i][j] > target){//delete a col\\n                j--;\\n            }  \\n            else{ //delete a row\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i=0; i <n; i++){\\n            if (target < matrix[i][0] || target > matrix[i][m-1]) continue;\\n            if(binary_search(matrix[i].begin(), matrix[i].end(), target))   return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529976,
                "title": "all-possible-solutions-by-ashay-nayak-best-solution-o-n-m",
                "content": "Please **upvote** if you find it helpful. Thank You.\\nPurpose - Practice of thinking of all possible solution which help you in **interviews**.\\nFeel free to comment below if you don\\'t get anything. I will surely reply back **within 12 hours.**\\n**3rd solution is best solution**\\npossible solutions...\\n\\n1.) Two For loops - TC - O(n^2) and SC - O(1) - please try to think by yourself and if you don\\'t get it then comment below.\\n\\n2.) Binary Search - TC - O(mlogn) and SC - O(1) - Iterate through each row and apply binary search to find the target. In worst case you will find the target in last row. See code below:\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length==0) return false;\\n        int rows=matrix.length, cols=matrix[0].length;\\n        for(int r=0; r<rows; r++){\\n            int lo=0, hi=cols-1;\\n            while(lo <= hi){\\n                int mid = (lo + hi)/2;\\n                if(matrix[r][mid] == target) return true;\\n                if(target <= matrix[r][mid]){\\n                    hi = mid-1;\\n                }else lo = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n3.) Start from top right - TC - O(n+m) and SC - O(1) - **best solution** - remember this - as mentioned in question that given 2d array is sorted in ascending order from left to right and top to bottom. Now, imagine you are standing at top right corner initially. Now you will check 3 conditions: (1) if target==value then you have found the target and return true. (2) if target<value, just think for a minute that what will you do? From you position either you can move towards bottom or towards left. As it is sorted in ascending order, if you move towards bottom then we will move towards increasing values and if we move towrads left then we will move towards decreasing values. As your target<value, we will move towards left to find the target. (3) if target>value, we will move towards bottom to find the target. See code below:\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        \\n        int i=0,j=col-1;\\n        \\n        while(i<row&&j>=0){\\n            if(matrix[i][j]==target)return true;\\n            else if(target<matrix[i][j])j--;\\n            else i++;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length==0) return false;\\n        int rows=matrix.length, cols=matrix[0].length;\\n        for(int r=0; r<rows; r++){\\n            int lo=0, hi=cols-1;\\n            while(lo <= hi){\\n                int mid = (lo + hi)/2;\\n                if(matrix[r][mid] == target) return true;\\n                if(target <= matrix[r][mid]){\\n                    hi = mid-1;\\n                }else lo = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        \\n        int i=0,j=col-1;\\n        \\n        while(i<row&&j>=0){\\n            if(matrix[i][j]==target)return true;\\n            else if(target<matrix[i][j])j--;\\n            else i++;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463365,
                "title": "c-single-traversal-solution-with-explanation",
                "content": "**If you like the approach please upvote as it motivates me to create such post!!!**\\n```\\nclass Solution {\\npublic:\\n    //since we know that the matrix is sorted row-wise as well as column-wise.. we will take advantage of it\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        // if we consider the upper right corner .. from that position if we see the values below it are increasing while values left to it are decresing .. so we use this to find our solution..\\n        int i=0;\\n        int j = col-1;\\n        while(i<row && j>=0){\\n            //first case is if we found the element we wanted to search then simply we will return true\\n            if(matrix[i][j] == target){\\n                return true;\\n            }else if(matrix[i][j] > target){ // second case if the value at that cell is greater than the value we want so in that case we will go left.. as left side values are smaller\\n                j--;\\n            }else{ //and now the last case is that if the value we want is greater than the value in the cell then we will move to bottom as bottom values are more than the value present in that particular cell..\\n                i++;\\n            }\\n        }\\n        return false; // if we traverse whole matrix and could not found the value then we simply return false as value is not present in the matrix.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //since we know that the matrix is sorted row-wise as well as column-wise.. we will take advantage of it\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        // if we consider the upper right corner .. from that position if we see the values below it are increasing while values left to it are decresing .. so we use this to find our solution..\\n        int i=0;\\n        int j = col-1;\\n        while(i<row && j>=0){\\n            //first case is if we found the element we wanted to search then simply we will return true\\n            if(matrix[i][j] == target){\\n                return true;\\n            }else if(matrix[i][j] > target){ // second case if the value at that cell is greater than the value we want so in that case we will go left.. as left side values are smaller\\n                j--;\\n            }else{ //and now the last case is that if the value we want is greater than the value in the cell then we will move to bottom as bottom values are more than the value present in that particular cell..\\n                i++;\\n            }\\n        }\\n        return false; // if we traverse whole matrix and could not found the value then we simply return false as value is not present in the matrix.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419121,
                "title": "easy-python-solution-faster-than-98-memory-93",
                "content": "#  Easy Python Solution | Faster than 98%, Memory < 93%\\n\\n**Runtime: 152 ms, faster than 98% of Python3 online submissions for Search a 2D Matrix II.\\nMemory Usage: 20 MB, less than 93% of Python3 online submissions for Search a 2D Matrix II.**\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for r in matrix:\\n            if r[0] <= target and r[-1] >= target:\\n                l, h = 0, len(r)-1\\n                while l <= h:\\n                    m = (l+h)//2\\n                    if r[m] > target:\\n                        h = m - 1\\n                    elif r[m] < target:\\n                        l = m + 1\\n                    else:\\n                        return True\\n            else:\\n                continue\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for r in matrix:\\n            if r[0] <= target and r[-1] >= target:\\n                l, h = 0, len(r)-1\\n                while l <= h:\\n                    m = (l+h)//2\\n                    if r[m] > target:\\n                        h = m - 1\\n                    elif r[m] < target:\\n                        l = m + 1\\n                    else:\\n                        return True\\n            else:\\n                continue\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321994,
                "title": "c-saddleback-search-o-m-n-explained",
                "content": "##### **Saddleback Search**\\n\\n**Algorithm**\\nStart from top right element\\n1. If the element if equal to target, return true\\n2. If the element is greater than target, move down *(increment row)*\\n3. If the element is less than target, move left *(decrement col)*\\n\\nTime complexity: O(m + n)\\n\\n\\n**C++ Code**\\n```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].size() - 1;\\n\\n        while(row < matrix.size() && col >= 0){\\n            \\n            if(matrix[row][col] == target) return true;\\n            (matrix[row][col] > target) ? col-- : row++;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].size() - 1;\\n\\n        while(row < matrix.size() && col >= 0){\\n            \\n            if(matrix[row][col] == target) return true;\\n            (matrix[row][col] > target) ? col-- : row++;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265170,
                "title": "easy-java-beats-100-4-lines-of-code-very-simple",
                "content": "```\\npublic boolean searchMatrix(int[][] matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].length-1; //starting at the last column is the key point here\\n        \\n        while(i <matrix.length && j>=0){\\n            if(matrix[i][j]== target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n\\t\\n\\tIf you find it easy please upvote!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean searchMatrix(int[][] matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].length-1; //starting at the last column is the key point here\\n        \\n        while(i <matrix.length && j>=0){\\n            if(matrix[i][j]== target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n\\t\\n\\tIf you find it easy please upvote!",
                "codeTag": "Unknown"
            },
            {
                "id": 1240641,
                "title": "blazzing-fast-short-clean-concise-binary-search-o-r-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        int i = 0;\\n        int j = cols - 1;\\n        \\n        while(i >= 0 && i < rows and j >= 0 && j < cols)\\n        {\\n            if(target == matrix[i][j]) return true;\\n            else if(target < matrix[i][j]) j--;\\n            else i++;\\n        }\\n    return false;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        int i = 0;\\n        int j = cols - 1;\\n        \\n        while(i >= 0 && i < rows and j >= 0 && j < cols)\\n        {\\n            if(target == matrix[i][j]) return true;\\n            else if(target < matrix[i][j]) j--;\\n            else i++;\\n        }\\n    return false;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080114,
                "title": "search-a-2d-matrix-ii-python-beats-90",
                "content": "Every step trying to narrow down search area to smaller matrix.\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        L1, L2 = len(matrix)-1, len(matrix[0]) -1\\n        i1, i2 = 0, L1\\n        j1, j2 = 0, L2\\n        \\n        while 0 <=i1 <= i2 <= L1 and 0 <=j1 <= j2 <= L2:\\n            if target == matrix[i2][j1] or target == matrix[i1][j2]: return True\\n            if matrix[i1][j2] < target: i1+=1\\n            elif matrix[i2][j1] < target: j1+=1 \\n            elif matrix[i2][j1] > target: j2-=1\\n            elif matrix[i2][j2] > target: i2-=1 \\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        L1, L2 = len(matrix)-1, len(matrix[0]) -1\\n        i1, i2 = 0, L1\\n        j1, j2 = 0, L2\\n        \\n        while 0 <=i1 <= i2 <= L1 and 0 <=j1 <= j2 <= L2:\\n            if target == matrix[i2][j1] or target == matrix[i1][j2]: return True\\n            if matrix[i1][j2] < target: i1+=1\\n            elif matrix[i2][j1] < target: j1+=1 \\n            elif matrix[i2][j1] > target: j2-=1\\n            elif matrix[i2][j2] > target: i2-=1 \\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061937,
                "title": "o-log-m-log-n-java-solution",
                "content": "Runtime is 6 ms.\\nI know this can be improved a little bit, but it should be sufficient from Interview point of view. Technically, this solution is equivalent to solving 3 different problems. Look at the comments for understanding.\\n\\nI think worst case could happen when all the elements in the row or column for the given indexes are duplicates, which will cause the **binary search** to run for each element in the corresponding row or column. This might make the current solution O(m + n), but I think, this can also be avoided by doing some extra checks on start and end indexes.\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null) {\\n            return false;\\n        }\\n\\n        int m = matrix.length;\\n        if (m == 0) {\\n            return false;\\n        }\\n\\n        int n = matrix[0].length;\\n\\n        int row = 0;\\n        int col = n-1;\\n        // Start from Top right entry in the matrix.\\n        // If target is less than the entry, we do binary search on the row.\\n        // Else, we do binary search on the column\\n        while (row < m && col >= 0) {\\n\\t\\t    // Target is found\\n            if (matrix[row][col] == target) {\\n                return true;\\n            }\\n\\n            if (matrix[row][col] > target) {\\n\\t\\t\\t\\t// If target is less than the current item, we do a binary search on the current row to find the appropriate column\\n                col = searchRow(matrix, row, col-1, target);\\n            } else {\\n\\t\\t\\t\\t// If target is greater than the current item, we do a binary search on the current column to find the appropriate row\\n                row = searchCol(matrix, col, row+1, target);\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    // Binary search on the row and return index of column for the possible entry\\n    // Technically, this is finding the first index of repeated target element in a sorted array, if the target exists.\\n    // Otherwise, it is just returning the index where target should have been in that particular row.\\n    private int searchRow(int[][] matrix, int rowIdx, int colEndIdx, int target) {\\n        int mid;\\n        int start = 0;\\n        int end = colEndIdx;\\n\\n        while (start < end) {\\n            mid = start + ((end-start)/2);\\n\\n            if (matrix[rowIdx][mid] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return end;\\n    }\\n\\n    // Binary search on the column and return index of row for the possible entry\\n    // Technically, this is finding the last index of repeated target element in a sorted array, if the target exists.\\n    // Otherwise, it is just returning the index where target should have been in that particular column.\\n    private int searchCol(int[][] matrix, int colIdx, int rowStartIdx, int target) {\\n        int mid;\\n        int start = rowStartIdx;\\n        int end = matrix.length;\\n\\n        while (start < end) {\\n            mid = start + ((end-start)/2);\\n\\n            if (matrix[mid][colIdx] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return end;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null) {\\n            return false;\\n        }\\n\\n        int m = matrix.length;\\n        if (m == 0) {\\n            return false;\\n        }\\n\\n        int n = matrix[0].length;\\n\\n        int row = 0;\\n        int col = n-1;\\n        // Start from Top right entry in the matrix.\\n        // If target is less than the entry, we do binary search on the row.\\n        // Else, we do binary search on the column\\n        while (row < m && col >= 0) {\\n\\t\\t    // Target is found\\n            if (matrix[row][col] == target) {\\n                return true;\\n            }\\n\\n            if (matrix[row][col] > target) {\\n\\t\\t\\t\\t// If target is less than the current item, we do a binary search on the current row to find the appropriate column\\n                col = searchRow(matrix, row, col-1, target);\\n            } else {\\n\\t\\t\\t\\t// If target is greater than the current item, we do a binary search on the current column to find the appropriate row\\n                row = searchCol(matrix, col, row+1, target);\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    // Binary search on the row and return index of column for the possible entry\\n    // Technically, this is finding the first index of repeated target element in a sorted array, if the target exists.\\n    // Otherwise, it is just returning the index where target should have been in that particular row.\\n    private int searchRow(int[][] matrix, int rowIdx, int colEndIdx, int target) {\\n        int mid;\\n        int start = 0;\\n        int end = colEndIdx;\\n\\n        while (start < end) {\\n            mid = start + ((end-start)/2);\\n\\n            if (matrix[rowIdx][mid] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return end;\\n    }\\n\\n    // Binary search on the column and return index of row for the possible entry\\n    // Technically, this is finding the last index of repeated target element in a sorted array, if the target exists.\\n    // Otherwise, it is just returning the index where target should have been in that particular column.\\n    private int searchCol(int[][] matrix, int colIdx, int rowStartIdx, int target) {\\n        int mid;\\n        int start = rowStartIdx;\\n        int end = matrix.length;\\n\\n        while (start < end) {\\n            mid = start + ((end-start)/2);\\n\\n            if (matrix[mid][colIdx] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836104,
                "title": "python-d-c-recursion",
                "content": "Divide and Conquer approach using recursion. With 4 areas and optimized with 3 areas.\\n\\nhttps://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/\\n\\nAs I undestand the optimized solution is O(log n) because in every recurscive step we work with 3/4 (0.75%) of the matrix thus T(n) = log_(4/3) n\\n\\n```\\nclass Solution:\\n    def searchMatrix_optimized(self, matrix, target):\\n        \"\"\"\\n\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return False\\n        if len(matrix) == 1 and len(matrix[0]) == 1:\\n            if matrix[0][0] == target:\\n                return True\\n            else:\\n                return False\\n\\n        pivot_x, pivot_y = len(matrix) // 2, len(matrix[0]) // 2\\n\\n        if matrix[pivot_x][pivot_y] > target:\\n            tl = self.searchMatrix([row[:pivot_y] for row in matrix[:pivot_x]], target)\\n            bl = self.searchMatrix([row[pivot_y:] for row in matrix[:pivot_x]], target)\\n            tr = self.searchMatrix([row[:pivot_y] for row in matrix[pivot_x:]], target)\\n            return tl or tr or bl\\n        elif matrix[pivot_x][pivot_y] < target:\\n            br = self.searchMatrix([row[pivot_y:] for row in matrix[pivot_x:]], target)\\n            bl = self.searchMatrix([row[pivot_y:] for row in matrix[:pivot_x]], target)\\n            tr = self.searchMatrix([row[:pivot_y] for row in matrix[pivot_x:]], target)\\n            return tr or bl or br\\n        else:\\n            return True\\n\\n\\n    def searchMatrix_bf(self, matrix, target):\\n        \"\"\"\\n\\n        Naive O(n ^ 2)\\n\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return False\\n        if len(matrix) == 1 and len(matrix[0]) == 1:\\n            if matrix[0][0] == target:\\n                return True\\n            else:\\n                return False\\n\\n        pivot_x, pivot_y = len(matrix) // 2, len(matrix[0]) // 2\\n\\n        tl = self.searchMatrix([row[:pivot_y] for row in matrix[:pivot_x]], target)\\n        br = self.searchMatrix([row[pivot_y:] for row in matrix[pivot_x:]], target)\\n        bl = self.searchMatrix([row[pivot_y:] for row in matrix[:pivot_x]], target)\\n        tr = self.searchMatrix([row[:pivot_y] for row in matrix[pivot_x:]], target)\\n\\n        return tl or tr or bl or br\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix_optimized(self, matrix, target):\\n        \"\"\"\\n\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return False\\n        if len(matrix) == 1 and len(matrix[0]) == 1:\\n            if matrix[0][0] == target:\\n                return True\\n            else:\\n                return False\\n\\n        pivot_x, pivot_y = len(matrix) // 2, len(matrix[0]) // 2\\n\\n        if matrix[pivot_x][pivot_y] > target:\\n            tl = self.searchMatrix([row[:pivot_y] for row in matrix[:pivot_x]], target)\\n            bl = self.searchMatrix([row[pivot_y:] for row in matrix[:pivot_x]], target)\\n            tr = self.searchMatrix([row[:pivot_y] for row in matrix[pivot_x:]], target)\\n            return tl or tr or bl\\n        elif matrix[pivot_x][pivot_y] < target:\\n            br = self.searchMatrix([row[pivot_y:] for row in matrix[pivot_x:]], target)\\n            bl = self.searchMatrix([row[pivot_y:] for row in matrix[:pivot_x]], target)\\n            tr = self.searchMatrix([row[:pivot_y] for row in matrix[pivot_x:]], target)\\n            return tr or bl or br\\n        else:\\n            return True\\n\\n\\n    def searchMatrix_bf(self, matrix, target):\\n        \"\"\"\\n\\n        Naive O(n ^ 2)\\n\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return False\\n        if len(matrix) == 1 and len(matrix[0]) == 1:\\n            if matrix[0][0] == target:\\n                return True\\n            else:\\n                return False\\n\\n        pivot_x, pivot_y = len(matrix) // 2, len(matrix[0]) // 2\\n\\n        tl = self.searchMatrix([row[:pivot_y] for row in matrix[:pivot_x]], target)\\n        br = self.searchMatrix([row[pivot_y:] for row in matrix[pivot_x:]], target)\\n        bl = self.searchMatrix([row[pivot_y:] for row in matrix[:pivot_x]], target)\\n        tr = self.searchMatrix([row[:pivot_y] for row in matrix[pivot_x:]], target)\\n\\n        return tl or tr or bl or br\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810393,
                "title": "c-easy-to-understand-and-optimised-solution-with-explanation",
                "content": "**Plese upvote my solution if you like it**\\n\\none thing to understand in this question is that the element below the current element is always greater than the current element.And the element on the left of the current element is always less than the current element.\\n\\nSo my solution is totaly based on this observation \\n1. Start form Top most Row and right most column.\\n2. check if the current element is target or not.\\n3. After that if current element is not a target element then and the current element is greater then the target element then we have to move left(IN simple words column-=1).\\n4. Else move down(means row+=1)\\n5. if out of bound occure return false\\n\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size()==0)return 0;\\n        int row=0,column=matrix[0].size()-1;//topmost row and rightmost column\\n        while(row<matrix.size() && column>=0) //checking for out of bound condition\\n        {\\n            if(matrix[row][column]==target)//checking if current element is target or not \\n                return 1;\\n            if(matrix[row][column]>target)//if current element is greater then target then move left or decrement column\\n                column--;\\n            else //else increment row or move down \\n                row++;\\n        }\\n        return 0;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size()==0)return 0;\\n        int row=0,column=matrix[0].size()-1;//topmost row and rightmost column\\n        while(row<matrix.size() && column>=0) //checking for out of bound condition\\n        {\\n            if(matrix[row][column]==target)//checking if current element is target or not \\n                return 1;\\n            if(matrix[row][column]>target)//if current element is greater then target then move left or decrement column\\n                column--;\\n            else //else increment row or move down \\n                row++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 762355,
                "title": "python-double-binary-search-better-than-90",
                "content": "The idea is the following:\\nWe start at ```row 0 and col 0```\\nWe perform a binary search on the row and a binary search on the column. If we didn\\'t find our target we proceed to perform a binary search from\\n```row 1 and col 1```, this way we eliminate checking already visited cells.\\n\\nCode is very readable.\\n\\n```\\nclass Solution:\\n    def row_binary_search(self, row, lo, hi):\\n        if lo >= hi:\\n            return self.matrix[row][hi] == self.target\\n        \\n        mid = (lo + hi) // 2\\n        cell = self.matrix[row][mid]\\n        \\n        if cell == self.target:\\n            return True\\n        elif cell < self.target:\\n            return self.row_binary_search(row, mid + 1, hi)\\n        else:\\n            return self.row_binary_search(row, lo, mid - 1)\\n    \\n    def col_binary_search(self, col, lo, hi):\\n        if lo >= hi:\\n            return self.matrix[hi][col] == self.target\\n        \\n        mid = (lo + hi) // 2\\n        cell = self.matrix[mid][col]\\n        \\n        if cell == self.target:\\n            return True\\n        elif cell < self.target:\\n            return self.col_binary_search(col, mid + 1, hi)\\n        else:\\n            return self.col_binary_search(col, lo, mid - 1)\\n    \\n    def searchMatrix(self, matrix, target):\\n        # The idea is to binary search the row and binary search the column and move 1 row and 1 col in\\n        if not matrix or not matrix[0]: return False\\n        \\n        self.matrix, self.target = matrix,  target\\n        n, m = len(matrix), len(matrix[0])\\n        row, col = 0, 0\\n        \\n        while row < n and col < m:\\n            if self.row_binary_search(row, col, m - 1):\\n                return True\\n            if self.col_binary_search(col, row, n - 1):\\n                return True\\n            row += 1\\n            col += 1\\n        \\n        # We can have col or row left over\\n        if col < m:\\n            return self.row_binary_search(row - 1, col, m - 1)\\n        else:\\n            # row < n\\n            return self.col_binary_search(col - 1, row, n - 1)\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```row 0 and col 0```\n```row 1 and col 1```\n```\\nclass Solution:\\n    def row_binary_search(self, row, lo, hi):\\n        if lo >= hi:\\n            return self.matrix[row][hi] == self.target\\n        \\n        mid = (lo + hi) // 2\\n        cell = self.matrix[row][mid]\\n        \\n        if cell == self.target:\\n            return True\\n        elif cell < self.target:\\n            return self.row_binary_search(row, mid + 1, hi)\\n        else:\\n            return self.row_binary_search(row, lo, mid - 1)\\n    \\n    def col_binary_search(self, col, lo, hi):\\n        if lo >= hi:\\n            return self.matrix[hi][col] == self.target\\n        \\n        mid = (lo + hi) // 2\\n        cell = self.matrix[mid][col]\\n        \\n        if cell == self.target:\\n            return True\\n        elif cell < self.target:\\n            return self.col_binary_search(col, mid + 1, hi)\\n        else:\\n            return self.col_binary_search(col, lo, mid - 1)\\n    \\n    def searchMatrix(self, matrix, target):\\n        # The idea is to binary search the row and binary search the column and move 1 row and 1 col in\\n        if not matrix or not matrix[0]: return False\\n        \\n        self.matrix, self.target = matrix,  target\\n        n, m = len(matrix), len(matrix[0])\\n        row, col = 0, 0\\n        \\n        while row < n and col < m:\\n            if self.row_binary_search(row, col, m - 1):\\n                return True\\n            if self.col_binary_search(col, row, n - 1):\\n                return True\\n            row += 1\\n            col += 1\\n        \\n        # We can have col or row left over\\n        if col < m:\\n            return self.row_binary_search(row - 1, col, m - 1)\\n        else:\\n            # row < n\\n            return self.col_binary_search(col - 1, row, n - 1)\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565039,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1568502,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1804251,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1567929,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1570311,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1568164,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1574245,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1576195,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 2006099,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 2004196,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1565039,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1568502,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1804251,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1567929,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1570311,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1568164,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1574245,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1576195,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 2006099,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 2004196,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote ❤️"
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1574529,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 1571482,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 2073107,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 2005365,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 2004476,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 2003997,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 1971292,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 1955047,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 1913771,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 1889669,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 1888625,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1886032,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1876249,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1854719,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1854155,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1833607,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1810852,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1806977,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1799746,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1795582,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1793194,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1785043,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1757552,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1748799,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1733557,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1730095,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1723180,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1716644,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1692492,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1688442,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Substring with At Most K Distinct Characters",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1569089,
                "content": [
                    {
                        "username": "kislayabhi",
                        "content": "I developed some intuition by solving a few problems of Dynamic Programming ... that the Longest Common subsequence (and some similar problems) can be handled nicely using Dynamic Programming. (Also LCS is discussed in great detail in Intro to Algo book [Cormen et. al])\\n\\nGiven you face this in an interview, how to *think* that it is not DP and that another linear time algorithm is possible. Right now I was able to do it since I couldn't come up with a proper recurrence (but to convince myself there is no DP recurrence possible, I had to spend a lot of time!!)\\n\\nWhat is your take on this?"
                    },
                    {
                        "username": "n0000b",
                        "content": "DP can be used pretty much for any problem you may come across, but it\\'s going to be a lot more complex and worst at time complexity, hence we\\'ve other techniques that we could use to reason about.\\n\\nFor example, this question is asking for a longest substring from a given string. A substring a sequence of strings and \"not\" the subsequence. Subsequence is not continuous, hence your intuition of deploying LCS based approach would result in lot more complex solution with an awful time complexity.\\n\\nFor the most part whenever you\\'re asked for \"continuous\" to work with, the sliding window or a two pointer approach is the way to go."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Something to remember is a hashmap itself has a size, and can serve in place of just using a list when you want to track an extra piece of information."
                    },
                    {
                        "username": "jooseong",
                        "content": "Here\\'s my code:\\nhttps://leetcode.com/playground/2cePRrEv\\n\\nFor testcase \"eceba\" / 2, the expected answer is 3:\\nBut if I submit this, the output is 2.\\n\\nStrange thing is that, in my eclipse and even in leetcode\\'s \"playground debug\", the code outputs 3, a right answer.\\nWhy this happens?"
                    },
                    {
                        "username": "tvue",
                        "content": "at most  k(3) distinct chars. How is \"ece\" atmost 3 distinct chars? 2 is correct unless I'm missing something here"
                    },
                    {
                        "username": "jbiesnecker",
                        "content": "Whenever I\\'m asked for the longest subsequence of something, my first thought it always some sort of sliding window. In this case it\\'s pretty easy and linear, because each letter is either 1) already in the window; 2) new but not causing the unique characters to overflow; or 3) new but causing the unique characters to overflow. Based on which case the new letter causes we can figure out how to move the left side of the window."
                    }
                ]
            },
            {
                "id": 1965017,
                "content": [
                    {
                        "username": "kislayabhi",
                        "content": "I developed some intuition by solving a few problems of Dynamic Programming ... that the Longest Common subsequence (and some similar problems) can be handled nicely using Dynamic Programming. (Also LCS is discussed in great detail in Intro to Algo book [Cormen et. al])\\n\\nGiven you face this in an interview, how to *think* that it is not DP and that another linear time algorithm is possible. Right now I was able to do it since I couldn't come up with a proper recurrence (but to convince myself there is no DP recurrence possible, I had to spend a lot of time!!)\\n\\nWhat is your take on this?"
                    },
                    {
                        "username": "n0000b",
                        "content": "DP can be used pretty much for any problem you may come across, but it\\'s going to be a lot more complex and worst at time complexity, hence we\\'ve other techniques that we could use to reason about.\\n\\nFor example, this question is asking for a longest substring from a given string. A substring a sequence of strings and \"not\" the subsequence. Subsequence is not continuous, hence your intuition of deploying LCS based approach would result in lot more complex solution with an awful time complexity.\\n\\nFor the most part whenever you\\'re asked for \"continuous\" to work with, the sliding window or a two pointer approach is the way to go."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Something to remember is a hashmap itself has a size, and can serve in place of just using a list when you want to track an extra piece of information."
                    },
                    {
                        "username": "jooseong",
                        "content": "Here\\'s my code:\\nhttps://leetcode.com/playground/2cePRrEv\\n\\nFor testcase \"eceba\" / 2, the expected answer is 3:\\nBut if I submit this, the output is 2.\\n\\nStrange thing is that, in my eclipse and even in leetcode\\'s \"playground debug\", the code outputs 3, a right answer.\\nWhy this happens?"
                    },
                    {
                        "username": "tvue",
                        "content": "at most  k(3) distinct chars. How is \"ece\" atmost 3 distinct chars? 2 is correct unless I'm missing something here"
                    },
                    {
                        "username": "jbiesnecker",
                        "content": "Whenever I\\'m asked for the longest subsequence of something, my first thought it always some sort of sliding window. In this case it\\'s pretty easy and linear, because each letter is either 1) already in the window; 2) new but not causing the unique characters to overflow; or 3) new but causing the unique characters to overflow. Based on which case the new letter causes we can figure out how to move the left side of the window."
                    }
                ]
            },
            {
                "id": 1572508,
                "content": [
                    {
                        "username": "kislayabhi",
                        "content": "I developed some intuition by solving a few problems of Dynamic Programming ... that the Longest Common subsequence (and some similar problems) can be handled nicely using Dynamic Programming. (Also LCS is discussed in great detail in Intro to Algo book [Cormen et. al])\\n\\nGiven you face this in an interview, how to *think* that it is not DP and that another linear time algorithm is possible. Right now I was able to do it since I couldn't come up with a proper recurrence (but to convince myself there is no DP recurrence possible, I had to spend a lot of time!!)\\n\\nWhat is your take on this?"
                    },
                    {
                        "username": "n0000b",
                        "content": "DP can be used pretty much for any problem you may come across, but it\\'s going to be a lot more complex and worst at time complexity, hence we\\'ve other techniques that we could use to reason about.\\n\\nFor example, this question is asking for a longest substring from a given string. A substring a sequence of strings and \"not\" the subsequence. Subsequence is not continuous, hence your intuition of deploying LCS based approach would result in lot more complex solution with an awful time complexity.\\n\\nFor the most part whenever you\\'re asked for \"continuous\" to work with, the sliding window or a two pointer approach is the way to go."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Something to remember is a hashmap itself has a size, and can serve in place of just using a list when you want to track an extra piece of information."
                    },
                    {
                        "username": "jooseong",
                        "content": "Here\\'s my code:\\nhttps://leetcode.com/playground/2cePRrEv\\n\\nFor testcase \"eceba\" / 2, the expected answer is 3:\\nBut if I submit this, the output is 2.\\n\\nStrange thing is that, in my eclipse and even in leetcode\\'s \"playground debug\", the code outputs 3, a right answer.\\nWhy this happens?"
                    },
                    {
                        "username": "tvue",
                        "content": "at most  k(3) distinct chars. How is \"ece\" atmost 3 distinct chars? 2 is correct unless I'm missing something here"
                    },
                    {
                        "username": "jbiesnecker",
                        "content": "Whenever I\\'m asked for the longest subsequence of something, my first thought it always some sort of sliding window. In this case it\\'s pretty easy and linear, because each letter is either 1) already in the window; 2) new but not causing the unique characters to overflow; or 3) new but causing the unique characters to overflow. Based on which case the new letter causes we can figure out how to move the left side of the window."
                    }
                ]
            },
            {
                "id": 1678583,
                "content": [
                    {
                        "username": "kislayabhi",
                        "content": "I developed some intuition by solving a few problems of Dynamic Programming ... that the Longest Common subsequence (and some similar problems) can be handled nicely using Dynamic Programming. (Also LCS is discussed in great detail in Intro to Algo book [Cormen et. al])\\n\\nGiven you face this in an interview, how to *think* that it is not DP and that another linear time algorithm is possible. Right now I was able to do it since I couldn't come up with a proper recurrence (but to convince myself there is no DP recurrence possible, I had to spend a lot of time!!)\\n\\nWhat is your take on this?"
                    },
                    {
                        "username": "n0000b",
                        "content": "DP can be used pretty much for any problem you may come across, but it\\'s going to be a lot more complex and worst at time complexity, hence we\\'ve other techniques that we could use to reason about.\\n\\nFor example, this question is asking for a longest substring from a given string. A substring a sequence of strings and \"not\" the subsequence. Subsequence is not continuous, hence your intuition of deploying LCS based approach would result in lot more complex solution with an awful time complexity.\\n\\nFor the most part whenever you\\'re asked for \"continuous\" to work with, the sliding window or a two pointer approach is the way to go."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Something to remember is a hashmap itself has a size, and can serve in place of just using a list when you want to track an extra piece of information."
                    },
                    {
                        "username": "jooseong",
                        "content": "Here\\'s my code:\\nhttps://leetcode.com/playground/2cePRrEv\\n\\nFor testcase \"eceba\" / 2, the expected answer is 3:\\nBut if I submit this, the output is 2.\\n\\nStrange thing is that, in my eclipse and even in leetcode\\'s \"playground debug\", the code outputs 3, a right answer.\\nWhy this happens?"
                    },
                    {
                        "username": "tvue",
                        "content": "at most  k(3) distinct chars. How is \"ece\" atmost 3 distinct chars? 2 is correct unless I'm missing something here"
                    },
                    {
                        "username": "jbiesnecker",
                        "content": "Whenever I\\'m asked for the longest subsequence of something, my first thought it always some sort of sliding window. In this case it\\'s pretty easy and linear, because each letter is either 1) already in the window; 2) new but not causing the unique characters to overflow; or 3) new but causing the unique characters to overflow. Based on which case the new letter causes we can figure out how to move the left side of the window."
                    }
                ]
            }
        ]
    },
    {
        "title": "K-th Smallest in Lexicographical Order",
        "question_content": "<p>Given two integers <code>n</code> and <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>lexicographically smallest integer in the range</em> <code>[1, n]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 13, k = 2\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, k = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 92242,
                "title": "concise-easy-to-understand-java-5ms-solution-with-explaination",
                "content": "Original idea comes from \\nhttp://bookshadow.com/weblog/2016/10/24/leetcode-k-th-smallest-in-lexicographical-order/\\n\\nActually this is a denary tree (each node has 10 children). Find the kth element is to do a k steps preorder traverse of the tree.\\n![0_1477293053966_upload-40379731-118a-4753-bed9-1cb372790d4b](/uploads/files/1477293057263-upload-40379731-118a-4753-bed9-1cb372790d4b.png) \\n\\nInitially, image you are at node 1 (variable: curr), \\nthe goal is move (k - 1) steps to the target node x.  (substract steps from k after moving)\\nwhen k is down to 0, curr will be finally at node x, there you get the result.\\n\\nwe don't really need to do a exact k steps preorder traverse of the denary tree, **the idea is to calculate the steps between curr and curr + 1 (neighbor nodes in same level), in order to skip some unnecessary moves.**\\n\\n**Main function**\\nFirstly, calculate how many steps curr need to move to curr + 1.\\n1. if the steps <= k, we know we can move to curr + 1, and narrow down k to k - steps.\\n\\n2. else if the steps > k, that means the curr + 1 is actually behind the target node x in the preorder path, we can't  jump to curr + 1. What we have to do is to move forward only 1 step (curr * 10 is always next preorder node) and repeat the iteration.\\n\\n\\n\\n**calSteps function**\\n\\n1.  how to calculate the steps between curr and curr + 1?\\n   Here we come up a idea to calculate by level.\\n   Let n1 = curr, n2 = curr + 1.\\n   n2 is always the next right node beside n1's right most node (who shares the same ancestor \"curr\")\\n(refer to the pic, 2 is right next to 1, 20 is right next to 19, 200 is right next to 199).\\n\\n   2. so, if n2 <= n, what means n1's right most node exists, we can simply add the number of nodes from n1 to n2 to steps.\\n\\n   3. else if n2 > n, what means n (the biggest node) is on the path between n1 to n2, add (n + 1 - n1) to  steps.\\n\\n   4. organize this flow to \"steps += Math.min(n + 1, n2) - n1; n1 *= 10; n2 *= 10;\"\\n\\n\\n\\n**Here is the code snippet:**\\n\\n    public int findKthNumber(int n, int k) {\\n        int curr = 1;\\n        k = k - 1;\\n        while (k > 0) {\\n            int steps = calSteps(n, curr, curr + 1);\\n            if (steps <= k) {\\n                curr += 1;\\n                k -= steps;\\n            } else {\\n                curr *= 10;\\n                k -= 1;\\n            }\\n        }\\n        return curr;\\n    }\\n    //use long in case of overflow\\n    public int calSteps(int n, long n1, long n2) {\\n        int steps = 0;\\n        while (n1 <= n) {\\n            steps += Math.min(n + 1, n2) - n1;\\n            n1 *= 10;\\n            n2 *= 10;\\n        }\\n        return steps;\\n    }",
                "solutionTags": [],
                "code": "Original idea comes from \\nhttp://bookshadow.com/weblog/2016/10/24/leetcode-k-th-smallest-in-lexicographical-order/\\n\\nActually this is a denary tree (each node has 10 children). Find the kth element is to do a k steps preorder traverse of the tree.\\n![0_1477293053966_upload-40379731-118a-4753-bed9-1cb372790d4b](/uploads/files/1477293057263-upload-40379731-118a-4753-bed9-1cb372790d4b.png) \\n\\nInitially, image you are at node 1 (variable: curr), \\nthe goal is move (k - 1) steps to the target node x.  (substract steps from k after moving)\\nwhen k is down to 0, curr will be finally at node x, there you get the result.\\n\\nwe don't really need to do a exact k steps preorder traverse of the denary tree, **the idea is to calculate the steps between curr and curr + 1 (neighbor nodes in same level), in order to skip some unnecessary moves.**\\n\\n**Main function**\\nFirstly, calculate how many steps curr need to move to curr + 1.\\n1. if the steps <= k, we know we can move to curr + 1, and narrow down k to k - steps.\\n\\n2. else if the steps > k, that means the curr + 1 is actually behind the target node x in the preorder path, we can't  jump to curr + 1. What we have to do is to move forward only 1 step (curr * 10 is always next preorder node) and repeat the iteration.\\n\\n\\n\\n**calSteps function**\\n\\n1.  how to calculate the steps between curr and curr + 1?\\n   Here we come up a idea to calculate by level.\\n   Let n1 = curr, n2 = curr + 1.\\n   n2 is always the next right node beside n1's right most node (who shares the same ancestor \"curr\")\\n(refer to the pic, 2 is right next to 1, 20 is right next to 19, 200 is right next to 199).\\n\\n   2. so, if n2 <= n, what means n1's right most node exists, we can simply add the number of nodes from n1 to n2 to steps.\\n\\n   3. else if n2 > n, what means n (the biggest node) is on the path between n1 to n2, add (n + 1 - n1) to  steps.\\n\\n   4. organize this flow to \"steps += Math.min(n + 1, n2) - n1; n1 *= 10; n2 *= 10;\"\\n\\n\\n\\n**Here is the code snippet:**\\n\\n    public int findKthNumber(int n, int k) {\\n        int curr = 1;\\n        k = k - 1;\\n        while (k > 0) {\\n            int steps = calSteps(n, curr, curr + 1);\\n            if (steps <= k) {\\n                curr += 1;\\n                k -= steps;\\n            } else {\\n                curr *= 10;\\n                k -= 1;\\n            }\\n        }\\n        return curr;\\n    }\\n    //use long in case of overflow\\n    public int calSteps(int n, long n1, long n2) {\\n        int steps = 0;\\n        while (n1 <= n) {\\n            steps += Math.min(n + 1, n2) - n1;\\n            n1 *= 10;\\n            n2 *= 10;\\n        }\\n        return steps;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2997641,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int findKthNumber(long n, int k) {\\n    auto getGap = [&n](long a, long b) {\\n      long gap = 0;\\n      while (a <= n) {\\n        gap += min(n + 1, b) - a;\\n        a *= 10;\\n        b *= 10;\\n      }\\n      return gap;\\n    };\\n\\n    long currNum = 1;\\n\\n    for (int i = 1; i < k;) {\\n      long gap = getGap(currNum, currNum + 1);\\n      if (i + gap <= k) {\\n        i += gap;\\n        ++currNum;\\n      } else {\\n        ++i;\\n        currNum *= 10;\\n      }\\n    }\\n\\n    return currNum;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.nextNodes = []\\n\\n    def __eq__(self, other):\\n        return self.val == other\\n\\nclass Solution:\\n    def generateTrieTree(self, data: list):\\n        root = Node(None)\\n        for intChar in data:\\n            pointer = root\\n            for char in intChar:\\n                try:\\n                    existedNodeIdx = pointer.nextNodes.index(char)\\n                    pointer = pointer.nextNodes[existedNodeIdx]\\n                except:\\n                    newNode = Node(char)\\n                    pointer.nextNodes.append(newNode)\\n                    pointer = newNode\\n        return root\\n\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        result = 1\\n        k -= 1\\n        while k > 0:\\n            count = 0\\n            interval = [result, result + 1]\\n            while interval[0] <= n:\\n                count += (min(n + 1, interval[1]) - interval[0])\\n                interval = [10 * interval[0], 10 * interval[1]]\\n\\n            if k >= count:\\n                result += 1\\n                k -= count\\n            else:\\n                result *= 10\\n                k -= 1\\n        return result\\n        \\n        \\n        root = self.generateTrieTree([str(i) for i in range(1, n + 1)])\\n        output = []\\n\\n        def traverse(pointer, previousVal):\\n            nextNodes = pointer.nextNodes\\n            if not nextNodes:\\n                return\\n\\n            for node in nextNodes:\\n                if len(output) == k:\\n                    return\\n\\n                newVal = previousVal + node.val\\n                output.append(newVal)\\n                traverse(node, newVal)\\n\\n        traverse(root, \"\")\\n        return int(output[-1])\\n```\\n\\n```Java []\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        int prefix=1;\\n        for(int count=1;count<k;){\\n            int currCount=getCountWithPrefix(prefix,prefix+1,n);\\n            if(currCount+count<=k){\\n                count+=currCount;\\n                prefix++;\\n            }else{\\n                prefix*=10;\\n                count++;\\n            }\\n        }\\n        return prefix;\\n    }\\n    private int getCountWithPrefix(long startPrefix,long endPrefix,int max){\\n        int count=0;\\n        while(startPrefix<=max){\\n            count+=Math.min(max+1,endPrefix)-startPrefix;\\n            startPrefix*=10;\\n            endPrefix*=10;\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int findKthNumber(long n, int k) {\\n    auto getGap = [&n](long a, long b) {\\n      long gap = 0;\\n      while (a <= n) {\\n        gap += min(n + 1, b) - a;\\n        a *= 10;\\n        b *= 10;\\n      }\\n      return gap;\\n    };\\n\\n    long currNum = 1;\\n\\n    for (int i = 1; i < k;) {\\n      long gap = getGap(currNum, currNum + 1);\\n      if (i + gap <= k) {\\n        i += gap;\\n        ++currNum;\\n      } else {\\n        ++i;\\n        currNum *= 10;\\n      }\\n    }\\n\\n    return currNum;\\n  }\\n};\\n```\n```Python3 []\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.nextNodes = []\\n\\n    def __eq__(self, other):\\n        return self.val == other\\n\\nclass Solution:\\n    def generateTrieTree(self, data: list):\\n        root = Node(None)\\n        for intChar in data:\\n            pointer = root\\n            for char in intChar:\\n                try:\\n                    existedNodeIdx = pointer.nextNodes.index(char)\\n                    pointer = pointer.nextNodes[existedNodeIdx]\\n                except:\\n                    newNode = Node(char)\\n                    pointer.nextNodes.append(newNode)\\n                    pointer = newNode\\n        return root\\n\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        result = 1\\n        k -= 1\\n        while k > 0:\\n            count = 0\\n            interval = [result, result + 1]\\n            while interval[0] <= n:\\n                count += (min(n + 1, interval[1]) - interval[0])\\n                interval = [10 * interval[0], 10 * interval[1]]\\n\\n            if k >= count:\\n                result += 1\\n                k -= count\\n            else:\\n                result *= 10\\n                k -= 1\\n        return result\\n        \\n        \\n        root = self.generateTrieTree([str(i) for i in range(1, n + 1)])\\n        output = []\\n\\n        def traverse(pointer, previousVal):\\n            nextNodes = pointer.nextNodes\\n            if not nextNodes:\\n                return\\n\\n            for node in nextNodes:\\n                if len(output) == k:\\n                    return\\n\\n                newVal = previousVal + node.val\\n                output.append(newVal)\\n                traverse(node, newVal)\\n\\n        traverse(root, \"\")\\n        return int(output[-1])\\n```\n```Java []\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        int prefix=1;\\n        for(int count=1;count<k;){\\n            int currCount=getCountWithPrefix(prefix,prefix+1,n);\\n            if(currCount+count<=k){\\n                count+=currCount;\\n                prefix++;\\n            }else{\\n                prefix*=10;\\n                count++;\\n            }\\n        }\\n        return prefix;\\n    }\\n    private int getCountWithPrefix(long startPrefix,long endPrefix,int max){\\n        int count=0;\\n        while(startPrefix<=max){\\n            count+=Math.min(max+1,endPrefix)-startPrefix;\\n            startPrefix*=10;\\n            endPrefix*=10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92254,
                "title": "c-python-0ms-o-log-n-2-time-o-1-space-super-easy-solution-with-detailed-explanations",
                "content": "This solution is inspired by @mgch's code.\\n\\n**General ideas:**\\n**1. Calculate the number of numbers that prefix with `result`.**\\n    Numbers prefixed by `result` are the union of the following intervals:\\n     [`result`, `result`+1)\\n     [`result`*10,  (`result`+1)*10 )\\n     [`result`*100,  (`result`+1)*100 )\\n    ...\\n    But they also shall belong to [1, n]\\n    Therefore, we can easily calculate the number of elements prefixed by `result` using the following code (not considering overflow):\\n\\n                int count = 0;\\n                for (int first = result, last = result + 1; // the first interval contains only one element: {result}\\n                    first <= n; // the interval is not empty\\n                    first *= 10, last *= 10) // increase a digit\\n                {\\n                    // valid interval = [first, last) union [first, n]\\n                    count += (min(n + 1, last) - first); // add the length of interval\\n                }\\n\\n**2. Search the next prefix, or search more detailedly.**\\n* If the number of numbers that prefixed by `result` is smaller than the remaining `k`, we do not need to consider the numbers prefixed by `result` any more, and march to the next prefix: `result`+1;\\n* Otherwise, we need to search more detailedly, by appending another digit to the prefix. Such search shall start with `result`*10.\\n\\n**C++**\\n\\n    class Solution {\\n    public:\\n        int findKthNumber(int n, int k)\\n        {\\n            int result = 1;\\n            for(--k; k > 0; )\\n            {\\n                // calculate #|{result, result*, result**, result***, ...}|\\n                int count = 0;\\n                for (long long first = static_cast<long long>(result), last = first + 1;\\n                    first <= n; // the interval is not empty\\n                    first *= 10, last *= 10) // increase a digit\\n                {\\n                    // valid interval = [first, last) union [first, n]\\n                    count += static_cast<int>((min(n + 1LL, last) - first)); // add the length of interval\\n                }\\n                \\n                if (k >= count)\\n                {   // skip {result, result*, result**, result***, ...}\\n                    // increase the current prefix\\n                    ++result;\\n                    k -= count;\\n                }\\n                else\\n                {   // not able to skip all of {result, result*, result**, result***, ...}\\n                    // search more detailedly\\n                    result *= 10;\\n                    --k;\\n                }\\n            }\\n            return result;\\n        }\\n    };\\n\\n**Python**\\n\\n    class Solution(object):\\n        def findKthNumber(self, n, k):\\n            result = 1;\\n            k -= 1\\n            while k > 0:\\n                count = 0\\n                interval = [result, result+1]\\n                while interval[0] <= n:\\n                    count += (min(n+1, interval[1]) - interval[0])\\n                    interval = [10*interval[0], 10*interval[1]]\\n                \\n                if k >= count:\\n                    result += 1\\n                    k -= count\\n                else:\\n                    result *= 10\\n                    k -= 1\\n            return result\\n\\n\\n\\n**Complexities:**\\n\\n* **Time Complexity:**   *O*( (log*n*) ^ 2 )\\nHere, log*n* is the number of digits in *n*, and it is also the number of replications of  appending zero to search detailedly. Each such appending introduces the increasement of prefix at most 10 times, and each increasement may require *O*(log*n*) time to calculate the number of numbers that prefixed by the `result`.\\n* **Space Complexity:** *O*(1)",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int findKthNumber(int n, int k)\\n        {\\n            int result = 1;\\n            for(--k; k > 0; )\\n            {\\n                // calculate #|{result, result*, result**, result***, ...}",
                "codeTag": "Java"
            },
            {
                "id": 369094,
                "title": "java-100-solution",
                "content": "Video:\\nhttps://youtu.be/yMnR63e3KLo\\n```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        long cur = 1;\\n        while(k > 1) {\\n            long gap = findGap(cur, cur + 1, n);\\n            if(gap <= k - 1) {\\n                k -= gap;\\n                cur = cur + 1;\\n            }\\n            else {\\n                cur = cur * 10;\\n                k -= 1;\\n            }\\n        }\\n\\n        return (int)cur;\\n    }\\n    \\n    private long findGap(long a, long b, int n) {\\n        long gap = 0;\\n        while(a <= n) {\\n            gap += Math.min(n + 1, b) - a;\\n            a = a * 10;\\n            b = b * 10;\\n        }\\n        return gap;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        long cur = 1;\\n        while(k > 1) {\\n            long gap = findGap(cur, cur + 1, n);\\n            if(gap <= k - 1) {\\n                k -= gap;\\n                cur = cur + 1;\\n            }\\n            else {\\n                cur = cur * 10;\\n                k -= 1;\\n            }\\n        }\\n\\n        return (int)cur;\\n    }\\n    \\n    private long findGap(long a, long b, int n) {\\n        long gap = 0;\\n        while(a <= n) {\\n            gap += Math.min(n + 1, b) - a;\\n            a = a * 10;\\n            b = b * 10;\\n        }\\n        return gap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 125769,
                "title": "an-o-log-2-implementation-using-prefixcount",
                "content": "Given a prefix ***a***, and an upper bound ***n***, ***prefixCount(p, n)*** returns the number of integers in [***1, n***], with prefix ***p***. For instance, ***prefixCount(12, 123) = 5***, since all numbers with prefix ***12*** are [***12, 120, 121, 122, 123***]. With prefixCount, we can implement ***findKthNumber*** as following:\\n```\\nint findKthNumber(int n, int k) {\\n        --k;\\n        int prefix = 1;\\n        while (k) {\\n            int c = prefixCount(prefix, n);\\n            if (k < c) { //current prefix is good, refine it\\n                --k;\\n                prefix *= 10;\\n            } else { //current prefix is too small, move to next prefix\\n                k -= c;\\n                prefix++;\\n            }\\n        }\\n        return prefix;\\n    }\\n```\\nAssume ***prefixCount*** takes ***O(log n)*** time. The running time of above function is ***O***(***log^2 n***). Now let\\u2019s talk about how to implement ***prefixCount***.\\n\\nA naive way to compute ***prefixCount*** is:\\n```\\nint prefixCount(int p, int n) {\\n    if (p > n) return 0;\\n    int res = 1;\\n    for (int i = 0; i < 10; ++i) res += prefixCount(p * 10 + i, n);\\n    return res;\\n}\\n```\\nThe time complexity is ***O***(***n***). However, you might notice, if ***p*** is not prefix of ***n***,  all ***prefixCount***(***p***  * ***10*** + ***i***), for ***9 >= i >=0*** will return the same value. This leads to the optimization:\\n```\\nint prefixCount(int p, int n) {\\n    if (p > n) return 0;\\n    if (p is not prefix of n) return 1 + 10 * prefixCount(p * 10 + 0, n);\\n    int res = 1;\\n    for (int i = 0; i < 10; ++i) res += prefixCount(p * 10 + i, n);\\n    return res;\\n}\\n```\\nAssume you can check if ***p*** is prefix of ***n*** in constant time, with this optimization, the time complexity becomes ***O***(***log n***), since the depth of the recursion is ***O***(***log n***) and there are ***10*** branches at each level (when ***p*** is the prefix of ***n***).\\n\\nChecking if ***p*** is prefix of ***n*** is trivial if we slight change our recursion to maintain the order of magnitude of ***n/p***. Here is the complete implementation:\\n```\\nint prefixCount(uint64_t p, int n, int mask) {\\n    if (p > n) return 0;\\n    if (p != n / mask) return 1 + 10 * prefixCount(p * 10 + 0, n, mask / 10);\\n    int res = 1;\\n    for (int i = 0; i < 10; ++i) res += prefixCount(p * 10 + i, n, mask / 10);\\n    return res;\\n}\\nint prefixCount(uint64_t  p, int n) {\\n    uint64_t mask = 1;\\n    while (p * mask <= n) mask *= 10;\\n    return prefixCount(p, n, mask / 10);\\n}\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nint findKthNumber(int n, int k) {\\n        --k;\\n        int prefix = 1;\\n        while (k) {\\n            int c = prefixCount(prefix, n);\\n            if (k < c) { //current prefix is good, refine it\\n                --k;\\n                prefix *= 10;\\n            } else { //current prefix is too small, move to next prefix\\n                k -= c;\\n                prefix++;\\n            }\\n        }\\n        return prefix;\\n    }\\n```\n```\\nint prefixCount(int p, int n) {\\n    if (p > n) return 0;\\n    int res = 1;\\n    for (int i = 0; i < 10; ++i) res += prefixCount(p * 10 + i, n);\\n    return res;\\n}\\n```\n```\\nint prefixCount(int p, int n) {\\n    if (p > n) return 0;\\n    if (p is not prefix of n) return 1 + 10 * prefixCount(p * 10 + 0, n);\\n    int res = 1;\\n    for (int i = 0; i < 10; ++i) res += prefixCount(p * 10 + i, n);\\n    return res;\\n}\\n```\n```\\nint prefixCount(uint64_t p, int n, int mask) {\\n    if (p > n) return 0;\\n    if (p != n / mask) return 1 + 10 * prefixCount(p * 10 + 0, n, mask / 10);\\n    int res = 1;\\n    for (int i = 0; i < 10; ++i) res += prefixCount(p * 10 + i, n, mask / 10);\\n    return res;\\n}\\nint prefixCount(uint64_t  p, int n) {\\n    uint64_t mask = 1;\\n    while (p * mask <= n) mask *= 10;\\n    return prefixCount(p, n, mask / 10);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92255,
                "title": "c-0ms-solution-digit-by-digit",
                "content": "Let n = 1500, how many numbers has the prefix \\u201c1\\u201d and in the range of n?\\n10-19: 10\\n100-199: 100\\n1000-1999: 501\\nIf k <= 611, the answer has the prefix \"1\", otherwise, remove all the numbers have the prefix \"1\", and search the prefix \"2\".\\nTime complexity should be O(digits^3).\\n\\n``` CPP\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k, int start = 0) {\\n        if(k > 0) {\\n            for(int i = (start==0)?1:0; i <= 9; i++) { // append 0-9 to the prefix\\n                int count = numbersBeginWith(n, 10*start+i);\\n                if(k <= count) // if k <= count, the answer is begin with the prefix\\n                    return findKthNumber(n, k-1, 10*start+i);\\n                k -= count; // if the answer does not begin with the prefix, remove all the numbers begin with this prefix\\n            }\\n        }\\n        return start;\\n    }\\n    \\n    // return how many numbers are begin with the prefix and in the range of N\\n    int numbersBeginWith(int n, long long prefix) \\n    {\\n        long long fac = 1;\\n        int count = 0;\\n        for(int digit = 1; digit <= 9; digit++) {\\n            long long min = prefix*fac;\\n            long long max = prefix*fac+fac-1;\\n            if(n < min)\\n                break;\\n            else if(min <= n && n <= max) {\\n                count += (n-min+1);\\n                break;\\n            }\\n            else\\n                count += fac;\\n            fac *= 10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` CPP\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k, int start = 0) {\\n        if(k > 0) {\\n            for(int i = (start==0)?1:0; i <= 9; i++) { // append 0-9 to the prefix\\n                int count = numbersBeginWith(n, 10*start+i);\\n                if(k <= count) // if k <= count, the answer is begin with the prefix\\n                    return findKthNumber(n, k-1, 10*start+i);\\n                k -= count; // if the answer does not begin with the prefix, remove all the numbers begin with this prefix\\n            }\\n        }\\n        return start;\\n    }\\n    \\n    // return how many numbers are begin with the prefix and in the range of N\\n    int numbersBeginWith(int n, long long prefix) \\n    {\\n        long long fac = 1;\\n        int count = 0;\\n        for(int digit = 1; digit <= 9; digit++) {\\n            long long min = prefix*fac;\\n            long long max = prefix*fac+fac-1;\\n            if(n < min)\\n                break;\\n            else if(min <= n && n <= max) {\\n                count += (n-min+1);\\n                break;\\n            }\\n            else\\n                count += fac;\\n            fac *= 10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92248,
                "title": "java-7ms-denary-trie-tree-solution-with-detailed-explanation",
                "content": "There is a good explanation at  [there](https://discuss.leetcode.com/topic/64387/it-s-a-denary-tree).\\n\\nThe solution used DFS to search in a trie tree. The trick is to skip the sub-tree if the (current index + node number of the sub-tree) is smaller than the k.\\n\\nThe key problem is - How to count the nodes in a sub-tree?\\n\\nThe trie tree was made up of two kinds of sub-tree, the complete sub-tree with each node either has ten or zero children and the incomplete sub-tree with some inner nodes can has 1 to 9 children.\\n\\nThe complete tree's nodes number is easy to get, it will be something like 1, 11, 111, 1111...(each node has ten children plus the root)\\n\\nThe incomplete tree can be calculated like the flowing example:\\n\\nfor n = 213, the tree will be something like this:\\n\\n```\\n                                      $\\n  /                 /                /                 \\\\\\n 1                 2                 3                 [4 ~ 9]                                 \\n /\\\\                 /\\\\              /\\\\                  /\\\\\\n0, [1~9]         0,   1,[2~9]    0,[1~9]               ...\\n/      \\\\          /   /           \\n[0~9]  ...     [0~9] [0~3] \\n```\\n\\nthe sub-trees start with char '1' and '3'~'9' are complete trees, which '1' sub-tree with ranges in 1,10~19, 100~199 has 111 nodes and '3'~'9' each has 11 nodes (e.g. 3 with ranges in 3, 30~39).\\n\\nthe sub-tree starts with '2' is not full, i.e. the ranges are 2, 20~29, 200~213. But the '2' sub-tree still has a 'complete' tree like  '3'~'9' with range in 2, 20~29, and we just need to add the remained leaf nodes which is (213%200)+1 or (213-200)+1. \\n\\nThe 200 is the most left node in the '2' sub-tree and 299 is the most right node in '2' sub-tree if it is complete.  \\nit also showed the idea about how to judge a given sub-three is complete or incomplete:\\n\\nWe first **assume all sub-trees are complete** and test by following:\\n\\n```\\n{\\nif (the most right node in a sub-tree is not greater than the number n) \\n\\n    the sub-tree is complete with nodes number  = 111..(log10(n)+1 1s)\\n\\nelse if (the most left node in a sub-tree is greater than the number n) \\n\\n    the sub-tree is complete with nodes number  = 11...  (log10(n) 1s)\\n\\nelse\\n\\n    the sub-tree is incomplete with nodes number = \\nn - (the most left node in the subree) + 1 + 11... (log10(n) 1s)\\n}\\n```\\n\\nThe nodes number in a complete tree can be  [cached.](https://discuss.leetcode.com/topic/64419/3ms-c-solution) \\n\\nThen we just need to recursively decrease k by the nodes number of the skipped \\nsub-tree until k reached 1.\\n\\nAlso be carefully the first layer is start from 1 while other layers are start from 0.\\n\\n```\\npublic class Solution {\\n    int countNum(int n){\\n        int i=0;\\n        while(n>0){\\n            n/=10;\\n            i++;\\n        }\\n        return i;\\n    }\\n    int getFullTreeNum(int depth){\\n        int sum=0, children=1;\\n        while(depth>0){\\n            sum+=children;\\n            children*=10;\\n            depth--;\\n        }\\n        return sum;\\n    }\\n    int getMax(int prefix, int depth){\\n        while(depth>0){\\n            prefix*=10;\\n            prefix+=9;\\n            depth--;\\n        }\\n        return prefix;\\n    }\\n    int getMin(int prefix, int depth){\\n        while(depth>0){\\n            prefix*=10;\\n            depth--;\\n        }\\n        return prefix;\\n    }\\n    int helper(int n, int k, int prefix, int depth){\\n        int lowNum=getFullTreeNum(depth), highNum=getFullTreeNum(depth-1);\\n        for(int i=(prefix==0?1:0);i<=9;i++){\\n            int nodeNum=0;\\n            if(getMax(prefix*10+i, depth-1)<=n){\\n                nodeNum=lowNum;\\n            }\\n            else if(getMin(prefix*10+i, depth-1)>n){\\n                nodeNum=highNum;\\n            }\\n            else{\\n                nodeNum=highNum+((n-getMin(prefix*10+i, depth-1))+1);\\n            }\\n            k-=nodeNum;\\n            if(k<=0){\\n                k+=nodeNum;\\n                if(k==1){\\n                    return prefix*10+i;\\n                }\\n                else {\\n                    return helper(n, k-1, prefix*10+i, depth-1);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public int findKthNumber(int n, int k) {\\n        int depth=countNum(n);\\n        int index=0;\\n        return helper(n, k, 0, depth);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n                                      $\\n  /                 /                /                 \\\\\\n 1                 2                 3                 [4 ~ 9]                                 \\n /\\\\                 /\\\\              /\\\\                  /\\\\\\n0, [1~9]         0,   1,[2~9]    0,[1~9]               ...\\n/      \\\\          /   /           \\n[0~9]  ...     [0~9] [0~3] \\n```\n```\\n{\\nif (the most right node in a sub-tree is not greater than the number n) \\n\\n    the sub-tree is complete with nodes number  = 111..(log10(n)+1 1s)\\n\\nelse if (the most left node in a sub-tree is greater than the number n) \\n\\n    the sub-tree is complete with nodes number  = 11...  (log10(n) 1s)\\n\\nelse\\n\\n    the sub-tree is incomplete with nodes number = \\nn - (the most left node in the subree) + 1 + 11... (log10(n) 1s)\\n}\\n```\n```\\npublic class Solution {\\n    int countNum(int n){\\n        int i=0;\\n        while(n>0){\\n            n/=10;\\n            i++;\\n        }\\n        return i;\\n    }\\n    int getFullTreeNum(int depth){\\n        int sum=0, children=1;\\n        while(depth>0){\\n            sum+=children;\\n            children*=10;\\n            depth--;\\n        }\\n        return sum;\\n    }\\n    int getMax(int prefix, int depth){\\n        while(depth>0){\\n            prefix*=10;\\n            prefix+=9;\\n            depth--;\\n        }\\n        return prefix;\\n    }\\n    int getMin(int prefix, int depth){\\n        while(depth>0){\\n            prefix*=10;\\n            depth--;\\n        }\\n        return prefix;\\n    }\\n    int helper(int n, int k, int prefix, int depth){\\n        int lowNum=getFullTreeNum(depth), highNum=getFullTreeNum(depth-1);\\n        for(int i=(prefix==0?1:0);i<=9;i++){\\n            int nodeNum=0;\\n            if(getMax(prefix*10+i, depth-1)<=n){\\n                nodeNum=lowNum;\\n            }\\n            else if(getMin(prefix*10+i, depth-1)>n){\\n                nodeNum=highNum;\\n            }\\n            else{\\n                nodeNum=highNum+((n-getMin(prefix*10+i, depth-1))+1);\\n            }\\n            k-=nodeNum;\\n            if(k<=0){\\n                k+=nodeNum;\\n                if(k==1){\\n                    return prefix*10+i;\\n                }\\n                else {\\n                    return helper(n, k-1, prefix*10+i, depth-1);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    public int findKthNumber(int n, int k) {\\n        int depth=countNum(n);\\n        int index=0;\\n        return helper(n, k, 0, depth);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92270,
                "title": "it-s-a-denary-tree",
                "content": "A naive solution is pre-order traversal of the tree. We can do better by skipping over a sub-tree if the k is larger than the number of nodes in that sub-tree + current index. \\n\\nFunction **count** does the part of counting number of nodes in a sub-tree given prefix of number in lexicographical order.\\n\\n```\\npublic class Solution {\\n    int index = 0;\\n    int ans = 0;\\n    public int findKthNumber(int n, int k) {\\n        for(int i=1;i<=9;i++) {\\n            int c = count(n, i, \"\");\\n            if(k>c+index) {\\n                index+=c;\\n                continue;\\n            }\\n            if(helper(n, k, \"\"+i)) break;\\n        }\\n        return ans;\\n    }\\n    public boolean helper(int n, int k, String cur) {\\n        index++;\\n        if(index==k) {\\n            ans = Integer.valueOf(cur);\\n            return true;\\n        }\\n        for(int i=0; i<=9; i++) {\\n            int c = count(n, i, cur);\\n            if(k>c+index) {\\n                index+=c;\\n                continue;\\n            }\\n            if(Integer.valueOf(cur+i)<=n) if(helper(n, k, cur+i)) return true;\\n        }\\n        return false;\\n    }\\n    public int count(int n, int i, String prefix) {\\n        long cur = Long.valueOf(prefix+i);\\n        int ans = 0;\\n        int number = 1;\\n        while(cur<=n) {\\n            ans += number;\\n            cur *= 10;\\n            number *= 10;\\n        }\\n        if(n<(cur/10+number/10-1)) ans -= cur/10+number/10-1-n;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int index = 0;\\n    int ans = 0;\\n    public int findKthNumber(int n, int k) {\\n        for(int i=1;i<=9;i++) {\\n            int c = count(n, i, \"\");\\n            if(k>c+index) {\\n                index+=c;\\n                continue;\\n            }\\n            if(helper(n, k, \"\"+i)) break;\\n        }\\n        return ans;\\n    }\\n    public boolean helper(int n, int k, String cur) {\\n        index++;\\n        if(index==k) {\\n            ans = Integer.valueOf(cur);\\n            return true;\\n        }\\n        for(int i=0; i<=9; i++) {\\n            int c = count(n, i, cur);\\n            if(k>c+index) {\\n                index+=c;\\n                continue;\\n            }\\n            if(Integer.valueOf(cur+i)<=n) if(helper(n, k, cur+i)) return true;\\n        }\\n        return false;\\n    }\\n    public int count(int n, int i, String prefix) {\\n        long cur = Long.valueOf(prefix+i);\\n        int ans = 0;\\n        int number = 1;\\n        while(cur<=n) {\\n            ans += number;\\n            cur *= 10;\\n            number *= 10;\\n        }\\n        if(n<(cur/10+number/10-1)) ans -= cur/10+number/10-1-n;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1608540,
                "title": "python3-traverse-denary-trie",
                "content": "\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        \\n        def fn(x): \\n            \"\"\"Return node counts in denary trie.\"\"\"\\n            ans, diff = 0, 1\\n            while x <= n: \\n                ans += min(n - x + 1, diff)\\n                x *= 10 \\n                diff *= 10 \\n            return ans \\n        \\n        x = 1\\n        while k > 1: \\n            cnt = fn(x)\\n            if k > cnt: k -= cnt; x += 1\\n            else: k -= 1; x *= 10 \\n        return x\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        \\n        def fn(x): \\n            \"\"\"Return node counts in denary trie.\"\"\"\\n            ans, diff = 0, 1\\n            while x <= n: \\n                ans += min(n - x + 1, diff)\\n                x *= 10 \\n                diff *= 10 \\n            return ans \\n        \\n        x = 1\\n        while k > 1: \\n            cnt = fn(x)\\n            if k > cnt: k -= cnt; x += 1\\n            else: k -= 1; x *= 10 \\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1347097,
                "title": "c-digit-by-digit-prefix-count-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for K-th Smallest in Lexicographical Order.\\nMemory Usage: 6.1 MB, less than 28.46% of C++ online submissions for K-th Smallest in Lexicographical Order.\\n\\nThis solution is taken from the post of \"**NotModified**\", for my own purpose details explanations are added.\\n\\n```\\nWe have to find the Kth smallest number  in Lexicographical Order, we can use Trie DS and iterate over it\\nas numbers are lexicographically sorted in Trie but limit is 10^9 too high here and so it will give TLE.\\n\\nIn lexicographically sorted array lower MSB digit prefix numbers always comes first and so we can count\\nthe number of numbers with lower prefix and if count is less than K, then Kth number will contain in the\\nnumbers with lower prefix MSB digit range (1 to N) otherwise it will be in the next higher prefix number\\nwith same digit range. This way we can count numbers with prefix \"1\" and check with K, if K<= count then\\nMSB prefix is \"1\" and then we go to next digit MSB prefix \"10\" otherwise we check for MSB digit \"2\" and so on. \\nWhen K <= count we decrease K by 1 cause we already have the prefix number in which Kth value falls\\nand so we can ignore it. If K > count we go to MSB digit next prefix and so we can ignore previous prefix\\ncount from K. When K ==0 we will get our prefix value as result.\\n```\\n\\n```\\nFrom lexicographically sorted numbers 1 to 13 =>  [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]\\nwe see that first 5 numbers have prefix \"1\" and then the other numbers have their own sequential values.\\nHere if K = 3 then result = 11\\nFirst number count with prefix \"1\" in range 1 to 13 is 5 and K =3 means Kth number must start with \\nprefix \"1\". Now we got the first digit of our result number which is \"1\". We have to find the next digit\\nand we will take the next digit prefix of \"1\" which is \"10\". As we already know that 1 is the MSB digit of\\nresult we can ignore it from count K and so we decrement K and now K = 2. Number count with prefix \"10\"\\nin range 10 to 13 is 1 and K = 2 and so Kth number can not contain prefix \"10\" and we ignore those number\\ncount of \"10\" from K and K becomes 1. Now same digit next prefix of \"10\" is \"11\" and number count of \\nprefix \"11\" in range of 11 to 13 is 1 and as K =1, the Kth number must start with prefix \"11\" and we ignore\\nthe prefix \"11\" from K and K becomes 0 and the prefix is the result.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // count the numbers which are in range 1 to N with prefix \\n    int countPrefix(int n, long long prefix)\\n    {\\n        long long offset = 10;\\n        long long target = n;\\n        int total = 0;\\n        for(int i=1;i<=9;i++)\\n        {\\n            long long minv = prefix * offset;\\n            long long maxv = minv + offset-1;\\n            \\n            \\n            if(target < minv)break;\\n            \\n            total+= min(target,maxv) - minv + 1;\\n            \\n            offset = offset * 10;\\n        }\\n        \\n        return total+1;\\n    }\\n    \\n    int findKthNumber(int n, int k, int prefix =0) {\\n\\n        // if K > 0 we have to find the result otherwise current prefix is the solution\\n        if(k>0)\\n        {\\n            // go through next prefix from current prefix and check count of numbers with ith prefix\\n            // if K <= prefix_count then K lies in the current prefix range and so we ignore current prefix\\n            // and go to next digit prefix from current prefix and decrease K by 1 \\n            // otherwise we check prefix count for same digit next prefix number and ignore the previous\\n            // prefix count from K as K is out of the range of previous prefix number\\n            for(int i= (prefix==0)?1:0;i<=9;i++)\\n            {\\n                int prefixCount = countPrefix(n,10*prefix+i);\\n                if(k<=prefixCount) return findKthNumber(n,k-1,10*prefix+i);\\n                k-=prefixCount;\\n            }            \\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nWe have to find the Kth smallest number  in Lexicographical Order, we can use Trie DS and iterate over it\\nas numbers are lexicographically sorted in Trie but limit is 10^9 too high here and so it will give TLE.\\n\\nIn lexicographically sorted array lower MSB digit prefix numbers always comes first and so we can count\\nthe number of numbers with lower prefix and if count is less than K, then Kth number will contain in the\\nnumbers with lower prefix MSB digit range (1 to N) otherwise it will be in the next higher prefix number\\nwith same digit range. This way we can count numbers with prefix \"1\" and check with K, if K<= count then\\nMSB prefix is \"1\" and then we go to next digit MSB prefix \"10\" otherwise we check for MSB digit \"2\" and so on. \\nWhen K <= count we decrease K by 1 cause we already have the prefix number in which Kth value falls\\nand so we can ignore it. If K > count we go to MSB digit next prefix and so we can ignore previous prefix\\ncount from K. When K ==0 we will get our prefix value as result.\\n```\n```\\nFrom lexicographically sorted numbers 1 to 13 =>  [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]\\nwe see that first 5 numbers have prefix \"1\" and then the other numbers have their own sequential values.\\nHere if K = 3 then result = 11\\nFirst number count with prefix \"1\" in range 1 to 13 is 5 and K =3 means Kth number must start with \\nprefix \"1\". Now we got the first digit of our result number which is \"1\". We have to find the next digit\\nand we will take the next digit prefix of \"1\" which is \"10\". As we already know that 1 is the MSB digit of\\nresult we can ignore it from count K and so we decrement K and now K = 2. Number count with prefix \"10\"\\nin range 10 to 13 is 1 and K = 2 and so Kth number can not contain prefix \"10\" and we ignore those number\\ncount of \"10\" from K and K becomes 1. Now same digit next prefix of \"10\" is \"11\" and number count of \\nprefix \"11\" in range of 11 to 13 is 1 and as K =1, the Kth number must start with prefix \"11\" and we ignore\\nthe prefix \"11\" from K and K becomes 0 and the prefix is the result.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // count the numbers which are in range 1 to N with prefix \\n    int countPrefix(int n, long long prefix)\\n    {\\n        long long offset = 10;\\n        long long target = n;\\n        int total = 0;\\n        for(int i=1;i<=9;i++)\\n        {\\n            long long minv = prefix * offset;\\n            long long maxv = minv + offset-1;\\n            \\n            \\n            if(target < minv)break;\\n            \\n            total+= min(target,maxv) - minv + 1;\\n            \\n            offset = offset * 10;\\n        }\\n        \\n        return total+1;\\n    }\\n    \\n    int findKthNumber(int n, int k, int prefix =0) {\\n\\n        // if K > 0 we have to find the result otherwise current prefix is the solution\\n        if(k>0)\\n        {\\n            // go through next prefix from current prefix and check count of numbers with ith prefix\\n            // if K <= prefix_count then K lies in the current prefix range and so we ignore current prefix\\n            // and go to next digit prefix from current prefix and decrease K by 1 \\n            // otherwise we check prefix count for same digit next prefix number and ignore the previous\\n            // prefix count from K as K is out of the range of previous prefix number\\n            for(int i= (prefix==0)?1:0;i<=9;i++)\\n            {\\n                int prefixCount = countPrefix(n,10*prefix+i);\\n                if(k<=prefixCount) return findKthNumber(n,k-1,10*prefix+i);\\n                k-=prefixCount;\\n            }            \\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92261,
                "title": "digit-by-digit-java-solution",
                "content": "To start, let's denote the answer as `res`. Without much thinking, we know `res` will always be an integer in the range `[1, n]`, therefore it's possible to obtain its value **digit by digit**. To implement the idea, here are the two questions you may ask yourself:\\n1. Should we go from most significant digit (MSD) to least significant digit (LSD) or the other way around?\\n\\n2. What are the conditions for determining the value of each digit?\\n\\nFor the first question, since the numbers will be arranged in lexicographical order, which means they will be compared from MSD to LSD, going in the same direction will be a wise choice (Otherwise later comparisons may override prior ones).\\n\\nAs to the second one, we can proceed in a \"trial and error\" fashion since there are at most `10` choices (`0 - 9`) for each digit (note `MSD` cannot be `0`). Okay, which one should go first, `0` or `9`? Remember we were asked to get the `k-th` smallest integer, so obviously we'd like to try from `0` up to `9`.\\n\\nBut how exactly do we choose the value for each digit? The principle is simple: count the total number of integers that have the same prefix as the current value of `res`, yet no more than `n`. For example, if `res = 0`, we count all integers starting with `1` (such as `1`, `10`, `100`,...),  then with `2` (such as `2`, `20`, `200`...), then with `3`, ..., up to `9` (`note` if `res = 0`, the digit will be MSD so it cannot be `0`); If `res = 13`, we will count all integers starting with `130` such as `130`, `1300`, `13500`, ..., then with `131` like `131`, `1310`,..., up to `139` (and of course `1390`, ...). For a given `k`, if the total count starting with (`res * 10 + i`), where `0 <= i <= 9`, is no less than `k`, then the next digit of `res` will be set as `i`, i.e., `res = res * 10 + i`. Otherwise subtract that total number from `k` and continue with `i` increased by `1`. Eventually `k` will be reduced to `1` and the corresponding value of `res` will be the `k-th` smallest integer in the lexicographical order.\\n\\nAll right, it looks like we are almost there except for how to count the total number of integers with some given prefix. Here is a quick idea: let the prefix be `res` and initially we have a count of `0`. First add one digit to the end of `res` to form a new integer (the value of the digit can be `0 - 9`) and check if the maximum one (i.e. digit added with value `9`) is no more than `n`. If so, increase count by `10` and continue adding another digit to each of the newly-obtained integers above (from smallest to largest) like doing \"DFS\", until the integer value exceeds `n`. As you can see, for each digit added, the total count for that particular digit will be ten times as that of the previous one. One tricky case is for some digit it cannot take all values up to `9` as doing so would render the number greater than `n`. In such cases we only count values that make the number no more than `n`.\\n\\nLet's do an example: let `res = 13`, `n = 1350` and `count = 0`. Adding one digit to `res` and  check its maximum value `139 < 1350`, so `count = 10`. Then adding another digit and again check its maximum value `1399 > 1350` so now we only retain those valid counts which are from `1300` up to `1350` so `count = 10 + (1350 - 1300 + 1) = 61`. \\n\\nFinally here is the java program for this digit by digit solution:\\n```\\npublic int findKthNumber(int n, int k) {\\n    int res = 0;\\n    \\n    do {\\n    \\tres *= 10;\\n    \\tint i = (res == 0 ? 1 : 0);\\n    \\t\\n    \\tfor (int count; i < 10; i++) {\\n            long base = 1, max = (res + i + 1) * base - 1;\\n            for (count = 0; max <= n; base *= 10, max = (res + i + 1) * base - 1) count += base;\\n            if (n >= (res + i) * base) count += (n - (res + i) * base + 1);\\n            if (k <= count) break;\\n            k -= count;\\n        }\\n    \\t\\t\\n    \\tres += i;\\n    \\t\\t\\n    } while (k-- > 1);\\n    \\t\\n    return res;\\n}\\n```\\nSome explanation of the program:\\n1. res is the final result, which is initialized to 0. \\n2. At the beginning of the do-while loop,  we shift res one digit to the left so we can determine the value of its current LSD. Also if res is 0, we are up to find the MSD of the final result so the starting digit value will be 1 instead of 0.\\n3. We then count the total number of integers starting with (res + i) and determine the digit value i. Here base denotes how many digits have been shifted and max is the maximum value with that many digits shifted (with prefix, of course). After counting the normal cases we then double check the corner cases when some of the digit values do not yield valid counts.\\n4. We set the corresponding digit value of res and continue until k is 1.\\n\\nCorrect me if I was wrong: time complexity is (logn)^2, which can be analyzed as follows: let T(n) be the original problem. For each digit, the total counts for each value are roughly equal so T(n) will be reduced to T(n/10) in logn time, i.e., T(n) = T(n/10) + O(logn) and by Master's theorem we have T(n) = O((logn)^2).\\n\\nAdvanced perspective: all the numbers can be arranged into a denary tree. The sequence 1, 2, .., n will be the result of level order traversal while the sequence of lexicographical order will be preorder traversal. Of course naive simulation of preorder traversal will result  in either TLE or StackOverFlow. The right way is again to count the total number of nodes in the subtrees for each node and choose the proper subtree to continue. Since each subtree is a complete tree, it is possible to obtain its total nodes in time proportional to its height, which is logn time with n the total number of nodes. For more details you can refer to [pureklkl](https://discuss.leetcode.com/topic/64539/java-7ms-denary-trie-tree-solution-with-detailed-explanation)'s post.",
                "solutionTags": [],
                "code": "```\\npublic int findKthNumber(int n, int k) {\\n    int res = 0;\\n    \\n    do {\\n    \\tres *= 10;\\n    \\tint i = (res == 0 ? 1 : 0);\\n    \\t\\n    \\tfor (int count; i < 10; i++) {\\n            long base = 1, max = (res + i + 1) * base - 1;\\n            for (count = 0; max <= n; base *= 10, max = (res + i + 1) * base - 1) count += base;\\n            if (n >= (res + i) * base) count += (n - (res + i) * base + 1);\\n            if (k <= count) break;\\n            k -= count;\\n        }\\n    \\t\\t\\n    \\tres += i;\\n    \\t\\t\\n    } while (k-- > 1);\\n    \\t\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878041,
                "title": "java-denary-tree-0-ms-faster-than-100-00-35-6-mb-less-than-99-46",
                "content": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        long rank = 1;\\n        long cur = 1;\\n        while (rank < k) {\\n            long cnt = getCnt(cur, n);\\n            if (rank + cnt <= k) {\\n                ++cur;\\n                rank += cnt;\\n            } else {\\n                cur *= 10;\\n                ++rank;\\n            }\\n        }\\n        return (int) cur;\\n    }\\n\\n    private long getCnt(long prefix, long n) {\\n        long cnt = 0;\\n        for (long cur = prefix, next = cur + 1; cur <= n; cur *= 10, next *= 10) {\\n            cnt += Math.min(next, n + 1) - cur;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        long rank = 1;\\n        long cur = 1;\\n        while (rank < k) {\\n            long cnt = getCnt(cur, n);\\n            if (rank + cnt <= k) {\\n                ++cur;\\n                rank += cnt;\\n            } else {\\n                cur *= 10;\\n                ++rank;\\n            }\\n        }\\n        return (int) cur;\\n    }\\n\\n    private long getCnt(long prefix, long n) {\\n        long cnt = 0;\\n        for (long cur = prefix, next = cur + 1; cur <= n; cur *= 10, next *= 10) {\\n            cnt += Math.min(next, n + 1) - cur;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785296,
                "title": "readable-c-solution-with-clear-explanation",
                "content": "I thought it may be worthwhile to create a solution that is marginally less efficient in favor of greater readability. So here it is!\\n\\nExplanation:\\n- `findKthNumber()` performs binary search on each digit of `num` (from the most significant to the least significant) until finding `num` such that `rank(num, n)` is exactly `k`\\n- `rank(prefix, n)` computes 1 plus the number of integers in [1, n] lexicographically smaller than `prefix`\\n- `numPrefixes(prefix, n)` computes the number of integers in [1, n] having a given prefix and is a helper function used exclusively for computing `rank(prefix, n)`\\n\\nEfficiency-wise: actual runtime reported by leetcode is stil 0ms, so it\\'s about as efficient as all other accepted solutions so far.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    static int findKthNumber(int const n, int const k) {\\n        int num = 0, rank_of_num = 0, nxt = 0, rank_of_nxt = 0;\\n        while (rank_of_num != k) {\\n            int lower = num ? 0 : 1, upper = 9;\\n            while (lower < upper) {\\n                auto const mid = (lower + upper + 1) / 2;\\n                nxt = num * 10 + mid;\\n                rank_of_nxt = rank(nxt, n);\\n                if (rank_of_nxt > k) upper = mid - 1; else lower = mid;\\n            }\\n            num *= 10;\\n            num += lower;\\n\\t\\t\\t// optimization: avoid re-computing rank(num, n) if possible\\n            rank_of_num = (num == nxt ? rank_of_nxt : rank(num, n));\\n        }\\n        return num;\\n    }\\nprivate:\\n    static int rank(int const prefix, int const max_val) {\\n        int r = 1;\\n        int num_digits = 0;\\n\\t\\t// consider all possible numbers having prefix `p - d` that will be\\n\\t\\t// lexicographically smaller than `prefix`\\n        for (int p = prefix; p; p /= 10, ++num_digits)\\n            for (int d = 1; d <= p % 10; ++d)\\n                r += numPrefixes(p - d, max_val);\\n        r += num_digits - 1;\\n        return r;\\n    }\\n    static int numPrefixes(int const prefix, int const max_val) {\\n        if (0 == prefix) return 0;\\n        int cnt = 0;\\n        unsigned long long p = 1;\\n\\t\\t// This just sets p = pow(10, x) for each viable value of x and counts the number of\\n\\t\\t// integers within the range of [prefix * pow(10, x), (prefix + 1) * pow(10, x)) that\\n\\t\\t// also do not exceed `max_val`\\n        for (unsigned long long val = prefix; val <= max_val; p *= 10, val *= 10)\\n\\t\\t\\tcnt += min(p, max_val - val + 1);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static int findKthNumber(int const n, int const k) {\\n        int num = 0, rank_of_num = 0, nxt = 0, rank_of_nxt = 0;\\n        while (rank_of_num != k) {\\n            int lower = num ? 0 : 1, upper = 9;\\n            while (lower < upper) {\\n                auto const mid = (lower + upper + 1) / 2;\\n                nxt = num * 10 + mid;\\n                rank_of_nxt = rank(nxt, n);\\n                if (rank_of_nxt > k) upper = mid - 1; else lower = mid;\\n            }\\n            num *= 10;\\n            num += lower;\\n\\t\\t\\t// optimization: avoid re-computing rank(num, n) if possible\\n            rank_of_num = (num == nxt ? rank_of_nxt : rank(num, n));\\n        }\\n        return num;\\n    }\\nprivate:\\n    static int rank(int const prefix, int const max_val) {\\n        int r = 1;\\n        int num_digits = 0;\\n\\t\\t// consider all possible numbers having prefix `p - d` that will be\\n\\t\\t// lexicographically smaller than `prefix`\\n        for (int p = prefix; p; p /= 10, ++num_digits)\\n            for (int d = 1; d <= p % 10; ++d)\\n                r += numPrefixes(p - d, max_val);\\n        r += num_digits - 1;\\n        return r;\\n    }\\n    static int numPrefixes(int const prefix, int const max_val) {\\n        if (0 == prefix) return 0;\\n        int cnt = 0;\\n        unsigned long long p = 1;\\n\\t\\t// This just sets p = pow(10, x) for each viable value of x and counts the number of\\n\\t\\t// integers within the range of [prefix * pow(10, x), (prefix + 1) * pow(10, x)) that\\n\\t\\t// also do not exceed `max_val`\\n        for (unsigned long long val = prefix; val <= max_val; p *= 10, val *= 10)\\n\\t\\t\\tcnt += min(p, max_val - val + 1);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761325,
                "title": "python-100-speed-bincount-histogram-method-o-log-n-2",
                "content": "**Python | 100% Speed | BinCount Histogram Method | O( log(n)^2 )**\\n\\nThe Python code below corresponds to a highly efficient solution, which achieves a speed rating of 100% on LeetCode.\\n\\nHighlights:\\n\\n1. The code is inspired by the concept of \"BinCount\" Histograms, where we group numbers based on certain boundaries. However, instead of using a classical ranges, here we group number by their first leading digit.\\n\\n2. As we sweep numbers from 1 to \"n\", we can notice that the Histogram is filled by loops with packets of size=10^i. For example, the histogram is first filled by packets of size=1 resembling [1,2,3,4,5,6,7,8,9]. Then, numbers move forward into packets of size=10 [1x, 2x, 3x, etc.], and so on. The function \"bincount\" implements a very simple algorithm to emulate this process, and it runs with O( log n ) time complexity per call. The last \"packet\" before the fuction \"bincount\" stops might not be complete though, but this is very easy to handle.\\n\\n3. As a result, we can easily calculate the leading digit of a given number with index=k. The function \"binmatch\" implements a one-pass loop to find in which \"bin\" our target number falls. (For the very first digit, our BinCount uses the binranges [1-9], but for the subsequent digits we must use [0-9].)\\n\\n4. After finding a leading digit, we can pass the remainder of our \"BinCounts\" to further recursive calls, until we \"discover\" the full number. Since each digit is discovered with O( log n ) time complexity, and we must find O( log n ) digits, our total time complexity is O( log(n)^2 ).\\n\\nI hope the explanation was helpful. The code makes a lot of sense after looking at the results of Brute Force experiments (Appendix). \\n\\n**A) Main Code**\\n```\\nclass Solution:\\n    def binmatch(self,A,k):\\n        i,s = 0,0\\n        for i,x in enumerate(A):\\n            s += x\\n            if s>=k:\\n                s -= x\\n                break\\n        return i,s\\n    def bincount(self,n,r):\\n        A = [0]*r\\n        s = 1\\n        while n>0:\\n            for i in range(r):\\n                s     = min(n,s)\\n                A[i] += s\\n                n    -= s\\n                if n<=0:\\n                    break\\n            s *= 10\\n        return A  \\n    def remainder(self,t,c): # target, container size\\n        if t==1:\\n            return # t=1 is always Null Zero (1,10,100,etc..)\\n        t -= 1 # subtract Null Zero\\n        c -= 1\\n        A  = self.bincount(c,r=10)\\n        i,s = self.binmatch(A,t)\\n        yield i\\n\\t\\t# yield from self.remainder(t-s,A[i]) # only works in Python 3\\n        for j in self.remainder(t-s,A[i]): \\n            yield j\\n    def findKthNumber(self, n, k): #-> int:\\n        # Find first digit:\\n        A   = self.bincount(n,r=9)\\n        i,s = self.binmatch(A,k)\\n        res = i+1\\n        # Find Upcoming Digits\\n        for x in self.remainder(k-s,A[i]):\\n            res = 10*res + x\\n        return res\\n```\\n\\n**B) Appendix: Brute Force Visualizer**\\n```\\n# Python 2/3\\n#     This code is only to see how number organize themselves\\nn = 31\\nA = []\\nfor x in range(1,n+1):\\n    A.append(str(x))\\nA.sort()\\nfor b in A:\\n    print(b)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def binmatch(self,A,k):\\n        i,s = 0,0\\n        for i,x in enumerate(A):\\n            s += x\\n            if s>=k:\\n                s -= x\\n                break\\n        return i,s\\n    def bincount(self,n,r):\\n        A = [0]*r\\n        s = 1\\n        while n>0:\\n            for i in range(r):\\n                s     = min(n,s)\\n                A[i] += s\\n                n    -= s\\n                if n<=0:\\n                    break\\n            s *= 10\\n        return A  \\n    def remainder(self,t,c): # target, container size\\n        if t==1:\\n            return # t=1 is always Null Zero (1,10,100,etc..)\\n        t -= 1 # subtract Null Zero\\n        c -= 1\\n        A  = self.bincount(c,r=10)\\n        i,s = self.binmatch(A,t)\\n        yield i\\n\\t\\t# yield from self.remainder(t-s,A[i]) # only works in Python 3\\n        for j in self.remainder(t-s,A[i]): \\n            yield j\\n    def findKthNumber(self, n, k): #-> int:\\n        # Find first digit:\\n        A   = self.bincount(n,r=9)\\n        i,s = self.binmatch(A,k)\\n        res = i+1\\n        # Find Upcoming Digits\\n        for x in self.remainder(k-s,A[i]):\\n            res = 10*res + x\\n        return res\\n```\n```\\n# Python 2/3\\n#     This code is only to see how number organize themselves\\nn = 31\\nA = []\\nfor x in range(1,n+1):\\n    A.append(str(x))\\nA.sort()\\nfor b in A:\\n    print(b)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222264,
                "title": "short-python",
                "content": "```\\nclass Solution:\\n    def findKthNumber(self, n, k):\\n        curr = 1 \\n        while k > 1:\\n            s = 0 \\n            left = right = curr\\n            while left <= n:\\n                s += min(right, n) - left  +1\\n                left *= 10 \\n                right = right * 10 + 9\\n            if k > s:\\n                curr += 1\\n                k -= s \\n            else:\\n                curr = curr * 10  \\n                k -= 1 \\n        return curr \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n, k):\\n        curr = 1 \\n        while k > 1:\\n            s = 0 \\n            left = right = curr\\n            while left <= n:\\n                s += min(right, n) - left  +1\\n                left *= 10 \\n                right = right * 10 + 9\\n            if k > s:\\n                curr += 1\\n                k -= s \\n            else:\\n                curr = curr * 10  \\n                k -= 1 \\n        return curr \\n",
                "codeTag": "Java"
            },
            {
                "id": 3271866,
                "title": "440-space-96-85-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define a function named \"findKthNumber\" that takes in two parameters: \"n\" and \"k\". This function will return an integer, which is the kth lexicographically smallest integer in the range [1, n].\\n\\n2. Initialize a variable \"cur\" to 1. This variable will keep track of the current number being considered.\\n\\n3. Decrement \"k\" by 1, since the variable \"cur\" has already been initialized to 1.\\n\\n4. Start a while loop that will continue until k is equal to 0. This loop will be used to find the kth lexicographically smallest number.\\n\\n5. Within the while loop, call the function \"getSteps\" with three arguments: \"n\", \"cur\", and \"cur+1\". This function will return the number of steps required to go from \"cur\" to \"cur+1\" while staying within the range of [1, n].\\n\\n6. If the number of steps required to go from \"cur\" to \"cur+1\" is less than or equal to k, increment \"cur\" by 1 and decrement \"k\" by the number of steps required to go from \"cur\" to \"cur+1\".\\n\\n7. If the number of steps required to go from \"cur\" to \"cur+1\" is greater than k, multiply \"cur\" by 10 and decrement \"k\" by 1.\\n\\n8. Once the while loop has terminated, return \"cur\", which is the kth lexicographically smallest integer in the range [1, n].\\n\\n9. Define another function named \"getSteps\" that takes in three parameters: \"n\", \"n1\", and \"n2\". This function will return the number of steps required to go from \"n1\" to \"n2\" while staying within the range of [1, n].\\n\\n10. Initialize a variable \"steps\" to 0. This variable will keep track of the number of steps required to go from \"n1\" to \"n2\".\\n\\n11. Start a while loop that will continue until \"n1\" is greater than \"n\". This loop will be used to count the number of steps required to go from \"n1\" to \"n2\".\\n\\n12. Within the while loop, add the minimum value between \"n+1\" and \"n2\" to \"steps\" and subtract \"n1\" from \"n2\". This will give us the number of steps required to go from \"n1\" to \"n2\" while staying within the range of [1, n].\\n\\n13. Multiply \"n1\" and \"n2\" by 10 to get the next set of numbers to consider.\\n\\n14. Once the while loop has terminated, return \"steps\", which is the number of steps required to go from \"n1\" to \"n2\" while staying within the range of [1, n].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def findKthNumber(self, n: int, k: int) -> int:\\n    cur = 1\\n    k -= 1\\n    while k > 0:\\n        steps = self.getSteps(n, cur, cur+1)\\n        if steps <= k:\\n            cur += 1\\n            k -= steps\\n        else:\\n            cur *= 10\\n            k -= 1\\n            \\n    return cur\\n\\n  def getSteps(self, n: int, n1: int, n2: int) -> int:\\n    steps = 0\\n    while n1 <= n:\\n        steps += min(n+1, n2) - n1\\n        n1 *= 10\\n        n2 *= 10\\n    return steps\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n  def findKthNumber(self, n: int, k: int) -> int:\\n    cur = 1\\n    k -= 1\\n    while k > 0:\\n        steps = self.getSteps(n, cur, cur+1)\\n        if steps <= k:\\n            cur += 1\\n            k -= steps\\n        else:\\n            cur *= 10\\n            k -= 1\\n            \\n    return cur\\n\\n  def getSteps(self, n: int, n1: int, n2: int) -> int:\\n    steps = 0\\n    while n1 <= n:\\n        steps += min(n+1, n2) - n1\\n        n1 *= 10\\n        n2 *= 10\\n    return steps\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373002,
                "title": "k-th-smallest-in-lexicographical-order-solution-java",
                "content": "class Solution {\\n  public int findKthNumber(int n, int k) {\\n    long currNum = 1;\\n\\n    for (int i = 1; i < k;) {\\n      long gap = getGap(currNum, currNum + 1, n);\\n      if (i + gap <= k) {\\n        i += gap;\\n        ++currNum;\\n      } else {\\n        ++i;\\n        currNum *= 10;\\n      }\\n    }\\n\\n    return (int) currNum;\\n  }\\n\\n  private long getGap(long a, long b, long n) {\\n    long gap = 0;\\n    while (a <= n) {\\n      gap += Math.min(n + 1, b) - a;\\n      a *= 10;\\n      b *= 10;\\n    }\\n    return gap;\\n  }\\n}\\n",
                "solutionTags": [
                    "Trie"
                ],
                "code": "class Solution {\\n  public int findKthNumber(int n, int k) {\\n    long currNum = 1;\\n\\n    for (int i = 1; i < k;) {\\n      long gap = getGap(currNum, currNum + 1, n);\\n      if (i + gap <= k) {\\n        i += gap;\\n        ++currNum;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1608549,
                "title": "c-440-k-th-smallest-in-lexicographical-order",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        int x = 1; \\n        while (k > 1) {\\n            long cnt = 0; \\n            for (long diff = 1, curr = x; curr <= n; curr *= 10, diff *= 10) \\n                cnt += min(n - curr + 1, diff); \\n            if (k > cnt) k -= cnt, ++x; \\n            else --k, x *= 10; \\n        }\\n        return x; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        int x = 1; \\n        while (k > 1) {\\n            long cnt = 0; \\n            for (long diff = 1, curr = x; curr <= n; curr *= 10, diff *= 10) \\n                cnt += min(n - curr + 1, diff); \\n            if (k > cnt) k -= cnt, ++x; \\n            else --k, x *= 10; \\n        }\\n        return x; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466283,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int FindKthNumber(int n, int k) \\n    {\\n        return (int) FindKthNumber(1, n, k);\\n    }\\n    \\n    public long FindKthNumber(long start, long end, long k) \\n    {\\n        if(k == 1) return start;\\n        var count = NumberOfChildren(start, end);\\n        return  count < k ? FindKthNumber(start + 1, end, k - count) : FindKthNumber(start * 10, end, k - 1);\\n    }\\n    \\n    public long NumberOfChildren(long start, long end) \\n    {\\n        long childrenCount = 0, rightSibling = start + 1;\\n        while (start <= end) \\n        {\\n            childrenCount += Math.Min(end + 1, rightSibling) - start;\\n            start *= 10;\\n            rightSibling *= 10;\\n        }\\n        \\n        return childrenCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int FindKthNumber(int n, int k) \\n    {\\n        return (int) FindKthNumber(1, n, k);\\n    }\\n    \\n    public long FindKthNumber(long start, long end, long k) \\n    {\\n        if(k == 1) return start;\\n        var count = NumberOfChildren(start, end);\\n        return  count < k ? FindKthNumber(start + 1, end, k - count) : FindKthNumber(start * 10, end, k - 1);\\n    }\\n    \\n    public long NumberOfChildren(long start, long end) \\n    {\\n        long childrenCount = 0, rightSibling = start + 1;\\n        while (start <= end) \\n        {\\n            childrenCount += Math.Min(end + 1, rightSibling) - start;\\n            start *= 10;\\n            rightSibling *= 10;\\n        }\\n        \\n        return childrenCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92267,
                "title": "easy-to-understand-js-solution",
                "content": "```\\n// Calculates the amount of\\n// numbers <= n that starts with prefix.\\n\\nfunction countForPrefix (n, prefix) {\\n    let a = parseInt(prefix);\\n    let b = a + 1;\\n    if (a > n || a === 0)\\n        return 0;\\n\\n    let res = 1;\\n    a *= 10; b *= 10;\\n    while (a <= n) {\\n        res += Math.min(n + 1, b) - a;\\n        a *= 10; b *= 10;\\n    }\\n\\n    return res;\\n}\\n\\n// Constructs resulting number digit by digit\\n// starting with the most significant.\\n\\nfunction findKthNumber (n, k) {\\n    let i, prefix = '';\\n    while (k !== 0) {\\n        for (i = 0; i <= 9; i++) {\\n            const count = countForPrefix(n, prefix + i);\\n            if (count < k)\\n                k -= count;\\n            else\\n                break;\\n        }\\n        prefix = prefix + i;\\n        k--; // number equal to prefix\\n    }\\n\\n    return parseInt(prefix, 10);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Calculates the amount of\\n// numbers <= n that starts with prefix.\\n\\nfunction countForPrefix (n, prefix) {\\n    let a = parseInt(prefix);\\n    let b = a + 1;\\n    if (a > n || a === 0)\\n        return 0;\\n\\n    let res = 1;\\n    a *= 10; b *= 10;\\n    while (a <= n) {\\n        res += Math.min(n + 1, b) - a;\\n        a *= 10; b *= 10;\\n    }\\n\\n    return res;\\n}\\n\\n// Constructs resulting number digit by digit\\n// starting with the most significant.\\n\\nfunction findKthNumber (n, k) {\\n    let i, prefix = '';\\n    while (k !== 0) {\\n        for (i = 0; i <= 9; i++) {\\n            const count = countForPrefix(n, prefix + i);\\n            if (count < k)\\n                k -= count;\\n            else\\n                break;\\n        }\\n        prefix = prefix + i;\\n        k--; // number equal to prefix\\n    }\\n\\n    return parseInt(prefix, 10);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3040048,
                "title": "100-faster-c-comments-explained-intuition-tc-sc",
                "content": "# Intuition\\nThe intuition behind this approach is to take advantage of the lexicographical order of the numbers to efficiently find the kth lexicographically smallest integer.\\n\\n# Approach\\nThe algorithm starts by initializing the current number curr to 1 and decrementing k by 1, since it is counting from 0.\\n\\nIt then enters a while loop that continues until k becomes 0. In each iteration of the loop, the code calls the helper function calSteps(int n, long n1, long n2) to calculate the number of nodes in the next level.\\n\\nThe helper function calSteps uses a while loop to iterate through all the levels and it uses two variable n1 and n2. n1 is the current number and n2 is the next number. It checks how many numbers are there between n1 and n2. It first check for the case where n1 is less than n, if true it adds the difference to the count, otherwise it adds n-n1+1 to count. This way it can calculate how many numbers are there in the next level and it returns this count.\\n\\nThen in the main function it compares the number of nodes in the next level with k, if the number of nodes is greater than k, it means that the kth number is in the next level, so it goes to the next level by incrementing the current number and subtracting the number of nodes from k.\\n\\nOtherwise, if the number of nodes is less than k, it means that the kth number is a sibling of the current node. So it goes to the next sibling node by multiplying the current number by 10 and subtracting the number of nodes in the next level from k.\\n\\nIt\\'s like a process of elimination, every time we go to a level we check if the number of nodes in the level is greater than k or not, if it\\'s greater we know that kth number is in that level and we update k and move to next level, if it\\'s not we know that kth number is a sibling and we move to the next sibling node and update k.\\n\\nAt the end of the loop, curr is returned as the kth lexicographically smallest integer\\n\\nIn this approach, the algorithm is able to efficiently find the kth lexicographically smallest integer by taking advantage of the lexicographical order of the numbers, and by only considering the numbers that could potentially be the kth lexicographically smallest number.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(log(n) * log(n)) . The outer while loop iterates log(n) times, and in each iteration, the helper function calSteps is called which also iterates log(n) times, giving a total of log(n) * log(n) iterations.\\n\\n- Space complexity:\\nThe space complexity of this approach is O(1) since it uses only a constant amount of additional memory to store the variables curr, k and steps\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int calSteps(int n, long n1, long n2) {\\n    int steps = 0;\\n    // Continue counting the number of nodes while n1 <= n\\n    while (n1 <= n) {\\n        // Add the minimum of (n + 1) and n2 to steps\\n        steps += min((long)n + 1, n2) - n1;\\n        n1 *= 10;\\n        n2 *= 10;\\n    }\\n    return steps;\\n}\\n   int findKthNumber(int n, int k) {\\n                // Initialize the current number as 1\\n        int curr = 1;\\n        // Decrement k by 1, since we\\'re counting from 0\\n        k--;\\n        while (k > 0) {\\n            // Calculate the number of nodes in the next level\\n            int steps = calSteps(n, curr, curr + 1);\\n            // If the number of nodes is greater than k, go to the next level\\n            if (steps <= k) {\\n                curr += 1;\\n                k -= steps;\\n            } \\n            // If the number of nodes is less than k, go to the next sibling\\n            else {\\n                curr *= 10;\\n                k--;\\n            }\\n        }\\n        // Return the kth lexicographically smallest integer\\n        return curr;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int calSteps(int n, long n1, long n2) {\\n    int steps = 0;\\n    // Continue counting the number of nodes while n1 <= n\\n    while (n1 <= n) {\\n        // Add the minimum of (n + 1) and n2 to steps\\n        steps += min((long)n + 1, n2) - n1;\\n        n1 *= 10;\\n        n2 *= 10;\\n    }\\n    return steps;\\n}\\n   int findKthNumber(int n, int k) {\\n                // Initialize the current number as 1\\n        int curr = 1;\\n        // Decrement k by 1, since we\\'re counting from 0\\n        k--;\\n        while (k > 0) {\\n            // Calculate the number of nodes in the next level\\n            int steps = calSteps(n, curr, curr + 1);\\n            // If the number of nodes is greater than k, go to the next level\\n            if (steps <= k) {\\n                curr += 1;\\n                k -= steps;\\n            } \\n            // If the number of nodes is less than k, go to the next sibling\\n            else {\\n                curr *= 10;\\n                k--;\\n            }\\n        }\\n        // Return the kth lexicographically smallest integer\\n        return curr;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798610,
                "title": "python-24ms-100-denary-solution-fully-documented",
                "content": "Core idea: \\n- go right or go down in a denary tree (maintaining \\'cur\\' number and remain \\'k-th\\')\\n- find \\'cur\\' when \\'k\\' is cutted down to 0\\n\\n```python\\nclass Solution:\\n    def findKthNumber(self, n, k):\\n        if k == 1: return 1\\n        return self.denary(n, k)\\n\\n    def denary(self, n, k):\\n        cur = 1  # cur starting from 1\\n        k -= 1  # k-th shift to 0-indexed\\n\\n        while k > 0:  # final goal : find cur when k is cutted down to 0\\n            counts = self.counts_lte(n, cur)\\n\\n            if counts <= k:  # final answer is not under current number, go right!\\n                k, cur = k - counts, cur + 1\\n            else:  # answer is under current number prefix, go in down~\\n                k, cur = k - 1, cur * 10\\n\\n        return cur  # at this moment, k is zero, the final prefix cur is what we want\\n\\n    def counts_lte(self, n, num):  # counts less or equal than num\\n        counts, limit = 0, num + 1\\n\\n        while num <= n:  # sum total counts layer by layer untill num is greater than n\\n            counts += min(n + 1, limit) - num  # notice: n is another limit boundary when calculating counts\\n            num, limit = num * 10, limit * 10  # next layer\\n\\n        return counts\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def findKthNumber(self, n, k):\\n        if k == 1: return 1\\n        return self.denary(n, k)\\n\\n    def denary(self, n, k):\\n        cur = 1  # cur starting from 1\\n        k -= 1  # k-th shift to 0-indexed\\n\\n        while k > 0:  # final goal : find cur when k is cutted down to 0\\n            counts = self.counts_lte(n, cur)\\n\\n            if counts <= k:  # final answer is not under current number, go right!\\n                k, cur = k - counts, cur + 1\\n            else:  # answer is under current number prefix, go in down~\\n                k, cur = k - 1, cur * 10\\n\\n        return cur  # at this moment, k is zero, the final prefix cur is what we want\\n\\n    def counts_lte(self, n, num):  # counts less or equal than num\\n        counts, limit = 0, num + 1\\n\\n        while num <= n:  # sum total counts layer by layer untill num is greater than n\\n            counts += min(n + 1, limit) - num  # notice: n is another limit boundary when calculating counts\\n            num, limit = num * 10, limit * 10  # next layer\\n\\n        return counts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761794,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int findKthNumber(int n, int k)\\n    {\\n        int result = 1;\\n        for(--k; k > 0; )\\n        {            int count = 0;\\n            for (long long first = static_cast<long long>(result), last = first + 1;\\n                first <= n; \\n                first *= 10, last *= 10) \\n            {\\n                count += static_cast<int>((min(n + 1LL, last) - first)); \\n            }\\n            \\n            if (k >= count)\\n            {   \\n                ++result;\\n                k -= count;\\n            }\\n            else\\n            {   \\n                result *= 10;\\n                --k;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int findKthNumber(int n, int k)\\n    {\\n        int result = 1;\\n        for(--k; k > 0; )\\n        {            int count = 0;\\n            for (long long first = static_cast<long long>(result), last = first + 1;\\n                first <= n; \\n                first *= 10, last *= 10) \\n            {\\n                count += static_cast<int>((min(n + 1LL, last) - first)); \\n            }\\n            \\n            if (k >= count)\\n            {   \\n                ++result;\\n                k -= count;\\n            }\\n            else\\n            {   \\n                result *= 10;\\n                --k;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174699,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        \\n        int x = 1; \\n        \\n        while (k > 1) \\n        {\\n            \\n            long count = 0; \\n            \\n            for (long diff =1, cur=x; cur<=n; cur*= 10, diff*=10)\\n            {\\n                count += min(n - cur + 1, diff);\\n                \\n            }\\n            \\n            if (k > count)   \\n            {\\n                k = k - count;\\n                \\n                x++; \\n             \\n            }\\n            else\\n            {\\n                k--;\\n                \\n                x *= 10; \\n                \\n            }\\n            \\n        }\\n        \\n        return x; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        \\n        int x = 1; \\n        \\n        while (k > 1) \\n        {\\n            \\n            long count = 0; \\n            \\n            for (long diff =1, cur=x; cur<=n; cur*= 10, diff*=10)\\n            {\\n                count += min(n - cur + 1, diff);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2063969,
                "title": "correct-code-using-trie-in-c-but-gives-tle",
                "content": "```\\nclass Node {\\n    private:\\n    Node* links[10];\\n    bool flag = false;\\n    public:\\n    bool containsKey(int digit) {\\n        return links[digit] != nullptr;\\n    }\\n    void put(int digit, Node* node) {\\n        links[digit] = node;\\n    }\\n    Node* get(int digit) {\\n        return links[digit];\\n    }\\n    bool isEnd() {\\n        return flag;\\n    }\\n    void setEnd() {\\n        flag = true;\\n    }\\n};\\n\\nclass Trie {\\n    private:\\n    Node* root;\\n    public:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        string str = to_string(num);\\n        Node* node = root;\\n        for(int i=0; i<str.length(); i++) {\\n            int digit = str[i] - \\'0\\';\\n            if(!node->containsKey(digit)) {\\n                node->put(digit, new Node());\\n            }\\n            node = node->get(digit);\\n        }\\n        node->setEnd();\\n        // stack<int> st;\\n        // while(num) {\\n        //     st.push(num%10);\\n        //     num /= 10;\\n        // }\\n        // Node* node = root;\\n        // while(!st.empty()) {\\n        //     int digit = st.top();\\n        //     st.pop();\\n        //     if(!node->containsKey(digit)) {\\n        //         node->put(digit, new Node());\\n        //     }\\n        //     node = node->get(digit);\\n        // }\\n        // node->setEnd();\\n    }\\n    int kthELE(int k) {\\n        int ans = 0;\\n        dfs(root, ans, k, 0);\\n        return ans;\\n    }\\n    void dfs(Node* root, int &ans, int &k, int num) {\\n        if(k == 0) return;\\n        if(root->isEnd()) {\\n            ans = num;\\n            k--;\\n        }\\n        for(int i=0; i<=9; i++) {\\n            if(root->containsKey(i)) {\\n                dfs(root->get(i), ans, k, num*10+i);\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        Trie trie;\\n        for(int i=1; i<=n; i++) trie.insert(i);\\n        return trie.kthELE(k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Node {\\n    private:\\n    Node* links[10];\\n    bool flag = false;\\n    public:\\n    bool containsKey(int digit) {\\n        return links[digit] != nullptr;\\n    }\\n    void put(int digit, Node* node) {\\n        links[digit] = node;\\n    }\\n    Node* get(int digit) {\\n        return links[digit];\\n    }\\n    bool isEnd() {\\n        return flag;\\n    }\\n    void setEnd() {\\n        flag = true;\\n    }\\n};\\n\\nclass Trie {\\n    private:\\n    Node* root;\\n    public:\\n    Trie() {\\n        root = new Node();\\n    }\\n    void insert(int num) {\\n        string str = to_string(num);\\n        Node* node = root;\\n        for(int i=0; i<str.length(); i++) {\\n            int digit = str[i] - \\'0\\';\\n            if(!node->containsKey(digit)) {\\n                node->put(digit, new Node());\\n            }\\n            node = node->get(digit);\\n        }\\n        node->setEnd();\\n        // stack<int> st;\\n        // while(num) {\\n        //     st.push(num%10);\\n        //     num /= 10;\\n        // }\\n        // Node* node = root;\\n        // while(!st.empty()) {\\n        //     int digit = st.top();\\n        //     st.pop();\\n        //     if(!node->containsKey(digit)) {\\n        //         node->put(digit, new Node());\\n        //     }\\n        //     node = node->get(digit);\\n        // }\\n        // node->setEnd();\\n    }\\n    int kthELE(int k) {\\n        int ans = 0;\\n        dfs(root, ans, k, 0);\\n        return ans;\\n    }\\n    void dfs(Node* root, int &ans, int &k, int num) {\\n        if(k == 0) return;\\n        if(root->isEnd()) {\\n            ans = num;\\n            k--;\\n        }\\n        for(int i=0; i<=9; i++) {\\n            if(root->containsKey(i)) {\\n                dfs(root->get(i), ans, k, num*10+i);\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        Trie trie;\\n        for(int i=1; i<=n; i++) trie.insert(i);\\n        return trie.kthELE(k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008831,
                "title": "a-javascript-solution",
                "content": "```\\nvar findKthNumber = function (n, k) {\\n    function dfs (l, r) {\\n        let nn = BigInt(n);\\n        \\n        if (l > nn) {\\n            return 0n;\\n        }\\n        \\n        if (r > nn) {\\n            r = nn;\\n        }\\n        \\n        return r - l + 1n + dfs(l * 10n, r * 10n + 9n);\\n    }\\n    \\n    let kn = BigInt(--k), cu = 1;\\n    \\n    while (kn > 0) {\\n        let cs = dfs(BigInt(cu), BigInt(cu));\\n        \\n        if (cs <= kn) {\\n            kn -= cs;\\n            cu++;\\n        }\\n        else {\\n            kn -= 1n;\\n            cu *= 10;\\n        }\\n    }\\n    \\n    return cu;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findKthNumber = function (n, k) {\\n    function dfs (l, r) {\\n        let nn = BigInt(n);\\n        \\n        if (l > nn) {\\n            return 0n;\\n        }\\n        \\n        if (r > nn) {\\n            r = nn;\\n        }\\n        \\n        return r - l + 1n + dfs(l * 10n, r * 10n + 9n);\\n    }\\n    \\n    let kn = BigInt(--k), cu = 1;\\n    \\n    while (kn > 0) {\\n        let cs = dfs(BigInt(cu), BigInt(cu));\\n        \\n        if (cs <= kn) {\\n            kn -= cs;\\n            cu++;\\n        }\\n        else {\\n            kn -= 1n;\\n            cu *= 10;\\n        }\\n    }\\n    \\n    return cu;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1700616,
                "title": "c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    long long get_count(long long prefix, long long n){\\n        long long upper=prefix+1, cnt=0;\\n        while(prefix<=n){\\n            cnt += min(n+1,upper)-prefix;\\n            prefix*=10;\\n            upper*=10;\\n        }\\n        return cnt;\\n    }\\n\\n    int findKthNumber(int n, int k) {\\n        int prefix=1, cnt=1;\\n        while(cnt<k){\\n            int tmpcnt=get_count(prefix,n);\\n            if(tmpcnt+cnt<=k){\\n                prefix++;\\n                cnt+=tmpcnt;\\n            }else{\\n                prefix*=10;\\n                cnt++;\\n            }\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long get_count(long long prefix, long long n){\\n        long long upper=prefix+1, cnt=0;\\n        while(prefix<=n){\\n            cnt += min(n+1,upper)-prefix;\\n            prefix*=10;\\n            upper*=10;\\n        }\\n        return cnt;\\n    }\\n\\n    int findKthNumber(int n, int k) {\\n        int prefix=1, cnt=1;\\n        while(cnt<k){\\n            int tmpcnt=get_count(prefix,n);\\n            if(tmpcnt+cnt<=k){\\n                prefix++;\\n                cnt+=tmpcnt;\\n            }else{\\n                prefix*=10;\\n                cnt++;\\n            }\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658185,
                "title": "getting-tle-using-trie-help",
                "content": "```\\nstruct Node\\n{\\n    Node* arr[10];\\n    int value=-1;\\n    \\n    bool contains(char c)\\n    {\\n        return arr[c-\\'0\\']!=NULL;\\n    }\\n    \\n    Node* getnext(char c)\\n    {\\n        return arr[c-\\'0\\'];\\n    }\\n    \\n    void put(char c,Node* newnode)\\n    {\\n        arr[c-\\'0\\']=newnode;\\n    }\\n    \\n    void setValue(int number)\\n    {\\n        value=number;\\n    }\\n};\\n\\nclass TRIE\\n{\\n    private:\\n        Node* root=new Node();\\n    \\n    public:\\n        \\n        void insert(string s,int value)\\n        {\\n            int n=s.size();\\n            Node* temp=root;\\n            for(int i=0;i<n;++i)\\n            {\\n                if(!temp->contains(s[i]))\\n                {\\n                    Node* newnode=new Node();\\n                    temp->put(s[i],newnode);\\n                }\\n                temp=temp->getnext(s[i]);\\n            }\\n            temp->setValue(value); \\n        }\\n    \\n        bool dfs(int& k,Node* root,int& ans)\\n        {\\n            \\n            if(root->value!=-1)\\n            {\\n                k--;\\n                if(k==0)\\n                {\\n                    ans=root->value;\\n                    return 1;\\n                }\\n            }\\n    \\n            for(char c=\\'0\\';c<=\\'9\\';++c)\\n            {\\n                if(root->contains(c))\\n                {\\n                    if(dfs(k,root->getnext(c),ans))\\n                        return 1;\\n                }\\n            }\\n            return 0;\\n            \\n        }\\n    \\n        int search(int k)\\n        {\\n            Node* temp=root;\\n            int ans=0;\\n            dfs(k,temp,ans);\\n            return ans;    \\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        \\n        TRIE trie;\\n        if(k>n)\\n            return -1;\\n        \\n        for(int i=1;i<=n;++i)\\n            trie.insert(to_string(i),i);\\n        \\n        return trie.search(k);\\n    \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Node\\n{\\n    Node* arr[10];\\n    int value=-1;\\n    \\n    bool contains(char c)\\n    {\\n        return arr[c-\\'0\\']!=NULL;\\n    }\\n    \\n    Node* getnext(char c)\\n    {\\n        return arr[c-\\'0\\'];\\n    }\\n    \\n    void put(char c,Node* newnode)\\n    {\\n        arr[c-\\'0\\']=newnode;\\n    }\\n    \\n    void setValue(int number)\\n    {\\n        value=number;\\n    }\\n};\\n\\nclass TRIE\\n{\\n    private:\\n        Node* root=new Node();\\n    \\n    public:\\n        \\n        void insert(string s,int value)\\n        {\\n            int n=s.size();\\n            Node* temp=root;\\n            for(int i=0;i<n;++i)\\n            {\\n                if(!temp->contains(s[i]))\\n                {\\n                    Node* newnode=new Node();\\n                    temp->put(s[i],newnode);\\n                }\\n                temp=temp->getnext(s[i]);\\n            }\\n            temp->setValue(value); \\n        }\\n    \\n        bool dfs(int& k,Node* root,int& ans)\\n        {\\n            \\n            if(root->value!=-1)\\n            {\\n                k--;\\n                if(k==0)\\n                {\\n                    ans=root->value;\\n                    return 1;\\n                }\\n            }\\n    \\n            for(char c=\\'0\\';c<=\\'9\\';++c)\\n            {\\n                if(root->contains(c))\\n                {\\n                    if(dfs(k,root->getnext(c),ans))\\n                        return 1;\\n                }\\n            }\\n            return 0;\\n            \\n        }\\n    \\n        int search(int k)\\n        {\\n            Node* temp=root;\\n            int ans=0;\\n            dfs(k,temp,ans);\\n            return ans;    \\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        \\n        TRIE trie;\\n        if(k>n)\\n            return -1;\\n        \\n        for(int i=1;i<=n;++i)\\n            trie.insert(to_string(i),i);\\n        \\n        return trie.search(k);\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491353,
                "title": "solution-beating-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        string s = to_string(n);\\n        bool flag1=false;\\n        bool flag2=false;\\n        \\n        vector<int> tens;\\n        tens.push_back(1);\\n        for(int i=1;i<s.length();i++)\\n            tens.push_back(tens.back()+pow(10,i));\\n        \\n        string ans;\\n        int start=1;\\n        int ptr = 0;\\n        while(k>0 && ptr<s.length()){\\n            // try the character to be put next!\\n            int cr = -1;\\n            int ref = s[ptr]-\\'0\\';\\n            int left = s.length()-(ptr+1);\\n            // left will always be greater than or equal to 0!\\n            for(int i=start;i<10;i++){\\n                // How many characters with prefix (ans + i) less than n!\\n                cr = i;\\n                int take=0;\\n                if(flag1){\\n                    // ans is lexicographically smaller than prefix(n). In this case, we can always extend till full length\\n                    take = tens[left];\\n                }\\n                else if(flag2){\\n                    // ans is lexicographically larger than prefix(n). In this case, we cannot extend to full length, as the result will be greater then n\\n                    take = (left>0)?tens[left-1]:0;\\n                }\\n                else{\\n                    // ans is equal to a prefix of n. \\n                    // 3 CASES. \\n                    if(i<ref){\\n                        // What if the next character is less than s[i], string can be extended till the end!\\n                        take = tens[left];\\n                    }\\n                    else if(i == ref){\\n                        // What if equal, string can be extended till the end but for full length strings we can only allow numbers less than n\\n                        take = (left>0)?tens[left-1]:0;\\n                        take += (n%(int)pow(10,left))+1;\\n                    }\\n                    else{\\n                        // What if greater, string cannot be extended till full length!\\n                        take = (left>0)?tens[left-1]:0;\\n                    }\\n                }\\n                // cout << ptr << \" \" << i << \" \" << take << \"\\\\n\";\\n                if(k-take>0){\\n                    k-=take;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ans.push_back(cr+\\'0\\');\\n            k--;\\n            // cr is the current value in ans -  Set flags if necessary!\\n            if(!flag1 && !flag2){\\n                if(cr < ref){\\n                    flag1 = true;\\n                }\\n                else if(cr > ref){\\n                    flag2 = true;\\n                }\\n            }\\n            start = 0;\\n            ptr++;\\n        }\\n        // cout << ans << \"\\\\n\";\\n        return stoi(ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        string s = to_string(n);\\n        bool flag1=false;\\n        bool flag2=false;\\n        \\n        vector<int> tens;\\n        tens.push_back(1);\\n        for(int i=1;i<s.length();i++)\\n            tens.push_back(tens.back()+pow(10,i));\\n        \\n        string ans;\\n        int start=1;\\n        int ptr = 0;\\n        while(k>0 && ptr<s.length()){\\n            // try the character to be put next!\\n            int cr = -1;\\n            int ref = s[ptr]-\\'0\\';\\n            int left = s.length()-(ptr+1);\\n            // left will always be greater than or equal to 0!\\n            for(int i=start;i<10;i++){\\n                // How many characters with prefix (ans + i) less than n!\\n                cr = i;\\n                int take=0;\\n                if(flag1){\\n                    // ans is lexicographically smaller than prefix(n). In this case, we can always extend till full length\\n                    take = tens[left];\\n                }\\n                else if(flag2){\\n                    // ans is lexicographically larger than prefix(n). In this case, we cannot extend to full length, as the result will be greater then n\\n                    take = (left>0)?tens[left-1]:0;\\n                }\\n                else{\\n                    // ans is equal to a prefix of n. \\n                    // 3 CASES. \\n                    if(i<ref){\\n                        // What if the next character is less than s[i], string can be extended till the end!\\n                        take = tens[left];\\n                    }\\n                    else if(i == ref){\\n                        // What if equal, string can be extended till the end but for full length strings we can only allow numbers less than n\\n                        take = (left>0)?tens[left-1]:0;\\n                        take += (n%(int)pow(10,left))+1;\\n                    }\\n                    else{\\n                        // What if greater, string cannot be extended till full length!\\n                        take = (left>0)?tens[left-1]:0;\\n                    }\\n                }\\n                // cout << ptr << \" \" << i << \" \" << take << \"\\\\n\";\\n                if(k-take>0){\\n                    k-=take;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ans.push_back(cr+\\'0\\');\\n            k--;\\n            // cr is the current value in ans -  Set flags if necessary!\\n            if(!flag1 && !flag2){\\n                if(cr < ref){\\n                    flag1 = true;\\n                }\\n                else if(cr > ref){\\n                    flag2 = true;\\n                }\\n            }\\n            start = 0;\\n            ptr++;\\n        }\\n        // cout << ans << \"\\\\n\";\\n        return stoi(ans);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 770352,
                "title": "100-faster-easy-java-solution-with-detail-explnation",
                "content": "method countSteps count the number of the integers whoes order small than k between the integer curr and curr + 1 generated in lexicographically order\\n\\ni.e \\ncurr = 1 and curr + 1 = 2\\nthe lexicographical order between 1 and 2 is [1, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20], totall number 1 + right\\\\*10 - left\\\\*10\\n\\nwhen n = 13 remove all the interger bigger than 13, we get [1, 10, 12, 13]  totall number 1 + min(n+1, right)-left = 4\\nso the the number of the integers whoes order small than k between 1 and 2 is 4, denote as steps\\n\\nif 4 smaller than k, it tell that the integer bigger than all the interger in [1, 10, 12, 13]\\nk = k - 4\\ncur = cur + 1\\nrepeat above process to get steps between in the 2 and 3\\n\\nif we k < steps, then the k-th smallest integer locate in the last steps between this steps\\ncur = cur * 10\\nk = k - 1\\nrepeat until k = 0\\nthen we find the the k-th smallest integer\\n\\n\\n```\\nclass Solution {\\n    \\n    private int countSteps(long left, long right, int n) {\\n        int res = 0;\\n        while(left <= n || right <= n) {\\n            res += Math.min(n+1, right) - left;\\n            left *= 10;\\n            right *= 10;\\n        }\\n        return res;\\n    }\\n    public int findKthNumber(int n, int k) {\\n        if(k == 0) return 0;\\n        int curr = 1;\\n        k--;\\n        while(k > 0) {\\n            int steps = countSteps(curr, curr+1, n);\\n            if(steps <= k) {\\n                curr++;\\n                k -= steps;\\n            } else {\\n                curr *= 10;\\n                k--;\\n            }\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int countSteps(long left, long right, int n) {\\n        int res = 0;\\n        while(left <= n || right <= n) {\\n            res += Math.min(n+1, right) - left;\\n            left *= 10;\\n            right *= 10;\\n        }\\n        return res;\\n    }\\n    public int findKthNumber(int n, int k) {\\n        if(k == 0) return 0;\\n        int curr = 1;\\n        k--;\\n        while(k > 0) {\\n            int steps = countSteps(curr, curr+1, n);\\n            if(steps <= k) {\\n                curr++;\\n                k -= steps;\\n            } else {\\n                curr *= 10;\\n                k--;\\n            }\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601198,
                "title": "golang-tree-nodes-gap-finding-solution-0ms-1-9mb",
                "content": "```go\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\nfunc findGap(a, b, n int) int {\\n    gap := 0 \\n    for (a <= n) {\\n        // n+1 => count node x0 too, which the gap includes it when n+1 is min\\n\\t\\t// otherwise b is the min\\n        gap = gap + min(n+1, b) - a\\n        a = a * 10\\n        b = b * 10\\n    }\\n    \\n    return gap\\n}\\nfunc findKthNumber(n int, k int) int {\\n    current := 1\\n    k = k - 1 // target index is k-1\\n    \\n    for k > 0 { // break when reaching target index, where k == 0\\n        gap := findGap(current, current+1, n)\\n        \\n        // k completely cover the gap, move forward. \\n        // if gap == k, loop will break next round since k == 0\\n        if gap <= k { \\n            k = k - gap \\n            current = current + 1 \\n        } else {\\n            // move one step down the tree\\n            k--\\n            current = current * 10\\n        }\\n    }\\n    \\n    return current\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Math",
                    "Tree"
                ],
                "code": "```go\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\nfunc findGap(a, b, n int) int {\\n    gap := 0 \\n    for (a <= n) {\\n        // n+1 => count node x0 too, which the gap includes it when n+1 is min\\n\\t\\t// otherwise b is the min\\n        gap = gap + min(n+1, b) - a\\n        a = a * 10\\n        b = b * 10\\n    }\\n    \\n    return gap\\n}\\nfunc findKthNumber(n int, k int) int {\\n    current := 1\\n    k = k - 1 // target index is k-1\\n    \\n    for k > 0 { // break when reaching target index, where k == 0\\n        gap := findGap(current, current+1, n)\\n        \\n        // k completely cover the gap, move forward. \\n        // if gap == k, loop will break next round since k == 0\\n        if gap <= k { \\n            k = k - gap \\n            current = current + 1 \\n        } else {\\n            // move one step down the tree\\n            k--\\n            current = current * 10\\n        }\\n    }\\n    \\n    return current\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571825,
                "title": "python-dfs-solution-20ms-98ish-runtime-100-space",
                "content": "```\\nclass Solution:\\n    @staticmethod\\n    def _count_nodes(root: int, n: int) -> int:\\n        \\n        count = 0\\n        next_node = root + 1\\n        \\n        while root <= n:\\n            count += min(next_node, n + 1) - root\\n            root *= 10\\n            next_node *= 10\\n        \\n        return count\\n    \\n    @staticmethod\\n    def _dfs(root: int, n: int, k: int) -> int:\\n        \\n        if k == 0:\\n            return root\\n        \\n        count = Solution._count_nodes(root, n)\\n        \\n        if count > k:\\n            return Solution._dfs(10 * root, n, k - 1)\\n        else:\\n            return Solution._dfs(root + 1, n, k - count)\\n        \\n    \\n    def findKthNumber(self, n: int, k: int) -> int:\\n        return self._dfs(1, n, k - 1)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    @staticmethod\\n    def _count_nodes(root: int, n: int) -> int:\\n        \\n        count = 0\\n        next_node = root + 1\\n        \\n        while root <= n:\\n            count += min(next_node, n + 1) - root\\n            root *= 10\\n            next_node *= 10\\n        \\n        return count\\n    \\n    @staticmethod\\n    def _dfs(root: int, n: int, k: int) -> int:\\n        \\n        if k == 0:\\n            return root\\n        \\n        count = Solution._count_nodes(root, n)\\n        \\n        if count > k:\\n            return Solution._dfs(10 * root, n, k - 1)\\n        else:\\n            return Solution._dfs(root + 1, n, k - count)\\n        \\n    \\n    def findKthNumber(self, n: int, k: int) -> int:\\n        return self._dfs(1, n, k - 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503399,
                "title": "c-solution",
                "content": "#include <math.h>    \\n\\nint fullCount[] = {1,11,111,1111,11111,111111,1111111,11111111,111111111};\\nint tens[] = {1, 10, 100, 1000, 10000,100000,1000000,10000000,100000000,1000000000};\\ndouble logN;\\n\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        logN = log10(n);\\n       return find(n , k, 0);\\n    }\\n    \\n    int find(const int n , int delta, const int pre) {\\n       \\n        for(int i = 0; i <= 9; i++) {\\n                int now = pre + i;\\n            if(now == 0) continue;\\n            if(delta == 1) return now;\\n         int count =countStartWith(n, now);\\n            // cout<< now<<\" \"<<count<<\" \"<<delta<<endl;\\n            if(delta <= count) {\\n                return find (n , delta - 1, (now) * 10);\\n            }\\n            \\n            delta -= count;\\n        }\\n      return -1;\\n    }\\n    \\n    int countStartWith(const int n, long pre) {\\n        int low = logN - log10(pre);\\n        if(low < 0) {\\n            return 0;\\n        }\\n        else if(low == 0) {\\n            return 1;\\n        }\\n        \\n        int high = logN - log10(pre + 1);\\n        \\n        if(low == high) {\\n            return fullCount[low];\\n        }\\n        else {\\n            return n % tens[low] + fullCount[low -1 ] + 1;\\n        }\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        logN = log10(n);\\n       return find(n , k, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 447443,
                "title": "preorder-traversal",
                "content": "preorder traversal of the tree  where\\n\\n1. given a node u ,10u, 10u+1, 10u+2, ..., 10u+9 are his direct descendants\\n1. the root is 0\\n\\n```\\n\\nclass Solution(object):\\n    def findKthNumber(self, n, k): \\n        count, res = [k + 1], [0]\\n        self.dfs(0,count,res, n)\\n        return res[0]\\n    \\n    def dfs(self, u, c, r, n):\\n        if u > n or c[0] < 0: return\\n        c[0] -= 1\\n        if c[0] == 0: \\n            r[0] = u\\n            return\\n        for v in range(0 if u else 1, 10): \\n            self.dfs(10*u + v, c, r, n)\\n```\\nexcuse my language but it TLEs like a M*** Fu*****\\ncome on man\\n\\nnow as seen in other solutions skip entire subtrees at once \\ncount the nodes within that subtree rooted at u, andgiven k moves\\n1. if less than k (more or less 1) within subtree rooted at u, go to the next subtree\\n2. if more than k, get in that subtree\\n\\n```\\nclass Solution(object):\\n    def findKthNumber(self, n, k): return self.f(1, k - 1 , n)\\n    \\n    def f(self, u, l, n):\\n        if l == 0: return u\\n        count = self.g(u, n) # how many nodes in the subtree rooted at u \\n        return self.f(10 * u, l - 1, n) if count > l else self.f(u + 1, l - count, n)\\n    \\n    \"\"\"\\n    how many nodes in the subtree rooted at u \\n    for this consider v the tree right next to u (virtually)\\n    \\n    and count layer by layer\\n    \\n    \"\"\"\\n    def g(self, u,n):\\n        count, v = 0, u + 1\\n        while(u <= n):\\n            count += min(v,n + 1) - u\\n            u *= 10\\n            v *= 10\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def findKthNumber(self, n, k): \\n        count, res = [k + 1], [0]\\n        self.dfs(0,count,res, n)\\n        return res[0]\\n    \\n    def dfs(self, u, c, r, n):\\n        if u > n or c[0] < 0: return\\n        c[0] -= 1\\n        if c[0] == 0: \\n            r[0] = u\\n            return\\n        for v in range(0 if u else 1, 10): \\n            self.dfs(10*u + v, c, r, n)\\n```\n```\\nclass Solution(object):\\n    def findKthNumber(self, n, k): return self.f(1, k - 1 , n)\\n    \\n    def f(self, u, l, n):\\n        if l == 0: return u\\n        count = self.g(u, n) # how many nodes in the subtree rooted at u \\n        return self.f(10 * u, l - 1, n) if count > l else self.f(u + 1, l - count, n)\\n    \\n    \"\"\"\\n    how many nodes in the subtree rooted at u \\n    for this consider v the tree right next to u (virtually)\\n    \\n    and count layer by layer\\n    \\n    \"\"\"\\n    def g(self, u,n):\\n        count, v = 0, u + 1\\n        while(u <= n):\\n            count += min(v,n + 1) - u\\n            u *= 10\\n            v *= 10\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380852,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        unsigned int root = 1;\\n        \\n        while (k > 1) {\\n            int subTreeSz = calcSubSize(n, root);\\n            if (subTreeSz < k) {\\n                k -= subTreeSz;\\n                root++;\\n            } else {\\n                root *= 10;\\n                k--;\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    int calcSubSize(unsigned long long int n, unsigned long long int root) {\\n        unsigned long long int l = root, r = root + 1;\\n        int sz = 0;\\n        while (l <= n) {\\n            sz += min(n + 1, r) - l;\\n            l *= 10;\\n            r *= 10;\\n        }\\n        return sz;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        unsigned int root = 1;\\n        \\n        while (k > 1) {\\n            int subTreeSz = calcSubSize(n, root);\\n            if (subTreeSz < k) {\\n                k -= subTreeSz;\\n                root++;\\n            } else {\\n                root *= 10;\\n                k--;\\n            }\\n        }\\n        return root;\\n    }\\n    \\n    int calcSubSize(unsigned long long int n, unsigned long long int root) {\\n        unsigned long long int l = root, r = root + 1;\\n        int sz = 0;\\n        while (l <= n) {\\n            sz += min(n + 1, r) - l;\\n            l *= 10;\\n            r *= 10;\\n        }\\n        return sz;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355119,
                "title": "python-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def findKthNumber(self, n, k):\\n        k -= 1\\n        cur = 1\\n        while k > 0:\\n            step, first, last = 0, cur, cur + 1\\n            while first <= n:\\n                step += min(n + 1, last) - first\\n                first *= 10\\n                last *= 10\\n            if step <= k:\\n                cur += 1\\n                k -= step\\n            else:\\n                cur *= 10\\n                k -= 1\\n        return cur\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n, k):\\n        k -= 1\\n        cur = 1\\n        while k > 0:\\n            step, first, last = 0, cur, cur + 1\\n            while first <= n:\\n                step += min(n + 1, last) - first\\n                first *= 10\\n                last *= 10\\n            if step <= k:\\n                cur += 1\\n                k -= step\\n            else:\\n                cur *= 10\\n                k -= 1\\n        return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162579,
                "title": "c-0ms",
                "content": "```\\nclass Solution {\\n    public:\\n        int findKthNumber(int n, int k) {\\n            vector<int> num{0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111};\\n\\n            int prefix = 0;\\n            int c = 1;\\n            int a = n;\\n            while(a /= 10) {\\n                c++;\\n            }\\n\\n            int first = 1;\\n            while (k) {\\n  \\n\\n                int l = n - num[c-1] * (10 - first);\\n                int m = l / (num[c] - num[c-1]);\\n                int r = l - m * (num[c] - num[c-1]);\\n                int p = 0;\\n\\n\\n                if(num[c] * m >= k) {\\n                    p = (k - 1) / num[c];\\n                    k = (k - 1)  % num[c] + 1;\\n                    n = num[c]; \\n                }\\n                else if((num[c-1] * (9 - m - first)) > (n - k)) {\\n                    p = 9 - ((n - k) / num[c-1]) - first;\\n                    k = num[c-1] - (n - k) % num[c-1];\\n                    n = num[c-1];\\n                }\\n                else {\\n                    p = m;\\n                    k -= m * num[c];\\n                    n = r + num[c-1];\\n                }\\n\\n                prefix = prefix * 10 + p + first;\\n     \\n\\n                if(k == 1) {\\n                    return prefix;\\n                }\\n\\n                c--;\\n                k--;\\n                n--;\\n\\n                first = 0;\\n            }\\n\\n            return prefix;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public:\\n        int findKthNumber(int n, int k) {\\n            vector<int> num{0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111};\\n\\n            int prefix = 0;\\n            int c = 1;\\n            int a = n;\\n            while(a /= 10) {\\n                c++;\\n            }\\n\\n            int first = 1;\\n            while (k) {\\n  \\n\\n                int l = n - num[c-1] * (10 - first);\\n                int m = l / (num[c] - num[c-1]);\\n                int r = l - m * (num[c] - num[c-1]);\\n                int p = 0;\\n\\n\\n                if(num[c] * m >= k) {\\n                    p = (k - 1) / num[c];\\n                    k = (k - 1)  % num[c] + 1;\\n                    n = num[c]; \\n                }\\n                else if((num[c-1] * (9 - m - first)) > (n - k)) {\\n                    p = 9 - ((n - k) / num[c-1]) - first;\\n                    k = num[c-1] - (n - k) % num[c-1];\\n                    n = num[c-1];\\n                }\\n                else {\\n                    p = m;\\n                    k -= m * num[c];\\n                    n = r + num[c-1];\\n                }\\n\\n                prefix = prefix * 10 + p + first;\\n     \\n\\n                if(k == 1) {\\n                    return prefix;\\n                }\\n\\n                c--;\\n                k--;\\n                n--;\\n\\n                first = 0;\\n            }\\n\\n            return prefix;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155644,
                "title": "what-s-wrong-with-my-answer-i-am-definitely-right",
                "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/lioninchina/image_1533114147.png)\\n\\u4E0B\\u9762\\u662F\\u6211\\u7684python\\u4EE3\\u7801\\uFF0C\\u6C42\\u5927\\u4F6C\\u6307\\u6559\\uFF0C\\u6211\\u628A\\u6D4B\\u8BD5\\u8F93\\u5165\\u6539\\u6210\\u548C\\u63D0\\u4EA4\\u7684\\u4E00\\u6837\\u7684\\u4E86\\n\\uFF08Here is my python code ,what\\'s the problem ,give me a hand ,thanks,big brother ,the test Input is totaly the same with verifiable input\\uFF09\\n```\\nclass Solution(object):\\n    def findKthNumber(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        global c,m\\n        c=1\\n        m=1\\n        for i in range(1,10):\\n\\t\\t\\tif(c==k and m==1):\\n\\t\\t\\t\\tm=i\\n\\t\\t\\t\\treturn m\\n\\t\\t\\tif(m!=1):\\n\\t\\t\\t\\treturn m\\n\\t\\t\\t\\tprint(m)\\n\\t\\t\\tc=c+1;\\n\\t\\t\\tdg(i,k,n)\\n        return m\\np=0\\ndef dg(t,k,n):\\n\\tglobal c,m,p\\n\\tif t>n:\\n\\t\\treturn m\\n\\tu=0\\n\\tt=t*10\\n\\twhile t<=n and u<10 and p==0:\\n\\t\\t# print(t,c)\\n\\t\\tif(c==k and p==0):\\n\\t\\t\\tm=t;p=1;return m;\\n\\t\\tc=c+1;\\n\\t\\tdg(t,k,n)\\n\\t\\tg=t\\n\\t\\tt=t+1\\n\\t\\tu=u+1;\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findKthNumber(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        global c,m\\n        c=1\\n        m=1\\n        for i in range(1,10):\\n\\t\\t\\tif(c==k and m==1):\\n\\t\\t\\t\\tm=i\\n\\t\\t\\t\\treturn m\\n\\t\\t\\tif(m!=1):\\n\\t\\t\\t\\treturn m\\n\\t\\t\\t\\tprint(m)\\n\\t\\t\\tc=c+1;\\n\\t\\t\\tdg(i,k,n)\\n        return m\\np=0\\ndef dg(t,k,n):\\n\\tglobal c,m,p\\n\\tif t>n:\\n\\t\\treturn m\\n\\tu=0\\n\\tt=t*10\\n\\twhile t<=n and u<10 and p==0:\\n\\t\\t# print(t,c)\\n\\t\\tif(c==k and p==0):\\n\\t\\t\\tm=t;p=1;return m;\\n\\t\\tc=c+1;\\n\\t\\tdg(t,k,n)\\n\\t\\tg=t\\n\\t\\tt=t+1\\n\\t\\tu=u+1;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92265,
                "title": "easy-understanding-python-49ms-solution",
                "content": "Inspired from [this post](https://discuss.leetcode.com/topic/55377/simple-java-dfs-solution/4) by @xialanxuan1015 .\\n\\n**The basic idea is: find the digit of result, from left to right.**\\n~~~\\ne.g.  Say n = 333, k = 171\\nbreakdown n into 9 buckets: [111, 111, 45, 11, 11, 11, 11, 11, 11].\\n                               1    2   3   4   5   6   7   8   9      => digit = 2\\nbreakdown 110 into 10 buckets: [11, 11, 11, 11, 11, 11, 11, 11, 11, 11].\\n(-1 for top element)             0   1   2   3   4   5   6   7   8   9 => digit = 5\\nbreakdown 10 into 10 buckets: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1].\\n                               0  1  2  3  4  5  6  7  8  9            => digit = 2\\nans = 252.\\n~~~\\nExplanation:\\n1. Get the **bucket-size** of n numbers distributed into 9 buckets (represent 1 - 9) and find out k-th number falls in which one (say, bucket B).\\n2. Break down bucket B into **10** buckets (represent 0 - 9), get the bucket-size of  and find out k-th number falls in which one.\\n3. Repeat 2. until no more numbers\\n\\n\\nHere's my Python code:\\n```\\nclass Solution(object):\\n    def findKthNumber(self, n, k):\\n        if n <= 9 or k == 1: return k\\n        init, res, sumOfBkts, bktID = 1, 0, [n], 0\\n\\n        while k > 0:\\n            k = k-1\\n            sumOfBkts = self.getBucket(sumOfBkts[bktID], init)\\n            bktID, k = self.findDigit(sumOfBkts, k)\\n            res = res*10+(bktID+init) if bktID != 10 else res+1\\n            init = 0\\n        return res\\n\\n    def getBucket(self, togo, init=False):                  # generate buckets\\n        if not init: togo -= 1\\n        L = 9 if init else 10\\n        newBkt, num, b = [0 for _ in xrange(L)], 1, 0      # num: numbers in this layer  \\n        while togo > 0:\\n            add = num if togo-num > 0 else togo             # add the rest numbers into buckets\\n            newBkt[b], togo, b = newBkt[b]+add, togo-num, b+1\\n            if b == L: num, b = num*10, 0\\n        return newBkt\\n\\n    def findDigit(self, sumBkt, k, bktId=0):                # find out which bucket.\\n        while k-sumBkt[bktId] >= 0: k, bktId = k-sumBkt[bktId], bktId+1      # go next bucket\\n        return bktId, k\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findKthNumber(self, n, k):\\n        if n <= 9 or k == 1: return k\\n        init, res, sumOfBkts, bktID = 1, 0, [n], 0\\n\\n        while k > 0:\\n            k = k-1\\n            sumOfBkts = self.getBucket(sumOfBkts[bktID], init)\\n            bktID, k = self.findDigit(sumOfBkts, k)\\n            res = res*10+(bktID+init) if bktID != 10 else res+1\\n            init = 0\\n        return res\\n\\n    def getBucket(self, togo, init=False):                  # generate buckets\\n        if not init: togo -= 1\\n        L = 9 if init else 10\\n        newBkt, num, b = [0 for _ in xrange(L)], 1, 0      # num: numbers in this layer  \\n        while togo > 0:\\n            add = num if togo-num > 0 else togo             # add the rest numbers into buckets\\n            newBkt[b], togo, b = newBkt[b]+add, togo-num, b+1\\n            if b == L: num, b = num*10, 0\\n        return newBkt\\n\\n    def findDigit(self, sumBkt, k, bktId=0):                # find out which bucket.\\n        while k-sumBkt[bktId] >= 0: k, bktId = k-sumBkt[bktId], bktId+1      # go next bucket\\n        return bktId, k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897520,
                "title": "c-java-trie-solution-tle-and-accepted-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        int curr=1;\\n        k--;\\n        while(k>0){\\n            int steps=countSteps(n,curr,curr+1);\\n            if(steps<=k){\\n                curr++;\\n                k-=steps;\\n            }\\n            else{\\n                curr*=10;\\n                k--;\\n            }\\n        }\\n        return curr;\\n    }\\n    int countSteps(long n,long start,long end){\\n        int steps=0;\\n        while(start<=n){\\n            steps+=min(n+1,end)-start;\\n            start*=10;\\n            end*=10;\\n        }\\n        return steps;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        int current = 1;\\n        k--;\\n        while (k > 0) {\\n            int steps = countSteps(n, current, current + 1);\\n            if (steps <= k) {\\n                current++;\\n                k -= steps;\\n            } else {\\n                current *= 10;\\n                k--;\\n            }\\n        }\\n\\n        return current;\\n    }\\n\\n    private int countSteps(int n, long start, long end) {\\n        int steps = 0;\\n        while (start <= n) {\\n            steps += Math.min(n + 1, end) - start;\\n            start *= 10;\\n            end *= 10;\\n        }\\n        return steps;\\n    }\\n}\\n\\n```\\n```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        Trie trie=new Trie();\\n        for(int i=1;i<=n;i++)\\n        {\\n            String word=String.valueOf(i);\\n            trie.insert(word,i);\\n        }\\n        trie.search(k,trie.root);\\n        return trie.ans;\\n    }\\n}\\nclass Trie{\\n    public static Node root;\\n    public int ans;\\n    public Trie() {\\n        ans=0;\\n        root=new Node(null);\\n    }\\n    public void insert(String word,int num) {\\n        Node node=root;\\n        for(char ch:word.toCharArray())\\n        {\\n            for(int i=0;i<10;i++){\\n                char c=(char)(i+\\'0\\');\\n                if(node.containsKey(c))continue;\\n                node.put(c,node);\\n            }\\n            node=node.get(ch);\\n        }\\n        node.setEnd(num);\\n    }\\n    public void search(int k,Node node){\\n\\n        if(node.isEnd() && !node.mark){\\n            k--;\\n            node.setMark();\\n        }\\n        if(k==0){\\n            ans=node.number();\\n            return;\\n        }\\n        for(int i=0;i<10;i++)\\n        {\\n            if(node.links[i]!=null && node.links[i].par==node){\\n                search(k,node.links[i]);\\n                return;\\n            }\\n        }\\n        Node temp=node.par;\\n        node.par=null;\\n        search(k,temp);\\n    }\\n}\\nclass Node{\\n    Node[] links;\\n    boolean end;\\n    int num;\\n    Node par;\\n    boolean mark;\\n    Node(Node par){\\n        this.mark=false;\\n        this.links=new Node[10];\\n        this.end=false;\\n        this.num=0;\\n        this.par=par;\\n    }\\n    boolean containsKey(char ch){\\n        return this.links[ch-\\'0\\']!=null;\\n    }\\n    void put(char ch,Node p){\\n        links[ch-\\'0\\']=new Node(p);\\n    }\\n    Node get(char ch){\\n        return links[ch-\\'0\\'];\\n    }\\n    void setEnd(int num){\\n        this.end=true;\\n        this.num=num;\\n    }\\n    boolean isEnd(){\\n        return this.end;\\n    }\\n    int number(){\\n        return this.num;\\n    }\\n    void setMark(){\\n        this.mark=true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        int curr=1;\\n        k--;\\n        while(k>0){\\n            int steps=countSteps(n,curr,curr+1);\\n            if(steps<=k){\\n                curr++;\\n                k-=steps;\\n            }\\n            else{\\n                curr*=10;\\n                k--;\\n            }\\n        }\\n        return curr;\\n    }\\n    int countSteps(long n,long start,long end){\\n        int steps=0;\\n        while(start<=n){\\n            steps+=min(n+1,end)-start;\\n            start*=10;\\n            end*=10;\\n        }\\n        return steps;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        int current = 1;\\n        k--;\\n        while (k > 0) {\\n            int steps = countSteps(n, current, current + 1);\\n            if (steps <= k) {\\n                current++;\\n                k -= steps;\\n            } else {\\n                current *= 10;\\n                k--;\\n            }\\n        }\\n\\n        return current;\\n    }\\n\\n    private int countSteps(int n, long start, long end) {\\n        int steps = 0;\\n        while (start <= n) {\\n            steps += Math.min(n + 1, end) - start;\\n            start *= 10;\\n            end *= 10;\\n        }\\n        return steps;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        Trie trie=new Trie();\\n        for(int i=1;i<=n;i++)\\n        {\\n            String word=String.valueOf(i);\\n            trie.insert(word,i);\\n        }\\n        trie.search(k,trie.root);\\n        return trie.ans;\\n    }\\n}\\nclass Trie{\\n    public static Node root;\\n    public int ans;\\n    public Trie() {\\n        ans=0;\\n        root=new Node(null);\\n    }\\n    public void insert(String word,int num) {\\n        Node node=root;\\n        for(char ch:word.toCharArray())\\n        {\\n            for(int i=0;i<10;i++){\\n                char c=(char)(i+\\'0\\');\\n                if(node.containsKey(c))continue;\\n                node.put(c,node);\\n            }\\n            node=node.get(ch);\\n        }\\n        node.setEnd(num);\\n    }\\n    public void search(int k,Node node){\\n\\n        if(node.isEnd() && !node.mark){\\n            k--;\\n            node.setMark();\\n        }\\n        if(k==0){\\n            ans=node.number();\\n            return;\\n        }\\n        for(int i=0;i<10;i++)\\n        {\\n            if(node.links[i]!=null && node.links[i].par==node){\\n                search(k,node.links[i]);\\n                return;\\n            }\\n        }\\n        Node temp=node.par;\\n        node.par=null;\\n        search(k,temp);\\n    }\\n}\\nclass Node{\\n    Node[] links;\\n    boolean end;\\n    int num;\\n    Node par;\\n    boolean mark;\\n    Node(Node par){\\n        this.mark=false;\\n        this.links=new Node[10];\\n        this.end=false;\\n        this.num=0;\\n        this.par=par;\\n    }\\n    boolean containsKey(char ch){\\n        return this.links[ch-\\'0\\']!=null;\\n    }\\n    void put(char ch,Node p){\\n        links[ch-\\'0\\']=new Node(p);\\n    }\\n    Node get(char ch){\\n        return links[ch-\\'0\\'];\\n    }\\n    void setEnd(int num){\\n        this.end=true;\\n        this.num=num;\\n    }\\n    boolean isEnd(){\\n        return this.end;\\n    }\\n    int number(){\\n        return this.num;\\n    }\\n    void setMark(){\\n        this.mark=true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892233,
                "title": "python3-explained",
                "content": "# Intuition\\nThe lexicographical order of numbers can be thought of as a preorder traversal of a 10-ary tree (a tree where each node has up to 10 children). At the top level, we have numbers from 1 to 9 (we exclude 0 because numbers don\\'t start with 0). Each of these numbers can be considered as the root of a subtree that represents all numbers that have that prefix. For instance, under the number 1, we have numbers 10 to 19, under 2 we have numbers 20 to 29, and so on.\\n# Approach\\n1. Tree Traversal:\\n- We can traverse this tree in a depth-first manner. Starting from 1, we go as deep as possible by multiplying the current number by 10 until we exceed the limit n. This represents exploring the subtree under each number.\\n- Once we exceed n or reach the maximum depth for a particular subtree, we move to the next sibling by adding 1 to the current number.\\n- The challenge is to efficiently skip over subtrees that don\\'t contain the kth smallest number. This is where the steps function comes into play.\\n2. Calculate Steps:\\n- The steps function calculates how many numbers are there between two given numbers, say a and b, in the lexicographical order under the limit n. For instance, between 1 and 2, we have the numbers [1, 10, 11, ...].\\n- If the number of steps from the current number to the next is less than k, it means the kth number is not in the current subtree. We can safely move to the next subtree.\\n- Otherwise, we delve deeper into the current subtree by multiplying the current number by 10.\\n1. Termination:\\n- The traversal stops once k becomes 0, which means we\\'ve reached the kth number in the sequence.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is O(log 10n). This is because in each iteration, we either multiply the current number by 10 (going deeper into the tree) or add 1 to it (moving to the next sibling). The depth of this tree is logarithmic with respect to n.\\n- Space complexity:\\nThe space complexity is O(1) since we are using a constant amount of space.\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        def steps(n, n1, n2):\\n            count = 0\\n            while n1 <= n:\\n                count += min(n + 1, n2) - n1\\n                n1 *= 10\\n                n2 *= 10\\n            return count\\n        \\n        curr = 1\\n        k -= 1\\n        while k > 0:\\n            count = steps(n, curr, curr + 1)\\n            if count <= k:\\n                curr += 1\\n                k -= count\\n            else:\\n                curr *= 10\\n                k -= 1\\n        return curr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        def steps(n, n1, n2):\\n            count = 0\\n            while n1 <= n:\\n                count += min(n + 1, n2) - n1\\n                n1 *= 10\\n                n2 *= 10\\n            return count\\n        \\n        curr = 1\\n        k -= 1\\n        while k > 0:\\n            count = steps(n, curr, curr + 1)\\n            if count <= k:\\n                curr += 1\\n                k -= count\\n            else:\\n                curr *= 10\\n                k -= 1\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852971,
                "title": "python3-beats-96",
                "content": "\\nOPT(dig) is given the substring \\'dig\\' how many substrings less than n start with that substring\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        if k == 1:\\n            return 1\\n        nstr = str(n)\\n\\n        @cache\\n        def opt(i, dig):\\n            if i == len(nstr):\\n                return 0\\n\\n            if int(nstr[:i+1]) > int(dig):\\n                temp = 0\\n                for x in range(i, len(nstr)-1):\\n                    temp+=pow(10, x-i)\\n                return temp + pow(10, len(nstr)-i-1)\\n\\n            elif int(nstr[:i+1])<int(dig):\\n                temp = 0\\n                for x in range(i, len(nstr)-1):\\n                    temp+=pow(10, x-i)\\n                return temp\\n\\n            else:\\n                temp = 1\\n                for x in \"1234567890\":\\n                    temp+=opt(i+1,dig+x)\\n\\n                return temp\\n\\n        s = \"0123456789\"\\n        h = 1\\n\\n        res = \"\"\\n        curr = 0\\n        ind = 0\\n        while True:\\n            x = s[h]\\n            y = opt(ind, res+x)\\n            if curr + y>=k:\\n                res += x\\n                curr+=1\\n                if curr == k:\\n                    return int(res)\\n                h = 0\\n                ind+=1\\n            else:\\n                curr+=y\\n                h+=1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        if k == 1:\\n            return 1\\n        nstr = str(n)\\n\\n        @cache\\n        def opt(i, dig):\\n            if i == len(nstr):\\n                return 0\\n\\n            if int(nstr[:i+1]) > int(dig):\\n                temp = 0\\n                for x in range(i, len(nstr)-1):\\n                    temp+=pow(10, x-i)\\n                return temp + pow(10, len(nstr)-i-1)\\n\\n            elif int(nstr[:i+1])<int(dig):\\n                temp = 0\\n                for x in range(i, len(nstr)-1):\\n                    temp+=pow(10, x-i)\\n                return temp\\n\\n            else:\\n                temp = 1\\n                for x in \"1234567890\":\\n                    temp+=opt(i+1,dig+x)\\n\\n                return temp\\n\\n        s = \"0123456789\"\\n        h = 1\\n\\n        res = \"\"\\n        curr = 0\\n        ind = 0\\n        while True:\\n            x = s[h]\\n            y = opt(ind, res+x)\\n            if curr + y>=k:\\n                res += x\\n                curr+=1\\n                if curr == k:\\n                    return int(res)\\n                h = 0\\n                ind+=1\\n            else:\\n                curr+=y\\n                h+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694614,
                "title": "c-fastest-and-easiest-solution",
                "content": "# Intuition\\nI highly reccomend you to approach a recursion problem called \"lexicographical ordering till n\" first, before approaching this problem. By that you will get an idea on how a digit lexicographical recursion tree is formed. It look like this:\\n\\n                            \"\"\\n                            /\\\\\\n                    \"1\"   \"2\"   \"3\"......\"9\"\\n                     /\\\\                   /\\\\\\n                \"10\" \"11\"...\"19\"   ...   \"90\" \"91\"...\"99\"  and so on.\\n\\nFor each level a prefix is fixed. and we use that prefix to for our numbers.\\n\\n# Approach\\nIdea is first we check wether k is less than the count of nodes in our subtree. If yes, then we are sure that it will belong to our current nodes subtree and we move down and k is decreased by one else we move to sibling node as our current node and we decrease the k by count of nodes in the subtree we just saw. This is done untill we reach the current pointer to kth smallest node (i.e is k==0). \\nNOTE: go through the counter method manually to understand it better.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n(Constant) in case of Auxiliary\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int counter(long long curr, long long next, int n){ //this function counts the number of nodes in lexi. tree under node->curr\\n        long long count=0;\\n        while(curr<=n){\\n            if(next<=n){\\n                count+=(next-curr);\\n                if(curr==n)break;\\n            }else{\\n                count+=(n-curr+1);\\n            }\\n            curr*=10;\\n            next*=10;\\n        }\\n        return (int)count;\\n    }\\n    int findKthNumber(int n, int k) {\\n        long long curr=1ll;\\n        k--; //as we have already counted 1 and our ans will always be positive.\\n        while(k>0){\\n            //if k==1, this while loop will not be entered and curr will be returned as one else we taverse the Lexicographical tree.\\n            long long number_of_nodes_with_prefix_curr = counter(curr,curr+1,n); //number of numbers with this prefix -> \"curr\"\\n            //cout<<number_of_nodes_with_prefix_curr<<endl;\\n            if(number_of_nodes_with_prefix_curr<=k){\\n                k-=number_of_nodes_with_prefix_curr; // as subtree nodes are smaller than k, k needs include this count.\\n                curr++; // this current-node\\'s subtree nodes are all smaller, we need to jump to +1 prefix.\\n            }else{\\n                k--;  // as we have counted the current node.\\n                curr*=10; // as we move down the lexicographical tree.\\n            }\\n        }return (int)curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int counter(long long curr, long long next, int n){ //this function counts the number of nodes in lexi. tree under node->curr\\n        long long count=0;\\n        while(curr<=n){\\n            if(next<=n){\\n                count+=(next-curr);\\n                if(curr==n)break;\\n            }else{\\n                count+=(n-curr+1);\\n            }\\n            curr*=10;\\n            next*=10;\\n        }\\n        return (int)count;\\n    }\\n    int findKthNumber(int n, int k) {\\n        long long curr=1ll;\\n        k--; //as we have already counted 1 and our ans will always be positive.\\n        while(k>0){\\n            //if k==1, this while loop will not be entered and curr will be returned as one else we taverse the Lexicographical tree.\\n            long long number_of_nodes_with_prefix_curr = counter(curr,curr+1,n); //number of numbers with this prefix -> \"curr\"\\n            //cout<<number_of_nodes_with_prefix_curr<<endl;\\n            if(number_of_nodes_with_prefix_curr<=k){\\n                k-=number_of_nodes_with_prefix_curr; // as subtree nodes are smaller than k, k needs include this count.\\n                curr++; // this current-node\\'s subtree nodes are all smaller, we need to jump to +1 prefix.\\n            }else{\\n                k--;  // as we have counted the current node.\\n                curr*=10; // as we move down the lexicographical tree.\\n            }\\n        }return (int)curr;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3606714,
                "title": "faster-and-easier-to-understand-than-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI struggled a long time with this problem until I got it. Wouldn\\'t have solved it during a 1hr interview but I learned some along the way.\\n\\nEventually what I realized is that\\n* all numbers in 1..n starting with 1 come before 2, those starting with 2 come before 3, etc.\\n* all numbers starting with 10 come before 11, and so on\\n* for a prefix such as 30, 30 comes before 30x, which comes before 30xy, etc.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nSuppose we had a function `startingWith(prefix, n)`that returned the number of values in 1..n that start with a given prefix. Then\\n* `startingWith(1, n)` tells us if the result starts with 1:\\n  * if the result is `<= k` then the result starts with 1\\n  * if the result is `> k` then the result starts with 2 or more\\n\\nThen we can do the same thing with `startingWith(2, n)`. If the number starting with 1 and 2 are fewer than k, the result must start with 3 or more. Otherwise the result starts with 2.\\n\\nSo I rewrote this loop as follows:\\n* we have a counter `rem` that tells us the number of values in the lexically ordered sequence we have left to go\\n* and a current `prefix`; the result is either `prefix` itself or starts wth prefix\\n\\nWe start with the lowest prefix: 1.\\n\\nIf the number of values left to go is exactly 1, the answer is the current prefix: it comes before `<prefix>0`, `<prefix>00`, etc.\\n\\nIf the number of values left to go is MORE than the number starting with the current prefix, we advance to the next prefix and subtract the number of values we just skipped over.\\n\\nOtherwise the value starts with something in `<prefix>0`, `<prefix>9`. So we move on to `<prefix>0` and decrement `rem` (because we advance past `<prefix>` itself).\\n\\n# Counting the number of values in 1..n starting with prefix\\n\\nAfter struggling a bit here as well I figured out the following: for a given prefix there are the following numbers that may be $\\\\leq n$:\\n* `<prefix>` itself\\n* `<prefix>0` to `<prefix>9`\\n* `<prefix>00` to `<prefix>99`\\n\\nThe next prefix is `<prefix+1>`, so in the loop I made (`numStartingWith`) we increment count by 1 for `<prefix>`, then by up to 10 for `<prefix>0 .. <prefix>9`, then by up to 100, etc. The loop stops when the `<prefix>00...0` is larger than $n$ so there can\\'t be any more numbers starting with `prefix` left to add.\\n\\n# Complexity\\n- Time complexity: $$O(\\\\log(n)^2)$$\\n\\nWe spend at most 9 iterations to find out what the first digit of the result is. Then we spend at most 10 iteratiosn to find out what the next digit is.\\n\\nThe number of digits in the result is the number of digits in $n$, i.e. $\\\\log(n)$ digits.\\n\\nIn each of those calls, we have an $O(\\\\log(n))$ loop to find the number of values starting with the current prefix.\\n\\n- Space complexity: $$O(1)$$, we just have a couple of counters\\n\\n# Code\\n```\\nclass Solution {\\n    /** Returns the number of integers in 1..n with the given lexical prefix */\\n    int numStartingWith(int prefix, int n) {\\n        \\n        int count = 0;\\n        long lo = prefix; // [lo, hi) with current number of digits\\n        long hi = prefix+1;\\n        while (lo <= n) {\\n            count += min(hi-lo, n-lo+1);\\n            lo *= 10;\\n            hi *= 10;\\n        }\\n        printf(\"numStartingWith(%i, %i) == %i\\\\n\", prefix, n, count);\\n        return count;\\n    }\\n\\npublic:\\n    int findKthNumber(int n, int k) {\\n        // suppose we know the number of integers <= n that start with a prefix\\n        //   if it\\'s fewer than k, we move on to the next prefix and decrement some remaining counter `rem`\\n        //   if it\\'s more than `rem`, e.g. maybe there are more numbers starting with 20 ...\\n        //   \\n        \\n        // e.g.  n = 127 and k = 40, rem = 40\\n        //   num starting with 1 is 32 (100..127, 10..12, 1). 32 < 40 so we move on to 2-something, and rem = 8\\n        //   num starting with 2 is 11, 11 >= 8 so the result lexically starts with 2\\n        //       // we\\'ve narrowed it down to 2, 2x, 2xy, 2xyz, etc.\\n        //       rem > 1 so we rule out 2 itself\\n        //       prefix = 20 and rem = 7\\n        //         num starting with 20 is 1, so move on to next prefix 21\\n        //         num starting with 21 is 1,\\n\\n        int prefix = 1; // current prefix\\n        int rem = k; // number to go\\n        while (true) {\\n            if (rem == 1) return prefix; \\n            int count = numStartingWith(prefix, n);\\n            if (count < rem) {\\n                ++prefix; // can skip past all `count` numbers <= n starting with this prefix\\n                rem -= count;\\n            } else {\\n                // prefix => <prefix>0, e.g. more than `rem` nums start with <30>, so we skip past 30 and move on to 300\\n                --rem;\\n                prefix *= 10;\\n            }\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    /** Returns the number of integers in 1..n with the given lexical prefix */\\n    int numStartingWith(int prefix, int n) {\\n        \\n        int count = 0;\\n        long lo = prefix; // [lo, hi) with current number of digits\\n        long hi = prefix+1;\\n        while (lo <= n) {\\n            count += min(hi-lo, n-lo+1);\\n            lo *= 10;\\n            hi *= 10;\\n        }\\n        printf(\"numStartingWith(%i, %i) == %i\\\\n\", prefix, n, count);\\n        return count;\\n    }\\n\\npublic:\\n    int findKthNumber(int n, int k) {\\n        // suppose we know the number of integers <= n that start with a prefix\\n        //   if it\\'s fewer than k, we move on to the next prefix and decrement some remaining counter `rem`\\n        //   if it\\'s more than `rem`, e.g. maybe there are more numbers starting with 20 ...\\n        //   \\n        \\n        // e.g.  n = 127 and k = 40, rem = 40\\n        //   num starting with 1 is 32 (100..127, 10..12, 1). 32 < 40 so we move on to 2-something, and rem = 8\\n        //   num starting with 2 is 11, 11 >= 8 so the result lexically starts with 2\\n        //       // we\\'ve narrowed it down to 2, 2x, 2xy, 2xyz, etc.\\n        //       rem > 1 so we rule out 2 itself\\n        //       prefix = 20 and rem = 7\\n        //         num starting with 20 is 1, so move on to next prefix 21\\n        //         num starting with 21 is 1,\\n\\n        int prefix = 1; // current prefix\\n        int rem = k; // number to go\\n        while (true) {\\n            if (rem == 1) return prefix; \\n            int count = numStartingWith(prefix, n);\\n            if (count < rem) {\\n                ++prefix; // can skip past all `count` numbers <= n starting with this prefix\\n                rem -= count;\\n            } else {\\n                // prefix => <prefix>0, e.g. more than `rem` nums start with <30>, so we skip past 30 and move on to 300\\n                --rem;\\n                prefix *= 10;\\n            }\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584007,
                "title": "dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        def countPrefixes(prefix: int, n: int) -> int:\\n            count = 0\\n            curr = prefix\\n            next = prefix + 1\\n\\n            while curr <= n:\\n                count += min(n + 1, next) - curr\\n                curr *= 10\\n                next *= 10\\n\\n            return count\\n\\n        curr = 1\\n        k -= 1\\n\\n        while k > 0:\\n            count = countPrefixes(curr, n)\\n\\n            if count <= k:\\n                curr += 1\\n                k -= count\\n            else:\\n                curr *= 10\\n                k -= 1\\n\\n        return curr\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        def countPrefixes(prefix: int, n: int) -> int:\\n            count = 0\\n            curr = prefix\\n            next = prefix + 1\\n\\n            while curr <= n:\\n                count += min(n + 1, next) - curr\\n                curr *= 10\\n                next *= 10\\n\\n            return count\\n\\n        curr = 1\\n        k -= 1\\n\\n        while k > 0:\\n            count = countPrefixes(curr, n)\\n\\n            if count <= k:\\n                curr += 1\\n                k -= count\\n            else:\\n                curr *= 10\\n                k -= 1\\n\\n        return curr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568083,
                "title": "simple-beats-100",
                "content": "# Approach\\nGiven prefix (`res`) compute possible count of times it is seen in number less than or equal n. Keep growing prefix one digit at a time (outer `while` loop).\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getNumPrefix(int n, int d){\\n        long long res = 0, factor = 1;\\n        while(factor * d <= n){\\n            res += min(n - factor * d + 1, factor);\\n            factor *= 10;\\n        }\\n        return res;\\n    }\\n\\n\\n    int findKthNumber(int n, int k) {\\n        int res = 0;\\n        ++k;\\n        while(k > 0){\\n            if(k-- == 1)\\n                return res;\\n            for(int i = res ? 0 : 1; i <= 9; i++){\\n                int tmp = getNumPrefix(n, res*10 + i);\\n                if(tmp >= k){\\n                    res = res * 10 + i;\\n                    break;\\n                }\\n                k -= tmp;\\n            }\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNumPrefix(int n, int d){\\n        long long res = 0, factor = 1;\\n        while(factor * d <= n){\\n            res += min(n - factor * d + 1, factor);\\n            factor *= 10;\\n        }\\n        return res;\\n    }\\n\\n\\n    int findKthNumber(int n, int k) {\\n        int res = 0;\\n        ++k;\\n        while(k > 0){\\n            if(k-- == 1)\\n                return res;\\n            for(int i = res ? 0 : 1; i <= 9; i++){\\n                int tmp = getNumPrefix(n, res*10 + i);\\n                if(tmp >= k){\\n                    res = res * 10 + i;\\n                    break;\\n                }\\n                k -= tmp;\\n            }\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565014,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n) * log(k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def findKthNumber(n: Int, k: Int): Int = {\\n      var prefix = 1\\n      var count = 1\\n      while (count < k) {\\n        val currCount = getCountWithPrefix(prefix, prefix + 1, n)\\n        if (currCount + count <= k) {\\n          count += currCount\\n          prefix += 1\\n        } else {\\n          prefix *= 10\\n          count += 1\\n        }\\n      }\\n      prefix\\n    }\\n\\n    def getCountWithPrefix(startPrefix: Long, endPrefix: Long, max: Int): Int = {\\n      var count:Long = 0\\n      var sp = startPrefix\\n      var ep = endPrefix\\n      while (sp <= max) {\\n        count += math.min(max + 1, ep) - sp\\n        sp *= 10\\n        ep *= 10\\n      }\\n      count.toInt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def findKthNumber(n: Int, k: Int): Int = {\\n      var prefix = 1\\n      var count = 1\\n      while (count < k) {\\n        val currCount = getCountWithPrefix(prefix, prefix + 1, n)\\n        if (currCount + count <= k) {\\n          count += currCount\\n          prefix += 1\\n        } else {\\n          prefix *= 10\\n          count += 1\\n        }\\n      }\\n      prefix\\n    }\\n\\n    def getCountWithPrefix(startPrefix: Long, endPrefix: Long, max: Int): Int = {\\n      var count:Long = 0\\n      var sp = startPrefix\\n      var ep = endPrefix\\n      while (sp <= max) {\\n        count += math.min(max + 1, ep) - sp\\n        sp *= 10\\n        ep *= 10\\n      }\\n      count.toInt\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3518918,
                "title": "k-th-smallest-in-lexicographical-order-c",
                "content": "Intuition:\\nTo find the kth lexicographically smallest integer in the range [1, n], we can generate all the integers in the range [1, n] in lexicographical order and return the kth integer.\\n\\nApproach:\\nWe can generate all the integers in the range [1, n] in lexicographical order using a DFS approach. Starting from 1, we can explore all the children nodes in lexicographical order until we have generated all the integers in the range [1, n]. We can keep track of the number of integers generated so far and return the kth integer when we reach it.\\n\\nTo generate the children nodes of a number curr, we can add 0 to curr to get the first child node and add 1 to curr to get the second child node. We can then explore the children nodes recursively until we reach a number greater than n.\\n\\nTo optimize the DFS approach, we can use the fact that the children nodes of a number curr differ by a factor of 10. This allows us to calculate the number of integers between curr and curr * 10 (i.e., the number of integers with curr as a prefix) in constant time. We can use this information to skip over entire ranges of integers in the DFS search when possible.\\n\\nComplexity:\\nTime Complexity: O(n). In the worst case, we will generate all n integers in the range [1, n] in lexicographical order. However, since we can skip over entire ranges of integers in the DFS search, the actual time complexity will be much lower.\\n\\nSpace Complexity: O(1). We only use constant extra space to store the current integer and the number of integers generated so far.\\n# Code\\n```\\npublic class Solution {\\n    public int FindKthNumber(int n, int k) {\\n        int curr = 1;\\n        k--;\\n\\n        while (k > 0) {\\n            long steps = 0, first = curr, last = curr + 1;\\n            while (first <= n) {\\n                steps += Math.Min((long)n + 1, last) - first;\\n                first *= 10;\\n                last *= 10;\\n            }\\n\\n            if (steps <= k) {\\n                curr++;\\n                k -= (int)steps;\\n            }\\n            else {\\n                curr *= 10;\\n                k--;\\n            }\\n        }\\n\\n        return curr;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindKthNumber(int n, int k) {\\n        int curr = 1;\\n        k--;\\n\\n        while (k > 0) {\\n            long steps = 0, first = curr, last = curr + 1;\\n            while (first <= n) {\\n                steps += Math.Min((long)n + 1, last) - first;\\n                first *= 10;\\n                last *= 10;\\n            }\\n\\n            if (steps <= k) {\\n                curr++;\\n                k -= (int)steps;\\n            }\\n            else {\\n                curr *= 10;\\n                k--;\\n            }\\n        }\\n\\n        return curr;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440182,
                "title": "explained-c-soln-100-fast",
                "content": "*Note- Learn it from a video not my original idea*\\nSo,I will try my best to explain\\ntaking case n=13, and k=3\\n \\nworking of currentnode function -> it will tell us how many elements are from curr and below it that are present in n\\n![MicrosoftTeams-image.png](https://assets.leetcode.com/users/images/9cde9775-869c-4bff-bb1a-981528758148_1682059531.829521.jpeg)\\n\\nhence for curr=1 currentnode function will return 5 value\\n\\nnow lets go to findKthNumber function , so it will go into loop till k==0. so for cur first we find number of nodes from it to below then there is 2 cases \\nif(k>=nodes) means that cur integer and all its below cases will come before index k that means it does not contain the answer so we will move to next(increment)\\nelse if it contain the ans we multiply it by 10 to go next level\\n\\nworking ->\\ncur =1 k=2\\nnodes=5\\nelse condition generate therefore cur=10 k=1\\nnodes = 1 for(cur =10)\\nif condition -> cur =12, k=0;\\nanswer=12 \\n\\nPlease Upvote \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint currentnode(long n,long cur){\\n    int total=0;\\n    long next=cur+1;\\n    while(cur<=n){\\n        total+= min(n-cur+1,next-cur);\\n        cur*=10;\\n        next*=10;\\n    }\\n    return total;\\n}\\n\\n    int findKthNumber(int n, int k) {\\n        long cur=1;\\n        k--;\\n        while(k>0){\\n            int nodes= currentnode(n,cur);\\n            if(k>=nodes){\\n                cur+=1;\\n                k-=nodes;\\n            }\\n            else {\\n                cur*=10;\\n                k--;\\n            }\\n        }\\n        return (int)cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint currentnode(long n,long cur){\\n    int total=0;\\n    long next=cur+1;\\n    while(cur<=n){\\n        total+= min(n-cur+1,next-cur);\\n        cur*=10;\\n        next*=10;\\n    }\\n    return total;\\n}\\n\\n    int findKthNumber(int n, int k) {\\n        long cur=1;\\n        k--;\\n        while(k>0){\\n            int nodes= currentnode(n,cur);\\n            if(k>=nodes){\\n                cur+=1;\\n                k-=nodes;\\n            }\\n            else {\\n                cur*=10;\\n                k--;\\n            }\\n        }\\n        return (int)cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382221,
                "title": "probably-a-good-soln-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        long curr=1;\\n        k-=1;\\n        while(k>0){\\n            int gap=(int)countNodes(curr, n, k);\\n            if(k>=gap){\\n                curr++;\\n                k-=gap;\\n            }\\n            else{\\n                curr*=10;\\n                k-=1;\\n            }\\n        }\\n        return (int)curr;\\n    }\\n    public long countNodes(long curr, long n, long k){\\n        long next=curr+1,  gap=0;\\n        while(curr<=n){\\n            gap+=Math.min(n-curr+1, next-curr);\\n            curr*=10;\\n            next*=10;\\n        }\\n        return gap;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        long curr=1;\\n        k-=1;\\n        while(k>0){\\n            int gap=(int)countNodes(curr, n, k);\\n            if(k>=gap){\\n                curr++;\\n                k-=gap;\\n            }\\n            else{\\n                curr*=10;\\n                k-=1;\\n            }\\n        }\\n        return (int)curr;\\n    }\\n    public long countNodes(long curr, long n, long k){\\n        long next=curr+1,  gap=0;\\n        while(curr<=n){\\n            gap+=Math.min(n-curr+1, next-curr);\\n            curr*=10;\\n            next*=10;\\n        }\\n        return gap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357816,
                "title": "python-kth-lexicographically-smallest-integer-in-range",
                "content": "# Intuition\\nWe can observe that the lexicographical order of the integers from 1 to n form a trie where the root is the empty string, and the children of a node represent the digits that can come after the digit sequence represented by the node. We can use this trie to find the kth lexicographically smallest integer by performing a modified depth-first search (DFS) where we keep track of the number of nodes visited so far and return the integer corresponding to the kth node.\\n# Approach\\n1. Initialize a variable count to 0 and create an empty list result to store the integers visited during the DFS.\\n2. Start the DFS from the empty string.\\n3. For each digit d from 0 to 9, add it to the current string, and recursively call the DFS with the updated string.\\n4. If the current string is not empty and is less than or equal to n, append it to the result list and increment count.\\n5. If count is equal to k, return the last element of the result list.\\n6. If count is greater than k, return the kth element of the result list.\\n7. If count is less than k, return -1.\\n# Complexity\\n- Time complexity:\\nO(n), since we visit each integer from 1 to n exactly once.\\n- Space complexity:\\nO(log n), since the depth of the trie is log n.\\n# Code\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        curr = 1\\n        k -= 1 # decrement k to handle 1-based indexing\\n        while k > 0:\\n            steps = self.countSteps(n, curr, curr+1) # count steps to the next number\\n            if steps <= k: # if there are not enough steps, move to the next number\\n                curr += 1\\n                k -= steps\\n            else: # if there are enough steps, move to the next digit\\n                curr *= 10\\n                k -= 1\\n        return curr\\n\\n    def countSteps(self, n: int, n1: int, n2: int) -> int:\\n        \"\"\"\\n        Count the number of steps from n1 to n2 in lexicographical order in the range [1, n].\\n        \"\"\"\\n        steps = 0\\n        while n1 <= n:\\n            steps += min(n+1, n2) - n1 # count the steps from n1 to the next number or n2, whichever comes first\\n            n1 *= 10\\n            n2 *= 10\\n        return steps\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        curr = 1\\n        k -= 1 # decrement k to handle 1-based indexing\\n        while k > 0:\\n            steps = self.countSteps(n, curr, curr+1) # count steps to the next number\\n            if steps <= k: # if there are not enough steps, move to the next number\\n                curr += 1\\n                k -= steps\\n            else: # if there are enough steps, move to the next digit\\n                curr *= 10\\n                k -= 1\\n        return curr\\n\\n    def countSteps(self, n: int, n1: int, n2: int) -> int:\\n        \"\"\"\\n        Count the number of steps from n1 to n2 in lexicographical order in the range [1, n].\\n        \"\"\"\\n        steps = 0\\n        while n1 <= n:\\n            steps += min(n+1, n2) - n1 # count the steps from n1 to the next number or n2, whichever comes first\\n            n1 *= 10\\n            n2 *= 10\\n        return steps\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340243,
                "title": "counting-with-style-finding-the-kth-lexicographically-smallest-integer-in-1-n-like-a-pro",
                "content": "# Intuition\\nThe problem requires us to find the kth lexicographically smallest integer in the range [1, n]. The lexicographical order is the same as the alphabetical order, where we compare the strings character by character. For example, \"10\" is lexicographically smaller than \"2\", because \"1\" comes before \"2\" in the alphabet. \\n\\nOne way to solve this problem is to traverse the lexicographically sorted integers in the range [1, n], and count the number of steps taken so far. We can start from 1, and move to its next smallest neighbor, or move to the first child of a number if we cannot move to its neighbor. By counting the number of steps taken, we can stop when we reach the kth number.\\n\\n# Approach\\nWe can use a variable `cur` to represent the current number, and a variable `k` to count the number of steps taken so far. Initially, `cur` is set to 1, and `k` is subtracted by 1, since the first number is always 1.\\n\\nThen we enter a loop that continues until `k` reaches 0. In each iteration, we first calculate the number of steps from `cur` to its next smallest neighbor, which is done by the helper function `calcSteps()`. If this number of steps is less than or equal to `k`, we can move to the next number by incrementing `cur` and subtracting the steps taken from `k`. Otherwise, we cannot move to the next number, and we need to move to the first child of `cur` by multiplying it by 10, and subtracting 1 from `k`, since `cur` itself is a valid number.\\n\\nAfter the loop ends, the current number `cur` is the kth lexicographically smallest integer in the range [1, n], so we return it. \\n\\nThe time complexity of this approach is O(log n), because each iteration reduces the search range by a factor of 10, and the maximum number of iterations is log10(n). The space complexity is O(1), because we only need to store the current number and the number of steps taken.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n- Space complexity: O(1)\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        int cur = 1; // current number\\n        k--; // the first number is always 1, so we subtract 1 from k\\n        while (k > 0) {\\n            int steps = calcSteps(n, cur, cur + 1); // the number of steps to the next number\\n            if (steps <= k) { // if we can move to the next number\\n                cur++; // move to the next number\\n                k -= steps; // subtract the steps taken\\n            } else { // if we cannot move to the next number\\n                cur *= 10; // move to the first child of cur\\n                k--; // subtract 1 from k, since cur itself is a valid number\\n            }\\n        }\\n        return cur; // the kth number is the current number\\n    }\\n    \\n    // calculate the number of steps from num1 to num2\\n    int calcSteps(int n, long num1, long num2) {\\n        int steps = 0;\\n        while (num1 <= n) {\\n            steps += min((long)n + 1, num2) - num1; // calculate the steps from num1 to either the end or num2\\n            num1 *= 10; // move to the next level\\n            num2 *= 10;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        int cur = 1; // current number\\n        k--; // the first number is always 1, so we subtract 1 from k\\n        while (k > 0) {\\n            int steps = calcSteps(n, cur, cur + 1); // the number of steps to the next number\\n            if (steps <= k) { // if we can move to the next number\\n                cur++; // move to the next number\\n                k -= steps; // subtract the steps taken\\n            } else { // if we cannot move to the next number\\n                cur *= 10; // move to the first child of cur\\n                k--; // subtract 1 from k, since cur itself is a valid number\\n            }\\n        }\\n        return cur; // the kth number is the current number\\n    }\\n    \\n    // calculate the number of steps from num1 to num2\\n    int calcSteps(int n, long num1, long num2) {\\n        int steps = 0;\\n        while (num1 <= n) {\\n            steps += min((long)n + 1, num2) - num1; // calculate the steps from num1 to either the end or num2\\n            num1 *= 10; // move to the next level\\n            num2 *= 10;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146627,
                "title": "simple-readable-100-0ms-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        int prefix=1;\\n        for(int count=1;count<k;){\\n            int currCount=getCountWithPrefix(prefix,prefix+1,n);\\n            //if total count of elements < k, our answer doesn\\'t lies with that prefix \\n            if(currCount+count<=k){\\n                count+=currCount;\\n                prefix++;\\n            }else{\\n                prefix*=10; //if count of elements > k our answer lies with that prefix\\n                count++;    //skip to next element\\n            }\\n        }\\n        return prefix;\\n    }\\n    private int getCountWithPrefix(long startPrefix,long endPrefix,int max){\\n        int count=0;\\n        while(startPrefix<=max){\\n            //elements between startPrefix and endPrefix\\n            count+=Math.min(max+1,endPrefix)-startPrefix; //max+1 since max is included\\n            //increase the digits\\n            startPrefix*=10;\\n            endPrefix*=10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        int prefix=1;\\n        for(int count=1;count<k;){\\n            int currCount=getCountWithPrefix(prefix,prefix+1,n);\\n            //if total count of elements < k, our answer doesn\\'t lies with that prefix \\n            if(currCount+count<=k){\\n                count+=currCount;\\n                prefix++;\\n            }else{\\n                prefix*=10; //if count of elements > k our answer lies with that prefix\\n                count++;    //skip to next element\\n            }\\n        }\\n        return prefix;\\n    }\\n    private int getCountWithPrefix(long startPrefix,long endPrefix,int max){\\n        int count=0;\\n        while(startPrefix<=max){\\n            //elements between startPrefix and endPrefix\\n            count+=Math.min(max+1,endPrefix)-startPrefix; //max+1 since max is included\\n            //increase the digits\\n            startPrefix*=10;\\n            endPrefix*=10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100002,
                "title": "greedy-tree-exploration-clean-readable-java-in-o-log-n-2-time-o-log-n-space",
                "content": "# Intuition\\nLexicographical order of numbers follows tree structre below:\\n```\\nnothing\\n  1\\n  2\\n  3\\n    ..\\n    34\\n      340\\n      341\\n        3410\\n        3411\\n        3412\\n        ...\\n        3410\\n      342\\n      ...\\n      349\\n    ..\\n  4\\n  ..\\n  9\\n```\\n\\n# Approach\\n1. We explore tree starting from root.\\n2. For every branch we count number of nodes under it in log(N) time\\n  2.1. If number of nodes is maller than target (k) we reduce target by this amount.\\n  2.2. If number of node is larger we recurde into this branch.\\n  2.3. We subtract 1 from target to account for current node.\\n\\n# Complexity\\n- Time complexity:\\nO(log(N)^2) - depth of recursion * log(N) effort in each level\\n\\n- Space complexity:\\nO(log(N)) - depth of recursion + prefix list size\\n\\n# Code\\n```\\nclass Solution {\\n    int len;\\n\\n    public int findKthNumber(int n, int k) {\\n        len = len(n);\\n        return findNumber(new ArrayList<>(), n, k);\\n    }\\n\\n    private int findNumber(List<Integer> prefix, int max, int target) {\\n        if (target == 0) {\\n            return digitsToNumber(prefix);\\n        }\\n        int tryDigit = prefix.size() == 0 ? 1 : 0;\\n        for (;tryDigit < 10; ++tryDigit) {\\n            prefix.add(tryDigit);\\n            int branchSize = calcBranchSize(prefix, max);\\n            if (branchSize < target) {\\n                target -= branchSize;\\n            } else {\\n                return findNumber(prefix, max, target-1);\\n            }\\n\\n            prefix.remove(prefix.size() - 1);\\n        }\\n        return -1;\\n    }\\n\\n    private int calcBranchSize(List<Integer> prefix, int max) {\\n        int maxSuffixLength = len - prefix.size();\\n        int count = 0;\\n        int mult = 1;\\n        int prefixNumber = digitsToNumber(prefix);\\n        for (int suffixLength = 0; suffixLength <= maxSuffixLength; ++suffixLength) {\\n            int minValue = prefixNumber * mult;\\n            int maxValue = minValue + mult - 1;\\n            if (minValue > max) {\\n                break;\\n            }\\n            if (maxValue > max) {\\n                maxValue = max;\\n            }\\n            int countValues = maxValue - minValue + 1;\\n            count += countValues;\\n            mult *= 10;\\n        }\\n        return count;\\n    }\\n\\n    private int digitsToNumber(List<Integer> digits) {\\n        int number = 0;\\n        for (Integer d : digits) {\\n            number = number * 10 + d;\\n        }\\n        return number;\\n    }\\n\\n    int len(int n) {\\n        int l = 0;\\n        while (n > 0) {\\n            n /= 10;\\n            ++l;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nnothing\\n  1\\n  2\\n  3\\n    ..\\n    34\\n      340\\n      341\\n        3410\\n        3411\\n        3412\\n        ...\\n        3410\\n      342\\n      ...\\n      349\\n    ..\\n  4\\n  ..\\n  9\\n```\n```\\nclass Solution {\\n    int len;\\n\\n    public int findKthNumber(int n, int k) {\\n        len = len(n);\\n        return findNumber(new ArrayList<>(), n, k);\\n    }\\n\\n    private int findNumber(List<Integer> prefix, int max, int target) {\\n        if (target == 0) {\\n            return digitsToNumber(prefix);\\n        }\\n        int tryDigit = prefix.size() == 0 ? 1 : 0;\\n        for (;tryDigit < 10; ++tryDigit) {\\n            prefix.add(tryDigit);\\n            int branchSize = calcBranchSize(prefix, max);\\n            if (branchSize < target) {\\n                target -= branchSize;\\n            } else {\\n                return findNumber(prefix, max, target-1);\\n            }\\n\\n            prefix.remove(prefix.size() - 1);\\n        }\\n        return -1;\\n    }\\n\\n    private int calcBranchSize(List<Integer> prefix, int max) {\\n        int maxSuffixLength = len - prefix.size();\\n        int count = 0;\\n        int mult = 1;\\n        int prefixNumber = digitsToNumber(prefix);\\n        for (int suffixLength = 0; suffixLength <= maxSuffixLength; ++suffixLength) {\\n            int minValue = prefixNumber * mult;\\n            int maxValue = minValue + mult - 1;\\n            if (minValue > max) {\\n                break;\\n            }\\n            if (maxValue > max) {\\n                maxValue = max;\\n            }\\n            int countValues = maxValue - minValue + 1;\\n            count += countValues;\\n            mult *= 10;\\n        }\\n        return count;\\n    }\\n\\n    private int digitsToNumber(List<Integer> digits) {\\n        int number = 0;\\n        for (Integer d : digits) {\\n            number = number * 10 + d;\\n        }\\n        return number;\\n    }\\n\\n    int len(int n) {\\n        int l = 0;\\n        while (n > 0) {\\n            n /= 10;\\n            ++l;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052161,
                "title": "fast-python-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to find the kth number in the lexicographic order of all the numbers from 1 to n. The idea is to use a combination of breadth-first search and dynamic programming to find the kth number in a fast and efficient manner.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use a breadth-first search algorithm that starts from 1 and goes through all the possible numbers from 1 to n. The algorithm checks the number of numbers that can be formed from the current number and if it is less than or equal to k, it will move on to the next number and subtract the number of formed numbers from k. If it is greater than k, the algorithm will move to the next digit by multiplying the current number by 10.\\n\\n\\n# Complexity\\n- Time complexity: O(log(n)^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        if k == 1:\\n            return 1\\n        k -= 1\\n        cur = 1\\n        while k > 0:\\n            steps = self.getSteps(n, cur, cur+1)\\n            if steps <= k:\\n                cur += 1\\n                k -= steps\\n            else:\\n                cur *= 10\\n                k -= 1\\n        return cur\\n\\n    def getSteps(self, n, n1, n2):\\n        steps = 0\\n        while n1 <= n:\\n            steps += min(n+1, n2) - n1\\n            n1 *= 10\\n            n2 *= 10\\n        return steps\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        if k == 1:\\n            return 1\\n        k -= 1\\n        cur = 1\\n        while k > 0:\\n            steps = self.getSteps(n, cur, cur+1)\\n            if steps <= k:\\n                cur += 1\\n                k -= steps\\n            else:\\n                cur *= 10\\n                k -= 1\\n        return cur\\n\\n    def getSteps(self, n, n1, n2):\\n        steps = 0\\n        while n1 <= n:\\n            steps += min(n+1, n2) - n1\\n            n1 *= 10\\n            n2 *= 10\\n        return steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959839,
                "title": "k-th-smallest-in-lexicographical-order-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n       int result = 1;\\n        for(--k; k > 0; )\\n        {            int count = 0;\\n            for (long long first = static_cast<long long>(result), last = first + 1;\\n                first <= n; \\n                first *= 10, last *= 10) \\n            {\\n                count += static_cast<int>((min(n + 1LL, last) - first)); \\n            }\\n            \\n            if (k >= count)\\n            {   \\n                ++result;\\n                k -= count;\\n            }\\n            else\\n            {   \\n                result *= 10;\\n                --k;\\n            }\\n        }\\n        return result; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n       int result = 1;\\n        for(--k; k > 0; )\\n        {            int count = 0;\\n            for (long long first = static_cast<long long>(result), last = first + 1;\\n                first <= n; \\n                first *= 10, last *= 10) \\n            {\\n                count += static_cast<int>((min(n + 1LL, last) - first)); \\n            }\\n            \\n            if (k >= count)\\n            {   \\n                ++result;\\n                k -= count;\\n            }\\n            else\\n            {   \\n                result *= 10;\\n                --k;\\n            }\\n        }\\n        return result; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844506,
                "title": "perfectly-working",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def findKthNumber(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        result = 0\\n\\n        cnts = [0] * 10\\n        for i in xrange(1, 10):\\n            cnts[i] = cnts[i - 1] * 10 + 1\\n\\n        nums = []\\n        i = n\\n        while i:\\n            nums.append(i % 10)\\n            i /= 10\\n\\n        total, target = n, 0\\n        i = len(nums) - 1\\n        while i >= 0 and k > 0:\\n            target = target*10 + nums[i]\\n            start = int(i == len(nums)-1)\\n            for j in xrange(start, 10):\\n                candidate = result*10 + j\\n                if candidate < target:\\n                    num = cnts[i+1]\\n                elif candidate > target:\\n                    num = cnts[i]\\n                else:\\n                    num = total - cnts[i + 1]*(j-start) - cnts[i]*(9-j)\\n                if k > num:\\n                    k -= num\\n                else:\\n                    result = candidate\\n                    k -= 1\\n                    total = num-1\\n                    break\\n            i -= 1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findKthNumber(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        result = 0\\n\\n        cnts = [0] * 10\\n        for i in xrange(1, 10):\\n            cnts[i] = cnts[i - 1] * 10 + 1\\n\\n        nums = []\\n        i = n\\n        while i:\\n            nums.append(i % 10)\\n            i /= 10\\n\\n        total, target = n, 0\\n        i = len(nums) - 1\\n        while i >= 0 and k > 0:\\n            target = target*10 + nums[i]\\n            start = int(i == len(nums)-1)\\n            for j in xrange(start, 10):\\n                candidate = result*10 + j\\n                if candidate < target:\\n                    num = cnts[i+1]\\n                elif candidate > target:\\n                    num = cnts[i]\\n                else:\\n                    num = total - cnts[i + 1]*(j-start) - cnts[i]*(9-j)\\n                if k > num:\\n                    k -= num\\n                else:\\n                    result = candidate\\n                    k -= 1\\n                    total = num-1\\n                    break\\n            i -= 1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744947,
                "title": "ruby",
                "content": "a bit verbose but posting since there are no other ruby solutions\\n\\n```\\ndef find_kth_number(n, k)\\n  n = n.to_s\\n\\n  # count numbers from 1..n that start with a prefix\\n  count = -> prefix { \\n    prefix==n ? 1 : n.start_with?(prefix) ? 1 + (?0..?9).sum{ count[prefix+_1] } :\\n      (0..(n.size-prefix.size).then{ prefix < n ? _1 : _1-1 }).sum{10**_1}\\n  }\\n  \\n  get = -> k,prefix=\\'\\'{\\n    i = prefix[0] ? ?0 : ?1\\n    i.next! while k >= t=count[prefix+i] and k-=t\\n    k>0 ? get[k-1, prefix+i] : prefix+i\\n  }\\n  \\n  get[k-1].to_i\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef find_kth_number(n, k)\\n  n = n.to_s\\n\\n  # count numbers from 1..n that start with a prefix\\n  count = -> prefix { \\n    prefix==n ? 1 : n.start_with?(prefix) ? 1 + (?0..?9).sum{ count[prefix+_1] } :\\n      (0..(n.size-prefix.size).then{ prefix < n ? _1 : _1-1 }).sum{10**_1}\\n  }\\n  \\n  get = -> k,prefix=\\'\\'{\\n    i = prefix[0] ? ?0 : ?1\\n    i.next! while k >= t=count[prefix+i] and k-=t\\n    k>0 ? get[k-1, prefix+i] : prefix+i\\n  }\\n  \\n  get[k-1].to_i\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2742375,
                "title": "tle-solution-but-very-easy-to-understand",
                "content": "```\\n List<Integer>lis=new ArrayList<>();\\n    public int findKthNumber(int n, int k) {\\n        for(int i=1;i<=9;i++){\\n            //if(lis.size()==k) break;\\n            cal(i,n,k);\\n        }\\n        //System.out.print(lis);\\n        return lis.get(k-1);\\n        \\n        \\n    }\\n    void cal(int i,int n,int k){\\n         if(lis.size()==k) return;\\n        if(i>n){\\n            return;\\n        }\\n        lis.add(i);\\n       \\n        \\n        for(int j=0;j<=9;j++){\\n            cal(i*10+j,n,k);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n List<Integer>lis=new ArrayList<>();\\n    public int findKthNumber(int n, int k) {\\n        for(int i=1;i<=9;i++){\\n            //if(lis.size()==k) break;\\n            cal(i,n,k);\\n        }\\n        //System.out.print(lis);\\n        return lis.get(k-1);\\n        \\n        \\n    }\\n    void cal(int i,int n,int k){\\n         if(lis.size()==k) return;\\n        if(i>n){\\n            return;\\n        }\\n        lis.add(i);\\n       \\n        \\n        for(int j=0;j<=9;j++){\\n            cal(i*10+j,n,k);\\n        }\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2703762,
                "title": "decision-from-the-head-binary-search-solution-python",
                "content": "Following the definition of \"Lexicographical order\", I determined all the digits from the highest digit to the lowest digit.\\n\\nIf the prefix of some number is fixed, we can find the number of x (>= 0)which satisfies concat(det_num + x) <= n, efficiently by binary-search.\\n\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        ans, sum = 0, 0\\n        while sum < k:\\n            ans = ans * 10\\n            for d in range(int(sum == 0), 10):\\n                if sum + self.subfunc(ans + d, n) >= k: \\n                    sum += 1\\n                    ans += d\\n                    break\\n                else:\\n                    sum += self.subfunc(ans + d, n)\\n        return ans\\n\\n    def subfunc(self, det_num : int, n : int) -> int:\\n        #the number of number x (>= 0) which satisfies: concat(det_num + x) <= n\\n        #note that [09], [9] are distinct beacause leading-zeros matter.\\n        #(ex) 10 + [09] = 1009 !=  10 + [9]  = 109.\\n\\n        ans = 0\\n        while det_num <= n:\\n            ans += self._subfunc(det_num, n)\\n            det_num *= 10\\n        return ans\\n\\n    def _subfunc(self, det_num : int, n : int) -> int:\\n        #the number of number x (>= 1) which satisfies: concat(det_num + x) <= n\\n        #this case we ignore leading-zeros\\n\\n        ok, ng = 1, int(1e9 + 1)\\n        convert = lambda x: int(str(det_num) + str(x))\\n        if convert(ok) > n:\\n            return int(det_num <= n)\\n        while ng - ok > 1:\\n            mid = (ng + ok) // 2\\n            if convert(mid) <= n:\\n                ok = mid\\n            else:\\n                ng = mid\\n        return ok + int(det_num <= n)\\n\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        ans, sum = 0, 0\\n        while sum < k:\\n            ans = ans * 10\\n            for d in range(int(sum == 0), 10):\\n                if sum + self.subfunc(ans + d, n) >= k: \\n                    sum += 1\\n                    ans += d\\n                    break\\n                else:\\n                    sum += self.subfunc(ans + d, n)\\n        return ans\\n\\n    def subfunc(self, det_num : int, n : int) -> int:\\n        #the number of number x (>= 0) which satisfies: concat(det_num + x) <= n\\n        #note that [09], [9] are distinct beacause leading-zeros matter.\\n        #(ex) 10 + [09] = 1009 !=  10 + [9]  = 109.\\n\\n        ans = 0\\n        while det_num <= n:\\n            ans += self._subfunc(det_num, n)\\n            det_num *= 10\\n        return ans\\n\\n    def _subfunc(self, det_num : int, n : int) -> int:\\n        #the number of number x (>= 1) which satisfies: concat(det_num + x) <= n\\n        #this case we ignore leading-zeros\\n\\n        ok, ng = 1, int(1e9 + 1)\\n        convert = lambda x: int(str(det_num) + str(x))\\n        if convert(ok) > n:\\n            return int(det_num <= n)\\n        while ng - ok > 1:\\n            mid = (ng + ok) // 2\\n            if convert(mid) <= n:\\n                ok = mid\\n            else:\\n                ng = mid\\n        return ok + int(det_num <= n)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662246,
                "title": "javascript-easy-to-understand",
                "content": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number}\\n */\\nvar findKthNumber = function(n, k) {\\n    let curr = 1\\n    k--\\n    while (k > 0) {\\n        let steps = getSteps(n, curr, curr + 1)\\n        if (steps <= k) {\\n            curr++\\n            k -= steps\\n        } else {\\n            curr *= 10\\n            k--\\n        }\\n    }\\n    return curr\\n};\\n\\nfunction getSteps(n, n1, n2) {\\n    let steps = 0\\n    while (n1 <= n) {\\n        steps += Math.min(n + 1, n2) - n1\\n        n1 *= 10\\n        n2 *= 10\\n    }\\n    return steps\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} k\\n * @return {number}\\n */\\nvar findKthNumber = function(n, k) {\\n    let curr = 1\\n    k--\\n    while (k > 0) {\\n        let steps = getSteps(n, curr, curr + 1)\\n        if (steps <= k) {\\n            curr++\\n            k -= steps\\n        } else {\\n            curr *= 10\\n            k--\\n        }\\n    }\\n    return curr\\n};\\n\\nfunction getSteps(n, n1, n2) {\\n    let steps = 0\\n    while (n1 <= n) {\\n        steps += Math.min(n + 1, n2) - n1\\n        n1 *= 10\\n        n2 *= 10\\n    }\\n    return steps\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2662097,
                "title": "recursive-solution-gives-tle-but-easier-to-understand",
                "content": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        return recursiveSolution(n,k);\\n    }\\n    \\n    String res  = \"\";\\n    int counter = 0;\\n    \\n    public int recursiveSolution(int n, int k){\\n                \\n        for(int i=1;i<10;i++)\\n            recursionHelper(n,k,i+\"\");\\n        \\n        return Integer.valueOf(res);\\n    }\\n    \\n    public void recursionHelper(int n,int k, String curr){\\n        \\n        if(Integer.valueOf(curr)>n)\\n            return ;\\n        \\n        counter++;\\n        \\n        if(counter==k){\\n            res = curr;\\n            return;\\n        }\\n        for(int i=0;i<10;i++){\\n            if(counter<=k)\\n                recursionHelper(n,k,curr+i);\\n        }\\n        \\n        return ;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        return recursiveSolution(n,k);\\n    }\\n    \\n    String res  = \"\";\\n    int counter = 0;\\n    \\n    public int recursiveSolution(int n, int k){\\n                \\n        for(int i=1;i<10;i++)\\n            recursionHelper(n,k,i+\"\");\\n        \\n        return Integer.valueOf(res);\\n    }\\n    \\n    public void recursionHelper(int n,int k, String curr){\\n        \\n        if(Integer.valueOf(curr)>n)\\n            return ;\\n        \\n        counter++;\\n        \\n        if(counter==k){\\n            res = curr;\\n            return;\\n        }\\n        for(int i=0;i<10;i++){\\n            if(counter<=k)\\n                recursionHelper(n,k,curr+i);\\n        }\\n        \\n        return ;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580379,
                "title": "weird-tree-solution-python",
                "content": "```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        \\n        def findK(n, k, depth):\\n            if k == 0:\\n                return \"\"\\n            min_tree_depth = 0 if n < 10 else floor(math.log10(n)) \\n            min_tree_size = 0 if min_tree_depth <= 0 else int(\"\".join([\"1\" for _ in range(min_tree_depth)]))\\n            max_tree_size = int(str(min_tree_size)+\"1\")\\n            total_nodes = n\\n            if depth != 0:\\n                total_nodes = n\\n            child_size = [min_tree_size for _ in range(0, 10)]\\n            for child in range(10):\\n                if(child == 0 and depth == 0):\\n                    child_size[0] = 0\\n                    continue\\n                child_size[child] = max(min(max_tree_size, total_nodes - min_tree_size * (9 - child)), min_tree_size)\\n                total_nodes -= child_size[child]\\n                if(child_size[child] != max_tree_size):\\n                    break\\n\\n            total = 0\\n            for i in range(10):\\n                if total + child_size[i] >= k:\\n                    return str(i) + findK(child_size[i] - 1, k - total - 1, depth + 1)\\n                total += child_size[i]\\n                \\n        \\n        return int(findK(n, k, 0))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        \\n        def findK(n, k, depth):\\n            if k == 0:\\n                return \"\"\\n            min_tree_depth = 0 if n < 10 else floor(math.log10(n)) \\n            min_tree_size = 0 if min_tree_depth <= 0 else int(\"\".join([\"1\" for _ in range(min_tree_depth)]))\\n            max_tree_size = int(str(min_tree_size)+\"1\")\\n            total_nodes = n\\n            if depth != 0:\\n                total_nodes = n\\n            child_size = [min_tree_size for _ in range(0, 10)]\\n            for child in range(10):\\n                if(child == 0 and depth == 0):\\n                    child_size[0] = 0\\n                    continue\\n                child_size[child] = max(min(max_tree_size, total_nodes - min_tree_size * (9 - child)), min_tree_size)\\n                total_nodes -= child_size[child]\\n                if(child_size[child] != max_tree_size):\\n                    break\\n\\n            total = 0\\n            for i in range(10):\\n                if total + child_size[i] >= k:\\n                    return str(i) + findK(child_size[i] - 1, k - total - 1, depth + 1)\\n                total += child_size[i]\\n                \\n        \\n        return int(findK(n, k, 0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498070,
                "title": "python-solution-log-n-2-time",
                "content": "For this solution I first wrote a function that returns the lexicographic position of a number between 1 and n, which takes log n time, then proceeded by bisection (in fact 10-section).\\nThe position function is based on the fact that among numbers of the same length the lexicographic order is the same as the usual order. Then one has to see where the given number would place among numbers of different lengths.\\nI do not know how to incorporate a trie into the solution, other than in the obvious way that would make the solution exceed the time limits.\\n\\n\\tdef findKthNumber(n, k):        \\n\\t\\tdef place2(n, n0):\\n\\t\\t\\tl=int(log10(n))\\n\\t\\t\\tl0=int(log10(n0))\\n\\t\\t\\tn-=10**l\\n\\t\\t\\tn0-=10**l0\\n\\t\\t\\tif l==l0:\\n\\t\\t\\t\\tans=min(n, n0)+1\\n\\t\\t\\t\\tn//=10\\n\\t\\t\\t\\tl-=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttmp=n*10**(l0-l)\\n\\t\\t\\t\\tans=min(n0+1, tmp)\\n\\t\\t\\tfor i in range(l+1, l0):\\n\\t\\t\\t\\tans+=n*(10**(i-l))\\n\\t\\t\\twhile n>=1:\\n\\t\\t\\t\\tans+=n\\n\\t\\t\\t\\tn//=10\\n\\t\\t\\tans+=l+1\\n\\t\\t\\treturn ans\\n\\n\\t\\ti=1\\n\\t\\twhile i<10:\\n\\t\\t\\ttmp=place2(i, n)\\n\\t\\t\\tif tmp>k:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif tmp==k:\\n\\t\\t\\t\\treturn i\\n\\t\\t\\ti+=1\\n\\t\\tans=i-1\\n\\t\\twhile True:\\n\\t\\t\\tans*=10\\n\\t\\t\\ti=0\\n\\t\\t\\twhile i<10:\\n\\t\\t\\t\\ttmp=place2(ans+i, n)\\n\\t\\t\\t\\tif tmp>k:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telif tmp==k:\\n\\t\\t\\t\\t\\treturn ans+i\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\tans+=i-1",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "For this solution I first wrote a function that returns the lexicographic position of a number between 1 and n, which takes log n time, then proceeded by bisection (in fact 10-section).\\nThe position function is based on the fact that among numbers of the same length the lexicographic order is the same as the usual order. Then one has to see where the given number would place among numbers of different lengths.\\nI do not know how to incorporate a trie into the solution, other than in the obvious way that would make the solution exceed the time limits.\\n\\n\\tdef findKthNumber(n, k):        \\n\\t\\tdef place2(n, n0):\\n\\t\\t\\tl=int(log10(n))\\n\\t\\t\\tl0=int(log10(n0))\\n\\t\\t\\tn-=10**l\\n\\t\\t\\tn0-=10**l0\\n\\t\\t\\tif l==l0:\\n\\t\\t\\t\\tans=min(n, n0)+1\\n\\t\\t\\t\\tn//=10\\n\\t\\t\\t\\tl-=1\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttmp=n*10**(l0-l)\\n\\t\\t\\t\\tans=min(n0+1, tmp)\\n\\t\\t\\tfor i in range(l+1, l0):\\n\\t\\t\\t\\tans+=n*(10**(i-l))\\n\\t\\t\\twhile n>=1:\\n\\t\\t\\t\\tans+=n\\n\\t\\t\\t\\tn//=10\\n\\t\\t\\tans+=l+1\\n\\t\\t\\treturn ans\\n\\n\\t\\ti=1\\n\\t\\twhile i<10:\\n\\t\\t\\ttmp=place2(i, n)\\n\\t\\t\\tif tmp>k:\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif tmp==k:\\n\\t\\t\\t\\treturn i\\n\\t\\t\\ti+=1\\n\\t\\tans=i-1\\n\\t\\twhile True:\\n\\t\\t\\tans*=10\\n\\t\\t\\ti=0\\n\\t\\t\\twhile i<10:\\n\\t\\t\\t\\ttmp=place2(ans+i, n)\\n\\t\\t\\t\\tif tmp>k:\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telif tmp==k:\\n\\t\\t\\t\\t\\treturn ans+i\\n\\t\\t\\t\\ti+=1\\n\\t\\t\\tans+=i-1",
                "codeTag": "Python3"
            },
            {
                "id": 2346192,
                "title": "go-simple-dfs-solution-with-explain",
                "content": "```\\n// package q_440\\n\\n/**\\n  440. K-th Smallest in Lexicographical Order\\n  Hard\\n\\n  579\\n\\n  73\\n\\n  Add to List\\n\\n  Share\\n  Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].\\n\\n\\n\\n  Example 1:\\n\\n  Input: n = 13, k = 2\\n  Output: 10\\n  Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\\n  Example 2:\\n\\n  Input: n = 1, k = 1\\n  Output: 1\\n\\n\\n  Constraints:\\n\\n  1 <= k <= n <= 109\\n*/\\n\\nconst (\\n\\tnilResult = -1\\n\\tdigitBase = 10\\n)\\n\\ntype Solution struct{}\\n\\n// countPrefixCombination\\n// count all the nums with prefix lees or equal to n\\n// include prefix itself\\nfunc (s *Solution) countPrefixCombination(n, prefix int) (retCount int) {\\n\\tif prefix > n {\\n\\t\\tretCount = 0\\n\\t\\treturn retCount\\n\\t}\\n\\tif prefix == n {\\n\\t\\tretCount = 1\\n\\t\\treturn retCount\\n\\t}\\n\\n\\tretCount = 1 // prefix itself\\n\\tnextMin, nextMax := prefix, prefix\\n\\tfor true {\\n\\t\\tnextMin = nextMin * digitBase\\n\\t\\tnextMax = nextMax*digitBase + digitBase - 1\\n\\t\\tif n < nextMin {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif n <= nextMax {\\n\\t\\t\\tretCount += n - nextMin + 1\\n\\t\\t\\tbreak\\n\\t\\t} else {\\n\\t\\t\\tretCount += nextMax - nextMin + 1\\n\\t\\t}\\n\\t}\\n\\treturn retCount\\n}\\n\\n// findKthNumberImpl\\n// make suer 1<=k<=n\\nfunc (s *Solution) findKthNumberImpl(n, k, prefix int) (retResult int) {\\n\\tif k == 0 {\\n\\t\\tretResult = prefix\\n\\t\\treturn retResult\\n\\t}\\n\\tnextStartDigit := 0\\n\\tif prefix == 0 {\\n\\t\\tnextStartDigit = 1\\n\\t}\\n\\tfor ; nextStartDigit < digitBase; nextStartDigit++ {\\n\\t\\tnextPrefix := prefix*digitBase + nextStartDigit\\n\\t\\tnextPrefixCount := s.countPrefixCombination(n, nextPrefix)\\n\\t\\tif nextPrefixCount >= k {\\n\\t\\t\\t// skip nextPrefix itself will not be count anymore\\n\\t\\t\\t// so k-1\\n\\t\\t\\tretResult = s.findKthNumberImpl(n, k-1, nextPrefix)\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tk -= nextPrefixCount\\n\\t}\\n\\treturn retResult\\n}\\n\\nfunc (s *Solution) FindKthNumberImpl(n, k int) (retResult int) {\\n\\tif k <= 0 || n <= 0 || n < k {\\n\\t\\tretResult = nilResult\\n\\t\\treturn retResult\\n\\t}\\n\\tretResult = s.findKthNumberImpl(n, k, 0)\\n\\treturn retResult\\n}\\n\\nfunc findKthNumber(n int, k int) (retResult int) {\\n\\tsolution := Solution{}\\n\\tretResult = solution.FindKthNumberImpl(n, k)\\n\\treturn retResult\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// package q_440\\n\\n/**\\n  440. K-th Smallest in Lexicographical Order\\n  Hard\\n\\n  579\\n\\n  73\\n\\n  Add to List\\n\\n  Share\\n  Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].\\n\\n\\n\\n  Example 1:\\n\\n  Input: n = 13, k = 2\\n  Output: 10\\n  Explanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.\\n  Example 2:\\n\\n  Input: n = 1, k = 1\\n  Output: 1\\n\\n\\n  Constraints:\\n\\n  1 <= k <= n <= 109\\n*/\\n\\nconst (\\n\\tnilResult = -1\\n\\tdigitBase = 10\\n)\\n\\ntype Solution struct{}\\n\\n// countPrefixCombination\\n// count all the nums with prefix lees or equal to n\\n// include prefix itself\\nfunc (s *Solution) countPrefixCombination(n, prefix int) (retCount int) {\\n\\tif prefix > n {\\n\\t\\tretCount = 0\\n\\t\\treturn retCount\\n\\t}\\n\\tif prefix == n {\\n\\t\\tretCount = 1\\n\\t\\treturn retCount\\n\\t}\\n\\n\\tretCount = 1 // prefix itself\\n\\tnextMin, nextMax := prefix, prefix\\n\\tfor true {\\n\\t\\tnextMin = nextMin * digitBase\\n\\t\\tnextMax = nextMax*digitBase + digitBase - 1\\n\\t\\tif n < nextMin {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif n <= nextMax {\\n\\t\\t\\tretCount += n - nextMin + 1\\n\\t\\t\\tbreak\\n\\t\\t} else {\\n\\t\\t\\tretCount += nextMax - nextMin + 1\\n\\t\\t}\\n\\t}\\n\\treturn retCount\\n}\\n\\n// findKthNumberImpl\\n// make suer 1<=k<=n\\nfunc (s *Solution) findKthNumberImpl(n, k, prefix int) (retResult int) {\\n\\tif k == 0 {\\n\\t\\tretResult = prefix\\n\\t\\treturn retResult\\n\\t}\\n\\tnextStartDigit := 0\\n\\tif prefix == 0 {\\n\\t\\tnextStartDigit = 1\\n\\t}\\n\\tfor ; nextStartDigit < digitBase; nextStartDigit++ {\\n\\t\\tnextPrefix := prefix*digitBase + nextStartDigit\\n\\t\\tnextPrefixCount := s.countPrefixCombination(n, nextPrefix)\\n\\t\\tif nextPrefixCount >= k {\\n\\t\\t\\t// skip nextPrefix itself will not be count anymore\\n\\t\\t\\t// so k-1\\n\\t\\t\\tretResult = s.findKthNumberImpl(n, k-1, nextPrefix)\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tk -= nextPrefixCount\\n\\t}\\n\\treturn retResult\\n}\\n\\nfunc (s *Solution) FindKthNumberImpl(n, k int) (retResult int) {\\n\\tif k <= 0 || n <= 0 || n < k {\\n\\t\\tretResult = nilResult\\n\\t\\treturn retResult\\n\\t}\\n\\tretResult = s.findKthNumberImpl(n, k, 0)\\n\\treturn retResult\\n}\\n\\nfunc findKthNumber(n int, k int) (retResult int) {\\n\\tsolution := Solution{}\\n\\tretResult = solution.FindKthNumberImpl(n, k)\\n\\treturn retResult\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2218744,
                "title": "c-100-faster-sol",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    int64_t count(int64_t n,int64_t j)\\n    {\\n       \\n        if(j>n) return 0;\\n        \\n        if(j==n) return 1;\\n        \\n        int64_t mx_range=j,mn_range=j;\\n        int64_t ct=1;\\n        \\n        while(1)\\n        {\\n          mx_range=mx_range*10+9;\\n          mn_range=mn_range*10;\\n            \\n            if(mn_range >n) break;\\n           else if(mn_range<=n&&n<=mx_range)\\n            {\\n                ct += (n-mn_range+1);\\n               break;\\n            }\\n            else \\n            {\\n                ct+=(mx_range-mn_range+1);\\n            }    \\n        }\\n        \\n        return ct;\\n    }\\n        \\n        \\n       \\n    int64_t findKthNumber(int64_t n, int64_t k,int64_t ct=0) \\n    {\\n        if(k>0)\\n       {\\n        for(int64_t i=(ct==0 ? 1 :0); i<=9; i++)\\n        {\\n            int64_t num =count(n,ct*10+i);\\n            \\n            if(num>=k) return findKthNumber (n,k-1,ct*10+i);\\n            k-=num;\\n            \\n        }\\n        }\\n        return ct;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    int64_t count(int64_t n,int64_t j)\\n    {\\n       \\n        if(j>n) return 0;\\n        \\n        if(j==n) return 1;\\n        \\n        int64_t mx_range=j,mn_range=j;\\n        int64_t ct=1;\\n        \\n        while(1)\\n        {\\n          mx_range=mx_range*10+9;\\n          mn_range=mn_range*10;\\n            \\n            if(mn_range >n) break;\\n           else if(mn_range<=n&&n<=mx_range)\\n            {\\n                ct += (n-mn_range+1);\\n               break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2154000,
                "title": "recursively-check-the-first-digit",
                "content": "Recursively check the first digit\\n\\n\\n\\n```\\n# Ex: level = 3\\n# X, X0 ~ X9, X00 ~ X99, X000 ~ X999\\n\\n# If no upper_bound:\\n# We can bucket it as:\\n# allow_leading_zero:  [X0, X00 ~ X09, X000 ~ X099] [X1, X10 ~ X19, X100 ~ X199] [X2, X20 ~ X29, X200 ~ X299]...\\n# not_allow_leading_zero: [X1, X10 ~ X19, X100 ~ X199] [X2, X20 ~ X29, X200 ~ X299] ...\\n\\n# If there is upper_bound, ex upper_bound=X375:\\n# We can bucket it as 3 ranges:\\n# [X0, X00 ~ X09, X000 ~ X099] [X1, X10 ~ X19, X100 ~ X199] [X2, X20 ~ X29, X200 ~ X299]\\n# [X3, X30 ~ X39, X300 ~ X375]\\n# [X4, X40 ~ X49] [X5, X50 ~ X59] [X6, X60 ~ X69]\\n\\n# After deciding to search in last range, we are actually search in the following range\\n# [XX, XX0 ~ XX9, XX00 ~ XX75] which is allow_leading_zero=True, level = 2, upper_bound = 75\\ndef find_first_digit(level, k, allow_leading_zero, upper_bound, debug):\\n\\n    if k == 1 and allow_leading_zero:\\n        return \"0\"\\n    elif k == 1:\\n        return \"1\"\\n\\n    # This is k - 1, since elements look like: X0 X1 X2\\n    if level == 1 and allow_leading_zero:\\n        return str(k - 1)\\n\\n    elif level == 1:\\n        return str(k)\\n\\n    head_bucket_size = int((10 ** (level - 1) * 10 - 1) / (10 - 1))\\n    tail_bucket_size = int((10 ** (level - 2) * 10 - 1) / (10 - 1))\\n\\n    total_bucket = 9 + int(allow_leading_zero)\\n    if upper_bound is not None:\\n        upper_bound_leading_digit = int(str(upper_bound)[0])\\n        num_head_bucket = upper_bound_leading_digit - 1 + int(allow_leading_zero)\\n        num_tail_bucket = total_bucket - num_head_bucket - 1\\n\\n        mid_bucket_size = head_bucket_size - (int(str(upper_bound_leading_digit) + \"9\" * (level - 1)) - upper_bound)\\n\\n        head_buckets_range = num_head_bucket * head_bucket_size\\n        tail_buckets_range = num_tail_bucket * tail_bucket_size\\n        mid_bucket_range = mid_bucket_size + head_buckets_range\\n        tail_buckets_range += mid_bucket_range\\n    else:\\n        num_head_bucket = total_bucket\\n\\n        head_buckets_range = num_head_bucket * head_bucket_size\\n        mid_bucket_range = head_buckets_range\\n        tail_buckets_range = head_buckets_range\\n\\n    if debug:\\n        print(head_buckets_range, mid_bucket_range, tail_buckets_range)\\n\\n    if k <= mid_bucket_range:\\n        mod = k % head_bucket_size\\n        if mod == 0:\\n            skipped_buckets = k // head_bucket_size - 1\\n        else:\\n            skipped_buckets = k // head_bucket_size\\n\\n        if allow_leading_zero:\\n            leading_digit = str(skipped_buckets)\\n        else:\\n            leading_digit = str(skipped_buckets + 1)\\n\\n        if mod == 1:\\n            return leading_digit\\n\\n        # We have skipped skipped_buckets * bucket_size elements\\n        skipped_elements = skipped_buckets * head_bucket_size + 1\\n        next_k = k - skipped_elements\\n\\n        new_upper_bound = None\\n        if upper_bound is not None and leading_digit == str(upper_bound)[0]:\\n            new_upper_bound = int(str(upper_bound)[1:]) if len(str(upper_bound)) > 1 else 0\\n\\n        next_res = find_first_digit(level - 1, next_k, allow_leading_zero=True, upper_bound=new_upper_bound, debug=False)\\n\\n        return str(leading_digit) + next_res\\n\\n    else:\\n        k -= mid_bucket_range\\n\\n        mod = k % tail_bucket_size\\n\\n        if mod == 0:\\n            skipped_buckets = k // tail_bucket_size - 1\\n        else:\\n            skipped_buckets = k // tail_bucket_size\\n\\n        leading_digit = str(upper_bound_leading_digit + skipped_buckets + 1)\\n\\n        if mod == 1 or tail_bucket_size == 1:\\n            return leading_digit\\n\\n        # We have skipped skipped_buckets * bucket_size elements\\n        skipped_elements = skipped_buckets * tail_bucket_size + 1\\n        next_k = k - skipped_elements\\n\\n        next_res = find_first_digit(level - 2, next_k, allow_leading_zero=True, upper_bound=None, debug=False)\\n\\n        return str(leading_digit) + next_res\\n\\n\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int, debug=False) -> int:\\n        if debug:\\n            a = list(range(1, n + 1))\\n            a = [str(v) for v in a]\\n            a.sort()\\n            answer = a[k - 1]\\n            print(f\"answer={answer}\")\\n\\n        level = len(str(n))\\n\\n        res = find_first_digit(level, k, allow_leading_zero=False, upper_bound=n, debug=debug)\\n        return res\\n\\n\\nif __name__ == \\'__main__\\':\\n    # r = Solution().findKthNumber(n=100, k=3, debug=True)\\n    # print(r)\\n    pass\\n```",
                "solutionTags": [],
                "code": "```\\n# Ex: level = 3\\n# X, X0 ~ X9, X00 ~ X99, X000 ~ X999\\n\\n# If no upper_bound:\\n# We can bucket it as:\\n# allow_leading_zero:  [X0, X00 ~ X09, X000 ~ X099] [X1, X10 ~ X19, X100 ~ X199] [X2, X20 ~ X29, X200 ~ X299]...\\n# not_allow_leading_zero: [X1, X10 ~ X19, X100 ~ X199] [X2, X20 ~ X29, X200 ~ X299] ...\\n\\n# If there is upper_bound, ex upper_bound=X375:\\n# We can bucket it as 3 ranges:\\n# [X0, X00 ~ X09, X000 ~ X099] [X1, X10 ~ X19, X100 ~ X199] [X2, X20 ~ X29, X200 ~ X299]\\n# [X3, X30 ~ X39, X300 ~ X375]\\n# [X4, X40 ~ X49] [X5, X50 ~ X59] [X6, X60 ~ X69]\\n\\n# After deciding to search in last range, we are actually search in the following range\\n# [XX, XX0 ~ XX9, XX00 ~ XX75] which is allow_leading_zero=True, level = 2, upper_bound = 75\\ndef find_first_digit(level, k, allow_leading_zero, upper_bound, debug):\\n\\n    if k == 1 and allow_leading_zero:\\n        return \"0\"\\n    elif k == 1:\\n        return \"1\"\\n\\n    # This is k - 1, since elements look like: X0 X1 X2\\n    if level == 1 and allow_leading_zero:\\n        return str(k - 1)\\n\\n    elif level == 1:\\n        return str(k)\\n\\n    head_bucket_size = int((10 ** (level - 1) * 10 - 1) / (10 - 1))\\n    tail_bucket_size = int((10 ** (level - 2) * 10 - 1) / (10 - 1))\\n\\n    total_bucket = 9 + int(allow_leading_zero)\\n    if upper_bound is not None:\\n        upper_bound_leading_digit = int(str(upper_bound)[0])\\n        num_head_bucket = upper_bound_leading_digit - 1 + int(allow_leading_zero)\\n        num_tail_bucket = total_bucket - num_head_bucket - 1\\n\\n        mid_bucket_size = head_bucket_size - (int(str(upper_bound_leading_digit) + \"9\" * (level - 1)) - upper_bound)\\n\\n        head_buckets_range = num_head_bucket * head_bucket_size\\n        tail_buckets_range = num_tail_bucket * tail_bucket_size\\n        mid_bucket_range = mid_bucket_size + head_buckets_range\\n        tail_buckets_range += mid_bucket_range\\n    else:\\n        num_head_bucket = total_bucket\\n\\n        head_buckets_range = num_head_bucket * head_bucket_size\\n        mid_bucket_range = head_buckets_range\\n        tail_buckets_range = head_buckets_range\\n\\n    if debug:\\n        print(head_buckets_range, mid_bucket_range, tail_buckets_range)\\n\\n    if k <= mid_bucket_range:\\n        mod = k % head_bucket_size\\n        if mod == 0:\\n            skipped_buckets = k // head_bucket_size - 1\\n        else:\\n            skipped_buckets = k // head_bucket_size\\n\\n        if allow_leading_zero:\\n            leading_digit = str(skipped_buckets)\\n        else:\\n            leading_digit = str(skipped_buckets + 1)\\n\\n        if mod == 1:\\n            return leading_digit\\n\\n        # We have skipped skipped_buckets * bucket_size elements\\n        skipped_elements = skipped_buckets * head_bucket_size + 1\\n        next_k = k - skipped_elements\\n\\n        new_upper_bound = None\\n        if upper_bound is not None and leading_digit == str(upper_bound)[0]:\\n            new_upper_bound = int(str(upper_bound)[1:]) if len(str(upper_bound)) > 1 else 0\\n\\n        next_res = find_first_digit(level - 1, next_k, allow_leading_zero=True, upper_bound=new_upper_bound, debug=False)\\n\\n        return str(leading_digit) + next_res\\n\\n    else:\\n        k -= mid_bucket_range\\n\\n        mod = k % tail_bucket_size\\n\\n        if mod == 0:\\n            skipped_buckets = k // tail_bucket_size - 1\\n        else:\\n            skipped_buckets = k // tail_bucket_size\\n\\n        leading_digit = str(upper_bound_leading_digit + skipped_buckets + 1)\\n\\n        if mod == 1 or tail_bucket_size == 1:\\n            return leading_digit\\n\\n        # We have skipped skipped_buckets * bucket_size elements\\n        skipped_elements = skipped_buckets * tail_bucket_size + 1\\n        next_k = k - skipped_elements\\n\\n        next_res = find_first_digit(level - 2, next_k, allow_leading_zero=True, upper_bound=None, debug=False)\\n\\n        return str(leading_digit) + next_res\\n\\n\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int, debug=False) -> int:\\n        if debug:\\n            a = list(range(1, n + 1))\\n            a = [str(v) for v in a]\\n            a.sort()\\n            answer = a[k - 1]\\n            print(f\"answer={answer}\")\\n\\n        level = len(str(n))\\n\\n        res = find_first_digit(level, k, allow_leading_zero=False, upper_bound=n, debug=debug)\\n        return res\\n\\n\\nif __name__ == \\'__main__\\':\\n    # r = Solution().findKthNumber(n=100, k=3, debug=True)\\n    # print(r)\\n    pass\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151145,
                "title": "c-solution-two-approaches-brute-dfs-and-optimised-versions",
                "content": "* Brute force DFS:\\n```\\n#define ll long long\\n#define vb vector<bool>\\n#define vi vector<int>\\n#define vl vector<long long>\\n#define vvb vector<vector<bool>>\\n#define vvi vector<vector<int>>\\n#define vvl vector<vector<long long>>\\n#define pii pair<int,int>\\n#define all(i) i.begin(),i.end()\\n#define f(i,s,e) for(int i = s; i < e; i++)\\n#define b(i,s,e) for(int i = s; i >= e; i--)\\ninline int getMid(int i,int j) { return i+(j-i)/2; }\\n\\nclass Solution {\\npublic:\\n    int k, n;\\n\\n    int dfs(ll num) {\\n        if(num > n) return 0;\\n        k--;\\n        if(k == 0) return num;\\n        f(i,0,10) {\\n            ll ret = dfs(num*10+i);\\n            if(k == 0) return ret;\\n        }\\n        return 0;\\n    }\\n\\n    int findKthNumber(int n, int k) {\\n        f(i,0,n) {\\n            ll ret = dfs(i);\\n            if(k == 0) return ret;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n* Optimised version: As determining the node count before hand is an `O(log n)` function unlike doing the DFS which actually take `O(n)` time. \\n```\\n#define ll long long\\n#define vb vector<bool>\\n#define vi vector<int>\\n#define vl vector<long long>\\n#define vvb vector<vector<bool>>\\n#define vvi vector<vector<int>>\\n#define vvl vector<vector<long long>>\\n#define pii pair<int,int>\\n#define all(i) i.begin(),i.end()\\n#define f(i,s,e) for(int i = s; i < e; i++)\\n#define b(i,s,e) for(int i = s; i >= e; i--)\\ninline int getMid(int i,int j) { return i+(j-i)/2; }\\n\\nclass Solution {\\npublic:\\n    ll n, k;\\n\\n    ll steps(ll node) {\\n        ll l = node, r = node+1, steps = 0;\\n        while(l <= n) {\\n            steps += min(n+1,r)-l;\\n            l *= 10;\\n            r *= 10;\\n        } \\n        return steps;\\n    }\\n\\n    int findKthNumber(int n, int k) {\\n        this->n = n;\\n        this->k = k;\\n        ll node = 1;\\n        ll _k = k-1;\\n        while(_k) {\\n            // cout << \"node \" << node << endl;\\n            int stps = steps(node);\\n            // cout << \"stps \" << stps << endl;\\n            if(stps <= _k) {\\n                node++;\\n                _k -= stps;\\n            } else {\\n                node *= 10;\\n                _k--;\\n            }\\n        }\\n\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n#define vb vector<bool>\\n#define vi vector<int>\\n#define vl vector<long long>\\n#define vvb vector<vector<bool>>\\n#define vvi vector<vector<int>>\\n#define vvl vector<vector<long long>>\\n#define pii pair<int,int>\\n#define all(i) i.begin(),i.end()\\n#define f(i,s,e) for(int i = s; i < e; i++)\\n#define b(i,s,e) for(int i = s; i >= e; i--)\\ninline int getMid(int i,int j) { return i+(j-i)/2; }\\n\\nclass Solution {\\npublic:\\n    int k, n;\\n\\n    int dfs(ll num) {\\n        if(num > n) return 0;\\n        k--;\\n        if(k == 0) return num;\\n        f(i,0,10) {\\n            ll ret = dfs(num*10+i);\\n            if(k == 0) return ret;\\n        }\\n        return 0;\\n    }\\n\\n    int findKthNumber(int n, int k) {\\n        f(i,0,n) {\\n            ll ret = dfs(i);\\n            if(k == 0) return ret;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\n#define ll long long\\n#define vb vector<bool>\\n#define vi vector<int>\\n#define vl vector<long long>\\n#define vvb vector<vector<bool>>\\n#define vvi vector<vector<int>>\\n#define vvl vector<vector<long long>>\\n#define pii pair<int,int>\\n#define all(i) i.begin(),i.end()\\n#define f(i,s,e) for(int i = s; i < e; i++)\\n#define b(i,s,e) for(int i = s; i >= e; i--)\\ninline int getMid(int i,int j) { return i+(j-i)/2; }\\n\\nclass Solution {\\npublic:\\n    ll n, k;\\n\\n    ll steps(ll node) {\\n        ll l = node, r = node+1, steps = 0;\\n        while(l <= n) {\\n            steps += min(n+1,r)-l;\\n            l *= 10;\\n            r *= 10;\\n        } \\n        return steps;\\n    }\\n\\n    int findKthNumber(int n, int k) {\\n        this->n = n;\\n        this->k = k;\\n        ll node = 1;\\n        ll _k = k-1;\\n        while(_k) {\\n            // cout << \"node \" << node << endl;\\n            int stps = steps(node);\\n            // cout << \"stps \" << stps << endl;\\n            if(stps <= _k) {\\n                node++;\\n                _k -= stps;\\n            } else {\\n                node *= 10;\\n                _k--;\\n            }\\n        }\\n\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2101504,
                "title": "correct-java-solution-using-heap-but-getting-tle-someone-please-help",
                "content": "class Solution {\\n    List<Integer> ans= new ArrayList<>();\\n    \\n     public int findKthNumber(int n, int k) {\\n        lexicalorder(n);         \\n        int a= ans.get(k-1);\\n        return a;\\n    }\\n    \\n    public void lexicalorder(int n)\\n    {\\n        for(int i=1; i<=9; i++){\\n            helper(i,n);\\n        }\\n    }\\n    \\n    public void helper(int x, int n){\\n        if(x<=n){\\n            ans.add(x);\\n        }\\n        else{\\n            return;\\n        }\\n        for(int i=0; i<=9; i++){\\n            helper(x*10+i, n);\\n        }\\n    }\\n        \\n   \\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    List<Integer> ans= new ArrayList<>();\\n    \\n     public int findKthNumber(int n, int k) {\\n        lexicalorder(n);         \\n        int a= ans.get(k-1);\\n        return a;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2038661,
                "title": "o-log-n-prefix-geometric-sum",
                "content": "Given some `n` with decimal representation `a_0 ... a_j`, we need to find the `k`th lexicographically smallest number in the range `[1, n]`.\\n\\n**DIGIT-BY-DIGIT USING PREFIXES**\\nSuppose we want to figure what the first digit for our final answer will be. It can be any of p=1, ..., 9. Let\\'s start with the lexicographically smallest `p = 1`. Denote `count(p)` as the count of numbers in `[1, n]` that start with this prefix `p`. Two things can happen:\\n- `count(p) < k`. Not enough numbers in `[1, n]` start with prefix `p`. Go to the next lexicographically smallest value for this first digit `p + 1`, but now we know precisely `count(p)` numbers are strictly less than anything that starts with the next candidate `p+1`, so we are now looking for the `k\\' = k - count(p)` lexicoraphically smallest number moving forward.\\n- `count(p) >= k`. We\\'ve found the smallest prefix for which we know at least `k` numbers start with `p`, so it has to be the correct prefix. Subtract 1 from `k`, corresponding to the number `p` itself, and we now consider the next lexicographically smallest prefix that has `p` as a prefix of itself, namely `10 * p` (i.e. tacking on a 0 to current `p`).\\n\\nOnce we finally arrive at `k = 0`, we know that our built up prefix `p` corresponds to the final answer.\\n\\n**COMPUTING COUNT FOR A PREFIX: GEOMETRIC SUM**\\nIf `n = a_0...a_j` has `j` digits, and `p = p_0...p_i` has `i <= j` digits, then we know we have at most `f = j - i` free slots to work with. We have precisely `f + 1` decisions:\\n- use 0 free slots. Just the number `p` itself, so corresponds to 1 number\\n- use 1 free slot. All numbers of the form `p_0...p_i *`, where  `* = 0,  ...,  9`; corresponds to 10 numbers\\n- use 2 free slots. All numbers of the form `p_0...p_i * *`, where `* = 0, ..., 9`; corresponds to 10^2 numbers\\n- ...\\n- use `f - 1` free slots. Corresponds to `10^(f-1)` numbers\\n- use all `f` free slots. More on this in a moment.\\n\\nWe know for free slot count strictly less than `f`, regardless how we fill them in, we always get a number that is in range `[1, n]` (since we will end up with numbers that have fewer digits than `j` in these cases). For these, we get a total of `1 + 10 + ... + 10^(f - 1) = (10^f - 1) / (10 - 1)` numbers in range `[1, n]` starting with prefix `p`, that go into `count(p)`.\\n\\nWhat about using all `f` free slots? In this case, there are three things which can happen:\\n- `p < n // 10^f`. We are free to fill the remaining `f` slots with anything; this corresponds to an additional `10^f` numbers in `count(p)`\\n- `p > n // 10^f.` There is no number starting with prefix `p` and with `f` additional digits after, which is in our range `[1, n]`. Add nothing to `count(p)`\\n- `p = n // 10^f`. In this case, there are precisely `(n % 10^f) + 1` numbers starting with `p` and using `f` more digits following (the + 1 term involves filling the remaining `f` digits with all 0\\'s). For instance `n = 1287` and `p = 12`, then the remaining 2 free slots can be filled with values `00 -> 87`, to give us all numbers in the range `[1200, 1287]`.\\n\\n**CODE**\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        n_as_str = str(n)\\n        slots = len(n_as_str)\\n        # power(i) = 10 ^ i\\n        power = [1] * (slots + 1)\\n        for i in range(1, slots + 1):\\n            power[i] = power[i - 1] * 10\\n        # geometric(i) = 1 + 10 + ...+ 10 ^ i = (10^{i+1} - 1) / ( 10 - 1) \\n        geometric = [1] * slots\\n        for i in range(1, slots):\\n            geometric[i] = (power[i + 1] - 1) // 9\\n        \\n        curr_prefix = 1\\n        free_slots = slots - 1\\n        \\n        def get_prefix_count(n: int, prefix: int) -> int:\\n            count = 0\\n            if free_slots > 0:\\n                count = geometric[free_slots - 1]\\n            if prefix < n // power[free_slots]:\\n                count += power[free_slots]\\n            if prefix > n // power[free_slots]:\\n                count += 0\\n            if prefix == n // power[free_slots]:\\n                count += n % power[free_slots] + 1\\n            return count\\n        \\n        while k > 0:\\n            prefix_count = get_prefix_count(n, curr_prefix)\\n            # Too few numbers in range [1, n] that start with curr_prefix, increment it\\n            if prefix_count < k:\\n                k -= prefix_count\\n                curr_prefix += 1\\n                continue\\n            k -= 1\\n            if k == 0:\\n                break\\n            curr_prefix = 10 * curr_prefix\\n            free_slots -= 1\\n        \\n        return curr_prefix\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        n_as_str = str(n)\\n        slots = len(n_as_str)\\n        # power(i) = 10 ^ i\\n        power = [1] * (slots + 1)\\n        for i in range(1, slots + 1):\\n            power[i] = power[i - 1] * 10\\n        # geometric(i) = 1 + 10 + ...+ 10 ^ i = (10^{i+1} - 1) / ( 10 - 1) \\n        geometric = [1] * slots\\n        for i in range(1, slots):\\n            geometric[i] = (power[i + 1] - 1) // 9\\n        \\n        curr_prefix = 1\\n        free_slots = slots - 1\\n        \\n        def get_prefix_count(n: int, prefix: int) -> int:\\n            count = 0\\n            if free_slots > 0:\\n                count = geometric[free_slots - 1]\\n            if prefix < n // power[free_slots]:\\n                count += power[free_slots]\\n            if prefix > n // power[free_slots]:\\n                count += 0\\n            if prefix == n // power[free_slots]:\\n                count += n % power[free_slots] + 1\\n            return count\\n        \\n        while k > 0:\\n            prefix_count = get_prefix_count(n, curr_prefix)\\n            # Too few numbers in range [1, n] that start with curr_prefix, increment it\\n            if prefix_count < k:\\n                k -= prefix_count\\n                curr_prefix += 1\\n                continue\\n            k -= 1\\n            if k == 0:\\n                break\\n            curr_prefix = 10 * curr_prefix\\n            free_slots -= 1\\n        \\n        return curr_prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895125,
                "title": "getting-tle-using-trie-help-python",
                "content": "```\\nclass tn:\\n    def __init__(self):\\n        self.children={}\\n        self.end=False\\n\\nclass trie:\\n    def __init__(self):\\n        self.head=tn()\\n    def additem(self,val):\\n        curr=self.head\\n        for c in val:\\n            if(c not in curr.children):\\n                curr.children[c]=tn()\\n            curr=curr.children[c]\\n        curr.end=True\\n    def printall(self):\\n        final=[]\\n        curr=self.head\\n        self.printll(curr,\\'\\',final)\\n        return final\\n        \\n    def printll(self,curr,string,final):\\n        if(curr.end):\\n            final.append(string)\\n        for c in curr.children:\\n            self.printll(curr.children[c],string+c,final)\\n        \\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        t=trie()\\n        for i in range(1,n+1):\\n            t.additem(str(i))\\n        final=t.printall()\\n        return final[k-1]\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass tn:\\n    def __init__(self):\\n        self.children={}\\n        self.end=False\\n\\nclass trie:\\n    def __init__(self):\\n        self.head=tn()\\n    def additem(self,val):\\n        curr=self.head\\n        for c in val:\\n            if(c not in curr.children):\\n                curr.children[c]=tn()\\n            curr=curr.children[c]\\n        curr.end=True\\n    def printall(self):\\n        final=[]\\n        curr=self.head\\n        self.printll(curr,\\'\\',final)\\n        return final\\n        \\n    def printll(self,curr,string,final):\\n        if(curr.end):\\n            final.append(string)\\n        for c in curr.children:\\n            self.printll(curr.children[c],string+c,final)\\n        \\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        t=trie()\\n        for i in range(1,n+1):\\n            t.additem(str(i))\\n        final=t.printall()\\n        return final[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874889,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        //\\u5F53\\u524D\\u904D\\u5386\\u5230\\u7684\\u4E2A\\u6570\\n        int cur = 1;\\n        int prefix = 1;\\n        while(cur < k){\\n            int temp = helper(n, prefix);\\n            if(temp + cur - 1 >= k){\\n                //\\u8BC1\\u660E\\u5728\\u6B64\\u524D\\u7F00\\u5185\\n                prefix *= 10;\\n                cur ++;\\n            }else{\\n                cur += temp;\\n                //\\u524D\\u7F00\\u589E\\u52A01\\n                prefix ++;\\n            }\\n        }\\n        return prefix;\\n    }\\n    \\n    //\\u7EDF\\u8BA1\\u8FD9\\u4E2A\\u524D\\u7F00\\u4E0B\\u7684\\u5143\\u7D20\\u4E2A\\u6570\\n    private int helper(int n, int prefix){\\n        long next = prefix + 1;\\n        //\\u4ECE\\u5F53\\u524D\\u5143\\u7D20\\u5F00\\u59CB\\uFF0C\\u76F4\\u81F3cur > n\\u9000\\u51FA\\n        long cur = prefix;\\n        int count = 0;\\n        while(cur <= n){\\n            count += Math.min(next, n + 1) - cur;\\n            cur *= 10;\\n            next *= 10;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        //\\u5F53\\u524D\\u904D\\u5386\\u5230\\u7684\\u4E2A\\u6570\\n        int cur = 1;\\n        int prefix = 1;\\n        while(cur < k){\\n            int temp = helper(n, prefix);\\n            if(temp + cur - 1 >= k){\\n                //\\u8BC1\\u660E\\u5728\\u6B64\\u524D\\u7F00\\u5185\\n                prefix *= 10;\\n                cur ++;\\n            }else{\\n                cur += temp;\\n                //\\u524D\\u7F00\\u589E\\u52A01\\n                prefix ++;\\n            }\\n        }\\n        return prefix;\\n    }\\n    \\n    //\\u7EDF\\u8BA1\\u8FD9\\u4E2A\\u524D\\u7F00\\u4E0B\\u7684\\u5143\\u7D20\\u4E2A\\u6570\\n    private int helper(int n, int prefix){\\n        long next = prefix + 1;\\n        //\\u4ECE\\u5F53\\u524D\\u5143\\u7D20\\u5F00\\u59CB\\uFF0C\\u76F4\\u81F3cur > n\\u9000\\u51FA\\n        long cur = prefix;\\n        int count = 0;\\n        while(cur <= n){\\n            count += Math.min(next, n + 1) - cur;\\n            cur *= 10;\\n            next *= 10;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1811480,
                "title": "c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int get(int prefix, int n) {\\n        long long p = 1;\\n        auto A = to_string(n), B = to_string(prefix);\\n        int dt = A.size() - B.size();\\n        int ans = 0;\\n        for(int i=0; i<dt; i++) {\\n            ans += p;\\n            p *= 10;\\n        }\\n        A = A.substr(0, B.size());\\n        if(A > B) {\\n            ans += p;\\n        } else if(A == B) {\\n            ans += n - prefix*p + 1;\\n        }\\n        return ans;\\n    }\\n    int findKthNumber(int n, int k) {\\n        int prefix = 1;\\n        while(k > 1) {\\n            int cnt = get(prefix, n);\\n            if(cnt < k) {\\n                k -= cnt;\\n                prefix++;\\n            } else {\\n                k --;\\n                prefix *= 10;\\n            }\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int get(int prefix, int n) {\\n        long long p = 1;\\n        auto A = to_string(n), B = to_string(prefix);\\n        int dt = A.size() - B.size();\\n        int ans = 0;\\n        for(int i=0; i<dt; i++) {\\n            ans += p;\\n            p *= 10;\\n        }\\n        A = A.substr(0, B.size());\\n        if(A > B) {\\n            ans += p;\\n        } else if(A == B) {\\n            ans += n - prefix*p + 1;\\n        }\\n        return ans;\\n    }\\n    int findKthNumber(int n, int k) {\\n        int prefix = 1;\\n        while(k > 1) {\\n            int cnt = get(prefix, n);\\n            if(cnt < k) {\\n                k -= cnt;\\n                prefix++;\\n            } else {\\n                k --;\\n                prefix *= 10;\\n            }\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791317,
                "title": "finding-number-of-node-in-a-branch",
                "content": "```\\nclass Solution {\\npublic:\\n    int nodeInBranch(int n, long cur){\\n        long node = 0;\\n        long next = cur + 1;\\n        while(cur <= n){\\n            if(next > n){\\n                node += n - cur + 1;\\n                break;\\n            }\\n            else{\\n                node += next - cur;\\n            }\\n            cur *= 10;\\n            next *= 10;\\n        }\\n        return node;\\n    }\\n    int findKthNumber(int n, int k) {\\n        int cur = 1;\\n        k--;\\n        while(k > 0){\\n            int node = nodeInBranch(n, cur);\\n            if(node > k){\\n                cur *= 10;\\n                k--;\\n            }\\n            else{\\n                k -= node;\\n                cur++;\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nodeInBranch(int n, long cur){\\n        long node = 0;\\n        long next = cur + 1;\\n        while(cur <= n){\\n            if(next > n){\\n                node += n - cur + 1;\\n                break;\\n            }\\n            else{\\n                node += next - cur;\\n            }\\n            cur *= 10;\\n            next *= 10;\\n        }\\n        return node;\\n    }\\n    int findKthNumber(int n, int k) {\\n        int cur = 1;\\n        k--;\\n        while(k > 0){\\n            int node = nodeInBranch(n, cur);\\n            if(node > k){\\n                cur *= 10;\\n                k--;\\n            }\\n            else{\\n                k -= node;\\n                cur++;\\n            }\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460468,
                "title": "c-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long _cnt;\\n    long _ans;\\n    void GetNums(long n, long prefix, int digits_left) {\\n        if(prefix>n || _cnt==0) return;\\n        if(--_cnt==0) {\\n            _ans=prefix;\\n            return;\\n        }\\n        if(digits_left) {\\n            long temp=prefix;\\n            int temp2=digits_left;\\n            while(temp2--) temp*=10;\\n            if(temp>n) digits_left--;\\n        }\\n        if(digits_left) {\\n            long max_cnt_nums=0, max_num=prefix+1, temp=digits_left;\\n            while(temp--) {\\n                max_cnt_nums=max_cnt_nums*10+1;\\n                max_num*=10;\\n            }\\n            max_cnt_nums*=10;\\n            if(max_cnt_nums<_cnt && max_num<n) {\\n                _cnt-=max_cnt_nums;\\n                return;\\n            }\\n        }\\n        for(int i=0; i<10; i++) GetNums(n, prefix*10+i, digits_left-1);\\n    }\\n\\n    int findKthNumber(int n, int k) {\\n        _cnt=k, _ans=-1;\\n        int nDigits=0, temp=n;\\n        while(temp) {\\n            nDigits++;\\n            temp/=10;\\n        }\\n        for(int i=1; i<10 && _cnt; i++) GetNums(n, i, nDigits-1);\\n        return _ans;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long _cnt;\\n    long _ans;\\n    void GetNums(long n, long prefix, int digits_left) {\\n        if(prefix>n || _cnt==0) return;\\n        if(--_cnt==0) {\\n            _ans=prefix;\\n            return;\\n        }\\n        if(digits_left) {\\n            long temp=prefix;\\n            int temp2=digits_left;\\n            while(temp2--) temp*=10;\\n            if(temp>n) digits_left--;\\n        }\\n        if(digits_left) {\\n            long max_cnt_nums=0, max_num=prefix+1, temp=digits_left;\\n            while(temp--) {\\n                max_cnt_nums=max_cnt_nums*10+1;\\n                max_num*=10;\\n            }\\n            max_cnt_nums*=10;\\n            if(max_cnt_nums<_cnt && max_num<n) {\\n                _cnt-=max_cnt_nums;\\n                return;\\n            }\\n        }\\n        for(int i=0; i<10; i++) GetNums(n, prefix*10+i, digits_left-1);\\n    }\\n\\n    int findKthNumber(int n, int k) {\\n        _cnt=k, _ans=-1;\\n        int nDigits=0, temp=n;\\n        while(temp) {\\n            nDigits++;\\n            temp/=10;\\n        }\\n        for(int i=1; i<10 && _cnt; i++) GetNums(n, i, nDigits-1);\\n        return _ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408855,
                "title": "tle-can-anyone-help",
                "content": "```\\n    vector<int> v;\\n    \\n    void dfs(int start,int end ,int n)\\n    {\\n        while(start<=end && start<=n)\\n        {\\n            v.push_back(start);\\n\\n            dfs(start*10,start*10+9,n);\\n            start++;\\n            \\n        }\\n        \\n    }\\n    \\n    int findKthNumber(int n, int k) \\n    {\\n        dfs(1,9,n);\\n        return v[k-1];\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<int> v;\\n    \\n    void dfs(int start,int end ,int n)\\n    {\\n        while(start<=end && start<=n)\\n        {\\n            v.push_back(start);\\n\\n            dfs(start*10,start*10+9,n);\\n            start++;\\n            \\n        }\\n        \\n    }\\n    \\n    int findKthNumber(int n, int k) \\n    {\\n        dfs(1,9,n);\\n        return v[k-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291576,
                "title": "clear-and-concise-solution",
                "content": "class Solution {\\n    public int findKthNumber(int n, int k) {\\n        int cur = 1;\\n        while (true) {\\n            if (k == 1) {\\n                return cur;\\n            }\\n            int steps = findSteps(cur, cur+1, n);\\n            if (k <= steps) {\\n                cur *= 10;\\n                k--;\\n            } else {\\n                cur++;\\n                k -= steps;\\n            }\\n        }\\n    }\\n    \\n    public int findSteps(long n1, long n2, long n) {\\n        long num = 0;\\n        while (n1 <= n) {\\n            if (n2 <= n) {\\n                num += (n2 - n1);\\n            } else {\\n                num += n - n1 + 1;\\n                break;\\n            }\\n            n1 *= 10;\\n            n2 *= 10;\\n        }\\n        return(int) num;\\n    }\\n    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findKthNumber(int n, int k) {\\n        int cur = 1;\\n        while (true) {\\n            if (k == 1) {\\n                return cur;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1146914,
                "title": "c-0ms-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/88f6ef30-403b-446c-8855-a765ba8f36d6_1617798289.993014.png)\\nLet\\'s make the every digit is the son node of it\\'s previous digit. We can make 9 infinity tree to build any number we want. But we only need to build from 1 to n.\\n\\nSo after we got the value of n, we know the size of the tree should be. It looks like a complete tree but in 10-childs version. (only the final level can be not completed).\\nJust calculate the tree base size (it\\'s increasing with the hight like 1, 11, 111, 1111, ...)\\nAnd final row size of the tree.  And the rest node number.\\n\\nAfter we got those information, what we only need to do is to figure out our target is in which tree. \\nLet\\'s say we figure out it\\'s in second tree, then we only need to update those infomation again and do the same thing in that tree (after you remove the root node it\\'s same).\\n```\\nclass Solution {\\npublic:\\n    void whatDi(int &ans, int base, int rest, int final_len, int k, int start) {\\n        if (k-- == 1) return; \\n        int i;\\n        for (i = start;; ++i) {\\n            int v = base + min(final_len, rest);\\n            if (v >= k) break;\\n            rest = max(0, rest-final_len);\\n            k -= v;   \\n        }\\n        ans = ans * 10 + i;\\n        whatDi(ans, base/10, rest, final_len/10, k, 0);\\n    }\\n    \\n    \\n    int findKthNumber(int n, int k) {\\n        int base = 1, final_len = 1;\\n        while (n / base >= 9) {\\n            base *= 10; base += 1; final_len *= 10;\\n        } \\n        if (n != 9 * base) base /= 10;\\n        int rest = n - 9 * base;\\n        \\n        int ans = 0;\\n        whatDi(ans, base, rest, final_len, k+1, 1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void whatDi(int &ans, int base, int rest, int final_len, int k, int start) {\\n        if (k-- == 1) return; \\n        int i;\\n        for (i = start;; ++i) {\\n            int v = base + min(final_len, rest);\\n            if (v >= k) break;\\n            rest = max(0, rest-final_len);\\n            k -= v;   \\n        }\\n        ans = ans * 10 + i;\\n        whatDi(ans, base/10, rest, final_len/10, k, 0);\\n    }\\n    \\n    \\n    int findKthNumber(int n, int k) {\\n        int base = 1, final_len = 1;\\n        while (n / base >= 9) {\\n            base *= 10; base += 1; final_len *= 10;\\n        } \\n        if (n != 9 * base) base /= 10;\\n        int rest = n - 9 * base;\\n        \\n        int ans = 0;\\n        whatDi(ans, base, rest, final_len, k+1, 1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077924,
                "title": "memory-limit-exceeded-but-where-can-someone-please-help",
                "content": "```\\nclass Solution {\\npublic static int findKthNumber(int n, int k) {\\n\\t\\tString[] arr = new String[n];\\n\\t\\tint i = 1;\\n\\t\\twhile (i <= n) {\\n\\t\\t\\tarr[i - 1] = String.valueOf(i);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tArrays.sort(arr);\\n\\t\\tif (k <= n) {\\n\\t\\t\\treturn Integer.valueOf(arr[k - 1]);\\n\\t\\t} else {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic static int findKthNumber(int n, int k) {\\n\\t\\tString[] arr = new String[n];\\n\\t\\tint i = 1;\\n\\t\\twhile (i <= n) {\\n\\t\\t\\tarr[i - 1] = String.valueOf(i);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tArrays.sort(arr);\\n\\t\\tif (k <= n) {\\n\\t\\t\\treturn Integer.valueOf(arr[k - 1]);\\n\\t\\t} else {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030172,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        \\n        \\n        def count_nodes(n,curr):\\n            \\n            total = 0\\n            next_ = curr + 1\\n            \\n            while curr <= n:\\n                \\n                total += min(n-curr+1,next_-curr)\\n                curr *=10\\n                next_ *=10\\n                \\n            \\n            return int(total)\\n        \\n        curr = 1\\n        k -=1\\n        \\n        while k > 0:\\n            \\n            nodes = count_nodes(n,curr)\\n            \\n            #print(\\'Before \\',k,nodes,curr)\\n            if(k >= nodes):\\n                k -= nodes\\n                curr +=1\\n            \\n            else:\\n                curr *= 10\\n                k-=1\\n        \\n            #print(\\'After \\',k,nodes,curr)\\n        \\n        return curr\\n    \\n    \\n    \\n    \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        \\n        \\n        def count_nodes(n,curr):\\n            \\n            total = 0\\n            next_ = curr + 1\\n            \\n            while curr <= n:\\n                \\n                total += min(n-curr+1,next_-curr)\\n                curr *=10\\n                next_ *=10\\n                \\n            \\n            return int(total)\\n        \\n        curr = 1\\n        k -=1\\n        \\n        while k > 0:\\n            \\n            nodes = count_nodes(n,curr)\\n            \\n            #print(\\'Before \\',k,nodes,curr)\\n            if(k >= nodes):\\n                k -= nodes\\n                curr +=1\\n            \\n            else:\\n                curr *= 10\\n                k-=1\\n        \\n            #print(\\'After \\',k,nodes,curr)\\n        \\n        return curr\\n    \\n    \\n    \\n    \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 892016,
                "title": "python-o-of-digits-in-n-dfs-solution",
                "content": "\\tdef findKthNumber(self, n: int, k: int) -> int:\\n        return self.dfs(str(n), k, \"\", 1)\\n    \\n    def dfs(self, n, k, c, j = 0):\\n        if k == 0: return c\\n        \\n        base = int(\"1\" * len(n))\\n        for i in range(j, 10):\\n            new = int(c + str(i))\\n            t = 0\\n            if str(i) == n[0] and len(n) > 1:\\n                t += int(str(n)[1:]) + 1\\n                base //= 10\\n            t+= base\\n            \\n            if t >= k:\\n                return self.dfs(str(base * 9 // 10) if str(i) != n[0] else n[1:], k - 1, c + str(i))\\n            k -= t",
                "solutionTags": [],
                "code": "\\tdef findKthNumber(self, n: int, k: int) -> int:\\n        return self.dfs(str(n), k, \"\", 1)\\n    \\n    def dfs(self, n, k, c, j = 0):\\n        if k == 0: return c\\n        \\n        base = int(\"1\" * len(n))\\n        for i in range(j, 10):\\n            new = int(c + str(i))\\n            t = 0\\n            if str(i) == n[0] and len(n) > 1:\\n                t += int(str(n)[1:]) + 1\\n                base //= 10\\n            t+= base\\n            \\n            if t >= k:\\n                return self.dfs(str(base * 9 // 10) if str(i) != n[0] else n[1:], k - 1, c + str(i))\\n            k -= t",
                "codeTag": "Python3"
            },
            {
                "id": 797771,
                "title": "can-anyone-tell-me-why-we-cant-just-do-it-like-this-please",
                "content": "\\n\\tdef whatswrong(n,k):\\n\\t\\tt=[]\\n\\t\\tfor i in range(n):\\n\\t\\t\\tt=t+[str(i)]\\n\\t\\tt.sort()\\n\\t\\treturn (int(t[k]))",
                "solutionTags": [],
                "code": "\\n\\tdef whatswrong(n,k):\\n\\t\\tt=[]\\n\\t\\tfor i in range(n):\\n\\t\\t\\tt=t+[str(i)]\\n\\t\\tt.sort()\\n\\t\\treturn (int(t[k]))",
                "codeTag": "Python3"
            },
            {
                "id": 674034,
                "title": "java-0ms-solution",
                "content": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        if(k == 0)\\n            return 0;\\n        int curr = 1;\\n        k = k-1;\\n        while(k > 0){\\n            int steps = findSteps(curr, curr+1, n);\\n            if(steps <= k){\\n                curr++;\\n                k = k-steps;\\n            }\\n            else{\\n                curr *= 10;\\n                k--;\\n            }\\n        }\\n        return curr;\\n    }\\n    \\n    private int findSteps(long left, long right, int n){\\n        int result = 0;\\n        while(left <= n || right <= n){\\n            result += (Math.min(n+1, right) -left);\\n            left *= 10;\\n            right *= 10;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        if(k == 0)\\n            return 0;\\n        int curr = 1;\\n        k = k-1;\\n        while(k > 0){\\n            int steps = findSteps(curr, curr+1, n);\\n            if(steps <= k){\\n                curr++;\\n                k = k-steps;\\n            }\\n            else{\\n                curr *= 10;\\n                k--;\\n            }\\n        }\\n        return curr;\\n    }\\n    \\n    private int findSteps(long left, long right, int n){\\n        int result = 0;\\n        while(left <= n || right <= n){\\n            result += (Math.min(n+1, right) -left);\\n            left *= 10;\\n            right *= 10;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661526,
                "title": "c-0ms-o-1-space-and-iterator-solution",
                "content": "Ideas:\\nThe first one is 1. If it is less than k, then + 1 becomes 2. (if the current bit is 9, then * 10 = 90),\\nIf it is greater than k, it means that the first one is 1, and then judge the next one, then (2-1) * 10 = 10, now from 10\\nStart to judge, and so on.\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int findKthNumber(int n, int k) {\\n        ll temp = n, ret = 0;\\n        int nums = 0, retLen = 1, len = 0;\\n        while(temp > 0) len++, temp /= 10;\\n        while(nums != k) {\\n            if(nums > k) ret = (ret-1)*10, retLen++;\\n            else if(ret%10 == 9) ret *= 10, retLen++;\\n            else ret++;\\n            nums = 0, temp = ret;\\n            for(int i = retLen; i < len; i++) temp *= 10;\\n            for(int i = 1; i <= len; i++) {\\n                int div = pow(10, len-i);\\n                int start = pow(10, i-1);\\n                ll dived = (temp>n&&i==len)?n:temp;\\n                int cur = dived/div;\\n                nums += cur - start + 1;\\n                double lg = log10(dived/ret);\\n                if(retLen < i && dived > ret && lg > 0 && lg == (int)lg) nums--;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    int findKthNumber(int n, int k) {\\n        ll temp = n, ret = 0;\\n        int nums = 0, retLen = 1, len = 0;\\n        while(temp > 0) len++, temp /= 10;\\n        while(nums != k) {\\n            if(nums > k) ret = (ret-1)*10, retLen++;\\n            else if(ret%10 == 9) ret *= 10, retLen++;\\n            else ret++;\\n            nums = 0, temp = ret;\\n            for(int i = retLen; i < len; i++) temp *= 10;\\n            for(int i = 1; i <= len; i++) {\\n                int div = pow(10, len-i);\\n                int start = pow(10, i-1);\\n                ll dived = (temp>n&&i==len)?n:temp;\\n                int cur = dived/div;\\n                nums += cur - start + 1;\\n                double lg = log10(dived/ret);\\n                if(retLen < i && dived > ret && lg > 0 && lg == (int)lg) nums--;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652716,
                "title": "simple-c-solution",
                "content": "```\\n#include <math.h>\\n\\nint fullCount[] = {1,11,111,1111,11111,111111,1111111,11111111,111111111};\\nint tens[] = {1, 10, 100, 1000, 10000,100000,1000000,10000000,100000000,1000000000};\\ndouble logN;\\n\\nclass Solution {\\n    public:\\n    int findKthNumber(int n, int k) {\\n        logN = log10(n);\\n        return find(n , k, 0);\\n    }\\n\\n    int find(const int n , int delta, const int pre) {\\n\\n        for(int i = 0; i <= 9; i++) {\\n            int now = pre + i;\\n            if(now == 0) continue;\\n            if(delta == 1) return now;\\n            int count =countStartWith(n, now);\\n            if(delta <= count) {\\n                return find (n , delta - 1, (now) * 10);\\n            }\\n            delta -= count;\\n        }\\n        return -1;\\n    }\\n\\n    int countStartWith(const int n, long pre) {\\n        int low = logN - log10(pre);\\n        if(low < 0) {\\n            return 0;\\n        } else if(low == 0) {\\n            return 1;\\n        }\\n\\n        int high = logN - log10(pre + 1);\\n        if(low == high) {\\n            return fullCount[low];\\n        } else {\\n            return n % tens[low] + fullCount[low -1 ] + 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <math.h>\\n\\nint fullCount[] = {1,11,111,1111,11111,111111,1111111,11111111,111111111};\\nint tens[] = {1, 10, 100, 1000, 10000,100000,1000000,10000000,100000000,1000000000};\\ndouble logN;\\n\\nclass Solution {\\n    public:\\n    int findKthNumber(int n, int k) {\\n        logN = log10(n);\\n        return find(n , k, 0);\\n    }\\n\\n    int find(const int n , int delta, const int pre) {\\n\\n        for(int i = 0; i <= 9; i++) {\\n            int now = pre + i;\\n            if(now == 0) continue;\\n            if(delta == 1) return now;\\n            int count =countStartWith(n, now);\\n            if(delta <= count) {\\n                return find (n , delta - 1, (now) * 10);\\n            }\\n            delta -= count;\\n        }\\n        return -1;\\n    }\\n\\n    int countStartWith(const int n, long pre) {\\n        int low = logN - log10(pre);\\n        if(low < 0) {\\n            return 0;\\n        } else if(low == 0) {\\n            return 1;\\n        }\\n\\n        int high = logN - log10(pre + 1);\\n        if(low == high) {\\n            return fullCount[low];\\n        } else {\\n            return n % tens[low] + fullCount[low -1 ] + 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 604242,
                "title": "c-dfs-easy-to-understand-count-numbers",
                "content": "Based on zhaoyang.liang solution :\\n\\n```\\nclass Solution {\\n    long long countNumber(long long root, long long n) {\\n        long long son = root+1;\\n        long long count = 0;\\n        while (root <= n) {\\n            count += min(son, n+1) - root;\\n            root *= 10;\\n            son *= 10;\\n        }\\n        \\n        return count;\\n    }\\n    long long dfs(long long root, long long n, long long k) {\\n        if (k == 0)\\n            return root;\\n        \\n        long long next = root+1;\\n        long long count = countNumber(root, n);\\n        \\n        if (count > k) {\\n            return dfs(root*10, n, k-1);\\n        } else {\\n            return dfs(root+1, n, k-count);\\n        }\\n    }\\npublic:\\n    int findKthNumber(int n, int k) {\\n        return dfs(1, n, k-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long countNumber(long long root, long long n) {\\n        long long son = root+1;\\n        long long count = 0;\\n        while (root <= n) {\\n            count += min(son, n+1) - root;\\n            root *= 10;\\n            son *= 10;\\n        }\\n        \\n        return count;\\n    }\\n    long long dfs(long long root, long long n, long long k) {\\n        if (k == 0)\\n            return root;\\n        \\n        long long next = root+1;\\n        long long count = countNumber(root, n);\\n        \\n        if (count > k) {\\n            return dfs(root*10, n, k-1);\\n        } else {\\n            return dfs(root+1, n, k-count);\\n        }\\n    }\\npublic:\\n    int findKthNumber(int n, int k) {\\n        return dfs(1, n, k-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540163,
                "title": "accepted-c-solution",
                "content": "```\\n        public class Solution\\n        {\\n            private void Helper(IList<int> res, IList<int> inputDigits, int startDigit, int k, int? trackIdx, int maxLength)\\n            {\\n                if (startDigit == 0)\\n                {\\n                    if (k == 0)\\n                    {\\n                        return;\\n                    }\\n\\n                    k--;\\n                }\\n\\n                if (maxLength == 0)\\n                {\\n                    return;\\n                }\\n\\n                for (int digit = startDigit; digit <= 9; digit++)\\n                {\\n                    if (trackIdx == null || inputDigits[trackIdx.Value] > digit)\\n                    {\\n                        int t = maxLength;\\n                        int count = (((int)Math.Pow(10, t) - 1)) / 9;\\n                        if (k >= count)\\n                        {\\n                            k -= count;\\n                        }\\n                        else\\n                        {\\n                            res.Add(digit);\\n                            Helper(res, inputDigits, 0, k, null, maxLength - 1);\\n                            return;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if(inputDigits[trackIdx.Value] < digit)\\n                        {\\n                            int t = maxLength - 1;\\n                            int count = (((int)Math.Pow(10, t) - 1)) / 9;\\n\\n                            if (k >= count)\\n                            {\\n                                k -= count;\\n                            }\\n                            else\\n                            {\\n                                res.Add(digit);\\n                                Helper(res, inputDigits, 0, k, null, maxLength - 2);\\n                                return;\\n                            }\\n                        }\\n                        else\\n                        {\\n                            int t = maxLength - 1;\\n                            int countOfCutSize = (((int)Math.Pow(10, t) - 1)) / 9;\\n                            int tmp = 0;\\n                            for (int i = trackIdx.Value + 1; i < inputDigits.Count; i++)\\n                            {\\n                                tmp *= 10;\\n                                tmp += inputDigits[i];\\n                            }\\n\\n                            int count = countOfCutSize + tmp + 1;\\n\\n\\n                            if (k >= count)\\n                            {\\n                                k -= count;\\n                            }\\n                            else\\n                            {\\n                                res.Add(digit);\\n                                Helper(res, inputDigits, 0, k, trackIdx + 1, maxLength - 1);\\n                                return;\\n                            }\\n\\n                        }\\n                    }\\n                }\\n            }\\n\\n            public int FindKthNumber(int n, int k)\\n            {\\n                checked\\n                {\\n                    k--;\\n                    int digitsCount = (int) Math.Floor(Math.Log10(n)) + 1;\\n                    List<int> inputDigits = new List<int>(digitsCount);\\n\\n\\n                    int num = n;\\n                    while (num != 0)\\n                    {\\n                        inputDigits.Add(num % 10);\\n                        num /= 10;\\n                    }\\n\\n                    inputDigits.Reverse();\\n\\n                    IList<int> resDigits = new List<int>();\\n\\n                    Helper(resDigits, inputDigits, 1, k, 0, digitsCount);\\n\\n                    int res = 0;\\n                    for (int i = 0; i < resDigits.Count; i++)\\n                    {\\n                        res *= 10;\\n                        res += resDigits[i];\\n                    }\\n                    return res;\\n                }\\n            }\\n        }\\n```",
                "solutionTags": [
                    "Math",
                    "Recursion"
                ],
                "code": "```\\n        public class Solution\\n        {\\n            private void Helper(IList<int> res, IList<int> inputDigits, int startDigit, int k, int? trackIdx, int maxLength)\\n            {\\n                if (startDigit == 0)\\n                {\\n                    if (k == 0)\\n                    {\\n                        return;\\n                    }\\n\\n                    k--;\\n                }\\n\\n                if (maxLength == 0)\\n                {\\n                    return;\\n                }\\n\\n                for (int digit = startDigit; digit <= 9; digit++)\\n                {\\n                    if (trackIdx == null || inputDigits[trackIdx.Value] > digit)\\n                    {\\n                        int t = maxLength;\\n                        int count = (((int)Math.Pow(10, t) - 1)) / 9;\\n                        if (k >= count)\\n                        {\\n                            k -= count;\\n                        }\\n                        else\\n                        {\\n                            res.Add(digit);\\n                            Helper(res, inputDigits, 0, k, null, maxLength - 1);\\n                            return;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if(inputDigits[trackIdx.Value] < digit)\\n                        {\\n                            int t = maxLength - 1;\\n                            int count = (((int)Math.Pow(10, t) - 1)) / 9;\\n\\n                            if (k >= count)\\n                            {\\n                                k -= count;\\n                            }\\n                            else\\n                            {\\n                                res.Add(digit);\\n                                Helper(res, inputDigits, 0, k, null, maxLength - 2);\\n                                return;\\n                            }\\n                        }\\n                        else\\n                        {\\n                            int t = maxLength - 1;\\n                            int countOfCutSize = (((int)Math.Pow(10, t) - 1)) / 9;\\n                            int tmp = 0;\\n                            for (int i = trackIdx.Value + 1; i < inputDigits.Count; i++)\\n                            {\\n                                tmp *= 10;\\n                                tmp += inputDigits[i];\\n                            }\\n\\n                            int count = countOfCutSize + tmp + 1;\\n\\n\\n                            if (k >= count)\\n                            {\\n                                k -= count;\\n                            }\\n                            else\\n                            {\\n                                res.Add(digit);\\n                                Helper(res, inputDigits, 0, k, trackIdx + 1, maxLength - 1);\\n                                return;\\n                            }\\n\\n                        }\\n                    }\\n                }\\n            }\\n\\n            public int FindKthNumber(int n, int k)\\n            {\\n                checked\\n                {\\n                    k--;\\n                    int digitsCount = (int) Math.Floor(Math.Log10(n)) + 1;\\n                    List<int> inputDigits = new List<int>(digitsCount);\\n\\n\\n                    int num = n;\\n                    while (num != 0)\\n                    {\\n                        inputDigits.Add(num % 10);\\n                        num /= 10;\\n                    }\\n\\n                    inputDigits.Reverse();\\n\\n                    IList<int> resDigits = new List<int>();\\n\\n                    Helper(resDigits, inputDigits, 1, k, 0, digitsCount);\\n\\n                    int res = 0;\\n                    for (int i = 0; i < resDigits.Count; i++)\\n                    {\\n                        res *= 10;\\n                        res += resDigits[i];\\n                    }\\n                    return res;\\n                }\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538654,
                "title": "use-denary-tree",
                "content": "```\\npublic int findKthNumber(int n, int k) {\\n        long curr = 1;\\n        k--; // start with 1, skip 1;\\n        while (k > 0) {\\n            long step = getStep(n, curr, curr + 1);\\n            if (step <= k) {\\n                curr += 1;\\n                k -= step;\\n            } else {\\n                curr *= 10;\\n                k -= 1;\\n            }\\n        }\\n        return (int) curr;\\n    }\\n    \\n    private long getStep(int n, long n1, long n2) {\\n        long step = 0;\\n        while (n1 <= n) {   // <= \\n            step += Math.min(n + 1, n2) - n1; // n + 1, include the parent node;\\n            n1 *= 10;\\n            n2 *= 10;\\n        }\\n        return step;\\n    }\\n```\\n\\nRef: https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/discuss/92242/ConciseEasy-to-understand-Java-5ms-solution-with-Explaination",
                "solutionTags": [],
                "code": "```\\npublic int findKthNumber(int n, int k) {\\n        long curr = 1;\\n        k--; // start with 1, skip 1;\\n        while (k > 0) {\\n            long step = getStep(n, curr, curr + 1);\\n            if (step <= k) {\\n                curr += 1;\\n                k -= step;\\n            } else {\\n                curr *= 10;\\n                k -= 1;\\n            }\\n        }\\n        return (int) curr;\\n    }\\n    \\n    private long getStep(int n, long n1, long n2) {\\n        long step = 0;\\n        while (n1 <= n) {   // <= \\n            step += Math.min(n + 1, n2) - n1; // n + 1, include the parent node;\\n            n1 *= 10;\\n            n2 *= 10;\\n        }\\n        return step;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506445,
                "title": "share-a-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        return findKthNumberWithPrefix(n, k, 1);\\n    }\\n    \\n    // a helper function taking an additional prefix, this helps us solve the problem recursively.\\n    public int findKthNumberWithPrefix(int n, int k, int prefix) {\\n        if(k == 1) {\\n            return prefix;\\n        }\\n        \\n        int number_with_prefix_count = (int)numSmallerThanN(n, prefix);\\n        if(k > number_with_prefix_count) {\\n            // If all numbers with this prefix smaller or equal to n does not exceed k, check for prefix+1 recursively.\\n            return findKthNumberWithPrefix(n, k-number_with_prefix_count, prefix+1);\\n        } else if(prefix*10 <= n) {\\n            // If all numbers with this prefix smaller or equal to n exceeds k, check for first child recursively.\\n            return findKthNumberWithPrefix(n, k-1, prefix*10);\\n        } else {\\n            // In this case, first child exceeds n, which means we should check for peers instead of children.\\n            return findKthNumberWithPrefix(n, k-1, prefix+1);\\n        }\\n    }\\n    \\n    // a helper function to count all the numbers with specified prefix and smaller or equal to n.\\n    public long numSmallerThanN(long n, long prefix) {\\n        long base = 1;\\n        long result = 0;\\n        while(prefix * base <= n) {\\n            if((prefix+1)*base <= n) {\\n                result += base;\\n            } else {\\n                result += n - prefix*base + 1;\\n            }\\n            base *= 10;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findKthNumber(int n, int k) {\\n        return findKthNumberWithPrefix(n, k, 1);\\n    }\\n    \\n    // a helper function taking an additional prefix, this helps us solve the problem recursively.\\n    public int findKthNumberWithPrefix(int n, int k, int prefix) {\\n        if(k == 1) {\\n            return prefix;\\n        }\\n        \\n        int number_with_prefix_count = (int)numSmallerThanN(n, prefix);\\n        if(k > number_with_prefix_count) {\\n            // If all numbers with this prefix smaller or equal to n does not exceed k, check for prefix+1 recursively.\\n            return findKthNumberWithPrefix(n, k-number_with_prefix_count, prefix+1);\\n        } else if(prefix*10 <= n) {\\n            // If all numbers with this prefix smaller or equal to n exceeds k, check for first child recursively.\\n            return findKthNumberWithPrefix(n, k-1, prefix*10);\\n        } else {\\n            // In this case, first child exceeds n, which means we should check for peers instead of children.\\n            return findKthNumberWithPrefix(n, k-1, prefix+1);\\n        }\\n    }\\n    \\n    // a helper function to count all the numbers with specified prefix and smaller or equal to n.\\n    public long numSmallerThanN(long n, long prefix) {\\n        long base = 1;\\n        long result = 0;\\n        while(prefix * base <= n) {\\n            if((prefix+1)*base <= n) {\\n                result += base;\\n            } else {\\n                result += n - prefix*base + 1;\\n            }\\n            base *= 10;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459018,
                "title": "cpp-0ms-o-log-n",
                "content": "In this algorithm I am getting the decimal digits of the answer successively from the most significant to least significant.\\nEach iteration, the problem is reduced to a similar search where the order of magnitude of *n* is lowered by a factor of 10 or 100.\\nI will provide a more detailed explanation later.\\n```\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        int j(1);\\n        std::vector<int> u= {0};                        // { 1, 11, 111, 1111...}\\n\\n        while(j<=n){\\n            u.push_back(u.back()*10+1);\\n            j *= 10;\\n        }\\n        j /= 10;\\n        int s = u.size()-1;\\n\\n        int num(0);\\n        int i(0);\\n        \\n        while(k>0){                                     // at most \\u230Alog10(n)\\u230B+1  iterations.\\n           \\n            int msd = n/j;                              // the case i=0 has to be handled separately: when i>0 msd may be 0, when i=0 msd > 0.\\n            int count1 = (msd-1+(i>0))*u.back();        // count of numbers with most significant digit less than the msd of n.\\n            int count2 = u.back()-(j-n+msd*j-1);        // count of numbers (less or equal to n) with most significant digit equal to the msd of n.\\n\\n            if(k<=count1){                              // first digit of the result is less than n\\'s one.\\n                int q = (k-1) / u.back();\\n                k -= q * u.back();\\n                num = num*10 + (q+1)-(i>0);\\n                n = j-1;\\n            }\\n            else if (k<= count1+count2){                // first digit of the result is equal to n\\'s one.\\n                num = num*10 + msd;\\n                k -= (msd-1+(i>0))*u.back();\\n                n -= j*msd;\\n            }\\n            else{                                       // first digit of the result is greater than n\\'s one.\\n                k -= (msd-1+(i>0))*u.back()+count2;\\n                u.pop_back();\\n                int q = (k-1) / u.back();\\n                k -= q * u.back();\\n                num = num*10 + (msd+q+1);\\n\\n                n = j/10-1;\\n                j /= 10;\\n                ++i;\\n            }\\n            k -= 1;\\n            u.pop_back();\\n            j /= 10;\\n            ++i;\\n        }\\n        \\n        return num;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        int j(1);\\n        std::vector<int> u= {0}",
                "codeTag": "Java"
            },
            {
                "id": 426936,
                "title": "pyhon-concise-solution",
                "content": "```\\nclass Solution:\\n    def findKthNumber(self, n, k):\\n        pre=1 #\\u8D77\\u59CB\\u524D\\u7F00\\n        pos=1\\n        while pos<k:\\n            cnt=self.count(pre,n)\\n            if pos+cnt>k:\\n                #\\u5728pre\\u524D\\u7F00\\u4E0B\\uFF0C\\u5728pre\\u524D\\u7F00\\u5BF9\\u5E94\\u7684\\u533A\\u95F4\\u91CCpre\\uFF0Cpos\\u9010\\u4F4D\\u79FB\\u52A8\\n                pre*=10\\n                pos+=1\\n            else:\\n                #next prefix\\n                pre+=1\\n                pos+=cnt\\n        return pre\\n        \\n    #\\u4EE5pre\\u4E3A\\u524D\\u7F00\\u7684\\u6570\\u5B57\\u4E2A\\u6570\\n    def count(self,pre,n):\\n        #\\u4EE5pre\\u4E3A\\u524D\\u7F00\\u7684\\u6570\\u5B57\\u5728\\u533A\\u95F4[a, min(n+1,b))\\uFF0C\\u6CE8\\u610F\\u533A\\u95F4\\u5DE6\\u95ED\\u53F3\\u5F00,\\n        #\\u4E5F\\u5C31\\u662F\\u5982\\u679Cb\\u66F4\\u5C0F\\uFF0C\\u5219\\u4E0D\\u80FD\\u5305\\u542B\\u4E0B\\u4E00\\u4E2A\\u524D\\u7F00\\uFF0C\\u5982\\u679Cn+1\\u66F4\\u5C0F\\uFF0C\\u5219\\u4E0D\\u80FD\\u5305\\u542Bn+1(n\\u4E3A\\u4E0A\\u754C)\\n        cnt=0\\n        a=pre\\n        b=pre+1\\n        while a<=n:\\n            cnt += min(n+1,b) - a #\\u5DE6\\u95ED\\u53F3\\u5F00\\uFF0C\\u6240\\u4EE5\\u4E0D\\u4F1A\\u989D\\u5916+1\\n            #update next a,b\\n            a*=10\\n            b*=10\\n        return cnt",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findKthNumber(self, n, k):\\n        pre=1 #\\u8D77\\u59CB\\u524D\\u7F00\\n        pos=1\\n        while pos<k:\\n            cnt=self.count(pre,n)\\n            if pos+cnt>k:\\n                #\\u5728pre\\u524D\\u7F00\\u4E0B\\uFF0C\\u5728pre\\u524D\\u7F00\\u5BF9\\u5E94\\u7684\\u533A\\u95F4\\u91CCpre\\uFF0Cpos\\u9010\\u4F4D\\u79FB\\u52A8\\n                pre*=10\\n                pos+=1\\n            else:\\n                #next prefix\\n                pre+=1\\n                pos+=cnt\\n        return pre\\n        \\n    #\\u4EE5pre\\u4E3A\\u524D\\u7F00\\u7684\\u6570\\u5B57\\u4E2A\\u6570\\n    def count(self,pre,n):\\n        #\\u4EE5pre\\u4E3A\\u524D\\u7F00\\u7684\\u6570\\u5B57\\u5728\\u533A\\u95F4[a, min(n+1,b))\\uFF0C\\u6CE8\\u610F\\u533A\\u95F4\\u5DE6\\u95ED\\u53F3\\u5F00,\\n        #\\u4E5F\\u5C31\\u662F\\u5982\\u679Cb\\u66F4\\u5C0F\\uFF0C\\u5219\\u4E0D\\u80FD\\u5305\\u542B\\u4E0B\\u4E00\\u4E2A\\u524D\\u7F00\\uFF0C\\u5982\\u679Cn+1\\u66F4\\u5C0F\\uFF0C\\u5219\\u4E0D\\u80FD\\u5305\\u542Bn+1(n\\u4E3A\\u4E0A\\u754C)\\n        cnt=0\\n        a=pre\\n        b=pre+1\\n        while a<=n:\\n            cnt += min(n+1,b) - a #\\u5DE6\\u95ED\\u53F3\\u5F00\\uFF0C\\u6240\\u4EE5\\u4E0D\\u4F1A\\u989D\\u5916+1\\n            #update next a,b\\n            a*=10\\n            b*=10\\n        return cnt",
                "codeTag": "Java"
            },
            {
                "id": 418938,
                "title": "the-definition-of-lexicographic-is-wrong",
                "content": "The example says that the sequence [1, 10, 11, 12, 13, 2, ...] is lexicographic but this is obviously wrong since the correct lexicographic order is:\\n\\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\\n\\nsince the lengths have to be compared first. Only if the lengths of two items are equal are they then compared alphabetically.",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 411512,
                "title": "o-log-n-scala-solution",
                "content": "The following scala solution is based on the idea that the position of any number can be calclated by adding the number of lesser digits for each logaritm that exists in the max number - see the **pos** metod.\\n\\nIt was in the 100 percentile for both memory and execution time.\\n\\n``` Scala\\nobject Solution {\\n  val pow10:Array[Int] = (0 to 9).map(v => math.pow(10, v).toInt).toArray\\n\\n  def stepLength(depth: Int, max: Int) = (0 to max-depth).map(p => pow10(p)).reduce(_ + _)\\n\\n  def nextNumDown(v: Int) = {\\n    // the next number is found by dividing by 10, adding one and then strip any trailing zeros\\n    var next = v / 10 + 1\\n    while (next % 10 == 0)\\n      next /= 10\\n    next\\n  }\\n\\n  def pos  (p: Int, v: Int) =\\n    (0 to p)\\n      .map(n => (n, v / pow10(n) match {\\n        case 0 =>\\n          v * pow10(n - math.log10(v).toInt) - 1\\n        case b: Int => b\\n      }))\\n      .map(m => m._2 - pow10(m._1) + 1)\\n      .reduce(_ + _) - 1\\n\\n\\n  def findKthNumber(n: Int, k: Int): Int = //time(\"findKthNumber\")\\n  {\\n    val zeroOffset = k - 1\\n\\n    val numDigits = math.log10(n).toInt\\n    val breakPoint = pos(numDigits, n)\\n    //System.out.println(s\"$k $n -> $numDigits digits $breakPoint\")\\n    val (pow, target) =\\n      if (zeroOffset > breakPoint)\\n        Some((numDigits - 1, zeroOffset - (breakPoint - pos(numDigits - 1, nextNumDown(n)) + 1))).get\\n      else\\n        (numDigits, zeroOffset)\\n    if (pow > zeroOffset) {\\n      return pow10(zeroOffset)\\n    }\\n    val steps = (0 to pow).map(stepLength(_, pow)).toArray\\n    var step = (0 to pow).find(v => v == pow || steps(v) <= target).get\\n    var value = pow10(step)\\n    var currPos = step\\n    while (currPos != target) {\\n      while (currPos + steps(step) <= target) {\\n        value += 1\\n        currPos += steps(step)\\n      }\\n      if (currPos != target) {\\n        value = value * 10\\n        currPos = currPos + 1\\n        step += 1\\n      }\\n    }\\n\\n    value\\n  }\\n }\\n ```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "``` Scala\\nobject Solution {\\n  val pow10:Array[Int] = (0 to 9).map(v => math.pow(10, v).toInt).toArray\\n\\n  def stepLength(depth: Int, max: Int) = (0 to max-depth).map(p => pow10(p)).reduce(_ + _)\\n\\n  def nextNumDown(v: Int) = {\\n    // the next number is found by dividing by 10, adding one and then strip any trailing zeros\\n    var next = v / 10 + 1\\n    while (next % 10 == 0)\\n      next /= 10\\n    next\\n  }\\n\\n  def pos  (p: Int, v: Int) =\\n    (0 to p)\\n      .map(n => (n, v / pow10(n) match {\\n        case 0 =>\\n          v * pow10(n - math.log10(v).toInt) - 1\\n        case b: Int => b\\n      }))\\n      .map(m => m._2 - pow10(m._1) + 1)\\n      .reduce(_ + _) - 1\\n\\n\\n  def findKthNumber(n: Int, k: Int): Int = //time(\"findKthNumber\")\\n  {\\n    val zeroOffset = k - 1\\n\\n    val numDigits = math.log10(n).toInt\\n    val breakPoint = pos(numDigits, n)\\n    //System.out.println(s\"$k $n -> $numDigits digits $breakPoint\")\\n    val (pow, target) =\\n      if (zeroOffset > breakPoint)\\n        Some((numDigits - 1, zeroOffset - (breakPoint - pos(numDigits - 1, nextNumDown(n)) + 1))).get\\n      else\\n        (numDigits, zeroOffset)\\n    if (pow > zeroOffset) {\\n      return pow10(zeroOffset)\\n    }\\n    val steps = (0 to pow).map(stepLength(_, pow)).toArray\\n    var step = (0 to pow).find(v => v == pow || steps(v) <= target).get\\n    var value = pow10(step)\\n    var currPos = step\\n    while (currPos != target) {\\n      while (currPos + steps(step) <= target) {\\n        value += 1\\n        currPos += steps(step)\\n      }\\n      if (currPos != target) {\\n        value = value * 10\\n        currPos = currPos + 1\\n        step += 1\\n      }\\n    }\\n\\n    value\\n  }\\n }\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 362259,
                "title": "c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        long long cnt=1;\\n        k--;\\n        while (k) {\\n            long long st=0,head=cnt,tail=cnt+1;\\n            while (head<=n) {\\n                if (tail>n+1)\\n                    st += n+1-head;\\n                else\\n                    st += tail-head;\\n                head *= 10;\\n                tail *= 10;\\n            }\\n            \\n            if (st<=k) {\\n                cnt++;\\n                k-=st;\\n            }\\n            else {\\n                cnt*=10;\\n                k--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        long long cnt=1;\\n        k--;\\n        while (k) {\\n            long long st=0,head=cnt,tail=cnt+1;\\n            while (head<=n) {\\n                if (tail>n+1)\\n                    st += n+1-head;\\n                else\\n                    st += tail-head;\\n                head *= 10;\\n                tail *= 10;\\n            }\\n            \\n            if (st<=k) {\\n                cnt++;\\n                k-=st;\\n            }\\n            else {\\n                cnt*=10;\\n                k--;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353256,
                "title": "c-binary-search-and-dp",
                "content": "```cpp\\nstruct Node { \\n    int first, last; \\n  \\n    Node (int f, int l) \\n    { \\n        first = f; \\n        last = l; \\n    } \\n  \\n    bool operator==(const Node& p) const\\n    { \\n        return first == p.first && last == p.last; \\n    } \\n};\\n\\nclass MyHashFunction { \\npublic: \\n    size_t operator()(const Node& p) const\\n    { \\n        return (hash<int>()(p.first)) ^  \\n               (hash<int>()(p.last)); \\n    } \\n}; \\n  \\n\\ntypedef std::pair<int, int> pair;\\n\\nstruct pair_hash\\n{\\n\\ttemplate <class T1, class T2>\\n\\tstd::size_t operator() (const std::pair<T1, T2> &pair) const\\n\\t{\\n\\t\\treturn std::hash<T1>()(pair.first) ^ std::hash<T2>()(pair.second);\\n\\t}\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    unordered_map<Node,int,MyHashFunction> mp;\\n    int count(vector<int>& K, int pos, int start, int first, bool upp, bool upp2) {\\n        if (pos == -1) {\\n            return first != 0;\\n        }\\n        if (!upp && !upp2 && mp.find({pos, start}) != mp.end()) return mp[{pos, start}];\\n        int res = 0;\\n        int r = upp ? nums[pos] : 9;\\n        int r2 = upp2 ? (start < K.size() ? K[start] : 9) : 9;\\n        for (int i = 0; i <= min(r, r2); ++i) {\\n            if (!upp2) {\\n                int next_first = first > 0 ? first : i;\\n                res += count(K, pos - 1, start, next_first, upp && i == r, upp2);\\n            }\\n            else {\\n                if (start < K.size() && i <= K[start]) {\\n                    int next_first = first > 0 ? first : i;\\n                    res += count(K, pos - 1, i == K[start] ? start + 1 : start, next_first, upp && i == r, next_first == 0 ? upp2 : upp2 && i == r2);\\n                }\\n            }\\n        }\\n        if (!upp && !upp2) mp[{pos, start}] = res;\\n        return res;\\n    }\\n    int count_it(vector<int>& K) {\\n        mp.clear();\\n        return count(K, nums.size() - 1, 0, 0, true, true);\\n    }\\n    int getNumber(vector<int>& nums) {\\n        int res = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            res = res * 10 + nums[i];\\n        }\\n        return res;\\n    }\\n\\n    int findKthNumber(int n, int k) {\\n        int nn = n;\\n        while (nn > 0) {\\n            nums.push_back(nn % 10);\\n            nn /= 10;\\n        }\\n\\n        vector<int> K = {};\\n        int pos = n - 1;\\n        bool flag = true;\\n        int cur = 0;\\n        while (1) {\\n            int l = K.empty() ? 1 : 0;\\n            int r = 9;\\n            while (l < r) {\\n                int mid = (l + r + 1) / 2;\\n                K.push_back(mid);\\n                for (auto tmp: K) cout << tmp << \" \" ;\\n                if (count_it(K) <= k && cur * 10 + mid <= n) {\\n                    l = mid;\\n                }\\n                else {\\n                    r = mid - 1;\\n                }\\n                K.pop_back();\\n            }\\n            cur = cur * 10 + l;\\n            K.push_back(l);\\n            if (count_it(K) == k) {\\n                return getNumber(K);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstruct Node { \\n    int first, last; \\n  \\n    Node (int f, int l) \\n    { \\n        first = f; \\n        last = l; \\n    } \\n  \\n    bool operator==(const Node& p) const\\n    { \\n        return first == p.first && last == p.last; \\n    } \\n};\\n\\nclass MyHashFunction { \\npublic: \\n    size_t operator()(const Node& p) const\\n    { \\n        return (hash<int>()(p.first)) ^  \\n               (hash<int>()(p.last)); \\n    } \\n}; \\n  \\n\\ntypedef std::pair<int, int> pair;\\n\\nstruct pair_hash\\n{\\n\\ttemplate <class T1, class T2>\\n\\tstd::size_t operator() (const std::pair<T1, T2> &pair) const\\n\\t{\\n\\t\\treturn std::hash<T1>()(pair.first) ^ std::hash<T2>()(pair.second);\\n\\t}\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> nums;\\n    unordered_map<Node,int,MyHashFunction> mp;\\n    int count(vector<int>& K, int pos, int start, int first, bool upp, bool upp2) {\\n        if (pos == -1) {\\n            return first != 0;\\n        }\\n        if (!upp && !upp2 && mp.find({pos, start}) != mp.end()) return mp[{pos, start}];\\n        int res = 0;\\n        int r = upp ? nums[pos] : 9;\\n        int r2 = upp2 ? (start < K.size() ? K[start] : 9) : 9;\\n        for (int i = 0; i <= min(r, r2); ++i) {\\n            if (!upp2) {\\n                int next_first = first > 0 ? first : i;\\n                res += count(K, pos - 1, start, next_first, upp && i == r, upp2);\\n            }\\n            else {\\n                if (start < K.size() && i <= K[start]) {\\n                    int next_first = first > 0 ? first : i;\\n                    res += count(K, pos - 1, i == K[start] ? start + 1 : start, next_first, upp && i == r, next_first == 0 ? upp2 : upp2 && i == r2);\\n                }\\n            }\\n        }\\n        if (!upp && !upp2) mp[{pos, start}] = res;\\n        return res;\\n    }\\n    int count_it(vector<int>& K) {\\n        mp.clear();\\n        return count(K, nums.size() - 1, 0, 0, true, true);\\n    }\\n    int getNumber(vector<int>& nums) {\\n        int res = 0;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            res = res * 10 + nums[i];\\n        }\\n        return res;\\n    }\\n\\n    int findKthNumber(int n, int k) {\\n        int nn = n;\\n        while (nn > 0) {\\n            nums.push_back(nn % 10);\\n            nn /= 10;\\n        }\\n\\n        vector<int> K = {};\\n        int pos = n - 1;\\n        bool flag = true;\\n        int cur = 0;\\n        while (1) {\\n            int l = K.empty() ? 1 : 0;\\n            int r = 9;\\n            while (l < r) {\\n                int mid = (l + r + 1) / 2;\\n                K.push_back(mid);\\n                for (auto tmp: K) cout << tmp << \" \" ;\\n                if (count_it(K) <= k && cur * 10 + mid <= n) {\\n                    l = mid;\\n                }\\n                else {\\n                    r = mid - 1;\\n                }\\n                K.pop_back();\\n            }\\n            cur = cur * 10 + l;\\n            K.push_back(l);\\n            if (count_it(K) == k) {\\n                return getNumber(K);\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 312557,
                "title": "golang",
                "content": "Brilliant solution from https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/discuss/92242/ConciseEasy-to-understand-Java-5ms-solution-with-Explaination\\n```\\nfunc findKthNumber(n int, k int) int {\\n\\tif n < k {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tcur := 1\\n\\tk = k - 1\\n\\tfor k > 0 {\\n\\t\\tsubtreesum := getSubTreeSum(n, cur, cur+1)\\n\\t\\tif k >= subtreesum {\\n\\t\\t\\tcur = cur + 1\\n\\t\\t\\tk -= subtreesum\\n\\t\\t} else {\\n\\t\\t\\tcur = cur * 10\\n\\t\\t\\tk -= 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn cur\\n}\\n\\nfunc getSubTreeSum(n int, cur int, next int) int {\\n\\tsum := 0\\n\\tfor cur <= n {\\n\\t\\tsum += getMin(next-cur, n-cur+1)\\n\\t\\tcur = cur * 10\\n\\t\\tnext = next * 10\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc getMin(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findKthNumber(n int, k int) int {\\n\\tif n < k {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tcur := 1\\n\\tk = k - 1\\n\\tfor k > 0 {\\n\\t\\tsubtreesum := getSubTreeSum(n, cur, cur+1)\\n\\t\\tif k >= subtreesum {\\n\\t\\t\\tcur = cur + 1\\n\\t\\t\\tk -= subtreesum\\n\\t\\t} else {\\n\\t\\t\\tcur = cur * 10\\n\\t\\t\\tk -= 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn cur\\n}\\n\\nfunc getSubTreeSum(n int, cur int, next int) int {\\n\\tsum := 0\\n\\tfor cur <= n {\\n\\t\\tsum += getMin(next-cur, n-cur+1)\\n\\t\\tcur = cur * 10\\n\\t\\tnext = next * 10\\n\\t}\\n\\n\\treturn sum\\n}\\n\\nfunc getMin(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 312036,
                "title": "python-simple-solution-inspired-by-hottest-post",
                "content": "calculate node\\'s number by adding level by level until last level cannot add anymore.\\nmaintain leftmost and rightmost node to do this process\\n```\\nclass Solution(object):\\n    def findKthNumber(self, n, k):\\n        def cal(prefix): # calculate for numbers of number contains prefix satisfy numbers<=k.\\n            steps=0#count for current node\\n            l=r=prefix\\n            while l<=n:\\n                if r<=n:\\n                    steps+=r-l+1\\n                else:#right out of range\\n                    steps+=max(0,n-l+1)\\n                l*=10\\n                r=r*10+9        \\n            return steps\\n        prefix = 1\\n        k-=1#count for current prefix\\n        while k > 0:\\n            val=cal(prefix)\\n            if val>k:#find the ans\\n                k-=1#going to current prefix\\'s subprefix x*10\\n                prefix*=10\\n            elif val==k:#if val==k,means exactly jump to next prefix.\\n                return prefix+1\\n            else:\\n                prefix+=1\\n                k-=val\\n        return prefix",
                "solutionTags": [],
                "code": "calculate node\\'s number by adding level by level until last level cannot add anymore.\\nmaintain leftmost and rightmost node to do this process\\n```\\nclass Solution(object):\\n    def findKthNumber(self, n, k):\\n        def cal(prefix): # calculate for numbers of number contains prefix satisfy numbers<=k.\\n            steps=0#count for current node\\n            l=r=prefix\\n            while l<=n:\\n                if r<=n:\\n                    steps+=r-l+1\\n                else:#right out of range\\n                    steps+=max(0,n-l+1)\\n                l*=10\\n                r=r*10+9        \\n            return steps\\n        prefix = 1\\n        k-=1#count for current prefix\\n        while k > 0:\\n            val=cal(prefix)\\n            if val>k:#find the ans\\n                k-=1#going to current prefix\\'s subprefix x*10\\n                prefix*=10\\n            elif val==k:#if val==k,means exactly jump to next prefix.\\n                return prefix+1\\n            else:\\n                prefix+=1\\n                k-=val\\n        return prefix",
                "codeTag": "Java"
            },
            {
                "id": 306099,
                "title": "c-beat-100",
                "content": "```\\nint num(int n, int pre) { //the amount of the number start with pre and not bigger than n\\n\\tint lp = log(pre + 0.5) / log(10) + 1, l = log(n + 0.5) / log(10) + 1;\\n\\tint top = n / pow(10, l - lp);\\n\\tif (top == pre) {\\n\\t\\treturn n % (int)pow(10, l - lp) + 1 + (pow(10, l - lp) - 1) / 9; //the length of the number may be l, l + 1...lp\\n\\t} else if (top > pre) {\\n\\t\\treturn (pow(10, l - lp + 1) - 1) / 9;//the length of the number may be l, l + 1...lp\\n\\t} else {\\n\\t\\treturn (pow(10, l - lp) - 1) / 9;//the length of the number may be l, l + 1...lp-1\\n\\t}\\n\\treturn 0;\\n\\n}\\n\\nint findKthNumber(int n, int k) {\\n\\tint pre = 1; //the ans start with pre\\n\\twhile (k > 0) {\\n\\t\\tif (k == 1) //if the ans is the first one of the number start with pre, return pre itself\\n\\t\\t\\treturn pre;\\n\\t\\tint size = num(n, pre); \\n\\t\\tif (k > size) { //if the ans not start with pre, but start with pre + 1\\n\\t\\t\\tk = k - size;\\n\\t\\t\\tpre++;\\n\\t\\t} else {\\n\\t\\t\\tk--; // the ans start with pre, but not the first one of the number start with pre\\n\\t\\t\\tpre = pre * 10;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint num(int n, int pre) { //the amount of the number start with pre and not bigger than n\\n\\tint lp = log(pre + 0.5) / log(10) + 1, l = log(n + 0.5) / log(10) + 1;\\n\\tint top = n / pow(10, l - lp);\\n\\tif (top == pre) {\\n\\t\\treturn n % (int)pow(10, l - lp) + 1 + (pow(10, l - lp) - 1) / 9; //the length of the number may be l, l + 1...lp\\n\\t} else if (top > pre) {\\n\\t\\treturn (pow(10, l - lp + 1) - 1) / 9;//the length of the number may be l, l + 1...lp\\n\\t} else {\\n\\t\\treturn (pow(10, l - lp) - 1) / 9;//the length of the number may be l, l + 1...lp-1\\n\\t}\\n\\treturn 0;\\n\\n}\\n\\nint findKthNumber(int n, int k) {\\n\\tint pre = 1; //the ans start with pre\\n\\twhile (k > 0) {\\n\\t\\tif (k == 1) //if the ans is the first one of the number start with pre, return pre itself\\n\\t\\t\\treturn pre;\\n\\t\\tint size = num(n, pre); \\n\\t\\tif (k > size) { //if the ans not start with pre, but start with pre + 1\\n\\t\\t\\tk = k - size;\\n\\t\\t\\tpre++;\\n\\t\\t} else {\\n\\t\\t\\tk--; // the ans start with pre, but not the first one of the number start with pre\\n\\t\\t\\tpre = pre * 10;\\n\\t\\t}\\n\\t}\\n\\treturn 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255894,
                "title": "trying-to-understand-this-solution",
                "content": "```\\n    public int findKthNumber(int n, int k) {\\n        int res = 1;\\n        k--;\\n        \\n        while(k > 0) {\\n            long steps = calSteps(n, res, res + 1);\\n            if(steps <= k) {\\n                res++;\\n                k -= steps;\\n            } else {\\n                res *= 10;\\n                k--;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    long calSteps(long n, long cur, long nxt) {\\n        long steps = 0;\\n        while(cur <= n) {\\n            steps += Math.min(n+1, nxt) - cur;\\n            cur *= 10;\\n            nxt *= 10;\\n        }\\n        return steps;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findKthNumber(int n, int k) {\\n        int res = 1;\\n        k--;\\n        \\n        while(k > 0) {\\n            long steps = calSteps(n, res, res + 1);\\n            if(steps <= k) {\\n                res++;\\n                k -= steps;\\n            } else {\\n                res *= 10;\\n                k--;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    long calSteps(long n, long cur, long nxt) {\\n        long steps = 0;\\n        while(cur <= n) {\\n            steps += Math.min(n+1, nxt) - cur;\\n            cur *= 10;\\n            nxt *= 10;\\n        }\\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249702,
                "title": "c-i-think-it-should-be-liner-search-o-log10-n-4ms",
                "content": "The idea is to think the n is  {A1,A2,A3,A4,...An} .  For example n = 103,  A1=1, A2=0, A3 = 3.\\n\\nThen first found A1 = value, after A1 is decided, then goto next level to find A2 value. Every time we chould remove some K and when k = 0.  We get the answer.\\n\\n4ms solution\\n```\\n// 4ms\\n\\n#define pr(a,b)\\nclass Solution {\\npublic:\\n    int maxL;\\n    vector<int> lvalues;\\n    bool IsLastLevel(int n, int l) {\\n       return l == maxL; \\n    }\\n\\n    int GenLastLevel(int l, int s, int k) {\\n        return s + k - 1;\\n    }\\n\\n\\n    int GetCurrnetCounts(int curr, int l, int n)\\n    {\\n        int v = 0;\\n        int v1 = 1;\\n        int baseV = GeneratResult(l - 1);\\n\\n        baseV = baseV * 10 + curr;\\n        pr(baseV, curr);\\n\\n        if (1) {\\n            while ( l <= maxL) {\\n                if (l < maxL) \\n                {\\n                    v = v  + v1;\\n                    v1 = v1 * 10;\\n                    baseV = baseV * 10;\\n                }\\n                else {\\n                    pr(baseV, n); \\n                    if (baseV <= n)\\n                        v = v + min(v1, n - baseV + 1);\\n                }\\n                pr(v, l);\\n                l++;\\n            } \\n        } \\n        return v;\\n    }\\n\\n    int GetLastLevel(int s, int k)\\n    {\\n        return s + k - 1;\\n    }\\n\\n    void _findKthNumber(int n, int l , int s, int k) {\\n        int _k  = k;\\n        pr(n, l);\\n        pr(s,k);\\n\\n        if (IsLastLevel(n, l)) {\\n           int v = GetLastLevel(s, k); \\n           pr(l, v);\\n           lvalues[l] = v;\\n           return;\\n        }\\n\\n        int cNum;\\n        // find current level value\\n        for (int i = s; i <= 9; i++) {\\n            int v;\\n            v = GetCurrnetCounts(i, l, n);\\n            pr(i, v);\\n            if (v >= _k) {\\n                cNum = i; \\n                break;\\n            }\\n            else {\\n                _k -= v;\\n            }\\n        }\\n\\n        lvalues[l] = cNum;\\n\\n\\n        // goto next level\\n        _k = _k - 1;\\n        if (_k > 0)\\n            _findKthNumber(n, l + 1, 0, _k);\\n    }\\n\\n    int findKthNumber(int n, int k){\\n        int _n = n;\\n\\n        maxL = 0;\\n        while(_n) {_n /= 10; maxL++;}\\n\\n        lvalues.resize(maxL + 1, -1);\\n        \\n        _n = n; \\n        int j = 0;\\n\\n\\n        _findKthNumber(n, 1, 1, k);\\n\\n        int v = GeneratResult(maxL);\\n        return v;\\n    }\\n\\n    int GeneratResult(int _maxL)\\n    {\\n        if (_maxL == 0) return 0;\\n        int v = 0;\\n        for ( int i = 1; i <= _maxL; i++) {\\n            if (lvalues[i] != -1) {\\n                v = v * 10;\\n                v = v + lvalues[i];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// 4ms\\n\\n#define pr(a,b)\\nclass Solution {\\npublic:\\n    int maxL;\\n    vector<int> lvalues;\\n    bool IsLastLevel(int n, int l) {\\n       return l == maxL; \\n    }\\n\\n    int GenLastLevel(int l, int s, int k) {\\n        return s + k - 1;\\n    }\\n\\n\\n    int GetCurrnetCounts(int curr, int l, int n)\\n    {\\n        int v = 0;\\n        int v1 = 1;\\n        int baseV = GeneratResult(l - 1);\\n\\n        baseV = baseV * 10 + curr;\\n        pr(baseV, curr);\\n\\n        if (1) {\\n            while ( l <= maxL) {\\n                if (l < maxL) \\n                {\\n                    v = v  + v1;\\n                    v1 = v1 * 10;\\n                    baseV = baseV * 10;\\n                }\\n                else {\\n                    pr(baseV, n); \\n                    if (baseV <= n)\\n                        v = v + min(v1, n - baseV + 1);\\n                }\\n                pr(v, l);\\n                l++;\\n            } \\n        } \\n        return v;\\n    }\\n\\n    int GetLastLevel(int s, int k)\\n    {\\n        return s + k - 1;\\n    }\\n\\n    void _findKthNumber(int n, int l , int s, int k) {\\n        int _k  = k;\\n        pr(n, l);\\n        pr(s,k);\\n\\n        if (IsLastLevel(n, l)) {\\n           int v = GetLastLevel(s, k); \\n           pr(l, v);\\n           lvalues[l] = v;\\n           return;\\n        }\\n\\n        int cNum;\\n        // find current level value\\n        for (int i = s; i <= 9; i++) {\\n            int v;\\n            v = GetCurrnetCounts(i, l, n);\\n            pr(i, v);\\n            if (v >= _k) {\\n                cNum = i; \\n                break;\\n            }\\n            else {\\n                _k -= v;\\n            }\\n        }\\n\\n        lvalues[l] = cNum;\\n\\n\\n        // goto next level\\n        _k = _k - 1;\\n        if (_k > 0)\\n            _findKthNumber(n, l + 1, 0, _k);\\n    }\\n\\n    int findKthNumber(int n, int k){\\n        int _n = n;\\n\\n        maxL = 0;\\n        while(_n) {_n /= 10; maxL++;}\\n\\n        lvalues.resize(maxL + 1, -1);\\n        \\n        _n = n; \\n        int j = 0;\\n\\n\\n        _findKthNumber(n, 1, 1, k);\\n\\n        int v = GeneratResult(maxL);\\n        return v;\\n    }\\n\\n    int GeneratResult(int _maxL)\\n    {\\n        if (_maxL == 0) return 0;\\n        int v = 0;\\n        for ( int i = 1; i <= _maxL; i++) {\\n            if (lvalues[i] != -1) {\\n                v = v * 10;\\n                v = v + lvalues[i];\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188642,
                "title": "python-1-line-tle",
                "content": "\nO(N Log N) Solution with multiple castings that reliably times out but I think its still pretty elegant :D\n\n\n```\n\n\nclass Solution:\n    def findKthNumber(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return int(sorted(list(map (str, range(1,n+1))))[k-1])\n```",
                "solutionTags": [],
                "code": "```\n\n\nclass Solution:\n    def findKthNumber(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        return int(sorted(list(map (str, range(1,n+1))))[k-1])\n```",
                "codeTag": "Java"
            },
            {
                "id": 147498,
                "title": "python-20ms-beats-100",
                "content": "Idea is to use trie and traverse it with DFS. Each node has `index` - number of lexicographically smaller strings. For each node we can find its maximum index in its subtree with a simple computation and, using maximum index we can effectively skip all the nodes except the answer node.\\n\\n```\\n        L = len(str(n))\\n        onezeros = pow(10, L - 1)\\n        weight = int(\\'\\'.join([\\'1\\'] * L)) - 1\\n\\n        path = 0\\n        index = 0\\n        while True:\\n            if index == k:\\n                return path\\n\\n            index += 1\\n\\n            for child in range(10):\\n                if path == 0 and child == 0:\\n                    continue\\n\\n                value = path * 10 + child\\n                max_value = (value + 1) * onezeros - 1\\n\\n                if index == k:\\n                    return value\\n\\n                if max_value <= n:\\n                    max_index = index + weight\\n\\n                else:\\n                    if value * onezeros <= n:\\n                        dw = weight // 10 + n - value*onezeros\\n                    else:\\n                        dw = weight // 10 - 1\\n\\n                    max_index = index + dw\\n\\n                if max_index >= k:\\n                    path = path * 10 + child\\n                    onezeros = onezeros // 10\\n                    weight = weight // 10 - 1\\n                    break\\n\\n                index = max_index + 1\\n```",
                "solutionTags": [],
                "code": "```\\n        L = len(str(n))\\n        onezeros = pow(10, L - 1)\\n        weight = int(\\'\\'.join([\\'1\\'] * L)) - 1\\n\\n        path = 0\\n        index = 0\\n        while True:\\n            if index == k:\\n                return path\\n\\n            index += 1\\n\\n            for child in range(10):\\n                if path == 0 and child == 0:\\n                    continue\\n\\n                value = path * 10 + child\\n                max_value = (value + 1) * onezeros - 1\\n\\n                if index == k:\\n                    return value\\n\\n                if max_value <= n:\\n                    max_index = index + weight\\n\\n                else:\\n                    if value * onezeros <= n:\\n                        dw = weight // 10 + n - value*onezeros\\n                    else:\\n                        dw = weight // 10 - 1\\n\\n                    max_index = index + dw\\n\\n                if max_index >= k:\\n                    path = path * 10 + child\\n                    onezeros = onezeros // 10\\n                    weight = weight // 10 - 1\\n                    break\\n\\n                index = max_index + 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92243,
                "title": "java-5ms-recursive-solution-traversing-the-dfs-tree-generating-the-lexicographical-items",
                "content": "```\\nclass Solution {\\n    private static int[] treeSize = new int[10];\\n    private static int[] pows = new int[10];\\n    \\n    static {\\n        treeSize[0] = 1;\\n        pows[0] = 1;\\n        for (int a = 1; a <= 9; ++a) {\\n            pows[a] = pows[a - 1] * 10;\\n            treeSize[a] = treeSize[a - 1]+pows[a];\\n        }\\n    }\\n    \\n    public int findKthNumber(int n, int k) {\\n        int pow = 0;\\n        for (int a = n/10; a > 0; a /= 10, ++pow) ;\\n        return findKthNumber(n, n, k - 1, pow, 1, 0);\\n    }\\n\\n    private int findKthNumber(int n, int size, int k, int pow, int lo, int pfx) {\\n        if (k < 0){\\n            return pfx;\\n        }\\n        if (pow == 0) {\\n            return 10 * pfx + lo + k;\\n        }\\n        int msd = n / pows[pow];\\n        int before = (msd - lo) * treeSize[pow];\\n        int after = (Math.min(size, 9) - msd) * treeSize[pow - 1];\\n        int mid = size - before - after;\\n        if (k < before) {\\n            return findInCompleteTree(k - 1 - (k / treeSize[pow]) * treeSize[pow], pow - 1, 10 * pfx + lo + k / treeSize[pow]);\\n        }\\n        if (k < before + mid) {\\n            return findKthNumber(n - msd * pows[pow], mid - 1, k - before - 1, pow - 1, 0, 10 * pfx + msd);\\n        }\\n        return findInCompleteTree(k - 1 - before - mid - ((k-before-mid)/ treeSize[pow-1]) * treeSize[pow-1], pow - 2, 10 * pfx + msd + 1 + (k - before - mid) / treeSize[pow - 1]);\\n    }\\n\\n    private int findInCompleteTree(int k, int pow, int pfx) {\\n        if (k < 0){\\n            return pfx;\\n        }\\n        if (pow == 0) {\\n            return 10 * pfx + k;\\n        }\\n        return findInCompleteTree(k - 1 - (k/treeSize[pow])*treeSize[pow], pow - 1, 10 * pfx + k / treeSize[pow]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static int[] treeSize = new int[10];\\n    private static int[] pows = new int[10];\\n    \\n    static {\\n        treeSize[0] = 1;\\n        pows[0] = 1;\\n        for (int a = 1; a <= 9; ++a) {\\n            pows[a] = pows[a - 1] * 10;\\n            treeSize[a] = treeSize[a - 1]+pows[a];\\n        }\\n    }\\n    \\n    public int findKthNumber(int n, int k) {\\n        int pow = 0;\\n        for (int a = n/10; a > 0; a /= 10, ++pow) ;\\n        return findKthNumber(n, n, k - 1, pow, 1, 0);\\n    }\\n\\n    private int findKthNumber(int n, int size, int k, int pow, int lo, int pfx) {\\n        if (k < 0){\\n            return pfx;\\n        }\\n        if (pow == 0) {\\n            return 10 * pfx + lo + k;\\n        }\\n        int msd = n / pows[pow];\\n        int before = (msd - lo) * treeSize[pow];\\n        int after = (Math.min(size, 9) - msd) * treeSize[pow - 1];\\n        int mid = size - before - after;\\n        if (k < before) {\\n            return findInCompleteTree(k - 1 - (k / treeSize[pow]) * treeSize[pow], pow - 1, 10 * pfx + lo + k / treeSize[pow]);\\n        }\\n        if (k < before + mid) {\\n            return findKthNumber(n - msd * pows[pow], mid - 1, k - before - 1, pow - 1, 0, 10 * pfx + msd);\\n        }\\n        return findInCompleteTree(k - 1 - before - mid - ((k-before-mid)/ treeSize[pow-1]) * treeSize[pow-1], pow - 2, 10 * pfx + msd + 1 + (k - before - mid) / treeSize[pow - 1]);\\n    }\\n\\n    private int findInCompleteTree(int k, int pow, int pfx) {\\n        if (k < 0){\\n            return pfx;\\n        }\\n        if (pow == 0) {\\n            return 10 * pfx + k;\\n        }\\n        return findInCompleteTree(k - 1 - (k/treeSize[pow])*treeSize[pow], pow - 1, 10 * pfx + k / treeSize[pow]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92244,
                "title": "c-worst-case-o-logn-time-o-logn-space-clean-solution-w-detailed-explanation",
                "content": "```\\n/// O(log10(N)) Time & Space\\n/// The main idea to simplify the implementation is, when count, start with empty then 0's at a certain length;\\n/// E.g. when do n = 345, k = 250, instead of counting from 1, 10, 100, ...., count from EMPTY, 0, 00, 000, 001, 002..09, 091, 092, ..099, 1\\n/// Therefore, I count 112 (there is an EMPTY at first) more than you should. So I add this difference first;\\n/// The reason why I do it this way is it will greatly simplify the implementation later.\\n/// Suppose I'm in an intermediate round, I have prevdigs = 3. I want to calculate solve(45, 27) now,\\n/// because there is a leading digit, it makes 0, 00 or even EMPTY valid now -- they can make 30, 300, 3 respectively.\\n/// So in all intermediate rounds, it's beneficial to consider 0, 00, EMPTY before 1XX. The only exceptional round is the first one.\\n/// So I just need to do some manipulate with the first round, then we are all good.\\nclass Solution {\\n    int solve(int n, int k, int prevdigs, int len) /// prevdigs are all digits known so far.\\n    {\\n        if (k == 0)          /// in this function, k = 0 means the 1st number.\\n            return prevdigs; /// e.g. 3XX's 0th string is 3; just the prevdigs;\\n        k --;                /// take account of the \"3XX's 0th\" case. minus one here to make the code below cleaner.\\n        if (len == 1)        /// the ending condition of recursion. For 1 digit number, just get k;\\n            return prevdigs*10 + k;\\n        /// suppose n = 345 in all comments below;\\n        int whole = pow(10, len - 1); /// 100\\n        int sigdig = n / whole;       /// 3\\n        int remain = n % whole;       /// 45\\n        int allones_1 = (whole - 1) / 9;  /// 11\\n        int allones_0 = allones_1*10 + 1; /// 111\\n        int allones_2 = allones_1 / 10;   /// 1\\n        int low_bar =  allones_0 * sigdig; /// 111 * 3 = 333 The number of strs before 3 (containing 111 digits starting with 0)\\n        int high_bar = low_bar + allones_1 + remain + 1; /// 333 + 11 + 45 + 1 (11 is 3, 30, 31 ... 39)\\n        if (k < low_bar)   /// k is before 3\\n        {\\n            int curdig = k / allones_0; /// figure out the current digit is 0, 1 or 2;\\n            return solve(allones_1 * 9, k % allones_0, prevdigs*10 + curdig, len - 1); /// allones_1 * 9 makes 99, meaning search everything\\n        }                                                                              /// with length len-1\\n        if (k >= high_bar) /// k is after 39 (largest in 3XX)\\n        {\\n            k -= high_bar;\\n            int curdig = sigdig + k / allones_1 + 1; /// figure out the current digit among 4~9;\\n            return solve(allones_2 * 9, k % allones_1, prevdigs * 10 + curdig, len - 2); ///allones_2 * 9 makes 9, meaning search everything\\n        }                                                                                ///with length len-2\\n        k -= low_bar;\\n        int curdig = sigdig;\\n        return solve(remain, k, prevdigs * 10 + curdig, len - 1); /// search in 45 with length 2;\\n    }\\npublic:\\n    int findKthNumber(int n, int k)\\n    {\\n        int len = 0; /// length of n\\n        for(int m = n; m > 0; m/= 10, ++len);\\n        k += (pow(10, len) - 1)/9; /// solve function considers 0's before 1; we make up this difference first;\\n        return solve(n, k, 0, len); ///len is important, o/w when k = 5 in a middle round, you don't know it's X005 or X05,\\n    }                               ///they have different number of 0s before them\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/// O(log10(N)) Time & Space\\n/// The main idea to simplify the implementation is, when count, start with empty then 0's at a certain length;\\n/// E.g. when do n = 345, k = 250, instead of counting from 1, 10, 100, ...., count from EMPTY, 0, 00, 000, 001, 002..09, 091, 092, ..099, 1\\n/// Therefore, I count 112 (there is an EMPTY at first) more than you should. So I add this difference first;\\n/// The reason why I do it this way is it will greatly simplify the implementation later.\\n/// Suppose I'm in an intermediate round, I have prevdigs = 3. I want to calculate solve(45, 27) now,\\n/// because there is a leading digit, it makes 0, 00 or even EMPTY valid now -- they can make 30, 300, 3 respectively.\\n/// So in all intermediate rounds, it's beneficial to consider 0, 00, EMPTY before 1XX. The only exceptional round is the first one.\\n/// So I just need to do some manipulate with the first round, then we are all good.\\nclass Solution {\\n    int solve(int n, int k, int prevdigs, int len) /// prevdigs are all digits known so far.\\n    {\\n        if (k == 0)          /// in this function, k = 0 means the 1st number.\\n            return prevdigs; /// e.g. 3XX's 0th string is 3; just the prevdigs;\\n        k --;                /// take account of the \"3XX's 0th\" case. minus one here to make the code below cleaner.\\n        if (len == 1)        /// the ending condition of recursion. For 1 digit number, just get k;\\n            return prevdigs*10 + k;\\n        /// suppose n = 345 in all comments below;\\n        int whole = pow(10, len - 1); /// 100\\n        int sigdig = n / whole;       /// 3\\n        int remain = n % whole;       /// 45\\n        int allones_1 = (whole - 1) / 9;  /// 11\\n        int allones_0 = allones_1*10 + 1; /// 111\\n        int allones_2 = allones_1 / 10;   /// 1\\n        int low_bar =  allones_0 * sigdig; /// 111 * 3 = 333 The number of strs before 3 (containing 111 digits starting with 0)\\n        int high_bar = low_bar + allones_1 + remain + 1; /// 333 + 11 + 45 + 1 (11 is 3, 30, 31 ... 39)\\n        if (k < low_bar)   /// k is before 3\\n        {\\n            int curdig = k / allones_0; /// figure out the current digit is 0, 1 or 2;\\n            return solve(allones_1 * 9, k % allones_0, prevdigs*10 + curdig, len - 1); /// allones_1 * 9 makes 99, meaning search everything\\n        }                                                                              /// with length len-1\\n        if (k >= high_bar) /// k is after 39 (largest in 3XX)\\n        {\\n            k -= high_bar;\\n            int curdig = sigdig + k / allones_1 + 1; /// figure out the current digit among 4~9;\\n            return solve(allones_2 * 9, k % allones_1, prevdigs * 10 + curdig, len - 2); ///allones_2 * 9 makes 9, meaning search everything\\n        }                                                                                ///with length len-2\\n        k -= low_bar;\\n        int curdig = sigdig;\\n        return solve(remain, k, prevdigs * 10 + curdig, len - 1); /// search in 45 with length 2;\\n    }\\npublic:\\n    int findKthNumber(int n, int k)\\n    {\\n        int len = 0; /// length of n\\n        for(int m = n; m > 0; m/= 10, ++len);\\n        k += (pow(10, len) - 1)/9; /// solve function considers 0's before 1; we make up this difference first;\\n        return solve(n, k, 0, len); ///len is important, o/w when k = 5 in a middle round, you don't know it's X005 or X05,\\n    }                               ///they have different number of 0s before them\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92245,
                "title": "java-dfs-pruning-heuristic",
                "content": "```\\npublic class Solution {\\n    private int kthNum;\\n    private int visited = -1;\\n\\n    public int findKthNumber(int n, int k) {\\n        int digits = getDigits(n);\\n        dfs(0, digits, 0, 0, n, k);\\n        return kthNum;\\n    }\\n\\n    private void dfs(int curLevel, int maxLevel, int digit, int value, int n, int k) {\\n        if (curLevel > maxLevel || visited >= k) {\\n            return;\\n        }\\n        int newvalue = value * 10 + digit;\\n        if (0 < curLevel && curLevel < maxLevel) {\\n            int leftBottom = getBottomValue(newvalue, curLevel, maxLevel, 0);\\n            int rightBottom = getBottomValue(newvalue, curLevel, maxLevel, 9);\\n            int subtreeNodes = getNodes(curLevel, maxLevel - 1) +\\n                    (leftBottom > n ? 0 : Math.min(n, rightBottom) - leftBottom + 1);\\n            if (visited + subtreeNodes < k) {\\n                visited += subtreeNodes;\\n                return;\\n            }\\n        }\\n        if (++visited == k) {\\n            kthNum = newvalue;\\n            return;\\n        }\\n        for (int i = curLevel == 0 ? 1 : 0; i < 10; i++) {\\n            dfs(curLevel + 1, maxLevel, i, newvalue, n, k);\\n        }\\n    }\\n\\n    private int getBottomValue(int value, int curLevel, int maxLevel, int addup) {\\n        for (int i = 0; i < maxLevel - curLevel; i++) {\\n            value = value * 10 + addup;\\n        }\\n        return value;\\n    }\\n\\n    private int getNodes(int curLevel, int maxLevel) {\\n        int total = 0;\\n        int here = 1;\\n        for (int i = curLevel; i <= maxLevel; i++) {\\n            total += here;\\n            here *= 10;\\n        }\\n        return total;\\n    }\\n\\n    private int getDigits(int n) {\\n        int digits = 0;\\n        while (n > 0) {\\n            digits++;\\n            n /= 10;\\n        }\\n        return digits;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private int kthNum;\\n    private int visited = -1;\\n\\n    public int findKthNumber(int n, int k) {\\n        int digits = getDigits(n);\\n        dfs(0, digits, 0, 0, n, k);\\n        return kthNum;\\n    }\\n\\n    private void dfs(int curLevel, int maxLevel, int digit, int value, int n, int k) {\\n        if (curLevel > maxLevel || visited >= k) {\\n            return;\\n        }\\n        int newvalue = value * 10 + digit;\\n        if (0 < curLevel && curLevel < maxLevel) {\\n            int leftBottom = getBottomValue(newvalue, curLevel, maxLevel, 0);\\n            int rightBottom = getBottomValue(newvalue, curLevel, maxLevel, 9);\\n            int subtreeNodes = getNodes(curLevel, maxLevel - 1) +\\n                    (leftBottom > n ? 0 : Math.min(n, rightBottom) - leftBottom + 1);\\n            if (visited + subtreeNodes < k) {\\n                visited += subtreeNodes;\\n                return;\\n            }\\n        }\\n        if (++visited == k) {\\n            kthNum = newvalue;\\n            return;\\n        }\\n        for (int i = curLevel == 0 ? 1 : 0; i < 10; i++) {\\n            dfs(curLevel + 1, maxLevel, i, newvalue, n, k);\\n        }\\n    }\\n\\n    private int getBottomValue(int value, int curLevel, int maxLevel, int addup) {\\n        for (int i = 0; i < maxLevel - curLevel; i++) {\\n            value = value * 10 + addup;\\n        }\\n        return value;\\n    }\\n\\n    private int getNodes(int curLevel, int maxLevel) {\\n        int total = 0;\\n        int here = 1;\\n        for (int i = curLevel; i <= maxLevel; i++) {\\n            total += here;\\n            here *= 10;\\n        }\\n        return total;\\n    }\\n\\n    private int getDigits(int n) {\\n        int digits = 0;\\n        while (n > 0) {\\n            digits++;\\n            n /= 10;\\n        }\\n        return digits;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92246,
                "title": "java-solution-with-a-map-to-record-the-uncomplete-subtree-then-dfs",
                "content": "```\\n   /**\\n     * for each subtree if it is complete tree\\n     * then the num of child is 11111....\\n     * so first find the root of each layer which is uncomplete and record the numbers of child\\n     */\\n    public int findKthNumber(int n, int k) {\\n        int cur = 1;\\n        k = k - 1;\\n        int layer = (int)Math.log10(n);\\n        int seg = 0;\\n        for (int i = 0 ; i <= layer; i ++) {\\n            seg += Math.pow(10, i);\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(n, 1);\\n        int cu = n / 10;\\n        int va = n % 10;\\n        map.put(cu, va + map.get(n)+1);\\n        gettheUncompletelyWay(cu , map);\\n        //calculate the D_value of root cur and cur + 1;\\n        while (k > 0) {\\n            int Dvalue;\\n            if (map.containsKey(cur)) {\\n                Dvalue = map.get(cur);\\n                if (k >= Dvalue) {\\n                    cur += 1;\\n                    k -= Dvalue;\\n                }else {\\n                    cur *= 10;\\n                    k -= 1;\\n                }\\n                seg = (seg - 1)/10;\\n            }else {\\n                Dvalue = seg;\\n                if (k >= Dvalue) {\\n                    cur += 1;\\n                    k -= Dvalue;\\n                }else {\\n                    cur *= 10;\\n                    k -= 1;\\n                    seg = (seg - 1)/10;\\n                }\\n            }\\n        }\\n        return cur;\\n    }\\n\\n    //get the way that is consist of each root of uncomplete tree and the number of child\\n    //using map dp solution\\n    private void gettheUncompletelyWay(int n, Map<Integer, Integer> map) {\\n        int t = 11;\\n        int pre = 1;\\n        while (n >= 10) {\\n            int cu = n / 10;\\n            int va = n % 10;\\n            map.put(cu, va * t + map.get(n)+ (10 - va - 1) * pre + 1);\\n            pre = t;\\n            t = t * 10 + 1;\\n            n = cu;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   /**\\n     * for each subtree if it is complete tree\\n     * then the num of child is 11111....\\n     * so first find the root of each layer which is uncomplete and record the numbers of child\\n     */\\n    public int findKthNumber(int n, int k) {\\n        int cur = 1;\\n        k = k - 1;\\n        int layer = (int)Math.log10(n);\\n        int seg = 0;\\n        for (int i = 0 ; i <= layer; i ++) {\\n            seg += Math.pow(10, i);\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(n, 1);\\n        int cu = n / 10;\\n        int va = n % 10;\\n        map.put(cu, va + map.get(n)+1);\\n        gettheUncompletelyWay(cu , map);\\n        //calculate the D_value of root cur and cur + 1;\\n        while (k > 0) {\\n            int Dvalue;\\n            if (map.containsKey(cur)) {\\n                Dvalue = map.get(cur);\\n                if (k >= Dvalue) {\\n                    cur += 1;\\n                    k -= Dvalue;\\n                }else {\\n                    cur *= 10;\\n                    k -= 1;\\n                }\\n                seg = (seg - 1)/10;\\n            }else {\\n                Dvalue = seg;\\n                if (k >= Dvalue) {\\n                    cur += 1;\\n                    k -= Dvalue;\\n                }else {\\n                    cur *= 10;\\n                    k -= 1;\\n                    seg = (seg - 1)/10;\\n                }\\n            }\\n        }\\n        return cur;\\n    }\\n\\n    //get the way that is consist of each root of uncomplete tree and the number of child\\n    //using map dp solution\\n    private void gettheUncompletelyWay(int n, Map<Integer, Integer> map) {\\n        int t = 11;\\n        int pre = 1;\\n        while (n >= 10) {\\n            int cu = n / 10;\\n            int va = n % 10;\\n            map.put(cu, va * t + map.get(n)+ (10 - va - 1) * pre + 1);\\n            pre = t;\\n            t = t * 10 + 1;\\n            n = cu;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92247,
                "title": "c-use-string",
                "content": "the problem is at first level it just has 1-9 and from second level it can be 0-9, so play a trick use a variable b to play offset.\\n\\n\\n    int findKthNumber(int n,int k)\\n    {\\n        if(n<10)return k;\\n        return stol(find_next(n,k-1,9));\\n    }\\n    string find_next(int n, int k,int b) {\\n       \\n        //cout<<n<<\",\"<<k<<endl;\\n        int next=n;\\n        long base=1;\\n        while(n/b>=base)base=base*10+1;\\n        base/=10;\\n        n-=base*b;\\n        vector<int> level;level.push_back(0);\\n        for(int i=0;i<b;i++)level.push_back(base);\\n        \\n        long new_base=base*9+1;\\n        int i=1;\\n        while(n>new_base){level[i++]+=new_base;n-=new_base;}\\n        level[i]+=n;\\n        for(i=1;i<=b;i++)level[i]+=level[i-1];\\n        //for(auto x:level)cout<<x<<\" \";cout<<endl;\\n        int result=0;\\n        i=0;\\n        while(level[i]<k)i++;\\n        if(level[i]==k)return to_string(i+10-b);\\n        if(i>0)k-=level[i-1]+1;\\n        \\n        return to_string(i+9-b)+find_next(i>0?level[i]-level[i-1]-1:level[i],k,10);\\n        \\n    }",
                "solutionTags": [],
                "code": "the problem is at first level it just has 1-9 and from second level it can be 0-9, so play a trick use a variable b to play offset.\\n\\n\\n    int findKthNumber(int n,int k)\\n    {\\n        if(n<10)return k;\\n        return stol(find_next(n,k-1,9));\\n    }\\n    string find_next(int n, int k,int b) {\\n       \\n        //cout<<n<<\",\"<<k<<endl;\\n        int next=n;\\n        long base=1;\\n        while(n/b>=base)base=base*10+1;\\n        base/=10;\\n        n-=base*b;\\n        vector<int> level;level.push_back(0);\\n        for(int i=0;i<b;i++)level.push_back(base);\\n        \\n        long new_base=base*9+1;\\n        int i=1;\\n        while(n>new_base){level[i++]+=new_base;n-=new_base;}\\n        level[i]+=n;\\n        for(i=1;i<=b;i++)level[i]+=level[i-1];\\n        //for(auto x:level)cout<<x<<\" \";cout<<endl;\\n        int result=0;\\n        i=0;\\n        while(level[i]<k)i++;\\n        if(level[i]==k)return to_string(i+10-b);\\n        if(i>0)k-=level[i-1]+1;\\n        \\n        return to_string(i+9-b)+find_next(i>0?level[i]-level[i-1]-1:level[i],k,10);\\n        \\n    }",
                "codeTag": "C++"
            },
            {
                "id": 92249,
                "title": "arithmetic-solution-in-python",
                "content": "There are a couple of helper functions:\\n\\n*h(n, m)* computes the order number of n in the lexicographical set of numbers with up-to-m digits.\\n*kth(k, m)* computes the k-th number in the lexicographical set of numbers with up-to-m digits.\\n\\nThe logic is to compare k with *h(n, m)* where m is the number of digits of n. If k is below *h(n, m)* the answer is *kth(k, m)*. Otherwise the answer can be computed from the *m-1* digit numbers as *kth(k - t + h(n//10, m-1), m-1)*.\\n```\\nclass Solution(object):\\n    def findKthNumber(self, n, k):\\n        from math import log10\\n        # Sum, of digits of n\\n        def sumdig(n):\\n            return 0 if n==0 else n%10 + sumdig(n//10)\\n        # The order number of n in the lexicographical set of up-to-m-digit numbers\\n        def h(n, m): return (10*n - sumdig(n) - 10**m + 1)//9 + m\\n\\n        # k-th number in the lexicographical set of up-to-m-digit numbers\\n        def kth(k, m):\\n            # First digit is 1 through 9\\n            G = (10**m - 1) // 9\\n            x = 1 + (k - 1) // G\\n            k = (k - 1) % G\\n            while k != 0:\\n                # Subsequent digits are 0 through 9\\n                # k==0 means that there are no more digits\\n                G = (G - 1) // 10\\n                x = 10 * x + (k - 1) // G\\n                k = (k - 1) % G\\n            return x\\n\\n        # The number of digits of n.\\n        m = 1 + int(log10(n))\\n        \\n        # The order number of n among up-to-m-digit numbers.\\n        t = h(n, m)\\n        # if k is below t get the answer\\n        if k <= t: return kth(k, m)\\n        # if k is above t look for the answer in the set of m-1 digit numbers.\\n        return kth(k - t + h(n//10, m-1), m-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findKthNumber(self, n, k):\\n        from math import log10\\n        # Sum, of digits of n\\n        def sumdig(n):\\n            return 0 if n==0 else n%10 + sumdig(n//10)\\n        # The order number of n in the lexicographical set of up-to-m-digit numbers\\n        def h(n, m): return (10*n - sumdig(n) - 10**m + 1)//9 + m\\n\\n        # k-th number in the lexicographical set of up-to-m-digit numbers\\n        def kth(k, m):\\n            # First digit is 1 through 9\\n            G = (10**m - 1) // 9\\n            x = 1 + (k - 1) // G\\n            k = (k - 1) % G\\n            while k != 0:\\n                # Subsequent digits are 0 through 9\\n                # k==0 means that there are no more digits\\n                G = (G - 1) // 10\\n                x = 10 * x + (k - 1) // G\\n                k = (k - 1) % G\\n            return x\\n\\n        # The number of digits of n.\\n        m = 1 + int(log10(n))\\n        \\n        # The order number of n among up-to-m-digit numbers.\\n        t = h(n, m)\\n        # if k is below t get the answer\\n        if k <= t: return kth(k, m)\\n        # if k is above t look for the answer in the set of m-1 digit numbers.\\n        return kth(k - t + h(n//10, m-1), m-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92250,
                "title": "440-k-th-smallest-in-lexicographical-order-cpp-solution",
                "content": "```\\n// 440. K-th Smallest in Lexicographical Order\\n// https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/\\n#include <iostream>\\n#include <fstream>\\n#include <cassert>\\n#include <string>\\n#include <algorithm>\\n#include <vector>\\n#include <iterator>\\nusing namespace std;\\n// BEGIN: https://discuss.leetcode.com/topic/64624/concise-easy-to-understand-java-5ms-solution-with-explaination\\n// BEGIN: http://bookshadow.com/weblog/2016/10/24/leetcode-k-th-smallest-in-lexicographical-order/\\nclass Solution {\\npublic:\\n\\tint findKthNumber(int n, int k) {\\n\\t\\tint result = 1;\\n\\t\\tk--;\\n\\t\\twhile (k > 0) {\\n\\t\\t\\tconst int delta = helper(result, result + 1, n);\\n\\t\\t\\tif (k >= delta) {\\n\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\tk -= delta;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tresult *= 10;\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\nprivate:\\n\\tsize_t helper(size_t lb, size_t ub, const size_t n) {\\n\\t\\tsize_t result = 0;\\n\\t\\twhile (lb <= n) {\\n\\t\\t\\tresult += min(n + 1, ub) - lb;\\n\\t\\t\\tlb *= 10;\\n\\t\\t\\tub *= 10;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n};\\n// END: http://bookshadow.com/weblog/2016/10/24/leetcode-k-th-smallest-in-lexicographical-order/\\n// END: https://discuss.leetcode.com/topic/64624/concise-easy-to-understand-java-5ms-solution-with-explaination\\n\\n// BEGIN: Time Limit Exceeded\\n// class Solution {\\n// public:\\n// \\tint findKthNumber(int n, int k) {\\n// \\t\\tsize_t result = 0;\\n// \\t\\tsize_t i = 1;\\n// \\t\\tbool nonFound = true;\\n// \\t\\tfor (i = 1; nonFound && i < 10; i++) {\\n// \\t\\t\\tsize_t cnt = 0;\\n// \\t\\t\\tfor (size_t lb = i, ub = i + 1; nonFound && lb <= size_t(n); lb *= 10, ub *= 10) {\\n// \\t\\t\\t\\tcnt += min(size_t(n + 1), ub) - lb;\\n// \\t\\t\\t\\tnonFound = size_t(k) > cnt;\\n// \\t\\t\\t}\\n// \\t\\t\\tk = nonFound ? k - cnt : k;\\n// \\t\\t}\\n// \\t\\t// ofstream output;\\n// \\t\\t// output.open(\"../result.txt\");\\n// \\t\\tresult = i - 1;\\n// \\t\\t// output << result << '\\\\n';\\n// \\t\\tfor (size_t j = 1; j < size_t(k); j++) {\\n// \\t\\t\\tresult = next(result, n);\\n// \\t\\t\\t// output << result << '\\\\n';\\n// \\t\\t}\\n// \\t\\t// output.close();\\n// \\t\\treturn result;\\n// \\t}\\n// private:\\n// \\tsize_t next(size_t val, const size_t n) {\\n// \\t\\tif (!val) return 1;\\n// \\t\\tif (size_t(10 * val) <= size_t(n)) return 10 * val;\\n// \\t\\tsize_t valp1 = val + 1;\\n// \\t\\tif (valp1 <= size_t(n) && valp1 % 10 != 0) return valp1;\\n// \\t\\tif (valp1 % 10 == 0) {\\n// \\t\\t\\twhile (valp1 % 10 == 0) valp1 /= 10;\\n// \\t\\t\\treturn valp1;\\n// \\t\\t}\\n// \\t\\tval = val / 10 + 1;\\n// \\t\\twhile (val % 10 == 0) val /= 10;\\n// \\t\\treturn val;\\n// \\t}\\n// };\\n\\n// class Solution {\\n// public:\\n// \\tint findKthNumber(int n, int k) {\\n// \\t\\tint result = 0;\\n// \\t\\tfor (int i = 0; i < k; i++) {\\n// \\t\\t\\tresult = next(result, n);\\n// \\t\\t}\\n// \\t\\treturn result;\\n// \\t}\\n// private:\\n// \\tsize_t next(size_t val, const size_t n) {\\n// \\t\\tif (!val) return 1;\\n// \\t\\tif (size_t(10 * val) <= size_t(n)) return 10 * val;\\n// \\t\\tsize_t valp1 = val + 1;\\n// \\t\\tif (valp1 <= size_t(n) && valp1 % 10 != 0) return valp1;\\n// \\t\\tif (valp1 % 10 == 0) {\\n// \\t\\t\\twhile (valp1 % 10 == 0) valp1 /= 10;\\n// \\t\\t\\treturn valp1;\\n// \\t\\t}\\n// \\t\\tval = val / 10 + 1;\\n// \\t\\twhile (val % 10 == 0) val /= 10;\\n// \\t\\treturn val;\\n// \\t}\\n// };\\n\\n// class Solution {\\n// public:\\n// \\tint findKthNumber(int n, int k) {\\n// \\t\\tint result = 0;\\n// \\t\\tfor (int i = 0; i < k; i++) {\\n// \\t\\t\\tresult = next(result, n);\\n// \\t\\t}\\n// \\t\\treturn result;\\n// \\t}\\n// private:\\n// \\tsize_t next(size_t val, const size_t n) {\\n// \\t\\tif (!val) return 1;\\n// \\t\\tif (size_t(10 * val) <= size_t(n)) return 10 * val;\\n// \\t\\tsize_t valp1 = val + 1;\\n// \\t\\tif (valp1 <= size_t(n) && valp1 % 10 != 0) return valp1;\\n// \\t\\tif (valp1 % 10 == 0) {\\n// \\t\\t\\twhile (valp1 % 10 == 0) valp1 /= 10;\\n// \\t\\t\\treturn valp1;\\n// \\t\\t}\\n// \\t\\tval = val / 10 + 1;\\n// \\t\\twhile (val % 10 == 0) val /= 10;\\n// \\t\\treturn val;\\n// \\t}\\n// };\\n\\n// class Solution {\\n// public:\\n// \\tint findKthNumber(int n, int k) {\\n// \\t\\tvector<string> OPT;\\n// \\t\\tfor (int i = 1; i <= n; i++) {\\n// \\t\\t\\tconst string str = to_string(i);\\n// \\t\\t\\tOPT.push_back(str);\\n// \\t\\t}\\n// \\t\\tsort(begin(OPT), end(OPT));\\n// \\t\\treturn stoi(OPT[k - 1]);\\n// \\t}\\n// };\\n// END: Time Limit Exceeded\\nint main(void) {\\n\\tSolution solution;\\n\\tint result = 0;\\n\\tresult = solution.findKthNumber(100, 10);\\n\\tassert(17 == result);\\n\\tresult = solution.findKthNumber(10, 3);\\n\\tassert(2 == result);\\n\\tresult = solution.findKthNumber(13, 2);\\n\\tassert(10 == result);\\n\\tresult = solution.findKthNumber(4289384, 1922239);\\n\\tassert(2730010 == result);\\n\\tresult = solution.findKthNumber(7747794, 5857460);\\n\\tassert(6271710 == result);\\n\\tresult = solution.findKthNumber(681692778, 351251360);\\n\\tassert(416126219 == result);\\n\\tresult = solution.findKthNumber(719885387, 209989719);\\n\\tassert(288990744 == result);\\n\\tcout << \"\\\\nPassed All\\\\n\";\\n\\treturn 0;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// 440. K-th Smallest in Lexicographical Order\\n// https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/\\n#include <iostream>\\n#include <fstream>\\n#include <cassert>\\n#include <string>\\n#include <algorithm>\\n#include <vector>\\n#include <iterator>\\nusing namespace std;\\n// BEGIN: https://discuss.leetcode.com/topic/64624/concise-easy-to-understand-java-5ms-solution-with-explaination\\n// BEGIN: http://bookshadow.com/weblog/2016/10/24/leetcode-k-th-smallest-in-lexicographical-order/\\nclass Solution {\\npublic:\\n\\tint findKthNumber(int n, int k) {\\n\\t\\tint result = 1;\\n\\t\\tk--;\\n\\t\\twhile (k > 0) {\\n\\t\\t\\tconst int delta = helper(result, result + 1, n);\\n\\t\\t\\tif (k >= delta) {\\n\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\tk -= delta;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tresult *= 10;\\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\nprivate:\\n\\tsize_t helper(size_t lb, size_t ub, const size_t n) {\\n\\t\\tsize_t result = 0;\\n\\t\\twhile (lb <= n) {\\n\\t\\t\\tresult += min(n + 1, ub) - lb;\\n\\t\\t\\tlb *= 10;\\n\\t\\t\\tub *= 10;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n};\\n// END: http://bookshadow.com/weblog/2016/10/24/leetcode-k-th-smallest-in-lexicographical-order/\\n// END: https://discuss.leetcode.com/topic/64624/concise-easy-to-understand-java-5ms-solution-with-explaination\\n\\n// BEGIN: Time Limit Exceeded\\n// class Solution {\\n// public:\\n// \\tint findKthNumber(int n, int k) {\\n// \\t\\tsize_t result = 0;\\n// \\t\\tsize_t i = 1;\\n// \\t\\tbool nonFound = true;\\n// \\t\\tfor (i = 1; nonFound && i < 10; i++) {\\n// \\t\\t\\tsize_t cnt = 0;\\n// \\t\\t\\tfor (size_t lb = i, ub = i + 1; nonFound && lb <= size_t(n); lb *= 10, ub *= 10) {\\n// \\t\\t\\t\\tcnt += min(size_t(n + 1), ub) - lb;\\n// \\t\\t\\t\\tnonFound = size_t(k) > cnt;\\n// \\t\\t\\t}\\n// \\t\\t\\tk = nonFound ? k - cnt : k;\\n// \\t\\t}\\n// \\t\\t// ofstream output;\\n// \\t\\t// output.open(\"../result.txt\");\\n// \\t\\tresult = i - 1;\\n// \\t\\t// output << result << '\\\\n';\\n// \\t\\tfor (size_t j = 1; j < size_t(k); j++) {\\n// \\t\\t\\tresult = next(result, n);\\n// \\t\\t\\t// output << result << '\\\\n';\\n// \\t\\t}\\n// \\t\\t// output.close();\\n// \\t\\treturn result;\\n// \\t}\\n// private:\\n// \\tsize_t next(size_t val, const size_t n) {\\n// \\t\\tif (!val) return 1;\\n// \\t\\tif (size_t(10 * val) <= size_t(n)) return 10 * val;\\n// \\t\\tsize_t valp1 = val + 1;\\n// \\t\\tif (valp1 <= size_t(n) && valp1 % 10 != 0) return valp1;\\n// \\t\\tif (valp1 % 10 == 0) {\\n// \\t\\t\\twhile (valp1 % 10 == 0) valp1 /= 10;\\n// \\t\\t\\treturn valp1;\\n// \\t\\t}\\n// \\t\\tval = val / 10 + 1;\\n// \\t\\twhile (val % 10 == 0) val /= 10;\\n// \\t\\treturn val;\\n// \\t}\\n// };\\n\\n// class Solution {\\n// public:\\n// \\tint findKthNumber(int n, int k) {\\n// \\t\\tint result = 0;\\n// \\t\\tfor (int i = 0; i < k; i++) {\\n// \\t\\t\\tresult = next(result, n);\\n// \\t\\t}\\n// \\t\\treturn result;\\n// \\t}\\n// private:\\n// \\tsize_t next(size_t val, const size_t n) {\\n// \\t\\tif (!val) return 1;\\n// \\t\\tif (size_t(10 * val) <= size_t(n)) return 10 * val;\\n// \\t\\tsize_t valp1 = val + 1;\\n// \\t\\tif (valp1 <= size_t(n) && valp1 % 10 != 0) return valp1;\\n// \\t\\tif (valp1 % 10 == 0) {\\n// \\t\\t\\twhile (valp1 % 10 == 0) valp1 /= 10;\\n// \\t\\t\\treturn valp1;\\n// \\t\\t}\\n// \\t\\tval = val / 10 + 1;\\n// \\t\\twhile (val % 10 == 0) val /= 10;\\n// \\t\\treturn val;\\n// \\t}\\n// };\\n\\n// class Solution {\\n// public:\\n// \\tint findKthNumber(int n, int k) {\\n// \\t\\tint result = 0;\\n// \\t\\tfor (int i = 0; i < k; i++) {\\n// \\t\\t\\tresult = next(result, n);\\n// \\t\\t}\\n// \\t\\treturn result;\\n// \\t}\\n// private:\\n// \\tsize_t next(size_t val, const size_t n) {\\n// \\t\\tif (!val) return 1;\\n// \\t\\tif (size_t(10 * val) <= size_t(n)) return 10 * val;\\n// \\t\\tsize_t valp1 = val + 1;\\n// \\t\\tif (valp1 <= size_t(n) && valp1 % 10 != 0) return valp1;\\n// \\t\\tif (valp1 % 10 == 0) {\\n// \\t\\t\\twhile (valp1 % 10 == 0) valp1 /= 10;\\n// \\t\\t\\treturn valp1;\\n// \\t\\t}\\n// \\t\\tval = val / 10 + 1;\\n// \\t\\twhile (val % 10 == 0) val /= 10;\\n// \\t\\treturn val;\\n// \\t}\\n// };\\n\\n// class Solution {\\n// public:\\n// \\tint findKthNumber(int n, int k) {\\n// \\t\\tvector<string> OPT;\\n// \\t\\tfor (int i = 1; i <= n; i++) {\\n// \\t\\t\\tconst string str = to_string(i);\\n// \\t\\t\\tOPT.push_back(str);\\n// \\t\\t}\\n// \\t\\tsort(begin(OPT), end(OPT));\\n// \\t\\treturn stoi(OPT[k - 1]);\\n// \\t}\\n// };\\n// END: Time Limit Exceeded\\nint main(void) {\\n\\tSolution solution;\\n\\tint result = 0;\\n\\tresult = solution.findKthNumber(100, 10);\\n\\tassert(17 == result);\\n\\tresult = solution.findKthNumber(10, 3);\\n\\tassert(2 == result);\\n\\tresult = solution.findKthNumber(13, 2);\\n\\tassert(10 == result);\\n\\tresult = solution.findKthNumber(4289384, 1922239);\\n\\tassert(2730010 == result);\\n\\tresult = solution.findKthNumber(7747794, 5857460);\\n\\tassert(6271710 == result);\\n\\tresult = solution.findKthNumber(681692778, 351251360);\\n\\tassert(416126219 == result);\\n\\tresult = solution.findKthNumber(719885387, 209989719);\\n\\tassert(288990744 == result);\\n\\tcout << \"\\\\nPassed All\\\\n\";\\n\\treturn 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 92251,
                "title": "awesome-java-solution",
                "content": "First, we need a help function to do something:\\n```\\n    private int findKthNumber(long p, long q, long n) {\\n        int result = 0;\\n        while (p <= n) {\\n            result += Math.min(q, n + 1) - p;\\n            p *= 10;\\n            q *= 10;\\n        }\\n        return result;\\n    }\\n```\\nThe use of the upper function is to get the number of numbers in range `[p,min(q,n+1))` in lexicographical order. Because the number must be `<=n`, so it must `<n+1`.\\nNow, given a lower bound `p(inclusive)`, a upper bound `q(exclusive)`, and with a constraint `n(inclusive)`, we can easily find the number of numbers which are in range `[p,min(q,n+1))` in `lexicographical order` by using the upper function.\\nMoreover, we use long to avoid overflow, as `10*q, 10*q, n+1` may be greater than `Integer.MAX_VALUE`, of course, n is not necessary, but if n is `Integer.MAX_VALUE`(not in this problem), may cause overflow.\\nNext, comes the main function:\\n```\\n    public int findKthNumber(int n, int k) {\\n        int result = 1;\\n        while (k > 1) {\\n            int count = findKthNumber(result, result + 1, n);\\n            if (count < k) {\\n                result++;\\n                k -= count;\\n            } else {\\n                result *= 10;\\n                k--;\\n            }\\n        }\\n        return result;\\n    }\\n```\\nif k>count, we scan from left to right by increase result\\nif k<=count, we scan from up to bottom by multiply result by 10\\nvery easy to understand, hope helps",
                "solutionTags": [],
                "code": "```\\n    private int findKthNumber(long p, long q, long n) {\\n        int result = 0;\\n        while (p <= n) {\\n            result += Math.min(q, n + 1) - p;\\n            p *= 10;\\n            q *= 10;\\n        }\\n        return result;\\n    }\\n```\n```\\n    public int findKthNumber(int n, int k) {\\n        int result = 1;\\n        while (k > 1) {\\n            int count = findKthNumber(result, result + 1, n);\\n            if (count < k) {\\n                result++;\\n                k -= count;\\n            } else {\\n                result *= 10;\\n                k--;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92252,
                "title": "python-o-log-n-algorithm",
                "content": "The idea is based on the denary tree. \\nHowever, we don't have to traverse the tree. We only need to find the exact location of the k-th node in this tree.\\nBut we have to consider two cases: suppose that the order of `n` is `pos`. Then `k <= pos` and `k > pos` should be treated differently. But if `k > pos`, it doesn't matter how we traverse the tree before `pos` steps, so with a simple modification, we can use the same way to find the result.\\n\\n```\\nclass Solution(object):\\n    def findKthNumber(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if n < 10: return k\\n        num, pos, ones, h = n, 0, 0, 0 # ones stored the number like \"1,11,111,...\", h is the height of the tree\\n        while num > 0:\\n            ones = ones*10 + 1\\n            h += 1\\n            pos += (num%10 if num >= 10 else num-1) * ones + 1\\n            num /= 10\\n        if k > pos:\\n            k -= n - 10**(h-1) + 1\\n            ones /= 10\\n        ans = 0\\n        while k > 0:\\n            ans = ans*10 + (k-1)/ones + (1 if ans == 0 else 0)\\n            k = (k-1)%ones\\n            ones /= 10\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findKthNumber(self, n, k):\\n        \"\"\"\\n        :type n: int\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if n < 10: return k\\n        num, pos, ones, h = n, 0, 0, 0 # ones stored the number like \"1,11,111,...\", h is the height of the tree\\n        while num > 0:\\n            ones = ones*10 + 1\\n            h += 1\\n            pos += (num%10 if num >= 10 else num-1) * ones + 1\\n            num /= 10\\n        if k > pos:\\n            k -= n - 10**(h-1) + 1\\n            ones /= 10\\n        ans = 0\\n        while k > 0:\\n            ans = ans*10 + (k-1)/ones + (1 if ans == 0 else 0)\\n            k = (k-1)%ones\\n            ones /= 10\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92253,
                "title": "why-tle-on-submission-but-correct-result-run-code",
                "content": "````\\npublic class Solution {\\n    public int findKthNumber(int n, int k) {\\n        long cur = 1;\\n        if (k == 1) {\\n            return 1;\\n        }\\n        k--;\\n        for (int i = 1; i <= n; i++) {\\n            if (cur * 10 <= n) {\\n                cur = cur * 10;\\n            } else if (cur % 10 != 9 && cur + 1 <= n) {\\n                cur++;\\n            } else {\\n                while ((cur / 10) % 10 == 9) {\\n                    cur = cur / 10;\\n                }\\n                cur = cur / 10 + 1;\\n            }\\n            if (--k == 0) {\\n                return (int)cur;\\n            }\\n        }\\n        return (int)cur;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\npublic class Solution {\\n    public int findKthNumber(int n, int k) {\\n        long cur = 1;\\n        if (k == 1) {\\n            return 1;\\n        }\\n        k--;\\n        for (int i = 1; i <= n; i++) {\\n            if (cur * 10 <= n) {\\n                cur = cur * 10;\\n            } else if (cur % 10 != 9 && cur + 1 <= n) {\\n                cur++;\\n            } else {\\n                while ((cur / 10) % 10 == 9) {\\n                    cur = cur / 10;\\n                }\\n                cur = cur / 10 + 1;\\n            }\\n            if (--k == 0) {\\n                return (int)cur;\\n            }\\n        }\\n        return (int)cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92257,
                "title": "concise-nonrecursive-c-0ms-solution",
                "content": "```\\n// The basic idea is to put numbers in 3 categories: before, after, or equal.\\n// The category checking  can be optimized as only \"equal\" can change to \"before\" or \"after\".  \\n// Once is in \"before\" or \"after\", it will stay in that category.\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        \\n        string res;\\n    \\tstring nstr = to_string(n);\\n    \\t\\n    \\tint dCounter = 0;\\n    \\tfor (int i = 0; i<nstr.length(); i++)\\n    \\t\\tdCounter += pow(10,i);\\n    \\n    \\tint pos = 0;\\n    \\tint hist[57+1] = {};\\n    \\n    \\twhile (k>0)\\n    \\t{\\n    \\t\\tk--; //tricky, skip the current number \\n    \\n    \\t\\tif ( res==nstr.substr(0,pos) )\\n    \\t\\t{\\n    \\t\\t\\tint sum = 0;\\n    \\t\\t\\thist[nstr[pos]] = 0;\\n    \\t\\t\\tfor (char d = res.empty()?'1':'0'; d <= '9'; d++)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tif (d< nstr[pos]) hist[d] = dCounter;\\n    \\t\\t\\t\\telse if ( d>nstr[pos] )  hist[d] = dCounter / 10;\\n    \\t\\t\\t\\tsum += hist[d];\\n    \\t\\t\\t}\\n    \\t\\t\\tn -= sum;\\n    \\t\\t\\thist[nstr[pos]] =n;\\n    \\t\\t\\tn--; //exclude the current number\\n    \\t\\t}\\n    \\t\\telse if ( res<nstr.substr(0, pos) )\\n    \\t\\t{\\n    \\t\\t\\tfor (char d = '0'; d <= '9'; d++)\\n    \\t\\t\\t\\thist[d] = dCounter;\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\tfor (char d = '0'; d <= '9'; d++)\\n    \\t\\t\\t\\thist[d] = dCounter/10;\\n    \\t\\t}\\n    \\n    \\t\\tchar d = '0';\\n    \\t\\twhile (k>=hist[d]) k -= hist[d++];\\n    \\n    \\t\\tres.append(1, d);\\n    \\n    \\t\\tpos++;\\n    \\t\\tdCounter /= 10;\\n    \\n    \\t}\\n    \\n    \\treturn atoi(res.c_str());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// The basic idea is to put numbers in 3 categories: before, after, or equal.\\n// The category checking  can be optimized as only \"equal\" can change to \"before\" or \"after\".  \\n// Once is in \"before\" or \"after\", it will stay in that category.\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        \\n        string res;\\n    \\tstring nstr = to_string(n);\\n    \\t\\n    \\tint dCounter = 0;\\n    \\tfor (int i = 0; i<nstr.length(); i++)\\n    \\t\\tdCounter += pow(10,i);\\n    \\n    \\tint pos = 0;\\n    \\tint hist[57+1] = {};\\n    \\n    \\twhile (k>0)\\n    \\t{\\n    \\t\\tk--; //tricky, skip the current number \\n    \\n    \\t\\tif ( res==nstr.substr(0,pos) )\\n    \\t\\t{\\n    \\t\\t\\tint sum = 0;\\n    \\t\\t\\thist[nstr[pos]] = 0;\\n    \\t\\t\\tfor (char d = res.empty()?'1':'0'; d <= '9'; d++)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tif (d< nstr[pos]) hist[d] = dCounter;\\n    \\t\\t\\t\\telse if ( d>nstr[pos] )  hist[d] = dCounter / 10;\\n    \\t\\t\\t\\tsum += hist[d];\\n    \\t\\t\\t}\\n    \\t\\t\\tn -= sum;\\n    \\t\\t\\thist[nstr[pos]] =n;\\n    \\t\\t\\tn--; //exclude the current number\\n    \\t\\t}\\n    \\t\\telse if ( res<nstr.substr(0, pos) )\\n    \\t\\t{\\n    \\t\\t\\tfor (char d = '0'; d <= '9'; d++)\\n    \\t\\t\\t\\thist[d] = dCounter;\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\tfor (char d = '0'; d <= '9'; d++)\\n    \\t\\t\\t\\thist[d] = dCounter/10;\\n    \\t\\t}\\n    \\n    \\t\\tchar d = '0';\\n    \\t\\twhile (k>=hist[d]) k -= hist[d++];\\n    \\n    \\t\\tres.append(1, d);\\n    \\n    \\t\\tpos++;\\n    \\t\\tdCounter /= 10;\\n    \\n    \\t}\\n    \\n    \\treturn atoi(res.c_str());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92258,
                "title": "c-solution-deduce-digit-one-by-one-log-n-0-3ms",
                "content": "The idea is to append digit to the number in form of string.\\n\\n\\nThere 3 main cases during the deduction; let's take input '334' as an example:\\n1. if we choose the first digit as 1 (i.e. \"under\" the prefix value), then it could be \"1\", \"1X\",\"1XX\"; that is, there are in total '111' combinations started with 1. \\n2.  if we place 3 first (i.e. \"exact match the prefix value), then it could be \"3\",\"3X\",\"300~334\"; that is, we can calculate the regular part \"3\",\"3X\"(11 numbers in total), and the variable part (\"300~334\", 35 in total), where the variable part can be calculated with modulo operator on the original input.\\n3. Besides the 2 cases above, the last case is \"over\" the prefix value (for example, \"4\" and \"4X\"). You can compare this part to case 1 or 2, and you will see the difference.\\n\\nin all cases the total number of the entries started with a certain digit is SUM(10^0,10^1,.....10^x), where x depends on which digit you are trying to figure out. (the number is consecutive '1' if you write it down.) In my implementation, I use a table to represent it.(function 'pow10Sum')\\n\\n\\nThe code:\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int findKthNumber(int n, int k) {\\n        string strN = to_string(n);\\n        bool isPrefix = true; // initially empty string is a prefix in any case\\n        int i,j;\\n        for(i=0, j = strN.size()-1, out=0;i<strN.size() && k;++i,--j) {\\n            --k; //current prefix occupied a position, too\\n            if(isPrefix) {\\n                char startDigit = '0' + max(0,1-i);\\n                int under, exact, over;\\n                under = (strN[i] - startDigit) * pow10Sum(j);\\n                if(under > k) {\\n                    strN[i] = startDigit + k/pow10Sum(j);\\n                    k   %= pow10Sum(j);\\n                    isPrefix = false;\\n                } else {\\n                    k -= under;\\n                    exact = pow10Sum(j-1) + n % pow10(j) +1;\\n                    if(exact > k) {\\n                        strN[i] = strN[i];\\n                    } else {\\n                        --j;\\n                        k -= exact;\\n                        strN[i] = strN[i]+1 + k/pow10Sum(j);\\n                        k   %= pow10Sum(j);\\n                        isPrefix = false;\\n                    }\\n                }\\n            } else {\\n                strN[i] = '0' + k/pow10Sum(j);\\n                k   %= pow10Sum(j); \\n            }\\n        }\\n        strN.resize(i);\\n        return atoi(strN.data());\\n    }\\n    // return 10 ^ exp\\n    int pow10(int exp) {\\n        const static int arr[] {\\n            1,\\n            10,\\n            100,\\n            1000,\\n            10000,\\n            100000,\\n            1000000,\\n            10000000,\\n            100000000,\\n            1000000000,\\n        };\\n        return arr[exp];\\n    }\\n    // return pow10(0) + pow10(1) + ....pow10(exp)\\n    int pow10Sum(int exp) {\\n        const static int arr[] {\\n            1,\\n            11,\\n            111,\\n            1111,\\n            11111,\\n            111111,\\n            1111111,\\n            11111111,\\n            111111111,\\n            1111111111,\\n        };\\n        return arr[exp];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findKthNumber(int n, int k) {\\n        string strN = to_string(n);\\n        bool isPrefix = true; // initially empty string is a prefix in any case\\n        int i,j;\\n        for(i=0, j = strN.size()-1, out=0;i<strN.size() && k;++i,--j) {\\n            --k; //current prefix occupied a position, too\\n            if(isPrefix) {\\n                char startDigit = '0' + max(0,1-i);\\n                int under, exact, over;\\n                under = (strN[i] - startDigit) * pow10Sum(j);\\n                if(under > k) {\\n                    strN[i] = startDigit + k/pow10Sum(j);\\n                    k   %= pow10Sum(j);\\n                    isPrefix = false;\\n                } else {\\n                    k -= under;\\n                    exact = pow10Sum(j-1) + n % pow10(j) +1;\\n                    if(exact > k) {\\n                        strN[i] = strN[i];\\n                    } else {\\n                        --j;\\n                        k -= exact;\\n                        strN[i] = strN[i]+1 + k/pow10Sum(j);\\n                        k   %= pow10Sum(j);\\n                        isPrefix = false;\\n                    }\\n                }\\n            } else {\\n                strN[i] = '0' + k/pow10Sum(j);\\n                k   %= pow10Sum(j); \\n            }\\n        }\\n        strN.resize(i);\\n        return atoi(strN.data());\\n    }\\n    // return 10 ^ exp\\n    int pow10(int exp) {\\n        const static int arr[] {\\n            1,\\n            10,\\n            100,\\n            1000,\\n            10000,\\n            100000,\\n            1000000,\\n            10000000,\\n            100000000,\\n            1000000000,\\n        };\\n        return arr[exp];\\n    }\\n    // return pow10(0) + pow10(1) + ....pow10(exp)\\n    int pow10Sum(int exp) {\\n        const static int arr[] {\\n            1,\\n            11,\\n            111,\\n            1111,\\n            11111,\\n            111111,\\n            1111111,\\n            11111111,\\n            111111111,\\n            1111111111,\\n        };\\n        return arr[exp];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92260,
                "title": "java-6ms-solution-easy-understanding",
                "content": "1. get the smallest m with the same number of digits as n, ps: n=356, m=100; n=35000, m=10000\\n2. from m to n, count x (in [m,n]) and when x has a '0' ending, insert y=x/10 before x\\n3. if y still ends with 0, continue inserting action\\n4. repeat [n/10+1,m-1] with step 2 and 3\\n\\n```\\npublic class Solution {\\n    public int findKthNumber(int n, int k) {\\n        int m = 1, tmp=n/10;\\n        while (tmp>0) {\\n            tmp /= 10;\\n            m *= 10;\\n        }\\n\\n        int firstPartNumber = count(m,n,m);\\n\\n        if (k<=firstPartNumber) return findKthNumber(m,n,m,k);\\n        if (k<=n) return findKthNumber(n/10+1,m-1,m/10,k-firstPartNumber);\\n        \\n        return 0;\\n    }\\n    \\n    public int count(int start, int end, int flag) {\\n        // assume start and end has same amount of digits, flag represents the smallest number with the same length of digits, such as 10,100,1000,...\\n        int result = 0;\\n        while (flag>0) {\\n            result += (end/flag-start/flag+((start%flag==0)?1:0));\\n            flag /= 10;\\n        }\\n        return result;\\n    }\\n    \\n    public int findKthNumber(int start, int end, int flag, int k) {\\n        int left = start, right = end;\\n        // b-search\\n        while (left<=right) {\\n            int mid = (left+right)/2;\\n            int x = count(start,mid,flag);\\n            if (x==k) return mid;\\n            if (x<k)\\n                left=mid+1;\\n            else\\n                right=mid-1;\\n        }\\n        int t = right+1;\\n        int zeroToBedeleted = count(start,t,flag)-k;\\n        for (int i=0; i<zeroToBedeleted; i++)\\n            t /= 10;\\n        \\n        return t;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int findKthNumber(int n, int k) {\\n        int m = 1, tmp=n/10;\\n        while (tmp>0) {\\n            tmp /= 10;\\n            m *= 10;\\n        }\\n\\n        int firstPartNumber = count(m,n,m);\\n\\n        if (k<=firstPartNumber) return findKthNumber(m,n,m,k);\\n        if (k<=n) return findKthNumber(n/10+1,m-1,m/10,k-firstPartNumber);\\n        \\n        return 0;\\n    }\\n    \\n    public int count(int start, int end, int flag) {\\n        // assume start and end has same amount of digits, flag represents the smallest number with the same length of digits, such as 10,100,1000,...\\n        int result = 0;\\n        while (flag>0) {\\n            result += (end/flag-start/flag+((start%flag==0)?1:0));\\n            flag /= 10;\\n        }\\n        return result;\\n    }\\n    \\n    public int findKthNumber(int start, int end, int flag, int k) {\\n        int left = start, right = end;\\n        // b-search\\n        while (left<=right) {\\n            int mid = (left+right)/2;\\n            int x = count(start,mid,flag);\\n            if (x==k) return mid;\\n            if (x<k)\\n                left=mid+1;\\n            else\\n                right=mid-1;\\n        }\\n        int t = right+1;\\n        int zeroToBedeleted = count(start,t,flag)-k;\\n        for (int i=0; i<zeroToBedeleted; i++)\\n            t /= 10;\\n        \\n        return t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92262,
                "title": "java-6ms-solution-determine-digit-by-digit-of-the-kth-number",
                "content": "Basically determine digit by digit for the kth number from most significant digit to least significant digit by computing 2 bounds which divide \"1 to n\" into 3 regions:\\n\\n```\\npublic class Solution {\\n    private int k;\\n    private int n;\\n    private final static int[] lengths2counts = new int[]{0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111};\\n\\n    private void findKth(int ind, int k, int[] pre){\\n        if(pre[0] == 0){\\n            pre[0]= (k - 1)/ lengths2counts[ind] + 1;\\n            findKth(ind - 1, k - (pre[0] - 1) * lengths2counts[ind], pre);\\n        }else if(k > 1){\\n            int curdigit = (k - 2)/ lengths2counts[ind];\\n            pre[0] = 10 * pre[0] + curdigit;\\n            findKth(ind - 1, k - 1 - curdigit * lengths2counts[ind], pre);\\n        }\\n    }\\n\\n    public int findKthNumber(int n, int k) {\\n\\n        int curdigit = n;\\n        List<Integer> list = new ArrayList<>();\\n        while(curdigit != 0){\\n            list.add(curdigit % 10);\\n            curdigit /= 10;\\n        }\\n\\n        int[] res = new int[]{0};\\n        for(int ind = list.size() - 1; ind >= 0; ind --) {\\n            curdigit = list.get(ind);\\n            int lb = (ind == list.size() - 1) ? (lengths2counts[ind + 1] * (curdigit - 1)) : (lengths2counts[ind + 1] * curdigit  + 1) ;//lower bound\\n            int ub = n - (9 - curdigit) * lengths2counts[ind]; //upper bound\\n            if (k > ub) {\\n                int temp = (k - ub - 1)/ lengths2counts[ind];\\n                res[0] = 10 * res[0] + curdigit + temp + 1;\\n                findKth(ind - 1, k - ub - temp * lengths2counts[ind], res);\\n                break;\\n            } else if (k <= lb) {\\n                findKth(ind + 1, k, res);\\n                break;\\n            }\\n            res[0] = 10 * res[0] + curdigit;\\n            n = ub - lb;\\n            k -= lb;\\n        }\\n        return res[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private int k;\\n    private int n;\\n    private final static int[] lengths2counts = new int[]{0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111};\\n\\n    private void findKth(int ind, int k, int[] pre){\\n        if(pre[0] == 0){\\n            pre[0]= (k - 1)/ lengths2counts[ind] + 1;\\n            findKth(ind - 1, k - (pre[0] - 1) * lengths2counts[ind], pre);\\n        }else if(k > 1){\\n            int curdigit = (k - 2)/ lengths2counts[ind];\\n            pre[0] = 10 * pre[0] + curdigit;\\n            findKth(ind - 1, k - 1 - curdigit * lengths2counts[ind], pre);\\n        }\\n    }\\n\\n    public int findKthNumber(int n, int k) {\\n\\n        int curdigit = n;\\n        List<Integer> list = new ArrayList<>();\\n        while(curdigit != 0){\\n            list.add(curdigit % 10);\\n            curdigit /= 10;\\n        }\\n\\n        int[] res = new int[]{0};\\n        for(int ind = list.size() - 1; ind >= 0; ind --) {\\n            curdigit = list.get(ind);\\n            int lb = (ind == list.size() - 1) ? (lengths2counts[ind + 1] * (curdigit - 1)) : (lengths2counts[ind + 1] * curdigit  + 1) ;//lower bound\\n            int ub = n - (9 - curdigit) * lengths2counts[ind]; //upper bound\\n            if (k > ub) {\\n                int temp = (k - ub - 1)/ lengths2counts[ind];\\n                res[0] = 10 * res[0] + curdigit + temp + 1;\\n                findKth(ind - 1, k - ub - temp * lengths2counts[ind], res);\\n                break;\\n            } else if (k <= lb) {\\n                findKth(ind + 1, k, res);\\n                break;\\n            }\\n            res[0] = 10 * res[0] + curdigit;\\n            n = ub - lb;\\n            k -= lb;\\n        }\\n        return res[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 92259,
                "title": "c-3ms-solution-using-stack",
                "content": "Test the prefix of the answer each time. If the total number of current prefix is less than `k`, test the next prefix with `current prefix +1`, otherwise test longer prefix with `current prefix * 10`\\n\\n```\\nclass Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        stack<int> stk;\\n        stk.push(1);\\n        \\n        while(k){\\n            if(k == 1) return stk.top();\\n            long long top = stk.top(), x = top;\\n            stk.pop();\\n            long long sum = 0, mask = 1;\\n            \\n            while(top <= n){\\n                if(top + mask - 1 <= n) sum += mask;\\n                else sum += n - top + 1;\\n                top *= 10;\\n                mask *= 10;\\n            }\\n            \\n            if(k > sum){\\n                k -= sum;\\n                stk.push(x+1);\\n            }else{\\n                k --;\\n                stk.push(x*10);\\n            }\\n        }\\n        return stk.top();\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findKthNumber(int n, int k) {\\n        stack<int> stk;\\n        stk.push(1);\\n        \\n        while(k){\\n            if(k == 1) return stk.top();\\n            long long top = stk.top(), x = top;\\n            stk.pop();\\n            long long sum = 0, mask = 1;\\n            \\n            while(top <= n){\\n                if(top + mask - 1 <= n) sum += mask;\\n                else sum += n - top + 1;\\n                top *= 10;\\n                mask *= 10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 92264,
                "title": "c-commented-46ms",
                "content": "       public class Solution\\n        {\\n            public int FindKthNumber(int n, int k)\\n            {\\n                if (n < 10) return k;\\n                \\n                int ret = 0;\\n                 //10 buckets, 9 buckets are used on the first pass as there is no \"0\" bucket initially.\\n                int[] buckets = new int[10]; /\\n                bool isFirst = true;\\n\\n                while (k > 0)\\n                {\\n                    //obtain the count of digits in each bucket.\\n                    GenerateBuckets(n, buckets, isFirst);\\n\\n                    //determine which bucket k lies in, this index is the next digit of the return value.\\n                    int bucketIndex = FindIndex(k, buckets);\\n                    ret = ret * 10 + bucketIndex + (isFirst ? 1 : 0); //add the next digit\\n                    \\n                    //k and n need to be modified for the next round.\\n                    k -= (ElementsBefore(bucketIndex, buckets) + 1);\\n                    n = buckets[bucketIndex] - 1;\\n                    isFirst = false;\\n                }\\n                return ret;\\n            }\\n\\n            private static void GenerateBuckets(int n, int[] buckets, bool isFirst)\\n            {\\n                int iterations = isFirst ? 9 : 10;\\n\\n                int maxValue = ObtainMaxBucketSize(n); //the max value in a bucket is a repetition of 1's (for example, 111)\\n                int minValue = maxValue - (int)Math.Pow(10, (int)Math.Log10(n)); //the min value of a bucket is the maxValue with 1 less 1 (example: 11).\\n                //Note: the minValue may be 0.\\n\\n                for (int i = 0; i < iterations; i++)\\n                    buckets[i] = minValue;\\n                \\n                int remaining = n - minValue * iterations; //we have handled minValue * iterations elements, determine how many are left.\\n                int maxAddition = maxValue - minValue; //A power of 10, the most we can add to a single bucket.\\n\\n                for (int i = 0; i < iterations; i++)\\n                {\\n                    buckets[i] += Math.Max(0, Math.Min(remaining, maxAddition));\\n                    remaining -= maxAddition;\\n                    if (remaining <= 0) break;\\n                }\\n            }\\n\\n            /// <summary>The number of elements before the given bucket index.</summary>\\n            private int ElementsBefore(int index, int[] buckets) \\n                => (from i in Enumerable.Range(0, index) select buckets[i]).Sum();\\n            \\n\\n            /// <summary>Determines the index of the bucket in which k lies.</summary>\\n            private int FindIndex(int k, int[] buckets)\\n            {\\n                int high = 0;\\n                for(int i = 0; i < buckets.Length; i++)\\n                {\\n                    high += buckets[i];\\n                    if (k <= high) return i;\\n                }\\n                throw new InvalidOperationException();\\n            }\\n\\n            private static int ObtainMaxBucketSize(int n)\\n                => obtainOnes(numberOfOnes: (int)Math.Log10(n) + 1);\\n\\n            /// <summary>Recurrence returning an integer containing \"n+1\" ones: 1, 11, 111</summary>\\n            private static int obtainOnes(int numberOfOnes)\\n            {\\n                if (numberOfOnes == 1) return 1;\\n\\n                int pow10 = (int)Math.Pow(10, numberOfOnes - 1);\\n\\n                return pow10 + obtainOnes(numberOfOnes-1);\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution\\n        {\\n            public int FindKthNumber(int n, int k)\\n            {\\n                if (n < 10) return k;\\n                \\n                int ret = 0;\\n                 //10 buckets, 9 buckets are used on the first pass as there is no \"0\" bucket initially.\\n                int[] buckets = new int[10]; /\\n                bool isFirst = true;\\n\\n                while (k > 0)\\n                {\\n                    //obtain the count of digits in each bucket.\\n                    GenerateBuckets(n, buckets, isFirst);\\n\\n                    //determine which bucket k lies in, this index is the next digit of the return value.\\n                    int bucketIndex = FindIndex(k, buckets);\\n                    ret = ret * 10 + bucketIndex + (isFirst ? 1 : 0); //add the next digit\\n                    \\n                    //k and n need to be modified for the next round.\\n                    k -= (ElementsBefore(bucketIndex, buckets) + 1);\\n                    n = buckets[bucketIndex] - 1;\\n                    isFirst = false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 92256,
                "title": "java-dfs-solution",
                "content": "```\\npublic int findKthNumber(int n, int k) {\\n\\tDeque<Integer> stack = new ArrayDeque<>();\\n\\tint count=0;\\n\\tfor(int i=1;i<10;i++) {\\n\\t\\tstack.push(i);\\n\\t\\twhile(!stack.isEmpty()) {\\n\\t\\t\\tint current = stack.pop();\\n\\t\\t\\tif(k==++count) return current;\\n\\t\\t\\tint countInSubtree = count(n,current);\\n\\t\\t\\tif(countInSubtree+count<k) {\\n\\t\\t\\t\\tcount=countInSubtree+count-1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor(int j=9;j>=0;j--) {\\n\\t\\t\\t\\t\\tint nextVal = Integer.parseInt(\"\"+current+j);\\n\\t\\t\\t\\t\\tif(nextVal<=n) {\\n\\t\\t\\t\\t\\t\\tstack.push(nextVal);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n\\npublic int count(int n, long val) {\\n\\tint ans = 0;\\n\\tint number = 1;\\n\\twhile(val<=n) {\\n\\t\\tans += number;\\n\\t\\tval *= 10;\\n\\t\\tnumber *= 10;\\n\\t}\\n\\tif(n<(val/10+number/10-1)) ans -= val/10+number/10-1-n;\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findKthNumber(int n, int k) {\\n\\tDeque<Integer> stack = new ArrayDeque<>();\\n\\tint count=0;\\n\\tfor(int i=1;i<10;i++) {\\n\\t\\tstack.push(i);\\n\\t\\twhile(!stack.isEmpty()) {\\n\\t\\t\\tint current = stack.pop();\\n\\t\\t\\tif(k==++count) return current;\\n\\t\\t\\tint countInSubtree = count(n,current);\\n\\t\\t\\tif(countInSubtree+count<k) {\\n\\t\\t\\t\\tcount=countInSubtree+count-1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor(int j=9;j>=0;j--) {\\n\\t\\t\\t\\t\\tint nextVal = Integer.parseInt(\"\"+current+j);\\n\\t\\t\\t\\t\\tif(nextVal<=n) {\\n\\t\\t\\t\\t\\t\\tstack.push(nextVal);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn -1;\\n}\\n\\npublic int count(int n, long val) {\\n\\tint ans = 0;\\n\\tint number = 1;\\n\\twhile(val<=n) {\\n\\t\\tans += number;\\n\\t\\tval *= 10;\\n\\t\\tnumber *= 10;\\n\\t}\\n\\tif(n<(val/10+number/10-1)) ans -= val/10+number/10-1-n;\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 92268,
                "title": "3ms-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int bnums[11] = {0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111};\\n    int dnums[11] = {0, 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};\\n\\n    int findKthNumber(int n, int k) {\\n        string res;\\n        find(n, to_string(n), k, res, 1);\\n        return atoi(res.c_str());\\n    }\\n\\n    void find(int n, const string &nstr, int k, string &res, int be) {\\n        int nn = nstr.size();\\n        vector<int> cnts(10, 0);\\n\\n        int c1 = bnums[nn];\\n        int c2 = bnums[nn-1] + (n % dnums[nn]) + 1;\\n        int c3 = bnums[nn-1];\\n\\n        int hdi = nstr[0] - '0';\\n        for (int i = be; i < hdi; i++) cnts[i] = c1;\\n        cnts[hdi] = c2;\\n        for (int i = hdi + 1; i <= 9; i++) cnts[i] = c3;\\n\\n        int cnt = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            cnt += cnts[i];\\n            if (cnt >= k) {\\n                res.push_back(i + '0');\\n                k -= (cnt - cnts[i]);\\n                if (k <= 1) return;\\n                if (i < hdi) {\\n                    find(dnums[nn]- 1, to_string(dnums[nn]- 1), k - 1, res, 0);\\n                }\\n                else if (i == hdi) {\\n                    string new_nstr = to_string(n % dnums[nn]);\\n                    int gg = (nn - 1) - new_nstr.size();\\n                    new_nstr.insert(0, gg, '0');\\n                    find(n % dnums[nn], new_nstr, k - 1, res, 0);\\n                }\\n                else {\\n                    find(dnums[nn-1] - 1, to_string(dnums[nn-1] - 1), k - 1, res, 0);\\n                }\\n                break;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int bnums[11] = {0, 1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111, 1111111111};\\n    int dnums[11] = {0, 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};\\n\\n    int findKthNumber(int n, int k) {\\n        string res;\\n        find(n, to_string(n), k, res, 1);\\n        return atoi(res.c_str());\\n    }\\n\\n    void find(int n, const string &nstr, int k, string &res, int be) {\\n        int nn = nstr.size();\\n        vector<int> cnts(10, 0);\\n\\n        int c1 = bnums[nn];\\n        int c2 = bnums[nn-1] + (n % dnums[nn]) + 1;\\n        int c3 = bnums[nn-1];\\n\\n        int hdi = nstr[0] - '0';\\n        for (int i = be; i < hdi; i++) cnts[i] = c1;\\n        cnts[hdi] = c2;\\n        for (int i = hdi + 1; i <= 9; i++) cnts[i] = c3;\\n\\n        int cnt = 0;\\n        for (int i = 0; i <= 9; i++) {\\n            cnt += cnts[i];\\n            if (cnt >= k) {\\n                res.push_back(i + '0');\\n                k -= (cnt - cnts[i]);\\n                if (k <= 1) return;\\n                if (i < hdi) {\\n                    find(dnums[nn]- 1, to_string(dnums[nn]- 1), k - 1, res, 0);\\n                }\\n                else if (i == hdi) {\\n                    string new_nstr = to_string(n % dnums[nn]);\\n                    int gg = (nn - 1) - new_nstr.size();\\n                    new_nstr.insert(0, gg, '0');\\n                    find(n % dnums[nn], new_nstr, k - 1, res, 0);\\n                }\\n                else {\\n                    find(dnums[nn-1] - 1, to_string(dnums[nn-1] - 1), k - 1, res, 0);\\n                }\\n                break;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1573273,
                "content": [
                    {
                        "username": "deshmukh_ajinkya",
                        "content": "The testcase (n=100,k=10) expects 17 as kth smallest element but shouldn\\'t it be 18? I am not able to understand this."
                    },
                    {
                        "username": "flow7f",
                        "content": "1 10 100 11 12 13 14 15 16 17"
                    },
                    {
                        "username": "tsuvmxwu",
                        "content": "So, we arrange numbers in a tree. If we know the size (the number of nodes) of every subtree, we can navigate the tree to find the digits of the target number.\\n\\nSuppose `n=4xx`. It's easy to see that any subtree rooted at `1,2,3` has a size of `111`, and any subtree rooted at `5,6,7,8,9` has a size of `11`. -- What about the subtree at `4`?\\n\\nSince the size of all subtrees at this level is `n`, the size of subtree rooted at `4` is `n-3*111-5*11`.\\n\\nGiven any `k`, we can easily find the first digit of the solution. We then adjust `n` and `k`, and descend to a lower level to find other digits."
                    },
                    {
                        "username": "ahan98",
                        "content": "This problem really pissed me the f off ngl"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Seems like a Variation of Digit DP"
                    }
                ]
            },
            {
                "id": 1571705,
                "content": [
                    {
                        "username": "deshmukh_ajinkya",
                        "content": "The testcase (n=100,k=10) expects 17 as kth smallest element but shouldn\\'t it be 18? I am not able to understand this."
                    },
                    {
                        "username": "flow7f",
                        "content": "1 10 100 11 12 13 14 15 16 17"
                    },
                    {
                        "username": "tsuvmxwu",
                        "content": "So, we arrange numbers in a tree. If we know the size (the number of nodes) of every subtree, we can navigate the tree to find the digits of the target number.\\n\\nSuppose `n=4xx`. It's easy to see that any subtree rooted at `1,2,3` has a size of `111`, and any subtree rooted at `5,6,7,8,9` has a size of `11`. -- What about the subtree at `4`?\\n\\nSince the size of all subtrees at this level is `n`, the size of subtree rooted at `4` is `n-3*111-5*11`.\\n\\nGiven any `k`, we can easily find the first digit of the solution. We then adjust `n` and `k`, and descend to a lower level to find other digits."
                    },
                    {
                        "username": "ahan98",
                        "content": "This problem really pissed me the f off ngl"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Seems like a Variation of Digit DP"
                    }
                ]
            },
            {
                "id": 2007865,
                "content": [
                    {
                        "username": "deshmukh_ajinkya",
                        "content": "The testcase (n=100,k=10) expects 17 as kth smallest element but shouldn\\'t it be 18? I am not able to understand this."
                    },
                    {
                        "username": "flow7f",
                        "content": "1 10 100 11 12 13 14 15 16 17"
                    },
                    {
                        "username": "tsuvmxwu",
                        "content": "So, we arrange numbers in a tree. If we know the size (the number of nodes) of every subtree, we can navigate the tree to find the digits of the target number.\\n\\nSuppose `n=4xx`. It's easy to see that any subtree rooted at `1,2,3` has a size of `111`, and any subtree rooted at `5,6,7,8,9` has a size of `11`. -- What about the subtree at `4`?\\n\\nSince the size of all subtrees at this level is `n`, the size of subtree rooted at `4` is `n-3*111-5*11`.\\n\\nGiven any `k`, we can easily find the first digit of the solution. We then adjust `n` and `k`, and descend to a lower level to find other digits."
                    },
                    {
                        "username": "ahan98",
                        "content": "This problem really pissed me the f off ngl"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Seems like a Variation of Digit DP"
                    }
                ]
            },
            {
                "id": 1998967,
                "content": [
                    {
                        "username": "deshmukh_ajinkya",
                        "content": "The testcase (n=100,k=10) expects 17 as kth smallest element but shouldn\\'t it be 18? I am not able to understand this."
                    },
                    {
                        "username": "flow7f",
                        "content": "1 10 100 11 12 13 14 15 16 17"
                    },
                    {
                        "username": "tsuvmxwu",
                        "content": "So, we arrange numbers in a tree. If we know the size (the number of nodes) of every subtree, we can navigate the tree to find the digits of the target number.\\n\\nSuppose `n=4xx`. It's easy to see that any subtree rooted at `1,2,3` has a size of `111`, and any subtree rooted at `5,6,7,8,9` has a size of `11`. -- What about the subtree at `4`?\\n\\nSince the size of all subtrees at this level is `n`, the size of subtree rooted at `4` is `n-3*111-5*11`.\\n\\nGiven any `k`, we can easily find the first digit of the solution. We then adjust `n` and `k`, and descend to a lower level to find other digits."
                    },
                    {
                        "username": "ahan98",
                        "content": "This problem really pissed me the f off ngl"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Seems like a Variation of Digit DP"
                    }
                ]
            }
        ]
    },
    {
        "title": "Single Element in a Sorted Array",
        "question_content": "<p>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</p>\n\n<p>Return <em>the single element that appears only once</em>.</p>\n\n<p>Your solution must run in <code>O(log n)</code> time and <code>O(1)</code> space.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1,2,3,3,4,4,8,8]\n<strong>Output:</strong> 2\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [3,3,7,7,10,11,11]\n<strong>Output:</strong> 10\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 627921,
                "title": "java-c-python3-easy-explanation-o-logn-o-1",
                "content": "```\\nEXPLANATION:-\\nSuppose array is [1, 1, 2, 2, 3, 3, 4, 5, 5]\\nwe can observe that for each pair, \\nfirst element takes even position and second element takes odd position\\nfor example, 1 is appeared as a pair,\\nso it takes 0 and 1 positions. similarly for all the pairs also.\\n\\nthis pattern will be missed when single element is appeared in the array.\\n\\nFrom these points, we can implement algorithm.\\n1. Take left and right pointers . \\n    left points to start of list. right points to end of the list.\\n2. find mid.\\n    if mid is even, then it\\'s duplicate should be in next index.\\n\\tor if mid is odd, then it\\'s duplicate  should be in previous index.\\n\\tcheck these two conditions, \\n\\tif any of the conditions is satisfied,\\n\\tthen pattern is not missed, \\n\\tso check in next half of the array. i.e, left = mid + 1\\n\\tif condition is not satisfied, then the pattern is missed.\\n\\tso, single number must be before mid.\\n\\tso, update end to mid.\\n3. At last return the nums[left]\\n\\nTime: -  O(logN)\\nspace:-  O(1)\\n\\nIF YOU  HAVE ANY DOUBTS, FEEL FREE TO ASK\\nIF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.\\n```\\n```\\nJava:-\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int left = 0, right = nums.length-1;\\n        while(left < right){\\n            int mid = (left + right)/2;\\n            if( (mid % 2 == 0 && nums[mid] == nums[mid +1]) || (mid %2 == 1 && nums[mid] == nums[mid - 1]) )\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return nums[left];\\n    }   \\n}\\n\\nPython3:-\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums)-1\\n        while left < right:\\n            mid = int((left + right)/2)\\n            if (mid % 2 == 1 and nums[mid - 1] == nums[mid]) or (mid%2 == 0 and nums[mid] == nums[mid + 1]):\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return nums[left]\\n\\t\\t\\nC++:-\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1;\\n        while(left < right){\\n            int mid = (left + right)/2;\\n            if((mid % 2 == 0 && nums[mid] == nums[mid + 1]) || (mid % 2 == 1 && nums[mid] == nums[mid - 1]))\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        \\n        return nums[left];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nEXPLANATION:-\\nSuppose array is [1, 1, 2, 2, 3, 3, 4, 5, 5]\\nwe can observe that for each pair, \\nfirst element takes even position and second element takes odd position\\nfor example, 1 is appeared as a pair,\\nso it takes 0 and 1 positions. similarly for all the pairs also.\\n\\nthis pattern will be missed when single element is appeared in the array.\\n\\nFrom these points, we can implement algorithm.\\n1. Take left and right pointers . \\n    left points to start of list. right points to end of the list.\\n2. find mid.\\n    if mid is even, then it\\'s duplicate should be in next index.\\n\\tor if mid is odd, then it\\'s duplicate  should be in previous index.\\n\\tcheck these two conditions, \\n\\tif any of the conditions is satisfied,\\n\\tthen pattern is not missed, \\n\\tso check in next half of the array. i.e, left = mid + 1\\n\\tif condition is not satisfied, then the pattern is missed.\\n\\tso, single number must be before mid.\\n\\tso, update end to mid.\\n3. At last return the nums[left]\\n\\nTime: -  O(logN)\\nspace:-  O(1)\\n\\nIF YOU  HAVE ANY DOUBTS, FEEL FREE TO ASK\\nIF YOU UNDERSTAND, DON\\'T FORGET TO UPVOTE.\\n```\n```\\nJava:-\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int left = 0, right = nums.length-1;\\n        while(left < right){\\n            int mid = (left + right)/2;\\n            if( (mid % 2 == 0 && nums[mid] == nums[mid +1]) || (mid %2 == 1 && nums[mid] == nums[mid - 1]) )\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return nums[left];\\n    }   \\n}\\n\\nPython3:-\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums)-1\\n        while left < right:\\n            mid = int((left + right)/2)\\n            if (mid % 2 == 1 and nums[mid - 1] == nums[mid]) or (mid%2 == 0 and nums[mid] == nums[mid + 1]):\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return nums[left]\\n\\t\\t\\nC++:-\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1;\\n        while(left < right){\\n            int mid = (left + right)/2;\\n            if((mid % 2 == 0 && nums[mid] == nums[mid + 1]) || (mid % 2 == 1 && nums[mid] == nums[mid - 1]))\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        \\n        return nums[left];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212178,
                "title": "day-52-binary-search-easiest-beginner-friendly-sol",
                "content": "# Intuition of this Problem:\\nSince every element in the sorted array appears exactly twice except for the single element, we know that if we take any element at an even index (0-indexed), the next element should be the same. Similarly, if we take any element at an odd index, the previous element should be the same. Therefore, we can use binary search to compare the middle element with its adjacent elements to determine which side of the array the single element is on.\\n\\nIf the middle element is at an even index, then the single element must be on the right side of the array, since all the elements on the left side should come in pairs. Similarly, if the middle element is at an odd index, then the single element must be on the left side of the array.\\n\\nWe can continue this process by dividing the search range in half each time, until we find the single element.\\n\\n ***Another interesting observation you might have made is that this algorithm will still work even if the array isn\\'t fully sorted. As long as pairs are always grouped together in the array (for example, [10, 10, 4, 4, 7, 11, 11, 12, 12, 2, 2]), it doesn\\'t matter what order they\\'re in. Binary search worked for this problem because we knew the subarray with the single number is always odd-lengthed, not because the array was fully sorted numerically***\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize two pointers, left and right, to the first and last indices of the input array, respectively.\\n2. While the left pointer is less than the right pointer:\\n    - a. Compute the index of the middle element by adding left and right and dividing by 2.\\n    - b. If the index of the middle element is odd, subtract 1 to make it even.\\n    - c. Compare the middle element with its adjacent element on the right:\\n        - i. If the middle element is not equal to its right neighbor, the single element must be on the left side of the array, so update the right pointer to be the current middle index.\\n        - ii. Otherwise, the single element must be on the right side of the array, so update the left pointer to be the middle index plus 2.\\n1. When the left and right pointers converge to a single element, return that element.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (mid % 2 == 1) {\\n                mid--;\\n            }\\n            if (nums[mid] != nums[mid + 1]) {\\n                right = mid;\\n            } else {\\n                left = mid + 2;\\n            }\\n        }\\n        return nums[left];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (mid % 2 == 1) {\\n                mid--;\\n            }\\n            if (nums[mid] != nums[mid + 1]) {\\n                right = mid;\\n            } else {\\n                left = mid + 2;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if mid % 2 == 1:\\n                mid -= 1\\n            if nums[mid] != nums[mid + 1]:\\n                right = mid\\n            else:\\n                left = mid + 2\\n        return nums[left]\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(logn)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (mid % 2 == 1) {\\n                mid--;\\n            }\\n            if (nums[mid] != nums[mid + 1]) {\\n                right = mid;\\n            } else {\\n                left = mid + 2;\\n            }\\n        }\\n        return nums[left];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (mid % 2 == 1) {\\n                mid--;\\n            }\\n            if (nums[mid] != nums[mid + 1]) {\\n                right = mid;\\n            } else {\\n                left = mid + 2;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums) - 1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if mid % 2 == 1:\\n                mid -= 1\\n            if nums[mid] != nums[mid + 1]:\\n                right = mid\\n            else:\\n                left = mid + 2\\n        return nums[left]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100754,
                "title": "java-binary-search-short-7l-o-log-n-w-explanations",
                "content": "All credits go to [@Penghuan](/post/175763) who thought of using the pairs wisely.\\n\\nThis method seems to be a bit simpler to understand, since it doesn't start with the left half and stays a little bit closer to the conventional solutions.\\n\\n```\\n   public static int singleNonDuplicate(int[] nums) {\\n        int start = 0, end = nums.length - 1;\\n\\n        while (start < end) {\\n            // We want the first element of the middle pair,\\n            // which should be at an even index if the left part is sorted.\\n            // Example:\\n            // Index: 0 1 2 3 4 5 6\\n            // Array: 1 1 3 3 4 8 8\\n            //            ^\\n            int mid = (start + end) / 2;\\n            if (mid % 2 == 1) mid--;\\n\\n            // We didn't find a pair. The single element must be on the left.\\n            // (pipes mean start & end)\\n            // Example: |0 1 1 3 3 6 6|\\n            //               ^ ^\\n            // Next:    |0 1 1|3 3 6 6\\n            if (nums[mid] != nums[mid + 1]) end = mid;\\n\\n            // We found a pair. The single element must be on the right.\\n            // Example: |1 1 3 3 5 6 6|\\n            //               ^ ^\\n            // Next:     1 1 3 3|5 6 6|\\n            else start = mid + 2;\\n        }\\n\\n        // 'start' should always be at the beginning of a pair.\\n        // When 'start > end', start must be the single element.\\n        return nums[start];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public static int singleNonDuplicate(int[] nums) {\\n        int start = 0, end = nums.length - 1;\\n\\n        while (start < end) {\\n            // We want the first element of the middle pair,\\n            // which should be at an even index if the left part is sorted.\\n            // Example:\\n            // Index: 0 1 2 3 4 5 6\\n            // Array: 1 1 3 3 4 8 8\\n            //            ^\\n            int mid = (start + end) / 2;\\n            if (mid % 2 == 1) mid--;\\n\\n            // We didn't find a pair. The single element must be on the left.\\n            // (pipes mean start & end)\\n            // Example: |0 1 1 3 3 6 6|\\n            //               ^ ^\\n            // Next:    |0 1 1|3 3 6 6\\n            if (nums[mid] != nums[mid + 1]) end = mid;\\n\\n            // We found a pair. The single element must be on the right.\\n            // Example: |1 1 3 3 5 6 6|\\n            //               ^ ^\\n            // Next:     1 1 3 3|5 6 6|\\n            else start = mid + 2;\\n        }\\n\\n        // 'start' should always be at the beginning of a pair.\\n        // When 'start > end', start must be the single element.\\n        return nums[start];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100732,
                "title": "short-compare-nums-i-with-nums-i-1",
                "content": "Simply find the first index whose \"partner index\" (the index xor 1) holds a different value.\\n\\n**Ruby:**\\n```\\ndef single_non_duplicate(nums)\\n  nums[(0..nums.size).bsearch { |i| nums[i] != nums[i^1] }]\\nend\\n```\\n**Python**\\n\\n    def singleNonDuplicate(self, nums):\\n        lo, hi = 0, len(nums) - 1\\n        while lo < hi:\\n            mid = (lo + hi) / 2\\n            if nums[mid] == nums[mid ^ 1]:\\n                lo = mid + 1\\n            else:\\n                hi = mid\\n        return nums[lo]\\n\\n**Java:**\\n\\n    public int singleNonDuplicate(int[] nums) {\\n        int lo = 0, hi = nums.length - 1;\\n        while (lo < hi) {\\n            int mid = (lo + hi) >>> 1;\\n            if (nums[mid] == nums[mid ^ 1])\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return nums[lo];\\n    }",
                "solutionTags": [],
                "code": "```\\ndef single_non_duplicate(nums)\\n  nums[(0..nums.size).bsearch { |i| nums[i] != nums[i^1] }]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1587270,
                "title": "c-python-7-simple-solutions-w-explanation-brute-hashmap-xor-linear-2-binary-search",
                "content": "We are given a sorted array `nums` consisting of elements each of which occurs twice except one. We need to return that element which occurs once.\\n\\n<details>\\n<summary><i>Table of Contents</i></summary>\\n<p align=middle>\\n<table>\\n  <tr>\\n    <th>No.</th>\\n    <th>Approach</th>\\n    <th>Time</th>\\n    <th>Space</th>\\n  </tr>\\n  <tr>\\n  <td>1</td>\\n  <td>\\u26A0\\uFE0F\\u2714\\uFE0F <b>Brute-Force</b></td>\\n    <td><code>O(N<sup>2</sup>)</code></td>\\n    <td><code>O(1)</code></td>\\n  </tr>\\n  <tr>\\n  <td>2</td>\\n    <td>\\u2714\\uFE0F <b>Hashmap</b></td>\\n    <td><code>O(N)</code></td>\\n    <td><code>O(N)</code></td>\\n  </tr>\\n  <tr>\\n  <td>3</td>\\n    <td>\\u2714\\uFE0F <b> Hashset</b></td>\\n    <td><code>O(N)</code></td>\\n    <td><code>O(N)</code></td>\\n  </tr>\\n  <tr>\\n  <td>4</td>\\n    <td>\\u2714\\uFE0F <b>XOR</b></td>\\n    <td><code>O(N)</code></td>\\n    <td><code>O(1)</code></td>\\n  </tr>\\n  <tr>\\n  <td>5</td>\\n    <td>\\u2714\\uFE0F <b>Linear-Search</b></td>\\n    <td><code>O(N)</code></td>\\n    <td><code>O(1)</code></td>\\n  </tr>\\n  <tr>\\n  <td>6</td>\\n    <td>\\u2714\\uFE0F <b>Binary Search</b></td>\\n    <td><code>O(logN)</code></td>\\n    <td><code>O(1)</code></td>\\n  </tr>  \\n  <tr>\\n  <td>7</td>\\n    <td>\\u2714\\uFE0F <b>Binary Search - 2nd Approach</b></td>\\n    <td><code>O(logN)</code></td>\\n    <td><code>O(1)</code></td>\\n  </tr>  \\n</table>\\n</p>\\n</details>\\n\\n---\\n\\n\\n\\n\\u26A0\\uFE0F \\u2714\\uFE0F  <em><b>Solution - I (Brute-Force)</b></em>\\n\\nThe most naive, brute-force way of solving this problem would be to consider each element in `nums` and check how many times it occurs. If it occurs just once, we can return that element as answer.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        for(auto c : nums) {\\n            int occurence = 0;\\n            for(auto c2 : nums)\\n                occurence += c == c2;\\n            if(occurence == 1) return c;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        for c in nums:\\n            if nums.count(c) == 1: \\n\\t\\t\\t\\treturn c\\n```\\n\\n***Time Complexity :*** **<code>O(N<sup>2</sup>)</code>**, where `N` is the number of elements in the `nums` array. We take `O(N)` time to check occurences of an element in `nums`. In the worst case, there are `N` elements for which this operation is performed giving a total time complexity of <code>O(N<sup>2</sup>)</code>\\n***Space Complexity :*** **`O(1)`**\\n\\n**Note :** The above solution passes for now but that\\'s due to weak test cases.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Hashmap)***\\n\\nWe can use a hashmap to iterate over the `nums` array and count the number of times each element occurs. Finally, the element that has frequency of 1 will be returned.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        for(auto c : nums) mp[c]++;                // counting frequency of elements\\n        for(auto [c, freq] : mp)\\n            if(freq == 1) return c;                // return element occuring once\\n        return -1;                                 // wont be reached\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        mp = Counter(nums)\\n        for c, freq in mp.items():\\n            if freq == 1: \\n                return c\\n```\\n\\n\\n***Time Complexity :*** **`O(N)`**, where `N` is the number of elements in the `nums` array. We required `O(N)` time to iterate over `nums` and populate hashmap and another `O(N)` to iterate over the hashmap.\\n***Space Complexity :*** **`O(N)`**, required to maintain the hashmap.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Hashset)***\\n\\nWe can do slightly better on average space complexity by using a hashset. Since every element occurs twice except one, we can insert into set when we find 1st occurence and remove from set when its found again. Finally the set will consist of only 1 element which will be the required answer.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(auto c : nums) \\n            if(s.count(c)) s.erase(c);      // erase on 2nd occurence\\n            else s.insert(c);               // insert on 1st occurence\\n        return *begin(s);                   // only element at end is the element occuring once\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        s = set()\\n        for c in nums:\\n            if c in s: s.remove(c)\\n            else: s.add(c)\\n        return s.pop()\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(N)`**, required to maintain the hashset. Here the average case complexity is `O(N/2)`, slight improvement from `O(N)` in case of hashmap.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (XOR)***\\n\\nWe can use the property of xor operation in this problem. We know that `a \\u2295 a = 0`, i.e, two same numbers when xor-ed, cancels each other out. In our case, every element occurs twice except the one. Thus, if we xor all the elements from `nums`, every element will cancel each other out except the required answer.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto c : nums) ans ^= c;    // xor-ing all elements of array\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        return reduce(xor, nums)\\n```\\n\\n***Time Complexity :*** **`O(N)`**\\n***Space Complexity :*** **`O(1)`** only constant extra space is being used.\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Linear Search)***\\n\\nWe know that the given array is sorted and so duplicates occur adjacently. So, we can just iterate over the array and starting from the 1st element of array, we compare each one with its next adjacent element. If the next element is not equal, we know that current element has occured only once and thus return it as answer.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        for(int i = 0; i < size(nums)-1; i+=2) \\n\\t\\t\\tif(nums[i] != nums[i+1])\\n                return nums[i];\\n        return nums.back();\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        for i in range(0, len(nums)-1, 2):\\n            if nums[i] != nums[i+1]:\\n                return nums[i]\\n        return nums[-1]\\n```\\n\\n***Time Complexity :*** **`O(N)`**, for iterating array once.\\n***Space Complexity :*** **`O(1)`** only constant extra space is being used.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - VI (Binary Search)***\\n\\nThis approach uses the fact that since the array is sorted, every duplicate element occur adjacently. We can also see that the length of given array must be odd (Why? All element occur twice while only 1 element occurs once). \\n\\nLet the search range be `[L, R]`. Now, when we consider the mid element, the array is split into two equal halves on the left and right sides. Then we have following cases -\\n1. `nums[mid] == nums[mid+1]`:\\n\\t* **Left Half Length = Right Half Length = Even :** In this case, we can be sure that our answer lies in the right half. How? One element of right half: `nums[mid+1]` matches with `nums[mid]`. So, leaving `nums[mid+1]` aside, we only have odd number of elements to pair up with each other in the right half. This means one element must be such that it cannot be paired with anyone and this is our required answer that occurs only once. So do **`L = mid+2`** (`+2` to skip `nums[mid]` and `nums[mid+1]` & keep search space odd for next iteration)\\n\\t* **Left Half Length = Right Half Length = Odd :** In this case, we can be sure that our answer lies in the left half. Again, how? Following same reasoning, one element of left half: `nums[mid+1]` matches with `nums[mid]`. So, leaving `nums[mid+1]` aside, the right half consists of even number of elements which can pair up with each other completely. However, left half only consists odd elements and thus one element which cannot be paired with anyone is our required answer. So do **`R = mid-1`** (`-1` to skip `nums[mid]` & keep search space odd for next iteration)\\n\\n2. `nums[mid] == nums[mid-1]`: We can follow similar reasoning based on array lengths as above -\\n\\t* **Left Half Length = Right Half Length = Even :** The answer lies in the left half. How? One element of left half: `nums[mid-1]` matches with `nums[mid]`. This leaves left half with odd number of elements to pair up with each other and one element that cant be paired with anyone is the required answer. So do **`R = mid-2`**\\n\\t* **Left Half Length = Right Half Length = Odd :** The answer lies in right half. How? One element of left half: `nums[mid-1]` matches with `nums[mid]`. This leaves left half with even number of elements which can pair up with each other completely. However, right half only consists odd elements and thus one element which cannot be paired with any other is the required answer. So do **`L = mid+1`**.\\n\\n3. If neither of above condition are satisfied, then we can be sure that `nums[mid]` itself is the required element occuring once (since it doesnt match with its neighbours). So we can just return it.\\n\\n```python\\nnums = [1,2,2,3,3,4,4,8,8]\\n\\n1. [L = 0, R = 8] => mid = 4 and nums[mid] == nums[mid-1]\\n   The left half length is even and 1 element is equal to nums[mid].\\n   This tells us that left half is left with odd elements to pair up with each other\\n   One element will be left out which is our answer. So search in left half - [0, 2]\\n   We decremented R by 2 to keep remaining search space of odd length so we can repeat same process\\n   \\n2. [L = 0, R = 2] => mid = 1 and nums[mid] == nums[mid+1]\\n   The left half is of odd length and one element cant be paired with another.\\n   So our answer exist in left half. So search in left half - [0, 0]\\n   \\n3. [L = 0, R = 0] => mid = 1 and nums[mid] != nums[mid-1] and nums[mid] != nums[mid+1]\\n   This means nums[mid] is our final answer since it is not equal to either of its neighbours\\n```\\n\\nThe below code is a direct translation of above logic -\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = size(nums), L = 0, R = n-1, mid;\\n        while(L <= R) {\\n            mid = (L + R) >> 1;\\n            bool isHalfEven = (mid-L) % 2 == 0;          // check length of each half is odd or even\\n\\t\\t\\t\\n            if(mid+1 < n && nums[mid] == nums[mid+1])    // case: 1\\n                if(isHalfEven) L = mid+2;\\n                else R = mid-1;\\n\\t\\t\\t\\t\\n            else if(mid && nums[mid] == nums[mid-1])     // case: 2\\n                if(isHalfEven) R = mid-2;\\n                else L = mid+1;\\n\\t\\t\\t\\t\\n            else return nums[mid];                       // case: 3\\n        }\\n        return -1;   // wont be reached since we will always find required element inside loop\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        L, R, mid = 0, len(nums)-1, 0\\n        while L <= R:\\n            mid = (L + R) >> 1\\n            isHalfEven = (mid-L) % 2 == 0\\n            \\n            if mid+1 < len(nums) and nums[mid] == nums[mid+1]:\\n                if isHalfEven: L = mid + 2\\n                else: R = mid - 1\\n            elif mid and nums[mid] == nums[mid-1]:\\n                if isHalfEven: R = mid - 2\\n                else: L = mid + 1\\n            else: \\n                return nums[mid]\\n```\\n\\n***Time Complexity :*** **`O(logN)`**, each time we are eliminating half of search space using binary search\\n***Space Complexity :*** **`O(1)`** only constant extra space is being used.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution VII (Binary Search - 2nd Approach)***\\n\\nWe can apply binary search using slightly different logic as well. \\n\\nSuppose you are given a sorted array with all elements occur twice. For eg. `[1,1,2,2,5,5,7,7,8,8]`. So, here we can see that the elements follow the condition - **`nums[0] == nums[1], nums[2] == nums[3],..., nums[2*k] == nums[2*k+1]`**. Now, if we insert an element somewhere in the array, the above relation wont be satisfied from that point of insertion. Eg. `[1,1,2,2,4,5,5,7,7,8,8]` the condition starts to fail from element `4`, that is from point where single-occurence element is present.\\n\\nThus, we can use this observation to apply binary-search to find the starting point from where the above condition starts to fail. This start point is the index of element occuring once. The binary search will be applied as follows -\\n\\n1. Initialize the search space as `[L, R] = [0, n-1]` and repeat the following step till `L <= R`.\\n2. Find the `mid` position and check if the above condition **`nums[2*k] == nums[2*k+1]`** is satisifed or not. \\nFor this, firstly we must ensure that `mid` is even. If `mid` is odd, decrease it by 1 to make it even. \\nThen, we need to check if the condition is satisfied or not - \\n\\t* **`nums[mid] == nums[mid+1]` :** The condition is correctly satisfied till index `mid+1`. So, the required element must occur somewhere on the right of `mid+1`. So do `L = mid+2`.\\n\\t* **`nums[mid] != nums[mid+1]` :** The condition is not satisfied at this point. So, the required element must either be `nums[mid]` or occur somewhere on the left of `mid` due to which the relation is not satisfied. Mark `nums[mid]` as a potential answer and search if condition is satisfied to the left of `mid` by doing `R = mid-1`\\n\\nFinally, we return the `ans` which was marked as potential answer during the binary search. \\n\\n```python\\nnums = [1,1,2,2,3,3,4,4,5,5,6]\\n\\n1. [L = 0, R = 10] => mid = 5\\n    Since mid is odd. We subtract 1 and mid becomes 4. Now, nums[mid] == nums[mid+1]\\n   So condition is satisfied upto this point.\\n   So the answer exists in right half in the [mid+2, R] = [6, 10] range\\n   \\n2. [L = 6, R = 10] => mid = 8 and nums[mid] == nums[mid+1]\\n   Again, condition is satisfied upto this point\\n   So, answer must exist in the right half in [mid+2, R] = [10, 10]\\n   \\n3. [L = 10, R = 10] => mid = 10\\n   Now, mid+1 >= n and so we get nums[mid] != nums[mid+1]\\n   So the condtion fails here. So mid is a potential answer. \\n   We mark nums[mid] as ans and search in [L, mid-1] = [10, 9] range\\n   \\n   But since L > R, we break out of loop,\\n   We finally return the marked answer which is nums[10] = 6\\n```\\n\\n\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = size(nums), L = 0, R = n-1, mid, ans;\\n        while(L <= R) {\\n            mid = (L + R) >> 1;\\n            if(mid & 1) mid--;                              // make mid even to check for required condition\\n            if(mid+1 < n && nums[mid] == nums[mid+1])       // condition satisfied upto mid+1:\\n                L = mid+2;                                  // so search in [mid+2, R] to find point where condition starts to fail\\n            else                                            // condition not satisfied:\\n                R = mid-1, ans = nums[mid];                 // nums[mid] is potential answer. search [L, mid-1] to see if condition started to fail somewhere before\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        L, R, mid, ans = 0, len(nums)-1, 0, 0\\n        while L <= R:\\n            mid = ((L + R) >> 2) << 1  # Does the same thing as above, i.e, ensuring mid is even\\n            if mid+1 < len(nums) and nums[mid] == nums[mid+1]:\\n                L = mid + 2\\n            else: \\n                R, ans = mid - 1, nums[mid]\\n        return ans\\n```\\n\\nOr instead of the usual way of declaring `[L,R]` as extremes of binary search space and searching within it, we can make a slight change to make the code a bit more concise (and also directly apply condition of `nums[2*k]==nums[2*k+1]`):\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {;\\n        int L = 0, R = size(nums) / 2, mid;\\n        while(L < R){\\n            mid = (L + R) >> 1;\\n            if(nums[2*mid] == nums[2*mid + 1])\\n                L = mid + 1;\\n            else\\n                R = mid;\\n        }\\n        return nums[2 * R];\\n    }\\n};\\n```\\n\\n***Time Complexity :*** **`O(logN)`**, each time we are eliminating half of search space using binary search\\n***Space Complexity :*** **`O(1)`**\\n\\n---\\n\\n\\uD83D\\uDCA1 **Note :**\\n* If you observe both binary search approaches carefully, you can see that it wouldn\\'t have mattered if the array was unsorted. The only thing we required to apply binary search is that the duplicate elements occur adjacent to each other. \\n\\tSo the above **Binary-Search approach works for both sorted & un-sorted arrays given that duplicates occur adjacently.**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        for(auto c : nums) {\\n            int occurence = 0;\\n            for(auto c2 : nums)\\n                occurence += c == c2;\\n            if(occurence == 1) return c;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        for c in nums:\\n            if nums.count(c) == 1: \\n\\t\\t\\t\\treturn c\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        for(auto c : nums) mp[c]++;                // counting frequency of elements\\n        for(auto [c, freq] : mp)\\n            if(freq == 1) return c;                // return element occuring once\\n        return -1;                                 // wont be reached\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        mp = Counter(nums)\\n        for c, freq in mp.items():\\n            if freq == 1: \\n                return c\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(auto c : nums) \\n            if(s.count(c)) s.erase(c);      // erase on 2nd occurence\\n            else s.insert(c);               // insert on 1st occurence\\n        return *begin(s);                   // only element at end is the element occuring once\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        s = set()\\n        for c in nums:\\n            if c in s: s.remove(c)\\n            else: s.add(c)\\n        return s.pop()\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto c : nums) ans ^= c;    // xor-ing all elements of array\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        return reduce(xor, nums)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        for(int i = 0; i < size(nums)-1; i+=2) \\n\\t\\t\\tif(nums[i] != nums[i+1])\\n                return nums[i];\\n        return nums.back();\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        for i in range(0, len(nums)-1, 2):\\n            if nums[i] != nums[i+1]:\\n                return nums[i]\\n        return nums[-1]\\n```\n```python\\nnums = [1,2,2,3,3,4,4,8,8]\\n\\n1. [L = 0, R = 8] => mid = 4 and nums[mid] == nums[mid-1]\\n   The left half length is even and 1 element is equal to nums[mid].\\n   This tells us that left half is left with odd elements to pair up with each other\\n   One element will be left out which is our answer. So search in left half - [0, 2]\\n   We decremented R by 2 to keep remaining search space of odd length so we can repeat same process\\n   \\n2. [L = 0, R = 2] => mid = 1 and nums[mid] == nums[mid+1]\\n   The left half is of odd length and one element cant be paired with another.\\n   So our answer exist in left half. So search in left half - [0, 0]\\n   \\n3. [L = 0, R = 0] => mid = 1 and nums[mid] != nums[mid-1] and nums[mid] != nums[mid+1]\\n   This means nums[mid] is our final answer since it is not equal to either of its neighbours\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = size(nums), L = 0, R = n-1, mid;\\n        while(L <= R) {\\n            mid = (L + R) >> 1;\\n            bool isHalfEven = (mid-L) % 2 == 0;          // check length of each half is odd or even\\n\\t\\t\\t\\n            if(mid+1 < n && nums[mid] == nums[mid+1])    // case: 1\\n                if(isHalfEven) L = mid+2;\\n                else R = mid-1;\\n\\t\\t\\t\\t\\n            else if(mid && nums[mid] == nums[mid-1])     // case: 2\\n                if(isHalfEven) R = mid-2;\\n                else L = mid+1;\\n\\t\\t\\t\\t\\n            else return nums[mid];                       // case: 3\\n        }\\n        return -1;   // wont be reached since we will always find required element inside loop\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        L, R, mid = 0, len(nums)-1, 0\\n        while L <= R:\\n            mid = (L + R) >> 1\\n            isHalfEven = (mid-L) % 2 == 0\\n            \\n            if mid+1 < len(nums) and nums[mid] == nums[mid+1]:\\n                if isHalfEven: L = mid + 2\\n                else: R = mid - 1\\n            elif mid and nums[mid] == nums[mid-1]:\\n                if isHalfEven: R = mid - 2\\n                else: L = mid + 1\\n            else: \\n                return nums[mid]\\n```\n```python\\nnums = [1,1,2,2,3,3,4,4,5,5,6]\\n\\n1. [L = 0, R = 10] => mid = 5\\n    Since mid is odd. We subtract 1 and mid becomes 4. Now, nums[mid] == nums[mid+1]\\n   So condition is satisfied upto this point.\\n   So the answer exists in right half in the [mid+2, R] = [6, 10] range\\n   \\n2. [L = 6, R = 10] => mid = 8 and nums[mid] == nums[mid+1]\\n   Again, condition is satisfied upto this point\\n   So, answer must exist in the right half in [mid+2, R] = [10, 10]\\n   \\n3. [L = 10, R = 10] => mid = 10\\n   Now, mid+1 >= n and so we get nums[mid] != nums[mid+1]\\n   So the condtion fails here. So mid is a potential answer. \\n   We mark nums[mid] as ans and search in [L, mid-1] = [10, 9] range\\n   \\n   But since L > R, we break out of loop,\\n   We finally return the marked answer which is nums[10] = 6\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = size(nums), L = 0, R = n-1, mid, ans;\\n        while(L <= R) {\\n            mid = (L + R) >> 1;\\n            if(mid & 1) mid--;                              // make mid even to check for required condition\\n            if(mid+1 < n && nums[mid] == nums[mid+1])       // condition satisfied upto mid+1:\\n                L = mid+2;                                  // so search in [mid+2, R] to find point where condition starts to fail\\n            else                                            // condition not satisfied:\\n                R = mid-1, ans = nums[mid];                 // nums[mid] is potential answer. search [L, mid-1] to see if condition started to fail somewhere before\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        L, R, mid, ans = 0, len(nums)-1, 0, 0\\n        while L <= R:\\n            mid = ((L + R) >> 2) << 1  # Does the same thing as above, i.e, ensuring mid is even\\n            if mid+1 < len(nums) and nums[mid] == nums[mid+1]:\\n                L = mid + 2\\n            else: \\n                R, ans = mid - 1, nums[mid]\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {;\\n        int L = 0, R = size(nums) / 2, mid;\\n        while(L < R){\\n            mid = (L + R) >> 1;\\n            if(nums[2*mid] == nums[2*mid + 1])\\n                L = mid + 1;\\n            else\\n                R = mid;\\n        }\\n        return nums[2 * R];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100759,
                "title": "java-binary-search-o-log-n-shorter-than-others",
                "content": "My solution using binary search. lo and hi are not regular index, but the pair index here. Basically you want to find the first even-index number not followed by the same number.\\n```\\npublic class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        // binary search\\n        int n=nums.length, lo=0, hi=n/2;\\n        while (lo < hi) {\\n            int m = (lo + hi) / 2;\\n            if (nums[2*m]!=nums[2*m+1]) hi = m;\\n            else lo = m+1;\\n        }\\n        return nums[2*lo];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        // binary search\\n        int n=nums.length, lo=0, hi=n/2;\\n        while (lo < hi) {\\n            int m = (lo + hi) / 2;\\n            if (nums[2*m]!=nums[2*m+1]) hi = m;\\n            else lo = m+1;\\n        }\\n        return nums[2*lo];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587257,
                "title": "c-easy-intuitive-solution-2-approaches-binary-search-tc-o-log-n-sc-o-1",
                "content": "Hello everyone, I hope you all are doing great!\\n\\n***NOTE: If you found this post helpful, then please do upvote it!***\\n\\n**Brute Force Approach: (XOR)** Since we know every element occurs exactly twice, where as our target element occurs once, then we can simple take xor of all the elements of the array. In the end we will be left with our target element that appeared once (Because A^A = 0).\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        int xr{};\\n        \\n        for(auto num: nums)\\n            xr = xr^num;\\n        \\n        return xr;\\n    }\\n};\\n```\\n\\n**Time Complexity:** ***O(N)***\\n**Space Complexity:** ***O(1)***\\n\\n<hr></hr>\\n\\n**Optimal Approach: (Binary Search)**\\n1. We will use the fact that the vector is sorted.\\n2. **Observation:** If you divide the array in two parts, `PART A`: where elements are before target element and `PART B`:  where elements are after target element then:\\n\\n\\ta. In `PART A`, the first instance of element occurs at even index and the second instance of the element occurs at odd index.\\n\\t\\n\\tb. In `PART B`, the first instance of element occurs at odd index and the second instance of the element occurs at even index.\\n\\t\\n\\tc. You can visualize using following example: \\n\\t```\\n\\tindex:   0 1 2 3 4 5 6 7 8\\n\\tvector: [1,1,2,3,3,4,4,8,8]\\n\\t             \\uD83D\\uDC46 (Target element is 2 since it appears once)\\n\\t```\\n\\tIn this example, before `2` every first instance of element occurs at even index and second instance at odd index (see element `1`) and after `2` every first instance of element occurs at odd index and second instance at even index (see element `3`, `4` and `8`).\\n\\t\\n\\t3. So from the above observation we will apply binary search on our array, and if we are on the `PART - B` side of array, we go to left, otherwise we go right.\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int low = 0, high = nums.size()-2; \\n        \\n        while(low <= high){\\n            \\n            int mid = low + (high-low)/2;\\n            \\n\\t\\t\\t// If we are on left side, move right\\n            if(nums[mid] == nums[mid^1]) low = mid+1;\\n\\t\\t\\t// if we are on right side, move left\\n            else high = mid-1;\\n        }\\n        \\n        return nums[low];\\n    }\\n};\\n\\n// mid^1 explanation:\\n// If mid is odd then (mid^1) will always be the even number before mid\\n// If mid is even then (mid^1) will always be the odd number after mid\\n\\n// And hence I am able to check whether mid is in left half or right half as:\\n\\n// Suppose mid is odd: then mid^1 will give even number before it, \\n// then if nums[mid] == nums[mid^1] \\n// then 1st instance at even (mid^1) and 2nd instance at odd (mid), \\n// hence we are on left side otherwise we are on right side.\\n\\n// Suppose mid is even: then mid^1 will give odd number after it, \\n// then if nums[mid] == nums[mid^1]\\n// then 1st instance at even (mid) and 2nd instance at odd (mid^1), \\n// hence we are on left side otherwise we are on right side\\n```\\n\\n**Time Complexity:** ***O(Log(N))***\\n**Space Complexity:** ***O(1)***\\n\\n**NOTE: Please \\uD83D\\uDD3C Upvote if you found this post helpful**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        int xr{};\\n        \\n        for(auto num: nums)\\n            xr = xr^num;\\n        \\n        return xr;\\n    }\\n};\\n```\n```\\n\\tindex:   0 1 2 3 4 5 6 7 8\\n\\tvector: [1,1,2,3,3,4,4,8,8]\\n\\t             \\uD83D\\uDC46 (Target element is 2 since it appears once)\\n\\t```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int low = 0, high = nums.size()-2; \\n        \\n        while(low <= high){\\n            \\n            int mid = low + (high-low)/2;\\n            \\n\\t\\t\\t// If we are on left side, move right\\n            if(nums[mid] == nums[mid^1]) low = mid+1;\\n\\t\\t\\t// if we are on right side, move left\\n            else high = mid-1;\\n        }\\n        \\n        return nums[low];\\n    }\\n};\\n\\n// mid^1 explanation:\\n// If mid is odd then (mid^1) will always be the even number before mid\\n// If mid is even then (mid^1) will always be the odd number after mid\\n\\n// And hence I am able to check whether mid is in left half or right half as:\\n\\n// Suppose mid is odd: then mid^1 will give even number before it, \\n// then if nums[mid] == nums[mid^1] \\n// then 1st instance at even (mid^1) and 2nd instance at odd (mid), \\n// hence we are on left side otherwise we are on right side.\\n\\n// Suppose mid is even: then mid^1 will give odd number after it, \\n// then if nums[mid] == nums[mid^1]\\n// then 1st instance at even (mid) and 2nd instance at odd (mid^1), \\n// hence we are on left side otherwise we are on right side\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587251,
                "title": "c-easy-and-concise-o-logn-solution-w-explanation",
                "content": "Hello everyone, firstly thanks for refering to my solution in advance :)\\n\\n**APPROACH :** \\n* So, the array has all the elements repeating twice except for one element which appears only once and the array is sorted. \\n* This means that in every number that\\'s repeated, the first number is at an even index (index%2==0) and the 2nd number is at an odd index. \\n* The idea is to peform a binary search over the entire array and find out if this pattern follows. If somewhere this pattern is broken, then we\\'re going to know in which half of the array there is an element that appears only once. \\n* We reduce the search space to that half an search again, until we\\'re left with a single element, which is the final answer.\\n\\nLet us look at the first example : \\n                 \\n```\\n        0    1    2    3    4    5    6    7    8\\nnums = [1,   1,   2,   3,   3,   4,   4,   8,   8]\\n\\nWe start with left = 0, right = 8 => mid = 0+(8-0)/2 = 4\\nNow, 4 is an even index which means the first repeating number should be at 4 and the next at 5. \\nBut nums[4] != nums[5]. So on the left half the pattern\\'s broken. \\n\\nNow, left = 0, right = 4 => mid = 0+(4-0)/2 = 2\\nNow again 2 is an even number so nums[2] should be equal to nums[3], but it is not. \\n\\nSo again, left = 0, right = 2 => mid = 0+(2-0)/2 = 1\\n1 is an odd number and nums[1] == nums[0]. So, we do l = mid+1 (Since the left half has the pattern). \\n\\nNow l = r = 2. \\nHence stop the search and return nums[l] = 2.\\n```\\nLet us look at another example : \\n                 \\n```\\n        0    1    2    3     4    5     6    \\nnums = [3,   3,   7,   7,   10,   11,   11]\\n\\nWe start with left = 0, right = 6 => mid = 0+(6-0)/2 = 3\\nNow, 3 is an odd index and nums[3] == nums[2]. So on the left half the pattern is followed. We move to the right half. \\n\\nNow, left = 4, right = 6 => mid = 4+(6-4)/2 = 5\\nNow 5 is an odd number so nums[5] should be equal to nums[4], but it is not. \\n\\nSo now, left = 4, right = 5 => mid = 4+(5-4)/2 = 4\\n4 is an even number but nums[4] != nums[5]. So, the pattern is not followed on the left side.\\n\\nNow l = r = 4. \\nHence stop the search and return nums[l] = 10.\\n```\\n\\n**Time Complexity :** O(logn); where n=length of the array\\n**Space Complexity :** O(1) ; no extra space is required. \\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n        int l=0, r=nums.size()-1, mid, num;\\n        \\n        while(l < r){\\n            mid = l+(r-l)/2;\\n            num = (mid%2 == 0) ? mid+1 : mid-1;\\n            if(nums[mid]==nums[num]) l = mid+1;\\n            else r = mid;\\n        }\\n        return nums[l];\\n    }\\n\\n};\\n``` \\n\\nIf the question was to solve the problem in O(n) time complexity; we could use bit-manipulation.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int xOR=0;  //a^a = 0. So all the elements repeating twice become \\'0\\' and we return the non-repeating element.\\n        for(int i=0;i<nums.size();i++) xOr ^= nums[i];\\n        \\n        return xOR;\\n    }\\n\\n};\\n```\\nIf you like my solution and explanation, **please UPVOTE!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n        0    1    2    3    4    5    6    7    8\\nnums = [1,   1,   2,   3,   3,   4,   4,   8,   8]\\n\\nWe start with left = 0, right = 8 => mid = 0+(8-0)/2 = 4\\nNow, 4 is an even index which means the first repeating number should be at 4 and the next at 5. \\nBut nums[4] != nums[5]. So on the left half the pattern\\'s broken. \\n\\nNow, left = 0, right = 4 => mid = 0+(4-0)/2 = 2\\nNow again 2 is an even number so nums[2] should be equal to nums[3], but it is not. \\n\\nSo again, left = 0, right = 2 => mid = 0+(2-0)/2 = 1\\n1 is an odd number and nums[1] == nums[0]. So, we do l = mid+1 (Since the left half has the pattern). \\n\\nNow l = r = 2. \\nHence stop the search and return nums[l] = 2.\\n```\n```\\n        0    1    2    3     4    5     6    \\nnums = [3,   3,   7,   7,   10,   11,   11]\\n\\nWe start with left = 0, right = 6 => mid = 0+(6-0)/2 = 3\\nNow, 3 is an odd index and nums[3] == nums[2]. So on the left half the pattern is followed. We move to the right half. \\n\\nNow, left = 4, right = 6 => mid = 4+(6-4)/2 = 5\\nNow 5 is an odd number so nums[5] should be equal to nums[4], but it is not. \\n\\nSo now, left = 4, right = 5 => mid = 4+(5-4)/2 = 4\\n4 is an even number but nums[4] != nums[5]. So, the pattern is not followed on the left side.\\n\\nNow l = r = 4. \\nHence stop the search and return nums[l] = 10.\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1) return nums[0];\\n        int l=0, r=nums.size()-1, mid, num;\\n        \\n        while(l < r){\\n            mid = l+(r-l)/2;\\n            num = (mid%2 == 0) ? mid+1 : mid-1;\\n            if(nums[mid]==nums[num]) l = mid+1;\\n            else r = mid;\\n        }\\n        return nums[l];\\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int xOR=0;  //a^a = 0. So all the elements repeating twice become \\'0\\' and we return the non-repeating element.\\n        for(int i=0;i<nums.size();i++) xOr ^= nums[i];\\n        \\n        return xOR;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628036,
                "title": "python-binary-search-o-logn-explained",
                "content": "If every element in the sorted array were to appear exactly twice, they would occur in pairs at indices `i`, `i+1` for all **even** `i`. \\n\\nEquivalently, `nums[i] = nums[i+1]` and `nums[i+1] != nums[i+2]` for all **even** `i`.\\n\\nWhen we insert the unique element into this list, the indices of all the pairs following it will be shifted by one, negating the above relationship. \\n\\nSo, for any **even** index `i`, we can compare `nums[i]` to `nums[i+1]`. \\n* If they are equal, the unique element must occur somewhere **after** index `i+1`\\n* If they aren\\'t equal, the unique element must occur somewhere **before** index `i+1`\\n\\nUsing this knowledge, we can use binary search to find the unique element.\\n\\nWe just have to make sure that our pivot index is always even, so we can use `mid = 2 * ((lo + hi) // 4)` instead of the usual `mid = (lo + hi) // 2`.\\n<hr>\\n\\n**Solution:**\\n\\nTime: `O(logn)`\\nSpace: `O(1)`\\n\\n```\\ndef singleNonDuplicate(self, nums: List[int]) -> int:\\n\\tlo, hi = 0, len(nums) - 1\\n\\twhile lo < hi:\\n\\t\\tmid = 2 * ((lo + hi) // 4)\\n\\t\\tif nums[mid] == nums[mid+1]:\\n\\t\\t\\tlo = mid+2\\n\\t\\telse:\\n\\t\\t\\thi = mid\\n\\treturn nums[lo]\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\ndef singleNonDuplicate(self, nums: List[int]) -> int:\\n\\tlo, hi = 0, len(nums) - 1\\n\\twhile lo < hi:\\n\\t\\tmid = 2 * ((lo + hi) // 4)\\n\\t\\tif nums[mid] == nums[mid+1]:\\n\\t\\t\\tlo = mid+2\\n\\t\\telse:\\n\\t\\t\\thi = mid\\n\\treturn nums[lo]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1587318,
                "title": "java-binary-search-beats-100-most-intutive-explanation-using-image",
                "content": "**Intution:** keep dividing your array in two halves and check in which half there are odd number of elements...that will be your required part.\\n\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/f7fc208d-13da-423c-8069-e50c7c810c0d_1637377156.442444.jpeg)\\n\\n\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        int l = 0;\\n        int h = nums.length-1;\\n        \\n        while(l<h){\\n            int mid = l+(h-l)/2;      // divide the array\\n            \\n            if(nums[mid]==nums[mid+1]) mid = mid-1;      //two same elements should be in same half\\n            \\n            if((mid-l+1)%2!=0) h = mid;            // checking the length of left half. If its is odd then update ur right pointer to mid\\n            \\n            else l = mid+1;    // else your right half will be odd then update your left pointer to mid+1\\n        }\\n        \\n        return nums[l];     //left pointer will have the answer at last\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        if(nums.length==1) return nums[0];\\n        int l = 0;\\n        int h = nums.length-1;\\n        \\n        while(l<h){\\n            int mid = l+(h-l)/2;      // divide the array\\n            \\n            if(nums[mid]==nums[mid+1]) mid = mid-1;      //two same elements should be in same half\\n            \\n            if((mid-l+1)%2!=0) h = mid;            // checking the length of left half. If its is odd then update ur right pointer to mid\\n            \\n            else l = mid+1;    // else your right half will be odd then update your left pointer to mid+1\\n        }\\n        \\n        return nums[l];     //left pointer will have the answer at last\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627786,
                "title": "c-o-log-n-time-o-1-space-simple-and-clean-use-xor-to-keep-track-of-odd-even-pair",
                "content": "**nums[mid] == nums[mid ^ 1]** for odd position compares with the previous number; for even position compares with the next number. The unique number must be at even position.\\n \\n```\\nint singleNonDuplicate(vector<int>& nums) {\\n\\tint start=0, end = nums.size()-1, mid;\\n\\twhile( start < end ) {\\n\\t\\tmid = start + (end-start)/2;\\n\\t\\tif( nums[mid] == nums[mid ^ 1] )\\n\\t\\t\\tstart = mid + 1;\\n\\t\\telse\\n\\t\\t\\tend = mid;\\n\\t}\\n\\treturn nums[start];\\n}\\n```\\n\\nIn case above one looks more complicated to you:\\n\\n```\\nint singleNonDuplicate(vector<int>& nums) {\\n\\tint left = 0, right = nums.size() - 1;\\n\\twhile(left < right){\\n\\t\\tint mid = (left + right)/2;\\n\\t\\tif((mid % 2 == 0 && nums[mid] == nums[mid + 1]) || (mid % 2 == 1 && nums[mid] == nums[mid - 1]))\\n\\t\\t\\tleft = mid + 1;\\n\\t\\telse\\n\\t\\t\\tright = mid;\\n\\t}\\n\\treturn nums[left];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint singleNonDuplicate(vector<int>& nums) {\\n\\tint start=0, end = nums.size()-1, mid;\\n\\twhile( start < end ) {\\n\\t\\tmid = start + (end-start)/2;\\n\\t\\tif( nums[mid] == nums[mid ^ 1] )\\n\\t\\t\\tstart = mid + 1;\\n\\t\\telse\\n\\t\\t\\tend = mid;\\n\\t}\\n\\treturn nums[start];\\n}\\n```\n```\\nint singleNonDuplicate(vector<int>& nums) {\\n\\tint left = 0, right = nums.size() - 1;\\n\\twhile(left < right){\\n\\t\\tint mid = (left + right)/2;\\n\\t\\tif((mid % 2 == 0 && nums[mid] == nums[mid + 1]) || (mid % 2 == 1 && nums[mid] == nums[mid - 1]))\\n\\t\\t\\tleft = mid + 1;\\n\\t\\telse\\n\\t\\t\\tright = mid;\\n\\t}\\n\\treturn nums[left];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100733,
                "title": "java-binary-search-with-detailed-explanation",
                "content": "Let's start with two simple observations.\\n\\n**Example 1**: An array with length ```2*4 + 1```\\n```left = 0```, ```right = 8```, ```mid = 4```.\\nIf the single element ```X``` is on the left hand side, ```nums[mid] == nums[mid-1]```: \\n```[1, 1, X, 2, 2(mid), 3, 3, 4, 4]```\\nIf the single element ```X``` is on the right hand side, ```nums[mid] == nums[mid+1]```: \\n```[1, 1, 2, 2, 3(mid), 3, X, 4, 4]```\\n\\n**Example 2**: An array with length ```2*3 + 1```\\n```left = 0```, ```right = 6```, ```mid = 3```.\\nIf the single element ```X``` is on the left hand side, ```nums[mid] == nums[mid+1]```: \\n```[1, 1, X, 2(mid), 2, 3, 3]```\\nIf the single element ```X``` is on the right hand side, ```nums[mid] == nums[mid-1]```: \\n```[1, 1, 2, 2(mid), 3, 3, X]```\\n\\nIn general, for an array with length ```2*n + 1```, if ```n``` is even, the behavior of ```mid``` will be the same as that in Example 1. Otherwise, it will be as in Example 2.\\n\\nBelow is the solution.\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n        \\n        int len = nums.length;\\n        int left = 0;\\n        int right = len - 1;\\n        \\n        while(left <= right && left < len && right >= 0){\\n            int mid = left + (right - left)/2;\\n            \\n            if((mid-1 >= 0 && nums[mid-1] == nums[mid]) || (mid + 1 < len && nums[mid+1] == nums[mid])){ // nums[mid] is not single\\n                int currLen = right - left; // actual length - 1                \\n                if((currLen/2) % 2 == 0){\\n                    if(nums[mid-1] == nums[mid]){\\n                        // The element is on the left hand side\\n                        right = mid - 2; // Skip mid-1 and mid as we know they are not single\\n                    }\\n                    else{\\n                        // The element is on the right hand side\\n                        left = mid + 2;\\n                    }\\n                }\\n                else{\\n                    if(nums[mid-1] == nums[mid]){\\n                        // The element is on the right hand side\\n                        left = mid + 1; // Skip mid\\n                    }\\n                    else{\\n                        // The element is on the left hand side\\n                        right = mid - 1;\\n                    }\\n                }\\n            }\\n            else return nums[mid];\\n        }\\n        \\n        return nums[left];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```2*4 + 1```\n```left = 0```\n```right = 8```\n```mid = 4```\n```X```\n```nums[mid] == nums[mid-1]```\n```[1, 1, X, 2, 2(mid), 3, 3, 4, 4]```\n```X```\n```nums[mid] == nums[mid+1]```\n```[1, 1, 2, 2, 3(mid), 3, X, 4, 4]```\n```2*3 + 1```\n```left = 0```\n```right = 6```\n```mid = 3```\n```X```\n```nums[mid] == nums[mid+1]```\n```[1, 1, X, 2(mid), 2, 3, 3]```\n```X```\n```nums[mid] == nums[mid-1]```\n```[1, 1, 2, 2(mid), 3, 3, X]```\n```2*n + 1```\n```n```\n```mid```\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n        \\n        int len = nums.length;\\n        int left = 0;\\n        int right = len - 1;\\n        \\n        while(left <= right && left < len && right >= 0){\\n            int mid = left + (right - left)/2;\\n            \\n            if((mid-1 >= 0 && nums[mid-1] == nums[mid]) || (mid + 1 < len && nums[mid+1] == nums[mid])){ // nums[mid] is not single\\n                int currLen = right - left; // actual length - 1                \\n                if((currLen/2) % 2 == 0){\\n                    if(nums[mid-1] == nums[mid]){\\n                        // The element is on the left hand side\\n                        right = mid - 2; // Skip mid-1 and mid as we know they are not single\\n                    }\\n                    else{\\n                        // The element is on the right hand side\\n                        left = mid + 2;\\n                    }\\n                }\\n                else{\\n                    if(nums[mid-1] == nums[mid]){\\n                        // The element is on the right hand side\\n                        left = mid + 1; // Skip mid\\n                    }\\n                    else{\\n                        // The element is on the left hand side\\n                        right = mid - 1;\\n                    }\\n                }\\n            }\\n            else return nums[mid];\\n        }\\n        \\n        return nums[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628111,
                "title": "c-solution-o-logn-with-detailed-explanation",
                "content": "```\\nWe use binary search to solve this.\\n\\nThe problem of using binary search is how to determine the conditions inside the while loop?\\n\\nWell this logic maynot come that intuitively but if u observe a few examples u will quickly get the idea.\\n\\nLet num=[1,1,2,3,3,4,4,8,8]\\n         0,1,2,3,4,5,6,7,8 <----indices\\n\\nLet us do our traditional binary search start and see what happens:-\\nl=0,r=nums.size()-1=8\\nm=4\\n\\n[1,1,2,3,3,4,4,8,8]\\n         ^\\n         |\\n         mid\\nNotice that once we hit the mid and remove its duplicate(if it doesnt have any that would be the answer)-> the answer will lie in the subarray \\nconstaining odd length (cuz everything will be paired up except for 1 thus odd length)\\n\\n[1,1,2, ,4,4,8,8]\\n\\\\_____/  \\\\______/\\n   |         |\\n odd        even \\n length     length\\n\\n Thus our answer is present in the odd length of the array.\\n\\n But one problem here  is how to find after the split whether its odd and even by making sure we stick to the complexity of o(logn).\\n\\n U initialize a bool variable and check if the r-mid is even or not.\\n[1,1,2,3,3,4,4,8,8]\\nFor this example 8-4=4 is even that mean ur answer cant lie in the right side of the array.\\nSo we can test our solution like this\\n\\nbool even_length=(r-m)%2==0\\nif(nums[m]==nums[m-1])\\n{\\n\\tif(even_length)\\n\\t\\tr=m-2;\\n\\telse \\n\\t\\tl=m+1;\\n}\\n\\ndid u understand? ->I am writing the code to suit for the above example \\n\\nNow what if nums[m]==nums[m+1]\\nnums=[1,1,4,4,5,5,6,7,7]\\n              ^\\n              |\\n              mid \\nHere r-m=even but wait...\\nm+1 has to be removed too \\nthus eventhough the right side show even due to the above property it has to odd cuz we subtract 1 element\\nThen just follow the same procedure\\n\\nif(nums[m]==nums[m+1])\\n{\\n\\tif(even_length)\\n\\t\\tl=m+2;\\n\\telse\\n\\t\\tr=m-1;\\n}\\n\\n\\nCode:-\\n\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int l=0,r=nums.size()-1;\\n        while(l<r)\\n        {\\n            int m=l+(r-l)/2;\\n            bool even_length=(r-m)%2==0;\\n            if(nums[m]==nums[m+1])\\n            {\\n                if(even_length)\\n                    l=m+2;\\n                else\\n                r=m-1;\\n            }\\n            else if(nums[m]==nums[m-1])\\n            {\\n                if(even_length)\\n                    r=m-2;\\n                else\\n                    l=m+1;\\n            }\\n            else\\n                return nums[m];\\n        }\\n        return nums[l];\\n    }\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nWe use binary search to solve this.\\n\\nThe problem of using binary search is how to determine the conditions inside the while loop?\\n\\nWell this logic maynot come that intuitively but if u observe a few examples u will quickly get the idea.\\n\\nLet num=[1,1,2,3,3,4,4,8,8]\\n         0,1,2,3,4,5,6,7,8 <----indices\\n\\nLet us do our traditional binary search start and see what happens:-\\nl=0,r=nums.size()-1=8\\nm=4\\n\\n[1,1,2,3,3,4,4,8,8]\\n         ^\\n         |\\n         mid\\nNotice that once we hit the mid and remove its duplicate(if it doesnt have any that would be the answer)-> the answer will lie in the subarray \\nconstaining odd length (cuz everything will be paired up except for 1 thus odd length)\\n\\n[1,1,2, ,4,4,8,8]\\n\\\\_____/  \\\\______/\\n   |         |\\n odd        even \\n length     length\\n\\n Thus our answer is present in the odd length of the array.\\n\\n But one problem here  is how to find after the split whether its odd and even by making sure we stick to the complexity of o(logn).\\n\\n U initialize a bool variable and check if the r-mid is even or not.\\n[1,1,2,3,3,4,4,8,8]\\nFor this example 8-4=4 is even that mean ur answer cant lie in the right side of the array.\\nSo we can test our solution like this\\n\\nbool even_length=(r-m)%2==0\\nif(nums[m]==nums[m-1])\\n{\\n\\tif(even_length)\\n\\t\\tr=m-2;\\n\\telse \\n\\t\\tl=m+1;\\n}\\n\\ndid u understand? ->I am writing the code to suit for the above example \\n\\nNow what if nums[m]==nums[m+1]\\nnums=[1,1,4,4,5,5,6,7,7]\\n              ^\\n              |\\n              mid \\nHere r-m=even but wait...\\nm+1 has to be removed too \\nthus eventhough the right side show even due to the above property it has to odd cuz we subtract 1 element\\nThen just follow the same procedure\\n\\nif(nums[m]==nums[m+1])\\n{\\n\\tif(even_length)\\n\\t\\tl=m+2;\\n\\telse\\n\\t\\tr=m-1;\\n}\\n\\n\\nCode:-\\n\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int l=0,r=nums.size()-1;\\n        while(l<r)\\n        {\\n            int m=l+(r-l)/2;\\n            bool even_length=(r-m)%2==0;\\n            if(nums[m]==nums[m+1])\\n            {\\n                if(even_length)\\n                    l=m+2;\\n                else\\n                r=m-1;\\n            }\\n            else if(nums[m]==nums[m-1])\\n            {\\n                if(even_length)\\n                    r=m-2;\\n                else\\n                    l=m+1;\\n            }\\n            else\\n                return nums[m];\\n        }\\n        return nums[l];\\n    }\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1587293,
                "title": "python-3-simple-approaches-with-explanation",
                "content": "### Approach 1: (Optimised) Brute Force\\n\\nThere are a few ways to brute force a solution. One way is to count the number of times each element appears in the array, and then return the value with a counter of 1.\\n\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        counts = defaultdict(int)\\n        for num in nums:\\n            counts[num] += 1\\n        for num, count in counts.items():\\n            if count == 1:\\n                return num\\n        return -1  # this will never be reached\\n\\t\\t# return Counter(nums).most_common()[-1][0]  # one-liner, but TC O(nlogn)\\n```\\n\\n**TC: O(2n) ~ O(n)**, since we loop through the array twice.\\n**SC: O(n)**, since we used a dictionary / Counter object.\\n\\nAnother way is to check if each element has been seen before in the array. This method is intrinsically highly optimised since we know that duplicate elements are adjacent to each other.\\n\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        val, seen = -1, True\\n        for num in nums:\\n            if val == num:\\n                seen = True\\n            elif seen:\\n                val = num\\n                seen = False\\n            else:\\n                return val\\n        return -1  # this will never be reached\\n```\\n\\n**TC: O(n)**, since we only loop through the array once.\\n**SC: O(1)**, since no additional data structures are used.\\n\\nWe can further optimise this method by abusing the adjacency of the duplicate elements: checking elements pairwise for equality.\\n\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        for i in range(0, len(nums)-1, 2):  # pairwise comparison\\n            if nums[i] != nums[i+1]:  # found the single element\\n                return nums[i]\\n        return nums[-1]  # the last element is the single element\\n```\\n\\n**TC: O(<img src=\"http://latex.codecogs.com/png.image?\\\\dpi{110}&space;\\\\frac{n}{2}\" title=\"\\\\frac{n}{2}\" />) ~ O(n)**, since we loop through the array two-by-two.\\n**SC: O(1)**; no additional data structures used.\\n\\n---\\n\\n### Approach 2: (One-liner) Reducing Operations\\n\\nSince we know that every element repeats twice except for the single element, we can try to apply a function where all duplicate elements cancel each other out, leaving only the single element.\\n\\nOne such operation is to take the summation of all elements, but have each element alternate between positive and negative absolute values. This guarantees that each pair of duplicate elements has one positive and one neagtive absolute value, thereby cancelling each other out when added together.\\n\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in range(len(nums)):\\n            if i%2:  # alternate between +ve and -ve\\n                result -= nums[i]\\n            else:\\n                result += nums[i]\\n        return result\\n\\t\\t# return sum((-1)**i*v for i,v in enumerate(nums))  # one-liner\\n```\\n\\nAnother such operation: bitwise-XOR. Bitwise-XOR works because `a XOR 0 = a` and `a XOR a = 0` for all real numbers `a`, therefore, chaining bitwise-XORs on `nums` will cancel out all duplicates and leave us with the single element.\\n\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        result = 0\\n        for num in nums:\\n            result ^= num\\n        return result\\n        # return reduce(xor, nums)  # one-liner\\n```\\n\\n**TC: O(n)**, since we loop through all elements in the array.\\n**SC: O(1)**, as discussed previously.\\n\\nWe can further optimise these approaches by looping through the array pairwise as per Approach 1.\\n\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        result = nums[0]\\n        for i in range(1, len(nums), 2):\\n            result += nums[i+1]-nums[i]\\n        return result\\n\\t\\t# return nums[0] + sum(nums[i+1]-nums[i] for i in range(1, len(nums), 2))  # one-liner\\n```\\n\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        result = nums[0]\\n        for i in range(1, len(nums), 2):\\n            result ^= nums[i]^nums[i+1]\\n        return result\\n        # return reduce(lambda x,i: x^nums[i]^nums[i+1], range(1, len(nums), 2), nums[0])  # one-liner\\n```\\n\\n**TC: O(<img src=\"http://latex.codecogs.com/png.image?\\\\dpi{110}&space;\\\\frac{n}{2}\" title=\"\\\\frac{n}{2}\" />) ~ O(n)**, as discussed previously.\\n**SC: O(1)**, as discussed previously.\\n\\n---\\n\\n### Approach 3: Binary Search\\n\\nSince the array is sorted and the requirement is for the TC to be O(<img src=\"http://latex.codecogs.com/svg.image?log(n)\" title=\"log(n)\" />), it should be clear that binary search is to be used. But what exactly is the condition to check for? Consider the following example:\\n\\n```text\\nnums = [ 1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8 ]\\nfirst:   ^     ^     ^     ^  ^     ^     ^     ^\\nindex:   0     2     4     6  7     9     11    13\\n```\\n\\nIt becomes clear that the index of the first of each duplicate element shows us where the single element is: **if the index is even, the single element lies in the upper end of the search space; but if the index is odd, the single element lies in the lower end of the search space**.\\n\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        lo, hi = 0, len(nums)-1\\n        while lo < hi:\\n            mid = lo+(hi-lo)//2\\n            if nums[mid] == nums[mid-1]:  # duplicate found\\n                if mid%2:       # target > mid\\n                    lo = mid+1  # exclude second index mid; mid+1\\n                else:           # target < mid\\n                    hi = mid-2  # exclude first index mid-1; mid-1-1\\n            elif nums[mid] == nums[mid+1]:  # duplicate found\\n                if mid%2:       # target < mid\\n                    hi = mid-1  # exclude first index mid; mid-1\\n                else:           # target > mid\\n                    lo = mid+2  # exclude second index mid+1; mid+1+1\\n            else:  # no duplicate found, target == mid\\n                return nums[mid]\\n        return nums[lo]\\n```\\n\\nA shorter but more unintuitive way: checking pairwise at `mid` via `mid^1`. `mid^1` returns the next odd number if `mid` is even, and returns the previous even number if `mid` is odd (you can try it for yourself). By checking pairwise, if the numbers are the same, it is equivalent to the first index being even. Likewise, the numbers not being equal is equivalent to the first index being odd.\\n\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        lo, hi = 0, len(nums)-2  # hi starts from an even index so that hi^1 gives the next odd number\\n        while lo <= hi:\\n            mid = lo+(hi-lo)//2\\n            if nums[mid] == nums[mid^1]:\\n                lo = mid+1\\n            else:\\n                hi = mid-1\\n        return nums[lo]\\n```\\n\\n**TC: O(<img src=\"http://latex.codecogs.com/svg.image?log(n)\" title=\"log(n)\" />)**, classic binary search time complexity.\\n**SC: O(1)**, as discussed previously.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        counts = defaultdict(int)\\n        for num in nums:\\n            counts[num] += 1\\n        for num, count in counts.items():\\n            if count == 1:\\n                return num\\n        return -1  # this will never be reached\\n\\t\\t# return Counter(nums).most_common()[-1][0]  # one-liner, but TC O(nlogn)\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        val, seen = -1, True\\n        for num in nums:\\n            if val == num:\\n                seen = True\\n            elif seen:\\n                val = num\\n                seen = False\\n            else:\\n                return val\\n        return -1  # this will never be reached\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        for i in range(0, len(nums)-1, 2):  # pairwise comparison\\n            if nums[i] != nums[i+1]:  # found the single element\\n                return nums[i]\\n        return nums[-1]  # the last element is the single element\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in range(len(nums)):\\n            if i%2:  # alternate between +ve and -ve\\n                result -= nums[i]\\n            else:\\n                result += nums[i]\\n        return result\\n\\t\\t# return sum((-1)**i*v for i,v in enumerate(nums))  # one-liner\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        result = 0\\n        for num in nums:\\n            result ^= num\\n        return result\\n        # return reduce(xor, nums)  # one-liner\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        result = nums[0]\\n        for i in range(1, len(nums), 2):\\n            result += nums[i+1]-nums[i]\\n        return result\\n\\t\\t# return nums[0] + sum(nums[i+1]-nums[i] for i in range(1, len(nums), 2))  # one-liner\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        result = nums[0]\\n        for i in range(1, len(nums), 2):\\n            result ^= nums[i]^nums[i+1]\\n        return result\\n        # return reduce(lambda x,i: x^nums[i]^nums[i+1], range(1, len(nums), 2), nums[0])  # one-liner\\n```\n```text\\nnums = [ 1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8 ]\\nfirst:   ^     ^     ^     ^  ^     ^     ^     ^\\nindex:   0     2     4     6  7     9     11    13\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        lo, hi = 0, len(nums)-1\\n        while lo < hi:\\n            mid = lo+(hi-lo)//2\\n            if nums[mid] == nums[mid-1]:  # duplicate found\\n                if mid%2:       # target > mid\\n                    lo = mid+1  # exclude second index mid; mid+1\\n                else:           # target < mid\\n                    hi = mid-2  # exclude first index mid-1; mid-1-1\\n            elif nums[mid] == nums[mid+1]:  # duplicate found\\n                if mid%2:       # target < mid\\n                    hi = mid-1  # exclude first index mid; mid-1\\n                else:           # target > mid\\n                    lo = mid+2  # exclude second index mid+1; mid+1+1\\n            else:  # no duplicate found, target == mid\\n                return nums[mid]\\n        return nums[lo]\\n```\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        lo, hi = 0, len(nums)-2  # hi starts from an even index so that hi^1 gives the next odd number\\n        while lo <= hi:\\n            mid = lo+(hi-lo)//2\\n            if nums[mid] == nums[mid^1]:\\n                lo = mid+1\\n            else:\\n                hi = mid-1\\n        return nums[lo]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587155,
                "title": "daily-leetcoding-challenge-november-day-20",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-element-in-a-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n**Approach 3:** Binary Search on Evens Indexes Only\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-element-in-a-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3212132,
                "title": "easy-binary-search-explanation-o-logn-o-1",
                "content": "# Intuition\\nLet\\'s look at an example array `[3,3,4,4,5,6,6,7,7]`. We look at indicies `0, 2, 4, 6, 8` and check if the number is equal to the number on its right.\\n```\\n  index:  0  1  2  3  4  5  6  7  8\\n   nums:  3  3  4  4  5  6  6  7  7\\nmatches:  T     T     F     F     F\\n```\\nAt the singleton number, the numbers stop matching with the number to its right. We can do binary serach to find this position where the numbers stop matching.\\n\\n# Complexity\\n- Time complexity: Binary search on an array of size `n` takes O(logn).\\n\\n- Space complexity: Constant space is needed for binary search, so O(1).\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums) // 2\\n        ans = -1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            idx = mid * 2\\n            if idx + 1 >= len(nums) or nums[idx] != nums[idx + 1]:\\n                r = mid - 1\\n                ans = nums[idx]\\n            else:\\n                l = mid + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n  index:  0  1  2  3  4  5  6  7  8\\n   nums:  3  3  4  4  5  6  6  7  7\\nmatches:  T     T     F     F     F\\n```\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums) // 2\\n        ans = -1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            idx = mid * 2\\n            if idx + 1 >= len(nums) or nums[idx] != nums[idx + 1]:\\n                r = mid - 1\\n                ans = nums[idx]\\n            else:\\n                l = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100763,
                "title": "java-code-by-using-binary-search-o-log-n",
                "content": "public int singleNonDuplicate(int[] nums) {\\n        int low = 0;\\n        int high = nums.length-1;\\n        \\n        while(low < high) {\\n            int mid = low + (high - low)/2;\\n            if(nums[mid] != nums[mid+1] && nums[mid] != nums[mid-1])\\n                return nums[mid];\\n            else if(nums[mid] == nums[mid+1] && mid % 2 == 0)\\n                low = mid+1;\\n            else if(nums[mid] == nums[mid-1] && mid % 2 == 1)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        return nums[low];\\n    }",
                "solutionTags": [],
                "code": "public int singleNonDuplicate(int[] nums) {\\n        int low = 0;\\n        int high = nums.length-1;\\n        \\n        while(low < high) {\\n            int mid = low + (high - low)/2;\\n            if(nums[mid] != nums[mid+1] && nums[mid] != nums[mid-1])\\n                return nums[mid];\\n            else if(nums[mid] == nums[mid+1] && mid % 2 == 0)\\n                low = mid+1;\\n            else if(nums[mid] == nums[mid-1] && mid % 2 == 1)\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n        }\\n        return nums[low];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3189848,
                "title": "best-c-5-solution-binary-search-xor-hash-table-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Array(Two Nested Loop). Brute Force Approach.\\n2. Solved using Array + Hash Table(Unordered map).\\n3. Solved using Linear Search.\\n4. Solved using Bit Manipulation(xor).\\n5. Solved using Binary Search. Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\\n    Array(nums).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : this will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            int count = 0;\\n            for(int j=0; j<n; j++){\\n                if(nums[i] == nums[j]) count++;\\n            }\\n            if(count == 1) return nums[i];\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Here we are doing N iteration which creates the time complexity. Where N is the size\\n    of the array(nums).\\n\\n    Space Complexity : O(N), Hash Table(unordered map) space.\\n\\n    Solved using Array + Hash Table(unordered map).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        for(auto num : nums){\\n            map[num]++;\\n        }\\n        for(auto num : map){\\n            if(num.second == 1) return num.first;\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\\n    Array(nums).\\n                    \\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved using Linear Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n-1; i+=2){\\n            if(nums[i] != nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return nums[n-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\\n    Array(nums).\\n                    \\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved using Bit manupulation(xor).\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int Xor = 0;\\n        for(auto num : nums){\\n            Xor ^= num;\\n        }\\n        return Xor;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved using Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 5 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int low = 0, high = nums.size()-1;\\n        while(low < high){\\n            int mid = (low + high) >> 1;\\n            int num = (mid%2==0) ? mid+1 : mid-1;\\n            if(nums[mid] == nums[num]) low = mid+1;\\n            else high = mid;\\n        }\\n        return nums[low];\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), Here Two nested loop creates the time complexity. Where N is the size of the\\n    Array(nums).\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : this will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            int count = 0;\\n            for(int j=0; j<n; j++){\\n                if(nums[i] == nums[j]) count++;\\n            }\\n            if(count == 1) return nums[i];\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Here we are doing N iteration which creates the time complexity. Where N is the size\\n    of the array(nums).\\n\\n    Space Complexity : O(N), Hash Table(unordered map) space.\\n\\n    Solved using Array + Hash Table(unordered map).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        for(auto num : nums){\\n            map[num]++;\\n        }\\n        for(auto num : map){\\n            if(num.second == 1) return num.first;\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\\n    Array(nums).\\n                    \\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved using Linear Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n-1; i+=2){\\n            if(nums[i] != nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return nums[n-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), because in the worst case we traverse the <= N element. Where N is the size of the\\n    Array(nums).\\n                    \\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved using Bit manupulation(xor).\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int Xor = 0;\\n        for(auto num : nums){\\n            Xor ^= num;\\n        }\\n        return Xor;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved using Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 5 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int low = 0, high = nums.size()-1;\\n        while(low < high){\\n            int mid = (low + high) >> 1;\\n            int num = (mid%2==0) ? mid+1 : mid-1;\\n            if(nums[mid] == nums[num]) low = mid+1;\\n            else high = mid;\\n        }\\n        return nums[low];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244459,
                "title": "c-solution-with-step-by-step-explanation",
                "content": "**Attacking the problem**\\nYou start with B.S. as the question is tagged as B.S. and then think that the array is sorted so B.S. it is.\\n**Stuck!! How do I know if I go left or right from the middle :(**\\nOkay jokes apart this is a really good problem on B.S. and let us carefully analyse what we are given.\\nThe array is sorted and as only one unique element and other elements exist as pairs. \\nDIY take few example arrays and write the indices above all the elements. \\n**Observe** \\nGot something?\\nNo?\\n**Observe again and look at the indices of pairs on the left of the unique element and on the right of the unique element**\\n\\nWe see that for every case on the left of the unique element the pairs exist as (even,odd), (even,odd),......(even)\\nwhere singular (even) is the index of the unique element. \\n(It can be easily concluded that the index of the unique element will always be even.)\\nAfter the unique element the pairs on the right exist as (odd,even),(odd,even),........\\nSo are we still stuck on where to go, left or right? \\nBy seeing this pattern we have found two distinct search spaces and we can move towards the unique element by checking in which search space we are in.\\nIf we are in the left search space we go right.\\nIf we are in the right search space we go left.\\nI leave the code for your reference below. \\n\\n```\\nint singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums[0];\\n        int l = 0,r=nums.size()-1;\\n        while(l<=r){\\n            int m = l + (r-l)/2;\\n            if(m%2){\\n\\t\\t\\t\\t// (even odd) i.e. we are on the left side of unique element--> go right\\n                if(nums[m-1]==nums[m])\\n                    l = m+1;\\n\\t\\t\\t\\t// (even odd) pair violated, happens on the right side of unique element--> go left\\n                else{\\n                    r = m-1;\\n                }\\n            }else{\\n\\t\\t\\t\\t// (even odd) i.e. we are on the left side of unique element--> go right\\n                if(nums[m]==nums[m+1]){\\n                    l = m+1;\\n\\t\\t\\t\\t// (even odd) pair violated, happens on the right side of unique element--> go left\\n                }else{\\n                    r = m-1;\\n                }\\n            }\\n        }\\n        return nums[l];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)\\n            return nums[0];\\n        int l = 0,r=nums.size()-1;\\n        while(l<=r){\\n            int m = l + (r-l)/2;\\n            if(m%2){\\n\\t\\t\\t\\t// (even odd) i.e. we are on the left side of unique element--> go right\\n                if(nums[m-1]==nums[m])\\n                    l = m+1;\\n\\t\\t\\t\\t// (even odd) pair violated, happens on the right side of unique element--> go left\\n                else{\\n                    r = m-1;\\n                }\\n            }else{\\n\\t\\t\\t\\t// (even odd) i.e. we are on the left side of unique element--> go right\\n                if(nums[m]==nums[m+1]){\\n                    l = m+1;\\n\\t\\t\\t\\t// (even odd) pair violated, happens on the right side of unique element--> go left\\n                }else{\\n                    r = m-1;\\n                }\\n            }\\n        }\\n        return nums[l];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100765,
                "title": "java-binary-search-o-lgn-clear-easy-explained-no-tricks",
                "content": "First, the code:\\n```java\\npublic class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n        int lo = 0, hi = n;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if ((mid % 2 == 0 && mid + 1 < n && nums[mid] == nums[mid + 1]) ||\\n                (mid % 2 == 1 && mid - 1 >= 0 && nums[mid] == nums[mid - 1]))\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return nums[lo];\\n    }\\n}\\n```\\nThe logic behind this is very easy: for each `mid`, we try to find understand whether the single number is on the **left** half. The `if` header tests that *`nums[mid]` is not single and neither is anything on its left*.\\n* if `mid` is even, then there are `2m` numbers on the left of `mid`. For the statement of *`nums[mid]` is not single and neither is anything on its left* to hold, we need the `2m` numbers to the left of `mid` to be `m` pairs, and also `nums[mid]` be in a pair with `nums[mid + 1]`. Indeed, we only have to make sure in this case that `nums[mid], nums[mid + 1]` is a pair. You can prove by contradiction that as long as this holds, the sole single number can\\'t be on the left of `mid`. Now that the statement of *`nums[mid]` is not single and neither is anything on its left* is proven, we can just go to the right half.\\n* if `mid` is odd, then to prove *`nums[mid]` is not single and neither is anything on its left*, we only need to prove that `nums[mid - 1], nums[mid]` is a pair. `mid - 1` is even, and as long as `nums[mid - 1], nums[mid - 1 + 1]` forms a pair, we can actually use the argument of previous paragraph to prove that no entry to the left of `mid` is single. And neither is `mid` itself obviously. With *`nums[mid]` is not single and neither is anything on its left* proven, we can again to the right half.\\n* If *`nums[mid]` is not single and neither is anything on its left* not provable, then go to left half since the single number is there.\\n\\nI am not entirely sure the above explanation suffices, but I do hope it helps.",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n        int lo = 0, hi = n;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if ((mid % 2 == 0 && mid + 1 < n && nums[mid] == nums[mid + 1]) ||\\n                (mid % 2 == 1 && mid - 1 >= 0 && nums[mid] == nums[mid - 1]))\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return nums[lo];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212430,
                "title": "multiple-approaches-py",
                "content": "<h3>UPVOTE IF YOU LIKE SOLN</h3>\\n\\n# Approach\\n<h4>Brute Force -> Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ --> $$O(log n)$$\\n# Codes\\n```\\n//Brute Force OP\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        for(int p=0;p<nums.size()-1;p+=2){\\n            if(nums[p]!=nums[p+1]){\\n                return nums[p];\\n            }\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\\n```\\n#Using XOR\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        x=0\\n        for i in nums:\\n            x=x^i\\n        return x\\n```\\n```\\n#One-Liner Using Set\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        return ((2*sum(set(nums)))-sum(nums))\\n\\n```\\n```\\n#One_liner Xor\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        return reduce(lambda m,n:m^n,nums)\\n```\\n```\\n//Another One\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        map<int,int>mp;\\n        int n=nums.size();\\n        for(int p=0;p<n;p++) mp[nums[p]]++;\\n        for(auto i:mp){\\n            if(i.second==1) return i.first;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n```\\n//Final One\\n//Binary Search Optimised\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        l,r=0,len(nums)//2\\n        ans=-1\\n        while l<=r:\\n            mid=(l+r)//2\\n            i=mid*2\\n            if i+1>=len(nums) or nums[i]!=nums[i+1]:\\n                r=mid-1\\n                ans=nums[i]\\n            else:\\n                l=mid+1\\n        return ans\\n```\\n\\n![](https://assets.leetcode.com/users/images/59cc0319-232b-4d39-9d5c-48a5a458b05f_1652453667.350621.jpeg)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n//Brute Force OP\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        for(int p=0;p<nums.size()-1;p+=2){\\n            if(nums[p]!=nums[p+1]){\\n                return nums[p];\\n            }\\n        }\\n        return nums[nums.size()-1];\\n    }\\n};\\n```\n```\\n#Using XOR\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        x=0\\n        for i in nums:\\n            x=x^i\\n        return x\\n```\n```\\n#One-Liner Using Set\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        return ((2*sum(set(nums)))-sum(nums))\\n\\n```\n```\\n#One_liner Xor\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        return reduce(lambda m,n:m^n,nums)\\n```\n```\\n//Another One\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        map<int,int>mp;\\n        int n=nums.size();\\n        for(int p=0;p<n;p++) mp[nums[p]]++;\\n        for(auto i:mp){\\n            if(i.second==1) return i.first;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\n//Final One\\n//Binary Search Optimised\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        l,r=0,len(nums)//2\\n        ans=-1\\n        while l<=r:\\n            mid=(l+r)//2\\n            i=mid*2\\n            if i+1>=len(nums) or nums[i]!=nums[i+1]:\\n                r=mid-1\\n                ans=nums[i]\\n            else:\\n                l=mid+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587818,
                "title": "java-easy-intuitive-sol-full-explanation-100-faster-bit-manipulation-binary-search",
                "content": "Hello everyone, I hope you all are doing great.\\n**Note: If you found this post helpful then please do upvote!**\\n\\nIn this post i\\'ll explain 4 approach from worst to best time complexity, and i\\'ll also i\\'ll try to explain the intution behind this.\\nBefore we proceed to various approaches let\\'s keep this thing in mind.\\nAs You can see in the image below all the second element in the pair before the target or ans index is at odd index and after the target they shifted to one index and are at even indexes.\\n![image](https://assets.leetcode.com/users/images/35047cf4-8b40-4ff2-99a4-53bf6d2a6904_1637394383.7849278.png)\\n\\n___\\n**Approach 1 : Linear Search  - TC O(n) - SC O(1)**\\n\\nIn this approach we simply traverse through every pair from the nums array and keep checking if the current element is equal to the prev one, if not we will simply return the prev element. \\n\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n\\t//traverse through arrau and check if prev is equal to curr ,if not return prev\\n        for(int i=1;i<nums.length;i+=2){\\n         if(nums[i]!=nums[i-1]){\\n             return nums[i-1];\\n         }   \\n        }\\n\\t\\t//if didn\\'t find means last element is single, here\\'s the example [1,1,2,2,3]\\n        return nums[nums.length-1];\\n    }\\n}\\n```\\n**Time Complexity: O(n)\\nSpace Complexity : O(1)**\\n___\\n\\n**Approach 2 : Bit manupulation - TC O(n) - SC (1)**\\nHere we use the fact that  performing **XOR** with two same numbers give us **zero** and doing XOR with zero and other number will give us that number itself.\\nhere\\'s the example \\n2 - 0010\\n2 - 0010\\n3 - 0011\\n\\nSo 2^2^3 = 3\\n\\nSo we simply iterate through the loop and do XOR and the final ans will be the required ans\\n```\\nclass Solution {\\n\\tpublic int singleNonDuplicate(int[] nums) {\\n\\t\\tint ans = 0;\\n        for(int num:nums){\\n            ans^=num;\\n        }\\n        return ans;\\n\\t}\\n}\\n```\\n**Time Complexity: O(n)\\nSpace Complexity : O(1)**\\n___\\n**Approach 3 : Bit Manupulation Improved - TC O(n) - SC O(1)**\\n\\nSince we already know that every odd index represent second element of the pair which means at every odd index the **XOR** value will be **zero**, and if we found a situation where XOR is not zero at odd index which means last element was single element and that is the ans.\\nwith this approach we will not iterate every time till last index and we can return when we find odd one.\\n\\n```\\nclass Solution {\\n\\tpublic int singleNonDuplicate(int[] nums) {\\n\\t\\tint ans = 0;\\n        int prev = 0;\\n        for(int i=0;i<nums.length;i++){\\n            prev=ans;\\n            ans^=nums[i];\\n            if((i&1)==1 && ans!=0){ //here we are checking if the index is odd and ans is not zero\\n                return prev;\\n            }\\n        }\\n        return ans;\\n\\t}\\n}\\n```\\n**Time Complexity: O(n)\\nSpace Complexity : O(1)**\\n___\\n\\n**Approach 4 : Binary Search - TC O(logn) - SC O(1)**\\nSince the array is already sorted we can apply binary search to find the single element.\\nBefore proceeding to this solution recall the above rule that i\\'ve explained with the image.\\n\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        //the idea is to find mid element and if mid is single return it\\n        //else mid is first element of the pair and \\n            //is at even pos means ans will be to it\\'s right\\n            //else ans will be it\\'s left\\n        //else mid is second element and \\n            //is at odd pos means ans will be towards right\\n        //else ans will be towards left\\n        \\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        \\n        int lo = 0,hi = nums.length-1;\\n        while(lo<=hi){\\n            int mid = lo +(hi-lo)/2;\\n            \\n            \\n            //means mid is second element of the pair\\n            if(mid-1>=0 &&(nums[mid]==nums[mid-1])){ \\n                //check if mid is at odd pos\\n                if((mid&1)==1){\\n                    lo = mid+1;\\n                }else{\\n                    hi = mid;\\n                }\\n                \\n            }else if(mid+1<nums.length &&(nums[mid]==nums[mid+1])){ //means mid is first element of the pair\\n                //check if mid is at even pos\\n                if((mid&1)==0){\\n                    lo = mid+2;\\n                }else{\\n                    hi = mid;\\n                }\\n                \\n            }else{ //means mid is single\\n                return nums[mid];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Time Complexity: O(logn)\\nSpace Complexity : O(1)**\\n\\n\\uD83D\\uDCCC  **Please Upvote \\u2705 if you found this post useful for you!**",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n\\t//traverse through arrau and check if prev is equal to curr ,if not return prev\\n        for(int i=1;i<nums.length;i+=2){\\n         if(nums[i]!=nums[i-1]){\\n             return nums[i-1];\\n         }   \\n        }\\n\\t\\t//if didn\\'t find means last element is single, here\\'s the example [1,1,2,2,3]\\n        return nums[nums.length-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\tpublic int singleNonDuplicate(int[] nums) {\\n\\t\\tint ans = 0;\\n        for(int num:nums){\\n            ans^=num;\\n        }\\n        return ans;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n\\tpublic int singleNonDuplicate(int[] nums) {\\n\\t\\tint ans = 0;\\n        int prev = 0;\\n        for(int i=0;i<nums.length;i++){\\n            prev=ans;\\n            ans^=nums[i];\\n            if((i&1)==1 && ans!=0){ //here we are checking if the index is odd and ans is not zero\\n                return prev;\\n            }\\n        }\\n        return ans;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        //the idea is to find mid element and if mid is single return it\\n        //else mid is first element of the pair and \\n            //is at even pos means ans will be to it\\'s right\\n            //else ans will be it\\'s left\\n        //else mid is second element and \\n            //is at odd pos means ans will be towards right\\n        //else ans will be towards left\\n        \\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        \\n        int lo = 0,hi = nums.length-1;\\n        while(lo<=hi){\\n            int mid = lo +(hi-lo)/2;\\n            \\n            \\n            //means mid is second element of the pair\\n            if(mid-1>=0 &&(nums[mid]==nums[mid-1])){ \\n                //check if mid is at odd pos\\n                if((mid&1)==1){\\n                    lo = mid+1;\\n                }else{\\n                    hi = mid;\\n                }\\n                \\n            }else if(mid+1<nums.length &&(nums[mid]==nums[mid+1])){ //means mid is first element of the pair\\n                //check if mid is at even pos\\n                if((mid&1)==0){\\n                    lo = mid+2;\\n                }else{\\n                    hi = mid;\\n                }\\n                \\n            }else{ //means mid is single\\n                return nums[mid];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212508,
                "title": "simplest-solution-binary-search-c-python3",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n# Intuition \\nIntitution is very simple we have to find the which appears once.\\nWe can see in array it follows a pattern all the duplicate pairs are at **Even and Odd positions** this pattern is not satisfied when there is a single element in the array.\\nFor example : [1,1,2,3,3,4,4,8,8]\\nIn this array `1` is at 0 and 1 index. This pattern follows for all pairs.\\n\\n    How we can implement Binary Search here.\\n    1. Take left and right pointers . \\n        `start` points to start of list. `end` points to end of the list.\\n    2. Find `mid`.\\n        If mid is `even`, then it\\'s duplicate should be in next index.\\n        or if `mid` is `odd`, then it\\'s duplicate  should be in previous index.\\n        For checking `mid` I am using Bit manipulation `mid^1` it means if `mid` is `even` it check at `odd` position and if it is `odd` it will check at `even` position.\\n        check these two conditions, \\n        if any of the conditions is satisfied,\\n        then pattern is not missed, \\n        so check in next half of the array. i.e, `start` = mid + 1\\n        if condition is not satisfied, then the pattern is missed.\\n        so, single number must be before mid.\\n        so, update `end` to mid-1.\\n    3. At last return the nums[start]\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int start=0, end=nums.size()-2;\\n        while(end>=start){\\n            int mid = (end+start)/2;\\n            if(nums[mid] == nums[mid^1])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return nums[start];\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        start = 0\\n        end = len(nums)-2\\n        while end>=start:\\n            mid = (end+start)//2\\n            if nums[mid] == nums[mid^1]:\\n                start = mid+1\\n            else:\\n                end = mid-1\\n        return nums[start]\\n```\\n```\\n                            Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int start=0, end=nums.size()-2;\\n        while(end>=start){\\n            int mid = (end+start)/2;\\n            if(nums[mid] == nums[mid^1])\\n                start = mid+1;\\n            else\\n                end = mid-1;\\n        }\\n        return nums[start];\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        start = 0\\n        end = len(nums)-2\\n        while end>=start:\\n            mid = (end+start)//2\\n            if nums[mid] == nums[mid^1]:\\n                start = mid+1\\n            else:\\n                end = mid-1\\n        return nums[start]\\n```\n```\\n                            Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959109,
                "title": "python-beats-100",
                "content": "Use binary search. It mid is even, then check nums[mid] and nums[mid + 1]. If they are equal, then the target must be on the right half. Similarly for mid is odd, check nums[mid] and nums[mid - 1].\\n```\\nclass Solution(object):\\n    def singleNonDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        left, right = 0, len(nums) - 1\\n        while left + 1 < right:\\n            mid = (left + right) // 2\\n            if mid % 2 == 1:\\n                if nums[mid] == nums[mid - 1]:\\n                    left = mid\\n                else:\\n                    right = mid\\n            else:\\n                if nums[mid] == nums[mid + 1]:\\n                    left = mid\\n                else:\\n                    right = mid\\n        #print(left, right)\\n        if left % 2 == 0:\\n            return nums[left]\\n        return nums[right]\\n```\\nPlease upvote if you find it helpful\\uFF01",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def singleNonDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        left, right = 0, len(nums) - 1\\n        while left + 1 < right:\\n            mid = (left + right) // 2\\n            if mid % 2 == 1:\\n                if nums[mid] == nums[mid - 1]:\\n                    left = mid\\n                else:\\n                    right = mid\\n            else:\\n                if nums[mid] == nums[mid + 1]:\\n                    left = mid\\n                else:\\n                    right = mid\\n        #print(left, right)\\n        if left % 2 == 0:\\n            return nums[left]\\n        return nums[right]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212124,
                "title": "java-c-python-log-n-beginners-can-understand-easy-intuitive",
                "content": "**Upvote if you like the Soltution and Explanation :)**\\n\\n# Intuition \\n- Element in pairs, even index, odd index, so find mid and check if it\\'s at correct position or not.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- I already handled the corner cases separately.\\n\\n- if nums[mid] is same as previous and it is at odd position then it\\'s at correct position and if nums[mid] is same as it\\'s next and it is at even position then it\\'s at correct position so there must be our answer is in right of the mid otherwise it must be in left.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code JAVA\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n        int l = 0;\\n        int r = n-1;\\n        \\n        if(n==1)\\n            return nums[0];\\n        if(nums[0] != nums[1])\\n            return nums[0];\\n        if(nums[n-1] != nums[n-2])\\n            return nums[n-1];\\n        \\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            \\n            if(mid>0 && mid < n-1){\\n                if(nums[mid] > nums[mid-1] && nums[mid] < nums[mid+1])\\n                    return nums[mid];\\n                else if((nums[mid] == nums[mid-1] && mid%2==1) || (nums[mid] == nums[mid+1] && mid%2==0))\\n                    l = mid+1;\\n                else \\n                    r = mid -1;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/dc898633-03c1-4fc3-a7c9-b3dd7be2ec32_1676944210.6929636.jpeg)\\n# Code PYHTON 3\\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l = 0\\n        r = n - 1\\n        \\n        if n == 1:\\n            return nums[0]\\n        if nums[0] != nums[1]:\\n            return nums[0]\\n        if nums[n - 1] != nums[n - 2]:\\n            return nums[n - 1]\\n        \\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            \\n            if mid > 0 and mid < n - 1:\\n                if nums[mid] > nums[mid - 1] and nums[mid] < nums[mid + 1]:\\n                    return nums[mid]\\n                elif (nums[mid] == nums[mid - 1] and mid % 2 == 1) or (nums[mid] == nums[mid + 1] and mid % 2 == 0):\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n                    \\n        return 0\\n\\n```\\n\\n# Code C++\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        int l = 0;\\n        int r = n - 1;\\n        \\n        if (n == 1)\\n            return nums[0];\\n        if (nums[0] != nums[1])\\n            return nums[0];\\n        if (nums[n - 1] != nums[n - 2])\\n            return nums[n - 1];\\n        \\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            \\n            if (mid > 0 && mid < n - 1) {\\n                if (nums[mid] > nums[mid - 1] && nums[mid] < nums[mid + 1])\\n                    return nums[mid];\\n                else if ((nums[mid] == nums[mid - 1] && mid % 2 == 1) || (nums[mid] == nums[mid + 1] && mid % 2 == 0))\\n                    l = mid + 1;\\n                else\\n                    r = mid - 1;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n        int l = 0;\\n        int r = n-1;\\n        \\n        if(n==1)\\n            return nums[0];\\n        if(nums[0] != nums[1])\\n            return nums[0];\\n        if(nums[n-1] != nums[n-2])\\n            return nums[n-1];\\n        \\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            \\n            if(mid>0 && mid < n-1){\\n                if(nums[mid] > nums[mid-1] && nums[mid] < nums[mid+1])\\n                    return nums[mid];\\n                else if((nums[mid] == nums[mid-1] && mid%2==1) || (nums[mid] == nums[mid+1] && mid%2==0))\\n                    l = mid+1;\\n                else \\n                    r = mid -1;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l = 0\\n        r = n - 1\\n        \\n        if n == 1:\\n            return nums[0]\\n        if nums[0] != nums[1]:\\n            return nums[0]\\n        if nums[n - 1] != nums[n - 2]:\\n            return nums[n - 1]\\n        \\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            \\n            if mid > 0 and mid < n - 1:\\n                if nums[mid] > nums[mid - 1] and nums[mid] < nums[mid + 1]:\\n                    return nums[mid]\\n                elif (nums[mid] == nums[mid - 1] and mid % 2 == 1) or (nums[mid] == nums[mid + 1] and mid % 2 == 0):\\n                    l = mid + 1\\n                else:\\n                    r = mid - 1\\n                    \\n        return 0\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        int l = 0;\\n        int r = n - 1;\\n        \\n        if (n == 1)\\n            return nums[0];\\n        if (nums[0] != nums[1])\\n            return nums[0];\\n        if (nums[n - 1] != nums[n - 2])\\n            return nums[n - 1];\\n        \\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            \\n            if (mid > 0 && mid < n - 1) {\\n                if (nums[mid] > nums[mid - 1] && nums[mid] < nums[mid + 1])\\n                    return nums[mid];\\n                else if ((nums[mid] == nums[mid - 1] && mid % 2 == 1) || (nums[mid] == nums[mid + 1] && mid % 2 == 0))\\n                    l = mid + 1;\\n                else\\n                    r = mid - 1;\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627935,
                "title": "java-super-elegent-solution-log-n-runtime-o-1-extra-space-bit-trick-detailed-explanation",
                "content": "Idea behind the solution:\\n\\n1.  If the current index in the binary search is `I` (0 index based), the we can decide the next search space based on:\\n\\ta. If `I` is even, and `nums[I] == nums[I + 1]`, then size of subarray `[0...I-1]` (left side) is even (since the element count is `I`), so left side does not contain the single occurance element. Hence we need to check in `[I + 1, ..., N]` subarray (right side of `I`)\\n\\tb. If `I` is odd, and `nums[I] == nums[I - 1]`, then size of subarray `[0...I-2]` (left side) is even (since the element count is `I - 1`, and `I-1` is even since `I` is odd), so left side does not contain the single occurance element. Hence we need to check in `[I + 1, ..., N]` subarray (right side of `I`) </br>\\n\\tNote: How can you implement the check operation. Remember the xor operation, and if you xor any number with 1, then it flips the LSB (Least significant bit)\\nEx. 1) `100^1=101` [i.e `4^1=5`, flips the first bit from right side] </br> 2) `101^1=100` [i.e `5^1=4`, again flips the first bit from right side]\\nSo, if  `I` is even, to find the next element we do `I^1`\\n\\tand if `I` is odd, to find the previous element we do `I^1`\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int l = 0;\\n        int h = nums.length - 1;\\n        while (l < h) {\\n            int m = (l + h) / 2;\\n            if (nums[m] == nums[m ^ 1]) {\\n                l = m + 1;\\n            } else {\\n                h = m;\\n            }\\n        }\\n        return nums[h];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int l = 0;\\n        int h = nums.length - 1;\\n        while (l < h) {\\n            int m = (l + h) / 2;\\n            if (nums[m] == nums[m ^ 1]) {\\n                l = m + 1;\\n            } else {\\n                h = m;\\n            }\\n        }\\n        return nums[h];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587644,
                "title": "python-short-binary-search-explained",
                "content": "Straightforward way is to just iterate over all elements in `O(n)`. There is smarter binary search solution. For example we have `aa bb cc dd ee ff gg h ii jj kk`. Let us find middle element, but shift it by one if number of element in the left part is odd: we always consider even number of elements in the left part. Then if `nums[mid] == nums[mid-1]` it means, that in the left part all elements are paired and we need to look in the right part. In the opposite case it means, that we need to look into the left half.\\n\\n#### Complexity\\nTime complexity is `O(log n)`, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        beg, end = 0, len(nums) - 1\\n\\n        while end > beg + 1:\\n            mid = (beg + end)//2\\n            if (mid - beg) % 2 == 0: mid += 1  \\n            if nums[mid] == nums[mid - 1]: \\n                beg = mid + 1\\n            else:\\n                end = mid \\n\\n        return nums[beg]\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def singleNonDuplicate(self, nums):\\n        beg, end = 0, len(nums) - 1\\n\\n        while end > beg + 1:\\n            mid = (beg + end)//2\\n            if (mid - beg) % 2 == 0: mid += 1  \\n            if nums[mid] == nums[mid - 1]: \\n                beg = mid + 1\\n            else:\\n                end = mid \\n\\n        return nums[beg]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100766,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size(), left = 0, right = n - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (mid % 2 == 0) {\\n                if (nums[mid] == nums[mid-1]) right = mid - 2;\\n                else if (nums[mid] == nums[mid+1]) left = mid + 2;\\n                else return nums[mid];\\n            }\\n            else {\\n                if (nums[mid] == nums[mid-1]) left = mid + 1;\\n                else if (nums[mid] == nums[mid+1]) right = mid - 1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size(), left = 0, right = n - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (mid % 2 == 0) {\\n                if (nums[mid] == nums[mid-1]) right = mid - 2;\\n                else if (nums[mid] == nums[mid+1]) left = mid + 2;\\n                else return nums[mid];\\n            }\\n            else {\\n                if (nums[mid] == nums[mid-1]) left = mid + 1;\\n                else if (nums[mid] == nums[mid+1]) right = mid - 1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587535,
                "title": "python-binary-search-o-logn-time-o-1-space-simple-solution-with-explanation",
                "content": "# Logic\\n1. Since we don\\'t have any target element to search for so we can\\'t directly decide which part of array we need to look for single element.\\n2. Since we know that every element has a duplicate except one so we can commit that the length of array will always be odd.\\n3. Now, based on the above logic we can decide which part of array to look for. We can simply check which part of array([start:mid+1] OR [mid+1:end]) has odd number of elements.\\n\\n**NOTE:** In this solution, I\\'m always updating the mid to be on the second index of every duplicate and then I count. You may do the vice-versa also by keeping the mid on first index of every duplicate and update start and end accordingly.\\n\\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            # Check if mid is the single number\\n            if start < mid < end and nums[mid-1] < nums[mid] < nums[mid+1]:\\n                return nums[mid]\\n            else:\\n                # Else goto the second index of nums[mid](duplicate) if already not there.\\n                if mid < end and nums[mid] == nums[mid+1]:\\n                    mid += 1\\n            \\n            if (mid - start + 1) % 2:\\n                end = mid - 2\\n            else:\\n                start = mid + 1\\n        return nums[start]\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = start + ((end - start) // 2)\\n            # Check if mid is the single number\\n            if start < mid < end and nums[mid-1] < nums[mid] < nums[mid+1]:\\n                return nums[mid]\\n            else:\\n                # Else goto the second index of nums[mid](duplicate) if already not there.\\n                if mid < end and nums[mid] == nums[mid+1]:\\n                    mid += 1\\n            \\n            if (mid - start + 1) % 2:\\n                end = mid - 2\\n            else:\\n                start = mid + 1\\n        return nums[start]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627787,
                "title": "java-binary-search-o-log-n-time-and-o-1-memory",
                "content": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int N = nums.length;\\n        if(N == 1)\\n            return nums[0];\\n        \\n        int left = 0;\\n        int right = N - 1;\\n        int mid;\\n        \\n        while(left < right){\\n            mid = left + ((right  - left) >> 1);\\n            if(nums[mid] == nums[mid + 1]){\\n                // from index mid to (N - 1) - if even then check left interval\\n                if(((N - mid) & 1) == 0)\\n                    right = mid - 1;\\n                else\\n                    left = mid + 2;\\n            }else if(nums[mid] == nums[mid - 1]){\\n                // from index (mid - 1) to (N - 1) - if even then check left interval\\n                if(((N - mid + 1) & 1) == 0)\\n                    right = mid - 2;\\n                else\\n                    left = mid + 1;\\n            }else\\n                return nums[mid];\\n        }\\n        \\n        return nums[left];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int N = nums.length;\\n        if(N == 1)\\n            return nums[0];\\n        \\n        int left = 0;\\n        int right = N - 1;\\n        int mid;\\n        \\n        while(left < right){\\n            mid = left + ((right  - left) >> 1);\\n            if(nums[mid] == nums[mid + 1]){\\n                // from index mid to (N - 1) - if even then check left interval\\n                if(((N - mid) & 1) == 0)\\n                    right = mid - 1;\\n                else\\n                    left = mid + 2;\\n            }else if(nums[mid] == nums[mid - 1]){\\n                // from index (mid - 1) to (N - 1) - if even then check left interval\\n                if(((N - mid + 1) & 1) == 0)\\n                    right = mid - 2;\\n                else\\n                    left = mid + 1;\\n            }else\\n                return nums[mid];\\n        }\\n        \\n        return nums[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748046,
                "title": "binary-search-time-complexity-space-complexity-explanation",
                "content": "Time Complexity - Binary search takes O(logN base 2) time.\\nSpace Complexity - Space taken is O(1).\\nExplanation - To solve this problem, we use a modified version of binary search.\\nWe know that mid is our target element, if the element is not equal to either its next or previous element (since array is sorted array).\\nIf our mid isn\\'t the target element, we need to search the left/right part of the array.\\n\\nIn an array where every element appears twice (1, 1, 2, 2) will always have an even number of elements.\\nIn such an array, any element at an odd index is equal to the element at its previous index.\\nHowever, an array with 1 non-repeated element will always have an odd number of elements.\\nIn such an array, we can easily identify where the non-repeated element lies based upon whether our mid element satisfies this property.\\n\\nSatisfying either (mid is odd and nums[mid] == nums[prev]) or (mid is even and nums[mid] == nums[next]) means that all elements to the left of mid are in pairs - so we should search to its right.\\n*Example:*\\n[1, 1, 2, 2, 3, 4, 4]\\n 0  1  2  3  4  5  6\\n \\nmid = 3, nums[mid] = 2\\nmid doesn\\'t hold our target element since arr[mid] = arr[prev], thus we need to move left/right.\\nWe know mid is an odd index, and this is a result of having only elements which are in pairs to the left of mid.\\nHence we should search to the right of mid for our target element.\\n \\n[1, 1, 2, 2, 3]\\n 0  1  2  3  4 \\n  \\n mid = 2, nums[mid] = 2\\n mid doesn\\'t hold our target element since arr[mid] = arr[next], thus we need to move left/right.\\n We know mid is an even index, and this is a result of having only elements which are in pairs to the left of arr[next].\\n Hence we should search to the right of mid for our target element.\\n \\n ```\\n class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums){\\n        int n = nums.size(), start = 0, end = n - 1, mid, next, prev;\\n        if(n == 1) return nums[0];\\n        while(start <= end){\\n            mid = start + (end - start) / 2;\\n            next = (mid + 1) % n;\\n            prev = (mid + n - 1) % n;\\n            if(nums[mid] != nums[prev] && nums[mid] != nums[next]) return nums[mid];\\n            else if((mid % 2 && nums[mid] == nums[prev]) || (!(mid % 2) && nums[mid] == nums[next])) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nKindly upvote if you found the solution helpful :)\\n**For more such explanations of LeetCode problems along with their C++ solutions:**\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums){\\n        int n = nums.size(), start = 0, end = n - 1, mid, next, prev;\\n        if(n == 1) return nums[0];\\n        while(start <= end){\\n            mid = start + (end - start) / 2;\\n            next = (mid + 1) % n;\\n            prev = (mid + n - 1) % n;\\n            if(nums[mid] != nums[prev] && nums[mid] != nums[next]) return nums[mid];\\n            else if((mid % 2 && nums[mid] == nums[prev]) || (!(mid % 2) && nums[mid] == nums[next])) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380497,
                "title": "c-simple-and-clean-solutions-o-logn-with-explanation",
                "content": "**O(logn) Binary Search Solution:**\\nExplanation:\\nFor a regular sorted array where each element is double, be have the first in an even index and the second in an odd index.\\nIf somewhere in the middle we have an element that appears only once, this pattern will be broken, and from there on the first element will be in an odd index and the second one in an even index.\\nSo, we makr a regular binary search. If the pattern is still holding in \"mid\", then we continue searching in the right side.\\nIf it\\'s already broken, we continue the search on the left side.\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int lo = 0, hi = nums.size()-1, mid;\\n        while (lo < hi) {\\n            mid = (lo + hi) / 2;\\n            if ((mid % 2 && nums[mid - 1] == nums[mid]) || (!(mid % 2) && nums[mid] == nums[mid + 1])) lo = mid + 1;\\n            else hi = mid;\\n        }\\n        return nums[lo];\\n    }\\n};\\n```\\n**O(n) Bitwise Solution:**\\nA number XOR itself is always 0.\\nA number XOR 0 always stays the number.\\nSo if we just XOR the entire array, we will be left with the element that appears only once.\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int res = nums[0];\\n        for (int i=1; i<nums.size(); i++)\\n            res ^= nums[i];\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int lo = 0, hi = nums.size()-1, mid;\\n        while (lo < hi) {\\n            mid = (lo + hi) / 2;\\n            if ((mid % 2 && nums[mid - 1] == nums[mid]) || (!(mid % 2) && nums[mid] == nums[mid + 1])) lo = mid + 1;\\n            else hi = mid;\\n        }\\n        return nums[lo];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int res = nums[0];\\n        for (int i=1; i<nums.size(); i++)\\n            res ^= nums[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212575,
                "title": "easy-in-c-binary-search-21st-feb-2023",
                "content": "*A good solution here would work even if the elements were not sorted, but just kept in pairs  and that is because the searching criterium we will use is not related to their own ordering, but to the fact that numbers to the left of the unique element will have the format nums[k] == nums[k + 1] with k being an even index and the ones to the right of it will have the same with k being an odd index.*\\n\\n*First of all, we will declare a couple of support variables:*\\n\\n*lmt as the name implies will be the upper limit of our search, set to be the very last index (nums.size() - 1);\\nmid, the middle element of our binary search.\\nWe will then proceeed to loop with a few more variables:*\\n\\n*l and r are the two pointers to the left and right interval we will be binary searching - initially set to be 0 and lmt, respectively;\\nprev and nxt will be the values we will consider for the elements around the one pointed by mid.\\nIn our loop, running as long as l <= r, we will then:*\\n\\n*compute mid, as the average between l and r;\\ncompute prev so that is equal to the previous element if mid is not on the first element or nums[mid] - 1 otherwise;\\ncompute nxt so that is equal to the previous element if mid is not on the first element or nums[mid] + 1 otherwise - and, yes: I found delight in the elegance of having an expression moving the - 1 / + 1 part inside or outside the square brackets;\\ntime to go for the actual binary search and we will deal with 3 cases:\\nif nums[mid] is different from both prev and nxt, we know we have a match, so we can just return nums[mid];\\nif nums[mid] is different from the previous element with an odd value of mid or from the next one with an even value of mid, it means we were looking too much to the right, so we will lower r to be mid - 1 in the next iteration (we might also have written the condition here as nums[mid] != nums[mid + (mid & 1 ? -1 : 1)], which was my first version, before storing prev and nxt for convenience);\\notherwise, it means we were looking too much to the left, so we will adjust l to be mid + 1.\\nI am not sure we will ever hit exit the loop and execute what is next, but just to make the compiler happy about the signature of our function, we will then just in case return nums[mid] and be done with it :)*\\n\\n**The code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        // support variables\\n        int lmt = nums.size() - 1, mid;\\n        // binary search\\n        for (int l = 0, r = lmt, prev, nxt; l <= r;) {\\n            // updating loop variables\\n            mid = (l + r) >> 1;\\n            prev = mid ? nums[mid - 1] : nums[mid] - 1;\\n            nxt = mid != lmt ? nums[mid + 1] : nums[mid] + 1;\\n            // checking the element pointed by mid:\\n            // match\\n            if (nums[mid] != prev && nums[mid] != nxt) return nums[mid];\\n            // too high\\n            else if (nums[mid] != (mid & 1 ? prev : nxt)) r = mid - 1;\\n            // too low\\n            else l = mid + 1;\\n        }\\n        return nums[mid];\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/f30cc85c-5d8c-435c-a8f9-c0ccb4548997_1676951964.5447822.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        // support variables\\n        int lmt = nums.size() - 1, mid;\\n        // binary search\\n        for (int l = 0, r = lmt, prev, nxt; l <= r;) {\\n            // updating loop variables\\n            mid = (l + r) >> 1;\\n            prev = mid ? nums[mid - 1] : nums[mid] - 1;\\n            nxt = mid != lmt ? nums[mid + 1] : nums[mid] + 1;\\n            // checking the element pointed by mid:\\n            // match\\n            if (nums[mid] != prev && nums[mid] != nxt) return nums[mid];\\n            // too high\\n            else if (nums[mid] != (mid & 1 ? prev : nxt)) r = mid - 1;\\n            // too low\\n            else l = mid + 1;\\n        }\\n        return nums[mid];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212234,
                "title": "c-faster-than-85-hashing-very-easy-code-clean-code",
                "content": "\\n\\n# Code\\n# PLEASE DO UPVOTE!!!!!\\n```\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n      unordered_map<int,int>mpp;\\n      for(auto i:nums) mpp[i]++;\\n      \\n      for(auto it:mpp)\\n        if(it.second==1) return it.first;\\n        \\n      return -1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n      unordered_map<int,int>mpp;\\n      for(auto i:nums) mpp[i]++;\\n      \\n      for(auto it:mpp)\\n        if(it.second==1) return it.first;\\n        \\n      return -1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774021,
                "title": "easy-c-o-log-n-o-1-soln",
                "content": "for (mid % 2 == 0) cases              \\n    0 1 2 3 4 5 6 7 8 -> index             \\n    1 1 2 2 **3** 5 5 7 7 - ON MID        \\n\\t1 1 **3** 5 5 7 7 9 9 - ON LEFT       \\n\\t1 1 2 2 3 3 **5** 7 7 - ON RIGHT    \\n\\t\\nFor (mid % 2 != 0) cases \\n0 1 2 3 4 5 6 -> index\\n1 1 2 2 **3** 5 5 - ON RIGHT\\n1 1 **3** 5 5 7 7 - ON LEFT\\n\\n\\n```\\nint singleNonDuplicate(vector<int>& v) \\n    {\\n        if(v.size() == 1)// if only one element is present\\n            return v[0];\\n        int low = 0;\\n        int high = v.size() - 1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if(mid % 2 == 0)\\n            {\\n                if(low == high) //if element is on the left most side , in that case, v[mid - 1] is not possible\\n                {    \\n                    return v[mid];\\n                }\\n                else if(v[mid] == v[mid - 1])\\n                {\\n                    high = mid - 2;\\n                }\\n                else if(v[mid] == v[mid + 1])\\n                {\\n                    low = mid + 2;\\n                }\\n                else\\n                {\\n                    return v[mid];\\n                }\\n            }\\n            else\\n            {\\n                if(v[mid] == v[mid - 1])\\n                {\\n                    low = mid + 1;\\n                }\\n                else if(v[mid] == v[mid + 1])\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint singleNonDuplicate(vector<int>& v) \\n    {\\n        if(v.size() == 1)// if only one element is present\\n            return v[0];\\n        int low = 0;\\n        int high = v.size() - 1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if(mid % 2 == 0)\\n            {\\n                if(low == high) //if element is on the left most side , in that case, v[mid - 1] is not possible\\n                {    \\n                    return v[mid];\\n                }\\n                else if(v[mid] == v[mid - 1])\\n                {\\n                    high = mid - 2;\\n                }\\n                else if(v[mid] == v[mid + 1])\\n                {\\n                    low = mid + 2;\\n                }\\n                else\\n                {\\n                    return v[mid];\\n                }\\n            }\\n            else\\n            {\\n                if(v[mid] == v[mid - 1])\\n                {\\n                    low = mid + 1;\\n                }\\n                else if(v[mid] == v[mid + 1])\\n                {\\n                    high = mid - 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 627989,
                "title": "python-o-lg-n-by-binary-search-85-w-visualization",
                "content": "Python O(lg n) by binary search\\n\\n---\\n\\nHint:\\n\\nGroup each numbers in pairs, and launch binary search to locate the first index of mis-matched pair.\\n\\n---\\n\\n**Illustration and Visualization**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1589277233.png)\\n\\n---\\n\\n**Implementation** by binary search:\\n\\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        left, right = 0, size // 2\\n        \\n        while left < right:\\n            \\n            pair_index = left + ( right - left ) // 2\\n            \\n            if nums[2*pair_index] != nums[2*pair_index+1]:\\n                # If current pair is mis-matched\\n                # then go left-half to find the first pair of mis-match\\n                right = pair_index\\n            \\n            else:\\n                # If current pair is with the same number appeared twice\\n                # then go right-half to find the first pair of mis-match\\n                left = pair_index + 1\\n        \\n        # when the while loop terminates, left = right = the first pair index of mis-match\\n        return nums[2*left]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        \\n        left, right = 0, size // 2\\n        \\n        while left < right:\\n            \\n            pair_index = left + ( right - left ) // 2\\n            \\n            if nums[2*pair_index] != nums[2*pair_index+1]:\\n                # If current pair is mis-matched\\n                # then go left-half to find the first pair of mis-match\\n                right = pair_index\\n            \\n            else:\\n                # If current pair is with the same number appeared twice\\n                # then go right-half to find the first pair of mis-match\\n                left = pair_index + 1\\n        \\n        # when the while loop terminates, left = right = the first pair index of mis-match\\n        return nums[2*left]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213337,
                "title": "multiple-javascript-solutions-brute-force-o-n-o-1-binary-search-o-logn-o-1-xor",
                "content": "**Feel free to ask Q\\'s...**\\n*#happytohelpu*\\n\\n***Do upvote if you find this solution useful. Happy Coding!***\\n\\n**Solution 1 : Brute Force (with XOR)**\\nTime Complexity : O(n)\\nSpace Complexity : O(1)\\n\\n```\\n\\nconst singleNonDuplicate = nums => nums.reduce((a, b) => a ^ b); // XOR to get the single value\\n\\n```\\n\\n\\n**Solution 2 : Brute Force**\\nTime Complexity : O(n)\\nSpace Complexity : O(1) \\n\\n```\\n\\nconst singleNonDuplicate = nums => {\\n    //Compare consecutive numbers and increment by 2 in each iteration\\n    for (let i = 0; i < nums.length - 1; i += 2) {\\n        if (nums[i] != nums[i + 1]) {\\n            return nums[i];\\n        }\\n    }\\n    return nums[nums.length - 1]; // The last element is the only single element.\\n}\\n\\n```\\n\\n**Solution 3 : Binary Search**\\nTime Complexity : O(log(n))\\nSpace Complexity : O(1) \\n\\n```\\n\\nconst singleNonDuplicate = (nums, left = 0, right = nums.length - 1) => {\\n\\n    while (left < right) {\\n        let mid = left + (right - left) / 2;\\n        if (nums[mid] == nums[mid + 1]) mid = mid - 1;\\n        if ((mid - left + 1) % 2 != 0) right = mid;\\n        else left = mid + 1;\\n    }\\n    return nums[left];\\n};\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Bit Manipulation",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n\\nconst singleNonDuplicate = nums => nums.reduce((a, b) => a ^ b); // XOR to get the single value\\n\\n```\n```\\n\\nconst singleNonDuplicate = nums => {\\n    //Compare consecutive numbers and increment by 2 in each iteration\\n    for (let i = 0; i < nums.length - 1; i += 2) {\\n        if (nums[i] != nums[i + 1]) {\\n            return nums[i];\\n        }\\n    }\\n    return nums[nums.length - 1]; // The last element is the only single element.\\n}\\n\\n```\n```\\n\\nconst singleNonDuplicate = (nums, left = 0, right = nums.length - 1) => {\\n\\n    while (left < right) {\\n        let mid = left + (right - left) / 2;\\n        if (nums[mid] == nums[mid + 1]) mid = mid - 1;\\n        if ((mid - left + 1) % 2 != 0) right = mid;\\n        else left = mid + 1;\\n    }\\n    return nums[left];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3212366,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=UayPePcTQIY&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=21) if you are interested.\\n\\n---\\n\\n**Suggested Problems**\\n\\n- https://leetcode.com/problems/binary-search/\\n- https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\\n- https://leetcode.com/problems/find-peak-element/\\n- https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/\\n\\n**Approach: Binary Search**\\n\\nSee [Binary Search](https://leetcodethehardway.com/tutorials/basic-topics/binary-search) for the tutorial.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        // init possible boundary\\n        int n = nums.size(), l = 0, r = n - 1;\\n        while (l < r) {\\n            // get the middle one\\n            // for even number of elements, take the lower one\\n            int m = l + (r - l) / 2;\\n            // handle case like [3,3,7,7,10,11,11]\\n             m -= m & 1;\\n            // exclude m\\n            if (nums[m] == nums[m + 1]) l = m + 2;\\n            // include m\\n            else r = m;\\n        }\\n        return nums[l];\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = 0, n - 1\\n        while l < r:\\n            m = (l + r) // 2\\n            if m & 1:\\n                m -= 1\\n            if nums[m] == nums[m + 1]:\\n                l = m + 2\\n            else:\\n                r = m\\n        return nums[l]\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        // init possible boundary\\n        int n = nums.size(), l = 0, r = n - 1;\\n        while (l < r) {\\n            // get the middle one\\n            // for even number of elements, take the lower one\\n            int m = l + (r - l) / 2;\\n            // handle case like [3,3,7,7,10,11,11]\\n             m -= m & 1;\\n            // exclude m\\n            if (nums[m] == nums[m + 1]) l = m + 2;\\n            // include m\\n            else r = m;\\n        }\\n        return nums[l];\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = 0, n - 1\\n        while l < r:\\n            m = (l + r) // 2\\n            if m & 1:\\n                m -= 1\\n            if nums[m] == nums[m + 1]:\\n                l = m + 2\\n            else:\\n                r = m\\n        return nums[l]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212922,
                "title": "hashmap-bitwise-xor-easy-to-understand-java-2-solutions",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Approach 1**: Bit manupulation - TC O(n) - SC (1)\\nHere we use the fact that performing XOR with two same numbers give us zero and doing XOR with zero and other number will give us that number itself.\\nhere\\'s the example\\n2 - 0010\\n2 - 0010\\n3 - 0011\\n\\nSo 2^2^3 = 3\\n\\nSo we simply iterate through the loop and do XOR and the final ans will be the required ans\\n**Approach 2**:HashMap\\nWe use an HashMap to make a frequency table to note number of occurrences of the elements.\\nThen we use an Entry Set to iterate and return the element with the single occurrence.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            ans^=nums[i];\\n        }\\n    return ans;\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        HashMap<Integer,Integer> hs= new HashMap<>();\\n        for(int i:nums)\\n        {\\n            hs.put(i,hs.getOrDefault(i,0)+1);\\n        }\\n        System.out.println(hs);\\n        for(Map.Entry<Integer,Integer> mp:hs.entrySet())\\n        {\\n            if(mp.getValue()==1)\\n            return mp.getKey();\\n        }\\n    return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            ans^=nums[i];\\n        }\\n    return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        HashMap<Integer,Integer> hs= new HashMap<>();\\n        for(int i:nums)\\n        {\\n            hs.put(i,hs.getOrDefault(i,0)+1);\\n        }\\n        System.out.println(hs);\\n        for(Map.Entry<Integer,Integer> mp:hs.entrySet())\\n        {\\n            if(mp.getValue()==1)\\n            return mp.getKey();\\n        }\\n    return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212859,
                "title": "java-easy-explained-two-approach",
                "content": "\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\nSo, Here we go what about the problem think carefully The first solution for this problem that get accepted. what i did i just run a for loop with starting index of 1 and check for its previous one and with incremental value is +2 here we go. \\n1. if it get match then we move ahead other wise it is our element that is single. \\n2. consider one of the edge case that is last index what if its last index is that element that nothing to worry about if we did no found any element during this loop that simple mean it is last element and we will return the last element. \\n\\n# Code in Java \\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n       \\n       for(int i=1; i<nums.length; i+=2){\\n           if(nums[i]!=nums[i-1]){\\n               return nums[i-1];\\n           }\\n       }\\n       return nums[nums.length-1];\\n    }\\n}\\n```\\nso if you can see in this code that exactly what it did. \\n\\n# About it complexity :- sorry to say but it is not required complexity even if it get accepted so what? \\n- Time complexity: $$O(n)$$\\n\\n# Approach 2\\n Here All we need to modify the solution and as given in question it is sorted array and what it mean the simple strike that comes in mind is ```binary search``` all we need to apply binary search so lets discuss the another problem with like how I can apply ? \\nyus exactly that the way like in normal binary search for deciding the left and right pointer we have condition to check what here there is nothing like that. \\uD83D\\uDE12\\n\\nAlright after thinking and analyzing some of the patterns here simple look. \\n1. there are some basic pattern like first number of pair is present in even index and the another its partner present on the right mean odd index so \\n2. suppose if there is no single element thsi pattern will always follow till the end. \\n3. but here is a catch this pattern will get disturbed when single element comes into the picture. \\n4. so at that exact time we will get to know that yeah there is pattern mismatch and rather then setting left we will set right to mid. \\n\\n# More Explain \\n- Alright here we go for little more explanation \\n- Here is input nums = ``[1,1,2,3,3,4,4,8,8]``\\n- look closely every first element is on even index and another one is on odd position \\n\\n![mac-looking.gif](https://assets.leetcode.com/users/images/1b0f0939-dbe6-4ab7-b5a2-bb6fce66dbb5_1676956185.3208497.gif)\\n\\n- So here is approach if any how we will encounter an element of mid and if it is and even index then it have next same in odd mean next place (mid+1) odd side\\n- and if we encounter any odd mid element its partner will present on mid-1;(even side)\\n- and if in any case these conditions are not matching what it mean simply that mean pattern get disturbed in between and then we have to set the right to middle \\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n       \\n       int l = 0; int r=nums.length-1;\\n\\n       while(l<r){\\n           // simple check for the condition\\n           int mid = (r+l)/2;\\n\\n            if(mid%2==0 && nums[mid+1]==nums[mid]|| mid%2!=0 && nums[mid-1]==nums[mid]){\\n                l = mid+1;\\n            }else{\\n                r = mid;\\n            }\\n\\n       }\\n\\n       return nums[l];\\n\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# :> Thanks for visiting my Solution. \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n       \\n       for(int i=1; i<nums.length; i+=2){\\n           if(nums[i]!=nums[i-1]){\\n               return nums[i-1];\\n           }\\n       }\\n       return nums[nums.length-1];\\n    }\\n}\\n```\n```binary search```\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n       \\n       int l = 0; int r=nums.length-1;\\n\\n       while(l<r){\\n           // simple check for the condition\\n           int mid = (r+l)/2;\\n\\n            if(mid%2==0 && nums[mid+1]==nums[mid]|| mid%2!=0 && nums[mid-1]==nums[mid]){\\n                l = mid+1;\\n            }else{\\n                r = mid;\\n            }\\n\\n       }\\n\\n       return nums[l];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212672,
                "title": "python3-two-approaches",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Using xor approach and binary search we can solve this.**\\n\\n# Approach 1: XOR 170ms\\n<!-- Describe your approach to solving the problem. -->\\n- traverse in array linearly and xor every element.\\n- which ever element is not repeted it\\'s xor will not be canclled out.\\n- return found xor.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        def helper():\\n            xor = 0\\n            for i in nums:\\n                xor ^= i\\n            return xor\\n        return helper()\\n```\\n---\\n\\n# Approach 2: Binary search 180ms\\n<!-- Describe your approach to solving the problem. -->\\n- here if we explore problem then we can see if we have even length of array then no element will be singlton and every even index will have next element same as it.\\n- but if we insert any simgleton element between repeted element(not in between pair) then we can see that if even index element is not having same element as next then singleton must be in left side.\\n- if that\\'s not the case then singleton is not inserted in left side because we\\'re having behavior like even length array and no singleton is present in it, so to search in left side is not in our favour.\\n- so singleton must be in right side.\\n- where we find right < left there, we stop.\\n- return nums[left].\\n\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        def helper():\\n            left, right = 0, len(nums) - 1\\n            while left < right:\\n                middle = (left + right) // 2\\n                if middle % 2 == 1:\\n                    middle -= 1\\n                if nums[middle] != nums[middle+1]:\\n                    right = middle - 1\\n                else:\\n                    left = middle + 2\\n            return nums[left]\\n        return helper()\\n```\\n---\\n# Please like and comment below.\\n# (\\uD83D\\uDC4D\\u2256\\u203F\\u203F\\u2256)\\uD83D\\uDC4D \\uD83D\\uDC4D(\\u2256\\u203F\\u203F\\u2256\\uD83D\\uDC4D)",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        def helper():\\n            xor = 0\\n            for i in nums:\\n                xor ^= i\\n            return xor\\n        return helper()\\n```\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        def helper():\\n            left, right = 0, len(nums) - 1\\n            while left < right:\\n                middle = (left + right) // 2\\n                if middle % 2 == 1:\\n                    middle -= 1\\n                if nums[middle] != nums[middle+1]:\\n                    right = middle - 1\\n                else:\\n                    left = middle + 2\\n            return nums[left]\\n        return helper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319640,
                "title": "simple-c-code-approach-discussed-tc-o-logn-sc-o-1-binary-search",
                "content": "![image](https://assets.leetcode.com/users/images/3fd1b723-c888-4af7-9e8e-8d09f071871e_1658591320.434945.jpeg)\\n\\n\\n```\\n\\n// Please upvote if it helps :)\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int e = nums.size();\\n        // Checking the boundary first\\n        if(e == 1){\\n            return nums[0];\\n        }\\n        \\n        if(nums[0] != nums[1]){\\n            return nums[0];\\n        }\\n        \\n        if(nums[e-1] != nums[e-2]){\\n            return nums[e-1];\\n        }\\n        \\n        int s = 0;\\n        int mid = s + (e - s) / 2;\\n        int ans = -1;\\n        \\n        while(s <= e){\\n            if(nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]){\\n                ans = nums[mid];\\n                break;\\n            }\\n            // check if it is left half or right half\\n            else if((nums[mid] == nums[mid+1] && mid % 2 == 0) || (mid % 2 == 1 && nums[mid] == nums[mid-1])){\\n                s = mid + 1;\\n            }\\n            else{\\n                e = mid - 1;\\n            }\\n            \\n            mid = s + (e - s) / 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// Please upvote if it helps :)\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n\\n// Please upvote if it helps :)\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int e = nums.size();\\n        // Checking the boundary first\\n        if(e == 1){\\n            return nums[0];\\n        }\\n        \\n        if(nums[0] != nums[1]){\\n            return nums[0];\\n        }\\n        \\n        if(nums[e-1] != nums[e-2]){\\n            return nums[e-1];\\n        }\\n        \\n        int s = 0;\\n        int mid = s + (e - s) / 2;\\n        int ans = -1;\\n        \\n        while(s <= e){\\n            if(nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]){\\n                ans = nums[mid];\\n                break;\\n            }\\n            // check if it is left half or right half\\n            else if((nums[mid] == nums[mid+1] && mid % 2 == 0) || (mid % 2 == 1 && nums[mid] == nums[mid-1])){\\n                s = mid + 1;\\n            }\\n            else{\\n                e = mid - 1;\\n            }\\n            \\n            mid = s + (e - s) / 2;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n// Please upvote if it helps :)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696551,
                "title": "o-logn-time-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int low=0;\\n        int high=nums.length;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(mid-1>=0 && nums[mid]==nums[mid-1]){\\n                // this is second occurance\\n                if(mid%2==1){\\n                    // it must be odd if all numbers are paired in left, then unpaired element must found in right\\n                    low=mid+1;\\n                }else{\\n                    // if it is not odd then element in in left\\n                    high=mid-1;\\n                }\\n            }else if(mid+1< nums.length && nums[mid]==nums[mid+1]){\\n                // this is first occurance\\n                if(mid%2==0){\\n                    low=mid+1;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }else{\\n                return nums[mid];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int low=0;\\n        int high=nums.length;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(mid-1>=0 && nums[mid]==nums[mid-1]){\\n                // this is second occurance\\n                if(mid%2==1){\\n                    // it must be odd if all numbers are paired in left, then unpaired element must found in right\\n                    low=mid+1;\\n                }else{\\n                    // if it is not odd then element in in left\\n                    high=mid-1;\\n                }\\n            }else if(mid+1< nums.length && nums[mid]==nums[mid+1]){\\n                // this is first occurance\\n                if(mid%2==0){\\n                    low=mid+1;\\n                }else{\\n                    high=mid-1;\\n                }\\n            }else{\\n                return nums[mid];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588411,
                "title": "c-two-simple-and-clean-solutions-o-logn-o-n-with-explanation",
                "content": "**O(logn) Binary Search Solution:**\\nExplanation:\\nFor a regular sorted array where each element is double, be have the first in an even index and the second in an odd index.\\nIf somewhere in the middle we have an element that appears only once, this pattern will be broken, and from there on the first element will be in an odd index and the second one in an even index.\\nSo, we makr a regular binary search. If the pattern is still holding in \"mid\", then we continue searching in the right side.\\nIf it\\'s already broken, we continue the search on the left side.\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int lo = 0, hi = nums.size()-1, mid;\\n        while (lo < hi) {\\n            mid = (lo + hi) / 2;\\n            if ((mid % 2 && nums[mid - 1] == nums[mid]) || (!(mid % 2) && nums[mid] == nums[mid + 1])) lo = mid + 1;\\n            else hi = mid;\\n        }\\n        return nums[lo];\\n    }\\n};\\n```\\n**O(n) Bitwise Solution:**\\nA number XOR itself is always 0.\\nA number XOR 0 always stays the number.\\nSo if we just XOR the entire array, we will be left with the element that appears only once.\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int res = nums[0];\\n        for (int i=1; i<nums.size(); i++)\\n            res ^= nums[i];\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int lo = 0, hi = nums.size()-1, mid;\\n        while (lo < hi) {\\n            mid = (lo + hi) / 2;\\n            if ((mid % 2 && nums[mid - 1] == nums[mid]) || (!(mid % 2) && nums[mid] == nums[mid + 1])) lo = mid + 1;\\n            else hi = mid;\\n        }\\n        return nums[lo];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int res = nums[0];\\n        for (int i=1; i<nums.size(); i++)\\n            res ^= nums[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017444,
                "title": "deep-explanation-leetcode-official-solution-visual-python",
                "content": "### Overview \\n\\nWe must find the ***only unique*** element in a ***sorted array*** where all **two copies*** of all other elements exist (or duplicate) \\n \\nfirst let us make some key observtions about the problem \\n\\nassuming  the constraints of the problem hold true, if  there is a match for an element it always exists to the ***adajcent left*** or the ***adjacent right*** of that number; otherwise the number is ***unique***.\\n\\nObserve key observation 1 in ***Figure 1***\\n\\n![image](https://assets.leetcode.com/users/images/2becd6d2-77aa-443c-a50e-d80bbcc30941_1610678546.0418265.png)\\n\\n* * * \\n\\n\\nRecall there are ***two copies*** of all elements ***except*** the unique value.\\n\\ninother words there are ***p*** pairs of ***duplicates*** where each pair is distinct. There is one value that cannot form a pair, this value is ***unique***. This means the length of the input array is ***2p + 1***\\n\\n***Observe key observation 2 in Figure 2***\\n![image](https://assets.leetcode.com/users/images/6af86593-3e0b-4a18-b9eb-72a8e8a6818b_1610679299.535254.png)\\n\\n* * * \\n\\n***we know that a unique value can  only exist if the array is of odd length***. We can use this ***principle to search*** the array for the ***unique value***.  \\n\\nsince this array is sorted a binary search like approach may prove useful. if we repeatedly divide the array in half and leverage our search principle mentioned above, we can always find the unique value in ```O(log N)``` time and ```O(1)``` space.\\n\\nWe always look for the unique value in the half that is odd length. because the half that is odd length, has some number of pairs ***k***, and ***1 unique value***. the other half would contain only pairs \\n\\n* * * \\n***The question now becomes, how do we do this?***\\n* * * \\n\\nyou may have already noticed that if we section an array of odd length into two parts by a mid point, ***both halves will contain the same number of elements.***\\n\\n![image](https://assets.leetcode.com/users/images/83a68561-7ce5-4261-92da-b1280fbb0d0b_1610680461.5730007.png)\\n\\nRecall that we said our search criteria was to always visit the half that is of ***odd length*** until we find our unique value, but from what we just saw in ***Figure 3*** it seems like this is going to be problem.\\n\\n* in the first example in ***Figure 3***  there is ***neither*** the ***left*** or ***right half*** is of ***odd length***, both halves are ***even length***. \\n\\n* in the second example in ***Figure 3***  both the ***left*** and the ***right*** halves are of ***odd length***, so it is unclear which half should be searched next. \\n\\nif we combine our key observations from above with our search principle, a solution is possible. \\n\\n***we always check to see if the mid point is the unique value*** \\n\\n![image](https://assets.leetcode.com/users/images/4ead9ac1-5153-43b3-87f5-d669d98ad22c_1610682563.080835.png)\\n\\nwe can see the unique value lies in the left half. what happens next?\\n\\n![image](https://assets.leetcode.com/users/images/3534e7a2-fba5-42be-b5fe-c224053f5100_1610684170.6051178.png)\\n\\n\\n\\n\\n\\nfrom here we can see that the 4 cases mentioned in the leetcode official solution arise\\n\\n\\n1. match is on ***left of mid point***  and both ****left and right halves*** are of ***even length***\\n\\t* exclude match and mid point and go left, that is ```high = mid - 2``` \\t\\n\\n2. match is on ***left of mid point*** and both ***left and right halves*** are of ***odd length***\\n\\t\\t* exclude match mid point and go right, that is ```low = mid + 1``` \\t\\n\\n3. match is on ***right of mid point***  and both ****left and right halves*** are of ***even length***\\n\\t * exclude match and mid point and go right, that is ```low = mid + 2``` \\n4.  match is on ***right of mid point*** and both ***left and right halves*** are of ***odd length***\\n\\t * exclude match mid point and go left, that is ```high = mid - 1``` \\n\\n\\n ```python\\n def singleNonDuplicate(self, nums: List[int]) -> int:\\n        lo = 0\\n        hi = len(nums) - 1   \\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n\\t\\t\\t# look to right for pair \\n            if nums[mid + 1] == nums[mid]:\\n\\t\\t\\t\\t# both halves are even length,\\n                if (hi - mid) % 2 == 0:\\n                    lo = mid + 2\\n                else:\\n                    hi = mid - 1\\n\\t\\t\\t # look to left for pair \\n            elif nums[mid - 1] == nums[mid]:\\n\\t\\t\\t\\t# both halves are even length\\n                if (hi - mid) % 2 == 0:\\n                    hi = mid - 2\\n                else:\\n                    lo = mid + 1\\n            else:\\n\\t\\t\\t\\t# no pair on either side, must be unique \\n                return nums[mid]\\n        return nums[lo]\\n```    \\n\\ncode courtesy of leetcode official solution \\n\\n\\n\\n\\n\\n\\n    \\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```O(log N)```\n```O(1)```\n```high = mid - 2```\n```low = mid + 1```\n```low = mid + 2```\n```high = mid - 1```\n```python\\n def singleNonDuplicate(self, nums: List[int]) -> int:\\n        lo = 0\\n        hi = len(nums) - 1   \\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n\\t\\t\\t# look to right for pair \\n            if nums[mid + 1] == nums[mid]:\\n\\t\\t\\t\\t# both halves are even length,\\n                if (hi - mid) % 2 == 0:\\n                    lo = mid + 2\\n                else:\\n                    hi = mid - 1\\n\\t\\t\\t # look to left for pair \\n            elif nums[mid - 1] == nums[mid]:\\n\\t\\t\\t\\t# both halves are even length\\n                if (hi - mid) % 2 == 0:\\n                    hi = mid - 2\\n                else:\\n                    lo = mid + 1\\n            else:\\n\\t\\t\\t\\t# no pair on either side, must be unique \\n                return nums[mid]\\n        return nums[lo]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 628014,
                "title": "short-javascript-binary-search-solution",
                "content": "```\\nvar singleNonDuplicate = function(nums) {\\n    if (nums.length == 1) return nums[0];\\n    return bsa(0, nums.length - 1);\\n    function bsa(start, end) {\\n        let mid = Math.floor((start + end) / 2);\\n        if (nums[mid] == nums[mid - 1]) return mid % 2 ? bsa(mid + 1, end) : bsa(start, mid);\\n        if (nums[mid] == nums[mid + 1]) return mid % 2 ? bsa(start, mid - 1) : bsa(mid, end);\\n        return nums[mid];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar singleNonDuplicate = function(nums) {\\n    if (nums.length == 1) return nums[0];\\n    return bsa(0, nums.length - 1);\\n    function bsa(start, end) {\\n        let mid = Math.floor((start + end) / 2);\\n        if (nums[mid] == nums[mid - 1]) return mid % 2 ? bsa(mid + 1, end) : bsa(start, mid);\\n        if (nums[mid] == nums[mid + 1]) return mid % 2 ? bsa(start, mid - 1) : bsa(mid, end);\\n        return nums[mid];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3213525,
                "title": "putta-easy-solution-c-beats-96-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary Search\\n\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int left = 0;\\n        int n = nums.size()-1;\\n        int right = n;\\n        while(left<=right){\\n            int mid = left+(right-left)/2;\\n            //edge case, if mid is single element\\n            if((mid == 0 || nums[mid] != nums[mid-1]) &&( mid == n || nums[mid] != nums[mid+1] )) return nums[mid];\\n        //as size of nums is odd logic to find which side to move\\n        int leftpart;\\n        if(nums[mid] == nums[mid-1])\\n        leftpart = mid-1;\\n        else leftpart = mid;\\n        \\n        if(leftpart%2 == 1) right = mid-1;\\n        else left = mid+1;\\n\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int left = 0;\\n        int n = nums.size()-1;\\n        int right = n;\\n        while(left<=right){\\n            int mid = left+(right-left)/2;\\n            //edge case, if mid is single element\\n            if((mid == 0 || nums[mid] != nums[mid-1]) &&( mid == n || nums[mid] != nums[mid+1] )) return nums[mid];\\n        //as size of nums is odd logic to find which side to move\\n        int leftpart;\\n        if(nums[mid] == nums[mid-1])\\n        leftpart = mid-1;\\n        else leftpart = mid;\\n        \\n        if(leftpart%2 == 1) right = mid-1;\\n        else left = mid+1;\\n\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212160,
                "title": "c-clean-code-5-lines-easy-to-understand-xor-method-well-explained",
                "content": "**Pls upvote the thread if you found it helpful.**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    We know :-\\n        - XOR(x,x) = 0\\n        - XOR(x,0) = x\\nUsing this the **repeating elements** will become 0 and the element that is **present once** will be left.\\nIterate over the given sorted array and maintain a curr_xor which will store XOR of the elements.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. Initialize variables. \\n    curr_xor = 0 and n (size of the given sorted array)\\n    2. Iterate over the given array \\n    3. XOR elements.\\n    curr_xor ^= nums[i]\\n    4. Return curr_xor\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)    \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        int curr_xor=0; //variable will store XOR\\n        for(int i =0;i<n;i++){\\n            curr_xor ^= nums[i]; // XOR\\n        }\\n        return curr_xor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        int curr_xor=0; //variable will store XOR\\n        for(int i =0;i<n;i++){\\n            curr_xor ^= nums[i]; // XOR\\n        }\\n        return curr_xor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212052,
                "title": "python3-166-ms-faster-than-95-30-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/efc9658c-14ab-4771-b4c6-9ca50950ec75_1676938125.9127867.png)\\n\\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        start = 0\\n        end = n - 1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            a = mid % 2 == 0 and nums[mid] == nums[mid - 1]\\n            b = mid % 2 != 0 and nums[mid] == nums[mid + 1]\\n            if a or b:\\n                end = mid - 1\\n            else: \\n                start = mid + 1\\n        return nums[start - 1]\\n```\\n\\nThe code is implementing the binary search algorithm to find the single element in a sorted array which appears only once. Here\\'s a step by step explanation of the code:\\n1. First, the length of the input array is stored in the variable \\'n\\'.\\n1. Then, the start and end indices of the array are set to 0 and n - 1 respectively.\\n1. A while loop is initiated that continues while the start index is less than or equal to the end index.\\n1. Inside the while loop, the mid index is calculated using the formula \"start + (end - start) // 2\". This is equivalent to (start + end) // 2 but avoids potential integer overflow issues.\\n1. Two boolean variables \\'a\\' and \\'b\\' are created to check if the mid index is pointing to the single element. \\'a\\' is True if the mid index is even and the element at mid is equal to the element at mid - 1. \\'b\\' is True if the mid index is odd and the element at mid is equal to the element at mid + 1.\\n1. If either \\'a\\' or \\'b\\' is True, then it means that the single element is in the left half of the array. Therefore, the end index is updated to mid - 1.\\n1. If \\'a\\' and \\'b\\' are both False, then the single element is in the right half of the array. Therefore, the start index is updated to mid + 1.\\n1. After the while loop completes, the function returns the element at index start - 1. This is because the start index will always point to the first occurrence of the single element, and decrementing it by 1 gives the index of the single element.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        start = 0\\n        end = n - 1\\n        \\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            a = mid % 2 == 0 and nums[mid] == nums[mid - 1]\\n            b = mid % 2 != 0 and nums[mid] == nums[mid + 1]\\n            if a or b:\\n                end = mid - 1\\n            else: \\n                start = mid + 1\\n        return nums[start - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588217,
                "title": "you-will-never-forget-this-approach-handwritten-dry-run",
                "content": "**Please Upvote,it helps a lot to write Such Posts**\\n\\n![image](https://assets.leetcode.com/users/images/67a81016-0023-44fd-bbc9-abdd4cec9d79_1637416896.3717594.jpeg)\\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n![image](https://assets.leetcode.com/users/images/f58a0946-72bb-44ac-872d-c956857ba484_1637416906.2029173.jpeg)\\n\\n```\\n/*Time Complexity : O(log n)\\nSpace complexity : O(1)\\n\\nExplanation: We know that  log n time Complexity can be Achieved by B.Search\\nonly and sorted array is given so definitely we can try B.Search. But only one\\nissue is there how to determine where to move from mid, so only solution is to\\ncheck the number of elements from 0 to mid, so that we can determine on \\nwhich side violation is there, then  only we can move when we find on which\\nside violation is there and it can be found out only using the odd/even number of elements and comparing the\\nmid with mid -1 and mid + 1 to \\ndetermince which side we have to go */\\n\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        \\n        int low = 0,high = nums.length - 1, mid = 0;\\n        \\n        while(low <= high){\\n             mid = (low + high )/2;\\n            \\n            int num = mid + 1;  //to find total number of elements from 0 to mid\\n            \\n            if(num % 2 == 0){ //even number of elements between low and high\\n                if(mid > 0 && nums[mid] == nums[mid - 1]) low = mid + 1;\\n                else if(mid < nums.length - 1 && nums[mid] == nums[mid + 1]) high = mid - 1;\\n                else return nums[mid];  \\n            }else{\\n                 if(mid > 0 && nums[mid] == nums[mid - 1]) high = mid - 1;\\n                 else if(mid < nums.length - 1 && nums [mid] == nums[mid + 1]) low = mid + 1;\\n                 else return nums[mid];\\n        }\\n     }\\n        return nums[mid];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n/*Time Complexity : O(log n)\\nSpace complexity : O(1)\\n\\nExplanation: We know that  log n time Complexity can be Achieved by B.Search\\nonly and sorted array is given so definitely we can try B.Search. But only one\\nissue is there how to determine where to move from mid, so only solution is to\\ncheck the number of elements from 0 to mid, so that we can determine on \\nwhich side violation is there, then  only we can move when we find on which\\nside violation is there and it can be found out only using the odd/even number of elements and comparing the\\nmid with mid -1 and mid + 1 to \\ndetermince which side we have to go */\\n\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        \\n        int low = 0,high = nums.length - 1, mid = 0;\\n        \\n        while(low <= high){\\n             mid = (low + high )/2;\\n            \\n            int num = mid + 1;  //to find total number of elements from 0 to mid\\n            \\n            if(num % 2 == 0){ //even number of elements between low and high\\n                if(mid > 0 && nums[mid] == nums[mid - 1]) low = mid + 1;\\n                else if(mid < nums.length - 1 && nums[mid] == nums[mid + 1]) high = mid - 1;\\n                else return nums[mid];  \\n            }else{\\n                 if(mid > 0 && nums[mid] == nums[mid - 1]) high = mid - 1;\\n                 else if(mid < nums.length - 1 && nums [mid] == nums[mid + 1]) low = mid + 1;\\n                 else return nums[mid];\\n        }\\n     }\\n        return nums[mid];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587502,
                "title": "straightforward-approach-using-binary-search-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\nThe idea of this solution is the following:\\n\\nSuppose we have the following array: ```[1,1,2,2,3,3,4,4,6,8,8]```\\n\\nWe can observe that for each pair: \\n\\n* The first pair element takes the even array index position \\n* The second pair element takes the odd array index position\\n\\nFor example, when examining the number 1 as a pair, we see it takes the array index positions ```0``` and ```1```. \\n\\nSimilarly for all other pairs, the first pair element takes the even array index position, and the second pair element takes the odd array index position.\\n\\nUsing this idea, we can see that this pattern for pairs will break when a single element appears in the array.\\n\\nIn this solution, we use binary search to look for the point in the array where the pattern mentioned above for the pairs first breaks.\\n\\n```\\npublic class Solution {\\n    public int SingleNonDuplicate(int[] nums) {    \\n        var lo = 0;\\n        var hi = nums.Length - 1;\\n        \\n        while (lo < hi) {\\n            // Get the mipoint\\n            var mid = lo + (hi - lo) / 2;\\n            \\n            // Check to see if mid is even\\n            var isEven = mid % 2 == 0;\\n            \\n            // If mid is even, its duplicate should be the next index\\n            // If mid is odd, its duplicate should be the previous index\\n            if ((isEven && nums[mid] == nums[mid + 1]) || (!isEven && nums[mid] == nums[mid - 1])) {\\n                // Duplicate found, advance to next index. Single element is > mid\\n                lo = mid + 1;\\n            } else {\\n                // Pattern is broken. Single element is <= mid\\n                hi = mid;\\n            }           \\n        }        \\n        return nums[lo];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```[1,1,2,2,3,3,4,4,6,8,8]```\n```0```\n```1```\n```\\npublic class Solution {\\n    public int SingleNonDuplicate(int[] nums) {    \\n        var lo = 0;\\n        var hi = nums.Length - 1;\\n        \\n        while (lo < hi) {\\n            // Get the mipoint\\n            var mid = lo + (hi - lo) / 2;\\n            \\n            // Check to see if mid is even\\n            var isEven = mid % 2 == 0;\\n            \\n            // If mid is even, its duplicate should be the next index\\n            // If mid is odd, its duplicate should be the previous index\\n            if ((isEven && nums[mid] == nums[mid + 1]) || (!isEven && nums[mid] == nums[mid - 1])) {\\n                // Duplicate found, advance to next index. Single element is > mid\\n                lo = mid + 1;\\n            } else {\\n                // Pattern is broken. Single element is <= mid\\n                hi = mid;\\n            }           \\n        }        \\n        return nums[lo];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100806,
                "title": "binary-search-based-approach-in-python",
                "content": "```\\nclass Solution(object):\\n    def singleNonDuplicate(self, list):\\n        low, high = 0 , len(list)-1\\n        while (low<high):\\n            mid = low + (high-low)/2\\n            if (list[mid]!=list[mid+1] and list[mid]!=list[mid-1]):\\n                return list[mid]\\n            elif (mid%2 ==1 and list[mid]==list[mid-1]):\\n                low = mid+1\\n            elif (mid%2 ==0 and list[mid]==list[mid+1]):\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        return list[low]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def singleNonDuplicate(self, list):\\n        low, high = 0 , len(list)-1\\n        while (low<high):\\n            mid = low + (high-low)/2\\n            if (list[mid]!=list[mid+1] and list[mid]!=list[mid-1]):\\n                return list[mid]\\n            elif (mid%2 ==1 and list[mid]==list[mid-1]):\\n                low = mid+1\\n            elif (mid%2 ==0 and list[mid]==list[mid+1]):\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        return list[low]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215377,
                "title": "0-ms-simple-java-solution-100-faster",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n        //create the search space\\n        int low = 0;\\n        int high = nums.length-1;\\n        while(low <= high){\\n            //find the middle index;\\n            int mid = low+(high - low)/2;\\n            if(mid-1 >=0 && nums[mid] == nums[mid-1]){\\n                mid--;\\n                int left_space = mid - low;\\n                int right_space = high - (mid - 1);\\n                if(left_space%2 != 0){\\n                    high = mid - 1;\\n                }\\n                else if(right_space%2 != 0){\\n                    low = mid + 2;\\n                }\\n            }\\n            else if(mid+1 <= nums.length-1 && nums[mid] == nums[mid+1]){\\n                mid++;\\n                int left_space = (mid-1) - low;\\n                int right_space = high - mid;\\n                if(left_space%2 != 0){\\n                    high = mid - 2;\\n                }\\n                else if(right_space%2 != 0){\\n                    low = mid + 1;\\n                }\\n            }\\n            else\\n                return nums[mid];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        if(nums.length == 1) return nums[0];\\n        //create the search space\\n        int low = 0;\\n        int high = nums.length-1;\\n        while(low <= high){\\n            //find the middle index;\\n            int mid = low+(high - low)/2;\\n            if(mid-1 >=0 && nums[mid] == nums[mid-1]){\\n                mid--;\\n                int left_space = mid - low;\\n                int right_space = high - (mid - 1);\\n                if(left_space%2 != 0){\\n                    high = mid - 1;\\n                }\\n                else if(right_space%2 != 0){\\n                    low = mid + 2;\\n                }\\n            }\\n            else if(mid+1 <= nums.length-1 && nums[mid] == nums[mid+1]){\\n                mid++;\\n                int left_space = (mid-1) - low;\\n                int right_space = high - mid;\\n                if(left_space%2 != 0){\\n                    high = mid - 2;\\n                }\\n                else if(right_space%2 != 0){\\n                    low = mid + 1;\\n                }\\n            }\\n            else\\n                return nums[mid];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213444,
                "title": "c-3-lines-xor-solution",
                "content": "\\n# Approach\\n- XOR of a number with itself results 0\\n- XOR of a number with 0 results a number only\\n- XOR of a number with itself, odd number of times results a number only\\n- XOR of a number with itself, even number of times reuslts 0 \\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n        int sum = 0;\\n\\n        for( auto &it : nums ) \\n            sum ^= it;\\n\\n        return sum ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n        int sum = 0;\\n\\n        for( auto &it : nums ) \\n            sum ^= it;\\n\\n        return sum ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213227,
                "title": "java-fastest-solution",
                "content": "0ms runtime\\n# JAVA Code\\n``` JAVA []\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int left = 0, right = nums.length-1;\\n        while(left < right){\\n            int mid = (left + right)/2;\\n            if( (mid % 2 == 0 && nums[mid] == nums[mid +1]) || (mid %2 == 1 && nums[mid] == nums[mid - 1]) )\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return nums[left];\\n    }   \\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int left = 0, right = nums.length-1;\\n        while(left < right){\\n            int mid = (left + right)/2;\\n            if( (mid % 2 == 0 && nums[mid] == nums[mid +1]) || (mid %2 == 1 && nums[mid] == nums[mid - 1]) )\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        return nums[left];\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212391,
                "title": "using-advantage-of-sorted-array-java-o-n",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the given array is sorted, if the element is present twice,we can simply check by checking the element with i+1 element, if twice the element found we can skip the next element, until the elements appearing twice we can search with i+=2, then if the element is not equal to i+1, then we return the element.\\nWe have to make sure the i wont reach the out of index.\\n# Complexity\\n- Time complexity:\\n- o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i == nums.length-1)\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                if(nums[i] == nums[i+1])\\n                {\\n                    if((i+1) != nums.length-1)\\n                    {\\n                        i++;\\n                    }\\n                }\\n                else\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i == nums.length-1)\\n            {\\n                return nums[i];\\n            }\\n            else\\n            {\\n                if(nums[i] == nums[i+1])\\n                {\\n                    if((i+1) != nums.length-1)\\n                    {\\n                        i++;\\n                    }\\n                }\\n                else\\n                {\\n                    return nums[i];\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015897,
                "title": "c-o-log-n-o-1",
                "content": "```\\n int singleNonDuplicate(vector<int>& nums) {\\n        int start = 0 , end = nums.size()-1;\\n        \\n        if(nums.size() == 1)    return nums[0]; \\n        if(nums[0] != nums[1]) return nums[0];\\n        if(nums[end] != nums[end-1]) return nums[end];\\n            \\n        while(start<=end)\\n        {\\n            int mid = (start+end)/2;\\n            if(mid%2 == 0)\\n            {\\n                if(nums[mid] == nums[mid+1])\\n                start = mid+1;\\n                else\\n                    end = mid-1;\\n            }\\n            else if(mid%2 != 0)\\n            {\\n                if(nums[mid] == nums[mid+1])\\n                    end = mid-1;\\n                else\\n                    start = mid+1;\\n            }\\n             if(nums[mid] != nums[mid+1] && nums[mid] != nums[mid-1])\\n                return nums[mid];\\n        }\\n        \\n        return 0;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n int singleNonDuplicate(vector<int>& nums) {\\n        int start = 0 , end = nums.size()-1;\\n        \\n        if(nums.size() == 1)    return nums[0]; \\n        if(nums[0] != nums[1]) return nums[0];\\n        if(nums[end] != nums[end-1]) return nums[end];\\n            \\n        while(start<=end)\\n        {\\n            int mid = (start+end)/2;\\n            if(mid%2 == 0)\\n            {\\n                if(nums[mid] == nums[mid+1])\\n                start = mid+1;\\n                else\\n                    end = mid-1;\\n            }\\n            else if(mid%2 != 0)\\n            {\\n                if(nums[mid] == nums[mid+1])\\n                    end = mid-1;\\n                else\\n                    start = mid+1;\\n            }\\n             if(nums[mid] != nums[mid+1] && nums[mid] != nums[mid-1])\\n                return nums[mid];\\n        }\\n        \\n        return 0;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1770051,
                "title": "easy-java-binary-solution-100-faster",
                "content": "Please upvote if you find it helpful\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        int l=0, h=nums.length-1;\\n        while(l<h){\\n            int mid = l + (h-l)/2;\\n            if(mid-1>=0 && nums[mid] == nums[mid-1]){ \\n                if(mid%2 == 1){    \\n                    l = mid+1;\\n                }\\n                else h = mid-1;\\n            }\\n            else if(mid+1<nums.length && nums[mid] == nums[mid+1]){\\n                if(mid%2 == 1){\\n                    h = mid-1;\\n                }\\n                else l = mid+1;\\n            }\\n            else return nums[mid];\\n        }\\n        return nums[h];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        int l=0, h=nums.length-1;\\n        while(l<h){\\n            int mid = l + (h-l)/2;\\n            if(mid-1>=0 && nums[mid] == nums[mid-1]){ \\n                if(mid%2 == 1){    \\n                    l = mid+1;\\n                }\\n                else h = mid-1;\\n            }\\n            else if(mid+1<nums.length && nums[mid] == nums[mid+1]){\\n                if(mid%2 == 1){\\n                    h = mid-1;\\n                }\\n                else l = mid+1;\\n            }\\n            else return nums[mid];\\n        }\\n        return nums[h];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590132,
                "title": "java-binary-search-100-fast-each-step-explained-with-comments",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        \\n        // As we are given a sorted array + it says that our solution must be of 0(log n) time\\n        // We, get the idea that we have to do BINARY SEARCH\\n        \\n        //BOUNDARY CONDITIONS:\\n        \\n        //1. Check if the length of nums is only 1     \\n        \\n        if(nums.length == 1)\\n        {\\n            return nums[0];\\n        }\\n        \\n        //2. Check if the first element is our answer?\\n        \\n        else if(nums[0] != nums[1])\\n        {\\n            return nums[0];\\n        }\\n        \\n        //3. Check if the last element of the array is our answer?\\n        \\n        else if(nums[nums.length-1] != nums[nums.length-2])\\n        {\\n            return nums[nums.length-1];\\n        }\\n        \\n        int start = 0;\\n        int end = nums.length-1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end - start)/2;\\n            \\n\\t\\t\\t// Here, we are checking that if the value at mid is not equal to any of its adjacent then that is our answer\\n            \\n            if((nums[mid] != nums[mid+1]) && (nums[mid] != nums[mid-1]))\\n            {\\n                return nums[mid];\\n            }  \\n            \\n\\t\\t\\t//Here for odd positions, we are checking the condition with mid-1, as the pair would definitely be on its left\\n\\t\\t\\t//And for the even position we have mid+1 as the pair would be on the right\\n            \\n            else if(((mid % 2 == 0) && (nums[mid] == nums[mid+1])) || ((mid % 2 == 1) && (nums[mid] == nums[mid-1])))\\n            {\\n                start = mid + 1;\\n            }\\n            else\\n            {\\n                end = mid - 1;\\n            }             \\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        \\n        // As we are given a sorted array + it says that our solution must be of 0(log n) time\\n        // We, get the idea that we have to do BINARY SEARCH\\n        \\n        //BOUNDARY CONDITIONS:\\n        \\n        //1. Check if the length of nums is only 1     \\n        \\n        if(nums.length == 1)\\n        {\\n            return nums[0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1481965,
                "title": "easy-java-solution-faster-than-100-o-logn",
                "content": "```\\npublic int singleNonDuplicate(int[] nums) {\\n\\tif(nums.length <= 2){\\n\\t\\treturn nums[0];\\n\\t}\\n\\tint low = 0;\\n\\tint high = nums.length - 1;\\n\\tint mid;\\n\\twhile(low <= high){\\n\\t\\tmid = low + (high - low) /2;\\n\\t\\t\\n\\t\\t//Check to see if element is in the middle\\n\\t\\tif(mid > 0 && mid < nums.length - 1 && nums[mid] != nums[mid - 1] && nums[mid] != nums[mid + 1]){\\n\\t\\t\\treturn nums[mid];\\n\\t\\t}\\n\\t\\t//This check\\'s if the array on then left part, till the mid has first occurence of the pair in even index position\\n\\t\\t//Because once the single element comes the first occurrence of the pair will always be in  odd index position\\n\\t\\t//In that case we have to search for the element on the right part of the array\\n\\t\\telse if((mid > 0 && nums[mid] == nums[mid - 1] && (mid - 1) % 2 == 0) || ( mid < nums.length - 1 && nums[mid] == nums[mid + 1] && (mid + 1) % 2 != 0)){\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\thigh = mid - 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn nums[low];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic int singleNonDuplicate(int[] nums) {\\n\\tif(nums.length <= 2){\\n\\t\\treturn nums[0];\\n\\t}\\n\\tint low = 0;\\n\\tint high = nums.length - 1;\\n\\tint mid;\\n\\twhile(low <= high){\\n\\t\\tmid = low + (high - low) /2;\\n\\t\\t\\n\\t\\t//Check to see if element is in the middle\\n\\t\\tif(mid > 0 && mid < nums.length - 1 && nums[mid] != nums[mid - 1] && nums[mid] != nums[mid + 1]){\\n\\t\\t\\treturn nums[mid];\\n\\t\\t}\\n\\t\\t//This check\\'s if the array on then left part, till the mid has first occurence of the pair in even index position\\n\\t\\t//Because once the single element comes the first occurrence of the pair will always be in  odd index position\\n\\t\\t//In that case we have to search for the element on the right part of the array\\n\\t\\telse if((mid > 0 && nums[mid] == nums[mid - 1] && (mid - 1) % 2 == 0) || ( mid < nums.length - 1 && nums[mid] == nums[mid + 1] && (mid + 1) % 2 != 0)){\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\thigh = mid - 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn nums[low];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436952,
                "title": "java-binary-search-o-log-n-solution",
                "content": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        \\n        if(nums.length == 0) return 0;\\n        else if(nums.length ==1) return nums[0];\\n        else if(nums[0] != nums[1]) return nums[0];\\n        else if(nums[end] != nums[end-1]) return nums[end];\\n        \\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            \\n            if(nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]) return nums[mid];\\n            \\n            else if(mid % 2 == 0) {\\n                if(nums[mid] == nums[mid+1]) start = mid + 1;\\n                else end = mid - 1;\\n            }\\n            else if(mid % 2 != 0) {\\n                if(nums[mid] == nums[mid-1]) start = mid +1;\\n                else end = mid - 1;\\n            }   \\n        }return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int start = 0;\\n        int end = nums.length-1;\\n        \\n        if(nums.length == 0) return 0;\\n        else if(nums.length ==1) return nums[0];\\n        else if(nums[0] != nums[1]) return nums[0];\\n        else if(nums[end] != nums[end-1]) return nums[end];\\n        \\n        while(start <= end) {\\n            int mid = start + (end - start) / 2;\\n            \\n            if(nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]) return nums[mid];\\n            \\n            else if(mid % 2 == 0) {\\n                if(nums[mid] == nums[mid+1]) start = mid + 1;\\n                else end = mid - 1;\\n            }\\n            else if(mid % 2 != 0) {\\n                if(nums[mid] == nums[mid-1]) start = mid +1;\\n                else end = mid - 1;\\n            }   \\n        }return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344226,
                "title": "c-binary-search-solution-o-logn",
                "content": "Runtime: 4 ms, faster than 97.93% of C++ online submissions for Single Element in a Sorted Array.\\nMemory Usage: 11.1 MB, less than 39.06% of C++ online submissions for Single Element in a Sorted Array.\\n\\n```\\nWe can do binary search over the sorted array to find the single element. But on which condition we should\\nmove to left half or right half ? During binary search we always make move decision  based on mid value,\\nhere we do the same too but we consider both mid value and index and there are 4 possible cases:\\n\\n1. Mid Index Odd: \\nMeans the length of array from start till mid value (included) is even. As the length of subarray [0, mid] is even\\nthe single element can be in [0, mid] or [mid+1, n-1]. Subarray [0, mid] length is even and if all elements in\\nsubarray are twice means no single element, then nums[mid] and nums[mid-1] will be same and single\\nelement will be in the right half [mid+1, n-1], so we move to right half. Otherwise nums[mid]!=nums[mid-1]\\nand there is a single element in the left half [0, mid] and  so we move to left half.\\n\\nExample:\\n[1,1,2,3,3,5,5] => mid = 3 => nums[mid]!=nums[mid-1] => nums[3]!=nums[2] =>move to left half\\n[1,1,2,2,3,5,5] => mid = 3 => nums[mid]==nums[mid-1] => nums[3]==nums[2] => move to right half\\n\\n2. Mid Index Even:\\nMeans the length of array from start till mid value (included) is odd. As the length of subarray [0, mid] is\\nodd the single element can be in [0, mid] or [mid+1, n-1]. Subarray [0, mid] length is odd and if nums[mid]\\nand nums[mid+1] are same then the single element is in the right half, otherwise it is in the left half.\\n\\nExample:\\n[1,1,3,2,2,4,4,5,5] => mid = 3 => nums[mid]!=nums[mid+1] => nums[3]!=nums[4] =>move to left half\\n[1,1,2,2,4,4,5,6,6] => mid = 3 => nums[mid]==nums[mid+1] => nums[3]==nums[4]  =>move to right half\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        // base cases\\n        if(n==1)return nums[0];\\n        if(nums[n-1]!=nums[n-2])return nums[n-1];\\n        if(nums[0]!=nums[1]) return nums[0];\\n        \\n        // iterative binary search\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n        while(left<right)\\n        {\\n            int mid = left + (right-left)/2;\\n            \\n            // mid is odd means subarray [0,mid] length is even\\n            // single element in the right half if nums[mid]==nums[mid-1], otherwise left half\\n            if(mid % 2 ==1)\\n            {\\n                if(nums[mid]!=nums[mid-1])right = mid;\\n                else left = mid + 1;                \\n            }\\n            // mid is even means subarray [0,mid] length is odd\\n            // single element in the right half if nums[mid]==nums[mid+1], otherwise left half\\n            else\\n            {\\n                if(nums[mid]!=nums[mid+1])right = mid;\\n                else left = mid + 1;\\n            }            \\n        }\\n        \\n        // after binary search the left element will contain the single element\\n        return nums[left];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nWe can do binary search over the sorted array to find the single element. But on which condition we should\\nmove to left half or right half ? During binary search we always make move decision  based on mid value,\\nhere we do the same too but we consider both mid value and index and there are 4 possible cases:\\n\\n1. Mid Index Odd: \\nMeans the length of array from start till mid value (included) is even. As the length of subarray [0, mid] is even\\nthe single element can be in [0, mid] or [mid+1, n-1]. Subarray [0, mid] length is even and if all elements in\\nsubarray are twice means no single element, then nums[mid] and nums[mid-1] will be same and single\\nelement will be in the right half [mid+1, n-1], so we move to right half. Otherwise nums[mid]!=nums[mid-1]\\nand there is a single element in the left half [0, mid] and  so we move to left half.\\n\\nExample:\\n[1,1,2,3,3,5,5] => mid = 3 => nums[mid]!=nums[mid-1] => nums[3]!=nums[2] =>move to left half\\n[1,1,2,2,3,5,5] => mid = 3 => nums[mid]==nums[mid-1] => nums[3]==nums[2] => move to right half\\n\\n2. Mid Index Even:\\nMeans the length of array from start till mid value (included) is odd. As the length of subarray [0, mid] is\\nodd the single element can be in [0, mid] or [mid+1, n-1]. Subarray [0, mid] length is odd and if nums[mid]\\nand nums[mid+1] are same then the single element is in the right half, otherwise it is in the left half.\\n\\nExample:\\n[1,1,3,2,2,4,4,5,5] => mid = 3 => nums[mid]!=nums[mid+1] => nums[3]!=nums[4] =>move to left half\\n[1,1,2,2,4,4,5,6,6] => mid = 3 => nums[mid]==nums[mid+1] => nums[3]==nums[4]  =>move to right half\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        // base cases\\n        if(n==1)return nums[0];\\n        if(nums[n-1]!=nums[n-2])return nums[n-1];\\n        if(nums[0]!=nums[1]) return nums[0];\\n        \\n        // iterative binary search\\n        int left = 0;\\n        int right = n-1;\\n        int mid;\\n        while(left<right)\\n        {\\n            int mid = left + (right-left)/2;\\n            \\n            // mid is odd means subarray [0,mid] length is even\\n            // single element in the right half if nums[mid]==nums[mid-1], otherwise left half\\n            if(mid % 2 ==1)\\n            {\\n                if(nums[mid]!=nums[mid-1])right = mid;\\n                else left = mid + 1;                \\n            }\\n            // mid is even means subarray [0,mid] length is odd\\n            // single element in the right half if nums[mid]==nums[mid+1], otherwise left half\\n            else\\n            {\\n                if(nums[mid]!=nums[mid+1])right = mid;\\n                else left = mid + 1;\\n            }            \\n        }\\n        \\n        // after binary search the left element will contain the single element\\n        return nums[left];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330728,
                "title": "0-ms-sol-using-java-bit-manipulation-binary-search",
                "content": "Bit manipulation\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int res = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            res = res^nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\nbinary search\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int start = 0,end = nums.length-1;\\n        while(start < end)\\n        {\\n            int mid = start + (end-start)/2;\\n            if(mid % 2 == 1)\\n                mid--;\\n            \\n            if(nums[mid] != nums[mid+1])\\n                end = mid;\\n            else start = mid+2;\\n        }\\n        return nums[start];\\n    }\\n}\\n```\\n\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int res = 0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            res = res^nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int start = 0,end = nums.length-1;\\n        while(start < end)\\n        {\\n            int mid = start + (end-start)/2;\\n            if(mid % 2 == 1)\\n                mid--;\\n            \\n            if(nums[mid] != nums[mid+1])\\n                end = mid;\\n            else start = mid+2;\\n        }\\n        return nums[start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 627803,
                "title": "python-3-today-s-one-liner",
                "content": "# Method 1 - xor\\n\\nJust xor all the numbers together. You\\'ll get the unique number. \\n\\nUse [functools.reduce](https://docs.python.org/3/library/functools.html#functools.reduce) and [operator.xor](https://docs.python.org/3/library/operator.html#operator.xor) to do it one line.\\n\\nTime: `O(n)`\\nSpace: `O(1)`\\n\\n## One line\\n\\n```python\\nclass Solution:\\n  def singleNonDuplicate(self, A: List[int]) -> int:\\n    return reduce(xor, A)\\n```\\n\\n## True one-liner\\n\\n```python\\nclass Solution: singleNonDuplicate = lambda A: reduce(xor, A)\\n```\\n\\n-----\\n# Method 2 - bisect\\n\\nIt\\'s a sorted list, so we should be able to use binary search. Which means we should be able to use [bisect](https://docs.python.org/3/library/bisect.html) somehow. But how?\\n\\nLet\\'s take the numbers and pair every two...\\n```\\n[1,1,3,3,4,4,7,8,8,9,9]\\n...\\n[(1,1), (3,3), (4,4), (7,8), (8,9), (9)]\\n...\\n[ match, match, match, no-match, no-match, single]\\n```\\nSo let\\'s assigning `match` and `no-match` values and chop off the single at the end. If we have `match` be `0` and `no-match` be `1`, the array is sorted and we\\'re looking for where the `0`\\'s become `1\\'s`. If they\\'re all 0\\'s, then our number is the single one at the end.\\n\\nWe can use [bisect_left](https://docs.python.org/3/library/bisect.html#bisect.bisect_left) to find the first 1, or [bisect_right](https://docs.python.org/3/library/bisect.html#bisect.bisect_right) to find the last 0. Either works, but you need an extra +1 if you use the position of the last 0.\\n\\nThen we take the position returned by bisect_left and double it, and that is the index of our answer.\\n\\nNote that to actually perform this version of the binary search, we have to create a class wrapper to override the [`A[i]` operation](https://docs.python.org/3/reference/datamodel.html#object.__getitem__).\\n\\nTime: `O(log n)`\\nSpace: `O(1)`\\n\\n## Four lines\\n\\n```python\\nclass Solution:\\n  def singleNonDuplicate(self, A: List[int]) -> int:\\n    class Wrapper:\\n      def __getitem__(self, i):\\n        return A[2*i] != A[2*i+1]\\n    return A[2*bisect_left(Wrapper(), 1, 0, len(A)//2)]\\n```\\n\\n## True one-liner\\n\\nUse the [type function](https://docs.python.org/3/library/functions.html#type) instead of defining a `class`.\\n\\n```python\\nclass Solution: singleNonDuplicate = lambda _,A: A[2*bisect_left(type(\\'\\', (), {\\'__getitem__\\': lambda _,i: A[2*i] != A[2*i+1]})(), 1, 0, len(A)//2)]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def singleNonDuplicate(self, A: List[int]) -> int:\\n    return reduce(xor, A)\\n```\n```python\\nclass Solution: singleNonDuplicate = lambda A: reduce(xor, A)\\n```\n```\\n[1,1,3,3,4,4,7,8,8,9,9]\\n...\\n[(1,1), (3,3), (4,4), (7,8), (8,9), (9)]\\n...\\n[ match, match, match, no-match, no-match, single]\\n```\n```python\\nclass Solution:\\n  def singleNonDuplicate(self, A: List[int]) -> int:\\n    class Wrapper:\\n      def __getitem__(self, i):\\n        return A[2*i] != A[2*i+1]\\n    return A[2*bisect_left(Wrapper(), 1, 0, len(A)//2)]\\n```\n```python\\nclass Solution: singleNonDuplicate = lambda _,A: A[2*bisect_left(type(\\'\\', (), {\\'__getitem__\\': lambda _,i: A[2*i] != A[2*i+1]})(), 1, 0, len(A)//2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611613,
                "title": "c-binary-search-o-log-n-use-xor-to-maintain-n-and-n-1-even-odd-pair",
                "content": "```\\nint singleNonDuplicate(vector<int>& nums) {\\n\\tint start=0, end = nums.size()-1, mid;\\n\\twhile( start < end ) {\\n\\t\\tmid = start + (end-start)/2;\\n\\t\\tif( nums[mid] == nums[mid ^ 1] )\\n\\t\\t\\tstart = mid + 1;\\n\\t\\telse\\n\\t\\t\\tend = mid;\\n\\t}\\n\\treturn nums[start];\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nint singleNonDuplicate(vector<int>& nums) {\\n\\tint start=0, end = nums.size()-1, mid;\\n\\twhile( start < end ) {\\n\\t\\tmid = start + (end-start)/2;\\n\\t\\tif( nums[mid] == nums[mid ^ 1] )\\n\\t\\t\\tstart = mid + 1;\\n\\t\\telse\\n\\t\\t\\tend = mid;\\n\\t}\\n\\treturn nums[start];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 372684,
                "title": "easy-peasy-python-with-lot-of-comments",
                "content": "\\tdef singleNonDuplicate(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln == 1:\\n            return nums[0]\\n        \\n        s, e = 0, ln-1\\n        while s <= e:\\n            mid = (e-s)//2 + s\\n            # print(s, e, mid)\\n            if (mid == 0 or nums[mid-1] != nums[mid]) and (mid == ln-1 or nums[mid+1] != nums[mid]):\\n                return nums[mid]\\n            # total elements on left of mid including mid is (mid+1)\\n            # case 1: mid-1 == mid and elements on left including mid are even\\n            # case 2: mid+1 == mid and elements on left excluding mid are even\\n            # for case 1 and case 2: s = mid + 1 or s = mid + 2 (for case 2, mid == mid+1)\\n            # so can move to mid + 2\\n            if(mid == 0 or nums[mid-1] == nums[mid]) and (mid+1) % 2 == 0:\\n                s = mid + 1\\n            elif (mid == ln-1 or nums[mid+1] == nums[mid]) and (mid) % 2 == 0:\\n                s = mid + 2\\n            else:\\n                e = mid - 1\\n        \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "\\tdef singleNonDuplicate(self, nums: List[int]) -> int:\\n        ln = len(nums)\\n        if ln == 1:\\n            return nums[0]\\n        \\n        s, e = 0, ln-1\\n        while s <= e:\\n            mid = (e-s)//2 + s\\n            # print(s, e, mid)\\n            if (mid == 0 or nums[mid-1] != nums[mid]) and (mid == ln-1 or nums[mid+1] != nums[mid]):\\n                return nums[mid]\\n            # total elements on left of mid including mid is (mid+1)\\n            # case 1: mid-1 == mid and elements on left including mid are even\\n            # case 2: mid+1 == mid and elements on left excluding mid are even\\n            # for case 1 and case 2: s = mid + 1 or s = mid + 2 (for case 2, mid == mid+1)\\n            # so can move to mid + 2\\n            if(mid == 0 or nums[mid-1] == nums[mid]) and (mid+1) % 2 == 0:\\n                s = mid + 1\\n            elif (mid == ln-1 or nums[mid+1] == nums[mid]) and (mid) % 2 == 0:\\n                s = mid + 2\\n            else:\\n                e = mid - 1\\n        \\n        return -1",
                "codeTag": "Python3"
            },
            {
                "id": 187532,
                "title": "python-binary-search-o-logn",
                "content": "```\\nclass Solution(object):\\n    def singleNonDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) < 1:\\n            return None\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            m = l + (r - l)/2\\n            if m - 1 < l or m + 1 > r:\\n                break\\n            if m % 2 == 0:\\n                if nums[m] == nums[m+1]:\\n                    l = m + 2\\n                else:\\n                    r = m\\n            else:\\n                if nums[m] == nums[m-1]:\\n                    l = m + 1\\n                else:\\n                    r = m\\n        return nums[l]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def singleNonDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) < 1:\\n            return None\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            m = l + (r - l)/2\\n            if m - 1 < l or m + 1 > r:\\n                break\\n            if m % 2 == 0:\\n                if nums[m] == nums[m+1]:\\n                    l = m + 2\\n                else:\\n                    r = m\\n            else:\\n                if nums[m] == nums[m-1]:\\n                    l = m + 1\\n                else:\\n                    r = m\\n        return nums[l]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517761,
                "title": "very-simple-easy-to-understand-0ms-c-soln",
                "content": "\\n\\n# Approach\\n\\n    Let There be 2 arrays .\\n    a1 = [1,1,2,2,3,3,4,4]; -> point 1\\n    a2  = [1,1,2,2,3,3]; -> point 2\\n\\n    here , let start = 0 , end = arr.size() -1;\\n\\n    a1 has even no of pairs  = 4 , s = 0 , e = 7;\\n    a2 has odd no of pairs  = 3 , s = 0, e = 5;\\n\\n    Let us assume 1 element added to the 2 arrays .\\n    now,\\n    for a1 -> s = 0, e = 8; pairs = (s-e)/2 = 4;\\n    for a2 -> s = 0 , e = 6; pairs = (s-e)/2 = 3;\\n\\n    now when you find mid for both the arrays ;\\n    m = (s+e)/2;\\n    for a1; \\n        m = (0+8)/2 = 4;\\n        from point 1 you can see that nums[m] = 3 and nums[m+1] also 3;\\n        This means , \\n        if we get nums[m]=nums[m+1] then element to be found will be on right\\n        if not this means the a1 in point1 is shifted by 1 space which is present on left of m;\\n    \\n\\n    for a2; \\n        m = (0+6)/2 = 3;\\n        from point 1 you can see that nums[m] = 2 and nums[m-1] also 2;\\n        This means , \\n        if we get nums[m]=nums[m-1] then element to be found will be on right\\n        if not this means the a1 in point1 is shifted by 1 space which is present on left of m;\\n\\n    PLEASE UPVOTE;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size() ,s = 0, e = n-1;// x  =  number of pairs excluding single element\\n        if(n==1 || nums[0]!=nums[1]) // if nums have single element or first element is the answer\\n            return nums[0];\\n        if(nums[n-2]!=nums[n-1]) // if last element is the answer\\n            return nums[n-1];\\n        while(s<=e){\\n            int m = (s+e)/2 , x = (s-e)/2;\\n            if(nums[m]!=nums[m+1] && nums[m]!=nums[m-1])\\n                return nums[m];\\n            if(x%2==0) // even number of pairs\\n            {\\n                if(nums[m-1]==nums[m]) // move left\\n                    e=m-2;\\n                else // move right\\n                    s=m+2;\\n            }\\n            else // odd number of pairs \\n            {\\n                if(nums[m-1]==nums[m]) // move right\\n                    s=m+1;\\n                else // move left\\n                    e=m-1;\\n            }\\n        }\\n        return -1; // PLEASE UPVOTE \\uD83E\\uDD7A\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size() ,s = 0, e = n-1;// x  =  number of pairs excluding single element\\n        if(n==1 || nums[0]!=nums[1]) // if nums have single element or first element is the answer\\n            return nums[0];\\n        if(nums[n-2]!=nums[n-1]) // if last element is the answer\\n            return nums[n-1];\\n        while(s<=e){\\n            int m = (s+e)/2 , x = (s-e)/2;\\n            if(nums[m]!=nums[m+1] && nums[m]!=nums[m-1])\\n                return nums[m];\\n            if(x%2==0) // even number of pairs\\n            {\\n                if(nums[m-1]==nums[m]) // move left\\n                    e=m-2;\\n                else // move right\\n                    s=m+2;\\n            }\\n            else // odd number of pairs \\n            {\\n                if(nums[m-1]==nums[m]) // move right\\n                    s=m+1;\\n                else // move left\\n                    e=m-1;\\n            }\\n        }\\n        return -1; // PLEASE UPVOTE \\uD83E\\uDD7A\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408082,
                "title": "easy-5-line-solution-java-100-beats-0ms",
                "content": "# Intuition\\nonly odd number of elements will contain 1 non duplicate elment\\n# Approach\\nmove towards the segment which has odd number of elements \\n```\\n//checking for odd sequence\\n        if((high+1-mid)%2!=0)  return solve(low,mid,nums);\\n//checking for odd sequence\\n        if((high+1-mid+1)%2!=0) return solve(mid+1,high,nums);\\n```\\nand try to check if true then increamment mid so that we end up having non duplicate on the left segment.\\n``` if(nums[mid]==nums[mid+1]) mid++;```\\n\\n# Complexity\\n- Time complexity:\\n0ms 100% beats\\n\\n# Code\\n```\\nclass Solution {\\n    int solve(int low,int high,int[] nums)\\n    {\\n        int mid=(low+high)/2; \\n// special condition sometimes occurs while serching for duplicate\\n //and it contains non duplicate value thus returning it as well\\n        if(high==low)return nums[low];\\n        if(nums[mid]==nums[mid+1]) mid++;\\n//stoppping the recursion  at 3 elements and it is obvious that \\n // 1 element will be non duplicate among 3 elemnts thus returning it\\n        if(high-low==2) return(nums[high]^nums[mid]^nums[low]);\\n//checking for odd sequence\\n        if((high+1-mid)%2!=0)  return solve(low,mid,nums);\\n//checking for odd sequence\\n        if((high+1-mid+1)%2!=0) return solve(mid+1,high,nums);\\n        return -1;\\n    }\\n    public int singleNonDuplicate(int[] nums) {\\n        return solve(0,nums.length-1,nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n//checking for odd sequence\\n        if((high+1-mid)%2!=0)  return solve(low,mid,nums);\\n//checking for odd sequence\\n        if((high+1-mid+1)%2!=0) return solve(mid+1,high,nums);\\n```\n``` if(nums[mid]==nums[mid+1]) mid++;```\n```\\nclass Solution {\\n    int solve(int low,int high,int[] nums)\\n    {\\n        int mid=(low+high)/2; \\n// special condition sometimes occurs while serching for duplicate\\n //and it contains non duplicate value thus returning it as well\\n        if(high==low)return nums[low];\\n        if(nums[mid]==nums[mid+1]) mid++;\\n//stoppping the recursion  at 3 elements and it is obvious that \\n // 1 element will be non duplicate among 3 elemnts thus returning it\\n        if(high-low==2) return(nums[high]^nums[mid]^nums[low]);\\n//checking for odd sequence\\n        if((high+1-mid)%2!=0)  return solve(low,mid,nums);\\n//checking for odd sequence\\n        if((high+1-mid+1)%2!=0) return solve(mid+1,high,nums);\\n        return -1;\\n    }\\n    public int singleNonDuplicate(int[] nums) {\\n        return solve(0,nums.length-1,nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214381,
                "title": "beats-91-47-c-binary-search-easy",
                "content": "# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//index of form:(even,odd) before pivot and of form (odd,even) after pivot for equal elements\\n    int singleNonDuplicate(vector<int>&nums) \\n    {\\n        int left=0,right=nums.size()-1;\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n            if(left==right)\\n            {\\n                return nums[mid];\\n            }\\n            if(mid==0 && nums[mid+1]!=nums[mid])\\n            {\\n                return nums[mid];\\n            }\\n            if(nums[mid+1]!=nums[mid] && nums[mid-1]!=nums[mid])\\n            {\\n                return nums[mid];\\n            }\\n            else if((nums[mid+1]==nums[mid] && mid%2==1)||(nums[mid-1]==nums[mid] && mid%2==0))\\n            {\\n                right=mid-1;\\n            }\\n            else if((nums[mid+1]==nums[mid] && mid%2==0)||(nums[mid-1]==nums[mid] && mid%2==1))\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//index of form:(even,odd) before pivot and of form (odd,even) after pivot for equal elements\\n    int singleNonDuplicate(vector<int>&nums) \\n    {\\n        int left=0,right=nums.size()-1;\\n        while(left<=right)\\n        {\\n            int mid=(left+right)/2;\\n            if(left==right)\\n            {\\n                return nums[mid];\\n            }\\n            if(mid==0 && nums[mid+1]!=nums[mid])\\n            {\\n                return nums[mid];\\n            }\\n            if(nums[mid+1]!=nums[mid] && nums[mid-1]!=nums[mid])\\n            {\\n                return nums[mid];\\n            }\\n            else if((nums[mid+1]==nums[mid] && mid%2==1)||(nums[mid-1]==nums[mid] && mid%2==0))\\n            {\\n                right=mid-1;\\n            }\\n            else if((nums[mid+1]==nums[mid] && mid%2==0)||(nums[mid-1]==nums[mid] && mid%2==1))\\n            {\\n                left=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214175,
                "title": "best-c-solution-beats-87-intuition-explained-o-logn-tc-o-1-sc",
                "content": "Follow Daily Dose of DSA Blog where I post important DSA Questions and different approaches for solving it!!!\\nhttps://legolas12.hashnode.dev/\\n![Single Element in a Sorted Array - LeetCode - Google Chrome 21-02-2023 16_04_47.png](https://assets.leetcode.com/users/images/5f33b65e-2be7-4693-8ee4-0611376ab373_1676975767.743381.png)\\n\\n# Intuition \\nAs we all know the element can be found by binary search. But to decide the region we have to write the check function .Lets assume the required element is in the right region. Then we have two cases \\n1) mid is 1st element in the pair\\n2) mid is 2nd element in the pair\\n\\n1st case: if mid is 1st element in the pair and required singleton element is in right region. Then left of mid has even number of elements (present in pairs) \\n2nd case: if mid is 2nd element in the pair and required singleton element is in the right region . Then left of mid has odd number of elements (elements in pair + pair of mid)\\nwhile checking mid is even or odd be aware of the 0 based indexing which will reverse the meaning of even and odd.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMade two check functions . Check 1 for checking mid has dissimilar elements to the right and left , if present return mid.\\nI have written Check 2 if the element is present in the right region.\\nand remaining all cases are covered in else statement.\\n\\n\\nBasic Intuition for writing this check function is written above\\nThen finally wrote BS code with this two check functions . Corner cases are handled seperately.\\n```\\nbool check(vector<int> &nums , int x )\\n    {\\n        if(nums[x]!=nums[x+1] && nums[x]!=nums[x-1])\\n        {\\n            return true;\\n        }\\n        else return false;\\n    } \\n\\nbool check2(vector<int> &nums , int x)\\n    {\\n        if((nums[x]==nums[x+1] && x%2==0) || (nums[x]==nums[x-1] && x%2!=0))\\n        {\\n            return true;\\n        }\\n        else return false;\\n    }\\n```\\n\\n# Complexity\\n- Time complexity: O(logn)\\n\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check(vector<int> &nums , int x )\\n    {\\n        if(nums[x]!=nums[x+1] && nums[x]!=nums[x-1])\\n        {\\n            return true;\\n        }\\n        else return false;\\n    } \\n\\n    bool check2(vector<int> &nums , int x)\\n    {\\n        if((nums[x]==nums[x+1] && x%2==0) || (nums[x]==nums[x-1] && x%2!=0))\\n        {\\n            return true;\\n        }\\n        else return false;\\n    }\\n    int singleNonDuplicate(vector<int>& nums) \\n {\\n        int n =(int)nums.size();\\n       \\n        int ans;\\n        int low = 0 , high= n-1;\\n         if(n==1) return nums[0];\\n        if(nums[0]!=nums[1]) return nums[0];\\n\\n        if(nums[high]!=nums[high-1]) return nums[high];\\n        while(low<high)\\n        {\\n            int mid = (low+high)/2;\\n            if(check(nums,mid))\\n            {\\n               return nums[mid];\\n            }\\n            else if(check2(nums,mid))\\n            {\\n             low = mid+1;\\n            }\\n\\n           else high=mid-1;\\n        }\\n     \\n       return nums[low];\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nbool check(vector<int> &nums , int x )\\n    {\\n        if(nums[x]!=nums[x+1] && nums[x]!=nums[x-1])\\n        {\\n            return true;\\n        }\\n        else return false;\\n    } \\n\\nbool check2(vector<int> &nums , int x)\\n    {\\n        if((nums[x]==nums[x+1] && x%2==0) || (nums[x]==nums[x-1] && x%2!=0))\\n        {\\n            return true;\\n        }\\n        else return false;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n\\n    bool check(vector<int> &nums , int x )\\n    {\\n        if(nums[x]!=nums[x+1] && nums[x]!=nums[x-1])\\n        {\\n            return true;\\n        }\\n        else return false;\\n    } \\n\\n    bool check2(vector<int> &nums , int x)\\n    {\\n        if((nums[x]==nums[x+1] && x%2==0) || (nums[x]==nums[x-1] && x%2!=0))\\n        {\\n            return true;\\n        }\\n        else return false;\\n    }\\n    int singleNonDuplicate(vector<int>& nums) \\n {\\n        int n =(int)nums.size();\\n       \\n        int ans;\\n        int low = 0 , high= n-1;\\n         if(n==1) return nums[0];\\n        if(nums[0]!=nums[1]) return nums[0];\\n\\n        if(nums[high]!=nums[high-1]) return nums[high];\\n        while(low<high)\\n        {\\n            int mid = (low+high)/2;\\n            if(check(nums,mid))\\n            {\\n               return nums[mid];\\n            }\\n            else if(check2(nums,mid))\\n            {\\n             low = mid+1;\\n            }\\n\\n           else high=mid-1;\\n        }\\n     \\n       return nums[low];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214037,
                "title": "runtime-0-ms-clear-and-easy-solution",
                "content": "# Intuition\\nIf the number in the current index is not equal to one of the numbers on either side, then the number we are looking for is that\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nRuntime : 0 ms      Beats : 100%\\nMemory :48 MB       Beats  :72.85%\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        if(nums.length == 1 ) return nums[0];\\n\\n        if(nums[0] != nums[1]) return nums[0]; // first index\\n        if(nums[nums.length-1] != nums[nums.length-2]) return nums[nums.length-1]; // last index \\n\\n        for (int i = 1; i < nums.length-1; i++) {\\n            if(!isD(nums,i)){\\n                return nums[i];\\n            }\\n        }\\n    \\n        return -1;\\n\\n    }\\n    private static boolean isD(int[] nums, int index){\\n        return nums[index - 1] == nums[index] || nums[index] == nums[index + 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        if(nums.length == 1 ) return nums[0];\\n\\n        if(nums[0] != nums[1]) return nums[0]; // first index\\n        if(nums[nums.length-1] != nums[nums.length-2]) return nums[nums.length-1]; // last index \\n\\n        for (int i = 1; i < nums.length-1; i++) {\\n            if(!isD(nums,i)){\\n                return nums[i];\\n            }\\n        }\\n    \\n        return -1;\\n\\n    }\\n    private static boolean isD(int[] nums, int index){\\n        return nums[index - 1] == nums[index] || nums[index] == nums[index + 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212720,
                "title": "binary-search-easy-left-and-right-half-approach",
                "content": "# Intuition\\ncheck for left half and right half\\n\\n# Approach\\nobservation->in left half odd index->2nd occurance of some no\\neven index->1st occurance of no\\nin right half\\nodd index ->first occurance of no\\neven index->second occurance\\naccording reduce search space by applying mid+1 or mid-1 for \\nperticular conditions\\nIF (YOU UNDERSTOOD THIS SOLUTION){UPVOTE}\\nELSE {CHECK CODE AND THEN UPVOTE}\\n\\n# Complexity\\n- Time complexity:\\no(log(n))\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-2;\\n        int mid=s+(e-s)/2;\\n        while(s<=e)\\n        {\\n\\n            if((mid&1)==0)\\n                {if(nums[mid]==nums[mid+1])\\n                {\\n                    s=mid+1;\\n                }\\n                else{\\n                    e=mid-1;\\n                }\\n            }\\n            else{\\n                if(nums[mid]==nums[mid+1])\\n                {\\n                    e=mid-1;\\n                }\\n                else\\n                {\\n                    s=mid+1;\\n                }\\n            }\\n            mid=s+(e-s)/2;\\n\\n        }\\n         return nums[mid];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int s=0;\\n        int e=nums.size()-2;\\n        int mid=s+(e-s)/2;\\n        while(s<=e)\\n        {\\n\\n            if((mid&1)==0)\\n                {if(nums[mid]==nums[mid+1])\\n                {\\n                    s=mid+1;\\n                }\\n                else{\\n                    e=mid-1;\\n                }\\n            }\\n            else{\\n                if(nums[mid]==nums[mid+1])\\n                {\\n                    e=mid-1;\\n                }\\n                else\\n                {\\n                    s=mid+1;\\n                }\\n            }\\n            mid=s+(e-s)/2;\\n\\n        }\\n         return nums[mid];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212461,
                "title": "python-short-and-clean-binary-search",
                "content": "# Approach\\n1. Since `nums` is sorted and it is guaranteed that all but one number occurs exactly twice. We can binary search for the number with no pair.\\n\\n2. Say `m` is the mid point in the search and if all numbers had pairs,\\n    If `m` is even index, the repeating pair should be at `m + 1`.\\n    If `m` is odd index, the repeating pair should be at `m - 1`.\\n    Let\\'s call them `i, j = (m - 1, m) if m % 2 else (m, m + 1)`\\n\\n3. Now, if `nums[i] == nums[j]` we know all numbers to the left of `j` has a pair. Hence Binary Search on the right sub array.\\n    If `nums[i] != nums[j]` we know the additional number is to the left of `j`. Hence Binary Search on the left sub array.\\n\\n4. Return when `i == j`.\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere, `n is the length of nums`.\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: list[int]) -> int:\\n        l, r = 0, len(nums) - 1\\n        while l < r:\\n            m = (l + r) // 2\\n            i, j = (m - 1, m) if m % 2 else (m, m + 1)\\n            l, r = (j + 1, r) if nums[i] == nums[j] else (l, i)\\n        return nums[r]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: list[int]) -> int:\\n        l, r = 0, len(nums) - 1\\n        while l < r:\\n            m = (l + r) // 2\\n            i, j = (m - 1, m) if m % 2 else (m, m + 1)\\n            l, r = (j + 1, r) if nums[i] == nums[j] else (l, i)\\n        return nums[r]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212316,
                "title": "python-c-clean-and-concise-solution-o-logn-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code Upvote please\\uD83D\\uDE4C\\uD83D\\uDE09\\n```\\nclass Solution(object):\\n    def singleNonDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        start , end = 0 , len(nums) -1\\n        while start < end :\\n            mid = (start + end) // 2\\n            if(nums[mid]==nums[mid+1]):\\n                mid = mid-1\\n            \\n            if((mid-start+1)%2!=0):\\n                end = mid\\n            \\n            else:\\n                start = mid+1\\n        return nums[start]\\n            \\n```\\n\\n# UPVOTE ME \\uD83D\\uDE09\\uD83E\\uDD1E\\uD83D\\uDE22",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def singleNonDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        start , end = 0 , len(nums) -1\\n        while start < end :\\n            mid = (start + end) // 2\\n            if(nums[mid]==nums[mid+1]):\\n                mid = mid-1\\n            \\n            if((mid-start+1)%2!=0):\\n                end = mid\\n            \\n            else:\\n                start = mid+1\\n        return nums[start]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212039,
                "title": "daily-leetcoding-challenge-february-day-21",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-element-in-a-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n**Approach 3:** Binary Search on Evens Indexes Only\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/single-element-in-a-sorted-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3172003,
                "title": "simple-c-code-in-log-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n=nums.size(),l=0,r=n-1,m;\\n            while(l<r){\\n            m=l+(r-l)/2;\\n            if(m%2==0){\\n                if(nums[m]==nums[m+1]) l=m+1;\\n                else {r=m;} }\\n            else{\\n                if(nums[m]!=nums[m+1]) l=m+1;\\n                else {r=m;}\\n            }\\n            }\\n            return nums[l];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n=nums.size(),l=0,r=n-1,m;\\n            while(l<r){\\n            m=l+(r-l)/2;\\n            if(m%2==0){\\n                if(nums[m]==nums[m+1]) l=m+1;\\n                else {r=m;} }\\n            else{\\n                if(nums[m]!=nums[m+1]) l=m+1;\\n                else {r=m;}\\n            }\\n            }\\n            return nums[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102142,
                "title": "best-o-logn-solution",
                "content": "# Approach 1\\nXOR\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            ans = ans ^ nums[i];\\n        return ans; \\n    }\\n};\\n```\\n# Approach 2\\nLinear Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        for (int i = 1; i < n; i = i + 2)\\n            if (nums[i - 1] != nums[i])\\n                return nums[i - 1];\\n        return nums[n - 1];    \\n    }\\n};\\n```\\n\\n# Approach 3\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        if (nums[0] != nums[1])\\n            return nums[0];    \\n        int low = 0, high = n - 1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if ((nums[mid] != nums[mid - 1] || mid == 0) &&\\n                (nums[mid] != nums[mid + 1] || mid == n - 1))\\n                return nums[mid];\\n             else if ((mid % 2 == 0 && nums[mid] == nums[mid - 1]) || \\n                (mid % 2 == 1 && nums[mid] == nums[mid + 1])) \\n                high = mid - 1;\\n            else\\n                low = mid + 1; \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++)\\n            ans = ans ^ nums[i];\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        for (int i = 1; i < n; i = i + 2)\\n            if (nums[i - 1] != nums[i])\\n                return nums[i - 1];\\n        return nums[n - 1];    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        if (nums[0] != nums[1])\\n            return nums[0];    \\n        int low = 0, high = n - 1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if ((nums[mid] != nums[mid - 1] || mid == 0) &&\\n                (nums[mid] != nums[mid + 1] || mid == n - 1))\\n                return nums[mid];\\n             else if ((mid % 2 == 0 && nums[mid] == nums[mid - 1]) || \\n                (mid % 2 == 1 && nums[mid] == nums[mid + 1])) \\n                high = mid - 1;\\n            else\\n                low = mid + 1; \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076115,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int l=0;\\n        int h=nums.size()-1;\\n        int m;\\n        if(nums.size()==1)\\n            return nums[0];\\n        while(l<h)\\n        {\\n            m=(l+h)/2;\\n            cout<<m<<l<<h<<\" \";\\n            int e=((h-m)%2==0);\\n            if(nums[m]==nums[m-1])\\n            {\\n                if(e)\\n                    h=m-2;\\n                else\\n                    l=m+1;\\n            }\\n            else if(nums[m]==nums[m+1])\\n                if(e)\\n                    l=m+2;\\n                else\\n                    h=m-1;\\n            else\\n                return nums[m];\\n        }\\n        return nums[(l+h)/2];\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int l=0;\\n        int h=nums.size()-1;\\n        int m;\\n        if(nums.size()==1)\\n            return nums[0];\\n        while(l<h)\\n        {\\n            m=(l+h)/2;\\n            cout<<m<<l<<h<<\" \";\\n            int e=((h-m)%2==0);\\n            if(nums[m]==nums[m-1])\\n            {\\n                if(e)\\n                    h=m-2;\\n                else\\n                    l=m+1;\\n            }\\n            else if(nums[m]==nums[m+1])\\n                if(e)\\n                    l=m+2;\\n                else\\n                    h=m-1;\\n            else\\n                return nums[m];\\n        }\\n        return nums[(l+h)/2];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2975730,
                "title": "java-2-line-code-hashmap",
                "content": "**PLEASE** **UPVOTE**, **IF YOU LIKE IT**\\n# Code\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\\n        for (int i : arr) if (map.get(i) == 1) return i;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\\n        for (int i : arr) if (map.get(i) == 1) return i;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832600,
                "title": "python-easy-solution-sorting-list",
                "content": "\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        r=len(nums)\\n        l=0\\n        while l<r:\\n            mid=l+(r-l)//2\\n            if mid>0 and mid<len(nums)-1:\\n                if nums[mid]==nums[mid-1]:\\n                    if mid%2==0:\\n                        r=mid-1\\n                    else:\\n                        l=mid+1\\n                elif nums[mid]==nums[mid+1]:\\n                    if mid%2==0:\\n                        l=mid+1\\n                    else:\\n                        r=mid-1\\n                elif nums[mid]!=nums[mid-1] and nums[mid]!=nums[mid+1]:\\n                    return nums[mid]\\n            else:\\n                return nums[mid]\\n        return nums[l]\\n            \\n\\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        r=len(nums)\\n        l=0\\n        while l<r:\\n            mid=l+(r-l)//2\\n            if mid>0 and mid<len(nums)-1:\\n                if nums[mid]==nums[mid-1]:\\n                    if mid%2==0:\\n                        r=mid-1\\n                    else:\\n                        l=mid+1\\n                elif nums[mid]==nums[mid+1]:\\n                    if mid%2==0:\\n                        l=mid+1\\n                    else:\\n                        r=mid-1\\n                elif nums[mid]!=nums[mid-1] and nums[mid]!=nums[mid+1]:\\n                    return nums[mid]\\n            else:\\n                return nums[mid]\\n        return nums[l]\\n            \\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2814568,
                "title": "easiest-c-solution-using-bit-manipulation",
                "content": "# Intuition\\nBitwise XOR operator (^):\\n1^0 = 1\\n0^0 = 0\\n1^1 = 0\\nXOR of same number gives 0 as an output\\n\\n\\n# Approach\\nEvery element appears exactly twice, except for one element which appears exactly once, Therefore only the single element reamains after xor of all the numbers\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int a = 0;\\n       for(int i=0; i<nums.size(); i++){\\n           a^=nums[i];\\n       }\\n       return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int a = 0;\\n       for(int i=0; i<nums.size(); i++){\\n           a^=nums[i];\\n       }\\n       return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2651686,
                "title": "c-binary-search-check-odd-lengths",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int start = 0, end = nums.size()-1;\\n        int n = nums.size();\\n        \\n        if(n == 1) return nums[0];\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end - start)/2;\\n            // This two if else are for edge conditons \\n            if(mid == 0 && nums[mid] != nums[mid + 1])\\n            {\\n                return nums[mid];\\n            }\\n            else if(mid == n-1 && nums[mid] != nums[n-2])\\n            {\\n                return nums[mid];\\n            }\\n            // This checks which subarray is having odd length, and move start & end accordingly\\n            else if(nums[mid] == nums[mid-1])\\n            {\\n                int left_sub = (mid - start) + 1;\\n                int right_sub = (end - mid);\\n                \\n                if(left_sub%2 != 0) end = mid;\\n                else start = mid + 1;\\n            }\\n            else if(nums[mid] == nums[mid+1])\\n            {\\n                int right_sub = (end - mid) + 1; \\n                int left_sub = mid - start;\\n                \\n                if(right_sub%2 != 0) start = mid;\\n                else end = mid - 1;\\n            }\\n            else return nums[mid];\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int start = 0, end = nums.size()-1;\\n        int n = nums.size();\\n        \\n        if(n == 1) return nums[0];\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end - start)/2;\\n            // This two if else are for edge conditons \\n            if(mid == 0 && nums[mid] != nums[mid + 1])\\n            {\\n                return nums[mid];\\n            }\\n            else if(mid == n-1 && nums[mid] != nums[n-2])\\n            {\\n                return nums[mid];\\n            }\\n            // This checks which subarray is having odd length, and move start & end accordingly\\n            else if(nums[mid] == nums[mid-1])\\n            {\\n                int left_sub = (mid - start) + 1;\\n                int right_sub = (end - mid);\\n                \\n                if(left_sub%2 != 0) end = mid;\\n                else start = mid + 1;\\n            }\\n            else if(nums[mid] == nums[mid+1])\\n            {\\n                int right_sub = (end - mid) + 1; \\n                int left_sub = mid - start;\\n                \\n                if(right_sub%2 != 0) start = mid;\\n                else end = mid - 1;\\n            }\\n            else return nums[mid];\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372321,
                "title": "easy-python-special-answer",
                "content": "class Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        r=0\\n        for i in range(len(nums)):\\n            r=r^nums[i]\\n        return r",
                "solutionTags": [],
                "code": "class Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        r=0\\n        for i in range(len(nums)):\\n            r=r^nums[i]\\n        return r",
                "codeTag": "Java"
            },
            {
                "id": 1833019,
                "title": "java-solution-0-ms-explained-in-comments",
                "content": "```class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        //set the low and high pointers\\n        int lo = 0; //lo points at first index \\n        int hi = nums.length - 1; //high points at last index \\n        int mid = 0; //mid\\n        \\n        //checking the boundary conditions\\n        if( nums.length == 1) //if there is only one element in the array nums\\n            return nums[0]; //return that single element\\n        \\n        else if( nums[0] != nums[1]) //if the unique element is at the first index\\n            return nums[0];\\n        \\n        else if( nums[hi] != nums[hi-1]) //if the unique element is at the last index\\n            return nums[hi];\\n\\n        //apply binary search\\n        /*\\n        The idea is: unless the unique element appears in the array, \\n        for every pair of duplicates, \\n        the first term appears at even index & the 2nd term appears at odd index.\\n        Once the unique element is appears, for every pair of duplicates,\\n        the first term appears at odd index & the 2nd term appears at even index.\\n        */\\n        while( lo <= hi)\\n        {\\n            mid = lo + (hi - lo)/2;\\n        \\n            //if the mid element is unique, i.e it is not equal to its neighbours\\n            if( nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1])\\n                return nums[mid]; //return element at mid\\n            /*\\n            If the mid is even, and the element at index mid is equal to its next element\\n            that means, the unique element lies somewhere in the second half. \\n            So, low pointer is updated.\\n            Also, if the mid index is odd and the element at mid is equal \\n            to its previous element, in that case too, unique element lies towards the left\\n            So, low is updated*/\\n            else if( (mid % 2 == 0) && (nums[mid] == nums[mid+1]) ||\\n                   (mid%2 == 1) && nums[mid] == nums[mid-1])\\n                lo = mid+1;\\n            else //otherwise, hi is updated\\n                hi = mid -1 ;\\n        }\\n        \\n        return -1; \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        //set the low and high pointers\\n        int lo = 0; //lo points at first index \\n        int hi = nums.length - 1; //high points at last index \\n        int mid = 0; //mid\\n        \\n        //checking the boundary conditions\\n        if( nums.length == 1) //if there is only one element in the array nums\\n            return nums[0]; //return that single element\\n        \\n        else if( nums[0] != nums[1]) //if the unique element is at the first index\\n            return nums[0];\\n        \\n        else if( nums[hi] != nums[hi-1]) //if the unique element is at the last index\\n            return nums[hi];\\n\\n        //apply binary search\\n        /*\\n        The idea is: unless the unique element appears in the array, \\n        for every pair of duplicates, \\n        the first term appears at even index & the 2nd term appears at odd index.\\n        Once the unique element is appears, for every pair of duplicates,\\n        the first term appears at odd index & the 2nd term appears at even index.\\n        */\\n        while( lo <= hi)\\n        {\\n            mid = lo + (hi - lo)/2;\\n        \\n            //if the mid element is unique, i.e it is not equal to its neighbours\\n            if( nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1])\\n                return nums[mid]; //return element at mid\\n            /*\\n            If the mid is even, and the element at index mid is equal to its next element\\n            that means, the unique element lies somewhere in the second half. \\n            So, low pointer is updated.\\n            Also, if the mid index is odd and the element at mid is equal \\n            to its previous element, in that case too, unique element lies towards the left\\n            So, low is updated*/\\n            else if( (mid % 2 == 0) && (nums[mid] == nums[mid+1]) ||\\n                   (mid%2 == 1) && nums[mid] == nums[mid-1])\\n                lo = mid+1;\\n            else //otherwise, hi is updated\\n                hi = mid -1 ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1587637,
                "title": "javascript-binary-search-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n  // because it is a sorted array, every element appears in pairs\\n  // this means, we can check the adjacent digit as our search target\\n  let lo = -1, hi = nums.length - 1;\\n  while (lo + 1 < hi) {\\n    let mid = lo + Math.floor((hi - lo) / 2);\\n    if (isValid(mid, nums)) {\\n      lo = mid;\\n    } else {\\n      hi = mid;\\n    }\\n  }\\n  return nums[hi];\\n};\\n\\nfunction isValid(index, nums) {\\n  // 0 based array, so index is even means, the next\\n  // element should be same as this one\\n  if (index % 2 === 0) {\\n    return nums[index + 1] === nums[index];\\n  } else {\\n    return nums[index + 1] !== nums[index];\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n  // because it is a sorted array, every element appears in pairs\\n  // this means, we can check the adjacent digit as our search target\\n  let lo = -1, hi = nums.length - 1;\\n  while (lo + 1 < hi) {\\n    let mid = lo + Math.floor((hi - lo) / 2);\\n    if (isValid(mid, nums)) {\\n      lo = mid;\\n    } else {\\n      hi = mid;\\n    }\\n  }\\n  return nums[hi];\\n};\\n\\nfunction isValid(index, nums) {\\n  // 0 based array, so index is even means, the next\\n  // element should be same as this one\\n  if (index % 2 === 0) {\\n    return nums[index + 1] === nums[index];\\n  } else {\\n    return nums[index + 1] !== nums[index];\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1507146,
                "title": "very-easy-java-solution",
                "content": "I used XOR operator here\\n\\'\\'\\'\\nint ans = nums[0];\\n        for(int  i=1;i<nums.length;i++)\\n        {\\n            ans ^=nums[i];\\n        }\\n        return ans;\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "I used XOR operator here\\n\\'\\'\\'\\nint ans = nums[0];\\n        for(int  i=1;i<nums.length;i++)\\n        {\\n            ans ^=nums[i];\\n        }\\n        return ans;\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1300467,
                "title": "java-easy-and-clear-solution-binray-search-iterative-tc-o-logn-sc-o-1",
                "content": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0];\\n        \\n        int low=0,high=n-1,mid;\\n        while(low <= high)\\n        {\\n\\t\\t\\t// To avoid Integer overflow\\n            mid = low + (high-low)/2;\\n            \\n            // to handle edge cases\\n            if(mid == 0)\\n            {\\n                if(nums[mid] != nums[mid+1]) return nums[mid];\\n            }\\n            if(mid == n-1)\\n            {\\n                if(nums[mid] != nums[mid-1]) return nums[mid];\\n            }\\n            \\n\\t\\t\\t// Checking if mid element is single element by comparing it with neighbour elements\\n            if (nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]) return nums[mid];\\n            else // i.e. either element is equal to its prev or next element \\n            {\\n                if(nums[mid] == nums[mid-1])\\n                {\\n                    if(mid % 2 == 0) high = mid-1; \\n                    else low = mid + 1;\\n                }\\n                else // here nums[mid]  = nums[mid+1]\\n                {\\n                    if(mid % 2 == 0) low = mid + 1;\\n                    else high = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0];\\n        \\n        int low=0,high=n-1,mid;\\n        while(low <= high)\\n        {\\n\\t\\t\\t// To avoid Integer overflow\\n            mid = low + (high-low)/2;\\n            \\n            // to handle edge cases\\n            if(mid == 0)\\n            {\\n                if(nums[mid] != nums[mid+1]) return nums[mid];\\n            }\\n            if(mid == n-1)\\n            {\\n                if(nums[mid] != nums[mid-1]) return nums[mid];\\n            }\\n            \\n\\t\\t\\t// Checking if mid element is single element by comparing it with neighbour elements\\n            if (nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]) return nums[mid];\\n            else // i.e. either element is equal to its prev or next element \\n            {\\n                if(nums[mid] == nums[mid-1])\\n                {\\n                    if(mid % 2 == 0) high = mid-1; \\n                    else low = mid + 1;\\n                }\\n                else // here nums[mid]  = nums[mid+1]\\n                {\\n                    if(mid % 2 == 0) low = mid + 1;\\n                    else high = mid - 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934566,
                "title": "binary-search-easy-explained",
                "content": "```\\nclass Solution {\\n    \\n// the idea is to use binary search, \\n// we need to find the first place where an odd is not equal to\\n// last even or even is not equal to next odd.\\n// because the array start as something like 1, 1, so even 0 \\n// equal next odd 1, (we use xor to find next odd or last even)\\n    \\n// so if we find things are abiding this condition, we move to\\n// right subarray, else move to left to find origin of this\\n// pattern shift.\\n    \\n// remember we can\\'t check consecutive odd/even in case there is \\n// only one element in the array\\n    \\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        \\n        if(nums.size() == 1)\\n            return nums[0];\\n        \\n        int left = 0, right = nums.size();\\n        while(left < right){\\n            \\n            int mid = (left+right)/2;\\n\\n            if(nums[mid] == nums[mid^1])\\n                left = mid+1;\\n            \\n            else\\n                right = mid;\\n        }\\n        \\n        return nums[left];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n// the idea is to use binary search, \\n// we need to find the first place where an odd is not equal to\\n// last even or even is not equal to next odd.\\n// because the array start as something like 1, 1, so even 0 \\n// equal next odd 1, (we use xor to find next odd or last even)\\n    \\n// so if we find things are abiding this condition, we move to\\n// right subarray, else move to left to find origin of this\\n// pattern shift.\\n    \\n// remember we can\\'t check consecutive odd/even in case there is \\n// only one element in the array\\n    \\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        \\n        if(nums.size() == 1)\\n            return nums[0];\\n        \\n        int left = 0, right = nums.size();\\n        while(left < right){\\n            \\n            int mid = (left+right)/2;\\n\\n            if(nums[mid] == nums[mid^1])\\n                left = mid+1;\\n            \\n            else\\n                right = mid;\\n        }\\n        \\n        return nums[left];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628625,
                "title": "figure-use-example-as-your-guide-generalization",
                "content": "\\n**Intuition:**\\nSorted array!\\nThat suggests we can use binary search.\\nThen I will use classical binary search template: [low_index, high_index)\\nThe middle value are highlighted in red color.\\n\\nThere is some observation about potential place for the unique item: it must be in an even-indexed position\\n![image](https://assets.leetcode.com/users/codedayday/image_1589322173.png)\\n\\nNote, for original middle value of ex3 and ex4, the middle indices need to be decreased by 1 and converted in ex3\\u2019, and ex4\\u2019 respectively. The unique number, highlighted in green, must occupied an even-index position.\\n\\nOne more fun knowledge about i-th index in zero-index space is that i means there are i items have smaller indices then current i-th item:\\nFor example,\\nnums[i]\\nmeans there are i items are in the left of nums[i].\\nWhat does it mean to this question?\\nOkay, if some index, say, mid,  is even, then it means there are even number of items in the left of the mid.\\n\\n```\\nclass Solution {//BEST: binary search\\npublic://Time/Space: O(logN); O(1)\\n    int singleNonDuplicate(vector<int>& nums) {\\n        const int n = nums.size();\\n        int lo = 0, hi = n;\\n        if(n==1) return nums[0];\\n        while(lo<hi){\\n            int mid = lo + (hi - lo) / 2;\\n            if(mid%2 == 1) mid--; //  if mid%2 == 1; then at least two items are there.\\n            if(nums[mid] == nums[mid+1]) // left and current duet are all alright\\n                lo = mid +2;  // then move right by two positions.\\n            else hi = mid;  // note, mid is even index, a potential home for unique number\\n        }\\n        return nums[lo];\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {//BEST: binary search\\npublic://Time/Space: O(logN); O(1)\\n    int singleNonDuplicate(vector<int>& nums) {\\n        const int n = nums.size();\\n        int lo = 0, hi = n;\\n        if(n==1) return nums[0];\\n        while(lo<hi){\\n            int mid = lo + (hi - lo) / 2;\\n            if(mid%2 == 1) mid--; //  if mid%2 == 1; then at least two items are there.\\n            if(nums[mid] == nums[mid+1]) // left and current duet are all alright\\n                lo = mid +2;  // then move right by two positions.\\n            else hi = mid;  // note, mid is even index, a potential home for unique number\\n        }\\n        return nums[lo];\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509638,
                "title": "python3-using-xor",
                "content": "```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in nums:\\n            result^=i\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in nums:\\n            result^=i\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330019,
                "title": "one-line-python",
                "content": "```\\nreturn sum(set(nums)) * 2 - sum(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nreturn sum(set(nums)) * 2 - sum(nums)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100798,
                "title": "c-o-log-n-5-lines",
                "content": "Split the array in the middle and check whether the single element is in the left or the right part. If the split index is even, and element in the middle is equal to the next one, the single element is in the right part. The logic is revere if the split index is odd. Repeat recursively for the respective part util your part contains the single elements. Pay attention to whether to include the middle element to the part.\\n```\\nint singleNonDuplicate(vector<int>& nums, int st, int end) {\\n    if (st == end) return nums[st];\\n    auto mid = st + (end - st) / 2;\\n    if (nums[mid] == nums[mid + 1]) mid % 2 ? end = mid - 1 : st = mid;\\n    else mid % 2 ? st = mid + 1 : end = mid;\\n    return singleNonDuplicate(nums, st, end);\\n}\\nint singleNonDuplicate(vector<int>& nums) {\\n    return singleNonDuplicate(nums, 0, nums.size() - 1);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint singleNonDuplicate(vector<int>& nums, int st, int end) {\\n    if (st == end) return nums[st];\\n    auto mid = st + (end - st) / 2;\\n    if (nums[mid] == nums[mid + 1]) mid % 2 ? end = mid - 1 : st = mid;\\n    else mid % 2 ? st = mid + 1 : end = mid;\\n    return singleNonDuplicate(nums, st, end);\\n}\\nint singleNonDuplicate(vector<int>& nums) {\\n    return singleNonDuplicate(nums, 0, nums.size() - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 100829,
                "title": "using-collections-binarysearch-for-fun",
                "content": "Longer than writing my own binary search, but I wanted to see how this would look. I let `Collections.binarySearch` search in a special `List` object which returns `-1` for indexes before the single element, `0` for the index of the single element, and `1` for indexes after the single element. So I run binary search for `0`. Since my special `List` object computes its entries only on the fly when requested, this solution takes O(log n) time and O(1) space.\\n\\n    public int singleNonDuplicate(int[] nums) {\\n        List list = new ArrayList() {\\n            public int size() {\\n                return nums.length;\\n            }\\n            public Integer get(int index) {\\n                if ((index ^ 1) < size() && nums[index] == nums[index ^ 1])\\n                    return -1;\\n                if (index == 0 || index % 2 == 0 && nums[index - 1] != nums[index])\\n                    return 0;\\n                return 1;\\n            }\\n        };\\n        return nums[Collections.binarySearch(list, 0)];\\n    }\\n\\nA variation, the helper `isOff` tells whether the index is in the part that's \"off\" (the single element and everything after it):\\n\\n    public int singleNonDuplicate(int[] nums) {\\n        List list = new ArrayList() {\\n            public int size() {\\n                return nums.length;\\n            }\\n            public Integer get(int index) {\\n                return isOff(index) + isOff(index - 1);\\n            }\\n            int isOff(int i) {\\n                return i == size() - 1 || i >= 0 && nums[i] != nums[i ^ 1] ? 1 : 0;\\n            }\\n        };\\n        return nums[Collections.binarySearch(list, 1)];\\n    }",
                "solutionTags": [],
                "code": "Longer than writing my own binary search, but I wanted to see how this would look. I let `Collections.binarySearch` search in a special `List` object which returns `-1` for indexes before the single element, `0` for the index of the single element, and `1` for indexes after the single element. So I run binary search for `0`. Since my special `List` object computes its entries only on the fly when requested, this solution takes O(log n) time and O(1) space.\\n\\n    public int singleNonDuplicate(int[] nums) {\\n        List list = new ArrayList() {\\n            public int size() {\\n                return nums.length;\\n            }\\n            public Integer get(int index) {\\n                if ((index ^ 1) < size() && nums[index] == nums[index ^ 1])\\n                    return -1;\\n                if (index == 0 || index % 2 == 0 && nums[index - 1] != nums[index])\\n                    return 0;\\n                return 1;\\n            }\\n        };\\n        return nums[Collections.binarySearch(list, 0)];\\n    }\\n\\nA variation, the helper `isOff` tells whether the index is in the part that's \"off\" (the single element and everything after it):\\n\\n    public int singleNonDuplicate(int[] nums) {\\n        List list = new ArrayList() {\\n            public int size() {\\n                return nums.length;\\n            }\\n            public Integer get(int index) {\\n                return isOff(index) + isOff(index - 1);\\n            }\\n            int isOff(int i) {\\n                return i == size() - 1 || i >= 0 && nums[i] != nums[i ^ 1] ? 1 : 0;\\n            }\\n        };\\n        return nums[Collections.binarySearch(list, 1)];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3912825,
                "title": "easy-c-solution-using-binary-search-self-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n      int left=0;\\n      int right=nums.size()-1;\\n      while(left<right)  \\n      {\\n          int mid=(left+right)/2;\\n          if(mid%2==1)\\n          {\\n              mid--;\\n          }\\n          if(nums[mid]!=nums[mid+1])\\n          {\\n              right=mid;\\n          }\\n          else{\\n              left=mid+2;\\n          }\\n      }\\n      return nums[left];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n      int left=0;\\n      int right=nums.size()-1;\\n      while(left<right)  \\n      {\\n          int mid=(left+right)/2;\\n          if(mid%2==1)\\n          {\\n              mid--;\\n          }\\n          if(nums[mid]!=nums[mid+1])\\n          {\\n              right=mid;\\n          }\\n          else{\\n              left=mid+2;\\n          }\\n      }\\n      return nums[left];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871001,
                "title": "most-optimal-solution-using-binary-search-with-explanation-c-and-java-code",
                "content": "\\n\\n# Approach\\nThe given solution is a binary search-based approach to find the single element that appears only once in a sorted array. It exploits the fact that all other elements appear exactly twice.\\n\\nThe algorithm initializes two pointers, \\'low\\' and \\'high\\', which represent the range of indices to search within. It then repeatedly narrows down the search range by halving it until the single element is found.\\n\\n1. Check the base cases: If the array contains only one element, return it as the single element.\\n2. Check if the first element in the array is the single element by comparing it with the second element. If they are different, return the first element as the single element.\\n3. Check if the last element in the array is the single element by comparing it with the second-to-last element. If they are different, return the last element as the single element.\\n4. Perform a binary search using a while loop:\\n    - Calculate the middle index \\'mid\\' of the current search range (low to high).\\n    - If the element at \\'mid\\' is different from both its adjacent elements (mid - 1 and mid + 1), it means we have found the single element, so return it.\\n    - If the element at \\'mid\\' is equal to its previous element (mid is even), it means the single element lies to the right of \\'mid\\'. Update \\'low\\' to \\'mid + 1\\'.\\n    - If the element at \\'mid\\' is equal to its next element (mid is odd), it means the single element lies to the left of \\'mid\\'. Update \\'high\\' to \\'mid - 1\\'.\\n5. Repeat the binary search until the single element is found or \\'low\\' becomes greater than \\'high\\', which indicates that the element is not present in the array.\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size(); \\n        if (n == 1) return nums[0];\\n        if (nums[0] != nums[1]) return nums[0];\\n        if (nums[n - 1] != nums[n - 2]) return nums[n - 1];\\n        int low = 1, high = n - 2;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            if ((mid % 2 == 1 && nums[mid] == nums[mid - 1])\\n                    || (mid % 2 == 0 && nums[mid] == nums[mid + 1])) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\npublic class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return nums[0];\\n        if (nums[0] != nums[1]) return nums[0];\\n        if (nums[n - 1] != nums[n - 2]) return nums[n - 1];\\n        \\n        int low = 1, high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            \\n            if ((mid % 2 == 1 && nums[mid] == nums[mid - 1]) || (mid % 2 == 0 && nums[mid] == nums[mid + 1])) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1; \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size(); \\n        if (n == 1) return nums[0];\\n        if (nums[0] != nums[1]) return nums[0];\\n        if (nums[n - 1] != nums[n - 2]) return nums[n - 1];\\n        int low = 1, high = n - 2;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            if ((mid % 2 == 1 && nums[mid] == nums[mid - 1])\\n                    || (mid % 2 == 0 && nums[mid] == nums[mid + 1])) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n        if (n == 1) return nums[0];\\n        if (nums[0] != nums[1]) return nums[0];\\n        if (nums[n - 1] != nums[n - 2]) return nums[n - 1];\\n        \\n        int low = 1, high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            \\n            if ((mid % 2 == 1 && nums[mid] == nums[mid - 1]) || (mid % 2 == 0 && nums[mid] == nums[mid + 1])) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442830,
                "title": "very-easy-java-solution-beats-100-o-logn-o-1",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n       int start=0;\\n       int end=nums.length-1;\\n       while(start<end){\\n           int mid=start+(end-start)/2;\\n           if((mid%2==0 && nums[mid]==nums[mid+1]) ||(mid%2 == 1 && nums[mid] == nums[mid - 1])){\\n               start=mid+1;\\n           }\\n           else{\\n               end=mid;\\n           }\\n       }\\n       return nums[start];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n       int start=0;\\n       int end=nums.length-1;\\n       while(start<end){\\n           int mid=start+(end-start)/2;\\n           if((mid%2==0 && nums[mid]==nums[mid+1]) ||(mid%2 == 1 && nums[mid] == nums[mid - 1])){\\n               start=mid+1;\\n           }\\n           else{\\n               end=mid;\\n           }\\n       }\\n       return nums[start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308353,
                "title": "binary-search-index-method",
                "content": "The Binary search on Index is the solution here \\n\\nsuppose we have 1 1 2 3 3 4 4\\n\\nthen we have index :- 0 1 2 3 4 5 6 7\\nWe need to check left half \\nif mid is even \\nthe the number first instance is even and he second instance is odd.\\nso check mid +1 . if true shrink left half by low=mid+1\\nelse\\nthen the number first instance is odd and he second instance is even.\\nso check mid -1 . if true shrink left half by low=mid+1 else high=mid-1.\\n\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        \\n         int low=0;\\n        int high=arr.length-2;\\n        \\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(mid%2==0){\\n                \\n                if(arr[mid]==arr[mid+1]){\\n                    low=mid+1;\\n                }else{\\n                    high=mid-1;\\n                }\\n                \\n                \\n            }else{\\n             \\n                \\n                if(arr[mid]==arr[mid-1]){\\n                    low=mid+1;\\n                }else{\\n                    high=mid-1;\\n                }\\n                \\n                \\n            }\\n            }\\n        return arr[low];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        \\n         int low=0;\\n        int high=arr.length-2;\\n        \\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(mid%2==0){\\n                \\n                if(arr[mid]==arr[mid+1]){\\n                    low=mid+1;\\n                }else{\\n                    high=mid-1;\\n                }\\n                \\n                \\n            }else{\\n             \\n                \\n                if(arr[mid]==arr[mid-1]){\\n                    low=mid+1;\\n                }else{\\n                    high=mid-1;\\n                }\\n                \\n                \\n            }\\n            }\\n        return arr[low];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294615,
                "title": "540-time-93-53-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Initialize two pointers left and right to point to the first and last element of the array respectively.\\n- Implement binary search until left and right point to the same element.\\n- Compute the mid index as the average of left and right.\\n- Check if the element at the mid index is the single element.\\n- If the element at the mid index is not equal to the elements adjacent to it, return it as the single element.\\n- Check if the single element is on the left side of the array.\\n- If the element at mid is equal to the element at mid-1, then the single element is on the left side.\\n- Compute the distance between left and mid and check if it is even or odd.\\n- If it is even, then the single element is to the left of mid. Update right to mid-2.1\\n- If it is odd, then the single element is to the right of mid. Update left to mid+1.\\n- Check if the single element is on the right side of the array.\\n- If the element at mid is equal to the element at mid+1, then the single element is on the right side.\\n- Compute the distance between mid and right and check if it is even or odd.\\n- If it is even, then the single element is to the right of mid. Update left to mid+2.\\n- If it is odd, then the single element is to the left of mid. Update right to mid-1.\\n- If we reach here, the single element is at the left index. Return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        # Initialize pointers\\n        left, right = 0, len(nums) - 1\\n        \\n        # Binary search\\n        while left < right:\\n            mid = (left + right) // 2\\n            \\n            # Check if mid is the single element\\n            if nums[mid] != nums[mid-1] and nums[mid] != nums[mid+1]:\\n                return nums[mid]\\n            \\n            # Check if the single element is on the left side\\n            if nums[mid] == nums[mid-1]:\\n                if (mid - left) % 2 == 0:\\n                    right = mid - 2\\n                else:\\n                    left = mid + 1\\n            \\n            # Check if the single element is on the right side\\n            elif nums[mid] == nums[mid+1]:\\n                if (right - mid) % 2 == 0:\\n                    left = mid + 2\\n                else:\\n                    right = mid - 1\\n        \\n        # If we reach here, the single element is at the last index\\n        return nums[left]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        # Initialize pointers\\n        left, right = 0, len(nums) - 1\\n        \\n        # Binary search\\n        while left < right:\\n            mid = (left + right) // 2\\n            \\n            # Check if mid is the single element\\n            if nums[mid] != nums[mid-1] and nums[mid] != nums[mid+1]:\\n                return nums[mid]\\n            \\n            # Check if the single element is on the left side\\n            if nums[mid] == nums[mid-1]:\\n                if (mid - left) % 2 == 0:\\n                    right = mid - 2\\n                else:\\n                    left = mid + 1\\n            \\n            # Check if the single element is on the right side\\n            elif nums[mid] == nums[mid+1]:\\n                if (right - mid) % 2 == 0:\\n                    left = mid + 2\\n                else:\\n                    right = mid - 1\\n        \\n        # If we reach here, the single element is at the last index\\n        return nums[left]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214483,
                "title": "rust-0ms-binary-search-xor-approach",
                "content": "# Complexity\\n- Time complexity: $$O(log \\\\space n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn single_non_duplicate(nums: Vec<i32>) -> i32 {\\n        let mut right = nums.len() - 1;\\n        let mut left = 0;\\n\\n        while left < right {\\n            let mid = (left + right) / 2;\\n\\n            if nums[mid] == nums[mid ^ 1] {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn single_non_duplicate(nums: Vec<i32>) -> i32 {\\n        let mut right = nums.len() - 1;\\n        let mut left = 0;\\n\\n        while left < right {\\n            let mid = (left + right) / 2;\\n\\n            if nums[mid] == nums[mid ^ 1] {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3214460,
                "title": "easy-and-simple-solution-o-log-n-beats-94-29",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int s = 0;\\n        int e = nums.size() - 2; // Second last Index\\n        int mid = (s+e)/2;\\n        while(s<=e){\\n            // checking left part or not\\n            if(nums[mid] == nums[mid^1]){\\n                s = mid+1;  \\n            }\\n            else{\\n                e = mid-1;\\n            }\\n            mid = (s+e)/2;\\n        }\\n        return nums[s];\\n    }\\n};\\n\\n// For Left part\\n// 1st instance -- even\\n// 2nd instance -- odd \\n// I Need to check on the left wheather the 1st instance of that number is there or not\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int s = 0;\\n        int e = nums.size() - 2; // Second last Index\\n        int mid = (s+e)/2;\\n        while(s<=e){\\n            // checking left part or not\\n            if(nums[mid] == nums[mid^1]){\\n                s = mid+1;  \\n            }\\n            else{\\n                e = mid-1;\\n            }\\n            mid = (s+e)/2;\\n        }\\n        return nums[s];\\n    }\\n};\\n\\n// For Left part\\n// 1st instance -- even\\n// 2nd instance -- odd \\n// I Need to check on the left wheather the 1st instance of that number is there or not\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214441,
                "title": "js-approach-if-you-re-coming-from-a-web-background",
                "content": "# Intuition\\n***Easy One liner Approach, helpful if you\\'re currently learning javascript methods ***\\n\\n# Approach\\n Taking nums as input and returns a single non-duplicate integer in the array using the **bitwise XOR operation.**\\n\\nThe reduce() method is used to iterate through each number in the nums array and perform the bitwise XOR operation with the accumulated result acc. The initial value of acc is set to 0.\\n\\nThe XOR operation returns 1 if the bits being compared are different, and 0 if they are the same. By applying the XOR operation to each element in the array, all pairs of duplicate integers will cancel each other out, leaving only the **single non-duplicate integer.**\\n\\nAt the end of the iteration, the final accumulated result is the single non-duplicate integer in the array, which is then returned by the function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) { \\n    return nums.reduce((acc, num) => acc ^ num, 0);\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) { \\n    return nums.reduce((acc, num) => acc ^ num, 0);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3214138,
                "title": "javascript-96-o-log-n-time-o-1-space-binary-search",
                "content": "![image.png](https://assets.leetcode.com/users/images/f5d988de-7e19-4e38-b41e-73a2b04cc022_1676972922.5721262.png)\\n\\n# Approach\\n\\n### Linear search\\n\\n$$A \\\\bigoplus A = 0$$ ($$XOR$$-ing a number with itself always equals zero)\\n$$A \\\\bigoplus 0 = A$$ ($$XOR$$-ing a number with zero always equals original number)\\n\\nIf we had an array where each element is present exactly twice, $$XOR$$-ing all elements together would equal zero (as per first rule).\\nSince we have one element with no duplicate, $$XOR$$-ing it with the rest of the array would equal this element (as per second rule).\\n\\n```\\nvar singleNonDuplicate = function(nums) {\\n    let sum = 0;\\n    \\n    for (const num of nums) sum ^= num;\\n    \\n    return sum;\\n};\\n```\\n\\nOr, as a one-liner:\\n\\n```\\nvar singleNonDuplicate = function(nums) {\\n    return nums.reduce((acc, num) => acc ^ num, 0);\\n};\\n```\\n\\n### Binary search\\n\\nAssuming we already know how binary search works, the main question to answer is - **how to know when to move the pointer to the left or to the right**?\\n\\nLook at the array below, where each element has a duplicate.\\n\\n<table>\\n    <tr>\\n        <td style=\"background-color:#555;color:red\">0</td>\\n        <td style=\"color:red\">0</td>\\n        <td style=\"background-color:#555;color:orange\">1</td>\\n        <td style=\"color:orange\">1</td>\\n        <td style=\"background-color:#555;color:yellow\">2</td>\\n        <td style=\"color:yellow\">2</td>\\n        <td style=\"background-color:#555;color:green\">3</td>\\n        <td style=\"color:green\">3</td>\\n        <td style=\"background-color:#555;color:cyan\">4</td>\\n        <td style=\"color:cyan\">4</td>\\n    </tr>\\n</table>\\n\\nYou can notice that every element at an odd index (grey background) is equal to the next element, and every element at an even index is equal to the previous element.\\n\\nIf we remove a single element from the left (such that there will be one element in the array with no duplicate), 0 in this case, the condition above would switch. Now, every element at an odd index (grey background) is equal to the previous element, and every element at an even index is equal to the next element.\\n\\n<table>\\n    <tr>\\n        <td style=\"background-color:#555;color:red\">0</td>\\n        <td style=\"color:orange\">1</td>\\n        <td style=\"background-color:#555;color:orange\">1</td>\\n        <td style=\"color:yellow\">2</td>\\n        <td style=\"background-color:#555;color:yellow\">2</td>\\n        <td style=\"color:green\">3</td>\\n        <td style=\"background-color:#555;color:green\">3</td>\\n        <td style=\"color:cyan\">4</td>\\n        <td style=\"background-color:#555;color:cyan\">4</td>\\n    </tr>\\n</table>\\n\\nThis won\\'t happen if we remove an element from the right, 4 in this case.\\n\\n<table>\\n    <tr>\\n        <td style=\"background-color:#555;color:red\">0</td>\\n        <td style=\"color:red\">0</td>\\n        <td style=\"background-color:#555;color:orange\">1</td>\\n        <td style=\"color:orange\">1</td>\\n        <td style=\"background-color:#555;color:yellow\">2</td>\\n        <td style=\"color:yellow\">2</td>\\n        <td style=\"background-color:#555;color:green\">3</td>\\n        <td style=\"color:green\">3</td>\\n        <td style=\"background-color:#555;color:cyan\">4</td>\\n    </tr>\\n</table>\\n\\nWhat this means is, if we pick an arbitrary index in the array, and it matches the first condition, the single element must be on the right, otherwise, it\\'s on the left, with one exception.\\n\\nIf the element does not equal the element on it\\'s right, and neither the element on the left, we have found the element with no duplicate.\\n\\n```\\nfunction singleNonDuplicate(nums) {\\n    let left = 0;\\n    let right = nums.length;\\n    \\n    while (left < right) {\\n        let mid = (left + right) >>> 1;\\n        if (mid % 2 !== 0) mid--;\\n\\n        const value = nums[mid];\\n        \\n        if (value !== nums[mid + 1] && \\n            value !== nums[mid - 1]) {\\n            return value;\\n        }\\n        \\n        if (value === nums[mid - 1]) {\\n            right = mid;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$\\n\\n- Space complexity: $$O(1)$$",
                "solutionTags": [
                    "JavaScript",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nvar singleNonDuplicate = function(nums) {\\n    let sum = 0;\\n    \\n    for (const num of nums) sum ^= num;\\n    \\n    return sum;\\n};\\n```\n```\\nvar singleNonDuplicate = function(nums) {\\n    return nums.reduce((acc, num) => acc ^ num, 0);\\n};\\n```\n```\\nfunction singleNonDuplicate(nums) {\\n    let left = 0;\\n    let right = nums.length;\\n    \\n    while (left < right) {\\n        let mid = (left + right) >>> 1;\\n        if (mid % 2 !== 0) mid--;\\n\\n        const value = nums[mid];\\n        \\n        if (value !== nums[mid + 1] && \\n            value !== nums[mid - 1]) {\\n            return value;\\n        }\\n        \\n        if (value === nums[mid - 1]) {\\n            right = mid;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3213429,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1;\\n        while(left < right){\\n            int mid = (left + right)/2;\\n            if((mid % 2 == 0 && nums[mid] == nums[mid + 1]) || (mid % 2 == 1 && nums[mid] == nums[mid - 1]))\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        \\n        return nums[left];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1;\\n        while(left < right){\\n            int mid = (left + right)/2;\\n            if((mid % 2 == 0 && nums[mid] == nums[mid + 1]) || (mid % 2 == 1 && nums[mid] == nums[mid - 1]))\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        \\n        return nums[left];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3213347,
                "title": "approaches-bit-manipulation-binary-search",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach 1\\nBit Manpulation\\n<!-- Describe your approach to solving the problem. -->\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int single = 0;\\n        for(int num: nums)\\n            single ^= num;\\n        return single;\\n    }\\n};\\n```\\n\\n# Approach 2\\nBinary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n## Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int mid, l = 0, r = nums.size() - 1;\\n        while(l < r) {\\n            mid = l + (r - l) / 2;\\n            if(nums[mid] == nums[mid + 1]) {\\n                if((mid - l) & 1)\\n                    r = mid - 1;\\n                else\\n                    l = mid;\\n            }\\n            else if(nums[mid] == nums[mid - 1]) {\\n                if((r - mid) & 1)\\n                    l = mid + 1;\\n                else\\n                    r = mid;\\n            }\\n            else\\n                return nums[mid];\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int single = 0;\\n        for(int num: nums)\\n            single ^= num;\\n        return single;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int mid, l = 0, r = nums.size() - 1;\\n        while(l < r) {\\n            mid = l + (r - l) / 2;\\n            if(nums[mid] == nums[mid + 1]) {\\n                if((mid - l) & 1)\\n                    r = mid - 1;\\n                else\\n                    l = mid;\\n            }\\n            else if(nums[mid] == nums[mid - 1]) {\\n                if((r - mid) & 1)\\n                    l = mid + 1;\\n                else\\n                    r = mid;\\n            }\\n            else\\n                return nums[mid];\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212811,
                "title": "0ms-beayts-100-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n=nums.length-1;\\n        int v=n;\\n        for(int i=0;i<n;i+=2){\\n            if(nums[i]!=nums[i+1]){\\n                v=i;\\n                break;\\n            } \\n            else if(nums[v]!=nums[v-1])\\n                break;\\n            v-=2;\\n        }\\n        return nums[v];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n=nums.length-1;\\n        int v=n;\\n        for(int i=0;i<n;i+=2){\\n            if(nums[i]!=nums[i+1]){\\n                v=i;\\n                break;\\n            } \\n            else if(nums[v]!=nums[v-1])\\n                break;\\n            v-=2;\\n        }\\n        return nums[v];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212651,
                "title": "optimized-solution-1ms-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(LogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n            int e = 0;\\n            for (int i = 0; i < n; i++) {\\n                e = e ^ nums[i];\\n        }\\n        \\n        return e;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n            int e = 0;\\n            for (int i = 0; i < n; i++) {\\n                e = e ^ nums[i];\\n        }\\n        \\n        return e;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212483,
                "title": "c-binary-search-explained",
                "content": "# Approach\\n1. if there\\'s only one element return it\\n2. check if the unique element is the first or last element of the array\\n\\n**CASE 1**: element at mid and mid - 1 are equal; \\n    - get count of left array and check if it is even or odd\\n    - in case it is even, discard and search **right**\\n    - in case of odd, continue search on the **left** side\\n\\n**CASE 2**: element at mid and mid + 1 are equal; get right count\\n\\nto decide the direction of search check which part of the array has odd number of elements.\\n\\nif number of element from start to mid is odd then unique element will be present on this left side of the array else search on the right side.\\n\\n# Complexity\\n- Time complexity: ```O(log n)```\\n\\n- Space complexity: ```O(1)```\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SingleNonDuplicate(int[] nums) {\\n        int start = 0, end = nums.Length - 1;        \\n        if(nums.Length == 1) return nums[end];\\n\\n        // if the unique element is the first or last element of the array\\n        if(nums[0] != nums[1]) return nums[0];\\n\\n        // if the unique element is the last element of the array\\n        if(nums[end] != nums[end - 1]) return nums[end];\\n\\n        while(start <= end) { \\n            int mid = start + (end - start) /2;\\n            if(nums[mid] != nums[mid - 1] && nums[mid] != nums[mid + 1])\\n                return nums[mid];\\n\\n            if(nums[mid] == nums[mid - 1]) {\\n                int leftCount = mid - start + 1;\\n                if(leftCount % 2 == 0) start = mid + 1;\\n                else end = mid - 2; \\n            }\\n            else if(nums[mid] == nums[mid + 1]) {\\n                int rightCount = end + mid - 1;\\n                if(rightCount % 2 == 0) end = mid - 1;\\n                else start = mid + 2;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```O(log n)```\n```O(1)```\n```\\npublic class Solution {\\n    public int SingleNonDuplicate(int[] nums) {\\n        int start = 0, end = nums.Length - 1;        \\n        if(nums.Length == 1) return nums[end];\\n\\n        // if the unique element is the first or last element of the array\\n        if(nums[0] != nums[1]) return nums[0];\\n\\n        // if the unique element is the last element of the array\\n        if(nums[end] != nums[end - 1]) return nums[end];\\n\\n        while(start <= end) { \\n            int mid = start + (end - start) /2;\\n            if(nums[mid] != nums[mid - 1] && nums[mid] != nums[mid + 1])\\n                return nums[mid];\\n\\n            if(nums[mid] == nums[mid - 1]) {\\n                int leftCount = mid - start + 1;\\n                if(leftCount % 2 == 0) start = mid + 1;\\n                else end = mid - 2; \\n            }\\n            else if(nums[mid] == nums[mid + 1]) {\\n                int rightCount = end + mid - 1;\\n                if(rightCount % 2 == 0) end = mid - 1;\\n                else start = mid + 2;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212187,
                "title": "java-binary-search-simple-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int singleNonDuplicate(int[] nums) {\\n    var n = nums.length;\\n    int l = 0, r = n-1;\\n\\n    while (l < r) {\\n      var m = l + (r-l) / 2;\\n      var mod = (r-l+1) % 4;\\n\\n      if (nums[m] == nums[m-1])\\n        if (mod == 1)\\n          r = m-2;\\n        else\\n          l = m+1;\\n      else if (nums[m] == nums[m+1])\\n        if (mod == 1)\\n          l = m+2;\\n        else\\n          r = m-1;\\n      else return nums[m];\\n    }\\n    return nums[l];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public int singleNonDuplicate(int[] nums) {\\n    var n = nums.length;\\n    int l = 0, r = n-1;\\n\\n    while (l < r) {\\n      var m = l + (r-l) / 2;\\n      var mod = (r-l+1) % 4;\\n\\n      if (nums[m] == nums[m-1])\\n        if (mod == 1)\\n          r = m-2;\\n        else\\n          l = m+1;\\n      else if (nums[m] == nums[m+1])\\n        if (mod == 1)\\n          l = m+2;\\n        else\\n          r = m-1;\\n      else return nums[m];\\n    }\\n    return nums[l];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065352,
                "title": "easily-understandable-java-sol-0ms-100-beats-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince repetetion is in pairs so single element can only be there if array length is odd. So by that logic we will binary search to that part of the divided array through mid whose length is odd and niglect the even sized part. \\n# Approach: Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n       int n = nums.length;\\n       if(n==1) { return nums[0]; }\\n       if(nums[0] != nums[1]) { return nums[0]; }\\n       if(nums[n-1] != nums[n-2]) { return nums[n-1]; }\\n\\n       int low = 0,high = n-1;\\n       while(low<=high){\\n           int mid = low+(high-low)/2;\\n           if(nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]){\\n               return nums[mid];\\n           }\\n           else if(nums[mid] == nums[mid-1]){\\n               int lc = mid-low+1;\\n               if(lc%2 == 0){\\n                   low = mid+1;\\n               }else{\\n                   high = mid-2;\\n               }\\n           }\\n           else if(nums[mid] == nums[mid+1]){\\n               int rc = high-mid+1;\\n               if(rc%2 == 0){\\n                   high = mid-1;\\n               }else{\\n                   low = mid+2;\\n               }\\n           }\\n       }\\n         return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n       int n = nums.length;\\n       if(n==1) { return nums[0]; }\\n       if(nums[0] != nums[1]) { return nums[0]; }\\n       if(nums[n-1] != nums[n-2]) { return nums[n-1]; }\\n\\n       int low = 0,high = n-1;\\n       while(low<=high){\\n           int mid = low+(high-low)/2;\\n           if(nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]){\\n               return nums[mid];\\n           }\\n           else if(nums[mid] == nums[mid-1]){\\n               int lc = mid-low+1;\\n               if(lc%2 == 0){\\n                   low = mid+1;\\n               }else{\\n                   high = mid-2;\\n               }\\n           }\\n           else if(nums[mid] == nums[mid+1]){\\n               int rc = high-mid+1;\\n               if(rc%2 == 0){\\n                   high = mid-1;\\n               }else{\\n                   low = mid+2;\\n               }\\n           }\\n       }\\n         return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015031,
                "title": "c-approach-using-binary-search-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are guaranteed that only one element has a frequency of 1 and rest have 2, so it is understood that the occurence of that \"one\" frequency element causes a break in the pattern of the indices, meaning that all elements before that anomaly digit will have a even starting index and the elements after the anomaly will have an odd starting index. So we detect for the indexes\\' odd/even property and then split our search space accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing binary search, check if middle digit is anomaly itself or not. If not, check if it\\'s starting index is odd or even. If it is even, then move right else move left. You\\'re guarnteed to find a solution, so put return dummy value as -1 at end. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1 || nums.size()==2) return nums[0];\\n\\n        int l=0;int r=nums.size()-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(mid==0){\\n                return nums[0];\\n            }\\n            else if(mid==nums.size()-1) return nums[nums.size()-1];\\n            if(nums[mid]!=nums[mid+1] && nums[mid]!=nums[mid-1]) return nums[mid];\\n            else if(nums[mid]==nums[mid-1]){\\n                if((mid-1)%2==0) l=mid+1;\\n                else r=mid-2;\\n            }\\n            else{\\n                if(mid%2==0) l=mid+2;\\n                else r=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1 || nums.size()==2) return nums[0];\\n\\n        int l=0;int r=nums.size()-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(mid==0){\\n                return nums[0];\\n            }\\n            else if(mid==nums.size()-1) return nums[nums.size()-1];\\n            if(nums[mid]!=nums[mid+1] && nums[mid]!=nums[mid-1]) return nums[mid];\\n            else if(nums[mid]==nums[mid-1]){\\n                if((mid-1)%2==0) l=mid+1;\\n                else r=mid-2;\\n            }\\n            else{\\n                if(mid%2==0) l=mid+2;\\n                else r=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864097,
                "title": "beats-99-60-upvote-python-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return nums[0]\\n        i=0\\n        j=len(nums)-1\\n        while i<=j:\\n            if nums[i]!=nums[i+1]:\\n                return nums[i]\\n            elif nums[j]!=nums[j-1]:\\n                return nums[j]\\n            if nums[i]==nums[i+1]:\\n                i+=2\\n            elif nums[j]==nums[j-1]:\\n                j-=2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        if len(nums)==1:\\n            return nums[0]\\n        i=0\\n        j=len(nums)-1\\n        while i<=j:\\n            if nums[i]!=nums[i+1]:\\n                return nums[i]\\n            elif nums[j]!=nums[j-1]:\\n                return nums[j]\\n            if nums[i]==nums[i+1]:\\n                i+=2\\n            elif nums[j]==nums[j-1]:\\n                j-=2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823897,
                "title": "easy-c-solution-binary-search",
                "content": "Here is my C++ Solution :-\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int i=0; int j= nums.size()-1;\\n        if (j==0)return nums[0];\\n        while (i<=j){\\n            int mid= i+(j-i)/2;\\n            // if (nums[mid]!=nums[mid-1] && nums[mid+1]!= nums[mid]){\\n            //     ans= mid;\\n            //     return nums[mid];\\n            // }\\n            if (mid%2==0){\\n                //even hua aur sahi hua toh aage wla sahi ho\\n                if (nums[mid]==nums[mid+1]){\\n                    i= mid+1;\\n                }\\n                else j= mid-1;\\n            }\\n            else{\\n                if (nums[mid]==nums[mid-1]){\\n                    i= mid+1;\\n                }\\n                else j= mid-1;\\n            }\\n        }\\n        return nums[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int i=0; int j= nums.size()-1;\\n        if (j==0)return nums[0];\\n        while (i<=j){\\n            int mid= i+(j-i)/2;\\n            // if (nums[mid]!=nums[mid-1] && nums[mid+1]!= nums[mid]){\\n            //     ans= mid;\\n            //     return nums[mid];\\n            // }\\n            if (mid%2==0){\\n                //even hua aur sahi hua toh aage wla sahi ho\\n                if (nums[mid]==nums[mid+1]){\\n                    i= mid+1;\\n                }\\n                else j= mid-1;\\n            }\\n            else{\\n                if (nums[mid]==nums[mid-1]){\\n                    i= mid+1;\\n                }\\n                else j= mid-1;\\n            }\\n        }\\n        return nums[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685481,
                "title": "java-detailed-explanation-3-approaches",
                "content": "\\n\\t// time complexity: o(n)\\n\\t// space complexity: o(1)\\n\\t// Approach 1 : Xor property - > this will give the single element as an answer  , ( a^a = 0)\\n\\n\\t\\tclass Solution {\\n\\n\\t\\tpublic int singleNonDuplicate(int[] arr) {\\n\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\tfor (int a : arr) {\\n\\n\\t\\t\\t\\tans ^= a;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}\\n\\n\\t\\t// time complexity: o(n)\\n\\t\\t// space complexity: o(n)\\n\\t\\t//Approach 2 : HashMap - > Create a frequency Array and return the element with 1 frequency\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\n\\t\\t\\tpublic int singleNonDuplicate(int[] arr) {\\n\\n\\t\\t\\tfor (int a : arr) {\\n\\n\\t\\t\\t\\tmap.put(a, map.getOrDefault(a, 0) + 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int a : arr) {\\n\\n\\t\\t\\t\\tif (map.get(a) == 1)\\n\\t\\t\\t\\t\\treturn a;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}\\n\\n\\t\\t// time complexity: o(logn)\\n\\t\\t// space complexity : O(1)\\n\\t\\t// Approach 3 : Binary Search \\n\\t\\n\\t\\t// if mid - 1 & mid +1 are not equal with the mid element this is our single element\\n\\t\\t// Intitution :  the ans will always lie in the part with odd no of elements because all other will occur even multiples.\\n\\t\\t\\n \\tclass Solution {\\n\\t\\tpublic int singleNonDuplicate(int[] nums) {\\n\\n\\t\\t\\tint low = 0;\\n\\t\\t\\tint high = nums.length - 1;\\n\\n\\t\\t\\tint n = nums.length;\\n\\t\\t\\tif (n == 1)\\n\\t\\t\\t\\treturn nums[0];\\n\\n\\t\\t\\tif (nums[1] != nums[0])\\n\\t\\t\\t\\treturn nums[0];\\n\\n\\t\\t\\tif (nums[n - 1] != nums[n - 2])\\n\\t\\t\\t\\treturn nums[n - 1];\\n\\n\\t\\t\\twhile (low <= high) {\\n\\n\\t\\t\\t\\tint mid = (low + high) / 2;\\n\\n\\t\\t\\t\\tif (nums[mid] != nums[mid - 1] && nums[mid] != nums[mid + 1])\\n\\t\\t\\t\\t\\treturn nums[mid];\\n\\n\\t\\t\\t\\tif (nums[mid] == nums[mid - 1]) {\\n\\n\\t\\t\\t\\t\\tint lc = mid - low + 1;\\n\\n\\t\\t\\t\\t\\tif (lc % 2 == 0)\\n\\t\\t\\t\\t\\t\\tlow = mid + 1;\\n\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\thigh = mid - 2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (nums[mid] == nums[mid + 1]) {\\n\\n\\t\\t\\t\\t\\tint rc = high - mid + 1;\\n\\n\\t\\t\\t\\t\\tif (rc % 2 == 0)\\n\\t\\t\\t\\t\\t\\thigh = mid - 1;\\n\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tlow = mid + 2;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn -1;\\n\\n\\t\\t}\\n\\t}\\n\\t\\n\\t// Like & upvote if it makes a sense to you :)",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\n\\t\\tpublic int singleNonDuplicate(int[] arr) {\\n\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\tfor (int a : arr) {\\n\\n\\t\\t\\t\\tans ^= a;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2555921,
                "title": "java-binary-search-explained-simple-100-faster",
                "content": "\\t//just simple search for the odd side from mid\\n\\t//condition : one thing to keep in mind always check mid that it should not lay on the 1st repeated element\\n\\t//for that put the condition,as I have putted in the first if statement\\n\\t\\n\\tThank you , if it helps then UPVOTE\\n\\t\\n\\tclass Solution {\\n\\t\\tpublic int singleNonDuplicate(int[] nums) {\\n\\t\\t\\tif(nums.length==1) return nums[0];\\n\\t\\t\\tint start=0;\\n\\t\\t\\tint end=nums.length-1;\\n\\t\\t\\twhile(start<end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mid= start+(end-start)/2;\\n\\t\\t\\t\\tif(nums[mid]==nums[mid+1]) //here is the condition for checking is mid on its right place or not\\n\\t\\t\\t\\t\\tmid=mid-1;\\n\\t\\t\\t\\tif((mid-start+1)%2==0) // check length of left if even the move to right side, in this we have added +1\\n\\t\\t\\t\\t//because we are including mid in left side, it is not possible to include it on both the sides\\n\\t\\t\\t\\t\\tstart=mid+1;\\n\\t\\t\\t\\telse // here if length of left side is odd then then answer will be on that side \\n\\t\\t\\t\\t\\tend=mid;\\n\\t\\t\\t}\\n\\t\\t\\t// in the end start,end and mid will be on same position then loop will break \\n\\t\\t\\treturn nums[start];\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic int singleNonDuplicate(int[] nums) {\\n\\t\\t\\tif(nums.length==1) return nums[0];\\n\\t\\t\\tint start=0;\\n\\t\\t\\tint end=nums.length-1;\\n\\t\\t\\twhile(start<end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mid= start+(end-start)/2;\\n\\t\\t\\t\\tif(nums[mid]==nums[mid+1]) //here is the condition for checking is mid on its right place or not\\n\\t\\t\\t\\t\\tmid=mid-1;\\n\\t\\t\\t\\tif((mid-start+1)%2==0) // check length of left if even the move to right side, in this we have added +1\\n\\t\\t\\t\\t//because we are including mid in left side, it is not possible to include it on both the sides\\n\\t\\t\\t\\t\\tstart=mid+1;\\n\\t\\t\\t\\telse // here if length of left side is odd then then answer will be on that side \\n\\t\\t\\t\\t\\tend=mid;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2102251,
                "title": "c-binary-search-o-log-n-have-a-look",
                "content": "class Solution {\\npublic:\\n\\n /**/just keep one thing in mind if we have all elements appearing twice than every first occurance will lie on the even index**\\n       ****** // **but here as one element is appearing only once **\\n        // so this element divides the whole array into two parts\\n        // **first part will be like every first occureance will be on even index******\\n   **     // **and then comes that single integer and first occurance of a number in second half will be at odd index****\\n        // **so we will just check whether the mid is odd or even** *\\n\\t\\t**\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\t\\n        int n=nums.size();\\n        int low=0;\\n        int high=n-2;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2; \\n            if(mid%2==0) //if mid is even so check whether it is first occurance\\n            {\\n             if(nums[mid+1]==nums[mid])//if first occurance this means it lies on the left part so we need to approach towards right to meet that single element \\n             {\\n                  low=mid+1;   \\n             }\\n                else //exists on right part so just reduce the searchin spacefd\\n                    \\n                {\\n                  high =mid-1; \\n                }\\n            }\\n            else\\n            {\\n                 if(nums[mid+1]!=nums[mid])//start at even we are on left\\n             {\\n                low=mid+1;\\n             }\\n                else //we are on right\\n                    \\n                { high =mid-1;\\n                    \\n                }\\n            }\\n        }\\n        return nums[low];\\n            \\n        \\n    }\\n};\\n**Upvote if helped**",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n /**/just keep one thing in mind if we have all elements appearing twice than every first occurance will lie on the even index**\\n       ****** // **but here as one element is appearing only once **\\n        // so this element divides the whole array into two parts\\n        // **first part will be like every first occureance will be on even index******\\n   **     // **and then comes that single integer and first occurance of a number in second half will be at odd index****\\n        // **so we will just check whether the mid is odd or even** *\\n\\t\\t**\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\t\\n        int n=nums.size();\\n        int low=0;\\n        int high=n-2;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2; \\n            if(mid%2==0) //if mid is even so check whether it is first occurance\\n            {\\n             if(nums[mid+1]==nums[mid])//if first occurance this means it lies on the left part so we need to approach towards right to meet that single element \\n             {\\n                  low=mid+1;   \\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2078341,
                "title": "easy-c-sol-naive-and-efficicent-approach-time-o-logn",
                "content": "```\\n// Naive Sol : Just take XoR of the array values and the result will be the single occurring element. \\n// Time : O(N) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int var = nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            var ^= nums[i];\\n        }\\n        return var;\\n    }\\n};\\n\\n// Effective Sol : before the single element the last occurence of the element will be @ odd index, but after a single element the last occurrence of the element \\n// will be at even index and we just need to find that break point.\\n\\n// Time : O(Logn) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int low= 0,high= n-2; // The high is @ n-2 cuz think the case when the single element is the last element of the array\\n        \\n        while(low<=high){\\n            \\n            int mid = (low+high) >> 1;\\n            \\n            if(nums[mid] == nums[mid^1]){ // [mid^1] will take you to the next odd or even index of the element, and it\\'ll help to know if you are on the left half or not\\n                low = mid+1;\\n            }else{\\n                high = mid-1;\\n            }\\n            \\n        }\\n        return nums[low];\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int var = nums[0];\\n        \\n        for(int i=1;i<n;i++){\\n            var ^= nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2058007,
                "title": "using-binary-search-2-approaches-c",
                "content": "Implementation\\n\\n**Using Binary Search\\n1st Approach\\nTime Complexity = O(LogN)\\nSpace Complexity = O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int left = 0, right = nums.size()-2; \\n       \\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n           \\n            if(mid%2 == 0 && nums[mid+1] == nums[mid] || \\n               mid%2 == 1 && nums[mid-1] == nums[mid]) {\\n                left = mid+1;\\n            }\\n            else right = mid-1;\\n        }\\n        return nums[left];\\n    }\\n};\\n```\\n\\n\\n**Using Binary Search\\n2nd Approach\\nTime Complexity = O(LogN)\\nSpace Complexity = O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if(n == 1) return nums[0];\\n        else if(nums[0] != nums[1]) return nums[0];\\n        else if(nums[n-1] != nums[n-2]) return nums[n-1];\\n        \\n        int start = 0, end = n-1;\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n            \\n            if(nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]) return nums[mid];\\n            \\n            if(mid%2 == 0 && nums[mid+1] == nums[mid] || \\n               mid%2 == 1 && nums[mid-1] == nums[mid]) {\\n                start = mid+1;\\n            }\\n            else end = mid-1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int left = 0, right = nums.size()-2; \\n       \\n        while(left <= right){\\n            int mid = left + (right-left)/2;\\n           \\n            if(mid%2 == 0 && nums[mid+1] == nums[mid] || \\n               mid%2 == 1 && nums[mid-1] == nums[mid]) {\\n                left = mid+1;\\n            }\\n            else right = mid-1;\\n        }\\n        return nums[left];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        if(n == 1) return nums[0];\\n        else if(nums[0] != nums[1]) return nums[0];\\n        else if(nums[n-1] != nums[n-2]) return nums[n-1];\\n        \\n        int start = 0, end = n-1;\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n            \\n            if(nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1]) return nums[mid];\\n            \\n            if(mid%2 == 0 && nums[mid+1] == nums[mid] || \\n               mid%2 == 1 && nums[mid-1] == nums[mid]) {\\n                start = mid+1;\\n            }\\n            else end = mid-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1993190,
                "title": "java-best-possible-explanation-o-log-n-time-o-1-space",
                "content": "**Explanation -** \\n\\nLet\\'s take the given example first \\n\\n`nums = [1, 1, 2, 3, 3, 4, 4, 8, 8]`\\n\\nHere we can see that 2 is the number which appears once and all the other number appears twice.\\n\\nIf all the number would have appeared twice in  `nums` in the above example then array would have looked like this -\\n```\\nnums = [1, 1, 2, 2, 3, 3, 4, 4, 8, 8]\\n\\t\\t0  1  2  3  4  5  6  7  8  9\\n```\\nThe thing to notice here is that each number is present on an **even index** and it\\'s duplicate is present on an **odd index**. This pattern will help in finding the single number.\\n\\nAnd in the given `nums`, since 2 is present only one time, the above pattern is distorted after the number 2.\\n\\n```\\nnums = [1, 1, 2, 3, 3, 4, 4, 8, 8]\\n\\t\\t0  1  2  3  4  5  6  7  8  \\n```\\n\\nSo here **binary search technique** can be applied.\\n1. Find the middle index of the list.\\n2. Check if middle index is even or odd.\\n\\t- If it\\'s even, the number at middle index should be equal to the next number. (from the above pattern)\\n\\t- If it\\'s odd, the number at middle index should be equal to the previous number. (from the above pattern)\\n\\t- If any of the above condition is satisfied, then the numbers before mid follows the pattern and hence single element must exist after mid.\\n\\t\\t- Reduce the list to number after mid by moving low pointer to mid+1.\\n\\t- If the condition is not statisfied that means the pattern is distorted before mid and hence single element must exist before mid.\\n\\t\\t- Reduce the list to number before mid by moving high pointer to mid.\\n\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        \\n        int low = 0, high = nums.length-1;\\n        \\n        while( low != high ) {\\n            \\n            int mid = low + (high-low)/2;\\n\\n            boolean isMidEven = mid % 2 == 0;\\n            \\n            /* Is mid even and next number equal or\\n            mid is odd and previous number equal */\\n            if( \\n                (isMidEven && nums[mid] == nums[mid+1]) ||\\n                (!isMidEven && nums[mid] == nums[mid-1])\\n            ) {\\n                /* All the number before the mid appear twice,\\n                reduce the search space to numbers after mid */\\n                low = mid+1;\\n            } else {\\n                /* The single number appears before mid */\\n                high = mid;\\n            }\\n        }\\n        \\n        return nums[low];\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nnums = [1, 1, 2, 2, 3, 3, 4, 4, 8, 8]\\n\\t\\t0  1  2  3  4  5  6  7  8  9\\n```\n```\\nnums = [1, 1, 2, 3, 3, 4, 4, 8, 8]\\n\\t\\t0  1  2  3  4  5  6  7  8  \\n```\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        \\n        int low = 0, high = nums.length-1;\\n        \\n        while( low != high ) {\\n            \\n            int mid = low + (high-low)/2;\\n\\n            boolean isMidEven = mid % 2 == 0;\\n            \\n            /* Is mid even and next number equal or\\n            mid is odd and previous number equal */\\n            if( \\n                (isMidEven && nums[mid] == nums[mid+1]) ||\\n                (!isMidEven && nums[mid] == nums[mid-1])\\n            ) {\\n                /* All the number before the mid appear twice,\\n                reduce the search space to numbers after mid */\\n                low = mid+1;\\n            } else {\\n                /* The single number appears before mid */\\n                high = mid;\\n            }\\n        }\\n        \\n        return nums[low];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722490,
                "title": "5-c-solutions-binary-search-xor-hashmap-unordered-set-linear-scan",
                "content": "**Solution 1: Using Xor operation**\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        for(int x: nums){\\n            ans^=x;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Solution 2: Linear Search Single Scan**\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int i = 0;\\n        for(; i<nums.size()-1; i+=2){\\n            if(nums[i]!=nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        \\n        return nums[i];\\n    }\\n};\\n```\\n\\n**Solution 3: Using Unordered Set**\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_set<int>us;\\n        \\n        for(int x: nums){\\n            if(us.find(x) != us.end()){\\n                us.erase(x);\\n            }\\n            \\n            else{\\n                us.insert(x);\\n            }\\n        }\\n        \\n        return *us.begin();\\n    }\\n};\\n```\\n**Solution 4: Using Hashmaps as frequency Counters**\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int>mp;\\n        \\n        for(int x: nums){\\n            mp[x]++;\\n        }\\n        \\n        for(auto x: mp){\\n            if(x.second == 1){\\n                return x.first;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n**Solution 5: Using Binary Search**\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& arr) {\\n        int low = 0, high = arr.size()-1;\\n        \\n        while(low<high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(mid>0 and mid<arr.size()-1){\\n                \\n                if(arr[mid] != arr[mid+1] and arr[mid]!=arr[mid-1]){\\n                    return arr[mid];\\n                }\\n                \\n                else if(arr[mid] == arr[mid+1]){\\n                    if((abs(mid-low))%2 == 0){\\n                        low = mid+2;\\n                    }\\n                    \\n                    else{\\n                        high = mid-1;\\n                    }\\n                }\\n                \\n                else if(arr[mid] == arr[mid-1]){\\n                    if((abs(mid-low))%2 == 0){\\n                        high = mid-2;\\n                    }\\n                    \\n                    else{\\n                        low = mid+1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return arr[low];\\n    }\\n};\\n```\\n\\n***If you really liked it....Do consider upvoting it...any queries and comments are hearby welcomed***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        for(int x: nums){\\n            ans^=x;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int i = 0;\\n        for(; i<nums.size()-1; i+=2){\\n            if(nums[i]!=nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        \\n        return nums[i];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_set<int>us;\\n        \\n        for(int x: nums){\\n            if(us.find(x) != us.end()){\\n                us.erase(x);\\n            }\\n            \\n            else{\\n                us.insert(x);\\n            }\\n        }\\n        \\n        return *us.begin();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int>mp;\\n        \\n        for(int x: nums){\\n            mp[x]++;\\n        }\\n        \\n        for(auto x: mp){\\n            if(x.second == 1){\\n                return x.first;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& arr) {\\n        int low = 0, high = arr.size()-1;\\n        \\n        while(low<high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(mid>0 and mid<arr.size()-1){\\n                \\n                if(arr[mid] != arr[mid+1] and arr[mid]!=arr[mid-1]){\\n                    return arr[mid];\\n                }\\n                \\n                else if(arr[mid] == arr[mid+1]){\\n                    if((abs(mid-low))%2 == 0){\\n                        low = mid+2;\\n                    }\\n                    \\n                    else{\\n                        high = mid-1;\\n                    }\\n                }\\n                \\n                else if(arr[mid] == arr[mid-1]){\\n                    if((abs(mid-low))%2 == 0){\\n                        high = mid-2;\\n                    }\\n                    \\n                    else{\\n                        low = mid+1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return arr[low];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588464,
                "title": "simple-python-solution",
                "content": "# python one of the easiest solution.\\n\\tclass Solution:\\n\\t\\tdef singleNonDuplicate(self, nums: List[int]) -> int:\\n\\t\\t\\tc=0\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\tif nums.count(i)==1:\\n\\t\\t\\t\\t\\treturn i\\n\\t\\t\\t\\t\\t\\nPlease UPVOTE if you like the Solution",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# python one of the easiest solution.\\n\\tclass Solution:\\n\\t\\tdef singleNonDuplicate(self, nums: List[int]) -> int:\\n\\t\\t\\tc=0\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\tif nums.count(i)==1:\\n\\t\\t\\t\\t\\treturn i\\n\\t\\t\\t\\t\\t\\nPlease UPVOTE if you like the Solution",
                "codeTag": "Java"
            },
            {
                "id": 1588229,
                "title": "cpp-100-in-o-logn-time-o-1-space",
                "content": "**Binary Search Solution**\\nTime Complexity: **O(logn)**\\nSpace Complexity: **O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint singleNonDuplicate(vector<int>& nums) {\\n\\t\\t\\tif(nums.size() == 1) return nums[0];\\n\\t\\t\\t int l = 0 , r = nums.size()-1;\\n\\t\\t\\tint mid;\\n\\t\\t\\twhile(l <= r){\\n\\t\\t\\t\\tmid = l + (r-l)/2;\\n\\t\\t\\t\\tif(mid > 0 && mid < nums.size()-1 && nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1])\\n\\t\\t\\t\\t\\treturn nums[mid];\\n\\t\\t\\t\\tif(mid == nums.size()-1 && nums[mid] != nums[mid-1])\\n\\t\\t\\t\\t\\treturn nums[mid];\\n\\t\\t\\t\\tif(mid == 0 && nums[mid] != nums[mid+1])\\n\\t\\t\\t\\t\\treturn nums[mid];\\n\\t\\t\\t\\tif(mid&1){\\n\\t\\t\\t\\t\\tif(mid > 0 && nums[mid] == nums[mid-1])\\n\\t\\t\\t\\t\\t\\tl = mid+1;\\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t\\tr = mid-1;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tif(mid < nums.size()-1 && nums[mid] == nums[mid+1])\\n\\t\\t\\t\\t\\t\\tl = mid+1;                    \\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\tr = mid-1; \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t\\n**Using XOR:**\\n\\tTime Complexity : **O(n)**\\n\\tSpace Complexity : **O(1)**\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tint singleNonDuplicate(vector<int>& nums) {\\n\\t\\t\\tif(nums.size() == 1) return nums[0];\\n\\t\\t\\tint xOr = 0;\\n\\t\\t\\tfor(int i : nums)\\n\\t\\t\\t\\txOr ^= i;\\n\\t\\t\\treturn xOr;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tint singleNonDuplicate(vector<int>& nums) {\\n\\t\\t\\tif(nums.size() == 1) return nums[0];\\n\\t\\t\\t int l = 0 , r = nums.size()-1;\\n\\t\\t\\tint mid;\\n\\t\\t\\twhile(l <= r){\\n\\t\\t\\t\\tmid = l + (r-l)/2;\\n\\t\\t\\t\\tif(mid > 0 && mid < nums.size()-1 && nums[mid] != nums[mid-1] && nums[mid] != nums[mid+1])\\n\\t\\t\\t\\t\\treturn nums[mid];\\n\\t\\t\\t\\tif(mid == nums.size()-1 && nums[mid] != nums[mid-1])\\n\\t\\t\\t\\t\\treturn nums[mid];\\n\\t\\t\\t\\tif(mid == 0 && nums[mid] != nums[mid+1])\\n\\t\\t\\t\\t\\treturn nums[mid];\\n\\t\\t\\t\\tif(mid&1){\\n\\t\\t\\t\\t\\tif(mid > 0 && nums[mid] == nums[mid-1])\\n\\t\\t\\t\\t\\t\\tl = mid+1;\\n\\t\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\t\\tr = mid-1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1588059,
                "title": "simple-one-liner-python",
                "content": "```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        return Counter(nums).most_common()[-1][0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        return Counter(nums).most_common()[-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587725,
                "title": "runtime-0ms-faster-than-100-java-submission-binary-search",
                "content": "```\\npublic int singleNonDuplicate(int[] nums) {\\n        int low =0;\\n        int high = nums.length -1;\\n        while(low < high)\\n        {\\n            int mid = (low + high) / 2;\\n            if(mid % 2 == 1)\\n                if(nums[mid - 1] == nums[mid])\\n                    low = mid + 1;\\n                else\\n                    high = mid;\\n            else if(nums[mid] == nums[mid+1])\\n                low = mid + 2;\\n            else high = mid;\\n        }\\n        return nums[low];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int singleNonDuplicate(int[] nums) {\\n        int low =0;\\n        int high = nums.length -1;\\n        while(low < high)\\n        {\\n            int mid = (low + high) / 2;\\n            if(mid % 2 == 1)\\n                if(nums[mid - 1] == nums[mid])\\n                    low = mid + 1;\\n                else\\n                    high = mid;\\n            else if(nums[mid] == nums[mid+1])\\n                low = mid + 2;\\n            else high = mid;\\n        }\\n        return nums[low];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1552854,
                "title": "c-o-log-n-o-1-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n      // ye maan ke chlna hai ki left half me hoga sirf repeated elemnt aur right half me hoga ek uniques aur baaki repeated\\n      // aab left half me khali repeated hai islie sb sb repeated elemrnt even index se start  hoga aur odd me hoga khtm\\n      // right me ek unique b hai islie ye order ni hoga \\n      // mid nikalenge\\n      // agar mid even hai to check krnge mid+1 same element hai ki nai mid type (agar hoga tlb left half me hai to left ko //         //mid+1 kr denge)\\n      // agar ni to wo right half me haito usme ko right ko mid-1 kr denge\\n      \\n       int low=0;\\n       int high= nums.size()-2;\\n        while(low<=high){\\n            int mid =low+(high-low)/2;\\n            if(mid%2==0){\\n                if(nums[mid+1]==nums[mid]) low=mid+1;\\n                else high=mid-1;\\n            }\\n          else{\\n             if(mid-1>=0 && nums[mid-1]==nums[mid]) low=mid+1;\\n                else high=mid-1;\\n          }\\n        }\\n       return nums[low];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n      // ye maan ke chlna hai ki left half me hoga sirf repeated elemnt aur right half me hoga ek uniques aur baaki repeated\\n      // aab left half me khali repeated hai islie sb sb repeated elemrnt even index se start  hoga aur odd me hoga khtm\\n      // right me ek unique b hai islie ye order ni hoga \\n      // mid nikalenge\\n      // agar mid even hai to check krnge mid+1 same element hai ki nai mid type (agar hoga tlb left half me hai to left ko //         //mid+1 kr denge)\\n      // agar ni to wo right half me haito usme ko right ko mid-1 kr denge\\n      \\n       int low=0;\\n       int high= nums.size()-2;\\n        while(low<=high){\\n            int mid =low+(high-low)/2;\\n            if(mid%2==0){\\n                if(nums[mid+1]==nums[mid]) low=mid+1;\\n                else high=mid-1;\\n            }\\n          else{\\n             if(mid-1>=0 && nums[mid-1]==nums[mid]) low=mid+1;\\n                else high=mid-1;\\n          }\\n        }\\n       return nums[low];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369895,
                "title": "o-logn-simple-logic-explanation",
                "content": "Notice: All elements except one appears 2 times -> total number of elements = (2*N + 1)\\n\\nAlgo:\\n1. Find Mid\\n2. if(Nums[Mid] == Nums[Mid-1])\\n\\tThen, if total number of elements from Mid to End is even -> all elements are duplicate on the right\\n\\t\\t\\t->Serach in left\\n\\tElse -> search in right\\n3. Else if(Nums[Mid] == Nums[Mid+1])\\n\\tThen, if total number of elements from Mid to Start is even -> all elements are duplicate on the left\\n\\t\\t\\t->Serach in Right\\n\\tElse -> search in Left\\n4. return Nums[Mid]\\n\\nHence, the below code will work\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicateFinal(vector<int>& nums, int begin, int end, int actBegin, int actEnd){\\n\\t   int mid = (begin + end)/2;\\n       if(nums[mid] == nums[mid-1]){\\n            if((mid - actBegin)%2 == 1)\\n                begin = mid;\\n            else\\n                end = mid;\\n        }\\n        else if(nums[mid] == nums[mid+1]){\\n            if((actEnd - mid)%2 == 1)\\n                end = mid;\\n            else\\n                begin = mid;\\n        }\\n        else\\n            return nums[mid];\\n        return singleNonDuplicateFinal(nums, begin, end, actBegin, actEnd);\\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        return singleNonDuplicateFinal(nums, 0, nums.size()-1, 0, nums.size()-1);\\n    }\\n};\\n```\\n\\nNow, we need to add few boundary cases (otherwise it might crash/go to infinite loop), like if mid = 0, mid = nums.size()-1, start = end - 1 (here, mid will always be equal to start)\\n\\nFinal Solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicateFinal(vector<int>& nums, int begin, int end, int actBegin, int actEnd){\\n        //cout << begin << \" : \" << end << endl;\\n        int mid = (begin + end)/2;\\n        \\n        if(mid == actBegin || mid == actEnd)\\n            return nums[mid];\\n        \\n        if(mid == begin && nums[mid] == nums[mid-1])\\n            return nums[mid+1];\\n        else if(mid == begin && nums[mid+1] == nums[mid+2])\\n            return nums[mid];\\n            \\n        if(nums[mid] == nums[mid-1]){\\n            if((mid - actBegin)%2 == 1)\\n                begin = mid;\\n            else\\n                end = mid;\\n        }\\n        else if(nums[mid] == nums[mid+1]){\\n            if((actEnd - mid)%2 == 1)\\n                end = mid;\\n            else\\n                begin = mid;\\n        }\\n        else\\n            return nums[mid];\\n        return singleNonDuplicateFinal(nums, begin, end, actBegin, actEnd);\\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        return singleNonDuplicateFinal(nums, 0, nums.size()-1, 0, nums.size()-1);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicateFinal(vector<int>& nums, int begin, int end, int actBegin, int actEnd){\\n\\t   int mid = (begin + end)/2;\\n       if(nums[mid] == nums[mid-1]){\\n            if((mid - actBegin)%2 == 1)\\n                begin = mid;\\n            else\\n                end = mid;\\n        }\\n        else if(nums[mid] == nums[mid+1]){\\n            if((actEnd - mid)%2 == 1)\\n                end = mid;\\n            else\\n                begin = mid;\\n        }\\n        else\\n            return nums[mid];\\n        return singleNonDuplicateFinal(nums, begin, end, actBegin, actEnd);\\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        return singleNonDuplicateFinal(nums, 0, nums.size()-1, 0, nums.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicateFinal(vector<int>& nums, int begin, int end, int actBegin, int actEnd){\\n        //cout << begin << \" : \" << end << endl;\\n        int mid = (begin + end)/2;\\n        \\n        if(mid == actBegin || mid == actEnd)\\n            return nums[mid];\\n        \\n        if(mid == begin && nums[mid] == nums[mid-1])\\n            return nums[mid+1];\\n        else if(mid == begin && nums[mid+1] == nums[mid+2])\\n            return nums[mid];\\n            \\n        if(nums[mid] == nums[mid-1]){\\n            if((mid - actBegin)%2 == 1)\\n                begin = mid;\\n            else\\n                end = mid;\\n        }\\n        else if(nums[mid] == nums[mid+1]){\\n            if((actEnd - mid)%2 == 1)\\n                end = mid;\\n            else\\n                begin = mid;\\n        }\\n        else\\n            return nums[mid];\\n        return singleNonDuplicateFinal(nums, begin, end, actBegin, actEnd);\\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        return singleNonDuplicateFinal(nums, 0, nums.size()-1, 0, nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1316862,
                "title": "c-easy-solution-check-for-left-and-right-half-o-log-n",
                "content": "check wheather it is a left or right half\\n\\nwe will take the mid and check wheather its a left or right half\\n\\n[1,1,2,2,3,4,4]\\n[0,1,2,3,4,5,6] -> index\\n \\n=> for left half ->  first instance will apppear at even index and second instance will appear                      at odd index\\n=> for right half -> first instace will appear at odd index and second instance will appear at                      even index\\nlow =0 high = 5\\n1) mid = 2 -> even -> first instance then check for second instance ? yes -> low = mid+1;\\n\\nlow = 3 high = 5\\n2) mid  = 4  ->  even -> first instance then check second instance ? no -> high = mid-1;\\n\\nlow = 3 high = 4 -> return low ->ans;\\n\\n**Solution**\\n```\\nclass Solution {\\npublic:\\n\\n    int singleNonDuplicate(vector<int>& nums) {\\n        \\n    int low = 0; int high = nums.size()-2;\\n    \\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            \\n            if(nums[mid]==nums[mid^1])\\n                low = mid+1;\\n            else high = mid-1;\\n            \\n        }\\n        return nums[low];\\n        \\n    }\\n};\\n\\n\\n```\\n\\n**NOTE** : we are taking high = size -2,because   if single element is present  at last index then low will shrink to the last index \\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int singleNonDuplicate(vector<int>& nums) {\\n        \\n    int low = 0; int high = nums.size()-2;\\n    \\n        while(low<=high){\\n            int mid = low+(high-low)/2;\\n            \\n            if(nums[mid]==nums[mid^1])\\n                low = mid+1;\\n            else high = mid-1;\\n            \\n        }\\n        return nums[low];\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256195,
                "title": "iterative-binary-search-easy-js-solution",
                "content": "```\\nvar singleNonDuplicate = function(nums) {\\n    let low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        let mid = low + Math.floor((high - low) / 2);\\n        if (mid > 0 && nums[mid-1] === nums[mid]) {\\n            let dist = mid-1; // # of elements between 0 and mid-2 inclusive\\n            (dist % 2 === 0) ? low = mid + 1 : high = mid - 2;\\n        } else if (mid < nums.length-1 && nums[mid] === nums[mid+1]) {\\n            let dist = nums.length - (mid+2); // # of elements bewteen mid+2 and end of array inclusive\\n            (dist % 2 === 0) ? high = mid - 1 : low = mid + 2;\\n        } else {\\n            return nums[mid];\\n        }\\n    }\\n    return -1; // should never be reached\\n    // T.C: O(log(N))\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar singleNonDuplicate = function(nums) {\\n    let low = 0, high = nums.length - 1;\\n    while (low <= high) {\\n        let mid = low + Math.floor((high - low) / 2);\\n        if (mid > 0 && nums[mid-1] === nums[mid]) {\\n            let dist = mid-1; // # of elements between 0 and mid-2 inclusive\\n            (dist % 2 === 0) ? low = mid + 1 : high = mid - 2;\\n        } else if (mid < nums.length-1 && nums[mid] === nums[mid+1]) {\\n            let dist = nums.length - (mid+2); // # of elements bewteen mid+2 and end of array inclusive\\n            (dist % 2 === 0) ? high = mid - 1 : low = mid + 2;\\n        } else {\\n            return nums[mid];\\n        }\\n    }\\n    return -1; // should never be reached\\n    // T.C: O(log(N))\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002355,
                "title": "simple-c-solution-using-binary-search",
                "content": "**Runtime: 12 ms, faster than 93.24% of C++ online submissions for Single Element in a Sorted Array.\\nMemory Usage: 11.3 MB, less than 49.50% of C++ online submissions for Single Element in a Sorted Array.**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n      \\n        int high = nums.size()-1;\\n        int low = 0;\\n        int mid;\\n        \\n        //Boundary cases\\n        if(high==0)\\n            return nums[0];\\n        else if(nums[0]!=nums[1])\\n            return nums[0];\\n        else if(nums[high]!=nums[high-1])\\n            return nums[high];\\n\\n        while(low<=high)\\n        {\\n            mid = low + (high-low)/2;\\n            //Unique element condition\\n            if(nums[mid]!=nums[mid+1] && nums[mid]!=nums[mid-1])\\n                return nums[mid];\\n            \\n            //left and right side cases\\n            if(((mid%2)==0 && nums[mid]==nums[mid+1])\\n               ||  ((mid%2)==1 && nums[mid]==nums[mid-1]))\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n      \\n        int high = nums.size()-1;\\n        int low = 0;\\n        int mid;\\n        \\n        //Boundary cases\\n        if(high==0)\\n            return nums[0];\\n        else if(nums[0]!=nums[1])\\n            return nums[0];\\n        else if(nums[high]!=nums[high-1])\\n            return nums[high];\\n\\n        while(low<=high)\\n        {\\n            mid = low + (high-low)/2;\\n            //Unique element condition\\n            if(nums[mid]!=nums[mid+1] && nums[mid]!=nums[mid-1])\\n                return nums[mid];\\n            \\n            //left and right side cases\\n            if(((mid%2)==0 && nums[mid]==nums[mid+1])\\n               ||  ((mid%2)==1 && nums[mid]==nums[mid-1]))\\n                low = mid+1;\\n            else\\n                high = mid-1;\\n            \\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992417,
                "title": "c-linq",
                "content": "I know not using linq could have a better performance.\\nBut C# + linq is just such a lazy solution.\\nFirst group all the same nums and get the count.\\nNext you order the count by ascending.\\nThen you take out the top 1, which is exactly the answer which in array with count == 1\\n\\n```\\npublic int SingleNonDuplicate(int[] nums)\\n{\\n\\tint ans = 0;\\n\\tvar numsCount = (from num in nums\\n\\t\\t\\t\\t\\t group num by num into numGrp\\n\\t\\t\\t\\t\\t orderby numGrp.Count() ascending\\n\\t\\t\\t\\t\\t select numGrp.Key).ToList();\\n\\tans = numsCount[0];\\n\\treturn ans;\\n}\\n",
                "solutionTags": [],
                "code": "I know not using linq could have a better performance.\\nBut C# + linq is just such a lazy solution.\\nFirst group all the same nums and get the count.\\nNext you order the count by ascending.\\nThen you take out the top 1, which is exactly the answer which in array with count == 1\\n\\n```\\npublic int SingleNonDuplicate(int[] nums)\\n{\\n\\tint ans = 0;\\n\\tvar numsCount = (from num in nums\\n\\t\\t\\t\\t\\t group num by num into numGrp\\n\\t\\t\\t\\t\\t orderby numGrp.Count() ascending\\n\\t\\t\\t\\t\\t select numGrp.Key).ToList();\\n\\tans = numsCount[0];\\n\\treturn ans;\\n}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 804251,
                "title": "easy-c-solution",
                "content": "```\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int low = 0, high = nums.size() - 1;\\n        while (low < high) {\\n            int mid = low + (high - low)/2;\\n            // index => 0 1 2 3 4 5 6 7 \\n            // if mid is even and elem at mid is equal to elem at mid - 1,\\n            //then we can analyse that the single elem must be present \\n            //on the left of mid\\n            if (mid % 2 == 0) {\\n                if (nums[mid] == nums[mid - 1]) {\\n                    high = mid;\\n                }\\n                else{\\n                    low = mid;\\n                }\\n            }\\n\\t\\t\\t// index => 0 1 2 3 4 5 6 7 \\n            // if mid is odd and elem at mid is equal to elem at mid - 1,\\n            //then we can analyse that the single elem must be present \\n            //on the right of mid\\n            else {\\n                if (nums[mid] == nums[mid - 1]) {\\n                    low = mid + 1;\\n                }\\n                else {\\n                    high = mid - 1;\\n                }\\n            }\\n            \\n        }\\n        return nums[low];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int low = 0, high = nums.size() - 1;\\n        while (low < high) {\\n            int mid = low + (high - low)/2;\\n            // index => 0 1 2 3 4 5 6 7 \\n            // if mid is even and elem at mid is equal to elem at mid - 1,\\n            //then we can analyse that the single elem must be present \\n            //on the left of mid\\n            if (mid % 2 == 0) {\\n                if (nums[mid] == nums[mid - 1]) {\\n                    high = mid;\\n                }\\n                else{\\n                    low = mid;\\n                }\\n            }\\n\\t\\t\\t// index => 0 1 2 3 4 5 6 7 \\n            // if mid is odd and elem at mid is equal to elem at mid - 1,\\n            //then we can analyse that the single elem must be present \\n            //on the right of mid\\n            else {\\n                if (nums[mid] == nums[mid - 1]) {\\n                    low = mid + 1;\\n                }\\n                else {\\n                    high = mid - 1;\\n                }\\n            }\\n            \\n        }\\n        return nums[low];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 659572,
                "title": "python-3-binary-search-with-explanations",
                "content": "Update:\\nLet\\'s try to solve a similar problem. \\nYou have a sorted array where each element is repeated thrice except one. Now your job is to find the single number. Can you do it? (Maybe using binary search?)\\nConfused? \\nHere is the solution: https://pastebin.com/HZ4U9emi\\n\\nNot interested? Not right now? Ok, try it some other time. You\\'ll find below what you are looking for. \\n\\n=====================================\\nExplaination:\\n\\nLook carefully, \\nWhen we have an array where everything appears twice like this one -\\n1, 1, 2, 2, 3, 3, 4, 4\\neach number first occurs at an even position gets repeated at the next odd position. \\n1 appears at 0, get repeated at 1\\n4 appears at 6, get repeated at 7\\n\\nNow what if a number appears just for once? The scenerio is turned upside down after that number\\'s position. \\n\\nHave a look:\\n\\n1, 1, 2, 2, 3, 4, 4, 5, 5\\n\\nhere 3 just apeared for once, so \\nbefore 3 =>\\n1 appears at postion 0, get repeated at postion 1\\n2 appears at postion 2, get repeated at postion 3\\nafter 3 appears at position 4 =>\\n4 appears at postion 5, get repeated at postion 6\\n5 appears at postion 7, get repeated at postion 8\\n\\nwhich means that, the element which appeared just for once, resides after 1 and 2 but before 4 and 5\\n\\nNow using this method we will solve it. \\n\\nUse binary search to find the element at the mid.\\n```\\nif mid is even -\\n\\tif nums[mid] == nums[mid+1]\\n\\t\\t#the elemnt resides after mid+1\\n\\telse\\n\\t\\t#the elemnt may resides before mid, or nums[mid] is the element itself\\n\\t\\t\\nif mid is odd -\\n\\tif nums[mid] == nums[mid-1]\\n\\t\\t# the elemnt resides after mid\\n\\telse\\n\\t\\t# the element resides before mid\\n\\t\\t# point to be noted, nums[mid] can never be the element since mid is odd\\n\\t\\t# according to the logic the single elemnt will only appear at an even index\\n```\\n\\n\\nHere is the code:\\n\\n\\n```\\ndef singleNonDuplicate(self, nums: List[int]) -> int:\\n\\treturn self.binary_search(nums, 0, len(nums)-1)\\n\\ndef binary_search(self, nums:List[int], low:int, high:int) -> int:\\n\\tif low>high:\\n\\t\\treturn None\\n\\tif low==high:\\n\\t\\treturn nums[low]\\n\\n\\tmid = (low+high)//2\\n\\n\\tif mid%2==0:\\n\\t\\tif nums[mid]==nums[mid+1]:\\n\\t\\t\\treturn self.binary_search(nums, mid+2, high)\\n\\t\\telse:\\n\\t\\t\\treturn self.binary_search(nums, low, mid)\\n\\telse:\\n\\t\\tif nums[mid]==nums[mid-1]:\\n\\t\\t\\treturn self.binary_search(nums, mid+1, high)\\n\\t\\telse:\\n\\t\\t\\treturn self.binary_search(nums, low, mid-1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nif mid is even -\\n\\tif nums[mid] == nums[mid+1]\\n\\t\\t#the elemnt resides after mid+1\\n\\telse\\n\\t\\t#the elemnt may resides before mid, or nums[mid] is the element itself\\n\\t\\t\\nif mid is odd -\\n\\tif nums[mid] == nums[mid-1]\\n\\t\\t# the elemnt resides after mid\\n\\telse\\n\\t\\t# the element resides before mid\\n\\t\\t# point to be noted, nums[mid] can never be the element since mid is odd\\n\\t\\t# according to the logic the single elemnt will only appear at an even index\\n```\n```\\ndef singleNonDuplicate(self, nums: List[int]) -> int:\\n\\treturn self.binary_search(nums, 0, len(nums)-1)\\n\\ndef binary_search(self, nums:List[int], low:int, high:int) -> int:\\n\\tif low>high:\\n\\t\\treturn None\\n\\tif low==high:\\n\\t\\treturn nums[low]\\n\\n\\tmid = (low+high)//2\\n\\n\\tif mid%2==0:\\n\\t\\tif nums[mid]==nums[mid+1]:\\n\\t\\t\\treturn self.binary_search(nums, mid+2, high)\\n\\t\\telse:\\n\\t\\t\\treturn self.binary_search(nums, low, mid)\\n\\telse:\\n\\t\\tif nums[mid]==nums[mid-1]:\\n\\t\\t\\treturn self.binary_search(nums, mid+1, high)\\n\\t\\telse:\\n\\t\\t\\treturn self.binary_search(nums, low, mid-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 629600,
                "title": "binary-search-explained",
                "content": "**Observation** : Each pair elements are starting from even index and end at odd index until some unique element(ans). After that unique element, the pair elements start at odd index and end at even index. \\n\\n\\n**Approach** : Start binary search with low and high, if the mid follows the first condition, then the unique element can\\'t be in left half so low = mid+1, else the opposite.\\n\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& a) {\\n        int low = 0, high = a.size()-1;\\n        //Check if the unique element is at the boundary\\n        if(high == 0) return a[high];\\n        if(a[low] != a[low+1])return a[low];\\n        if(a[high] != a[high-1])return a[high];\\n        \\n        //Search\\n        while(low <= high){\\n            int mid = low + ((high-low)>>1);\\n            if(a[mid] != a[mid-1] && a[mid] != a[mid+1])return a[mid];\\n            \\n            //if mid index is odd and prev element is same as mid element or mid index is even and next element is same as mid element, it means the order has not yet been disrupted, so search in right half\\n            if( ((mid%2 == 1) && a[mid-1] == a[mid]) || ((mid%2 == 0) && a[mid] == a[mid+1]) ){\\n                low = mid+1;\\n            }\\n            else {\\n                high = mid-1;\\n            }   \\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& a) {\\n        int low = 0, high = a.size()-1;\\n        //Check if the unique element is at the boundary\\n        if(high == 0) return a[high];\\n        if(a[low] != a[low+1])return a[low];\\n        if(a[high] != a[high-1])return a[high];\\n        \\n        //Search\\n        while(low <= high){\\n            int mid = low + ((high-low)>>1);\\n            if(a[mid] != a[mid-1] && a[mid] != a[mid+1])return a[mid];\\n            \\n            //if mid index is odd and prev element is same as mid element or mid index is even and next element is same as mid element, it means the order has not yet been disrupted, so search in right half\\n            if( ((mid%2 == 1) && a[mid-1] == a[mid]) || ((mid%2 == 0) && a[mid] == a[mid+1]) ){\\n                low = mid+1;\\n            }\\n            else {\\n                high = mid-1;\\n            }   \\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629387,
                "title": "begginer-friendly-a-rather-lengthy-but-heavily-commented-soln",
                "content": "\\n\\n//THE LOGIC IN PLAY IS THAT\\n//SINCE ALL THE ELEMNT OCCUR TWIC AND ONE ELEMENT EXACTY ONCE\\n**//THE LENGTH OF THE ARRAY CONTAINING THE EXACTLY ONE ELEMENT WILL BE ODD**\\n\\n```\\nvar singleNonDuplicate = function(arr) {\\n  \\n  const binary = (start,end) => {\\n    if(start == end) { return arr[start]} //BASE CASE\\n    \\n    let  mid = start + Math.floor((end-start)/2);//FIND MID\\n      \\n    //IF MID IS UNIQUE\\n    if(( arr[mid] != arr[mid-1] )&& (arr[mid] != arr[mid+1])) { return arr[mid] }\\n    \\n    //FIND LEFT AND RIGHT ARRAR LENGTH SEPERATED BY MID  \\n    let l,r;\\n      \\n    if(arr[mid-1] == arr[mid]){ // IF THE ELEMENT LEFT TO MID IS SAME AS MID\\n      l = mid-start-1;// -1 FOR COMPUTING THE LNGTH REMOVING THE SAME ELEMENT AS MID \\n      r = end-mid\\n    }else{// THE RIGHT ELEMNT TO MID IS SAME AS MID\\n      l = mid-start; \\n      r = end-mid-1;// IGNORE THE SAME ELEMENT AND COMPUTE THE LENGTH SO -1\\n      }\\n      \\n    \\n    if(l%2 != 0){// IF LEFT LENGTH IS ODD\\n      if(arr[mid-1] ==arr[mid]){ // AND THE LEFT TO MID IS SAME AS MID \\n        return binary(start,mid-2)// APPLY SEARCH ON THE LEFT REMOVING THE SAME ELEMNT\\n        }\\n      else{// LEFT TO MID IS NOT SAME AS MID SO NO NEED TO REMOVE ANY THING\\n          return binary(start, (mid-1));// JUST APPLY APPLY SEARCH TO LEFT \\n        }\\n    }  \\n    // IF RIGHT LENGTH IS ODD  \\n    //APPLY THE SAME LOGIC AS RIGHT   \\n    else{\\n      if(arr[mid+1] ==arr[mid]){  \\n        return binary(mid+2,end)\\n        }\\n      else{\\n          return binary(mid+1,end)\\n      }\\n    }\\n  }\\n  \\n  return binary(0, arr.length-1); \\n \\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nvar singleNonDuplicate = function(arr) {\\n  \\n  const binary = (start,end) => {\\n    if(start == end) { return arr[start]} //BASE CASE\\n    \\n    let  mid = start + Math.floor((end-start)/2);//FIND MID\\n      \\n    //IF MID IS UNIQUE\\n    if(( arr[mid] != arr[mid-1] )&& (arr[mid] != arr[mid+1])) { return arr[mid] }\\n    \\n    //FIND LEFT AND RIGHT ARRAR LENGTH SEPERATED BY MID  \\n    let l,r;\\n      \\n    if(arr[mid-1] == arr[mid]){ // IF THE ELEMENT LEFT TO MID IS SAME AS MID\\n      l = mid-start-1;// -1 FOR COMPUTING THE LNGTH REMOVING THE SAME ELEMENT AS MID \\n      r = end-mid\\n    }else{// THE RIGHT ELEMNT TO MID IS SAME AS MID\\n      l = mid-start; \\n      r = end-mid-1;// IGNORE THE SAME ELEMENT AND COMPUTE THE LENGTH SO -1\\n      }\\n      \\n    \\n    if(l%2 != 0){// IF LEFT LENGTH IS ODD\\n      if(arr[mid-1] ==arr[mid]){ // AND THE LEFT TO MID IS SAME AS MID \\n        return binary(start,mid-2)// APPLY SEARCH ON THE LEFT REMOVING THE SAME ELEMNT\\n        }\\n      else{// LEFT TO MID IS NOT SAME AS MID SO NO NEED TO REMOVE ANY THING\\n          return binary(start, (mid-1));// JUST APPLY APPLY SEARCH TO LEFT \\n        }\\n    }  \\n    // IF RIGHT LENGTH IS ODD  \\n    //APPLY THE SAME LOGIC AS RIGHT   \\n    else{\\n      if(arr[mid+1] ==arr[mid]){  \\n        return binary(mid+2,end)\\n        }\\n      else{\\n          return binary(mid+1,end)\\n      }\\n    }\\n  }\\n  \\n  return binary(0, arr.length-1); \\n \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 629239,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n    if (nums.length < 1) {\\n        return nums;\\n    }\\n    \\n    let low = 0;\\n    let high = nums.length;\\n    let mid;\\n    \\n    while (low <= high) {\\n        mid = low + (Math.floor((high - low) / 2));\\n\\n        if (nums[mid] !== nums[mid + 1] && nums[mid] !== nums[mid - 1]) {\\n            return nums[mid];\\n        } else {\\n            if( (mid % 2 === 0 && nums[mid] === nums[mid+1]) || \\n                (mid % 2 !== 0 && nums[mid] !== nums[mid + 1])\\n              ) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n    if (nums.length < 1) {\\n        return nums;\\n    }\\n    \\n    let low = 0;\\n    let high = nums.length;\\n    let mid;\\n    \\n    while (low <= high) {\\n        mid = low + (Math.floor((high - low) / 2));\\n\\n        if (nums[mid] !== nums[mid + 1] && nums[mid] !== nums[mid - 1]) {\\n            return nums[mid];\\n        } else {\\n            if( (mid % 2 === 0 && nums[mid] === nums[mid+1]) || \\n                (mid % 2 !== 0 && nums[mid] !== nums[mid + 1])\\n              ) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 628911,
                "title": "java-fastest-o-log-n-2-runtime-and-o-1-space-comprehensible-explanation",
                "content": "**Intuition ->**\\n\\nLet\\'s assume the nonDuplicate occurs at **ith** position. Since there is only one nonDuplicate we can deduce that all the **values before i** definetely are **pairs** (i.e No. of values before i are always even) -> Finally we can conclude that **\\'i\\' is always odd (even index in array)**\\n\\nSo let\\'s assume index **\\'x\\'** corresponds to all **even indices (odd positions)**. If you observe carefully ->\\n**For All (x  < i)  nums[x] is always equal to nums[x+1]**  || Kudos.. Breakpoint for binary search\\n\\nSo let\\'s implement **binary search** and **consider only even indices** in the array(odd positions).Then our **sample size** becomes -> **n/2** and since time complexity of binary search is O(log size), Our **time complexity will be O(log n/2)** which is the **fastest** out there.. Ofcourse it\\'s only one iteration slower than O(log n) in some cases but yeah the fastest.\\n\\n\\n**Algo ->**\\n\\n**while (start <= end)**\\n- **mid = (start+end)/2 OR (start+end)/2 + 1 -> Since we consider only odd positions.**\\n\\t- **if( value at mid == value at (mid+1)**\\n\\t\\t- **then start = mid + 2**\\n\\t- **else** \\n\\t\\t - **end = mid - 2**\\n\\n**return nums[start]** \\n\\n***Note** -> **start,end,mid** are always **even indices** that represent odd positions.*\\n\\n***Note** -> Since our algo won\\'t work for **last index**, we\\'ll check that **manually**.*\\n\\n```\\npublic int singleNonDuplicate(int[] nums) {\\n        int len = nums.length, start = 0, end = len-3, mid;\\n        if (len > 1) { if (nums[len-1]!=nums[len-2]) return nums[len-1];}\\n        while(start <= end){\\n            mid = (start + end)%4 == 0 ? (start+end)/2 : (start+end)/2 + 1;\\n            if(nums[mid] == nums[mid+1]) { start = mid+2; }\\n            else{ end = mid - 2; }\\n        }\\n        return nums[start];\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int singleNonDuplicate(int[] nums) {\\n        int len = nums.length, start = 0, end = len-3, mid;\\n        if (len > 1) { if (nums[len-1]!=nums[len-2]) return nums[len-1];}\\n        while(start <= end){\\n            mid = (start + end)%4 == 0 ? (start+end)/2 : (start+end)/2 + 1;\\n            if(nums[mid] == nums[mid+1]) { start = mid+2; }\\n            else{ end = mid - 2; }\\n        }\\n        return nums[start];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 628648,
                "title": "c-pairwise-binary-search",
                "content": "This is a basic binary search, with some modifications that follow naturally.\\n\\nFirst: In order to determine if you\\'ve landed on the correct element, then you need to compare the current value with the previous and the next element. If you\\'re on the correct element, then all three elements are different.\\n\\nSo, change #1 looks something like this:\\n```\\nint prevVal = nums[mid - 1];\\nint nextVal = nums[mid + 1];\\nif (midVal != prevVal && midVal != nextVal) {\\n  return midVal;\\n}\\n```\\n\\nThis now leads to the second modification of binary search. Since we need to check the next value and the previous value,\\nthere\\'s new bounds checking we need to do  - if the target index is the beginning or the end of the array.\\n\\nFor the ends of the array, if the midpoint has reached that point, then (at best) the possible indices are [0, 1] if it\\'s the start or [n - 2, n - 1] for the end. With a little bit of thought, we realize that the only valid case if the midpoint gets to this point is the very last item.\\nLet\\'s consider the two possible cases:\\n[0, 1, 1, ....]\\n[1, 1, 2, 3, 3, ...]\\nIt\\'s not possible for the target index to be 1, because for that to happen the previous item would have to be duplicated. However there\\'s no place for the matching pair to go. The same logic follows for the end.\\n\\nThat leads to this bit of code:\\n```\\nif (mid == 0 || mid == numsSize - 1) {\\n  return nums[mid];\\n}\\n```\\n\\nAnd now the very last thing to do is to figure out which direction to go. Here\\'s the part where you have to sit and think about it for a bit and come up with the trick. The trick is that before the singleton, each pair starts at an even index. E.g. indices 0, 2, 4, 6, 8, ... all contain the first number of a pair. Then there\\'s a singleton, which is on an even index. Then there are more pairs afterwards. These pairs after the singleton are out-of-phase. They start on an odd index. Let\\'s look at an example:\\n```\\nindices: [0, 1, 2, 3, 4, 5, 6, 7, 8]\\nvalues:  [2, 2, 3, 3, 6, 7, 7, 8, 8]\\n```\\nNote how the pair of 2\\'s starts at index 0, the pair of 3\\'s starts at index 2. Then we hit the unique number.\\nThe 7\\'s start at index 5.\\n\\nNow we have the insight to figure out whether to search high or low for the unique number.\\n\\n```\\nconst bool isPair = midVal == nextVal;\\nif ((mid % 2 == 0) ^ isPair) {\\n\\thigh = mid;\\n} else {\\n\\tlow = mid + 1;\\n}\\n```\\nThe XOR is just a shorthand way of writing `(if mid %2 == 0 && !isPair || mid % 2 != 0 && isPair)`\\n\\nPut everything together and you get a solution like this.\\n```\\nint singleNonDuplicate(int* nums, int numsSize){\\n    int low = 0;\\n    int high = numsSize;\\n    while (low < high) {\\n        const int mid = low + (high - low) / 2;\\n        const int midVal = nums[mid];\\n        if (mid == 0 || mid == numsSize - 1) {\\n          return midVal;\\n        }\\n        \\n        int prevVal = nums[mid - 1];\\n        int nextVal = nums[mid + 1];\\n        if (midVal != prevVal && midVal != nextVal) {\\n            return midVal;\\n        }\\n        \\n        bool isPair = midVal == nextVal;\\n        \\n        if ((mid % 2 == 0) ^ isPair) {\\n            high = mid;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint prevVal = nums[mid - 1];\\nint nextVal = nums[mid + 1];\\nif (midVal != prevVal && midVal != nextVal) {\\n  return midVal;\\n}\\n```\n```\\nif (mid == 0 || mid == numsSize - 1) {\\n  return nums[mid];\\n}\\n```\n```\\nindices: [0, 1, 2, 3, 4, 5, 6, 7, 8]\\nvalues:  [2, 2, 3, 3, 6, 7, 7, 8, 8]\\n```\n```\\nconst bool isPair = midVal == nextVal;\\nif ((mid % 2 == 0) ^ isPair) {\\n\\thigh = mid;\\n} else {\\n\\tlow = mid + 1;\\n}\\n```\n```\\nint singleNonDuplicate(int* nums, int numsSize){\\n    int low = 0;\\n    int high = numsSize;\\n    while (low < high) {\\n        const int mid = low + (high - low) / 2;\\n        const int midVal = nums[mid];\\n        if (mid == 0 || mid == numsSize - 1) {\\n          return midVal;\\n        }\\n        \\n        int prevVal = nums[mid - 1];\\n        int nextVal = nums[mid + 1];\\n        if (midVal != prevVal && midVal != nextVal) {\\n            return midVal;\\n        }\\n        \\n        bool isPair = midVal == nextVal;\\n        \\n        if ((mid % 2 == 0) ^ isPair) {\\n            high = mid;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 544846,
                "title": "java-easy-solution-binary-search-using-length-of-array-0-ms",
                "content": "Simple Assumption\\nDo binary search.\\n1) If mid element is equal to immediate left or right element & length of that part is odd then the answer is in that part or else move on to opposite part.\\n\\n```\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n     \\n        int start = 0, end = nums.length-1;\\n        \\n        while(start <= end) {\\n            \\n            if(start == end)\\n                return nums[start];\\n            \\n            int mid = (start+end)/2;\\n            \\n            if(nums[mid] > nums[mid-1] && nums[mid] < nums[mid+1])\\n                return nums[mid];\\n            \\n            if(nums[mid] == nums[mid-1]) {\\n                if((mid-start)%2 == 0)\\n                    end = mid-2;\\n                else\\n                    start = mid+1;\\n\\n            } else if(nums[mid] == nums[mid+1]) {\\n                if((end-mid)%2 == 0)\\n                    start = mid+2;\\n                else\\n                    end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n     \\n        int start = 0, end = nums.length-1;\\n        \\n        while(start <= end) {\\n            \\n            if(start == end)\\n                return nums[start];\\n            \\n            int mid = (start+end)/2;\\n            \\n            if(nums[mid] > nums[mid-1] && nums[mid] < nums[mid+1])\\n                return nums[mid];\\n            \\n            if(nums[mid] == nums[mid-1]) {\\n                if((mid-start)%2 == 0)\\n                    end = mid-2;\\n                else\\n                    start = mid+1;\\n\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 353150,
                "title": "python-binary-search",
                "content": "```\\n    def singleNonDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        l, r = 0, len(nums) - 1\\n        while(l < r):\\n            m = (l + r) / 2\\n            if m % 2 == 0:\\n                if nums[m] != nums[m + 1]:\\n                    r = m\\n                else:\\n                    l = m + 1\\n            else:\\n                if nums[m] != nums[m - 1]:\\n                    r = m\\n                else:\\n                    l = m + 1\\n                    \\n        return nums[l]\\n```",
                "solutionTags": [],
                "code": "```\\n    def singleNonDuplicate(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        l, r = 0, len(nums) - 1\\n        while(l < r):\\n            m = (l + r) / 2\\n            if m % 2 == 0:\\n                if nums[m] != nums[m + 1]:\\n                    r = m\\n                else:\\n                    l = m + 1\\n            else:\\n                if nums[m] != nums[m - 1]:\\n                    r = m\\n                else:\\n                    l = m + 1\\n                    \\n        return nums[l]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 347850,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "Simply Perform XOR operation you will get the required answer.\\t\\t\\t\\n\\n\\t\\t\\tint xor = 0;\\n\\t\\t\\tfor(int i=0; i<nums.length; i++){\\n\\t\\t\\t\\txor = xor ^ nums[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn xor;",
                "solutionTags": [],
                "code": "Simply Perform XOR operation you will get the required answer.\\t\\t\\t\\n\\n\\t\\t\\tint xor = 0;\\n\\t\\t\\tfor(int i=0; i<nums.length; i++){\\n\\t\\t\\t\\txor = xor ^ nums[i];\\n\\t\\t\\t}\\n\\t\\t\\treturn xor;",
                "codeTag": "Unknown"
            },
            {
                "id": 325838,
                "title": "java-o-n-vs-o-logn-solutions",
                "content": "**BinarySearch**:\\n\\tthe paris are at 2 * k and 2 * k + 1 indexes before the unique element and are at 2 * k + 1 and 2 * k + 2 indexes after the unique element. Binary search is leveraging this different to quickly locate the odd elements in this array.\\n```\\n    public int singleNonDuplicate(int[] nums) {\\n        int left = 0, right = nums.length -1, mid = left + (right - left) / 2;\\n        while(left < right - 1) {\\n            mid = left + (right - left) / 2;\\n            if(mid % 2 == 0  && nums[mid] == nums[mid+1] || mid % 2 != 0 && nums[mid] != nums[mid + 1]) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        if (left % 2 == 0) {\\n            return nums[left];\\n        }\\n        \\n        return nums[right];\\n     }\\n```\\n\\n**XOR**\\n\\n    public int singleNonDuplicate(int[] nums) {\\n        int res = 0;\\n        for(int num : nums) {\\n            res ^= num;\\n        }\\n        \\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n    public int singleNonDuplicate(int[] nums) {\\n        int left = 0, right = nums.length -1, mid = left + (right - left) / 2;\\n        while(left < right - 1) {\\n            mid = left + (right - left) / 2;\\n            if(mid % 2 == 0  && nums[mid] == nums[mid+1] || mid % 2 != 0 && nums[mid] != nums[mid + 1]) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        if (left % 2 == 0) {\\n            return nums[left];\\n        }\\n        \\n        return nums[right];\\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205220,
                "title": "c-beat-92",
                "content": "Main idea is check if nums[m] == nums[m+1] and check if m % 2 == 0 or m % 2 == 1. If m % 2 == 0, that mean the single number should on  the right side of m, else, left side of m.\\n\\nEx: [1,1,2,3,3,4,4,8,8] has 2 as single number, every duplicate value on its left has even then odd index and every duplicate value on its right has odd then even index.\\n```\\npublic class Solution {\\n    public int SingleNonDuplicate(int[] nums) {\\n            if (nums.Length == 1) return nums[0];\\n\\n            int l = 0, r = nums.Length - 1;\\n\\n            while (l <= r)\\n            {\\n                var m = (l + r) / 2;\\n\\n                if ((m == 0 && nums[m] != nums[m + 1]) || (m == nums.Length - 1 && nums[m] != nums[m - 1])) return nums[m];\\n\\n                if (nums[m] == nums[m + 1])\\n                {\\n                    if (m % 2 == 0) l = m + 2;\\n                    else r = m - 1;\\n                }\\n                else\\n                {\\n                    if (nums[m] != nums[m - 1]) return nums[m];\\n\\n                    if (m % 2 == 0) r = m - 2;\\n                    else l = m + 1;\\n                }\\n            }\\n\\n            return nums[l];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int SingleNonDuplicate(int[] nums) {\\n            if (nums.Length == 1) return nums[0];\\n\\n            int l = 0, r = nums.Length - 1;\\n\\n            while (l <= r)\\n            {\\n                var m = (l + r) / 2;\\n\\n                if ((m == 0 && nums[m] != nums[m + 1]) || (m == nums.Length - 1 && nums[m] != nums[m - 1])) return nums[m];\\n\\n                if (nums[m] == nums[m + 1])\\n                {\\n                    if (m % 2 == 0) l = m + 2;\\n                    else r = m - 1;\\n                }\\n                else\\n                {\\n                    if (nums[m] != nums[m - 1]) return nums[m];\\n\\n                    if (m % 2 == 0) r = m - 2;\\n                    else l = m + 1;\\n                }\\n            }\\n\\n            return nums[l];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179531,
                "title": "c-solution-playing-around-with-indices",
                "content": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int first = 0;\\n        for (int last = nums.size(), mid = first + (last - first) / 2;\\n             last - first > 1;\\n             mid = first + (last - first) / 2) \\n        {\\n            if (nums[mid] == nums[mid + 1]) {\\n                // \\'mid\\' index is even, go right\\n                if (0 == mid % 2) first = mid + 2;\\n                // \\'mid\\' index is odd, go left\\n                else last = mid;\\n            } else if (nums[mid - 1] == nums[mid]) {\\n                // \\'mid\\' index is even, go left\\n                if (0 == mid % 2) last = mid - 1;\\n                // \\'mid\\' index is odd, go right\\n                else first = mid + 1;\\n            }\\n            else {\\n                first = mid;\\n                break;\\n            }    \\n        }\\n        return nums[first];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int first = 0;\\n        for (int last = nums.size(), mid = first + (last - first) / 2;\\n             last - first > 1;\\n             mid = first + (last - first) / 2) \\n        {\\n            if (nums[mid] == nums[mid + 1]) {\\n                // \\'mid\\' index is even, go right\\n                if (0 == mid % 2) first = mid + 2;\\n                // \\'mid\\' index is odd, go left\\n                else last = mid;\\n            } else if (nums[mid - 1] == nums[mid]) {\\n                // \\'mid\\' index is even, go left\\n                if (0 == mid % 2) last = mid - 1;\\n                // \\'mid\\' index is odd, go right\\n                else first = mid + 1;\\n            }\\n            else {\\n                first = mid;\\n                break;\\n            }    \\n        }\\n        return nums[first];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 100728,
                "title": "easy-java-solution-with-explanation",
                "content": "This problem must probably belong to EASY category\\nThe idea is that, since the array is a sorted array, every element that appears twice appears consecutively in the array. We take two variables to point to the consecutive indices. when the values pointed by the indices are not same, then the value at the first index is the number that appears only once. if the values are equal we increment both indices by 2.\\nHere's my accepted solution\\n````\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int index=0;\\n        for(int i=0,j=1;i<nums.length && j<nums.length;){\\n            if(nums[i]==nums[j]){\\n                i = i+2;\\n                j = j+2;\\n                index = i;\\n            }\\n            else{\\n                return nums[i];\\n            }\\n        }\\n        return nums[index];\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int index=0;\\n        for(int i=0,j=1;i<nums.length && j<nums.length;){\\n            if(nums[i]==nums[j]){\\n                i = i+2;\\n                j = j+2;\\n                index = i;\\n            }\\n            else{\\n                return nums[i];\\n            }\\n        }\\n        return nums[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012466,
                "title": "single-element-in-a-sorted-array-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        uint32_t low = 0;\\n        uint32_t high = nums.size();\\n        while (low < high) {\\n            const uint32_t mid = low + ((high - low) >> 1);\\n            if (IsNumberOnTheRight(nums, mid)) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }}\\n        return nums[low];\\n    }\\n    bool IsNumberOnTheRight(vector<int>& nums, const uint32_t mid) {\\n        const bool odd = mid % 2 == 1;\\n        \\n        if (mid + 1 >= nums.size() || mid - 1 < 0) {\\n            return false;\\n        }\\n        return odd ? (nums[mid] == nums[mid - 1]) : (nums[mid] == nums[mid + 1]);\\n    }};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        uint32_t low = 0;\\n        uint32_t high = nums.size();\\n        while (low < high) {\\n            const uint32_t mid = low + ((high - low) >> 1);\\n            if (IsNumberOnTheRight(nums, mid)) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }}\\n        return nums[low];\\n    }\\n    bool IsNumberOnTheRight(vector<int>& nums, const uint32_t mid) {\\n        const bool odd = mid % 2 == 1;\\n        \\n        if (mid + 1 >= nums.size() || mid - 1 < 0) {\\n            return false;\\n        }\\n        return odd ? (nums[mid] == nums[mid - 1]) : (nums[mid] == nums[mid + 1]);\\n    }};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750887,
                "title": "simple-solution-using-binary-search-in-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        \"\"\"\\n        ans :- nums[ind]!=nums[ind-1] and nums[ind]!=nums[ind+1]\\n        Duplicate pairs which are in left and right subarray of inr unique element is\\n\\n        (even , odd) => Left Subarray   (if in odd ->chk previous ele , evn ->chk next)\\n        (odd , even) => Right Subarray\\n        \"\"\"\\n        n = len(nums)\\n\\n        low , high = 1 ,  n-2       # to avoid more coniditions of out-of-bound ..!!\\n\\n        if n == 1: return nums[0]\\n        elif nums[0] != nums[1]: return nums[0]\\n        elif nums[n-1] != nums[n-2]: return nums[n-1]\\n\\n        while(low <= high):\\n            mid = (low+high) // 2\\n\\n            if nums[mid]!=nums[mid-1] and nums[mid]!=nums[mid+1]:\\n                return nums[mid]\\n            \\n            \"\"\"Check both [odd ->chk previous ele , evn ->chk next element]\"\"\"\\n            if ( mid%2 == 0 and nums[mid+1] == nums[mid]) or(mid%2 == 1 and nums[mid-1] == nums[mid]): \\n                # we are currently in left_subarray .. \\n                # hence eliminate left subarry and move to right_subarray\\n                low = mid + 1           \\n            else:\\n                high = mid - 1\\n\\n         \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        \"\"\"\\n        ans :- nums[ind]!=nums[ind-1] and nums[ind]!=nums[ind+1]\\n        Duplicate pairs which are in left and right subarray of inr unique element is\\n\\n        (even , odd) => Left Subarray   (if in odd ->chk previous ele , evn ->chk next)\\n        (odd , even) => Right Subarray\\n        \"\"\"\\n        n = len(nums)\\n\\n        low , high = 1 ,  n-2       # to avoid more coniditions of out-of-bound ..!!\\n\\n        if n == 1: return nums[0]\\n        elif nums[0] != nums[1]: return nums[0]\\n        elif nums[n-1] != nums[n-2]: return nums[n-1]\\n\\n        while(low <= high):\\n            mid = (low+high) // 2\\n\\n            if nums[mid]!=nums[mid-1] and nums[mid]!=nums[mid+1]:\\n                return nums[mid]\\n            \\n            \"\"\"Check both [odd ->chk previous ele , evn ->chk next element]\"\"\"\\n            if ( mid%2 == 0 and nums[mid+1] == nums[mid]) or(mid%2 == 1 and nums[mid-1] == nums[mid]): \\n                # we are currently in left_subarray .. \\n                # hence eliminate left subarry and move to right_subarray\\n                low = mid + 1           \\n            else:\\n                high = mid - 1\\n\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745622,
                "title": "easy-c-solution-simple-binary-search-approach-beats-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums){\\n        int start = 0, end = nums.size() - 1;\\n        while(start < end){\\n            int mid = (start + end)/2;\\n            if((mid%2==0 && nums[mid]==nums[mid+1]) || (mid%2==1 && nums[mid]==nums[mid-1]))\\n                start = mid + 1;\\n            else\\n                end = mid;\\n        }\\n        return nums[start];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums){\\n        int start = 0, end = nums.size() - 1;\\n        while(start < end){\\n            int mid = (start + end)/2;\\n            if((mid%2==0 && nums[mid]==nums[mid+1]) || (mid%2==1 && nums[mid]==nums[mid-1]))\\n                start = mid + 1;\\n            else\\n                end = mid;\\n        }\\n        return nums[start];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718573,
                "title": "super-easy-solution",
                "content": "https://takeuforward.org/data-structure/search-single-element-in-a-sorted-array/\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n      int n=nums.size();\\n        if(n==1)return nums[0];\\n        if(nums[0]!=nums[1])return nums[0];\\n        if(nums[n-1]!=nums[n-2])return nums[n-1];\\n        int st=1,end=n-2;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(nums[mid]!=nums[mid-1] && nums[mid]!=nums[mid+1])return nums[mid];\\n\\n            if((mid%2==1 && nums[mid]==nums[mid-1]) || (mid%2==0 && nums[mid]==nums[mid+1]) ){\\n                st=mid+1;\\n            }else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n      int n=nums.size();\\n        if(n==1)return nums[0];\\n        if(nums[0]!=nums[1])return nums[0];\\n        if(nums[n-1]!=nums[n-2])return nums[n-1];\\n        int st=1,end=n-2;\\n        while(st<=end){\\n            int mid=(st+end)/2;\\n            if(nums[mid]!=nums[mid-1] && nums[mid]!=nums[mid+1])return nums[mid];\\n\\n            if((mid%2==1 && nums[mid]==nums[mid-1]) || (mid%2==0 && nums[mid]==nums[mid+1]) ){\\n                st=mid+1;\\n            }else{\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705177,
                "title": "two-approaches-java-solution",
                "content": "**Approach 1 : BINARY SEARCH **\\n# \\n    public int singleNonDuplicate(int[] nums) {\\n        if(nums.length==1)\\n        {\\n            return nums[0];\\n        }\\n        if(nums[0]!=nums[1])\\n        {\\n            return nums[0];\\n        }\\n        if(nums[nums.length-1]!=nums[nums.length-2])\\n        {\\n            return nums[nums.length-1];\\n        }\\n        int low=1,high=nums.length-2;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]!=nums[mid+1] && nums[mid]!=nums[mid-1])\\n            {\\n                return nums[mid];\\n            }\\n    else if((mid%2==1 && nums[mid]==nums[mid-1]) || (mid%2==0 && nums[mid]==nums[mid+1]))\\n            {\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n**Approach 2 : BRUTE FORCE**\\n\\n# \\n    public int singleNonDuplicate(int[] nums) {\\n        for(int i=0;i<nums.length-1;i=i+2)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            {\\n                return nums[i];\\n            }\\n        }\\n        return nums[nums.length-1];\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "**Approach 1 : BINARY SEARCH **\\n# \\n    public int singleNonDuplicate(int[] nums) {\\n        if(nums.length==1)\\n        {\\n            return nums[0];\\n        }\\n        if(nums[0]!=nums[1])\\n        {\\n            return nums[0];\\n        }\\n        if(nums[nums.length-1]!=nums[nums.length-2])\\n        {\\n            return nums[nums.length-1];\\n        }\\n        int low=1,high=nums.length-2;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(nums[mid]!=nums[mid+1] && nums[mid]!=nums[mid-1])\\n            {\\n                return nums[mid];\\n            }\\n    else if((mid%2==1 && nums[mid]==nums[mid-1]) || (mid%2==0 && nums[mid]==nums[mid+1]))\\n            {\\n                low=mid+1;\\n            }else{\\n                high=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n**Approach 2 : BRUTE FORCE**\\n\\n# \\n    public int singleNonDuplicate(int[] nums) {\\n        for(int i=0;i<nums.length-1;i=i+2)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            {\\n                return nums[i];\\n            }\\n        }\\n        return nums[nums.length-1];\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3564989,
                "title": "easy-to-understand-5-approaches-binary-search-c",
                "content": "\\n\\n# Approach\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Array(Two Nested Loop). Brute Force Approach.\\n2. Solved using Array + Hash Table(Unordered map).\\n3. Solved using Linear Search.\\n4. Solved using Bit Manipulation(xor).\\n5. Solved using Binary Search. Optimized Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Brute force \\n// TLE\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            int count = 0;\\n            for(int j=0; j<n; j++){\\n                if(nums[i] == nums[j]) count++;\\n            }\\n            if(count == 1) return nums[i];\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n// Hash Table\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        for(auto num : nums){\\n            map[num]++;\\n        }\\n        for(auto num : map){\\n            if(num.second == 1) return num.first;\\n        }\\n        return -1;\\n    }\\n};\\n// TC O(n)\\n// SC O(1)\\n```\\n\\n```\\n// Linear Search \\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n-1; i+=2){\\n            if(nums[i] != nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return nums[n-1];\\n    }\\n};\\n// TC O(N)\\n// SC O(1)\\n```\\n```\\n// XOR \\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int Xor = 0;\\n        for(auto num : nums){\\n            Xor ^= num;\\n        }\\n        return Xor;\\n    }\\n};\\n\\n// TC O(N)\\n// SC O(1)\\n\\n```\\n\\n```\\n//Binary search \\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (mid % 2 == 1) {\\n                mid--;\\n            }\\n            if (nums[mid] != nums[mid + 1]) {\\n                right = mid;\\n            } else {\\n                left = mid + 2;\\n            }\\n        }\\n        return nums[left];\\n    }\\n};\\n// TC O(Nlogn)\\n// SC O(1)\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\n//Brute force \\n// TLE\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; i++){\\n            int count = 0;\\n            for(int j=0; j<n; j++){\\n                if(nums[i] == nums[j]) count++;\\n            }\\n            if(count == 1) return nums[i];\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n// Hash Table\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        for(auto num : nums){\\n            map[num]++;\\n        }\\n        for(auto num : map){\\n            if(num.second == 1) return num.first;\\n        }\\n        return -1;\\n    }\\n};\\n// TC O(n)\\n// SC O(1)\\n```\n```\\n// Linear Search \\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n-1; i+=2){\\n            if(nums[i] != nums[i+1]){\\n                return nums[i];\\n            }\\n        }\\n        return nums[n-1];\\n    }\\n};\\n// TC O(N)\\n// SC O(1)\\n```\n```\\n// XOR \\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int Xor = 0;\\n        for(auto num : nums){\\n            Xor ^= num;\\n        }\\n        return Xor;\\n    }\\n};\\n\\n// TC O(N)\\n// SC O(1)\\n\\n```\n```\\n//Binary search \\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (mid % 2 == 1) {\\n                mid--;\\n            }\\n            if (nums[mid] != nums[mid + 1]) {\\n                right = mid;\\n            } else {\\n                left = mid + 2;\\n            }\\n        }\\n        return nums[left];\\n    }\\n};\\n// TC O(Nlogn)\\n// SC O(1)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564803,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1809105,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1808848,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1774109,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1808835,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1809242,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1809267,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1808801,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1809036,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1571912,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1564803,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1809105,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1808848,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1774109,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1808835,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1809242,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1809267,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1808801,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1809036,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1571912,
                "content": [
                    {
                        "username": "banty",
                        "content": "The pairs which are on the left of the single element, will have the first element in an even position and the second element at an odd position. All the pairs which are on the right side of the single element will have the first position at an odd position and the second element at an even position. Use this fact to decide whether to go to the left side of the array or the right side."
                    },
                    {
                        "username": "pijushmondal617",
                        "content": "amazing. how did u get this intution.?"
                    },
                    {
                        "username": "SinghalRishabh",
                        "content": "[@user0291CQ](/user0291CQ) I also have solve my first medium question with this hint only. thanks man"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "[@fuzzyara](/fuzzyara) Why it\\'s wrong can you explain?"
                    },
                    {
                        "username": "fuzzyara",
                        "content": "This is wrong!!!"
                    },
                    {
                        "username": "user0291CQ",
                        "content": "Thank you for this hint! And thank you for not just giving the answer. This is the first medium I\\'ve solved!"
                    },
                    {
                        "username": "Chandra_kanth_sagar",
                        "content": "Extradinory"
                    },
                    {
                        "username": "chost0",
                        "content": "Geniusly!"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "thanks a lot i was struggling to find out "
                    },
                    {
                        "username": "Teng0318",
                        "content": "WOW! Sounds a great idea!"
                    },
                    {
                        "username": "djslim",
                        "content": "Great hint"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "\"Your solution must run in O(log n) time\"\nis a dead giveaway that we are supposed to mimic binary search. I feel like they should have instead designed test cases to give TLE if we provide solution in anything other than O(log n) time. Doing this , we could actually think and come to the solution from bottom up , rather than having a solution at hand and then deciding how to apply it on this problem.\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[@A-V-Jagannathan](/A-V-Jagannathan) For this problem, there were only 15 test cases.."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@hung_nguyen](/hung_nguyen) idk it could be anything from bad test case design to nearby elements being cached and thus retrieved faster"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@DPcodes123](/DPcodes123) Exactly! "
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Electron1997](/Electron1997) That makes sense"
                    },
                    {
                        "username": "Electron1997",
                        "content": "I think their judging system measures the execution time of the entire program. Creating the array nums is already O(n), so some fast O(n) solutions will inevitably run within the time limit. To do what you say they would have to change the interface of the problem. Instead of the array nums itself they would have to only provide an O(1) access method for the nums array that works without actually creating the entire array, that way they could even change the constraint on the size of the array to 1e9 and make sure only logarithmic solutions pass"
                    },
                    {
                        "username": "hung_nguyen",
                        "content": "do you know why this O(n/2) solution faster than binary search? I get it from example AC submissions, \\n\\nfunc singleNonDuplicate(nums []int) int {\\n    i:=0\\n   for i<len(nums)-1 {\\n      if nums[i] == nums[i+1]{\\n          i = i+2\\n      }else{\\n          return nums[i]\\n      }\\n   } \\n   return nums[i];\\n}"
                    },
                    {
                        "username": "DPcodes123",
                        "content": "True, and also the fact that we are told the array is sorted, I jumped to binary search instantly. The array could just as easily be unsorted, as long as the pair elements are together. That probably would have taken me longer to figure out."
                    },
                    {
                        "username": "Movsar",
                        "content": "This question is very similar to Binary Search algorithm. If you look at the example below you will see that: \n- If the number at index `m` is the same as the number at index `m-1`, the unique number cannot be on the right side of the middle, as there are an even number of numbers (`(r-m) % 2 = 0`) on that side (first example below). **However, if we had an odd number of numbers**, the unique number would have to be on the right side. \n- If the number at index `m` is the same as the number at index `m+1`, the unique number must be on the right side of the middle, since there are an even number of numbers (`(r-m) % 2 = 0`) on that side (second example below). **However, if we had an odd number of numbers**, the unique number would have to be on the left side from the middle. \n- If the number at index `m` is different from the numbers at indexes `m+1` and `m-1`, it is the *unique number*.\n\nWe can use these checks to decide where to move `l` and `r` pointers. If you have any other ideas, please comment. Thank you!\n\n![screenshot](https://i.ibb.co/qgncfcY/2023-02-21-11-14-35.jpg)"
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "[@jems1123](/jems1123)  I think you have to check if the remaining numbers you have are an odd number or even, if m == m-1 and you have an odd number of diggits on the right side, then you check the right side. if the remaining digits are an even number then it cannot be on the right side."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@amansingh4958](/amansingh4958) Beautiful! Thank you my friend! Thats what I meant. \n\nIt wont present if number at index `m` and `m - 1` are the same AND there are even count (4 for this example) of numbers on the right side from `m`\nIt will present if number at index `m` and `m - 1` are the same AND there are odd count of numbers on the right side from `m`"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "[@jems1123](/jems1123) the guy is not saying that if the number at mid and number at it\\'s left are same then the unique number will not be present at it\\'s right side.\\n\\nHe is implying that if the size of array to the right of mid is even then unique number will not be present at right because even size denote that every number appeared twice. \\n\\n[[@Movsar Makhmutov](/Movsar) Thanks for such a brilliant idea. It\\'s very easy to understand."
                    },
                    {
                        "username": "Movsar",
                        "content": "[@jems1123](/jems1123) the same number as mid is on the left side and there are 3 numbers on the right. If we have odd count of numbers, unique number must be on the right\n\nDescription: … every element appears exactly twice, except for one element which appears exactly once"
                    },
                    {
                        "username": "jems1123",
                        "content": "[3,3,7,7,10,11,11] what will you say about this case here m will be at 3 and unique number is on right size??"
                    },
                    {
                        "username": "LEGENDZQH",
                        "content": "The input array is not required to be sorted, just need to satisfy that all identical values are adjacent."
                    },
                    {
                        "username": "Finesse",
                        "content": "This constraint is added intentionally to confuse the players"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "True indeed.  The binary search works on the basis of Indexing not the elements. however I think the driver code must have sorted it internally to frame it in a usable way."
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@cswartzell](/cswartzell) It is not required for O(log n) time. As long as every pair of elements are directly adjacent to each other and unique, then the value of the pairs is irrelevant, since it is the index of each pair that matters (as [@Qionghui Zhang](/LEGENDZQH) implied)."
                    },
                    {
                        "username": "cswartzell",
                        "content": "It is if you want it to run in O(log n) time... like it says it must. Unless you have an algo that somehow checks a randomized array for a conditional without checking every element. Id very much like to see that algo if so. \n\nOh, I see. Nope, they are right. It ONLY requires pairs, the order of the pairs IS irrelevant. The value of the pairs is of course relevant, but only in for checking parity to know if the singlet is left or right of the current pair (or, perhaps youve found it)"
                    },
                    {
                        "username": "palharshit239",
                        "content": "[@PrisonM1ke](/PrisonM1ke)  you can appy binary search on the basis of index we are note interested in the value of the elements cuz we wre not searching any key within the array"
                    },
                    {
                        "username": "atharvdarunkar111",
                        "content": "**After a very long time have seen yellow tag on question ; )**"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/example2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case1.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case2.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case3.png)\\n![](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/416649/Figures/540/case4.png)"
                    },
                    {
                        "username": "hridoy100",
                        "content": "Closely look at the pattern of the input.\\n`nums = [1,1,2,3,3,4,4,8,8]`\\nFrom the start first 1 is in index 0.\\nSecond 1 is in index 1.\\nBut after the single element 2,\\nfirst 3 is in index 3.\\nsecond 3 is in index 4.\\nSo, as you got a hint that before single element, if our current index is even and the immediate next element is equal \\nor, if our current index is odd and immediate previous element is equal,\\nthen we are still on the left side. So, update left.\\nIf all these conditions don\\'t satisfy, we have passed our target element. So, update right."
                    },
                    {
                        "username": "SNEHAJIT_DEY27",
                        "content": "[@hridoy100](/hridoy100) great observation bro,wish id seen it too"
                    },
                    {
                        "username": "hridoy100",
                        "content": "[@ahmz](/ahmz) Glad the hint was helpful!"
                    },
                    {
                        "username": "ahmz",
                        "content": "Now I understand!"
                    },
                    {
                        "username": "leetcodingm",
                        "content": "finally a medium problem!! \nplease leetcode do a mix of easy, medium and hards, we want to actually practice properly"
                    },
                    {
                        "username": "user1715ZB",
                        "content": "Careful what you wish for. I think we are due for an end of February surprise!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "You can of course do hard problems that are not the daily challenge. "
                    },
                    {
                        "username": "WTIFS",
                        "content": "This problem is a dupliate of [136. Single Number]"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It\\'s not. That array is not sorted and the time constraint here is much stricter. My codes for both answers don\\'t work of the other one"
                    },
                    {
                        "username": "beardedone",
                        "content": "Almost.  The difference is that for this problem, the input array is sorted, so you could perform a binary search to achieve an O(log n) time complexity, which is \"required\" by this problem (for some reason).  \\n\\nGiven that the constraints make the array length relatively small, it probably not be worth the effort in practice, and  the O(n) solution that works with 136 would perform adequately for this problem."
                    },
                    {
                        "username": "EnegueIAm",
                        "content": "I wrote a linear solution that beats 100% of the other answers. It\\'s just a simple fast/slow pointer that increments by two through the array, and as soon as they\\'re not equivilent to eachother, we return the slower pointer.\\n\\nWe do not have info of which distinct number we\\'re looking for therefore we don\\'t know the exact location. Using binary search is therefore useless -- what\\'s the point?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Problem asks you to write solution in O(log n). Maybe at the time of your answer, that was not required"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Just Imagine a test cases of size 10^5 elements and the last element of array is the answer element. Then your Linear solution will traverse all the elements of array which is technically O(n). Don\\'t know how it is giving you faster than 100%, or is it the memory constraint you are talking about."
                    },
                    {
                        "username": "cswartzell",
                        "content": "The point is youve written an O(n) algorithm, while being asked to write an O(log n) algorithm. Technically you havent solved the problem as asked. That being said... yes, obviously this is a better faster way for any sensible input. Thats not the point of a challenge though. I\\'m not sure what kind of input would be necessary to make O(n) solutions fail when the test is this quick and easy, but really the constraints should have some MASSIVE lists to fail out linear checks. "
                    },
                    {
                        "username": "kurtischarnock",
                        "content": "We don\\'t need to know the distinct number, we know that the alignment of the pairs changes after the number appears."
                    }
                ]
            },
            {
                "id": 1821191,
                "content": [
                    {
                        "username": "neeshumaini55",
                        "content": "The problem is for checking valid even odd pair.\\n1. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is odd and it has completed even odd pairs i.e. mid and mid-1 elements are same so we should search in right of mid \\n2. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is even and it has completed even odd pairs i.e. mid and mid+1 elements are same so we should search in right of mid \\n3. CONDITION OF VALID ODD EVEN PAIR\\nif position of mid is odd and it has not completed even odd pairs i.e. mid and mid-1 elements are different or mid and mid+1 elements are same, so we should search in left of mid \\n4. CONDITION OF VALID ODD EVEN PAIR\\n if position of mid is even and it has not completed even odd pairs i.e. mid and mid+1 elements are different or mid and mid-1 elements are same, so we should search in left of mid \\n5. CONDITION OF VALID NUMBER\\nif mid and mid+1 elements are different and mid and mid-1 elements are different, then mid element would be our answer. \\n"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I think bit manipulation is one of the better approach;\\n"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "add more test cases\\ni literally hard coded so that i could pass all 15 test cases and i did that ...lol"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "An O(N/2) solution beats 80% of the solutions. What\\'s even the point of putting that O(logN) time constraint?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "If the requirement is \"do this in O(log n)\", basically instructs what main algorithm you need to use to check through your array as a big fat hint. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Yeah XD. I did a dry run of my logic using binary search and the answer panned itself out"
                    },
                    {
                        "username": "scor32k",
                        "content": "using xor made easy"
                    },
                    {
                        "username": "viku_kr",
                        "content": "I solved by XOR and it passed. I was wondering why my solution is slightly slow, then I saw its supposed to be Log(n), still it not that fast compared other people\\'s submission."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a O(log n) problem"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "Your solution must run in O(log n) time, xor will run in O(n)"
                    },
                    {
                        "username": "yosemite",
                        "content": "The time complexity is mentioned as O(log n). To meet this, an additional constraint needs to be added in the question: \"All repeated numbers appear in pairs in the input.\" The examples in the question seem to illustrate this, but the condition is not mentioned in the question itself. \\n\\nPS: I received this question in a real interview too, and that is how I am aware."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sorted implies this is true"
                    },
                    {
                        "username": "skipper__7",
                        "content": "It is mentioned in the question that the array is sorted so they appear together."
                    },
                    {
                        "username": "CHOPPER14",
                        "content": "\"\"\"\\nreturn ((2*sum(set(nums)))-sum(nums))\\n\"\"\""
                    },
                    {
                        "username": "cswartzell",
                        "content": "While a pretty clever hack, this is an O(n) solution, so shouldnt actually count. That being said, I personally think this is my favorite solution so far. "
                    },
                    {
                        "username": "Akriti1701",
                        "content": "Using binary search, is there any other method of determining on which side the single element lies, instead of identifying odd and even numbers?"
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "1. If n == 1: This means the array size is 1. If the array contains only one element, we will return that element only.\\n2. If arr[0] != arr[1]: This means the very first element of the array is the single element. So, we will return arr[0].\\n3. If arr[n-1] != arr[n-2]: This means the last element of the array is the single element. So, we will return arr[n-1].\\n4. Place the 2 pointers i.e. low and high: Initially, we will place the pointers excluding index 0 and n-1 like this: low will point to index 1, and high will point to index n-2 i.e. the second last index.\\n5. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n6. Check if arr[mid] is the single element:\\nIf arr[mid] != arr[mid-1] and arr[mid] != arr[mid+1]: If this condition is true for arr[mid], we can conclude arr[mid] is the single element. We will return arr[mid].\\n7. If (mid % 2 == 0 and arr[mid] == arr[mid+1])\\nor (mid%2 == 1 and arr[mid] == arr[mid-1]): This means we are in the left half and we should eliminate it as our single element appears on the right. So, we will do this:\\nlow = mid+1.\\n8. Otherwise, we are in the right half and we should eliminate it as our single element appears on the left. So, we will do this: high = mid-1."
                    }
                ]
            },
            {
                "id": 1809772,
                "content": [
                    {
                        "username": "neeshumaini55",
                        "content": "The problem is for checking valid even odd pair.\\n1. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is odd and it has completed even odd pairs i.e. mid and mid-1 elements are same so we should search in right of mid \\n2. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is even and it has completed even odd pairs i.e. mid and mid+1 elements are same so we should search in right of mid \\n3. CONDITION OF VALID ODD EVEN PAIR\\nif position of mid is odd and it has not completed even odd pairs i.e. mid and mid-1 elements are different or mid and mid+1 elements are same, so we should search in left of mid \\n4. CONDITION OF VALID ODD EVEN PAIR\\n if position of mid is even and it has not completed even odd pairs i.e. mid and mid+1 elements are different or mid and mid-1 elements are same, so we should search in left of mid \\n5. CONDITION OF VALID NUMBER\\nif mid and mid+1 elements are different and mid and mid-1 elements are different, then mid element would be our answer. \\n"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I think bit manipulation is one of the better approach;\\n"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "add more test cases\\ni literally hard coded so that i could pass all 15 test cases and i did that ...lol"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "An O(N/2) solution beats 80% of the solutions. What\\'s even the point of putting that O(logN) time constraint?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "If the requirement is \"do this in O(log n)\", basically instructs what main algorithm you need to use to check through your array as a big fat hint. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Yeah XD. I did a dry run of my logic using binary search and the answer panned itself out"
                    },
                    {
                        "username": "scor32k",
                        "content": "using xor made easy"
                    },
                    {
                        "username": "viku_kr",
                        "content": "I solved by XOR and it passed. I was wondering why my solution is slightly slow, then I saw its supposed to be Log(n), still it not that fast compared other people\\'s submission."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a O(log n) problem"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "Your solution must run in O(log n) time, xor will run in O(n)"
                    },
                    {
                        "username": "yosemite",
                        "content": "The time complexity is mentioned as O(log n). To meet this, an additional constraint needs to be added in the question: \"All repeated numbers appear in pairs in the input.\" The examples in the question seem to illustrate this, but the condition is not mentioned in the question itself. \\n\\nPS: I received this question in a real interview too, and that is how I am aware."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sorted implies this is true"
                    },
                    {
                        "username": "skipper__7",
                        "content": "It is mentioned in the question that the array is sorted so they appear together."
                    },
                    {
                        "username": "CHOPPER14",
                        "content": "\"\"\"\\nreturn ((2*sum(set(nums)))-sum(nums))\\n\"\"\""
                    },
                    {
                        "username": "cswartzell",
                        "content": "While a pretty clever hack, this is an O(n) solution, so shouldnt actually count. That being said, I personally think this is my favorite solution so far. "
                    },
                    {
                        "username": "Akriti1701",
                        "content": "Using binary search, is there any other method of determining on which side the single element lies, instead of identifying odd and even numbers?"
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "1. If n == 1: This means the array size is 1. If the array contains only one element, we will return that element only.\\n2. If arr[0] != arr[1]: This means the very first element of the array is the single element. So, we will return arr[0].\\n3. If arr[n-1] != arr[n-2]: This means the last element of the array is the single element. So, we will return arr[n-1].\\n4. Place the 2 pointers i.e. low and high: Initially, we will place the pointers excluding index 0 and n-1 like this: low will point to index 1, and high will point to index n-2 i.e. the second last index.\\n5. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n6. Check if arr[mid] is the single element:\\nIf arr[mid] != arr[mid-1] and arr[mid] != arr[mid+1]: If this condition is true for arr[mid], we can conclude arr[mid] is the single element. We will return arr[mid].\\n7. If (mid % 2 == 0 and arr[mid] == arr[mid+1])\\nor (mid%2 == 1 and arr[mid] == arr[mid-1]): This means we are in the left half and we should eliminate it as our single element appears on the right. So, we will do this:\\nlow = mid+1.\\n8. Otherwise, we are in the right half and we should eliminate it as our single element appears on the left. So, we will do this: high = mid-1."
                    }
                ]
            },
            {
                "id": 1809568,
                "content": [
                    {
                        "username": "neeshumaini55",
                        "content": "The problem is for checking valid even odd pair.\\n1. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is odd and it has completed even odd pairs i.e. mid and mid-1 elements are same so we should search in right of mid \\n2. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is even and it has completed even odd pairs i.e. mid and mid+1 elements are same so we should search in right of mid \\n3. CONDITION OF VALID ODD EVEN PAIR\\nif position of mid is odd and it has not completed even odd pairs i.e. mid and mid-1 elements are different or mid and mid+1 elements are same, so we should search in left of mid \\n4. CONDITION OF VALID ODD EVEN PAIR\\n if position of mid is even and it has not completed even odd pairs i.e. mid and mid+1 elements are different or mid and mid-1 elements are same, so we should search in left of mid \\n5. CONDITION OF VALID NUMBER\\nif mid and mid+1 elements are different and mid and mid-1 elements are different, then mid element would be our answer. \\n"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I think bit manipulation is one of the better approach;\\n"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "add more test cases\\ni literally hard coded so that i could pass all 15 test cases and i did that ...lol"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "An O(N/2) solution beats 80% of the solutions. What\\'s even the point of putting that O(logN) time constraint?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "If the requirement is \"do this in O(log n)\", basically instructs what main algorithm you need to use to check through your array as a big fat hint. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Yeah XD. I did a dry run of my logic using binary search and the answer panned itself out"
                    },
                    {
                        "username": "scor32k",
                        "content": "using xor made easy"
                    },
                    {
                        "username": "viku_kr",
                        "content": "I solved by XOR and it passed. I was wondering why my solution is slightly slow, then I saw its supposed to be Log(n), still it not that fast compared other people\\'s submission."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a O(log n) problem"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "Your solution must run in O(log n) time, xor will run in O(n)"
                    },
                    {
                        "username": "yosemite",
                        "content": "The time complexity is mentioned as O(log n). To meet this, an additional constraint needs to be added in the question: \"All repeated numbers appear in pairs in the input.\" The examples in the question seem to illustrate this, but the condition is not mentioned in the question itself. \\n\\nPS: I received this question in a real interview too, and that is how I am aware."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sorted implies this is true"
                    },
                    {
                        "username": "skipper__7",
                        "content": "It is mentioned in the question that the array is sorted so they appear together."
                    },
                    {
                        "username": "CHOPPER14",
                        "content": "\"\"\"\\nreturn ((2*sum(set(nums)))-sum(nums))\\n\"\"\""
                    },
                    {
                        "username": "cswartzell",
                        "content": "While a pretty clever hack, this is an O(n) solution, so shouldnt actually count. That being said, I personally think this is my favorite solution so far. "
                    },
                    {
                        "username": "Akriti1701",
                        "content": "Using binary search, is there any other method of determining on which side the single element lies, instead of identifying odd and even numbers?"
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "1. If n == 1: This means the array size is 1. If the array contains only one element, we will return that element only.\\n2. If arr[0] != arr[1]: This means the very first element of the array is the single element. So, we will return arr[0].\\n3. If arr[n-1] != arr[n-2]: This means the last element of the array is the single element. So, we will return arr[n-1].\\n4. Place the 2 pointers i.e. low and high: Initially, we will place the pointers excluding index 0 and n-1 like this: low will point to index 1, and high will point to index n-2 i.e. the second last index.\\n5. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n6. Check if arr[mid] is the single element:\\nIf arr[mid] != arr[mid-1] and arr[mid] != arr[mid+1]: If this condition is true for arr[mid], we can conclude arr[mid] is the single element. We will return arr[mid].\\n7. If (mid % 2 == 0 and arr[mid] == arr[mid+1])\\nor (mid%2 == 1 and arr[mid] == arr[mid-1]): This means we are in the left half and we should eliminate it as our single element appears on the right. So, we will do this:\\nlow = mid+1.\\n8. Otherwise, we are in the right half and we should eliminate it as our single element appears on the left. So, we will do this: high = mid-1."
                    }
                ]
            },
            {
                "id": 1809096,
                "content": [
                    {
                        "username": "neeshumaini55",
                        "content": "The problem is for checking valid even odd pair.\\n1. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is odd and it has completed even odd pairs i.e. mid and mid-1 elements are same so we should search in right of mid \\n2. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is even and it has completed even odd pairs i.e. mid and mid+1 elements are same so we should search in right of mid \\n3. CONDITION OF VALID ODD EVEN PAIR\\nif position of mid is odd and it has not completed even odd pairs i.e. mid and mid-1 elements are different or mid and mid+1 elements are same, so we should search in left of mid \\n4. CONDITION OF VALID ODD EVEN PAIR\\n if position of mid is even and it has not completed even odd pairs i.e. mid and mid+1 elements are different or mid and mid-1 elements are same, so we should search in left of mid \\n5. CONDITION OF VALID NUMBER\\nif mid and mid+1 elements are different and mid and mid-1 elements are different, then mid element would be our answer. \\n"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I think bit manipulation is one of the better approach;\\n"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "add more test cases\\ni literally hard coded so that i could pass all 15 test cases and i did that ...lol"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "An O(N/2) solution beats 80% of the solutions. What\\'s even the point of putting that O(logN) time constraint?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "If the requirement is \"do this in O(log n)\", basically instructs what main algorithm you need to use to check through your array as a big fat hint. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Yeah XD. I did a dry run of my logic using binary search and the answer panned itself out"
                    },
                    {
                        "username": "scor32k",
                        "content": "using xor made easy"
                    },
                    {
                        "username": "viku_kr",
                        "content": "I solved by XOR and it passed. I was wondering why my solution is slightly slow, then I saw its supposed to be Log(n), still it not that fast compared other people\\'s submission."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a O(log n) problem"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "Your solution must run in O(log n) time, xor will run in O(n)"
                    },
                    {
                        "username": "yosemite",
                        "content": "The time complexity is mentioned as O(log n). To meet this, an additional constraint needs to be added in the question: \"All repeated numbers appear in pairs in the input.\" The examples in the question seem to illustrate this, but the condition is not mentioned in the question itself. \\n\\nPS: I received this question in a real interview too, and that is how I am aware."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sorted implies this is true"
                    },
                    {
                        "username": "skipper__7",
                        "content": "It is mentioned in the question that the array is sorted so they appear together."
                    },
                    {
                        "username": "CHOPPER14",
                        "content": "\"\"\"\\nreturn ((2*sum(set(nums)))-sum(nums))\\n\"\"\""
                    },
                    {
                        "username": "cswartzell",
                        "content": "While a pretty clever hack, this is an O(n) solution, so shouldnt actually count. That being said, I personally think this is my favorite solution so far. "
                    },
                    {
                        "username": "Akriti1701",
                        "content": "Using binary search, is there any other method of determining on which side the single element lies, instead of identifying odd and even numbers?"
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "1. If n == 1: This means the array size is 1. If the array contains only one element, we will return that element only.\\n2. If arr[0] != arr[1]: This means the very first element of the array is the single element. So, we will return arr[0].\\n3. If arr[n-1] != arr[n-2]: This means the last element of the array is the single element. So, we will return arr[n-1].\\n4. Place the 2 pointers i.e. low and high: Initially, we will place the pointers excluding index 0 and n-1 like this: low will point to index 1, and high will point to index n-2 i.e. the second last index.\\n5. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n6. Check if arr[mid] is the single element:\\nIf arr[mid] != arr[mid-1] and arr[mid] != arr[mid+1]: If this condition is true for arr[mid], we can conclude arr[mid] is the single element. We will return arr[mid].\\n7. If (mid % 2 == 0 and arr[mid] == arr[mid+1])\\nor (mid%2 == 1 and arr[mid] == arr[mid-1]): This means we are in the left half and we should eliminate it as our single element appears on the right. So, we will do this:\\nlow = mid+1.\\n8. Otherwise, we are in the right half and we should eliminate it as our single element appears on the left. So, we will do this: high = mid-1."
                    }
                ]
            },
            {
                "id": 1808907,
                "content": [
                    {
                        "username": "neeshumaini55",
                        "content": "The problem is for checking valid even odd pair.\\n1. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is odd and it has completed even odd pairs i.e. mid and mid-1 elements are same so we should search in right of mid \\n2. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is even and it has completed even odd pairs i.e. mid and mid+1 elements are same so we should search in right of mid \\n3. CONDITION OF VALID ODD EVEN PAIR\\nif position of mid is odd and it has not completed even odd pairs i.e. mid and mid-1 elements are different or mid and mid+1 elements are same, so we should search in left of mid \\n4. CONDITION OF VALID ODD EVEN PAIR\\n if position of mid is even and it has not completed even odd pairs i.e. mid and mid+1 elements are different or mid and mid-1 elements are same, so we should search in left of mid \\n5. CONDITION OF VALID NUMBER\\nif mid and mid+1 elements are different and mid and mid-1 elements are different, then mid element would be our answer. \\n"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I think bit manipulation is one of the better approach;\\n"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "add more test cases\\ni literally hard coded so that i could pass all 15 test cases and i did that ...lol"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "An O(N/2) solution beats 80% of the solutions. What\\'s even the point of putting that O(logN) time constraint?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "If the requirement is \"do this in O(log n)\", basically instructs what main algorithm you need to use to check through your array as a big fat hint. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Yeah XD. I did a dry run of my logic using binary search and the answer panned itself out"
                    },
                    {
                        "username": "scor32k",
                        "content": "using xor made easy"
                    },
                    {
                        "username": "viku_kr",
                        "content": "I solved by XOR and it passed. I was wondering why my solution is slightly slow, then I saw its supposed to be Log(n), still it not that fast compared other people\\'s submission."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a O(log n) problem"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "Your solution must run in O(log n) time, xor will run in O(n)"
                    },
                    {
                        "username": "yosemite",
                        "content": "The time complexity is mentioned as O(log n). To meet this, an additional constraint needs to be added in the question: \"All repeated numbers appear in pairs in the input.\" The examples in the question seem to illustrate this, but the condition is not mentioned in the question itself. \\n\\nPS: I received this question in a real interview too, and that is how I am aware."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sorted implies this is true"
                    },
                    {
                        "username": "skipper__7",
                        "content": "It is mentioned in the question that the array is sorted so they appear together."
                    },
                    {
                        "username": "CHOPPER14",
                        "content": "\"\"\"\\nreturn ((2*sum(set(nums)))-sum(nums))\\n\"\"\""
                    },
                    {
                        "username": "cswartzell",
                        "content": "While a pretty clever hack, this is an O(n) solution, so shouldnt actually count. That being said, I personally think this is my favorite solution so far. "
                    },
                    {
                        "username": "Akriti1701",
                        "content": "Using binary search, is there any other method of determining on which side the single element lies, instead of identifying odd and even numbers?"
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "1. If n == 1: This means the array size is 1. If the array contains only one element, we will return that element only.\\n2. If arr[0] != arr[1]: This means the very first element of the array is the single element. So, we will return arr[0].\\n3. If arr[n-1] != arr[n-2]: This means the last element of the array is the single element. So, we will return arr[n-1].\\n4. Place the 2 pointers i.e. low and high: Initially, we will place the pointers excluding index 0 and n-1 like this: low will point to index 1, and high will point to index n-2 i.e. the second last index.\\n5. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n6. Check if arr[mid] is the single element:\\nIf arr[mid] != arr[mid-1] and arr[mid] != arr[mid+1]: If this condition is true for arr[mid], we can conclude arr[mid] is the single element. We will return arr[mid].\\n7. If (mid % 2 == 0 and arr[mid] == arr[mid+1])\\nor (mid%2 == 1 and arr[mid] == arr[mid-1]): This means we are in the left half and we should eliminate it as our single element appears on the right. So, we will do this:\\nlow = mid+1.\\n8. Otherwise, we are in the right half and we should eliminate it as our single element appears on the left. So, we will do this: high = mid-1."
                    }
                ]
            },
            {
                "id": 1808795,
                "content": [
                    {
                        "username": "neeshumaini55",
                        "content": "The problem is for checking valid even odd pair.\\n1. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is odd and it has completed even odd pairs i.e. mid and mid-1 elements are same so we should search in right of mid \\n2. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is even and it has completed even odd pairs i.e. mid and mid+1 elements are same so we should search in right of mid \\n3. CONDITION OF VALID ODD EVEN PAIR\\nif position of mid is odd and it has not completed even odd pairs i.e. mid and mid-1 elements are different or mid and mid+1 elements are same, so we should search in left of mid \\n4. CONDITION OF VALID ODD EVEN PAIR\\n if position of mid is even and it has not completed even odd pairs i.e. mid and mid+1 elements are different or mid and mid-1 elements are same, so we should search in left of mid \\n5. CONDITION OF VALID NUMBER\\nif mid and mid+1 elements are different and mid and mid-1 elements are different, then mid element would be our answer. \\n"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I think bit manipulation is one of the better approach;\\n"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "add more test cases\\ni literally hard coded so that i could pass all 15 test cases and i did that ...lol"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "An O(N/2) solution beats 80% of the solutions. What\\'s even the point of putting that O(logN) time constraint?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "If the requirement is \"do this in O(log n)\", basically instructs what main algorithm you need to use to check through your array as a big fat hint. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Yeah XD. I did a dry run of my logic using binary search and the answer panned itself out"
                    },
                    {
                        "username": "scor32k",
                        "content": "using xor made easy"
                    },
                    {
                        "username": "viku_kr",
                        "content": "I solved by XOR and it passed. I was wondering why my solution is slightly slow, then I saw its supposed to be Log(n), still it not that fast compared other people\\'s submission."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a O(log n) problem"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "Your solution must run in O(log n) time, xor will run in O(n)"
                    },
                    {
                        "username": "yosemite",
                        "content": "The time complexity is mentioned as O(log n). To meet this, an additional constraint needs to be added in the question: \"All repeated numbers appear in pairs in the input.\" The examples in the question seem to illustrate this, but the condition is not mentioned in the question itself. \\n\\nPS: I received this question in a real interview too, and that is how I am aware."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sorted implies this is true"
                    },
                    {
                        "username": "skipper__7",
                        "content": "It is mentioned in the question that the array is sorted so they appear together."
                    },
                    {
                        "username": "CHOPPER14",
                        "content": "\"\"\"\\nreturn ((2*sum(set(nums)))-sum(nums))\\n\"\"\""
                    },
                    {
                        "username": "cswartzell",
                        "content": "While a pretty clever hack, this is an O(n) solution, so shouldnt actually count. That being said, I personally think this is my favorite solution so far. "
                    },
                    {
                        "username": "Akriti1701",
                        "content": "Using binary search, is there any other method of determining on which side the single element lies, instead of identifying odd and even numbers?"
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "1. If n == 1: This means the array size is 1. If the array contains only one element, we will return that element only.\\n2. If arr[0] != arr[1]: This means the very first element of the array is the single element. So, we will return arr[0].\\n3. If arr[n-1] != arr[n-2]: This means the last element of the array is the single element. So, we will return arr[n-1].\\n4. Place the 2 pointers i.e. low and high: Initially, we will place the pointers excluding index 0 and n-1 like this: low will point to index 1, and high will point to index n-2 i.e. the second last index.\\n5. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n6. Check if arr[mid] is the single element:\\nIf arr[mid] != arr[mid-1] and arr[mid] != arr[mid+1]: If this condition is true for arr[mid], we can conclude arr[mid] is the single element. We will return arr[mid].\\n7. If (mid % 2 == 0 and arr[mid] == arr[mid+1])\\nor (mid%2 == 1 and arr[mid] == arr[mid-1]): This means we are in the left half and we should eliminate it as our single element appears on the right. So, we will do this:\\nlow = mid+1.\\n8. Otherwise, we are in the right half and we should eliminate it as our single element appears on the left. So, we will do this: high = mid-1."
                    }
                ]
            },
            {
                "id": 1571767,
                "content": [
                    {
                        "username": "neeshumaini55",
                        "content": "The problem is for checking valid even odd pair.\\n1. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is odd and it has completed even odd pairs i.e. mid and mid-1 elements are same so we should search in right of mid \\n2. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is even and it has completed even odd pairs i.e. mid and mid+1 elements are same so we should search in right of mid \\n3. CONDITION OF VALID ODD EVEN PAIR\\nif position of mid is odd and it has not completed even odd pairs i.e. mid and mid-1 elements are different or mid and mid+1 elements are same, so we should search in left of mid \\n4. CONDITION OF VALID ODD EVEN PAIR\\n if position of mid is even and it has not completed even odd pairs i.e. mid and mid+1 elements are different or mid and mid-1 elements are same, so we should search in left of mid \\n5. CONDITION OF VALID NUMBER\\nif mid and mid+1 elements are different and mid and mid-1 elements are different, then mid element would be our answer. \\n"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I think bit manipulation is one of the better approach;\\n"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "add more test cases\\ni literally hard coded so that i could pass all 15 test cases and i did that ...lol"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "An O(N/2) solution beats 80% of the solutions. What\\'s even the point of putting that O(logN) time constraint?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "If the requirement is \"do this in O(log n)\", basically instructs what main algorithm you need to use to check through your array as a big fat hint. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Yeah XD. I did a dry run of my logic using binary search and the answer panned itself out"
                    },
                    {
                        "username": "scor32k",
                        "content": "using xor made easy"
                    },
                    {
                        "username": "viku_kr",
                        "content": "I solved by XOR and it passed. I was wondering why my solution is slightly slow, then I saw its supposed to be Log(n), still it not that fast compared other people\\'s submission."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a O(log n) problem"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "Your solution must run in O(log n) time, xor will run in O(n)"
                    },
                    {
                        "username": "yosemite",
                        "content": "The time complexity is mentioned as O(log n). To meet this, an additional constraint needs to be added in the question: \"All repeated numbers appear in pairs in the input.\" The examples in the question seem to illustrate this, but the condition is not mentioned in the question itself. \\n\\nPS: I received this question in a real interview too, and that is how I am aware."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sorted implies this is true"
                    },
                    {
                        "username": "skipper__7",
                        "content": "It is mentioned in the question that the array is sorted so they appear together."
                    },
                    {
                        "username": "CHOPPER14",
                        "content": "\"\"\"\\nreturn ((2*sum(set(nums)))-sum(nums))\\n\"\"\""
                    },
                    {
                        "username": "cswartzell",
                        "content": "While a pretty clever hack, this is an O(n) solution, so shouldnt actually count. That being said, I personally think this is my favorite solution so far. "
                    },
                    {
                        "username": "Akriti1701",
                        "content": "Using binary search, is there any other method of determining on which side the single element lies, instead of identifying odd and even numbers?"
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "1. If n == 1: This means the array size is 1. If the array contains only one element, we will return that element only.\\n2. If arr[0] != arr[1]: This means the very first element of the array is the single element. So, we will return arr[0].\\n3. If arr[n-1] != arr[n-2]: This means the last element of the array is the single element. So, we will return arr[n-1].\\n4. Place the 2 pointers i.e. low and high: Initially, we will place the pointers excluding index 0 and n-1 like this: low will point to index 1, and high will point to index n-2 i.e. the second last index.\\n5. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n6. Check if arr[mid] is the single element:\\nIf arr[mid] != arr[mid-1] and arr[mid] != arr[mid+1]: If this condition is true for arr[mid], we can conclude arr[mid] is the single element. We will return arr[mid].\\n7. If (mid % 2 == 0 and arr[mid] == arr[mid+1])\\nor (mid%2 == 1 and arr[mid] == arr[mid-1]): This means we are in the left half and we should eliminate it as our single element appears on the right. So, we will do this:\\nlow = mid+1.\\n8. Otherwise, we are in the right half and we should eliminate it as our single element appears on the left. So, we will do this: high = mid-1."
                    }
                ]
            },
            {
                "id": 1575868,
                "content": [
                    {
                        "username": "neeshumaini55",
                        "content": "The problem is for checking valid even odd pair.\\n1. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is odd and it has completed even odd pairs i.e. mid and mid-1 elements are same so we should search in right of mid \\n2. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is even and it has completed even odd pairs i.e. mid and mid+1 elements are same so we should search in right of mid \\n3. CONDITION OF VALID ODD EVEN PAIR\\nif position of mid is odd and it has not completed even odd pairs i.e. mid and mid-1 elements are different or mid and mid+1 elements are same, so we should search in left of mid \\n4. CONDITION OF VALID ODD EVEN PAIR\\n if position of mid is even and it has not completed even odd pairs i.e. mid and mid+1 elements are different or mid and mid-1 elements are same, so we should search in left of mid \\n5. CONDITION OF VALID NUMBER\\nif mid and mid+1 elements are different and mid and mid-1 elements are different, then mid element would be our answer. \\n"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I think bit manipulation is one of the better approach;\\n"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "add more test cases\\ni literally hard coded so that i could pass all 15 test cases and i did that ...lol"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "An O(N/2) solution beats 80% of the solutions. What\\'s even the point of putting that O(logN) time constraint?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "If the requirement is \"do this in O(log n)\", basically instructs what main algorithm you need to use to check through your array as a big fat hint. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Yeah XD. I did a dry run of my logic using binary search and the answer panned itself out"
                    },
                    {
                        "username": "scor32k",
                        "content": "using xor made easy"
                    },
                    {
                        "username": "viku_kr",
                        "content": "I solved by XOR and it passed. I was wondering why my solution is slightly slow, then I saw its supposed to be Log(n), still it not that fast compared other people\\'s submission."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a O(log n) problem"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "Your solution must run in O(log n) time, xor will run in O(n)"
                    },
                    {
                        "username": "yosemite",
                        "content": "The time complexity is mentioned as O(log n). To meet this, an additional constraint needs to be added in the question: \"All repeated numbers appear in pairs in the input.\" The examples in the question seem to illustrate this, but the condition is not mentioned in the question itself. \\n\\nPS: I received this question in a real interview too, and that is how I am aware."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sorted implies this is true"
                    },
                    {
                        "username": "skipper__7",
                        "content": "It is mentioned in the question that the array is sorted so they appear together."
                    },
                    {
                        "username": "CHOPPER14",
                        "content": "\"\"\"\\nreturn ((2*sum(set(nums)))-sum(nums))\\n\"\"\""
                    },
                    {
                        "username": "cswartzell",
                        "content": "While a pretty clever hack, this is an O(n) solution, so shouldnt actually count. That being said, I personally think this is my favorite solution so far. "
                    },
                    {
                        "username": "Akriti1701",
                        "content": "Using binary search, is there any other method of determining on which side the single element lies, instead of identifying odd and even numbers?"
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "1. If n == 1: This means the array size is 1. If the array contains only one element, we will return that element only.\\n2. If arr[0] != arr[1]: This means the very first element of the array is the single element. So, we will return arr[0].\\n3. If arr[n-1] != arr[n-2]: This means the last element of the array is the single element. So, we will return arr[n-1].\\n4. Place the 2 pointers i.e. low and high: Initially, we will place the pointers excluding index 0 and n-1 like this: low will point to index 1, and high will point to index n-2 i.e. the second last index.\\n5. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n6. Check if arr[mid] is the single element:\\nIf arr[mid] != arr[mid-1] and arr[mid] != arr[mid+1]: If this condition is true for arr[mid], we can conclude arr[mid] is the single element. We will return arr[mid].\\n7. If (mid % 2 == 0 and arr[mid] == arr[mid+1])\\nor (mid%2 == 1 and arr[mid] == arr[mid-1]): This means we are in the left half and we should eliminate it as our single element appears on the right. So, we will do this:\\nlow = mid+1.\\n8. Otherwise, we are in the right half and we should eliminate it as our single element appears on the left. So, we will do this: high = mid-1."
                    }
                ]
            },
            {
                "id": 2075565,
                "content": [
                    {
                        "username": "neeshumaini55",
                        "content": "The problem is for checking valid even odd pair.\\n1. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is odd and it has completed even odd pairs i.e. mid and mid-1 elements are same so we should search in right of mid \\n2. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is even and it has completed even odd pairs i.e. mid and mid+1 elements are same so we should search in right of mid \\n3. CONDITION OF VALID ODD EVEN PAIR\\nif position of mid is odd and it has not completed even odd pairs i.e. mid and mid-1 elements are different or mid and mid+1 elements are same, so we should search in left of mid \\n4. CONDITION OF VALID ODD EVEN PAIR\\n if position of mid is even and it has not completed even odd pairs i.e. mid and mid+1 elements are different or mid and mid-1 elements are same, so we should search in left of mid \\n5. CONDITION OF VALID NUMBER\\nif mid and mid+1 elements are different and mid and mid-1 elements are different, then mid element would be our answer. \\n"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I think bit manipulation is one of the better approach;\\n"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "add more test cases\\ni literally hard coded so that i could pass all 15 test cases and i did that ...lol"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "An O(N/2) solution beats 80% of the solutions. What\\'s even the point of putting that O(logN) time constraint?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "If the requirement is \"do this in O(log n)\", basically instructs what main algorithm you need to use to check through your array as a big fat hint. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Yeah XD. I did a dry run of my logic using binary search and the answer panned itself out"
                    },
                    {
                        "username": "scor32k",
                        "content": "using xor made easy"
                    },
                    {
                        "username": "viku_kr",
                        "content": "I solved by XOR and it passed. I was wondering why my solution is slightly slow, then I saw its supposed to be Log(n), still it not that fast compared other people\\'s submission."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a O(log n) problem"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "Your solution must run in O(log n) time, xor will run in O(n)"
                    },
                    {
                        "username": "yosemite",
                        "content": "The time complexity is mentioned as O(log n). To meet this, an additional constraint needs to be added in the question: \"All repeated numbers appear in pairs in the input.\" The examples in the question seem to illustrate this, but the condition is not mentioned in the question itself. \\n\\nPS: I received this question in a real interview too, and that is how I am aware."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sorted implies this is true"
                    },
                    {
                        "username": "skipper__7",
                        "content": "It is mentioned in the question that the array is sorted so they appear together."
                    },
                    {
                        "username": "CHOPPER14",
                        "content": "\"\"\"\\nreturn ((2*sum(set(nums)))-sum(nums))\\n\"\"\""
                    },
                    {
                        "username": "cswartzell",
                        "content": "While a pretty clever hack, this is an O(n) solution, so shouldnt actually count. That being said, I personally think this is my favorite solution so far. "
                    },
                    {
                        "username": "Akriti1701",
                        "content": "Using binary search, is there any other method of determining on which side the single element lies, instead of identifying odd and even numbers?"
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "1. If n == 1: This means the array size is 1. If the array contains only one element, we will return that element only.\\n2. If arr[0] != arr[1]: This means the very first element of the array is the single element. So, we will return arr[0].\\n3. If arr[n-1] != arr[n-2]: This means the last element of the array is the single element. So, we will return arr[n-1].\\n4. Place the 2 pointers i.e. low and high: Initially, we will place the pointers excluding index 0 and n-1 like this: low will point to index 1, and high will point to index n-2 i.e. the second last index.\\n5. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n6. Check if arr[mid] is the single element:\\nIf arr[mid] != arr[mid-1] and arr[mid] != arr[mid+1]: If this condition is true for arr[mid], we can conclude arr[mid] is the single element. We will return arr[mid].\\n7. If (mid % 2 == 0 and arr[mid] == arr[mid+1])\\nor (mid%2 == 1 and arr[mid] == arr[mid-1]): This means we are in the left half and we should eliminate it as our single element appears on the right. So, we will do this:\\nlow = mid+1.\\n8. Otherwise, we are in the right half and we should eliminate it as our single element appears on the left. So, we will do this: high = mid-1."
                    }
                ]
            },
            {
                "id": 2016098,
                "content": [
                    {
                        "username": "neeshumaini55",
                        "content": "The problem is for checking valid even odd pair.\\n1. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is odd and it has completed even odd pairs i.e. mid and mid-1 elements are same so we should search in right of mid \\n2. CONDITION OF VALID EVEN ODD PAIR \\nif position of mid is even and it has completed even odd pairs i.e. mid and mid+1 elements are same so we should search in right of mid \\n3. CONDITION OF VALID ODD EVEN PAIR\\nif position of mid is odd and it has not completed even odd pairs i.e. mid and mid-1 elements are different or mid and mid+1 elements are same, so we should search in left of mid \\n4. CONDITION OF VALID ODD EVEN PAIR\\n if position of mid is even and it has not completed even odd pairs i.e. mid and mid+1 elements are different or mid and mid-1 elements are same, so we should search in left of mid \\n5. CONDITION OF VALID NUMBER\\nif mid and mid+1 elements are different and mid and mid-1 elements are different, then mid element would be our answer. \\n"
                    },
                    {
                        "username": "jadonabhi_",
                        "content": "I think bit manipulation is one of the better approach;\\n"
                    },
                    {
                        "username": "rishabhrawat526",
                        "content": "add more test cases\\ni literally hard coded so that i could pass all 15 test cases and i did that ...lol"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "An O(N/2) solution beats 80% of the solutions. What\\'s even the point of putting that O(logN) time constraint?"
                    },
                    {
                        "username": "cswartzell",
                        "content": "If the requirement is \"do this in O(log n)\", basically instructs what main algorithm you need to use to check through your array as a big fat hint. "
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Yeah XD. I did a dry run of my logic using binary search and the answer panned itself out"
                    },
                    {
                        "username": "scor32k",
                        "content": "using xor made easy"
                    },
                    {
                        "username": "viku_kr",
                        "content": "I solved by XOR and it passed. I was wondering why my solution is slightly slow, then I saw its supposed to be Log(n), still it not that fast compared other people\\'s submission."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "This is a O(log n) problem"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "Your solution must run in O(log n) time, xor will run in O(n)"
                    },
                    {
                        "username": "yosemite",
                        "content": "The time complexity is mentioned as O(log n). To meet this, an additional constraint needs to be added in the question: \"All repeated numbers appear in pairs in the input.\" The examples in the question seem to illustrate this, but the condition is not mentioned in the question itself. \\n\\nPS: I received this question in a real interview too, and that is how I am aware."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sorted implies this is true"
                    },
                    {
                        "username": "skipper__7",
                        "content": "It is mentioned in the question that the array is sorted so they appear together."
                    },
                    {
                        "username": "CHOPPER14",
                        "content": "\"\"\"\\nreturn ((2*sum(set(nums)))-sum(nums))\\n\"\"\""
                    },
                    {
                        "username": "cswartzell",
                        "content": "While a pretty clever hack, this is an O(n) solution, so shouldnt actually count. That being said, I personally think this is my favorite solution so far. "
                    },
                    {
                        "username": "Akriti1701",
                        "content": "Using binary search, is there any other method of determining on which side the single element lies, instead of identifying odd and even numbers?"
                    },
                    {
                        "username": "DraculeMihawk",
                        "content": "1. If n == 1: This means the array size is 1. If the array contains only one element, we will return that element only.\\n2. If arr[0] != arr[1]: This means the very first element of the array is the single element. So, we will return arr[0].\\n3. If arr[n-1] != arr[n-2]: This means the last element of the array is the single element. So, we will return arr[n-1].\\n4. Place the 2 pointers i.e. low and high: Initially, we will place the pointers excluding index 0 and n-1 like this: low will point to index 1, and high will point to index n-2 i.e. the second last index.\\n5. Calculate the \\u2018mid\\u2019: Now, inside a loop, we will calculate the value of \\u2018mid\\u2019 using the following formula:\\nmid = (low+high) // 2 ( \\u2018//\\u2019 refers to integer division)\\n6. Check if arr[mid] is the single element:\\nIf arr[mid] != arr[mid-1] and arr[mid] != arr[mid+1]: If this condition is true for arr[mid], we can conclude arr[mid] is the single element. We will return arr[mid].\\n7. If (mid % 2 == 0 and arr[mid] == arr[mid+1])\\nor (mid%2 == 1 and arr[mid] == arr[mid-1]): This means we are in the left half and we should eliminate it as our single element appears on the right. So, we will do this:\\nlow = mid+1.\\n8. Otherwise, we are in the right half and we should eliminate it as our single element appears on the left. So, we will do this: high = mid-1."
                    }
                ]
            },
            {
                "id": 2010811,
                "content": [
                    {
                        "username": "Mohtashim_ali",
                        "content": "Can also be solved in O(n) using XOR , as the XOR of two same numbers is 0 , 136. Single Number delivers the XOR concept "
                    },
                    {
                        "username": "willa999",
                        "content": "can i solve it by binary searching for element at index i.if i get an element similar to that i return true but for some index i dont gets its similar and return false and finally return the element at false "
                    },
                    {
                        "username": "karkisa",
                        "content": "Hint 1: \\nThink of some way to split it nums into even lenght +odd length \\n\\n\\nHint 2 :\\nUse mid point and some how use hint 1 if mid point number has duplicate: else return mid"
                    },
                    {
                        "username": "abhishah1304",
                        "content": " `int single(vector<int> nums,int start,int end)\\n    { \\n        if(start<=end)\\n        {\\n            int middle = (start+((end-start)/2));\\n           if(middle==0)\\n           {\\n               if(nums[middle+1]!=nums[middle])\\n               {\\n                   return nums[middle];\\n               }\\n           }\\n           else if(middle==(nums.size()-1))\\n           {\\n           if(nums[middle]!=nums[middle-1])\\n           {\\n              return nums[middle];\\n           }\\n           }\\n           else if((nums[middle]!=nums[middle+1])&&(nums[middle]!=nums[middle-1]))\\n           {\\n               return nums[middle];\\n           }\\n           int a = single(nums,start,middle-1);\\n           if(a!=-1)\\n           {\\n             return a;\\n           }\\n           else return single(nums,middle+1,end);\\n        }\\n        return -1;\\n        \\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        return single(nums,0,nums.size()-1);\\n    }`\\nCan some explain why it is giving TLE Exceeded ?"
                    },
                    {
                        "username": "_SID_",
                        "content": "- As it is given sorted we use Binary Search\\n- If not sorted then bit manipulation XOR"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "yuppp\\n"
                    },
                    {
                        "username": "abhinavcode69",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        \\n        // Handle edge cases separately to avoid complexity\\n        if (nums[0] != nums[1]) {\\n            return nums[0];\\n        }\\n        if (nums[n - 1] != nums[n - 2]) {\\n            return nums[n - 1];\\n        }\\n        \\n        int low = 1;\\n        int high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            // Check if nums[mid] is the unique element\\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            \\n            // Eliminate the left or right half based on the conditions\\n            if (mid % 2 == 1 && nums[mid - 1] == nums[mid]) {\\n                low = mid + 1;\\n            }\\n            else if (mid % 2 == 0 && nums[mid - 1] == nums[mid]) {\\n                high = mid - 1;\\n            }\\n           \\n        }\\n        \\n        return -1;  // No unique element found\\n    }\\n};\\nthis code is giving me tle even after i did in logn? help"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "// Eliminate the left or right half based on the conditions\\nWhat if neither condition is true?  Sounds like inf loop"
                    },
                    {
                        "username": "YASH0025",
                        "content": "\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n    let xor = 0\\n    for(let i= 0 ; i<nums.length;i++){\\n        xor = xor^nums[i]\\n\\n    }\\n    return xor\\n};\\n\\n// javascript solution using xor"
                    },
                    {
                        "username": "Vithesh",
                        "content": "I did actually solve this problem in O(logn) time and O(1) space in like 25 min but.... i felt like something is off. I dont know what.."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me, i\\'m practising problems on binary search, i\\'m not able to figure out when should i use the while loop condition as left < right and left <= right . I\\'m totally confused, by different usage in different problem.\\n\\nCan anyone share a generic template and generic way of thought process. I\\'ll be really grateful.\\nThanks in advance!"
                    },
                    {
                        "username": "Codilini",
                        "content": "Can someone please help solve this? I am getting \"list index out of range\" error for line elif nums[mid] == nums[mid+1]\n\n `       left = 0`\n`        right = len(nums)-1`\n   \n        `while(left < right):\n            mid = (left+(right-left))//2\n\n            if nums[mid] == nums[mid-1]:\n                if mid%2==0:\n                    right = mid-2\n                else:\n                    left = mid+1\n\n            elif nums[mid] == nums[mid+1]:\n                \n                if mid%2==0:\n                    left = mid+2\n                else:\n                    right = mid-1\n            \n            else:\n                return nums[mid]\n        return nums[left]`"
                    }
                ]
            },
            {
                "id": 2005326,
                "content": [
                    {
                        "username": "Mohtashim_ali",
                        "content": "Can also be solved in O(n) using XOR , as the XOR of two same numbers is 0 , 136. Single Number delivers the XOR concept "
                    },
                    {
                        "username": "willa999",
                        "content": "can i solve it by binary searching for element at index i.if i get an element similar to that i return true but for some index i dont gets its similar and return false and finally return the element at false "
                    },
                    {
                        "username": "karkisa",
                        "content": "Hint 1: \\nThink of some way to split it nums into even lenght +odd length \\n\\n\\nHint 2 :\\nUse mid point and some how use hint 1 if mid point number has duplicate: else return mid"
                    },
                    {
                        "username": "abhishah1304",
                        "content": " `int single(vector<int> nums,int start,int end)\\n    { \\n        if(start<=end)\\n        {\\n            int middle = (start+((end-start)/2));\\n           if(middle==0)\\n           {\\n               if(nums[middle+1]!=nums[middle])\\n               {\\n                   return nums[middle];\\n               }\\n           }\\n           else if(middle==(nums.size()-1))\\n           {\\n           if(nums[middle]!=nums[middle-1])\\n           {\\n              return nums[middle];\\n           }\\n           }\\n           else if((nums[middle]!=nums[middle+1])&&(nums[middle]!=nums[middle-1]))\\n           {\\n               return nums[middle];\\n           }\\n           int a = single(nums,start,middle-1);\\n           if(a!=-1)\\n           {\\n             return a;\\n           }\\n           else return single(nums,middle+1,end);\\n        }\\n        return -1;\\n        \\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        return single(nums,0,nums.size()-1);\\n    }`\\nCan some explain why it is giving TLE Exceeded ?"
                    },
                    {
                        "username": "_SID_",
                        "content": "- As it is given sorted we use Binary Search\\n- If not sorted then bit manipulation XOR"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "yuppp\\n"
                    },
                    {
                        "username": "abhinavcode69",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        \\n        // Handle edge cases separately to avoid complexity\\n        if (nums[0] != nums[1]) {\\n            return nums[0];\\n        }\\n        if (nums[n - 1] != nums[n - 2]) {\\n            return nums[n - 1];\\n        }\\n        \\n        int low = 1;\\n        int high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            // Check if nums[mid] is the unique element\\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            \\n            // Eliminate the left or right half based on the conditions\\n            if (mid % 2 == 1 && nums[mid - 1] == nums[mid]) {\\n                low = mid + 1;\\n            }\\n            else if (mid % 2 == 0 && nums[mid - 1] == nums[mid]) {\\n                high = mid - 1;\\n            }\\n           \\n        }\\n        \\n        return -1;  // No unique element found\\n    }\\n};\\nthis code is giving me tle even after i did in logn? help"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "// Eliminate the left or right half based on the conditions\\nWhat if neither condition is true?  Sounds like inf loop"
                    },
                    {
                        "username": "YASH0025",
                        "content": "\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n    let xor = 0\\n    for(let i= 0 ; i<nums.length;i++){\\n        xor = xor^nums[i]\\n\\n    }\\n    return xor\\n};\\n\\n// javascript solution using xor"
                    },
                    {
                        "username": "Vithesh",
                        "content": "I did actually solve this problem in O(logn) time and O(1) space in like 25 min but.... i felt like something is off. I dont know what.."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me, i\\'m practising problems on binary search, i\\'m not able to figure out when should i use the while loop condition as left < right and left <= right . I\\'m totally confused, by different usage in different problem.\\n\\nCan anyone share a generic template and generic way of thought process. I\\'ll be really grateful.\\nThanks in advance!"
                    },
                    {
                        "username": "Codilini",
                        "content": "Can someone please help solve this? I am getting \"list index out of range\" error for line elif nums[mid] == nums[mid+1]\n\n `       left = 0`\n`        right = len(nums)-1`\n   \n        `while(left < right):\n            mid = (left+(right-left))//2\n\n            if nums[mid] == nums[mid-1]:\n                if mid%2==0:\n                    right = mid-2\n                else:\n                    left = mid+1\n\n            elif nums[mid] == nums[mid+1]:\n                \n                if mid%2==0:\n                    left = mid+2\n                else:\n                    right = mid-1\n            \n            else:\n                return nums[mid]\n        return nums[left]`"
                    }
                ]
            },
            {
                "id": 2002005,
                "content": [
                    {
                        "username": "Mohtashim_ali",
                        "content": "Can also be solved in O(n) using XOR , as the XOR of two same numbers is 0 , 136. Single Number delivers the XOR concept "
                    },
                    {
                        "username": "willa999",
                        "content": "can i solve it by binary searching for element at index i.if i get an element similar to that i return true but for some index i dont gets its similar and return false and finally return the element at false "
                    },
                    {
                        "username": "karkisa",
                        "content": "Hint 1: \\nThink of some way to split it nums into even lenght +odd length \\n\\n\\nHint 2 :\\nUse mid point and some how use hint 1 if mid point number has duplicate: else return mid"
                    },
                    {
                        "username": "abhishah1304",
                        "content": " `int single(vector<int> nums,int start,int end)\\n    { \\n        if(start<=end)\\n        {\\n            int middle = (start+((end-start)/2));\\n           if(middle==0)\\n           {\\n               if(nums[middle+1]!=nums[middle])\\n               {\\n                   return nums[middle];\\n               }\\n           }\\n           else if(middle==(nums.size()-1))\\n           {\\n           if(nums[middle]!=nums[middle-1])\\n           {\\n              return nums[middle];\\n           }\\n           }\\n           else if((nums[middle]!=nums[middle+1])&&(nums[middle]!=nums[middle-1]))\\n           {\\n               return nums[middle];\\n           }\\n           int a = single(nums,start,middle-1);\\n           if(a!=-1)\\n           {\\n             return a;\\n           }\\n           else return single(nums,middle+1,end);\\n        }\\n        return -1;\\n        \\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        return single(nums,0,nums.size()-1);\\n    }`\\nCan some explain why it is giving TLE Exceeded ?"
                    },
                    {
                        "username": "_SID_",
                        "content": "- As it is given sorted we use Binary Search\\n- If not sorted then bit manipulation XOR"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "yuppp\\n"
                    },
                    {
                        "username": "abhinavcode69",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        \\n        // Handle edge cases separately to avoid complexity\\n        if (nums[0] != nums[1]) {\\n            return nums[0];\\n        }\\n        if (nums[n - 1] != nums[n - 2]) {\\n            return nums[n - 1];\\n        }\\n        \\n        int low = 1;\\n        int high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            // Check if nums[mid] is the unique element\\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            \\n            // Eliminate the left or right half based on the conditions\\n            if (mid % 2 == 1 && nums[mid - 1] == nums[mid]) {\\n                low = mid + 1;\\n            }\\n            else if (mid % 2 == 0 && nums[mid - 1] == nums[mid]) {\\n                high = mid - 1;\\n            }\\n           \\n        }\\n        \\n        return -1;  // No unique element found\\n    }\\n};\\nthis code is giving me tle even after i did in logn? help"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "// Eliminate the left or right half based on the conditions\\nWhat if neither condition is true?  Sounds like inf loop"
                    },
                    {
                        "username": "YASH0025",
                        "content": "\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n    let xor = 0\\n    for(let i= 0 ; i<nums.length;i++){\\n        xor = xor^nums[i]\\n\\n    }\\n    return xor\\n};\\n\\n// javascript solution using xor"
                    },
                    {
                        "username": "Vithesh",
                        "content": "I did actually solve this problem in O(logn) time and O(1) space in like 25 min but.... i felt like something is off. I dont know what.."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me, i\\'m practising problems on binary search, i\\'m not able to figure out when should i use the while loop condition as left < right and left <= right . I\\'m totally confused, by different usage in different problem.\\n\\nCan anyone share a generic template and generic way of thought process. I\\'ll be really grateful.\\nThanks in advance!"
                    },
                    {
                        "username": "Codilini",
                        "content": "Can someone please help solve this? I am getting \"list index out of range\" error for line elif nums[mid] == nums[mid+1]\n\n `       left = 0`\n`        right = len(nums)-1`\n   \n        `while(left < right):\n            mid = (left+(right-left))//2\n\n            if nums[mid] == nums[mid-1]:\n                if mid%2==0:\n                    right = mid-2\n                else:\n                    left = mid+1\n\n            elif nums[mid] == nums[mid+1]:\n                \n                if mid%2==0:\n                    left = mid+2\n                else:\n                    right = mid-1\n            \n            else:\n                return nums[mid]\n        return nums[left]`"
                    }
                ]
            },
            {
                "id": 1958532,
                "content": [
                    {
                        "username": "Mohtashim_ali",
                        "content": "Can also be solved in O(n) using XOR , as the XOR of two same numbers is 0 , 136. Single Number delivers the XOR concept "
                    },
                    {
                        "username": "willa999",
                        "content": "can i solve it by binary searching for element at index i.if i get an element similar to that i return true but for some index i dont gets its similar and return false and finally return the element at false "
                    },
                    {
                        "username": "karkisa",
                        "content": "Hint 1: \\nThink of some way to split it nums into even lenght +odd length \\n\\n\\nHint 2 :\\nUse mid point and some how use hint 1 if mid point number has duplicate: else return mid"
                    },
                    {
                        "username": "abhishah1304",
                        "content": " `int single(vector<int> nums,int start,int end)\\n    { \\n        if(start<=end)\\n        {\\n            int middle = (start+((end-start)/2));\\n           if(middle==0)\\n           {\\n               if(nums[middle+1]!=nums[middle])\\n               {\\n                   return nums[middle];\\n               }\\n           }\\n           else if(middle==(nums.size()-1))\\n           {\\n           if(nums[middle]!=nums[middle-1])\\n           {\\n              return nums[middle];\\n           }\\n           }\\n           else if((nums[middle]!=nums[middle+1])&&(nums[middle]!=nums[middle-1]))\\n           {\\n               return nums[middle];\\n           }\\n           int a = single(nums,start,middle-1);\\n           if(a!=-1)\\n           {\\n             return a;\\n           }\\n           else return single(nums,middle+1,end);\\n        }\\n        return -1;\\n        \\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        return single(nums,0,nums.size()-1);\\n    }`\\nCan some explain why it is giving TLE Exceeded ?"
                    },
                    {
                        "username": "_SID_",
                        "content": "- As it is given sorted we use Binary Search\\n- If not sorted then bit manipulation XOR"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "yuppp\\n"
                    },
                    {
                        "username": "abhinavcode69",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        \\n        // Handle edge cases separately to avoid complexity\\n        if (nums[0] != nums[1]) {\\n            return nums[0];\\n        }\\n        if (nums[n - 1] != nums[n - 2]) {\\n            return nums[n - 1];\\n        }\\n        \\n        int low = 1;\\n        int high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            // Check if nums[mid] is the unique element\\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            \\n            // Eliminate the left or right half based on the conditions\\n            if (mid % 2 == 1 && nums[mid - 1] == nums[mid]) {\\n                low = mid + 1;\\n            }\\n            else if (mid % 2 == 0 && nums[mid - 1] == nums[mid]) {\\n                high = mid - 1;\\n            }\\n           \\n        }\\n        \\n        return -1;  // No unique element found\\n    }\\n};\\nthis code is giving me tle even after i did in logn? help"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "// Eliminate the left or right half based on the conditions\\nWhat if neither condition is true?  Sounds like inf loop"
                    },
                    {
                        "username": "YASH0025",
                        "content": "\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n    let xor = 0\\n    for(let i= 0 ; i<nums.length;i++){\\n        xor = xor^nums[i]\\n\\n    }\\n    return xor\\n};\\n\\n// javascript solution using xor"
                    },
                    {
                        "username": "Vithesh",
                        "content": "I did actually solve this problem in O(logn) time and O(1) space in like 25 min but.... i felt like something is off. I dont know what.."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me, i\\'m practising problems on binary search, i\\'m not able to figure out when should i use the while loop condition as left < right and left <= right . I\\'m totally confused, by different usage in different problem.\\n\\nCan anyone share a generic template and generic way of thought process. I\\'ll be really grateful.\\nThanks in advance!"
                    },
                    {
                        "username": "Codilini",
                        "content": "Can someone please help solve this? I am getting \"list index out of range\" error for line elif nums[mid] == nums[mid+1]\n\n `       left = 0`\n`        right = len(nums)-1`\n   \n        `while(left < right):\n            mid = (left+(right-left))//2\n\n            if nums[mid] == nums[mid-1]:\n                if mid%2==0:\n                    right = mid-2\n                else:\n                    left = mid+1\n\n            elif nums[mid] == nums[mid+1]:\n                \n                if mid%2==0:\n                    left = mid+2\n                else:\n                    right = mid-1\n            \n            else:\n                return nums[mid]\n        return nums[left]`"
                    }
                ]
            },
            {
                "id": 1957730,
                "content": [
                    {
                        "username": "Mohtashim_ali",
                        "content": "Can also be solved in O(n) using XOR , as the XOR of two same numbers is 0 , 136. Single Number delivers the XOR concept "
                    },
                    {
                        "username": "willa999",
                        "content": "can i solve it by binary searching for element at index i.if i get an element similar to that i return true but for some index i dont gets its similar and return false and finally return the element at false "
                    },
                    {
                        "username": "karkisa",
                        "content": "Hint 1: \\nThink of some way to split it nums into even lenght +odd length \\n\\n\\nHint 2 :\\nUse mid point and some how use hint 1 if mid point number has duplicate: else return mid"
                    },
                    {
                        "username": "abhishah1304",
                        "content": " `int single(vector<int> nums,int start,int end)\\n    { \\n        if(start<=end)\\n        {\\n            int middle = (start+((end-start)/2));\\n           if(middle==0)\\n           {\\n               if(nums[middle+1]!=nums[middle])\\n               {\\n                   return nums[middle];\\n               }\\n           }\\n           else if(middle==(nums.size()-1))\\n           {\\n           if(nums[middle]!=nums[middle-1])\\n           {\\n              return nums[middle];\\n           }\\n           }\\n           else if((nums[middle]!=nums[middle+1])&&(nums[middle]!=nums[middle-1]))\\n           {\\n               return nums[middle];\\n           }\\n           int a = single(nums,start,middle-1);\\n           if(a!=-1)\\n           {\\n             return a;\\n           }\\n           else return single(nums,middle+1,end);\\n        }\\n        return -1;\\n        \\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        return single(nums,0,nums.size()-1);\\n    }`\\nCan some explain why it is giving TLE Exceeded ?"
                    },
                    {
                        "username": "_SID_",
                        "content": "- As it is given sorted we use Binary Search\\n- If not sorted then bit manipulation XOR"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "yuppp\\n"
                    },
                    {
                        "username": "abhinavcode69",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        \\n        // Handle edge cases separately to avoid complexity\\n        if (nums[0] != nums[1]) {\\n            return nums[0];\\n        }\\n        if (nums[n - 1] != nums[n - 2]) {\\n            return nums[n - 1];\\n        }\\n        \\n        int low = 1;\\n        int high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            // Check if nums[mid] is the unique element\\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            \\n            // Eliminate the left or right half based on the conditions\\n            if (mid % 2 == 1 && nums[mid - 1] == nums[mid]) {\\n                low = mid + 1;\\n            }\\n            else if (mid % 2 == 0 && nums[mid - 1] == nums[mid]) {\\n                high = mid - 1;\\n            }\\n           \\n        }\\n        \\n        return -1;  // No unique element found\\n    }\\n};\\nthis code is giving me tle even after i did in logn? help"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "// Eliminate the left or right half based on the conditions\\nWhat if neither condition is true?  Sounds like inf loop"
                    },
                    {
                        "username": "YASH0025",
                        "content": "\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n    let xor = 0\\n    for(let i= 0 ; i<nums.length;i++){\\n        xor = xor^nums[i]\\n\\n    }\\n    return xor\\n};\\n\\n// javascript solution using xor"
                    },
                    {
                        "username": "Vithesh",
                        "content": "I did actually solve this problem in O(logn) time and O(1) space in like 25 min but.... i felt like something is off. I dont know what.."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me, i\\'m practising problems on binary search, i\\'m not able to figure out when should i use the while loop condition as left < right and left <= right . I\\'m totally confused, by different usage in different problem.\\n\\nCan anyone share a generic template and generic way of thought process. I\\'ll be really grateful.\\nThanks in advance!"
                    },
                    {
                        "username": "Codilini",
                        "content": "Can someone please help solve this? I am getting \"list index out of range\" error for line elif nums[mid] == nums[mid+1]\n\n `       left = 0`\n`        right = len(nums)-1`\n   \n        `while(left < right):\n            mid = (left+(right-left))//2\n\n            if nums[mid] == nums[mid-1]:\n                if mid%2==0:\n                    right = mid-2\n                else:\n                    left = mid+1\n\n            elif nums[mid] == nums[mid+1]:\n                \n                if mid%2==0:\n                    left = mid+2\n                else:\n                    right = mid-1\n            \n            else:\n                return nums[mid]\n        return nums[left]`"
                    }
                ]
            },
            {
                "id": 1930818,
                "content": [
                    {
                        "username": "Mohtashim_ali",
                        "content": "Can also be solved in O(n) using XOR , as the XOR of two same numbers is 0 , 136. Single Number delivers the XOR concept "
                    },
                    {
                        "username": "willa999",
                        "content": "can i solve it by binary searching for element at index i.if i get an element similar to that i return true but for some index i dont gets its similar and return false and finally return the element at false "
                    },
                    {
                        "username": "karkisa",
                        "content": "Hint 1: \\nThink of some way to split it nums into even lenght +odd length \\n\\n\\nHint 2 :\\nUse mid point and some how use hint 1 if mid point number has duplicate: else return mid"
                    },
                    {
                        "username": "abhishah1304",
                        "content": " `int single(vector<int> nums,int start,int end)\\n    { \\n        if(start<=end)\\n        {\\n            int middle = (start+((end-start)/2));\\n           if(middle==0)\\n           {\\n               if(nums[middle+1]!=nums[middle])\\n               {\\n                   return nums[middle];\\n               }\\n           }\\n           else if(middle==(nums.size()-1))\\n           {\\n           if(nums[middle]!=nums[middle-1])\\n           {\\n              return nums[middle];\\n           }\\n           }\\n           else if((nums[middle]!=nums[middle+1])&&(nums[middle]!=nums[middle-1]))\\n           {\\n               return nums[middle];\\n           }\\n           int a = single(nums,start,middle-1);\\n           if(a!=-1)\\n           {\\n             return a;\\n           }\\n           else return single(nums,middle+1,end);\\n        }\\n        return -1;\\n        \\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        return single(nums,0,nums.size()-1);\\n    }`\\nCan some explain why it is giving TLE Exceeded ?"
                    },
                    {
                        "username": "_SID_",
                        "content": "- As it is given sorted we use Binary Search\\n- If not sorted then bit manipulation XOR"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "yuppp\\n"
                    },
                    {
                        "username": "abhinavcode69",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        \\n        // Handle edge cases separately to avoid complexity\\n        if (nums[0] != nums[1]) {\\n            return nums[0];\\n        }\\n        if (nums[n - 1] != nums[n - 2]) {\\n            return nums[n - 1];\\n        }\\n        \\n        int low = 1;\\n        int high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            // Check if nums[mid] is the unique element\\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            \\n            // Eliminate the left or right half based on the conditions\\n            if (mid % 2 == 1 && nums[mid - 1] == nums[mid]) {\\n                low = mid + 1;\\n            }\\n            else if (mid % 2 == 0 && nums[mid - 1] == nums[mid]) {\\n                high = mid - 1;\\n            }\\n           \\n        }\\n        \\n        return -1;  // No unique element found\\n    }\\n};\\nthis code is giving me tle even after i did in logn? help"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "// Eliminate the left or right half based on the conditions\\nWhat if neither condition is true?  Sounds like inf loop"
                    },
                    {
                        "username": "YASH0025",
                        "content": "\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n    let xor = 0\\n    for(let i= 0 ; i<nums.length;i++){\\n        xor = xor^nums[i]\\n\\n    }\\n    return xor\\n};\\n\\n// javascript solution using xor"
                    },
                    {
                        "username": "Vithesh",
                        "content": "I did actually solve this problem in O(logn) time and O(1) space in like 25 min but.... i felt like something is off. I dont know what.."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me, i\\'m practising problems on binary search, i\\'m not able to figure out when should i use the while loop condition as left < right and left <= right . I\\'m totally confused, by different usage in different problem.\\n\\nCan anyone share a generic template and generic way of thought process. I\\'ll be really grateful.\\nThanks in advance!"
                    },
                    {
                        "username": "Codilini",
                        "content": "Can someone please help solve this? I am getting \"list index out of range\" error for line elif nums[mid] == nums[mid+1]\n\n `       left = 0`\n`        right = len(nums)-1`\n   \n        `while(left < right):\n            mid = (left+(right-left))//2\n\n            if nums[mid] == nums[mid-1]:\n                if mid%2==0:\n                    right = mid-2\n                else:\n                    left = mid+1\n\n            elif nums[mid] == nums[mid+1]:\n                \n                if mid%2==0:\n                    left = mid+2\n                else:\n                    right = mid-1\n            \n            else:\n                return nums[mid]\n        return nums[left]`"
                    }
                ]
            },
            {
                "id": 1927877,
                "content": [
                    {
                        "username": "Mohtashim_ali",
                        "content": "Can also be solved in O(n) using XOR , as the XOR of two same numbers is 0 , 136. Single Number delivers the XOR concept "
                    },
                    {
                        "username": "willa999",
                        "content": "can i solve it by binary searching for element at index i.if i get an element similar to that i return true but for some index i dont gets its similar and return false and finally return the element at false "
                    },
                    {
                        "username": "karkisa",
                        "content": "Hint 1: \\nThink of some way to split it nums into even lenght +odd length \\n\\n\\nHint 2 :\\nUse mid point and some how use hint 1 if mid point number has duplicate: else return mid"
                    },
                    {
                        "username": "abhishah1304",
                        "content": " `int single(vector<int> nums,int start,int end)\\n    { \\n        if(start<=end)\\n        {\\n            int middle = (start+((end-start)/2));\\n           if(middle==0)\\n           {\\n               if(nums[middle+1]!=nums[middle])\\n               {\\n                   return nums[middle];\\n               }\\n           }\\n           else if(middle==(nums.size()-1))\\n           {\\n           if(nums[middle]!=nums[middle-1])\\n           {\\n              return nums[middle];\\n           }\\n           }\\n           else if((nums[middle]!=nums[middle+1])&&(nums[middle]!=nums[middle-1]))\\n           {\\n               return nums[middle];\\n           }\\n           int a = single(nums,start,middle-1);\\n           if(a!=-1)\\n           {\\n             return a;\\n           }\\n           else return single(nums,middle+1,end);\\n        }\\n        return -1;\\n        \\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        return single(nums,0,nums.size()-1);\\n    }`\\nCan some explain why it is giving TLE Exceeded ?"
                    },
                    {
                        "username": "_SID_",
                        "content": "- As it is given sorted we use Binary Search\\n- If not sorted then bit manipulation XOR"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "yuppp\\n"
                    },
                    {
                        "username": "abhinavcode69",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        \\n        // Handle edge cases separately to avoid complexity\\n        if (nums[0] != nums[1]) {\\n            return nums[0];\\n        }\\n        if (nums[n - 1] != nums[n - 2]) {\\n            return nums[n - 1];\\n        }\\n        \\n        int low = 1;\\n        int high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            // Check if nums[mid] is the unique element\\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            \\n            // Eliminate the left or right half based on the conditions\\n            if (mid % 2 == 1 && nums[mid - 1] == nums[mid]) {\\n                low = mid + 1;\\n            }\\n            else if (mid % 2 == 0 && nums[mid - 1] == nums[mid]) {\\n                high = mid - 1;\\n            }\\n           \\n        }\\n        \\n        return -1;  // No unique element found\\n    }\\n};\\nthis code is giving me tle even after i did in logn? help"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "// Eliminate the left or right half based on the conditions\\nWhat if neither condition is true?  Sounds like inf loop"
                    },
                    {
                        "username": "YASH0025",
                        "content": "\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n    let xor = 0\\n    for(let i= 0 ; i<nums.length;i++){\\n        xor = xor^nums[i]\\n\\n    }\\n    return xor\\n};\\n\\n// javascript solution using xor"
                    },
                    {
                        "username": "Vithesh",
                        "content": "I did actually solve this problem in O(logn) time and O(1) space in like 25 min but.... i felt like something is off. I dont know what.."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me, i\\'m practising problems on binary search, i\\'m not able to figure out when should i use the while loop condition as left < right and left <= right . I\\'m totally confused, by different usage in different problem.\\n\\nCan anyone share a generic template and generic way of thought process. I\\'ll be really grateful.\\nThanks in advance!"
                    },
                    {
                        "username": "Codilini",
                        "content": "Can someone please help solve this? I am getting \"list index out of range\" error for line elif nums[mid] == nums[mid+1]\n\n `       left = 0`\n`        right = len(nums)-1`\n   \n        `while(left < right):\n            mid = (left+(right-left))//2\n\n            if nums[mid] == nums[mid-1]:\n                if mid%2==0:\n                    right = mid-2\n                else:\n                    left = mid+1\n\n            elif nums[mid] == nums[mid+1]:\n                \n                if mid%2==0:\n                    left = mid+2\n                else:\n                    right = mid-1\n            \n            else:\n                return nums[mid]\n        return nums[left]`"
                    }
                ]
            },
            {
                "id": 1859456,
                "content": [
                    {
                        "username": "Mohtashim_ali",
                        "content": "Can also be solved in O(n) using XOR , as the XOR of two same numbers is 0 , 136. Single Number delivers the XOR concept "
                    },
                    {
                        "username": "willa999",
                        "content": "can i solve it by binary searching for element at index i.if i get an element similar to that i return true but for some index i dont gets its similar and return false and finally return the element at false "
                    },
                    {
                        "username": "karkisa",
                        "content": "Hint 1: \\nThink of some way to split it nums into even lenght +odd length \\n\\n\\nHint 2 :\\nUse mid point and some how use hint 1 if mid point number has duplicate: else return mid"
                    },
                    {
                        "username": "abhishah1304",
                        "content": " `int single(vector<int> nums,int start,int end)\\n    { \\n        if(start<=end)\\n        {\\n            int middle = (start+((end-start)/2));\\n           if(middle==0)\\n           {\\n               if(nums[middle+1]!=nums[middle])\\n               {\\n                   return nums[middle];\\n               }\\n           }\\n           else if(middle==(nums.size()-1))\\n           {\\n           if(nums[middle]!=nums[middle-1])\\n           {\\n              return nums[middle];\\n           }\\n           }\\n           else if((nums[middle]!=nums[middle+1])&&(nums[middle]!=nums[middle-1]))\\n           {\\n               return nums[middle];\\n           }\\n           int a = single(nums,start,middle-1);\\n           if(a!=-1)\\n           {\\n             return a;\\n           }\\n           else return single(nums,middle+1,end);\\n        }\\n        return -1;\\n        \\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        return single(nums,0,nums.size()-1);\\n    }`\\nCan some explain why it is giving TLE Exceeded ?"
                    },
                    {
                        "username": "_SID_",
                        "content": "- As it is given sorted we use Binary Search\\n- If not sorted then bit manipulation XOR"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "yuppp\\n"
                    },
                    {
                        "username": "abhinavcode69",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        \\n        // Handle edge cases separately to avoid complexity\\n        if (nums[0] != nums[1]) {\\n            return nums[0];\\n        }\\n        if (nums[n - 1] != nums[n - 2]) {\\n            return nums[n - 1];\\n        }\\n        \\n        int low = 1;\\n        int high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            // Check if nums[mid] is the unique element\\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            \\n            // Eliminate the left or right half based on the conditions\\n            if (mid % 2 == 1 && nums[mid - 1] == nums[mid]) {\\n                low = mid + 1;\\n            }\\n            else if (mid % 2 == 0 && nums[mid - 1] == nums[mid]) {\\n                high = mid - 1;\\n            }\\n           \\n        }\\n        \\n        return -1;  // No unique element found\\n    }\\n};\\nthis code is giving me tle even after i did in logn? help"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "// Eliminate the left or right half based on the conditions\\nWhat if neither condition is true?  Sounds like inf loop"
                    },
                    {
                        "username": "YASH0025",
                        "content": "\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n    let xor = 0\\n    for(let i= 0 ; i<nums.length;i++){\\n        xor = xor^nums[i]\\n\\n    }\\n    return xor\\n};\\n\\n// javascript solution using xor"
                    },
                    {
                        "username": "Vithesh",
                        "content": "I did actually solve this problem in O(logn) time and O(1) space in like 25 min but.... i felt like something is off. I dont know what.."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me, i\\'m practising problems on binary search, i\\'m not able to figure out when should i use the while loop condition as left < right and left <= right . I\\'m totally confused, by different usage in different problem.\\n\\nCan anyone share a generic template and generic way of thought process. I\\'ll be really grateful.\\nThanks in advance!"
                    },
                    {
                        "username": "Codilini",
                        "content": "Can someone please help solve this? I am getting \"list index out of range\" error for line elif nums[mid] == nums[mid+1]\n\n `       left = 0`\n`        right = len(nums)-1`\n   \n        `while(left < right):\n            mid = (left+(right-left))//2\n\n            if nums[mid] == nums[mid-1]:\n                if mid%2==0:\n                    right = mid-2\n                else:\n                    left = mid+1\n\n            elif nums[mid] == nums[mid+1]:\n                \n                if mid%2==0:\n                    left = mid+2\n                else:\n                    right = mid-1\n            \n            else:\n                return nums[mid]\n        return nums[left]`"
                    }
                ]
            },
            {
                "id": 1820549,
                "content": [
                    {
                        "username": "Mohtashim_ali",
                        "content": "Can also be solved in O(n) using XOR , as the XOR of two same numbers is 0 , 136. Single Number delivers the XOR concept "
                    },
                    {
                        "username": "willa999",
                        "content": "can i solve it by binary searching for element at index i.if i get an element similar to that i return true but for some index i dont gets its similar and return false and finally return the element at false "
                    },
                    {
                        "username": "karkisa",
                        "content": "Hint 1: \\nThink of some way to split it nums into even lenght +odd length \\n\\n\\nHint 2 :\\nUse mid point and some how use hint 1 if mid point number has duplicate: else return mid"
                    },
                    {
                        "username": "abhishah1304",
                        "content": " `int single(vector<int> nums,int start,int end)\\n    { \\n        if(start<=end)\\n        {\\n            int middle = (start+((end-start)/2));\\n           if(middle==0)\\n           {\\n               if(nums[middle+1]!=nums[middle])\\n               {\\n                   return nums[middle];\\n               }\\n           }\\n           else if(middle==(nums.size()-1))\\n           {\\n           if(nums[middle]!=nums[middle-1])\\n           {\\n              return nums[middle];\\n           }\\n           }\\n           else if((nums[middle]!=nums[middle+1])&&(nums[middle]!=nums[middle-1]))\\n           {\\n               return nums[middle];\\n           }\\n           int a = single(nums,start,middle-1);\\n           if(a!=-1)\\n           {\\n             return a;\\n           }\\n           else return single(nums,middle+1,end);\\n        }\\n        return -1;\\n        \\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        return single(nums,0,nums.size()-1);\\n    }`\\nCan some explain why it is giving TLE Exceeded ?"
                    },
                    {
                        "username": "_SID_",
                        "content": "- As it is given sorted we use Binary Search\\n- If not sorted then bit manipulation XOR"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "yuppp\\n"
                    },
                    {
                        "username": "abhinavcode69",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        \\n        // Handle edge cases separately to avoid complexity\\n        if (nums[0] != nums[1]) {\\n            return nums[0];\\n        }\\n        if (nums[n - 1] != nums[n - 2]) {\\n            return nums[n - 1];\\n        }\\n        \\n        int low = 1;\\n        int high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            // Check if nums[mid] is the unique element\\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            \\n            // Eliminate the left or right half based on the conditions\\n            if (mid % 2 == 1 && nums[mid - 1] == nums[mid]) {\\n                low = mid + 1;\\n            }\\n            else if (mid % 2 == 0 && nums[mid - 1] == nums[mid]) {\\n                high = mid - 1;\\n            }\\n           \\n        }\\n        \\n        return -1;  // No unique element found\\n    }\\n};\\nthis code is giving me tle even after i did in logn? help"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "// Eliminate the left or right half based on the conditions\\nWhat if neither condition is true?  Sounds like inf loop"
                    },
                    {
                        "username": "YASH0025",
                        "content": "\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n    let xor = 0\\n    for(let i= 0 ; i<nums.length;i++){\\n        xor = xor^nums[i]\\n\\n    }\\n    return xor\\n};\\n\\n// javascript solution using xor"
                    },
                    {
                        "username": "Vithesh",
                        "content": "I did actually solve this problem in O(logn) time and O(1) space in like 25 min but.... i felt like something is off. I dont know what.."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me, i\\'m practising problems on binary search, i\\'m not able to figure out when should i use the while loop condition as left < right and left <= right . I\\'m totally confused, by different usage in different problem.\\n\\nCan anyone share a generic template and generic way of thought process. I\\'ll be really grateful.\\nThanks in advance!"
                    },
                    {
                        "username": "Codilini",
                        "content": "Can someone please help solve this? I am getting \"list index out of range\" error for line elif nums[mid] == nums[mid+1]\n\n `       left = 0`\n`        right = len(nums)-1`\n   \n        `while(left < right):\n            mid = (left+(right-left))//2\n\n            if nums[mid] == nums[mid-1]:\n                if mid%2==0:\n                    right = mid-2\n                else:\n                    left = mid+1\n\n            elif nums[mid] == nums[mid+1]:\n                \n                if mid%2==0:\n                    left = mid+2\n                else:\n                    right = mid-1\n            \n            else:\n                return nums[mid]\n        return nums[left]`"
                    }
                ]
            },
            {
                "id": 1813285,
                "content": [
                    {
                        "username": "Mohtashim_ali",
                        "content": "Can also be solved in O(n) using XOR , as the XOR of two same numbers is 0 , 136. Single Number delivers the XOR concept "
                    },
                    {
                        "username": "willa999",
                        "content": "can i solve it by binary searching for element at index i.if i get an element similar to that i return true but for some index i dont gets its similar and return false and finally return the element at false "
                    },
                    {
                        "username": "karkisa",
                        "content": "Hint 1: \\nThink of some way to split it nums into even lenght +odd length \\n\\n\\nHint 2 :\\nUse mid point and some how use hint 1 if mid point number has duplicate: else return mid"
                    },
                    {
                        "username": "abhishah1304",
                        "content": " `int single(vector<int> nums,int start,int end)\\n    { \\n        if(start<=end)\\n        {\\n            int middle = (start+((end-start)/2));\\n           if(middle==0)\\n           {\\n               if(nums[middle+1]!=nums[middle])\\n               {\\n                   return nums[middle];\\n               }\\n           }\\n           else if(middle==(nums.size()-1))\\n           {\\n           if(nums[middle]!=nums[middle-1])\\n           {\\n              return nums[middle];\\n           }\\n           }\\n           else if((nums[middle]!=nums[middle+1])&&(nums[middle]!=nums[middle-1]))\\n           {\\n               return nums[middle];\\n           }\\n           int a = single(nums,start,middle-1);\\n           if(a!=-1)\\n           {\\n             return a;\\n           }\\n           else return single(nums,middle+1,end);\\n        }\\n        return -1;\\n        \\n    }\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)\\n        {\\n            return nums[0];\\n        }\\n        return single(nums,0,nums.size()-1);\\n    }`\\nCan some explain why it is giving TLE Exceeded ?"
                    },
                    {
                        "username": "_SID_",
                        "content": "- As it is given sorted we use Binary Search\\n- If not sorted then bit manipulation XOR"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "yuppp\\n"
                    },
                    {
                        "username": "abhinavcode69",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1) {\\n            return nums[0];\\n        }\\n        \\n        // Handle edge cases separately to avoid complexity\\n        if (nums[0] != nums[1]) {\\n            return nums[0];\\n        }\\n        if (nums[n - 1] != nums[n - 2]) {\\n            return nums[n - 1];\\n        }\\n        \\n        int low = 1;\\n        int high = n - 2;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            // Check if nums[mid] is the unique element\\n            if (nums[mid] != nums[mid + 1] && nums[mid] != nums[mid - 1]) {\\n                return nums[mid];\\n            }\\n            \\n            // Eliminate the left or right half based on the conditions\\n            if (mid % 2 == 1 && nums[mid - 1] == nums[mid]) {\\n                low = mid + 1;\\n            }\\n            else if (mid % 2 == 0 && nums[mid - 1] == nums[mid]) {\\n                high = mid - 1;\\n            }\\n           \\n        }\\n        \\n        return -1;  // No unique element found\\n    }\\n};\\nthis code is giving me tle even after i did in logn? help"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "// Eliminate the left or right half based on the conditions\\nWhat if neither condition is true?  Sounds like inf loop"
                    },
                    {
                        "username": "YASH0025",
                        "content": "\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar singleNonDuplicate = function(nums) {\\n    let xor = 0\\n    for(let i= 0 ; i<nums.length;i++){\\n        xor = xor^nums[i]\\n\\n    }\\n    return xor\\n};\\n\\n// javascript solution using xor"
                    },
                    {
                        "username": "Vithesh",
                        "content": "I did actually solve this problem in O(logn) time and O(1) space in like 25 min but.... i felt like something is off. I dont know what.."
                    },
                    {
                        "username": "the_coder_8297",
                        "content": "Can anyone help me, i\\'m practising problems on binary search, i\\'m not able to figure out when should i use the while loop condition as left < right and left <= right . I\\'m totally confused, by different usage in different problem.\\n\\nCan anyone share a generic template and generic way of thought process. I\\'ll be really grateful.\\nThanks in advance!"
                    },
                    {
                        "username": "Codilini",
                        "content": "Can someone please help solve this? I am getting \"list index out of range\" error for line elif nums[mid] == nums[mid+1]\n\n `       left = 0`\n`        right = len(nums)-1`\n   \n        `while(left < right):\n            mid = (left+(right-left))//2\n\n            if nums[mid] == nums[mid-1]:\n                if mid%2==0:\n                    right = mid-2\n                else:\n                    left = mid+1\n\n            elif nums[mid] == nums[mid+1]:\n                \n                if mid%2==0:\n                    left = mid+2\n                else:\n                    right = mid-1\n            \n            else:\n                return nums[mid]\n        return nums[left]`"
                    }
                ]
            },
            {
                "id": 1812158,
                "content": [
                    {
                        "username": "21tushar",
                        "content": "https://github.com/tushar21-p/LeetCode_Problems-Solution/tree/main\\nOptimized Java Solution"
                    },
                    {
                        "username": "dipteshh",
                        "content": "What is wrong in this code?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int l=0, h= n-1,m=0;\\n        while(l<=h){\\n            m=l+((h-l)/2);\\n            if(m%2 != 0){\\n                if(m-1>=0 && nums[m-1]==nums[m]) l=m+1;\\n                else h=m-1;\\n            }\\n            else{\\n                if(m+1<n && nums[m+1]!=nums[m]) h=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return nums[m];\\n    }\\n};"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "It was easier than most of the easy level ques.\\n\\nint singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize==1||nums[0]!=nums[1])\\n    return nums[0];\\n  for(int i=1;i<numsSize;i++)\\n  {\\n      if(i+1==numsSize||nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\\n      return nums[i];\\n  }\\n  return nums[0];\\n}\\n\\ni think its an O(N) complexicity,am i right?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you fin it helpful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/540.%20Single%20Element%20in%20a%20Sorted%20Array.cpp"
                    },
                    {
                        "username": "user0667jw",
                        "content": "please checkout the solution [Single element in sorted array](https://www.youtube.com/watch?v=h-zJmgQnBXU)."
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "Just a bit of simple math + unrolled recursion. Nice one. "
                    },
                    {
                        "username": "sidddhant",
                        "content": "first we have to initialize a variable taken to 0. Then we will traverse through the array and apply XOR Bitwise operation to every element of the array. the element appearing odd number of times would be returned ."
                    },
                    {
                        "username": "harshb445",
                        "content": "How this code with O(n) complexity ran sucessfully? Can anyone please explain?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int single =0;\\n        int i=0;\\n        while(i<nums.size()){\\n            single=single^nums[i];\\n            i++;\\n        }\\n        return single;\\n    }\\n}; "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Hint: If you have a pair, and the index of the second number is even, then you know the answer is lower than your current index."
                    },
                    {
                        "username": "shivam_p",
                        "content": " `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        if(nums.size() == 2) return 0;\\n        int low = 0;\\n        int high = 1;\\n        while(low <= nums.size()-1){\\n            if(nums[low] == nums[high]){\\n                high = high + 1;\\n            }\\n            else{\\n                low = high + 1;\\n                if(nums[low] != nums[high]){\\n                    return nums[high];\\n                }\\n                else{\\n                    if(high - 1 == 0 ){\\n                        return nums[0];\\n                    }\\n                  \\n                   // continue;\\n                }\\n            }\\n        }\\n        return nums[nums.size() - 1];\\n    }\\n};`\\n\\nNot A O(logN) soln. Just implementation. NO algorithms"
                    }
                ]
            },
            {
                "id": 1811157,
                "content": [
                    {
                        "username": "21tushar",
                        "content": "https://github.com/tushar21-p/LeetCode_Problems-Solution/tree/main\\nOptimized Java Solution"
                    },
                    {
                        "username": "dipteshh",
                        "content": "What is wrong in this code?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int l=0, h= n-1,m=0;\\n        while(l<=h){\\n            m=l+((h-l)/2);\\n            if(m%2 != 0){\\n                if(m-1>=0 && nums[m-1]==nums[m]) l=m+1;\\n                else h=m-1;\\n            }\\n            else{\\n                if(m+1<n && nums[m+1]!=nums[m]) h=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return nums[m];\\n    }\\n};"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "It was easier than most of the easy level ques.\\n\\nint singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize==1||nums[0]!=nums[1])\\n    return nums[0];\\n  for(int i=1;i<numsSize;i++)\\n  {\\n      if(i+1==numsSize||nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\\n      return nums[i];\\n  }\\n  return nums[0];\\n}\\n\\ni think its an O(N) complexicity,am i right?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you fin it helpful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/540.%20Single%20Element%20in%20a%20Sorted%20Array.cpp"
                    },
                    {
                        "username": "user0667jw",
                        "content": "please checkout the solution [Single element in sorted array](https://www.youtube.com/watch?v=h-zJmgQnBXU)."
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "Just a bit of simple math + unrolled recursion. Nice one. "
                    },
                    {
                        "username": "sidddhant",
                        "content": "first we have to initialize a variable taken to 0. Then we will traverse through the array and apply XOR Bitwise operation to every element of the array. the element appearing odd number of times would be returned ."
                    },
                    {
                        "username": "harshb445",
                        "content": "How this code with O(n) complexity ran sucessfully? Can anyone please explain?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int single =0;\\n        int i=0;\\n        while(i<nums.size()){\\n            single=single^nums[i];\\n            i++;\\n        }\\n        return single;\\n    }\\n}; "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Hint: If you have a pair, and the index of the second number is even, then you know the answer is lower than your current index."
                    },
                    {
                        "username": "shivam_p",
                        "content": " `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        if(nums.size() == 2) return 0;\\n        int low = 0;\\n        int high = 1;\\n        while(low <= nums.size()-1){\\n            if(nums[low] == nums[high]){\\n                high = high + 1;\\n            }\\n            else{\\n                low = high + 1;\\n                if(nums[low] != nums[high]){\\n                    return nums[high];\\n                }\\n                else{\\n                    if(high - 1 == 0 ){\\n                        return nums[0];\\n                    }\\n                  \\n                   // continue;\\n                }\\n            }\\n        }\\n        return nums[nums.size() - 1];\\n    }\\n};`\\n\\nNot A O(logN) soln. Just implementation. NO algorithms"
                    }
                ]
            },
            {
                "id": 1810979,
                "content": [
                    {
                        "username": "21tushar",
                        "content": "https://github.com/tushar21-p/LeetCode_Problems-Solution/tree/main\\nOptimized Java Solution"
                    },
                    {
                        "username": "dipteshh",
                        "content": "What is wrong in this code?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int l=0, h= n-1,m=0;\\n        while(l<=h){\\n            m=l+((h-l)/2);\\n            if(m%2 != 0){\\n                if(m-1>=0 && nums[m-1]==nums[m]) l=m+1;\\n                else h=m-1;\\n            }\\n            else{\\n                if(m+1<n && nums[m+1]!=nums[m]) h=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return nums[m];\\n    }\\n};"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "It was easier than most of the easy level ques.\\n\\nint singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize==1||nums[0]!=nums[1])\\n    return nums[0];\\n  for(int i=1;i<numsSize;i++)\\n  {\\n      if(i+1==numsSize||nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\\n      return nums[i];\\n  }\\n  return nums[0];\\n}\\n\\ni think its an O(N) complexicity,am i right?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you fin it helpful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/540.%20Single%20Element%20in%20a%20Sorted%20Array.cpp"
                    },
                    {
                        "username": "user0667jw",
                        "content": "please checkout the solution [Single element in sorted array](https://www.youtube.com/watch?v=h-zJmgQnBXU)."
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "Just a bit of simple math + unrolled recursion. Nice one. "
                    },
                    {
                        "username": "sidddhant",
                        "content": "first we have to initialize a variable taken to 0. Then we will traverse through the array and apply XOR Bitwise operation to every element of the array. the element appearing odd number of times would be returned ."
                    },
                    {
                        "username": "harshb445",
                        "content": "How this code with O(n) complexity ran sucessfully? Can anyone please explain?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int single =0;\\n        int i=0;\\n        while(i<nums.size()){\\n            single=single^nums[i];\\n            i++;\\n        }\\n        return single;\\n    }\\n}; "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Hint: If you have a pair, and the index of the second number is even, then you know the answer is lower than your current index."
                    },
                    {
                        "username": "shivam_p",
                        "content": " `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        if(nums.size() == 2) return 0;\\n        int low = 0;\\n        int high = 1;\\n        while(low <= nums.size()-1){\\n            if(nums[low] == nums[high]){\\n                high = high + 1;\\n            }\\n            else{\\n                low = high + 1;\\n                if(nums[low] != nums[high]){\\n                    return nums[high];\\n                }\\n                else{\\n                    if(high - 1 == 0 ){\\n                        return nums[0];\\n                    }\\n                  \\n                   // continue;\\n                }\\n            }\\n        }\\n        return nums[nums.size() - 1];\\n    }\\n};`\\n\\nNot A O(logN) soln. Just implementation. NO algorithms"
                    }
                ]
            },
            {
                "id": 1810394,
                "content": [
                    {
                        "username": "21tushar",
                        "content": "https://github.com/tushar21-p/LeetCode_Problems-Solution/tree/main\\nOptimized Java Solution"
                    },
                    {
                        "username": "dipteshh",
                        "content": "What is wrong in this code?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int l=0, h= n-1,m=0;\\n        while(l<=h){\\n            m=l+((h-l)/2);\\n            if(m%2 != 0){\\n                if(m-1>=0 && nums[m-1]==nums[m]) l=m+1;\\n                else h=m-1;\\n            }\\n            else{\\n                if(m+1<n && nums[m+1]!=nums[m]) h=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return nums[m];\\n    }\\n};"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "It was easier than most of the easy level ques.\\n\\nint singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize==1||nums[0]!=nums[1])\\n    return nums[0];\\n  for(int i=1;i<numsSize;i++)\\n  {\\n      if(i+1==numsSize||nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\\n      return nums[i];\\n  }\\n  return nums[0];\\n}\\n\\ni think its an O(N) complexicity,am i right?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you fin it helpful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/540.%20Single%20Element%20in%20a%20Sorted%20Array.cpp"
                    },
                    {
                        "username": "user0667jw",
                        "content": "please checkout the solution [Single element in sorted array](https://www.youtube.com/watch?v=h-zJmgQnBXU)."
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "Just a bit of simple math + unrolled recursion. Nice one. "
                    },
                    {
                        "username": "sidddhant",
                        "content": "first we have to initialize a variable taken to 0. Then we will traverse through the array and apply XOR Bitwise operation to every element of the array. the element appearing odd number of times would be returned ."
                    },
                    {
                        "username": "harshb445",
                        "content": "How this code with O(n) complexity ran sucessfully? Can anyone please explain?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int single =0;\\n        int i=0;\\n        while(i<nums.size()){\\n            single=single^nums[i];\\n            i++;\\n        }\\n        return single;\\n    }\\n}; "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Hint: If you have a pair, and the index of the second number is even, then you know the answer is lower than your current index."
                    },
                    {
                        "username": "shivam_p",
                        "content": " `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        if(nums.size() == 2) return 0;\\n        int low = 0;\\n        int high = 1;\\n        while(low <= nums.size()-1){\\n            if(nums[low] == nums[high]){\\n                high = high + 1;\\n            }\\n            else{\\n                low = high + 1;\\n                if(nums[low] != nums[high]){\\n                    return nums[high];\\n                }\\n                else{\\n                    if(high - 1 == 0 ){\\n                        return nums[0];\\n                    }\\n                  \\n                   // continue;\\n                }\\n            }\\n        }\\n        return nums[nums.size() - 1];\\n    }\\n};`\\n\\nNot A O(logN) soln. Just implementation. NO algorithms"
                    }
                ]
            },
            {
                "id": 1810354,
                "content": [
                    {
                        "username": "21tushar",
                        "content": "https://github.com/tushar21-p/LeetCode_Problems-Solution/tree/main\\nOptimized Java Solution"
                    },
                    {
                        "username": "dipteshh",
                        "content": "What is wrong in this code?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int l=0, h= n-1,m=0;\\n        while(l<=h){\\n            m=l+((h-l)/2);\\n            if(m%2 != 0){\\n                if(m-1>=0 && nums[m-1]==nums[m]) l=m+1;\\n                else h=m-1;\\n            }\\n            else{\\n                if(m+1<n && nums[m+1]!=nums[m]) h=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return nums[m];\\n    }\\n};"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "It was easier than most of the easy level ques.\\n\\nint singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize==1||nums[0]!=nums[1])\\n    return nums[0];\\n  for(int i=1;i<numsSize;i++)\\n  {\\n      if(i+1==numsSize||nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\\n      return nums[i];\\n  }\\n  return nums[0];\\n}\\n\\ni think its an O(N) complexicity,am i right?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you fin it helpful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/540.%20Single%20Element%20in%20a%20Sorted%20Array.cpp"
                    },
                    {
                        "username": "user0667jw",
                        "content": "please checkout the solution [Single element in sorted array](https://www.youtube.com/watch?v=h-zJmgQnBXU)."
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "Just a bit of simple math + unrolled recursion. Nice one. "
                    },
                    {
                        "username": "sidddhant",
                        "content": "first we have to initialize a variable taken to 0. Then we will traverse through the array and apply XOR Bitwise operation to every element of the array. the element appearing odd number of times would be returned ."
                    },
                    {
                        "username": "harshb445",
                        "content": "How this code with O(n) complexity ran sucessfully? Can anyone please explain?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int single =0;\\n        int i=0;\\n        while(i<nums.size()){\\n            single=single^nums[i];\\n            i++;\\n        }\\n        return single;\\n    }\\n}; "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Hint: If you have a pair, and the index of the second number is even, then you know the answer is lower than your current index."
                    },
                    {
                        "username": "shivam_p",
                        "content": " `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        if(nums.size() == 2) return 0;\\n        int low = 0;\\n        int high = 1;\\n        while(low <= nums.size()-1){\\n            if(nums[low] == nums[high]){\\n                high = high + 1;\\n            }\\n            else{\\n                low = high + 1;\\n                if(nums[low] != nums[high]){\\n                    return nums[high];\\n                }\\n                else{\\n                    if(high - 1 == 0 ){\\n                        return nums[0];\\n                    }\\n                  \\n                   // continue;\\n                }\\n            }\\n        }\\n        return nums[nums.size() - 1];\\n    }\\n};`\\n\\nNot A O(logN) soln. Just implementation. NO algorithms"
                    }
                ]
            },
            {
                "id": 1810011,
                "content": [
                    {
                        "username": "21tushar",
                        "content": "https://github.com/tushar21-p/LeetCode_Problems-Solution/tree/main\\nOptimized Java Solution"
                    },
                    {
                        "username": "dipteshh",
                        "content": "What is wrong in this code?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int l=0, h= n-1,m=0;\\n        while(l<=h){\\n            m=l+((h-l)/2);\\n            if(m%2 != 0){\\n                if(m-1>=0 && nums[m-1]==nums[m]) l=m+1;\\n                else h=m-1;\\n            }\\n            else{\\n                if(m+1<n && nums[m+1]!=nums[m]) h=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return nums[m];\\n    }\\n};"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "It was easier than most of the easy level ques.\\n\\nint singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize==1||nums[0]!=nums[1])\\n    return nums[0];\\n  for(int i=1;i<numsSize;i++)\\n  {\\n      if(i+1==numsSize||nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\\n      return nums[i];\\n  }\\n  return nums[0];\\n}\\n\\ni think its an O(N) complexicity,am i right?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you fin it helpful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/540.%20Single%20Element%20in%20a%20Sorted%20Array.cpp"
                    },
                    {
                        "username": "user0667jw",
                        "content": "please checkout the solution [Single element in sorted array](https://www.youtube.com/watch?v=h-zJmgQnBXU)."
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "Just a bit of simple math + unrolled recursion. Nice one. "
                    },
                    {
                        "username": "sidddhant",
                        "content": "first we have to initialize a variable taken to 0. Then we will traverse through the array and apply XOR Bitwise operation to every element of the array. the element appearing odd number of times would be returned ."
                    },
                    {
                        "username": "harshb445",
                        "content": "How this code with O(n) complexity ran sucessfully? Can anyone please explain?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int single =0;\\n        int i=0;\\n        while(i<nums.size()){\\n            single=single^nums[i];\\n            i++;\\n        }\\n        return single;\\n    }\\n}; "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Hint: If you have a pair, and the index of the second number is even, then you know the answer is lower than your current index."
                    },
                    {
                        "username": "shivam_p",
                        "content": " `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        if(nums.size() == 2) return 0;\\n        int low = 0;\\n        int high = 1;\\n        while(low <= nums.size()-1){\\n            if(nums[low] == nums[high]){\\n                high = high + 1;\\n            }\\n            else{\\n                low = high + 1;\\n                if(nums[low] != nums[high]){\\n                    return nums[high];\\n                }\\n                else{\\n                    if(high - 1 == 0 ){\\n                        return nums[0];\\n                    }\\n                  \\n                   // continue;\\n                }\\n            }\\n        }\\n        return nums[nums.size() - 1];\\n    }\\n};`\\n\\nNot A O(logN) soln. Just implementation. NO algorithms"
                    }
                ]
            },
            {
                "id": 1809965,
                "content": [
                    {
                        "username": "21tushar",
                        "content": "https://github.com/tushar21-p/LeetCode_Problems-Solution/tree/main\\nOptimized Java Solution"
                    },
                    {
                        "username": "dipteshh",
                        "content": "What is wrong in this code?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int l=0, h= n-1,m=0;\\n        while(l<=h){\\n            m=l+((h-l)/2);\\n            if(m%2 != 0){\\n                if(m-1>=0 && nums[m-1]==nums[m]) l=m+1;\\n                else h=m-1;\\n            }\\n            else{\\n                if(m+1<n && nums[m+1]!=nums[m]) h=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return nums[m];\\n    }\\n};"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "It was easier than most of the easy level ques.\\n\\nint singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize==1||nums[0]!=nums[1])\\n    return nums[0];\\n  for(int i=1;i<numsSize;i++)\\n  {\\n      if(i+1==numsSize||nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\\n      return nums[i];\\n  }\\n  return nums[0];\\n}\\n\\ni think its an O(N) complexicity,am i right?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you fin it helpful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/540.%20Single%20Element%20in%20a%20Sorted%20Array.cpp"
                    },
                    {
                        "username": "user0667jw",
                        "content": "please checkout the solution [Single element in sorted array](https://www.youtube.com/watch?v=h-zJmgQnBXU)."
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "Just a bit of simple math + unrolled recursion. Nice one. "
                    },
                    {
                        "username": "sidddhant",
                        "content": "first we have to initialize a variable taken to 0. Then we will traverse through the array and apply XOR Bitwise operation to every element of the array. the element appearing odd number of times would be returned ."
                    },
                    {
                        "username": "harshb445",
                        "content": "How this code with O(n) complexity ran sucessfully? Can anyone please explain?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int single =0;\\n        int i=0;\\n        while(i<nums.size()){\\n            single=single^nums[i];\\n            i++;\\n        }\\n        return single;\\n    }\\n}; "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Hint: If you have a pair, and the index of the second number is even, then you know the answer is lower than your current index."
                    },
                    {
                        "username": "shivam_p",
                        "content": " `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        if(nums.size() == 2) return 0;\\n        int low = 0;\\n        int high = 1;\\n        while(low <= nums.size()-1){\\n            if(nums[low] == nums[high]){\\n                high = high + 1;\\n            }\\n            else{\\n                low = high + 1;\\n                if(nums[low] != nums[high]){\\n                    return nums[high];\\n                }\\n                else{\\n                    if(high - 1 == 0 ){\\n                        return nums[0];\\n                    }\\n                  \\n                   // continue;\\n                }\\n            }\\n        }\\n        return nums[nums.size() - 1];\\n    }\\n};`\\n\\nNot A O(logN) soln. Just implementation. NO algorithms"
                    }
                ]
            },
            {
                "id": 1809895,
                "content": [
                    {
                        "username": "21tushar",
                        "content": "https://github.com/tushar21-p/LeetCode_Problems-Solution/tree/main\\nOptimized Java Solution"
                    },
                    {
                        "username": "dipteshh",
                        "content": "What is wrong in this code?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int l=0, h= n-1,m=0;\\n        while(l<=h){\\n            m=l+((h-l)/2);\\n            if(m%2 != 0){\\n                if(m-1>=0 && nums[m-1]==nums[m]) l=m+1;\\n                else h=m-1;\\n            }\\n            else{\\n                if(m+1<n && nums[m+1]!=nums[m]) h=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return nums[m];\\n    }\\n};"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "It was easier than most of the easy level ques.\\n\\nint singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize==1||nums[0]!=nums[1])\\n    return nums[0];\\n  for(int i=1;i<numsSize;i++)\\n  {\\n      if(i+1==numsSize||nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\\n      return nums[i];\\n  }\\n  return nums[0];\\n}\\n\\ni think its an O(N) complexicity,am i right?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you fin it helpful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/540.%20Single%20Element%20in%20a%20Sorted%20Array.cpp"
                    },
                    {
                        "username": "user0667jw",
                        "content": "please checkout the solution [Single element in sorted array](https://www.youtube.com/watch?v=h-zJmgQnBXU)."
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "Just a bit of simple math + unrolled recursion. Nice one. "
                    },
                    {
                        "username": "sidddhant",
                        "content": "first we have to initialize a variable taken to 0. Then we will traverse through the array and apply XOR Bitwise operation to every element of the array. the element appearing odd number of times would be returned ."
                    },
                    {
                        "username": "harshb445",
                        "content": "How this code with O(n) complexity ran sucessfully? Can anyone please explain?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int single =0;\\n        int i=0;\\n        while(i<nums.size()){\\n            single=single^nums[i];\\n            i++;\\n        }\\n        return single;\\n    }\\n}; "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Hint: If you have a pair, and the index of the second number is even, then you know the answer is lower than your current index."
                    },
                    {
                        "username": "shivam_p",
                        "content": " `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        if(nums.size() == 2) return 0;\\n        int low = 0;\\n        int high = 1;\\n        while(low <= nums.size()-1){\\n            if(nums[low] == nums[high]){\\n                high = high + 1;\\n            }\\n            else{\\n                low = high + 1;\\n                if(nums[low] != nums[high]){\\n                    return nums[high];\\n                }\\n                else{\\n                    if(high - 1 == 0 ){\\n                        return nums[0];\\n                    }\\n                  \\n                   // continue;\\n                }\\n            }\\n        }\\n        return nums[nums.size() - 1];\\n    }\\n};`\\n\\nNot A O(logN) soln. Just implementation. NO algorithms"
                    }
                ]
            },
            {
                "id": 1809880,
                "content": [
                    {
                        "username": "21tushar",
                        "content": "https://github.com/tushar21-p/LeetCode_Problems-Solution/tree/main\\nOptimized Java Solution"
                    },
                    {
                        "username": "dipteshh",
                        "content": "What is wrong in this code?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int l=0, h= n-1,m=0;\\n        while(l<=h){\\n            m=l+((h-l)/2);\\n            if(m%2 != 0){\\n                if(m-1>=0 && nums[m-1]==nums[m]) l=m+1;\\n                else h=m-1;\\n            }\\n            else{\\n                if(m+1<n && nums[m+1]!=nums[m]) h=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return nums[m];\\n    }\\n};"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "It was easier than most of the easy level ques.\\n\\nint singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize==1||nums[0]!=nums[1])\\n    return nums[0];\\n  for(int i=1;i<numsSize;i++)\\n  {\\n      if(i+1==numsSize||nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\\n      return nums[i];\\n  }\\n  return nums[0];\\n}\\n\\ni think its an O(N) complexicity,am i right?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you fin it helpful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/540.%20Single%20Element%20in%20a%20Sorted%20Array.cpp"
                    },
                    {
                        "username": "user0667jw",
                        "content": "please checkout the solution [Single element in sorted array](https://www.youtube.com/watch?v=h-zJmgQnBXU)."
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "Just a bit of simple math + unrolled recursion. Nice one. "
                    },
                    {
                        "username": "sidddhant",
                        "content": "first we have to initialize a variable taken to 0. Then we will traverse through the array and apply XOR Bitwise operation to every element of the array. the element appearing odd number of times would be returned ."
                    },
                    {
                        "username": "harshb445",
                        "content": "How this code with O(n) complexity ran sucessfully? Can anyone please explain?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int single =0;\\n        int i=0;\\n        while(i<nums.size()){\\n            single=single^nums[i];\\n            i++;\\n        }\\n        return single;\\n    }\\n}; "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Hint: If you have a pair, and the index of the second number is even, then you know the answer is lower than your current index."
                    },
                    {
                        "username": "shivam_p",
                        "content": " `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        if(nums.size() == 2) return 0;\\n        int low = 0;\\n        int high = 1;\\n        while(low <= nums.size()-1){\\n            if(nums[low] == nums[high]){\\n                high = high + 1;\\n            }\\n            else{\\n                low = high + 1;\\n                if(nums[low] != nums[high]){\\n                    return nums[high];\\n                }\\n                else{\\n                    if(high - 1 == 0 ){\\n                        return nums[0];\\n                    }\\n                  \\n                   // continue;\\n                }\\n            }\\n        }\\n        return nums[nums.size() - 1];\\n    }\\n};`\\n\\nNot A O(logN) soln. Just implementation. NO algorithms"
                    }
                ]
            },
            {
                "id": 1809872,
                "content": [
                    {
                        "username": "21tushar",
                        "content": "https://github.com/tushar21-p/LeetCode_Problems-Solution/tree/main\\nOptimized Java Solution"
                    },
                    {
                        "username": "dipteshh",
                        "content": "What is wrong in this code?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int n=nums.size();\\n        int l=0, h= n-1,m=0;\\n        while(l<=h){\\n            m=l+((h-l)/2);\\n            if(m%2 != 0){\\n                if(m-1>=0 && nums[m-1]==nums[m]) l=m+1;\\n                else h=m-1;\\n            }\\n            else{\\n                if(m+1<n && nums[m+1]!=nums[m]) h=m-1;\\n                else l=m+1;\\n            }\\n        }\\n        return nums[m];\\n    }\\n};"
                    },
                    {
                        "username": "JeevanjotSingh01",
                        "content": "It was easier than most of the easy level ques.\\n\\nint singleNonDuplicate(int* nums, int numsSize){\\n    if(numsSize==1||nums[0]!=nums[1])\\n    return nums[0];\\n  for(int i=1;i<numsSize;i++)\\n  {\\n      if(i+1==numsSize||nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\\n      return nums[i];\\n  }\\n  return nums[0];\\n}\\n\\ni think its an O(N) complexicity,am i right?"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "This repository contains ALL LEETCODE SOLUTION IN C++,\\nIf you fin it helpful PLEASE LEAVE A STAR.\\n\\nhttps://github.com/AnkushRawat10601/Leetcode/blob/main/540.%20Single%20Element%20in%20a%20Sorted%20Array.cpp"
                    },
                    {
                        "username": "user0667jw",
                        "content": "please checkout the solution [Single element in sorted array](https://www.youtube.com/watch?v=h-zJmgQnBXU)."
                    },
                    {
                        "username": "fedorgoncharov",
                        "content": "Just a bit of simple math + unrolled recursion. Nice one. "
                    },
                    {
                        "username": "sidddhant",
                        "content": "first we have to initialize a variable taken to 0. Then we will traverse through the array and apply XOR Bitwise operation to every element of the array. the element appearing odd number of times would be returned ."
                    },
                    {
                        "username": "harshb445",
                        "content": "How this code with O(n) complexity ran sucessfully? Can anyone please explain?\\n\\nclass Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int single =0;\\n        int i=0;\\n        while(i<nums.size()){\\n            single=single^nums[i];\\n            i++;\\n        }\\n        return single;\\n    }\\n}; "
                    },
                    {
                        "username": "seraphsword",
                        "content": "Hint: If you have a pair, and the index of the second number is even, then you know the answer is lower than your current index."
                    },
                    {
                        "username": "shivam_p",
                        "content": " `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size() == 1) return nums[0];\\n        if(nums.size() == 2) return 0;\\n        int low = 0;\\n        int high = 1;\\n        while(low <= nums.size()-1){\\n            if(nums[low] == nums[high]){\\n                high = high + 1;\\n            }\\n            else{\\n                low = high + 1;\\n                if(nums[low] != nums[high]){\\n                    return nums[high];\\n                }\\n                else{\\n                    if(high - 1 == 0 ){\\n                        return nums[0];\\n                    }\\n                  \\n                   // continue;\\n                }\\n            }\\n        }\\n        return nums[nums.size() - 1];\\n    }\\n};`\\n\\nNot A O(logN) soln. Just implementation. NO algorithms"
                    }
                ]
            },
            {
                "id": 1809856,
                "content": [
                    {
                        "username": "naveen_engineer",
                        "content": "bit manupiltion gain its power again \\n"
                    },
                    {
                        "username": "rri",
                        "content": "This question description is inadequate. The solution assumes repeated element next to the element itself. But it was not given in the question."
                    },
                    {
                        "username": "ohYouCan",
                        "content": "But it says sorted right, that means repeated will be next to each other."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "made it too easy, different approach, give it a try and your feedback is appreciated in comments  , THANK YOU https://youtu.be/NeBJz66GGf0"
                    },
                    {
                        "username": "aryanrstg26",
                        "content": "class Solution \\n{\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) \\n    {   int ch=0;\\n        int size=nums.size();\\n    if(size<2)\\n    return nums[0];\\n\\n    if(size%2!=0)\\n        if(nums[size-1]!=nums[size-2])\\n        return nums[size-1];\\n\\n        for(int i=0;i<nums.size()-1;)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            return nums[i];\\n            i=i+2;\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "elgatti",
                        "content": "fun fact: I once got asked this for an internship position at Meta and BOMBED it. Fun times (I eventually re-interviewed and passed, altough they did ask different questions)."
                    },
                    {
                        "username": "singh_3662",
                        "content": "The different cases which we have to consider in this question is that :-\\n1. If there is only one element in array.\\n2. If the first element of array is single element.\\n3. If the last element of array is single element.\\n4. Rest of the cases will follow the same logic i.e. middle element of array is single element.\\nHope it helps someone."
                    },
                    {
                        "username": "abhi_452000",
                        "content": "simplest in o(n) complexity\\nBy taking XOR of every element ,you will get the element with single frequenct\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "YuPengChen",
                        "content": "First thought is that we can just use binary operation (i.e., XOR) to solve this problem as long as we know:\n\n- A^A = 0\n- 0^A = A\n\nThen, we can easily come up with this:\n\n```Python\nres = 0\nfor i in nums:\n    res ^= i\nreturn res\n```\n\nSo, when I saw that there's a specific requirement for $O(log n)$ time complexity, I felt like this is testing if we know how to use binary search instead of testing our problem-solving ability, which involves identifying possible solutions and select the one that is the most suitable based on the situation. Also, the code above was still accepted. But using binary search to solve this problem is actually quite fun.\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "just check whether the mid element is on even index or odd index------>>>>\\n\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& a) {\\n        int n= a.size();\\n        int l= 0;\\n        int r= n-1;\\n\\n        if(a.size()==1) return a[0];\\n        if(a.size()==2){\\n            if(a[0]==a[1])return -1;\\n            else return a[0];\\n        }\\n\\n        if(a[0]!= a[1]){\\n            return a[0];\\n        }\\n        if(a[n-1]!= a[n-2]){\\n            return a[n-1];\\n        }\\n\\n        while(l<=r){\\n            int m= l+(r-l)/2;\\n            if(a[m]!= a[m-1] && a[m]!= a[m+1]){\\n                return a[m];\\n            }\\n            else if(m%2==0){\\n                if(a[m]!=a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n            else{\\n                if(a[m]==a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "kxcoder",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto e : nums) {\\n            mp[e]++;\\n        }\\n        for(auto e : mp) {\\n            if(e.second == 1) {\\n                ans = e.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809835,
                "content": [
                    {
                        "username": "naveen_engineer",
                        "content": "bit manupiltion gain its power again \\n"
                    },
                    {
                        "username": "rri",
                        "content": "This question description is inadequate. The solution assumes repeated element next to the element itself. But it was not given in the question."
                    },
                    {
                        "username": "ohYouCan",
                        "content": "But it says sorted right, that means repeated will be next to each other."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "made it too easy, different approach, give it a try and your feedback is appreciated in comments  , THANK YOU https://youtu.be/NeBJz66GGf0"
                    },
                    {
                        "username": "aryanrstg26",
                        "content": "class Solution \\n{\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) \\n    {   int ch=0;\\n        int size=nums.size();\\n    if(size<2)\\n    return nums[0];\\n\\n    if(size%2!=0)\\n        if(nums[size-1]!=nums[size-2])\\n        return nums[size-1];\\n\\n        for(int i=0;i<nums.size()-1;)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            return nums[i];\\n            i=i+2;\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "elgatti",
                        "content": "fun fact: I once got asked this for an internship position at Meta and BOMBED it. Fun times (I eventually re-interviewed and passed, altough they did ask different questions)."
                    },
                    {
                        "username": "singh_3662",
                        "content": "The different cases which we have to consider in this question is that :-\\n1. If there is only one element in array.\\n2. If the first element of array is single element.\\n3. If the last element of array is single element.\\n4. Rest of the cases will follow the same logic i.e. middle element of array is single element.\\nHope it helps someone."
                    },
                    {
                        "username": "abhi_452000",
                        "content": "simplest in o(n) complexity\\nBy taking XOR of every element ,you will get the element with single frequenct\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "YuPengChen",
                        "content": "First thought is that we can just use binary operation (i.e., XOR) to solve this problem as long as we know:\n\n- A^A = 0\n- 0^A = A\n\nThen, we can easily come up with this:\n\n```Python\nres = 0\nfor i in nums:\n    res ^= i\nreturn res\n```\n\nSo, when I saw that there's a specific requirement for $O(log n)$ time complexity, I felt like this is testing if we know how to use binary search instead of testing our problem-solving ability, which involves identifying possible solutions and select the one that is the most suitable based on the situation. Also, the code above was still accepted. But using binary search to solve this problem is actually quite fun.\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "just check whether the mid element is on even index or odd index------>>>>\\n\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& a) {\\n        int n= a.size();\\n        int l= 0;\\n        int r= n-1;\\n\\n        if(a.size()==1) return a[0];\\n        if(a.size()==2){\\n            if(a[0]==a[1])return -1;\\n            else return a[0];\\n        }\\n\\n        if(a[0]!= a[1]){\\n            return a[0];\\n        }\\n        if(a[n-1]!= a[n-2]){\\n            return a[n-1];\\n        }\\n\\n        while(l<=r){\\n            int m= l+(r-l)/2;\\n            if(a[m]!= a[m-1] && a[m]!= a[m+1]){\\n                return a[m];\\n            }\\n            else if(m%2==0){\\n                if(a[m]!=a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n            else{\\n                if(a[m]==a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "kxcoder",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto e : nums) {\\n            mp[e]++;\\n        }\\n        for(auto e : mp) {\\n            if(e.second == 1) {\\n                ans = e.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809825,
                "content": [
                    {
                        "username": "naveen_engineer",
                        "content": "bit manupiltion gain its power again \\n"
                    },
                    {
                        "username": "rri",
                        "content": "This question description is inadequate. The solution assumes repeated element next to the element itself. But it was not given in the question."
                    },
                    {
                        "username": "ohYouCan",
                        "content": "But it says sorted right, that means repeated will be next to each other."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "made it too easy, different approach, give it a try and your feedback is appreciated in comments  , THANK YOU https://youtu.be/NeBJz66GGf0"
                    },
                    {
                        "username": "aryanrstg26",
                        "content": "class Solution \\n{\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) \\n    {   int ch=0;\\n        int size=nums.size();\\n    if(size<2)\\n    return nums[0];\\n\\n    if(size%2!=0)\\n        if(nums[size-1]!=nums[size-2])\\n        return nums[size-1];\\n\\n        for(int i=0;i<nums.size()-1;)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            return nums[i];\\n            i=i+2;\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "elgatti",
                        "content": "fun fact: I once got asked this for an internship position at Meta and BOMBED it. Fun times (I eventually re-interviewed and passed, altough they did ask different questions)."
                    },
                    {
                        "username": "singh_3662",
                        "content": "The different cases which we have to consider in this question is that :-\\n1. If there is only one element in array.\\n2. If the first element of array is single element.\\n3. If the last element of array is single element.\\n4. Rest of the cases will follow the same logic i.e. middle element of array is single element.\\nHope it helps someone."
                    },
                    {
                        "username": "abhi_452000",
                        "content": "simplest in o(n) complexity\\nBy taking XOR of every element ,you will get the element with single frequenct\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "YuPengChen",
                        "content": "First thought is that we can just use binary operation (i.e., XOR) to solve this problem as long as we know:\n\n- A^A = 0\n- 0^A = A\n\nThen, we can easily come up with this:\n\n```Python\nres = 0\nfor i in nums:\n    res ^= i\nreturn res\n```\n\nSo, when I saw that there's a specific requirement for $O(log n)$ time complexity, I felt like this is testing if we know how to use binary search instead of testing our problem-solving ability, which involves identifying possible solutions and select the one that is the most suitable based on the situation. Also, the code above was still accepted. But using binary search to solve this problem is actually quite fun.\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "just check whether the mid element is on even index or odd index------>>>>\\n\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& a) {\\n        int n= a.size();\\n        int l= 0;\\n        int r= n-1;\\n\\n        if(a.size()==1) return a[0];\\n        if(a.size()==2){\\n            if(a[0]==a[1])return -1;\\n            else return a[0];\\n        }\\n\\n        if(a[0]!= a[1]){\\n            return a[0];\\n        }\\n        if(a[n-1]!= a[n-2]){\\n            return a[n-1];\\n        }\\n\\n        while(l<=r){\\n            int m= l+(r-l)/2;\\n            if(a[m]!= a[m-1] && a[m]!= a[m+1]){\\n                return a[m];\\n            }\\n            else if(m%2==0){\\n                if(a[m]!=a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n            else{\\n                if(a[m]==a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "kxcoder",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto e : nums) {\\n            mp[e]++;\\n        }\\n        for(auto e : mp) {\\n            if(e.second == 1) {\\n                ans = e.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809797,
                "content": [
                    {
                        "username": "naveen_engineer",
                        "content": "bit manupiltion gain its power again \\n"
                    },
                    {
                        "username": "rri",
                        "content": "This question description is inadequate. The solution assumes repeated element next to the element itself. But it was not given in the question."
                    },
                    {
                        "username": "ohYouCan",
                        "content": "But it says sorted right, that means repeated will be next to each other."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "made it too easy, different approach, give it a try and your feedback is appreciated in comments  , THANK YOU https://youtu.be/NeBJz66GGf0"
                    },
                    {
                        "username": "aryanrstg26",
                        "content": "class Solution \\n{\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) \\n    {   int ch=0;\\n        int size=nums.size();\\n    if(size<2)\\n    return nums[0];\\n\\n    if(size%2!=0)\\n        if(nums[size-1]!=nums[size-2])\\n        return nums[size-1];\\n\\n        for(int i=0;i<nums.size()-1;)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            return nums[i];\\n            i=i+2;\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "elgatti",
                        "content": "fun fact: I once got asked this for an internship position at Meta and BOMBED it. Fun times (I eventually re-interviewed and passed, altough they did ask different questions)."
                    },
                    {
                        "username": "singh_3662",
                        "content": "The different cases which we have to consider in this question is that :-\\n1. If there is only one element in array.\\n2. If the first element of array is single element.\\n3. If the last element of array is single element.\\n4. Rest of the cases will follow the same logic i.e. middle element of array is single element.\\nHope it helps someone."
                    },
                    {
                        "username": "abhi_452000",
                        "content": "simplest in o(n) complexity\\nBy taking XOR of every element ,you will get the element with single frequenct\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "YuPengChen",
                        "content": "First thought is that we can just use binary operation (i.e., XOR) to solve this problem as long as we know:\n\n- A^A = 0\n- 0^A = A\n\nThen, we can easily come up with this:\n\n```Python\nres = 0\nfor i in nums:\n    res ^= i\nreturn res\n```\n\nSo, when I saw that there's a specific requirement for $O(log n)$ time complexity, I felt like this is testing if we know how to use binary search instead of testing our problem-solving ability, which involves identifying possible solutions and select the one that is the most suitable based on the situation. Also, the code above was still accepted. But using binary search to solve this problem is actually quite fun.\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "just check whether the mid element is on even index or odd index------>>>>\\n\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& a) {\\n        int n= a.size();\\n        int l= 0;\\n        int r= n-1;\\n\\n        if(a.size()==1) return a[0];\\n        if(a.size()==2){\\n            if(a[0]==a[1])return -1;\\n            else return a[0];\\n        }\\n\\n        if(a[0]!= a[1]){\\n            return a[0];\\n        }\\n        if(a[n-1]!= a[n-2]){\\n            return a[n-1];\\n        }\\n\\n        while(l<=r){\\n            int m= l+(r-l)/2;\\n            if(a[m]!= a[m-1] && a[m]!= a[m+1]){\\n                return a[m];\\n            }\\n            else if(m%2==0){\\n                if(a[m]!=a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n            else{\\n                if(a[m]==a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "kxcoder",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto e : nums) {\\n            mp[e]++;\\n        }\\n        for(auto e : mp) {\\n            if(e.second == 1) {\\n                ans = e.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809756,
                "content": [
                    {
                        "username": "naveen_engineer",
                        "content": "bit manupiltion gain its power again \\n"
                    },
                    {
                        "username": "rri",
                        "content": "This question description is inadequate. The solution assumes repeated element next to the element itself. But it was not given in the question."
                    },
                    {
                        "username": "ohYouCan",
                        "content": "But it says sorted right, that means repeated will be next to each other."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "made it too easy, different approach, give it a try and your feedback is appreciated in comments  , THANK YOU https://youtu.be/NeBJz66GGf0"
                    },
                    {
                        "username": "aryanrstg26",
                        "content": "class Solution \\n{\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) \\n    {   int ch=0;\\n        int size=nums.size();\\n    if(size<2)\\n    return nums[0];\\n\\n    if(size%2!=0)\\n        if(nums[size-1]!=nums[size-2])\\n        return nums[size-1];\\n\\n        for(int i=0;i<nums.size()-1;)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            return nums[i];\\n            i=i+2;\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "elgatti",
                        "content": "fun fact: I once got asked this for an internship position at Meta and BOMBED it. Fun times (I eventually re-interviewed and passed, altough they did ask different questions)."
                    },
                    {
                        "username": "singh_3662",
                        "content": "The different cases which we have to consider in this question is that :-\\n1. If there is only one element in array.\\n2. If the first element of array is single element.\\n3. If the last element of array is single element.\\n4. Rest of the cases will follow the same logic i.e. middle element of array is single element.\\nHope it helps someone."
                    },
                    {
                        "username": "abhi_452000",
                        "content": "simplest in o(n) complexity\\nBy taking XOR of every element ,you will get the element with single frequenct\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "YuPengChen",
                        "content": "First thought is that we can just use binary operation (i.e., XOR) to solve this problem as long as we know:\n\n- A^A = 0\n- 0^A = A\n\nThen, we can easily come up with this:\n\n```Python\nres = 0\nfor i in nums:\n    res ^= i\nreturn res\n```\n\nSo, when I saw that there's a specific requirement for $O(log n)$ time complexity, I felt like this is testing if we know how to use binary search instead of testing our problem-solving ability, which involves identifying possible solutions and select the one that is the most suitable based on the situation. Also, the code above was still accepted. But using binary search to solve this problem is actually quite fun.\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "just check whether the mid element is on even index or odd index------>>>>\\n\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& a) {\\n        int n= a.size();\\n        int l= 0;\\n        int r= n-1;\\n\\n        if(a.size()==1) return a[0];\\n        if(a.size()==2){\\n            if(a[0]==a[1])return -1;\\n            else return a[0];\\n        }\\n\\n        if(a[0]!= a[1]){\\n            return a[0];\\n        }\\n        if(a[n-1]!= a[n-2]){\\n            return a[n-1];\\n        }\\n\\n        while(l<=r){\\n            int m= l+(r-l)/2;\\n            if(a[m]!= a[m-1] && a[m]!= a[m+1]){\\n                return a[m];\\n            }\\n            else if(m%2==0){\\n                if(a[m]!=a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n            else{\\n                if(a[m]==a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "kxcoder",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto e : nums) {\\n            mp[e]++;\\n        }\\n        for(auto e : mp) {\\n            if(e.second == 1) {\\n                ans = e.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809744,
                "content": [
                    {
                        "username": "naveen_engineer",
                        "content": "bit manupiltion gain its power again \\n"
                    },
                    {
                        "username": "rri",
                        "content": "This question description is inadequate. The solution assumes repeated element next to the element itself. But it was not given in the question."
                    },
                    {
                        "username": "ohYouCan",
                        "content": "But it says sorted right, that means repeated will be next to each other."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "made it too easy, different approach, give it a try and your feedback is appreciated in comments  , THANK YOU https://youtu.be/NeBJz66GGf0"
                    },
                    {
                        "username": "aryanrstg26",
                        "content": "class Solution \\n{\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) \\n    {   int ch=0;\\n        int size=nums.size();\\n    if(size<2)\\n    return nums[0];\\n\\n    if(size%2!=0)\\n        if(nums[size-1]!=nums[size-2])\\n        return nums[size-1];\\n\\n        for(int i=0;i<nums.size()-1;)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            return nums[i];\\n            i=i+2;\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "elgatti",
                        "content": "fun fact: I once got asked this for an internship position at Meta and BOMBED it. Fun times (I eventually re-interviewed and passed, altough they did ask different questions)."
                    },
                    {
                        "username": "singh_3662",
                        "content": "The different cases which we have to consider in this question is that :-\\n1. If there is only one element in array.\\n2. If the first element of array is single element.\\n3. If the last element of array is single element.\\n4. Rest of the cases will follow the same logic i.e. middle element of array is single element.\\nHope it helps someone."
                    },
                    {
                        "username": "abhi_452000",
                        "content": "simplest in o(n) complexity\\nBy taking XOR of every element ,you will get the element with single frequenct\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "YuPengChen",
                        "content": "First thought is that we can just use binary operation (i.e., XOR) to solve this problem as long as we know:\n\n- A^A = 0\n- 0^A = A\n\nThen, we can easily come up with this:\n\n```Python\nres = 0\nfor i in nums:\n    res ^= i\nreturn res\n```\n\nSo, when I saw that there's a specific requirement for $O(log n)$ time complexity, I felt like this is testing if we know how to use binary search instead of testing our problem-solving ability, which involves identifying possible solutions and select the one that is the most suitable based on the situation. Also, the code above was still accepted. But using binary search to solve this problem is actually quite fun.\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "just check whether the mid element is on even index or odd index------>>>>\\n\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& a) {\\n        int n= a.size();\\n        int l= 0;\\n        int r= n-1;\\n\\n        if(a.size()==1) return a[0];\\n        if(a.size()==2){\\n            if(a[0]==a[1])return -1;\\n            else return a[0];\\n        }\\n\\n        if(a[0]!= a[1]){\\n            return a[0];\\n        }\\n        if(a[n-1]!= a[n-2]){\\n            return a[n-1];\\n        }\\n\\n        while(l<=r){\\n            int m= l+(r-l)/2;\\n            if(a[m]!= a[m-1] && a[m]!= a[m+1]){\\n                return a[m];\\n            }\\n            else if(m%2==0){\\n                if(a[m]!=a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n            else{\\n                if(a[m]==a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "kxcoder",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto e : nums) {\\n            mp[e]++;\\n        }\\n        for(auto e : mp) {\\n            if(e.second == 1) {\\n                ans = e.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809600,
                "content": [
                    {
                        "username": "naveen_engineer",
                        "content": "bit manupiltion gain its power again \\n"
                    },
                    {
                        "username": "rri",
                        "content": "This question description is inadequate. The solution assumes repeated element next to the element itself. But it was not given in the question."
                    },
                    {
                        "username": "ohYouCan",
                        "content": "But it says sorted right, that means repeated will be next to each other."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "made it too easy, different approach, give it a try and your feedback is appreciated in comments  , THANK YOU https://youtu.be/NeBJz66GGf0"
                    },
                    {
                        "username": "aryanrstg26",
                        "content": "class Solution \\n{\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) \\n    {   int ch=0;\\n        int size=nums.size();\\n    if(size<2)\\n    return nums[0];\\n\\n    if(size%2!=0)\\n        if(nums[size-1]!=nums[size-2])\\n        return nums[size-1];\\n\\n        for(int i=0;i<nums.size()-1;)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            return nums[i];\\n            i=i+2;\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "elgatti",
                        "content": "fun fact: I once got asked this for an internship position at Meta and BOMBED it. Fun times (I eventually re-interviewed and passed, altough they did ask different questions)."
                    },
                    {
                        "username": "singh_3662",
                        "content": "The different cases which we have to consider in this question is that :-\\n1. If there is only one element in array.\\n2. If the first element of array is single element.\\n3. If the last element of array is single element.\\n4. Rest of the cases will follow the same logic i.e. middle element of array is single element.\\nHope it helps someone."
                    },
                    {
                        "username": "abhi_452000",
                        "content": "simplest in o(n) complexity\\nBy taking XOR of every element ,you will get the element with single frequenct\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "YuPengChen",
                        "content": "First thought is that we can just use binary operation (i.e., XOR) to solve this problem as long as we know:\n\n- A^A = 0\n- 0^A = A\n\nThen, we can easily come up with this:\n\n```Python\nres = 0\nfor i in nums:\n    res ^= i\nreturn res\n```\n\nSo, when I saw that there's a specific requirement for $O(log n)$ time complexity, I felt like this is testing if we know how to use binary search instead of testing our problem-solving ability, which involves identifying possible solutions and select the one that is the most suitable based on the situation. Also, the code above was still accepted. But using binary search to solve this problem is actually quite fun.\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "just check whether the mid element is on even index or odd index------>>>>\\n\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& a) {\\n        int n= a.size();\\n        int l= 0;\\n        int r= n-1;\\n\\n        if(a.size()==1) return a[0];\\n        if(a.size()==2){\\n            if(a[0]==a[1])return -1;\\n            else return a[0];\\n        }\\n\\n        if(a[0]!= a[1]){\\n            return a[0];\\n        }\\n        if(a[n-1]!= a[n-2]){\\n            return a[n-1];\\n        }\\n\\n        while(l<=r){\\n            int m= l+(r-l)/2;\\n            if(a[m]!= a[m-1] && a[m]!= a[m+1]){\\n                return a[m];\\n            }\\n            else if(m%2==0){\\n                if(a[m]!=a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n            else{\\n                if(a[m]==a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "kxcoder",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto e : nums) {\\n            mp[e]++;\\n        }\\n        for(auto e : mp) {\\n            if(e.second == 1) {\\n                ans = e.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809590,
                "content": [
                    {
                        "username": "naveen_engineer",
                        "content": "bit manupiltion gain its power again \\n"
                    },
                    {
                        "username": "rri",
                        "content": "This question description is inadequate. The solution assumes repeated element next to the element itself. But it was not given in the question."
                    },
                    {
                        "username": "ohYouCan",
                        "content": "But it says sorted right, that means repeated will be next to each other."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "made it too easy, different approach, give it a try and your feedback is appreciated in comments  , THANK YOU https://youtu.be/NeBJz66GGf0"
                    },
                    {
                        "username": "aryanrstg26",
                        "content": "class Solution \\n{\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) \\n    {   int ch=0;\\n        int size=nums.size();\\n    if(size<2)\\n    return nums[0];\\n\\n    if(size%2!=0)\\n        if(nums[size-1]!=nums[size-2])\\n        return nums[size-1];\\n\\n        for(int i=0;i<nums.size()-1;)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            return nums[i];\\n            i=i+2;\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "elgatti",
                        "content": "fun fact: I once got asked this for an internship position at Meta and BOMBED it. Fun times (I eventually re-interviewed and passed, altough they did ask different questions)."
                    },
                    {
                        "username": "singh_3662",
                        "content": "The different cases which we have to consider in this question is that :-\\n1. If there is only one element in array.\\n2. If the first element of array is single element.\\n3. If the last element of array is single element.\\n4. Rest of the cases will follow the same logic i.e. middle element of array is single element.\\nHope it helps someone."
                    },
                    {
                        "username": "abhi_452000",
                        "content": "simplest in o(n) complexity\\nBy taking XOR of every element ,you will get the element with single frequenct\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "YuPengChen",
                        "content": "First thought is that we can just use binary operation (i.e., XOR) to solve this problem as long as we know:\n\n- A^A = 0\n- 0^A = A\n\nThen, we can easily come up with this:\n\n```Python\nres = 0\nfor i in nums:\n    res ^= i\nreturn res\n```\n\nSo, when I saw that there's a specific requirement for $O(log n)$ time complexity, I felt like this is testing if we know how to use binary search instead of testing our problem-solving ability, which involves identifying possible solutions and select the one that is the most suitable based on the situation. Also, the code above was still accepted. But using binary search to solve this problem is actually quite fun.\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "just check whether the mid element is on even index or odd index------>>>>\\n\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& a) {\\n        int n= a.size();\\n        int l= 0;\\n        int r= n-1;\\n\\n        if(a.size()==1) return a[0];\\n        if(a.size()==2){\\n            if(a[0]==a[1])return -1;\\n            else return a[0];\\n        }\\n\\n        if(a[0]!= a[1]){\\n            return a[0];\\n        }\\n        if(a[n-1]!= a[n-2]){\\n            return a[n-1];\\n        }\\n\\n        while(l<=r){\\n            int m= l+(r-l)/2;\\n            if(a[m]!= a[m-1] && a[m]!= a[m+1]){\\n                return a[m];\\n            }\\n            else if(m%2==0){\\n                if(a[m]!=a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n            else{\\n                if(a[m]==a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "kxcoder",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto e : nums) {\\n            mp[e]++;\\n        }\\n        for(auto e : mp) {\\n            if(e.second == 1) {\\n                ans = e.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809584,
                "content": [
                    {
                        "username": "naveen_engineer",
                        "content": "bit manupiltion gain its power again \\n"
                    },
                    {
                        "username": "rri",
                        "content": "This question description is inadequate. The solution assumes repeated element next to the element itself. But it was not given in the question."
                    },
                    {
                        "username": "ohYouCan",
                        "content": "But it says sorted right, that means repeated will be next to each other."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "made it too easy, different approach, give it a try and your feedback is appreciated in comments  , THANK YOU https://youtu.be/NeBJz66GGf0"
                    },
                    {
                        "username": "aryanrstg26",
                        "content": "class Solution \\n{\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) \\n    {   int ch=0;\\n        int size=nums.size();\\n    if(size<2)\\n    return nums[0];\\n\\n    if(size%2!=0)\\n        if(nums[size-1]!=nums[size-2])\\n        return nums[size-1];\\n\\n        for(int i=0;i<nums.size()-1;)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            return nums[i];\\n            i=i+2;\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "elgatti",
                        "content": "fun fact: I once got asked this for an internship position at Meta and BOMBED it. Fun times (I eventually re-interviewed and passed, altough they did ask different questions)."
                    },
                    {
                        "username": "singh_3662",
                        "content": "The different cases which we have to consider in this question is that :-\\n1. If there is only one element in array.\\n2. If the first element of array is single element.\\n3. If the last element of array is single element.\\n4. Rest of the cases will follow the same logic i.e. middle element of array is single element.\\nHope it helps someone."
                    },
                    {
                        "username": "abhi_452000",
                        "content": "simplest in o(n) complexity\\nBy taking XOR of every element ,you will get the element with single frequenct\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "YuPengChen",
                        "content": "First thought is that we can just use binary operation (i.e., XOR) to solve this problem as long as we know:\n\n- A^A = 0\n- 0^A = A\n\nThen, we can easily come up with this:\n\n```Python\nres = 0\nfor i in nums:\n    res ^= i\nreturn res\n```\n\nSo, when I saw that there's a specific requirement for $O(log n)$ time complexity, I felt like this is testing if we know how to use binary search instead of testing our problem-solving ability, which involves identifying possible solutions and select the one that is the most suitable based on the situation. Also, the code above was still accepted. But using binary search to solve this problem is actually quite fun.\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "just check whether the mid element is on even index or odd index------>>>>\\n\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& a) {\\n        int n= a.size();\\n        int l= 0;\\n        int r= n-1;\\n\\n        if(a.size()==1) return a[0];\\n        if(a.size()==2){\\n            if(a[0]==a[1])return -1;\\n            else return a[0];\\n        }\\n\\n        if(a[0]!= a[1]){\\n            return a[0];\\n        }\\n        if(a[n-1]!= a[n-2]){\\n            return a[n-1];\\n        }\\n\\n        while(l<=r){\\n            int m= l+(r-l)/2;\\n            if(a[m]!= a[m-1] && a[m]!= a[m+1]){\\n                return a[m];\\n            }\\n            else if(m%2==0){\\n                if(a[m]!=a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n            else{\\n                if(a[m]==a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "kxcoder",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto e : nums) {\\n            mp[e]++;\\n        }\\n        for(auto e : mp) {\\n            if(e.second == 1) {\\n                ans = e.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809524,
                "content": [
                    {
                        "username": "naveen_engineer",
                        "content": "bit manupiltion gain its power again \\n"
                    },
                    {
                        "username": "rri",
                        "content": "This question description is inadequate. The solution assumes repeated element next to the element itself. But it was not given in the question."
                    },
                    {
                        "username": "ohYouCan",
                        "content": "But it says sorted right, that means repeated will be next to each other."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "made it too easy, different approach, give it a try and your feedback is appreciated in comments  , THANK YOU https://youtu.be/NeBJz66GGf0"
                    },
                    {
                        "username": "aryanrstg26",
                        "content": "class Solution \\n{\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) \\n    {   int ch=0;\\n        int size=nums.size();\\n    if(size<2)\\n    return nums[0];\\n\\n    if(size%2!=0)\\n        if(nums[size-1]!=nums[size-2])\\n        return nums[size-1];\\n\\n        for(int i=0;i<nums.size()-1;)\\n        {\\n            if(nums[i]!=nums[i+1])\\n            return nums[i];\\n            i=i+2;\\n        }\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "elgatti",
                        "content": "fun fact: I once got asked this for an internship position at Meta and BOMBED it. Fun times (I eventually re-interviewed and passed, altough they did ask different questions)."
                    },
                    {
                        "username": "singh_3662",
                        "content": "The different cases which we have to consider in this question is that :-\\n1. If there is only one element in array.\\n2. If the first element of array is single element.\\n3. If the last element of array is single element.\\n4. Rest of the cases will follow the same logic i.e. middle element of array is single element.\\nHope it helps someone."
                    },
                    {
                        "username": "abhi_452000",
                        "content": "simplest in o(n) complexity\\nBy taking XOR of every element ,you will get the element with single frequenct\\nclass Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length;i++){\\n            ans = ans^nums[i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "YuPengChen",
                        "content": "First thought is that we can just use binary operation (i.e., XOR) to solve this problem as long as we know:\n\n- A^A = 0\n- 0^A = A\n\nThen, we can easily come up with this:\n\n```Python\nres = 0\nfor i in nums:\n    res ^= i\nreturn res\n```\n\nSo, when I saw that there's a specific requirement for $O(log n)$ time complexity, I felt like this is testing if we know how to use binary search instead of testing our problem-solving ability, which involves identifying possible solutions and select the one that is the most suitable based on the situation. Also, the code above was still accepted. But using binary search to solve this problem is actually quite fun.\n"
                    },
                    {
                        "username": "looser_no_1",
                        "content": "just check whether the mid element is on even index or odd index------>>>>\\n\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& a) {\\n        int n= a.size();\\n        int l= 0;\\n        int r= n-1;\\n\\n        if(a.size()==1) return a[0];\\n        if(a.size()==2){\\n            if(a[0]==a[1])return -1;\\n            else return a[0];\\n        }\\n\\n        if(a[0]!= a[1]){\\n            return a[0];\\n        }\\n        if(a[n-1]!= a[n-2]){\\n            return a[n-1];\\n        }\\n\\n        while(l<=r){\\n            int m= l+(r-l)/2;\\n            if(a[m]!= a[m-1] && a[m]!= a[m+1]){\\n                return a[m];\\n            }\\n            else if(m%2==0){\\n                if(a[m]!=a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n            else{\\n                if(a[m]==a[m-1]){\\n                    l= m+1;\\n                }\\n                else{\\n                    r= m-1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "kxcoder",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        unordered_map<int, int> mp;\\n        int ans = 0;\\n        for(auto e : nums) {\\n            mp[e]++;\\n        }\\n        for(auto e : mp) {\\n            if(e.second == 1) {\\n                ans = e.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1809504,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "I feel like the O( log(n) ) description is really throwing - I just searched every other index and if there\\u2019s a pair that don\\u2019t match, then terminate early"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution using Two  methods . \\n1st O(N) time and O(1) space .  https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3214036/c-easy-and-simple-solution-o-n-time/\\n\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "shivanshu03pal",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int curr_xor=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr_xor=curr_xor^nums[i];\\n        }\\n        return curr_xor;\\n    }\\n};// we can also do it using xor logic"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "by using xor can slove this problem in very simple way  worst case time complexity : o(n)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It is explicitly stated that you should sole it in O(log(n))"
                    },
                    {
                        "username": "ajay2305",
                        "content": "its a binary search week IG"
                    },
                    {
                        "username": "user5326v",
                        "content": "Java code with 0 ms code with 48 memory.  \nThe approach for the given question is :- \n1) check if length of array is 1. If condition is true, return nums[0]\n2) check if nums[0]!=nums[length-1] so return nums[0]\n3)check if nums[length-2]!=nums[length-1]\n4) run loop and a condition will arise if when nums[i-1]!=nums[i]and nums[i]!=nums[i+1] which quoted that it is single element.\n\n\nclass Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int a=0;\n        if(nums.length==1)\n        return nums[0];\n        if(nums[0]!=nums[1])\n        return nums[0];\n        if(nums[nums.length-2]!=nums[nums.length-1])\n        return nums[nums.length-1];\n        for(int i=0;i<nums.length-1;i++)\n        {\n            if(i!=0&&nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\n            {a=nums[i];\n             break;\n            }\n        }\nreturn a;\n    }\n}"
                    },
                    {
                        "username": "user0667jw",
                        "content": "I consider it an easy one."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Question was easy but its about the time complexity in which we are going to solve this."
                    },
                    {
                        "username": "vivekparri",
                        "content": "how to build logic"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really liked this problem, the observation that we have to do this question was quite good."
                    }
                ]
            },
            {
                "id": 1809483,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "I feel like the O( log(n) ) description is really throwing - I just searched every other index and if there\\u2019s a pair that don\\u2019t match, then terminate early"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution using Two  methods . \\n1st O(N) time and O(1) space .  https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3214036/c-easy-and-simple-solution-o-n-time/\\n\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "shivanshu03pal",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int curr_xor=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr_xor=curr_xor^nums[i];\\n        }\\n        return curr_xor;\\n    }\\n};// we can also do it using xor logic"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "by using xor can slove this problem in very simple way  worst case time complexity : o(n)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It is explicitly stated that you should sole it in O(log(n))"
                    },
                    {
                        "username": "ajay2305",
                        "content": "its a binary search week IG"
                    },
                    {
                        "username": "user5326v",
                        "content": "Java code with 0 ms code with 48 memory.  \nThe approach for the given question is :- \n1) check if length of array is 1. If condition is true, return nums[0]\n2) check if nums[0]!=nums[length-1] so return nums[0]\n3)check if nums[length-2]!=nums[length-1]\n4) run loop and a condition will arise if when nums[i-1]!=nums[i]and nums[i]!=nums[i+1] which quoted that it is single element.\n\n\nclass Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int a=0;\n        if(nums.length==1)\n        return nums[0];\n        if(nums[0]!=nums[1])\n        return nums[0];\n        if(nums[nums.length-2]!=nums[nums.length-1])\n        return nums[nums.length-1];\n        for(int i=0;i<nums.length-1;i++)\n        {\n            if(i!=0&&nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\n            {a=nums[i];\n             break;\n            }\n        }\nreturn a;\n    }\n}"
                    },
                    {
                        "username": "user0667jw",
                        "content": "I consider it an easy one."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Question was easy but its about the time complexity in which we are going to solve this."
                    },
                    {
                        "username": "vivekparri",
                        "content": "how to build logic"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really liked this problem, the observation that we have to do this question was quite good."
                    }
                ]
            },
            {
                "id": 1809458,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "I feel like the O( log(n) ) description is really throwing - I just searched every other index and if there\\u2019s a pair that don\\u2019t match, then terminate early"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution using Two  methods . \\n1st O(N) time and O(1) space .  https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3214036/c-easy-and-simple-solution-o-n-time/\\n\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "shivanshu03pal",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int curr_xor=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr_xor=curr_xor^nums[i];\\n        }\\n        return curr_xor;\\n    }\\n};// we can also do it using xor logic"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "by using xor can slove this problem in very simple way  worst case time complexity : o(n)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It is explicitly stated that you should sole it in O(log(n))"
                    },
                    {
                        "username": "ajay2305",
                        "content": "its a binary search week IG"
                    },
                    {
                        "username": "user5326v",
                        "content": "Java code with 0 ms code with 48 memory.  \nThe approach for the given question is :- \n1) check if length of array is 1. If condition is true, return nums[0]\n2) check if nums[0]!=nums[length-1] so return nums[0]\n3)check if nums[length-2]!=nums[length-1]\n4) run loop and a condition will arise if when nums[i-1]!=nums[i]and nums[i]!=nums[i+1] which quoted that it is single element.\n\n\nclass Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int a=0;\n        if(nums.length==1)\n        return nums[0];\n        if(nums[0]!=nums[1])\n        return nums[0];\n        if(nums[nums.length-2]!=nums[nums.length-1])\n        return nums[nums.length-1];\n        for(int i=0;i<nums.length-1;i++)\n        {\n            if(i!=0&&nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\n            {a=nums[i];\n             break;\n            }\n        }\nreturn a;\n    }\n}"
                    },
                    {
                        "username": "user0667jw",
                        "content": "I consider it an easy one."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Question was easy but its about the time complexity in which we are going to solve this."
                    },
                    {
                        "username": "vivekparri",
                        "content": "how to build logic"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really liked this problem, the observation that we have to do this question was quite good."
                    }
                ]
            },
            {
                "id": 1809451,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "I feel like the O( log(n) ) description is really throwing - I just searched every other index and if there\\u2019s a pair that don\\u2019t match, then terminate early"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution using Two  methods . \\n1st O(N) time and O(1) space .  https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3214036/c-easy-and-simple-solution-o-n-time/\\n\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "shivanshu03pal",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int curr_xor=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr_xor=curr_xor^nums[i];\\n        }\\n        return curr_xor;\\n    }\\n};// we can also do it using xor logic"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "by using xor can slove this problem in very simple way  worst case time complexity : o(n)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It is explicitly stated that you should sole it in O(log(n))"
                    },
                    {
                        "username": "ajay2305",
                        "content": "its a binary search week IG"
                    },
                    {
                        "username": "user5326v",
                        "content": "Java code with 0 ms code with 48 memory.  \nThe approach for the given question is :- \n1) check if length of array is 1. If condition is true, return nums[0]\n2) check if nums[0]!=nums[length-1] so return nums[0]\n3)check if nums[length-2]!=nums[length-1]\n4) run loop and a condition will arise if when nums[i-1]!=nums[i]and nums[i]!=nums[i+1] which quoted that it is single element.\n\n\nclass Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int a=0;\n        if(nums.length==1)\n        return nums[0];\n        if(nums[0]!=nums[1])\n        return nums[0];\n        if(nums[nums.length-2]!=nums[nums.length-1])\n        return nums[nums.length-1];\n        for(int i=0;i<nums.length-1;i++)\n        {\n            if(i!=0&&nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\n            {a=nums[i];\n             break;\n            }\n        }\nreturn a;\n    }\n}"
                    },
                    {
                        "username": "user0667jw",
                        "content": "I consider it an easy one."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Question was easy but its about the time complexity in which we are going to solve this."
                    },
                    {
                        "username": "vivekparri",
                        "content": "how to build logic"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really liked this problem, the observation that we have to do this question was quite good."
                    }
                ]
            },
            {
                "id": 1809418,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "I feel like the O( log(n) ) description is really throwing - I just searched every other index and if there\\u2019s a pair that don\\u2019t match, then terminate early"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution using Two  methods . \\n1st O(N) time and O(1) space .  https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3214036/c-easy-and-simple-solution-o-n-time/\\n\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "shivanshu03pal",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int curr_xor=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr_xor=curr_xor^nums[i];\\n        }\\n        return curr_xor;\\n    }\\n};// we can also do it using xor logic"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "by using xor can slove this problem in very simple way  worst case time complexity : o(n)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It is explicitly stated that you should sole it in O(log(n))"
                    },
                    {
                        "username": "ajay2305",
                        "content": "its a binary search week IG"
                    },
                    {
                        "username": "user5326v",
                        "content": "Java code with 0 ms code with 48 memory.  \nThe approach for the given question is :- \n1) check if length of array is 1. If condition is true, return nums[0]\n2) check if nums[0]!=nums[length-1] so return nums[0]\n3)check if nums[length-2]!=nums[length-1]\n4) run loop and a condition will arise if when nums[i-1]!=nums[i]and nums[i]!=nums[i+1] which quoted that it is single element.\n\n\nclass Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int a=0;\n        if(nums.length==1)\n        return nums[0];\n        if(nums[0]!=nums[1])\n        return nums[0];\n        if(nums[nums.length-2]!=nums[nums.length-1])\n        return nums[nums.length-1];\n        for(int i=0;i<nums.length-1;i++)\n        {\n            if(i!=0&&nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\n            {a=nums[i];\n             break;\n            }\n        }\nreturn a;\n    }\n}"
                    },
                    {
                        "username": "user0667jw",
                        "content": "I consider it an easy one."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Question was easy but its about the time complexity in which we are going to solve this."
                    },
                    {
                        "username": "vivekparri",
                        "content": "how to build logic"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really liked this problem, the observation that we have to do this question was quite good."
                    }
                ]
            },
            {
                "id": 1809413,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "I feel like the O( log(n) ) description is really throwing - I just searched every other index and if there\\u2019s a pair that don\\u2019t match, then terminate early"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution using Two  methods . \\n1st O(N) time and O(1) space .  https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3214036/c-easy-and-simple-solution-o-n-time/\\n\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "shivanshu03pal",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int curr_xor=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr_xor=curr_xor^nums[i];\\n        }\\n        return curr_xor;\\n    }\\n};// we can also do it using xor logic"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "by using xor can slove this problem in very simple way  worst case time complexity : o(n)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It is explicitly stated that you should sole it in O(log(n))"
                    },
                    {
                        "username": "ajay2305",
                        "content": "its a binary search week IG"
                    },
                    {
                        "username": "user5326v",
                        "content": "Java code with 0 ms code with 48 memory.  \nThe approach for the given question is :- \n1) check if length of array is 1. If condition is true, return nums[0]\n2) check if nums[0]!=nums[length-1] so return nums[0]\n3)check if nums[length-2]!=nums[length-1]\n4) run loop and a condition will arise if when nums[i-1]!=nums[i]and nums[i]!=nums[i+1] which quoted that it is single element.\n\n\nclass Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int a=0;\n        if(nums.length==1)\n        return nums[0];\n        if(nums[0]!=nums[1])\n        return nums[0];\n        if(nums[nums.length-2]!=nums[nums.length-1])\n        return nums[nums.length-1];\n        for(int i=0;i<nums.length-1;i++)\n        {\n            if(i!=0&&nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\n            {a=nums[i];\n             break;\n            }\n        }\nreturn a;\n    }\n}"
                    },
                    {
                        "username": "user0667jw",
                        "content": "I consider it an easy one."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Question was easy but its about the time complexity in which we are going to solve this."
                    },
                    {
                        "username": "vivekparri",
                        "content": "how to build logic"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really liked this problem, the observation that we have to do this question was quite good."
                    }
                ]
            },
            {
                "id": 1809408,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "I feel like the O( log(n) ) description is really throwing - I just searched every other index and if there\\u2019s a pair that don\\u2019t match, then terminate early"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution using Two  methods . \\n1st O(N) time and O(1) space .  https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3214036/c-easy-and-simple-solution-o-n-time/\\n\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "shivanshu03pal",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int curr_xor=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr_xor=curr_xor^nums[i];\\n        }\\n        return curr_xor;\\n    }\\n};// we can also do it using xor logic"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "by using xor can slove this problem in very simple way  worst case time complexity : o(n)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It is explicitly stated that you should sole it in O(log(n))"
                    },
                    {
                        "username": "ajay2305",
                        "content": "its a binary search week IG"
                    },
                    {
                        "username": "user5326v",
                        "content": "Java code with 0 ms code with 48 memory.  \nThe approach for the given question is :- \n1) check if length of array is 1. If condition is true, return nums[0]\n2) check if nums[0]!=nums[length-1] so return nums[0]\n3)check if nums[length-2]!=nums[length-1]\n4) run loop and a condition will arise if when nums[i-1]!=nums[i]and nums[i]!=nums[i+1] which quoted that it is single element.\n\n\nclass Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int a=0;\n        if(nums.length==1)\n        return nums[0];\n        if(nums[0]!=nums[1])\n        return nums[0];\n        if(nums[nums.length-2]!=nums[nums.length-1])\n        return nums[nums.length-1];\n        for(int i=0;i<nums.length-1;i++)\n        {\n            if(i!=0&&nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\n            {a=nums[i];\n             break;\n            }\n        }\nreturn a;\n    }\n}"
                    },
                    {
                        "username": "user0667jw",
                        "content": "I consider it an easy one."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Question was easy but its about the time complexity in which we are going to solve this."
                    },
                    {
                        "username": "vivekparri",
                        "content": "how to build logic"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really liked this problem, the observation that we have to do this question was quite good."
                    }
                ]
            },
            {
                "id": 1809406,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "I feel like the O( log(n) ) description is really throwing - I just searched every other index and if there\\u2019s a pair that don\\u2019t match, then terminate early"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution using Two  methods . \\n1st O(N) time and O(1) space .  https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3214036/c-easy-and-simple-solution-o-n-time/\\n\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "shivanshu03pal",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int curr_xor=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr_xor=curr_xor^nums[i];\\n        }\\n        return curr_xor;\\n    }\\n};// we can also do it using xor logic"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "by using xor can slove this problem in very simple way  worst case time complexity : o(n)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It is explicitly stated that you should sole it in O(log(n))"
                    },
                    {
                        "username": "ajay2305",
                        "content": "its a binary search week IG"
                    },
                    {
                        "username": "user5326v",
                        "content": "Java code with 0 ms code with 48 memory.  \nThe approach for the given question is :- \n1) check if length of array is 1. If condition is true, return nums[0]\n2) check if nums[0]!=nums[length-1] so return nums[0]\n3)check if nums[length-2]!=nums[length-1]\n4) run loop and a condition will arise if when nums[i-1]!=nums[i]and nums[i]!=nums[i+1] which quoted that it is single element.\n\n\nclass Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int a=0;\n        if(nums.length==1)\n        return nums[0];\n        if(nums[0]!=nums[1])\n        return nums[0];\n        if(nums[nums.length-2]!=nums[nums.length-1])\n        return nums[nums.length-1];\n        for(int i=0;i<nums.length-1;i++)\n        {\n            if(i!=0&&nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\n            {a=nums[i];\n             break;\n            }\n        }\nreturn a;\n    }\n}"
                    },
                    {
                        "username": "user0667jw",
                        "content": "I consider it an easy one."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Question was easy but its about the time complexity in which we are going to solve this."
                    },
                    {
                        "username": "vivekparri",
                        "content": "how to build logic"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really liked this problem, the observation that we have to do this question was quite good."
                    }
                ]
            },
            {
                "id": 1809404,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "I feel like the O( log(n) ) description is really throwing - I just searched every other index and if there\\u2019s a pair that don\\u2019t match, then terminate early"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution using Two  methods . \\n1st O(N) time and O(1) space .  https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3214036/c-easy-and-simple-solution-o-n-time/\\n\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "shivanshu03pal",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int curr_xor=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr_xor=curr_xor^nums[i];\\n        }\\n        return curr_xor;\\n    }\\n};// we can also do it using xor logic"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "by using xor can slove this problem in very simple way  worst case time complexity : o(n)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It is explicitly stated that you should sole it in O(log(n))"
                    },
                    {
                        "username": "ajay2305",
                        "content": "its a binary search week IG"
                    },
                    {
                        "username": "user5326v",
                        "content": "Java code with 0 ms code with 48 memory.  \nThe approach for the given question is :- \n1) check if length of array is 1. If condition is true, return nums[0]\n2) check if nums[0]!=nums[length-1] so return nums[0]\n3)check if nums[length-2]!=nums[length-1]\n4) run loop and a condition will arise if when nums[i-1]!=nums[i]and nums[i]!=nums[i+1] which quoted that it is single element.\n\n\nclass Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int a=0;\n        if(nums.length==1)\n        return nums[0];\n        if(nums[0]!=nums[1])\n        return nums[0];\n        if(nums[nums.length-2]!=nums[nums.length-1])\n        return nums[nums.length-1];\n        for(int i=0;i<nums.length-1;i++)\n        {\n            if(i!=0&&nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\n            {a=nums[i];\n             break;\n            }\n        }\nreturn a;\n    }\n}"
                    },
                    {
                        "username": "user0667jw",
                        "content": "I consider it an easy one."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Question was easy but its about the time complexity in which we are going to solve this."
                    },
                    {
                        "username": "vivekparri",
                        "content": "how to build logic"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really liked this problem, the observation that we have to do this question was quite good."
                    }
                ]
            },
            {
                "id": 1809360,
                "content": [
                    {
                        "username": "charlieanthony",
                        "content": "I feel like the O( log(n) ) description is really throwing - I just searched every other index and if there\\u2019s a pair that don\\u2019t match, then terminate early"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution using Two  methods . \\n1st O(N) time and O(1) space .  https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3214036/c-easy-and-simple-solution-o-n-time/\\n\\nDon\\'t forgot to upvote it . "
                    },
                    {
                        "username": "shivanshu03pal",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int curr_xor=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            curr_xor=curr_xor^nums[i];\\n        }\\n        return curr_xor;\\n    }\\n};// we can also do it using xor logic"
                    },
                    {
                        "username": "HumbleFool22",
                        "content": "by using xor can slove this problem in very simple way  worst case time complexity : o(n)"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It is explicitly stated that you should sole it in O(log(n))"
                    },
                    {
                        "username": "ajay2305",
                        "content": "its a binary search week IG"
                    },
                    {
                        "username": "user5326v",
                        "content": "Java code with 0 ms code with 48 memory.  \nThe approach for the given question is :- \n1) check if length of array is 1. If condition is true, return nums[0]\n2) check if nums[0]!=nums[length-1] so return nums[0]\n3)check if nums[length-2]!=nums[length-1]\n4) run loop and a condition will arise if when nums[i-1]!=nums[i]and nums[i]!=nums[i+1] which quoted that it is single element.\n\n\nclass Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int a=0;\n        if(nums.length==1)\n        return nums[0];\n        if(nums[0]!=nums[1])\n        return nums[0];\n        if(nums[nums.length-2]!=nums[nums.length-1])\n        return nums[nums.length-1];\n        for(int i=0;i<nums.length-1;i++)\n        {\n            if(i!=0&&nums[i]!=nums[i-1]&&nums[i]!=nums[i+1])\n            {a=nums[i];\n             break;\n            }\n        }\nreturn a;\n    }\n}"
                    },
                    {
                        "username": "user0667jw",
                        "content": "I consider it an easy one."
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Question was easy but its about the time complexity in which we are going to solve this."
                    },
                    {
                        "username": "vivekparri",
                        "content": "how to build logic"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I really liked this problem, the observation that we have to do this question was quite good."
                    }
                ]
            },
            {
                "id": 1809354,
                "content": [
                    {
                        "username": "nguyenhuunghia99",
                        "content": "Testcase is not exclude brute force method, where it take complexity of O(n) !"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "We don\\'t even need the sorted array, we just same elements to be together ig "
                    },
                    {
                        "username": "_aman_gupta_",
                        "content": "A xor A = 0\\nA xor 0 = A\\nIs there a way to use this property of xor in this question?"
                    },
                    {
                        "username": "mchim",
                        "content": "Hint 1: Observe the index position. Find pattern for positions of duplicate elements.\\nHint 2: What will happen to index position if single element is inserted in the array?\\nHint 3: Apply Binary Search."
                    },
                    {
                        "username": "MayankBhadaraka",
                        "content": "def singleNonDuplicate(self, nums):\\n        ans=0\\n        for x in nums:\\n            ans=ans^x\\n        return ans"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "cant think binary search without some sort of notion related to \\'target\\' element \\uD83D\\uDE16"
                    },
                    {
                        "username": "amaan7",
                        "content": "observe the indexes before and after the single element which one is even which one is odd , you\\'ll get your answer !!"
                    },
                    {
                        "username": "avni_lee",
                        "content": "This problem could be solved by doing the ex-or(^) of all the elements of the vector, but it will take O(n) time. \\nWe need to solve this using Binary Search in order to reduce the time complexity to O(log N)."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use left and right pointers approach, check its adjacent elements, if both elements are different return its value. During each iteration increase left pointer value by 2 and decrease right pointer value by 2. ( Travel only half of the length )"
                    },
                    {
                        "username": "akshitagupta15june",
                        "content": "array is sorted so logn time binary search is sufficient to calculate"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "We Just Have to maintain the even pair on left and right side of the mid .\\nBased on that we can get correct output"
                    }
                ]
            },
            {
                "id": 1809342,
                "content": [
                    {
                        "username": "nguyenhuunghia99",
                        "content": "Testcase is not exclude brute force method, where it take complexity of O(n) !"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "We don\\'t even need the sorted array, we just same elements to be together ig "
                    },
                    {
                        "username": "_aman_gupta_",
                        "content": "A xor A = 0\\nA xor 0 = A\\nIs there a way to use this property of xor in this question?"
                    },
                    {
                        "username": "mchim",
                        "content": "Hint 1: Observe the index position. Find pattern for positions of duplicate elements.\\nHint 2: What will happen to index position if single element is inserted in the array?\\nHint 3: Apply Binary Search."
                    },
                    {
                        "username": "MayankBhadaraka",
                        "content": "def singleNonDuplicate(self, nums):\\n        ans=0\\n        for x in nums:\\n            ans=ans^x\\n        return ans"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "cant think binary search without some sort of notion related to \\'target\\' element \\uD83D\\uDE16"
                    },
                    {
                        "username": "amaan7",
                        "content": "observe the indexes before and after the single element which one is even which one is odd , you\\'ll get your answer !!"
                    },
                    {
                        "username": "avni_lee",
                        "content": "This problem could be solved by doing the ex-or(^) of all the elements of the vector, but it will take O(n) time. \\nWe need to solve this using Binary Search in order to reduce the time complexity to O(log N)."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use left and right pointers approach, check its adjacent elements, if both elements are different return its value. During each iteration increase left pointer value by 2 and decrease right pointer value by 2. ( Travel only half of the length )"
                    },
                    {
                        "username": "akshitagupta15june",
                        "content": "array is sorted so logn time binary search is sufficient to calculate"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "We Just Have to maintain the even pair on left and right side of the mid .\\nBased on that we can get correct output"
                    }
                ]
            },
            {
                "id": 1809331,
                "content": [
                    {
                        "username": "nguyenhuunghia99",
                        "content": "Testcase is not exclude brute force method, where it take complexity of O(n) !"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "We don\\'t even need the sorted array, we just same elements to be together ig "
                    },
                    {
                        "username": "_aman_gupta_",
                        "content": "A xor A = 0\\nA xor 0 = A\\nIs there a way to use this property of xor in this question?"
                    },
                    {
                        "username": "mchim",
                        "content": "Hint 1: Observe the index position. Find pattern for positions of duplicate elements.\\nHint 2: What will happen to index position if single element is inserted in the array?\\nHint 3: Apply Binary Search."
                    },
                    {
                        "username": "MayankBhadaraka",
                        "content": "def singleNonDuplicate(self, nums):\\n        ans=0\\n        for x in nums:\\n            ans=ans^x\\n        return ans"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "cant think binary search without some sort of notion related to \\'target\\' element \\uD83D\\uDE16"
                    },
                    {
                        "username": "amaan7",
                        "content": "observe the indexes before and after the single element which one is even which one is odd , you\\'ll get your answer !!"
                    },
                    {
                        "username": "avni_lee",
                        "content": "This problem could be solved by doing the ex-or(^) of all the elements of the vector, but it will take O(n) time. \\nWe need to solve this using Binary Search in order to reduce the time complexity to O(log N)."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use left and right pointers approach, check its adjacent elements, if both elements are different return its value. During each iteration increase left pointer value by 2 and decrease right pointer value by 2. ( Travel only half of the length )"
                    },
                    {
                        "username": "akshitagupta15june",
                        "content": "array is sorted so logn time binary search is sufficient to calculate"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "We Just Have to maintain the even pair on left and right side of the mid .\\nBased on that we can get correct output"
                    }
                ]
            },
            {
                "id": 1809311,
                "content": [
                    {
                        "username": "nguyenhuunghia99",
                        "content": "Testcase is not exclude brute force method, where it take complexity of O(n) !"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "We don\\'t even need the sorted array, we just same elements to be together ig "
                    },
                    {
                        "username": "_aman_gupta_",
                        "content": "A xor A = 0\\nA xor 0 = A\\nIs there a way to use this property of xor in this question?"
                    },
                    {
                        "username": "mchim",
                        "content": "Hint 1: Observe the index position. Find pattern for positions of duplicate elements.\\nHint 2: What will happen to index position if single element is inserted in the array?\\nHint 3: Apply Binary Search."
                    },
                    {
                        "username": "MayankBhadaraka",
                        "content": "def singleNonDuplicate(self, nums):\\n        ans=0\\n        for x in nums:\\n            ans=ans^x\\n        return ans"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "cant think binary search without some sort of notion related to \\'target\\' element \\uD83D\\uDE16"
                    },
                    {
                        "username": "amaan7",
                        "content": "observe the indexes before and after the single element which one is even which one is odd , you\\'ll get your answer !!"
                    },
                    {
                        "username": "avni_lee",
                        "content": "This problem could be solved by doing the ex-or(^) of all the elements of the vector, but it will take O(n) time. \\nWe need to solve this using Binary Search in order to reduce the time complexity to O(log N)."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use left and right pointers approach, check its adjacent elements, if both elements are different return its value. During each iteration increase left pointer value by 2 and decrease right pointer value by 2. ( Travel only half of the length )"
                    },
                    {
                        "username": "akshitagupta15june",
                        "content": "array is sorted so logn time binary search is sufficient to calculate"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "We Just Have to maintain the even pair on left and right side of the mid .\\nBased on that we can get correct output"
                    }
                ]
            },
            {
                "id": 1809283,
                "content": [
                    {
                        "username": "nguyenhuunghia99",
                        "content": "Testcase is not exclude brute force method, where it take complexity of O(n) !"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "We don\\'t even need the sorted array, we just same elements to be together ig "
                    },
                    {
                        "username": "_aman_gupta_",
                        "content": "A xor A = 0\\nA xor 0 = A\\nIs there a way to use this property of xor in this question?"
                    },
                    {
                        "username": "mchim",
                        "content": "Hint 1: Observe the index position. Find pattern for positions of duplicate elements.\\nHint 2: What will happen to index position if single element is inserted in the array?\\nHint 3: Apply Binary Search."
                    },
                    {
                        "username": "MayankBhadaraka",
                        "content": "def singleNonDuplicate(self, nums):\\n        ans=0\\n        for x in nums:\\n            ans=ans^x\\n        return ans"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "cant think binary search without some sort of notion related to \\'target\\' element \\uD83D\\uDE16"
                    },
                    {
                        "username": "amaan7",
                        "content": "observe the indexes before and after the single element which one is even which one is odd , you\\'ll get your answer !!"
                    },
                    {
                        "username": "avni_lee",
                        "content": "This problem could be solved by doing the ex-or(^) of all the elements of the vector, but it will take O(n) time. \\nWe need to solve this using Binary Search in order to reduce the time complexity to O(log N)."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use left and right pointers approach, check its adjacent elements, if both elements are different return its value. During each iteration increase left pointer value by 2 and decrease right pointer value by 2. ( Travel only half of the length )"
                    },
                    {
                        "username": "akshitagupta15june",
                        "content": "array is sorted so logn time binary search is sufficient to calculate"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "We Just Have to maintain the even pair on left and right side of the mid .\\nBased on that we can get correct output"
                    }
                ]
            },
            {
                "id": 1809227,
                "content": [
                    {
                        "username": "nguyenhuunghia99",
                        "content": "Testcase is not exclude brute force method, where it take complexity of O(n) !"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "We don\\'t even need the sorted array, we just same elements to be together ig "
                    },
                    {
                        "username": "_aman_gupta_",
                        "content": "A xor A = 0\\nA xor 0 = A\\nIs there a way to use this property of xor in this question?"
                    },
                    {
                        "username": "mchim",
                        "content": "Hint 1: Observe the index position. Find pattern for positions of duplicate elements.\\nHint 2: What will happen to index position if single element is inserted in the array?\\nHint 3: Apply Binary Search."
                    },
                    {
                        "username": "MayankBhadaraka",
                        "content": "def singleNonDuplicate(self, nums):\\n        ans=0\\n        for x in nums:\\n            ans=ans^x\\n        return ans"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "cant think binary search without some sort of notion related to \\'target\\' element \\uD83D\\uDE16"
                    },
                    {
                        "username": "amaan7",
                        "content": "observe the indexes before and after the single element which one is even which one is odd , you\\'ll get your answer !!"
                    },
                    {
                        "username": "avni_lee",
                        "content": "This problem could be solved by doing the ex-or(^) of all the elements of the vector, but it will take O(n) time. \\nWe need to solve this using Binary Search in order to reduce the time complexity to O(log N)."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use left and right pointers approach, check its adjacent elements, if both elements are different return its value. During each iteration increase left pointer value by 2 and decrease right pointer value by 2. ( Travel only half of the length )"
                    },
                    {
                        "username": "akshitagupta15june",
                        "content": "array is sorted so logn time binary search is sufficient to calculate"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "We Just Have to maintain the even pair on left and right side of the mid .\\nBased on that we can get correct output"
                    }
                ]
            },
            {
                "id": 1809223,
                "content": [
                    {
                        "username": "nguyenhuunghia99",
                        "content": "Testcase is not exclude brute force method, where it take complexity of O(n) !"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "We don\\'t even need the sorted array, we just same elements to be together ig "
                    },
                    {
                        "username": "_aman_gupta_",
                        "content": "A xor A = 0\\nA xor 0 = A\\nIs there a way to use this property of xor in this question?"
                    },
                    {
                        "username": "mchim",
                        "content": "Hint 1: Observe the index position. Find pattern for positions of duplicate elements.\\nHint 2: What will happen to index position if single element is inserted in the array?\\nHint 3: Apply Binary Search."
                    },
                    {
                        "username": "MayankBhadaraka",
                        "content": "def singleNonDuplicate(self, nums):\\n        ans=0\\n        for x in nums:\\n            ans=ans^x\\n        return ans"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "cant think binary search without some sort of notion related to \\'target\\' element \\uD83D\\uDE16"
                    },
                    {
                        "username": "amaan7",
                        "content": "observe the indexes before and after the single element which one is even which one is odd , you\\'ll get your answer !!"
                    },
                    {
                        "username": "avni_lee",
                        "content": "This problem could be solved by doing the ex-or(^) of all the elements of the vector, but it will take O(n) time. \\nWe need to solve this using Binary Search in order to reduce the time complexity to O(log N)."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use left and right pointers approach, check its adjacent elements, if both elements are different return its value. During each iteration increase left pointer value by 2 and decrease right pointer value by 2. ( Travel only half of the length )"
                    },
                    {
                        "username": "akshitagupta15june",
                        "content": "array is sorted so logn time binary search is sufficient to calculate"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "We Just Have to maintain the even pair on left and right side of the mid .\\nBased on that we can get correct output"
                    }
                ]
            },
            {
                "id": 1809202,
                "content": [
                    {
                        "username": "nguyenhuunghia99",
                        "content": "Testcase is not exclude brute force method, where it take complexity of O(n) !"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "We don\\'t even need the sorted array, we just same elements to be together ig "
                    },
                    {
                        "username": "_aman_gupta_",
                        "content": "A xor A = 0\\nA xor 0 = A\\nIs there a way to use this property of xor in this question?"
                    },
                    {
                        "username": "mchim",
                        "content": "Hint 1: Observe the index position. Find pattern for positions of duplicate elements.\\nHint 2: What will happen to index position if single element is inserted in the array?\\nHint 3: Apply Binary Search."
                    },
                    {
                        "username": "MayankBhadaraka",
                        "content": "def singleNonDuplicate(self, nums):\\n        ans=0\\n        for x in nums:\\n            ans=ans^x\\n        return ans"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "cant think binary search without some sort of notion related to \\'target\\' element \\uD83D\\uDE16"
                    },
                    {
                        "username": "amaan7",
                        "content": "observe the indexes before and after the single element which one is even which one is odd , you\\'ll get your answer !!"
                    },
                    {
                        "username": "avni_lee",
                        "content": "This problem could be solved by doing the ex-or(^) of all the elements of the vector, but it will take O(n) time. \\nWe need to solve this using Binary Search in order to reduce the time complexity to O(log N)."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use left and right pointers approach, check its adjacent elements, if both elements are different return its value. During each iteration increase left pointer value by 2 and decrease right pointer value by 2. ( Travel only half of the length )"
                    },
                    {
                        "username": "akshitagupta15june",
                        "content": "array is sorted so logn time binary search is sufficient to calculate"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "We Just Have to maintain the even pair on left and right side of the mid .\\nBased on that we can get correct output"
                    }
                ]
            },
            {
                "id": 1809193,
                "content": [
                    {
                        "username": "nguyenhuunghia99",
                        "content": "Testcase is not exclude brute force method, where it take complexity of O(n) !"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "We don\\'t even need the sorted array, we just same elements to be together ig "
                    },
                    {
                        "username": "_aman_gupta_",
                        "content": "A xor A = 0\\nA xor 0 = A\\nIs there a way to use this property of xor in this question?"
                    },
                    {
                        "username": "mchim",
                        "content": "Hint 1: Observe the index position. Find pattern for positions of duplicate elements.\\nHint 2: What will happen to index position if single element is inserted in the array?\\nHint 3: Apply Binary Search."
                    },
                    {
                        "username": "MayankBhadaraka",
                        "content": "def singleNonDuplicate(self, nums):\\n        ans=0\\n        for x in nums:\\n            ans=ans^x\\n        return ans"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "cant think binary search without some sort of notion related to \\'target\\' element \\uD83D\\uDE16"
                    },
                    {
                        "username": "amaan7",
                        "content": "observe the indexes before and after the single element which one is even which one is odd , you\\'ll get your answer !!"
                    },
                    {
                        "username": "avni_lee",
                        "content": "This problem could be solved by doing the ex-or(^) of all the elements of the vector, but it will take O(n) time. \\nWe need to solve this using Binary Search in order to reduce the time complexity to O(log N)."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use left and right pointers approach, check its adjacent elements, if both elements are different return its value. During each iteration increase left pointer value by 2 and decrease right pointer value by 2. ( Travel only half of the length )"
                    },
                    {
                        "username": "akshitagupta15june",
                        "content": "array is sorted so logn time binary search is sufficient to calculate"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "We Just Have to maintain the even pair on left and right side of the mid .\\nBased on that we can get correct output"
                    }
                ]
            },
            {
                "id": 1809180,
                "content": [
                    {
                        "username": "nguyenhuunghia99",
                        "content": "Testcase is not exclude brute force method, where it take complexity of O(n) !"
                    },
                    {
                        "username": "shriganesh2019",
                        "content": "We don\\'t even need the sorted array, we just same elements to be together ig "
                    },
                    {
                        "username": "_aman_gupta_",
                        "content": "A xor A = 0\\nA xor 0 = A\\nIs there a way to use this property of xor in this question?"
                    },
                    {
                        "username": "mchim",
                        "content": "Hint 1: Observe the index position. Find pattern for positions of duplicate elements.\\nHint 2: What will happen to index position if single element is inserted in the array?\\nHint 3: Apply Binary Search."
                    },
                    {
                        "username": "MayankBhadaraka",
                        "content": "def singleNonDuplicate(self, nums):\\n        ans=0\\n        for x in nums:\\n            ans=ans^x\\n        return ans"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "cant think binary search without some sort of notion related to \\'target\\' element \\uD83D\\uDE16"
                    },
                    {
                        "username": "amaan7",
                        "content": "observe the indexes before and after the single element which one is even which one is odd , you\\'ll get your answer !!"
                    },
                    {
                        "username": "avni_lee",
                        "content": "This problem could be solved by doing the ex-or(^) of all the elements of the vector, but it will take O(n) time. \\nWe need to solve this using Binary Search in order to reduce the time complexity to O(log N)."
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "Use left and right pointers approach, check its adjacent elements, if both elements are different return its value. During each iteration increase left pointer value by 2 and decrease right pointer value by 2. ( Travel only half of the length )"
                    },
                    {
                        "username": "akshitagupta15june",
                        "content": "array is sorted so logn time binary search is sufficient to calculate"
                    },
                    {
                        "username": "tarun000dhouni",
                        "content": "We Just Have to maintain the even pair on left and right side of the mid .\\nBased on that we can get correct output"
                    }
                ]
            },
            {
                "id": 1809157,
                "content": [
                    {
                        "username": "UVSinghK",
                        "content": "Me after submitting XOR solution-\n\n😎 Easy sh*t !!"
                    },
                    {
                        "username": "generalkernel",
                        "content": "Think about trisecting the array: \\n1. nums[mid] and the element before or after.\\n2. Left of the above 2 element array.\\n3. Right of the above the 2 element array.\\n\\nFor #1, we can easily check if nums[mid] is the solution.\\nNow what condition has to be true for the left subarray (#2) to hold the solution?\\n\\nIf you are stuck even with the above hint, you can check out my explanation here: https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3212522/simple-log-n-java-solution-with-detailed-explanation-beats-100/"
                    },
                    {
                        "username": "GoArtyom",
                        "content": "Is it really medium?, it\\'s so easy question"
                    },
                    {
                        "username": "abinaya_selvaraj",
                        "content": "what to do for time limit exceeded in brute force approach in python\\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "The input array is sorted, so pairs will be next to each other."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "hint: to the left of the unique element, pairs begin at even index and to the right , it begins at odd index"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans=0;\\n        for(int i : nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "This can be solved by XOR operation "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "not in log(n) time"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "Is this problem is similar to : \\nhttps://leetcode.com/problems/single-number/ "
                    },
                    {
                        "username": "dumb_me",
                        "content": "its so confusing to keep track of left and right poniter when returning ans i have to check either to return left or right pointer \\n\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "beardedone",
                        "content": "I write an O(n) solution in C++ and it outperforms a binary search...  it seems that the constraints on the array length do not justify a complex solution with an \"optimal\" (i.e., O(log n)) time complexity...."
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Think in terms of Indexes than apply Binary Search."
                    }
                ]
            },
            {
                "id": 1809154,
                "content": [
                    {
                        "username": "UVSinghK",
                        "content": "Me after submitting XOR solution-\n\n😎 Easy sh*t !!"
                    },
                    {
                        "username": "generalkernel",
                        "content": "Think about trisecting the array: \\n1. nums[mid] and the element before or after.\\n2. Left of the above 2 element array.\\n3. Right of the above the 2 element array.\\n\\nFor #1, we can easily check if nums[mid] is the solution.\\nNow what condition has to be true for the left subarray (#2) to hold the solution?\\n\\nIf you are stuck even with the above hint, you can check out my explanation here: https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3212522/simple-log-n-java-solution-with-detailed-explanation-beats-100/"
                    },
                    {
                        "username": "GoArtyom",
                        "content": "Is it really medium?, it\\'s so easy question"
                    },
                    {
                        "username": "abinaya_selvaraj",
                        "content": "what to do for time limit exceeded in brute force approach in python\\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "The input array is sorted, so pairs will be next to each other."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "hint: to the left of the unique element, pairs begin at even index and to the right , it begins at odd index"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans=0;\\n        for(int i : nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "This can be solved by XOR operation "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "not in log(n) time"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "Is this problem is similar to : \\nhttps://leetcode.com/problems/single-number/ "
                    },
                    {
                        "username": "dumb_me",
                        "content": "its so confusing to keep track of left and right poniter when returning ans i have to check either to return left or right pointer \\n\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "beardedone",
                        "content": "I write an O(n) solution in C++ and it outperforms a binary search...  it seems that the constraints on the array length do not justify a complex solution with an \"optimal\" (i.e., O(log n)) time complexity...."
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Think in terms of Indexes than apply Binary Search."
                    }
                ]
            },
            {
                "id": 1809134,
                "content": [
                    {
                        "username": "UVSinghK",
                        "content": "Me after submitting XOR solution-\n\n😎 Easy sh*t !!"
                    },
                    {
                        "username": "generalkernel",
                        "content": "Think about trisecting the array: \\n1. nums[mid] and the element before or after.\\n2. Left of the above 2 element array.\\n3. Right of the above the 2 element array.\\n\\nFor #1, we can easily check if nums[mid] is the solution.\\nNow what condition has to be true for the left subarray (#2) to hold the solution?\\n\\nIf you are stuck even with the above hint, you can check out my explanation here: https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3212522/simple-log-n-java-solution-with-detailed-explanation-beats-100/"
                    },
                    {
                        "username": "GoArtyom",
                        "content": "Is it really medium?, it\\'s so easy question"
                    },
                    {
                        "username": "abinaya_selvaraj",
                        "content": "what to do for time limit exceeded in brute force approach in python\\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "The input array is sorted, so pairs will be next to each other."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "hint: to the left of the unique element, pairs begin at even index and to the right , it begins at odd index"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans=0;\\n        for(int i : nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "This can be solved by XOR operation "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "not in log(n) time"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "Is this problem is similar to : \\nhttps://leetcode.com/problems/single-number/ "
                    },
                    {
                        "username": "dumb_me",
                        "content": "its so confusing to keep track of left and right poniter when returning ans i have to check either to return left or right pointer \\n\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "beardedone",
                        "content": "I write an O(n) solution in C++ and it outperforms a binary search...  it seems that the constraints on the array length do not justify a complex solution with an \"optimal\" (i.e., O(log n)) time complexity...."
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Think in terms of Indexes than apply Binary Search."
                    }
                ]
            },
            {
                "id": 1809091,
                "content": [
                    {
                        "username": "UVSinghK",
                        "content": "Me after submitting XOR solution-\n\n😎 Easy sh*t !!"
                    },
                    {
                        "username": "generalkernel",
                        "content": "Think about trisecting the array: \\n1. nums[mid] and the element before or after.\\n2. Left of the above 2 element array.\\n3. Right of the above the 2 element array.\\n\\nFor #1, we can easily check if nums[mid] is the solution.\\nNow what condition has to be true for the left subarray (#2) to hold the solution?\\n\\nIf you are stuck even with the above hint, you can check out my explanation here: https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3212522/simple-log-n-java-solution-with-detailed-explanation-beats-100/"
                    },
                    {
                        "username": "GoArtyom",
                        "content": "Is it really medium?, it\\'s so easy question"
                    },
                    {
                        "username": "abinaya_selvaraj",
                        "content": "what to do for time limit exceeded in brute force approach in python\\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "The input array is sorted, so pairs will be next to each other."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "hint: to the left of the unique element, pairs begin at even index and to the right , it begins at odd index"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans=0;\\n        for(int i : nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "This can be solved by XOR operation "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "not in log(n) time"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "Is this problem is similar to : \\nhttps://leetcode.com/problems/single-number/ "
                    },
                    {
                        "username": "dumb_me",
                        "content": "its so confusing to keep track of left and right poniter when returning ans i have to check either to return left or right pointer \\n\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "beardedone",
                        "content": "I write an O(n) solution in C++ and it outperforms a binary search...  it seems that the constraints on the array length do not justify a complex solution with an \"optimal\" (i.e., O(log n)) time complexity...."
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Think in terms of Indexes than apply Binary Search."
                    }
                ]
            },
            {
                "id": 1809080,
                "content": [
                    {
                        "username": "UVSinghK",
                        "content": "Me after submitting XOR solution-\n\n😎 Easy sh*t !!"
                    },
                    {
                        "username": "generalkernel",
                        "content": "Think about trisecting the array: \\n1. nums[mid] and the element before or after.\\n2. Left of the above 2 element array.\\n3. Right of the above the 2 element array.\\n\\nFor #1, we can easily check if nums[mid] is the solution.\\nNow what condition has to be true for the left subarray (#2) to hold the solution?\\n\\nIf you are stuck even with the above hint, you can check out my explanation here: https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3212522/simple-log-n-java-solution-with-detailed-explanation-beats-100/"
                    },
                    {
                        "username": "GoArtyom",
                        "content": "Is it really medium?, it\\'s so easy question"
                    },
                    {
                        "username": "abinaya_selvaraj",
                        "content": "what to do for time limit exceeded in brute force approach in python\\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "The input array is sorted, so pairs will be next to each other."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "hint: to the left of the unique element, pairs begin at even index and to the right , it begins at odd index"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans=0;\\n        for(int i : nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "This can be solved by XOR operation "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "not in log(n) time"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "Is this problem is similar to : \\nhttps://leetcode.com/problems/single-number/ "
                    },
                    {
                        "username": "dumb_me",
                        "content": "its so confusing to keep track of left and right poniter when returning ans i have to check either to return left or right pointer \\n\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "beardedone",
                        "content": "I write an O(n) solution in C++ and it outperforms a binary search...  it seems that the constraints on the array length do not justify a complex solution with an \"optimal\" (i.e., O(log n)) time complexity...."
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Think in terms of Indexes than apply Binary Search."
                    }
                ]
            },
            {
                "id": 1809063,
                "content": [
                    {
                        "username": "UVSinghK",
                        "content": "Me after submitting XOR solution-\n\n😎 Easy sh*t !!"
                    },
                    {
                        "username": "generalkernel",
                        "content": "Think about trisecting the array: \\n1. nums[mid] and the element before or after.\\n2. Left of the above 2 element array.\\n3. Right of the above the 2 element array.\\n\\nFor #1, we can easily check if nums[mid] is the solution.\\nNow what condition has to be true for the left subarray (#2) to hold the solution?\\n\\nIf you are stuck even with the above hint, you can check out my explanation here: https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3212522/simple-log-n-java-solution-with-detailed-explanation-beats-100/"
                    },
                    {
                        "username": "GoArtyom",
                        "content": "Is it really medium?, it\\'s so easy question"
                    },
                    {
                        "username": "abinaya_selvaraj",
                        "content": "what to do for time limit exceeded in brute force approach in python\\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "The input array is sorted, so pairs will be next to each other."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "hint: to the left of the unique element, pairs begin at even index and to the right , it begins at odd index"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans=0;\\n        for(int i : nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "This can be solved by XOR operation "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "not in log(n) time"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "Is this problem is similar to : \\nhttps://leetcode.com/problems/single-number/ "
                    },
                    {
                        "username": "dumb_me",
                        "content": "its so confusing to keep track of left and right poniter when returning ans i have to check either to return left or right pointer \\n\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "beardedone",
                        "content": "I write an O(n) solution in C++ and it outperforms a binary search...  it seems that the constraints on the array length do not justify a complex solution with an \"optimal\" (i.e., O(log n)) time complexity...."
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Think in terms of Indexes than apply Binary Search."
                    }
                ]
            },
            {
                "id": 1809062,
                "content": [
                    {
                        "username": "UVSinghK",
                        "content": "Me after submitting XOR solution-\n\n😎 Easy sh*t !!"
                    },
                    {
                        "username": "generalkernel",
                        "content": "Think about trisecting the array: \\n1. nums[mid] and the element before or after.\\n2. Left of the above 2 element array.\\n3. Right of the above the 2 element array.\\n\\nFor #1, we can easily check if nums[mid] is the solution.\\nNow what condition has to be true for the left subarray (#2) to hold the solution?\\n\\nIf you are stuck even with the above hint, you can check out my explanation here: https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3212522/simple-log-n-java-solution-with-detailed-explanation-beats-100/"
                    },
                    {
                        "username": "GoArtyom",
                        "content": "Is it really medium?, it\\'s so easy question"
                    },
                    {
                        "username": "abinaya_selvaraj",
                        "content": "what to do for time limit exceeded in brute force approach in python\\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "The input array is sorted, so pairs will be next to each other."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "hint: to the left of the unique element, pairs begin at even index and to the right , it begins at odd index"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans=0;\\n        for(int i : nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "This can be solved by XOR operation "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "not in log(n) time"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "Is this problem is similar to : \\nhttps://leetcode.com/problems/single-number/ "
                    },
                    {
                        "username": "dumb_me",
                        "content": "its so confusing to keep track of left and right poniter when returning ans i have to check either to return left or right pointer \\n\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "beardedone",
                        "content": "I write an O(n) solution in C++ and it outperforms a binary search...  it seems that the constraints on the array length do not justify a complex solution with an \"optimal\" (i.e., O(log n)) time complexity...."
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Think in terms of Indexes than apply Binary Search."
                    }
                ]
            },
            {
                "id": 1809033,
                "content": [
                    {
                        "username": "UVSinghK",
                        "content": "Me after submitting XOR solution-\n\n😎 Easy sh*t !!"
                    },
                    {
                        "username": "generalkernel",
                        "content": "Think about trisecting the array: \\n1. nums[mid] and the element before or after.\\n2. Left of the above 2 element array.\\n3. Right of the above the 2 element array.\\n\\nFor #1, we can easily check if nums[mid] is the solution.\\nNow what condition has to be true for the left subarray (#2) to hold the solution?\\n\\nIf you are stuck even with the above hint, you can check out my explanation here: https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3212522/simple-log-n-java-solution-with-detailed-explanation-beats-100/"
                    },
                    {
                        "username": "GoArtyom",
                        "content": "Is it really medium?, it\\'s so easy question"
                    },
                    {
                        "username": "abinaya_selvaraj",
                        "content": "what to do for time limit exceeded in brute force approach in python\\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "The input array is sorted, so pairs will be next to each other."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "hint: to the left of the unique element, pairs begin at even index and to the right , it begins at odd index"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans=0;\\n        for(int i : nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "This can be solved by XOR operation "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "not in log(n) time"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "Is this problem is similar to : \\nhttps://leetcode.com/problems/single-number/ "
                    },
                    {
                        "username": "dumb_me",
                        "content": "its so confusing to keep track of left and right poniter when returning ans i have to check either to return left or right pointer \\n\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "beardedone",
                        "content": "I write an O(n) solution in C++ and it outperforms a binary search...  it seems that the constraints on the array length do not justify a complex solution with an \"optimal\" (i.e., O(log n)) time complexity...."
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Think in terms of Indexes than apply Binary Search."
                    }
                ]
            },
            {
                "id": 1809029,
                "content": [
                    {
                        "username": "UVSinghK",
                        "content": "Me after submitting XOR solution-\n\n😎 Easy sh*t !!"
                    },
                    {
                        "username": "generalkernel",
                        "content": "Think about trisecting the array: \\n1. nums[mid] and the element before or after.\\n2. Left of the above 2 element array.\\n3. Right of the above the 2 element array.\\n\\nFor #1, we can easily check if nums[mid] is the solution.\\nNow what condition has to be true for the left subarray (#2) to hold the solution?\\n\\nIf you are stuck even with the above hint, you can check out my explanation here: https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3212522/simple-log-n-java-solution-with-detailed-explanation-beats-100/"
                    },
                    {
                        "username": "GoArtyom",
                        "content": "Is it really medium?, it\\'s so easy question"
                    },
                    {
                        "username": "abinaya_selvaraj",
                        "content": "what to do for time limit exceeded in brute force approach in python\\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "The input array is sorted, so pairs will be next to each other."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "hint: to the left of the unique element, pairs begin at even index and to the right , it begins at odd index"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans=0;\\n        for(int i : nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "This can be solved by XOR operation "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "not in log(n) time"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "Is this problem is similar to : \\nhttps://leetcode.com/problems/single-number/ "
                    },
                    {
                        "username": "dumb_me",
                        "content": "its so confusing to keep track of left and right poniter when returning ans i have to check either to return left or right pointer \\n\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "beardedone",
                        "content": "I write an O(n) solution in C++ and it outperforms a binary search...  it seems that the constraints on the array length do not justify a complex solution with an \"optimal\" (i.e., O(log n)) time complexity...."
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Think in terms of Indexes than apply Binary Search."
                    }
                ]
            },
            {
                "id": 1809028,
                "content": [
                    {
                        "username": "UVSinghK",
                        "content": "Me after submitting XOR solution-\n\n😎 Easy sh*t !!"
                    },
                    {
                        "username": "generalkernel",
                        "content": "Think about trisecting the array: \\n1. nums[mid] and the element before or after.\\n2. Left of the above 2 element array.\\n3. Right of the above the 2 element array.\\n\\nFor #1, we can easily check if nums[mid] is the solution.\\nNow what condition has to be true for the left subarray (#2) to hold the solution?\\n\\nIf you are stuck even with the above hint, you can check out my explanation here: https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3212522/simple-log-n-java-solution-with-detailed-explanation-beats-100/"
                    },
                    {
                        "username": "GoArtyom",
                        "content": "Is it really medium?, it\\'s so easy question"
                    },
                    {
                        "username": "abinaya_selvaraj",
                        "content": "what to do for time limit exceeded in brute force approach in python\\n"
                    },
                    {
                        "username": "beardedone",
                        "content": "The input array is sorted, so pairs will be next to each other."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "hint: to the left of the unique element, pairs begin at even index and to the right , it begins at odd index"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        int ans=0;\\n        for(int i : nums){\\n            ans=ans^i;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "This can be solved by XOR operation "
                    },
                    {
                        "username": "yinboshi13",
                        "content": "not in log(n) time"
                    },
                    {
                        "username": "sujaninekkanti",
                        "content": "Is this problem is similar to : \\nhttps://leetcode.com/problems/single-number/ "
                    },
                    {
                        "username": "dumb_me",
                        "content": "its so confusing to keep track of left and right poniter when returning ans i have to check either to return left or right pointer \\n\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "beardedone",
                        "content": "I write an O(n) solution in C++ and it outperforms a binary search...  it seems that the constraints on the array length do not justify a complex solution with an \"optimal\" (i.e., O(log n)) time complexity...."
                    },
                    {
                        "username": "amanchandna",
                        "content": "# Think in terms of Indexes than apply Binary Search."
                    }
                ]
            },
            {
                "id": 1809023,
                "content": [
                    {
                        "username": "actuallyGod",
                        "content": "Constraints of the problem dictate taht if a number is a valid target it MUST be on an even index. "
                    },
                    {
                        "username": "MayuD",
                        "content": "February being lucky."
                    },
                    {
                        "username": "halfengineer",
                        "content": "when u realize xor will not work\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@bhuppidhamii](/bhuppidhamii) \\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01LOL"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "when you realize you don't know xor"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "The Question is Very Easy But Challenging is Solve in O(log n) . Is I am Right?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, the challenge is O(log N). If you want to do it in O(N) time there\\'s a slightly different Easy problem for that: https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "so we moved from easy Trees to binary searching genre \\uD83D\\uDC4C\\uD83D\\uDE0F"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Remember everyone, the problem **REQUIRES** you to do it in O(log N) time. If you have to process every element in the array then your solution is O(N) and you're not solving the problem properly.\n\nIf you do it in O(N) time it's an Easy, not a Medium. And you'd fail in an interview for ignoring constraints. It's better to practice it properly now.\n\nIf you want to do an O(N) solution, try https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "Knight-03",
                        "content": "just run for loop and do xor \\nyou\\'ll get the answer \\uD83D\\uDE04"
                    },
                    {
                        "username": "zbr_98",
                        "content": "What\\'s problem in this code??\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n        if(nums.size()==1) return nums[0];\\n\\n        int n=nums.size();\\n        int s=0,e=n-1;\\n        int mid;\\n        int x;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            x=nums[mid];\\n\\n            if((mid&1 && (nums[mid-1]==x)) || (mid&1==0 && (nums[mid+1]==x)))\\n                s=mid+1;\\n            else e=mid;\\n        }\\n        return nums[s];\\n    }\\n};.`"
                    },
                    {
                        "username": "shadyboy77",
                        "content": "**Why this didnt work?**\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        int n = arr.length;\\n        if(n==1) return arr[0];\\n        int start = 0;\\n        int end = n-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            int pre = (mid-1+n)%n;\\n            int next = (mid+1)%n;\\n            int temp;\\n            if(arr[mid]!=arr[pre] && arr[mid]!=arr[next]) return arr[mid];\\n            if(arr[mid]==arr[pre]) temp = pre;\\n            else temp = next;\\n            if(temp==next){\\n                if((end-mid)%2==0) start = mid+1;\\n                else end = mid-1;\\n            }\\n            else{\\n                if((mid-start)%2==0) end = mid-1;\\n                else start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "krishnaMadesh",
                        "content": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n\\t\\tint k =0;\\n\\t\\tif(n == 1){\\n\\t\\t    return 1;\\n\\t\\t}\\n\\t\\tint j = 1;\\n\\t\\tfor(int i = 0; i < n ;){\\n\\t\\t    if(nums[i] == nums[j]){\\n\\t\\t        i+=2;\\n                if(i == n-1 && j == n-2){\\n                    k = nums[i];\\n                    return k;\\n                }\\n                else{\\n                    j+=2;\\n                }\\n\\t\\t    }\\n\\t\\t    else{\\n\\t\\t         k = nums[i];\\n\\t\\t         break;\\n\\t\\t    }\\n\\t\\t}\\n        return k;\\n    }\\n}\\n\\niteration approach for beginners easily understands"
                    }
                ]
            },
            {
                "id": 1809021,
                "content": [
                    {
                        "username": "actuallyGod",
                        "content": "Constraints of the problem dictate taht if a number is a valid target it MUST be on an even index. "
                    },
                    {
                        "username": "MayuD",
                        "content": "February being lucky."
                    },
                    {
                        "username": "halfengineer",
                        "content": "when u realize xor will not work\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@bhuppidhamii](/bhuppidhamii) \\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01LOL"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "when you realize you don't know xor"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "The Question is Very Easy But Challenging is Solve in O(log n) . Is I am Right?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, the challenge is O(log N). If you want to do it in O(N) time there\\'s a slightly different Easy problem for that: https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "so we moved from easy Trees to binary searching genre \\uD83D\\uDC4C\\uD83D\\uDE0F"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Remember everyone, the problem **REQUIRES** you to do it in O(log N) time. If you have to process every element in the array then your solution is O(N) and you're not solving the problem properly.\n\nIf you do it in O(N) time it's an Easy, not a Medium. And you'd fail in an interview for ignoring constraints. It's better to practice it properly now.\n\nIf you want to do an O(N) solution, try https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "Knight-03",
                        "content": "just run for loop and do xor \\nyou\\'ll get the answer \\uD83D\\uDE04"
                    },
                    {
                        "username": "zbr_98",
                        "content": "What\\'s problem in this code??\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n        if(nums.size()==1) return nums[0];\\n\\n        int n=nums.size();\\n        int s=0,e=n-1;\\n        int mid;\\n        int x;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            x=nums[mid];\\n\\n            if((mid&1 && (nums[mid-1]==x)) || (mid&1==0 && (nums[mid+1]==x)))\\n                s=mid+1;\\n            else e=mid;\\n        }\\n        return nums[s];\\n    }\\n};.`"
                    },
                    {
                        "username": "shadyboy77",
                        "content": "**Why this didnt work?**\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        int n = arr.length;\\n        if(n==1) return arr[0];\\n        int start = 0;\\n        int end = n-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            int pre = (mid-1+n)%n;\\n            int next = (mid+1)%n;\\n            int temp;\\n            if(arr[mid]!=arr[pre] && arr[mid]!=arr[next]) return arr[mid];\\n            if(arr[mid]==arr[pre]) temp = pre;\\n            else temp = next;\\n            if(temp==next){\\n                if((end-mid)%2==0) start = mid+1;\\n                else end = mid-1;\\n            }\\n            else{\\n                if((mid-start)%2==0) end = mid-1;\\n                else start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "krishnaMadesh",
                        "content": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n\\t\\tint k =0;\\n\\t\\tif(n == 1){\\n\\t\\t    return 1;\\n\\t\\t}\\n\\t\\tint j = 1;\\n\\t\\tfor(int i = 0; i < n ;){\\n\\t\\t    if(nums[i] == nums[j]){\\n\\t\\t        i+=2;\\n                if(i == n-1 && j == n-2){\\n                    k = nums[i];\\n                    return k;\\n                }\\n                else{\\n                    j+=2;\\n                }\\n\\t\\t    }\\n\\t\\t    else{\\n\\t\\t         k = nums[i];\\n\\t\\t         break;\\n\\t\\t    }\\n\\t\\t}\\n        return k;\\n    }\\n}\\n\\niteration approach for beginners easily understands"
                    }
                ]
            },
            {
                "id": 1809011,
                "content": [
                    {
                        "username": "actuallyGod",
                        "content": "Constraints of the problem dictate taht if a number is a valid target it MUST be on an even index. "
                    },
                    {
                        "username": "MayuD",
                        "content": "February being lucky."
                    },
                    {
                        "username": "halfengineer",
                        "content": "when u realize xor will not work\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@bhuppidhamii](/bhuppidhamii) \\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01LOL"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "when you realize you don't know xor"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "The Question is Very Easy But Challenging is Solve in O(log n) . Is I am Right?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, the challenge is O(log N). If you want to do it in O(N) time there\\'s a slightly different Easy problem for that: https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "so we moved from easy Trees to binary searching genre \\uD83D\\uDC4C\\uD83D\\uDE0F"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Remember everyone, the problem **REQUIRES** you to do it in O(log N) time. If you have to process every element in the array then your solution is O(N) and you're not solving the problem properly.\n\nIf you do it in O(N) time it's an Easy, not a Medium. And you'd fail in an interview for ignoring constraints. It's better to practice it properly now.\n\nIf you want to do an O(N) solution, try https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "Knight-03",
                        "content": "just run for loop and do xor \\nyou\\'ll get the answer \\uD83D\\uDE04"
                    },
                    {
                        "username": "zbr_98",
                        "content": "What\\'s problem in this code??\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n        if(nums.size()==1) return nums[0];\\n\\n        int n=nums.size();\\n        int s=0,e=n-1;\\n        int mid;\\n        int x;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            x=nums[mid];\\n\\n            if((mid&1 && (nums[mid-1]==x)) || (mid&1==0 && (nums[mid+1]==x)))\\n                s=mid+1;\\n            else e=mid;\\n        }\\n        return nums[s];\\n    }\\n};.`"
                    },
                    {
                        "username": "shadyboy77",
                        "content": "**Why this didnt work?**\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        int n = arr.length;\\n        if(n==1) return arr[0];\\n        int start = 0;\\n        int end = n-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            int pre = (mid-1+n)%n;\\n            int next = (mid+1)%n;\\n            int temp;\\n            if(arr[mid]!=arr[pre] && arr[mid]!=arr[next]) return arr[mid];\\n            if(arr[mid]==arr[pre]) temp = pre;\\n            else temp = next;\\n            if(temp==next){\\n                if((end-mid)%2==0) start = mid+1;\\n                else end = mid-1;\\n            }\\n            else{\\n                if((mid-start)%2==0) end = mid-1;\\n                else start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "krishnaMadesh",
                        "content": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n\\t\\tint k =0;\\n\\t\\tif(n == 1){\\n\\t\\t    return 1;\\n\\t\\t}\\n\\t\\tint j = 1;\\n\\t\\tfor(int i = 0; i < n ;){\\n\\t\\t    if(nums[i] == nums[j]){\\n\\t\\t        i+=2;\\n                if(i == n-1 && j == n-2){\\n                    k = nums[i];\\n                    return k;\\n                }\\n                else{\\n                    j+=2;\\n                }\\n\\t\\t    }\\n\\t\\t    else{\\n\\t\\t         k = nums[i];\\n\\t\\t         break;\\n\\t\\t    }\\n\\t\\t}\\n        return k;\\n    }\\n}\\n\\niteration approach for beginners easily understands"
                    }
                ]
            },
            {
                "id": 1808988,
                "content": [
                    {
                        "username": "actuallyGod",
                        "content": "Constraints of the problem dictate taht if a number is a valid target it MUST be on an even index. "
                    },
                    {
                        "username": "MayuD",
                        "content": "February being lucky."
                    },
                    {
                        "username": "halfengineer",
                        "content": "when u realize xor will not work\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@bhuppidhamii](/bhuppidhamii) \\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01LOL"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "when you realize you don't know xor"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "The Question is Very Easy But Challenging is Solve in O(log n) . Is I am Right?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, the challenge is O(log N). If you want to do it in O(N) time there\\'s a slightly different Easy problem for that: https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "so we moved from easy Trees to binary searching genre \\uD83D\\uDC4C\\uD83D\\uDE0F"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Remember everyone, the problem **REQUIRES** you to do it in O(log N) time. If you have to process every element in the array then your solution is O(N) and you're not solving the problem properly.\n\nIf you do it in O(N) time it's an Easy, not a Medium. And you'd fail in an interview for ignoring constraints. It's better to practice it properly now.\n\nIf you want to do an O(N) solution, try https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "Knight-03",
                        "content": "just run for loop and do xor \\nyou\\'ll get the answer \\uD83D\\uDE04"
                    },
                    {
                        "username": "zbr_98",
                        "content": "What\\'s problem in this code??\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n        if(nums.size()==1) return nums[0];\\n\\n        int n=nums.size();\\n        int s=0,e=n-1;\\n        int mid;\\n        int x;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            x=nums[mid];\\n\\n            if((mid&1 && (nums[mid-1]==x)) || (mid&1==0 && (nums[mid+1]==x)))\\n                s=mid+1;\\n            else e=mid;\\n        }\\n        return nums[s];\\n    }\\n};.`"
                    },
                    {
                        "username": "shadyboy77",
                        "content": "**Why this didnt work?**\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        int n = arr.length;\\n        if(n==1) return arr[0];\\n        int start = 0;\\n        int end = n-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            int pre = (mid-1+n)%n;\\n            int next = (mid+1)%n;\\n            int temp;\\n            if(arr[mid]!=arr[pre] && arr[mid]!=arr[next]) return arr[mid];\\n            if(arr[mid]==arr[pre]) temp = pre;\\n            else temp = next;\\n            if(temp==next){\\n                if((end-mid)%2==0) start = mid+1;\\n                else end = mid-1;\\n            }\\n            else{\\n                if((mid-start)%2==0) end = mid-1;\\n                else start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "krishnaMadesh",
                        "content": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n\\t\\tint k =0;\\n\\t\\tif(n == 1){\\n\\t\\t    return 1;\\n\\t\\t}\\n\\t\\tint j = 1;\\n\\t\\tfor(int i = 0; i < n ;){\\n\\t\\t    if(nums[i] == nums[j]){\\n\\t\\t        i+=2;\\n                if(i == n-1 && j == n-2){\\n                    k = nums[i];\\n                    return k;\\n                }\\n                else{\\n                    j+=2;\\n                }\\n\\t\\t    }\\n\\t\\t    else{\\n\\t\\t         k = nums[i];\\n\\t\\t         break;\\n\\t\\t    }\\n\\t\\t}\\n        return k;\\n    }\\n}\\n\\niteration approach for beginners easily understands"
                    }
                ]
            },
            {
                "id": 1808981,
                "content": [
                    {
                        "username": "actuallyGod",
                        "content": "Constraints of the problem dictate taht if a number is a valid target it MUST be on an even index. "
                    },
                    {
                        "username": "MayuD",
                        "content": "February being lucky."
                    },
                    {
                        "username": "halfengineer",
                        "content": "when u realize xor will not work\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@bhuppidhamii](/bhuppidhamii) \\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01LOL"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "when you realize you don't know xor"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "The Question is Very Easy But Challenging is Solve in O(log n) . Is I am Right?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, the challenge is O(log N). If you want to do it in O(N) time there\\'s a slightly different Easy problem for that: https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "so we moved from easy Trees to binary searching genre \\uD83D\\uDC4C\\uD83D\\uDE0F"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Remember everyone, the problem **REQUIRES** you to do it in O(log N) time. If you have to process every element in the array then your solution is O(N) and you're not solving the problem properly.\n\nIf you do it in O(N) time it's an Easy, not a Medium. And you'd fail in an interview for ignoring constraints. It's better to practice it properly now.\n\nIf you want to do an O(N) solution, try https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "Knight-03",
                        "content": "just run for loop and do xor \\nyou\\'ll get the answer \\uD83D\\uDE04"
                    },
                    {
                        "username": "zbr_98",
                        "content": "What\\'s problem in this code??\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n        if(nums.size()==1) return nums[0];\\n\\n        int n=nums.size();\\n        int s=0,e=n-1;\\n        int mid;\\n        int x;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            x=nums[mid];\\n\\n            if((mid&1 && (nums[mid-1]==x)) || (mid&1==0 && (nums[mid+1]==x)))\\n                s=mid+1;\\n            else e=mid;\\n        }\\n        return nums[s];\\n    }\\n};.`"
                    },
                    {
                        "username": "shadyboy77",
                        "content": "**Why this didnt work?**\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        int n = arr.length;\\n        if(n==1) return arr[0];\\n        int start = 0;\\n        int end = n-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            int pre = (mid-1+n)%n;\\n            int next = (mid+1)%n;\\n            int temp;\\n            if(arr[mid]!=arr[pre] && arr[mid]!=arr[next]) return arr[mid];\\n            if(arr[mid]==arr[pre]) temp = pre;\\n            else temp = next;\\n            if(temp==next){\\n                if((end-mid)%2==0) start = mid+1;\\n                else end = mid-1;\\n            }\\n            else{\\n                if((mid-start)%2==0) end = mid-1;\\n                else start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "krishnaMadesh",
                        "content": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n\\t\\tint k =0;\\n\\t\\tif(n == 1){\\n\\t\\t    return 1;\\n\\t\\t}\\n\\t\\tint j = 1;\\n\\t\\tfor(int i = 0; i < n ;){\\n\\t\\t    if(nums[i] == nums[j]){\\n\\t\\t        i+=2;\\n                if(i == n-1 && j == n-2){\\n                    k = nums[i];\\n                    return k;\\n                }\\n                else{\\n                    j+=2;\\n                }\\n\\t\\t    }\\n\\t\\t    else{\\n\\t\\t         k = nums[i];\\n\\t\\t         break;\\n\\t\\t    }\\n\\t\\t}\\n        return k;\\n    }\\n}\\n\\niteration approach for beginners easily understands"
                    }
                ]
            },
            {
                "id": 1808938,
                "content": [
                    {
                        "username": "actuallyGod",
                        "content": "Constraints of the problem dictate taht if a number is a valid target it MUST be on an even index. "
                    },
                    {
                        "username": "MayuD",
                        "content": "February being lucky."
                    },
                    {
                        "username": "halfengineer",
                        "content": "when u realize xor will not work\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@bhuppidhamii](/bhuppidhamii) \\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01LOL"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "when you realize you don't know xor"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "The Question is Very Easy But Challenging is Solve in O(log n) . Is I am Right?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, the challenge is O(log N). If you want to do it in O(N) time there\\'s a slightly different Easy problem for that: https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "so we moved from easy Trees to binary searching genre \\uD83D\\uDC4C\\uD83D\\uDE0F"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Remember everyone, the problem **REQUIRES** you to do it in O(log N) time. If you have to process every element in the array then your solution is O(N) and you're not solving the problem properly.\n\nIf you do it in O(N) time it's an Easy, not a Medium. And you'd fail in an interview for ignoring constraints. It's better to practice it properly now.\n\nIf you want to do an O(N) solution, try https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "Knight-03",
                        "content": "just run for loop and do xor \\nyou\\'ll get the answer \\uD83D\\uDE04"
                    },
                    {
                        "username": "zbr_98",
                        "content": "What\\'s problem in this code??\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n        if(nums.size()==1) return nums[0];\\n\\n        int n=nums.size();\\n        int s=0,e=n-1;\\n        int mid;\\n        int x;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            x=nums[mid];\\n\\n            if((mid&1 && (nums[mid-1]==x)) || (mid&1==0 && (nums[mid+1]==x)))\\n                s=mid+1;\\n            else e=mid;\\n        }\\n        return nums[s];\\n    }\\n};.`"
                    },
                    {
                        "username": "shadyboy77",
                        "content": "**Why this didnt work?**\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        int n = arr.length;\\n        if(n==1) return arr[0];\\n        int start = 0;\\n        int end = n-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            int pre = (mid-1+n)%n;\\n            int next = (mid+1)%n;\\n            int temp;\\n            if(arr[mid]!=arr[pre] && arr[mid]!=arr[next]) return arr[mid];\\n            if(arr[mid]==arr[pre]) temp = pre;\\n            else temp = next;\\n            if(temp==next){\\n                if((end-mid)%2==0) start = mid+1;\\n                else end = mid-1;\\n            }\\n            else{\\n                if((mid-start)%2==0) end = mid-1;\\n                else start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "krishnaMadesh",
                        "content": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n\\t\\tint k =0;\\n\\t\\tif(n == 1){\\n\\t\\t    return 1;\\n\\t\\t}\\n\\t\\tint j = 1;\\n\\t\\tfor(int i = 0; i < n ;){\\n\\t\\t    if(nums[i] == nums[j]){\\n\\t\\t        i+=2;\\n                if(i == n-1 && j == n-2){\\n                    k = nums[i];\\n                    return k;\\n                }\\n                else{\\n                    j+=2;\\n                }\\n\\t\\t    }\\n\\t\\t    else{\\n\\t\\t         k = nums[i];\\n\\t\\t         break;\\n\\t\\t    }\\n\\t\\t}\\n        return k;\\n    }\\n}\\n\\niteration approach for beginners easily understands"
                    }
                ]
            },
            {
                "id": 1808935,
                "content": [
                    {
                        "username": "actuallyGod",
                        "content": "Constraints of the problem dictate taht if a number is a valid target it MUST be on an even index. "
                    },
                    {
                        "username": "MayuD",
                        "content": "February being lucky."
                    },
                    {
                        "username": "halfengineer",
                        "content": "when u realize xor will not work\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@bhuppidhamii](/bhuppidhamii) \\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01LOL"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "when you realize you don't know xor"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "The Question is Very Easy But Challenging is Solve in O(log n) . Is I am Right?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, the challenge is O(log N). If you want to do it in O(N) time there\\'s a slightly different Easy problem for that: https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "so we moved from easy Trees to binary searching genre \\uD83D\\uDC4C\\uD83D\\uDE0F"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Remember everyone, the problem **REQUIRES** you to do it in O(log N) time. If you have to process every element in the array then your solution is O(N) and you're not solving the problem properly.\n\nIf you do it in O(N) time it's an Easy, not a Medium. And you'd fail in an interview for ignoring constraints. It's better to practice it properly now.\n\nIf you want to do an O(N) solution, try https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "Knight-03",
                        "content": "just run for loop and do xor \\nyou\\'ll get the answer \\uD83D\\uDE04"
                    },
                    {
                        "username": "zbr_98",
                        "content": "What\\'s problem in this code??\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n        if(nums.size()==1) return nums[0];\\n\\n        int n=nums.size();\\n        int s=0,e=n-1;\\n        int mid;\\n        int x;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            x=nums[mid];\\n\\n            if((mid&1 && (nums[mid-1]==x)) || (mid&1==0 && (nums[mid+1]==x)))\\n                s=mid+1;\\n            else e=mid;\\n        }\\n        return nums[s];\\n    }\\n};.`"
                    },
                    {
                        "username": "shadyboy77",
                        "content": "**Why this didnt work?**\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        int n = arr.length;\\n        if(n==1) return arr[0];\\n        int start = 0;\\n        int end = n-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            int pre = (mid-1+n)%n;\\n            int next = (mid+1)%n;\\n            int temp;\\n            if(arr[mid]!=arr[pre] && arr[mid]!=arr[next]) return arr[mid];\\n            if(arr[mid]==arr[pre]) temp = pre;\\n            else temp = next;\\n            if(temp==next){\\n                if((end-mid)%2==0) start = mid+1;\\n                else end = mid-1;\\n            }\\n            else{\\n                if((mid-start)%2==0) end = mid-1;\\n                else start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "krishnaMadesh",
                        "content": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n\\t\\tint k =0;\\n\\t\\tif(n == 1){\\n\\t\\t    return 1;\\n\\t\\t}\\n\\t\\tint j = 1;\\n\\t\\tfor(int i = 0; i < n ;){\\n\\t\\t    if(nums[i] == nums[j]){\\n\\t\\t        i+=2;\\n                if(i == n-1 && j == n-2){\\n                    k = nums[i];\\n                    return k;\\n                }\\n                else{\\n                    j+=2;\\n                }\\n\\t\\t    }\\n\\t\\t    else{\\n\\t\\t         k = nums[i];\\n\\t\\t         break;\\n\\t\\t    }\\n\\t\\t}\\n        return k;\\n    }\\n}\\n\\niteration approach for beginners easily understands"
                    }
                ]
            },
            {
                "id": 1779741,
                "content": [
                    {
                        "username": "actuallyGod",
                        "content": "Constraints of the problem dictate taht if a number is a valid target it MUST be on an even index. "
                    },
                    {
                        "username": "MayuD",
                        "content": "February being lucky."
                    },
                    {
                        "username": "halfengineer",
                        "content": "when u realize xor will not work\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@bhuppidhamii](/bhuppidhamii) \\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01LOL"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "when you realize you don't know xor"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "The Question is Very Easy But Challenging is Solve in O(log n) . Is I am Right?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, the challenge is O(log N). If you want to do it in O(N) time there\\'s a slightly different Easy problem for that: https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "so we moved from easy Trees to binary searching genre \\uD83D\\uDC4C\\uD83D\\uDE0F"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Remember everyone, the problem **REQUIRES** you to do it in O(log N) time. If you have to process every element in the array then your solution is O(N) and you're not solving the problem properly.\n\nIf you do it in O(N) time it's an Easy, not a Medium. And you'd fail in an interview for ignoring constraints. It's better to practice it properly now.\n\nIf you want to do an O(N) solution, try https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "Knight-03",
                        "content": "just run for loop and do xor \\nyou\\'ll get the answer \\uD83D\\uDE04"
                    },
                    {
                        "username": "zbr_98",
                        "content": "What\\'s problem in this code??\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n        if(nums.size()==1) return nums[0];\\n\\n        int n=nums.size();\\n        int s=0,e=n-1;\\n        int mid;\\n        int x;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            x=nums[mid];\\n\\n            if((mid&1 && (nums[mid-1]==x)) || (mid&1==0 && (nums[mid+1]==x)))\\n                s=mid+1;\\n            else e=mid;\\n        }\\n        return nums[s];\\n    }\\n};.`"
                    },
                    {
                        "username": "shadyboy77",
                        "content": "**Why this didnt work?**\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        int n = arr.length;\\n        if(n==1) return arr[0];\\n        int start = 0;\\n        int end = n-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            int pre = (mid-1+n)%n;\\n            int next = (mid+1)%n;\\n            int temp;\\n            if(arr[mid]!=arr[pre] && arr[mid]!=arr[next]) return arr[mid];\\n            if(arr[mid]==arr[pre]) temp = pre;\\n            else temp = next;\\n            if(temp==next){\\n                if((end-mid)%2==0) start = mid+1;\\n                else end = mid-1;\\n            }\\n            else{\\n                if((mid-start)%2==0) end = mid-1;\\n                else start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "krishnaMadesh",
                        "content": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n\\t\\tint k =0;\\n\\t\\tif(n == 1){\\n\\t\\t    return 1;\\n\\t\\t}\\n\\t\\tint j = 1;\\n\\t\\tfor(int i = 0; i < n ;){\\n\\t\\t    if(nums[i] == nums[j]){\\n\\t\\t        i+=2;\\n                if(i == n-1 && j == n-2){\\n                    k = nums[i];\\n                    return k;\\n                }\\n                else{\\n                    j+=2;\\n                }\\n\\t\\t    }\\n\\t\\t    else{\\n\\t\\t         k = nums[i];\\n\\t\\t         break;\\n\\t\\t    }\\n\\t\\t}\\n        return k;\\n    }\\n}\\n\\niteration approach for beginners easily understands"
                    }
                ]
            },
            {
                "id": 1721838,
                "content": [
                    {
                        "username": "actuallyGod",
                        "content": "Constraints of the problem dictate taht if a number is a valid target it MUST be on an even index. "
                    },
                    {
                        "username": "MayuD",
                        "content": "February being lucky."
                    },
                    {
                        "username": "halfengineer",
                        "content": "when u realize xor will not work\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@bhuppidhamii](/bhuppidhamii) \\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01LOL"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "when you realize you don't know xor"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "The Question is Very Easy But Challenging is Solve in O(log n) . Is I am Right?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, the challenge is O(log N). If you want to do it in O(N) time there\\'s a slightly different Easy problem for that: https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "so we moved from easy Trees to binary searching genre \\uD83D\\uDC4C\\uD83D\\uDE0F"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Remember everyone, the problem **REQUIRES** you to do it in O(log N) time. If you have to process every element in the array then your solution is O(N) and you're not solving the problem properly.\n\nIf you do it in O(N) time it's an Easy, not a Medium. And you'd fail in an interview for ignoring constraints. It's better to practice it properly now.\n\nIf you want to do an O(N) solution, try https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "Knight-03",
                        "content": "just run for loop and do xor \\nyou\\'ll get the answer \\uD83D\\uDE04"
                    },
                    {
                        "username": "zbr_98",
                        "content": "What\\'s problem in this code??\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n        if(nums.size()==1) return nums[0];\\n\\n        int n=nums.size();\\n        int s=0,e=n-1;\\n        int mid;\\n        int x;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            x=nums[mid];\\n\\n            if((mid&1 && (nums[mid-1]==x)) || (mid&1==0 && (nums[mid+1]==x)))\\n                s=mid+1;\\n            else e=mid;\\n        }\\n        return nums[s];\\n    }\\n};.`"
                    },
                    {
                        "username": "shadyboy77",
                        "content": "**Why this didnt work?**\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        int n = arr.length;\\n        if(n==1) return arr[0];\\n        int start = 0;\\n        int end = n-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            int pre = (mid-1+n)%n;\\n            int next = (mid+1)%n;\\n            int temp;\\n            if(arr[mid]!=arr[pre] && arr[mid]!=arr[next]) return arr[mid];\\n            if(arr[mid]==arr[pre]) temp = pre;\\n            else temp = next;\\n            if(temp==next){\\n                if((end-mid)%2==0) start = mid+1;\\n                else end = mid-1;\\n            }\\n            else{\\n                if((mid-start)%2==0) end = mid-1;\\n                else start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "krishnaMadesh",
                        "content": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n\\t\\tint k =0;\\n\\t\\tif(n == 1){\\n\\t\\t    return 1;\\n\\t\\t}\\n\\t\\tint j = 1;\\n\\t\\tfor(int i = 0; i < n ;){\\n\\t\\t    if(nums[i] == nums[j]){\\n\\t\\t        i+=2;\\n                if(i == n-1 && j == n-2){\\n                    k = nums[i];\\n                    return k;\\n                }\\n                else{\\n                    j+=2;\\n                }\\n\\t\\t    }\\n\\t\\t    else{\\n\\t\\t         k = nums[i];\\n\\t\\t         break;\\n\\t\\t    }\\n\\t\\t}\\n        return k;\\n    }\\n}\\n\\niteration approach for beginners easily understands"
                    }
                ]
            },
            {
                "id": 1714364,
                "content": [
                    {
                        "username": "actuallyGod",
                        "content": "Constraints of the problem dictate taht if a number is a valid target it MUST be on an even index. "
                    },
                    {
                        "username": "MayuD",
                        "content": "February being lucky."
                    },
                    {
                        "username": "halfengineer",
                        "content": "when u realize xor will not work\\uD83D\\uDE23\\uD83D\\uDE23"
                    },
                    {
                        "username": "halfengineer",
                        "content": "[@bhuppidhamii](/bhuppidhamii) \\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE01LOL"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "when you realize you don't know xor"
                    },
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "The Question is Very Easy But Challenging is Solve in O(log n) . Is I am Right?"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Yes, the challenge is O(log N). If you want to do it in O(N) time there\\'s a slightly different Easy problem for that: https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "so we moved from easy Trees to binary searching genre \\uD83D\\uDC4C\\uD83D\\uDE0F"
                    },
                    {
                        "username": "nikhila01",
                        "content": "Remember everyone, the problem **REQUIRES** you to do it in O(log N) time. If you have to process every element in the array then your solution is O(N) and you're not solving the problem properly.\n\nIf you do it in O(N) time it's an Easy, not a Medium. And you'd fail in an interview for ignoring constraints. It's better to practice it properly now.\n\nIf you want to do an O(N) solution, try https://leetcode.com/problems/single-number/"
                    },
                    {
                        "username": "Knight-03",
                        "content": "just run for loop and do xor \\nyou\\'ll get the answer \\uD83D\\uDE04"
                    },
                    {
                        "username": "zbr_98",
                        "content": "What\\'s problem in this code??\\n\\n `class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n\\n        if(nums.size()==1) return nums[0];\\n\\n        int n=nums.size();\\n        int s=0,e=n-1;\\n        int mid;\\n        int x;\\n        while(s<e){\\n            mid=s+(e-s)/2;\\n            x=nums[mid];\\n\\n            if((mid&1 && (nums[mid-1]==x)) || (mid&1==0 && (nums[mid+1]==x)))\\n                s=mid+1;\\n            else e=mid;\\n        }\\n        return nums[s];\\n    }\\n};.`"
                    },
                    {
                        "username": "shadyboy77",
                        "content": "**Why this didnt work?**\\nclass Solution {\\n    public int singleNonDuplicate(int[] arr) {\\n        int n = arr.length;\\n        if(n==1) return arr[0];\\n        int start = 0;\\n        int end = n-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            int pre = (mid-1+n)%n;\\n            int next = (mid+1)%n;\\n            int temp;\\n            if(arr[mid]!=arr[pre] && arr[mid]!=arr[next]) return arr[mid];\\n            if(arr[mid]==arr[pre]) temp = pre;\\n            else temp = next;\\n            if(temp==next){\\n                if((end-mid)%2==0) start = mid+1;\\n                else end = mid-1;\\n            }\\n            else{\\n                if((mid-start)%2==0) end = mid-1;\\n                else start = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "krishnaMadesh",
                        "content": "class Solution {\\n    public int singleNonDuplicate(int[] nums) {\\n        int n = nums.length;\\n\\t\\tint k =0;\\n\\t\\tif(n == 1){\\n\\t\\t    return 1;\\n\\t\\t}\\n\\t\\tint j = 1;\\n\\t\\tfor(int i = 0; i < n ;){\\n\\t\\t    if(nums[i] == nums[j]){\\n\\t\\t        i+=2;\\n                if(i == n-1 && j == n-2){\\n                    k = nums[i];\\n                    return k;\\n                }\\n                else{\\n                    j+=2;\\n                }\\n\\t\\t    }\\n\\t\\t    else{\\n\\t\\t         k = nums[i];\\n\\t\\t         break;\\n\\t\\t    }\\n\\t\\t}\\n        return k;\\n    }\\n}\\n\\niteration approach for beginners easily understands"
                    }
                ]
            }
        ]
    }
]