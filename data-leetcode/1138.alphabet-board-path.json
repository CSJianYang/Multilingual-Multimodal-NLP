[
    {
        "title": "Rotated Digits",
        "question_content": "An integer x is a good if after rotating each digit individually by 180 degrees, we get a valid number that is different from x. Each digit must be rotated - we cannot choose to leave it alone.\nA number is valid if each digit remains a digit after rotation. For example:\n\n\t0, 1, and 8 rotate to themselves,\n\t2 and 5 rotate to each other (in this case they are rotated in a different direction, in other words, 2 or 5 gets mirrored),\n\t6 and 9 rotate to each other, and\n\tthe rest of the numbers do not rotate to any other number and become invalid.\n\nGiven an integer n, return the number of good integers in the range [1, n].\n&nbsp;\nExample 1:\n\nInput: n = 10\nOutput: 4\nExplanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.\nNote that 1 and 10 are not good numbers, since they remain unchanged after rotating.\n\nExample 2:\n\nInput: n = 1\nOutput: 0\n\nExample 3:\n\nInput: n = 2\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 104",
        "solutions": [
            {
                "id": 117975,
                "title": "java-dp-solution-9ms",
                "content": "Using a int[] for dp.\ndp[i] = 0, invalid number\ndp[i] = 1, valid and same number\ndp[i] = 2, valid and different number\n```\n    public int rotatedDigits(int N) {\n        int[] dp = new int[N + 1];\n        int count = 0;\n        for(int i = 0; i <= N; i++){\n            if(i < 10){\n                if(i == 0 || i == 1 || i == 8) dp[i] = 1;\n                else if(i == 2 || i == 5 || i == 6 || i == 9){\n                    dp[i] = 2;\n                    count++;\n                }\n            } else {\n                int a = dp[i / 10], b = dp[i % 10];\n                if(a == 1 && b == 1) dp[i] = 1;\n                else if(a >= 1 && b >= 1){\n                    dp[i] = 2;\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n```",
                "solutionTags": [],
                "code": "```\n    public int rotatedDigits(int N) {\n        int[] dp = new int[N + 1];\n        int count = 0;\n        for(int i = 0; i <= N; i++){\n            if(i < 10){\n                if(i == 0 || i == 1 || i == 8) dp[i] = 1;\n                else if(i == 2 || i == 5 || i == 6 || i == 9){\n                    dp[i] = 2;\n                    count++;\n                }\n            } else {\n                int a = dp[i / 10], b = dp[i % 10];\n                if(a == 1 && b == 1) dp[i] = 1;\n                else if(a >= 1 && b >= 1){\n                    dp[i] = 2;\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116547,
                "title": "easily-understood-java-solution",
                "content": "```\nclass Solution {\n    public int rotatedDigits(int N) {\n        int count = 0;\n        for (int i = 1; i <= N; i ++) {\n            if (isValid(i)) count ++;\n        }\n        return count;\n    }\n    \n    public boolean isValid(int N) {\n        /*\n         Valid if N contains ATLEAST ONE 2, 5, 6, 9\n         AND NO 3, 4 or 7s\n         */\n        boolean validFound = false;\n        while (N > 0) {\n            if (N % 10 == 2) validFound = true;\n            if (N % 10 == 5) validFound = true;\n            if (N % 10 == 6) validFound = true;\n            if (N % 10 == 9) validFound = true;\n            if (N % 10 == 3) return false;\n            if (N % 10 == 4) return false;\n            if (N % 10 == 7) return false;\n            N = N / 10;\n        }\n        return validFound;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int rotatedDigits(int N) {\n        int count = 0;\n        for (int i = 1; i <= N; i ++) {\n            if (isValid(i)) count ++;\n        }\n        return count;\n    }\n    \n    public boolean isValid(int N) {\n        /*\n         Valid if N contains ATLEAST ONE 2, 5, 6, 9\n         AND NO 3, 4 or 7s\n         */\n        boolean validFound = false;\n        while (N > 0) {\n            if (N % 10 == 2) validFound = true;\n            if (N % 10 == 5) validFound = true;\n            if (N % 10 == 6) validFound = true;\n            if (N % 10 == 9) validFound = true;\n            if (N % 10 == 3) return false;\n            if (N % 10 == 4) return false;\n            if (N % 10 == 7) return false;\n            N = N / 10;\n        }\n        return validFound;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 116530,
                "title": "java-python-o-logn-time-o-1-space",
                "content": "# Soluton 1\\n5 lines, self-explaining\\n\\n`s1 = set([1, 8, 0])` \"A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves\"\\n`s2 = set([1, 8, 0, 6, 9, 2, 5])`, \"2 and 5 rotate to each other, 6 and 9 rotate to each other\"\\n\\n`s.issubset(s2)`, \"X is a good number if after rotating each digit individually by 180 degrees, \"\\n`not s.issubset(s1)` \"we get a valid number that is different from X. \"\\n\\n```py\\n  def rotatedDigits(self, N):\\n        s1 = set([1, 8, 0])\\n        s2 = set([1, 8, 0, 6, 9, 2, 5])\\n        def isGood(x):\\n            s = set([int(i) for i in str(x)])\\n            return s.issubset(s2) and not s.issubset(s1)\\n        return sum(isGood(i) for i in range(N + 1))\\n```\\n<br>\\n\\n# Solution 2\\n`O(NlogN)` solution is simple in all languages.\\nHere is solution in `O(logN)` complexity.\\n```py\\n  def rotatedDigits(self, N):\\n        s1 = set([0, 1, 8])\\n        s2 = set([0, 1, 8, 2, 5, 6, 9])\\n        s = set()\\n        res = 0\\n        N = map(int, str(N))\\n        for i, v in enumerate(N):\\n            for j in range(v):\\n                if s.issubset(s2) and j in s2:\\n                    res += 7**(len(N) - i - 1)\\n                if s.issubset(s1) and j in s1:\\n                    res -= 3**(len(N) - i - 1)\\n            if v not in s2:\\n                return res\\n            s.add(v)\\n        return res + (s.issubset(s2) and not s.issubset(s1))\\n```\\n**Java**\\n```java\\npublic int rotatedDigits(int N) {\\n    char[] chars = Integer.toString(N).toCharArray();\\n    int res = 0;\\n    HashSet<Integer> digits = new HashSet<>();\\n    for (int i = 0; i < chars.length; i++) {\\n        int digit = chars[i] - \\'0\\';\\n        for (int j = 0; j < digit; j++) {\\n            if (set2.contains(j)) {\\n                res += (int)Math.pow(7, chars.length - i - 1);\\n            }\\n            if (set1.containsAll(digits) && set1.contains(j)) {\\n                res -= (int)Math.pow(3, chars.length - i - 1);\\n            }\\n        }\\n        digits.add(digit);\\n        if (!set2.contains(digit)) {\\n            return res;\\n        }\\n\\n    }\\n\\n    return res + (!set1.containsAll(digits) ? 1 : 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```py\\n  def rotatedDigits(self, N):\\n        s1 = set([1, 8, 0])\\n        s2 = set([1, 8, 0, 6, 9, 2, 5])\\n        def isGood(x):\\n            s = set([int(i) for i in str(x)])\\n            return s.issubset(s2) and not s.issubset(s1)\\n        return sum(isGood(i) for i in range(N + 1))\\n```\n```py\\n  def rotatedDigits(self, N):\\n        s1 = set([0, 1, 8])\\n        s2 = set([0, 1, 8, 2, 5, 6, 9])\\n        s = set()\\n        res = 0\\n        N = map(int, str(N))\\n        for i, v in enumerate(N):\\n            for j in range(v):\\n                if s.issubset(s2) and j in s2:\\n                    res += 7**(len(N) - i - 1)\\n                if s.issubset(s1) and j in s1:\\n                    res -= 3**(len(N) - i - 1)\\n            if v not in s2:\\n                return res\\n            s.add(v)\\n        return res + (s.issubset(s2) and not s.issubset(s1))\\n```\n```java\\npublic int rotatedDigits(int N) {\\n    char[] chars = Integer.toString(N).toCharArray();\\n    int res = 0;\\n    HashSet<Integer> digits = new HashSet<>();\\n    for (int i = 0; i < chars.length; i++) {\\n        int digit = chars[i] - \\'0\\';\\n        for (int j = 0; j < digit; j++) {\\n            if (set2.contains(j)) {\\n                res += (int)Math.pow(7, chars.length - i - 1);\\n            }\\n            if (set1.containsAll(digits) && set1.contains(j)) {\\n                res -= (int)Math.pow(3, chars.length - i - 1);\\n            }\\n        }\\n        digits.add(digit);\\n        if (!set2.contains(digit)) {\\n            return res;\\n        }\\n\\n    }\\n\\n    return res + (!set1.containsAll(digits) ? 1 : 0);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 130681,
                "title": "simple-easy-c",
                "content": "```\\n        int f[] = {1,1,2,0,0,2,2,0,1,2};\\n        int res = 0;\\n        for(int i = 1; i <= N; i++){\\n            int p = i;\\n            int s = 1;\\n            while(p){\\n                s *= f[p%10];\\n                p /= 10;\\n            }\\n            if(s >=2) res+=1;\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "```\\n        int f[] = {1,1,2,0,0,2,2,0,1,2};\\n        int res = 0;\\n        for(int i = 1; i <= N; i++){\\n            int p = i;\\n            int s = 1;\\n            while(p){\\n                s *= f[p%10];\\n                p /= 10;\\n            }\\n            if(s >=2) res+=1;\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 116658,
                "title": "the-question-need-to-be-explained-clearly",
                "content": "after looking at the accepted solution, I found that, to be a \"good\" number, every digit must be roated, for example ```23``` is not a good number although, it can be roated to ```53```\\n\\nUpdate: The question description has been updated as mentioned by @awice",
                "solutionTags": [],
                "code": "```23```\n```53```",
                "codeTag": "Unknown"
            },
            {
                "id": 116539,
                "title": "easy-to-understand-python-solution-using-string",
                "content": "Used string indexing instead of integer division in my solution, which might be inefficient. But here's my solution anyways:\n```\nclass Solution(object):\n    def rotatedDigits(self, N):\n        counts = 0\n        for num in range(1, N+1):\n            number = str(num)\n            if '3' in number or '7' in number or '4' in number: # This will be an invalid number upon rotation\n                continue # Skip this number and go to next iteration\n            if '2' in number or '5' in number or '6' in number or '9' in number:\n                counts += 1\n        return counts\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def rotatedDigits(self, N):\n        counts = 0\n        for num in range(1, N+1):\n            number = str(num)\n            if '3' in number or '7' in number or '4' in number: # This will be an invalid number upon rotation\n                continue # Skip this number and go to next iteration\n            if '2' in number or '5' in number or '6' in number or '9' in number:\n                counts += 1\n        return counts\n```",
                "codeTag": "Java"
            },
            {
                "id": 485290,
                "title": "easy-understand-solution-python-o-1-space",
                "content": "```\\ndef rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for d in range(1, N+1):\\n            d = str(d)\\n            if \\'3\\' in d or \\'4\\' in d or \\'7\\' in d:\\n                continue\\n            if \\'2\\' in d or \\'5\\' in d or \\'6\\' in d or \\'9\\' in d:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for d in range(1, N+1):\\n            d = str(d)\\n            if \\'3\\' in d or \\'4\\' in d or \\'7\\' in d:\\n                continue\\n            if \\'2\\' in d or \\'5\\' in d or \\'6\\' in d or \\'9\\' in d:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 379257,
                "title": "easy-c-solution-0ms-less-than-100-memory",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Rotated Digits.\\nMemory Usage: 8.1 MB, less than 100.00% of C++ online submissions for Rotated Digits.\\n\\n```\\nint rotatedDigits(int N) {\\n        \\n        int count = 0;\\n        for(int i=1; i<=N; i++)\\n        {\\n            bool flag = false;\\n            int num = i;\\n            while(num > 0)\\n            {\\n                int d = num%10;\\n                if(d == 3 || d == 4 || d == 7)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                if(d == 2 || d == 5 || d == 6 || d == 9)\\n                    flag = true;\\n                \\n                num = num/10;\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Rotated Digits.\\nMemory Usage: 8.1 MB, less than 100.00% of C++ online submissions for Rotated Digits.\\n\\n```\\nint rotatedDigits(int N) {\\n        \\n        int count = 0;\\n        for(int i=1; i<=N; i++)\\n        {\\n            bool flag = false;\\n            int num = i;\\n            while(num > 0)\\n            {\\n                int d = num%10;\\n                if(d == 3 || d == 4 || d == 7)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                if(d == 2 || d == 5 || d == 6 || d == 9)\\n                    flag = true;\\n                \\n                num = num/10;\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 116674,
                "title": "o-log10-n-easy-to-understand-java-solution",
                "content": "\n```\nclass Solution {\n    private int[] allPossibleCount =  new int[]{1,2,3,3,3,4,5,5,6,7}; // 0,1,2,5,6,8,9\n    private int[] excludeNumCount = new int[]{1,2,2,2,2,2,2,2,3,3}; // 0, 1, 8\n    private boolean[] isExclude = new boolean[] {true,true,false,false,false,false,false,false,true,false};\n    private boolean[] isValid = new boolean[]{true, true, true, false,false,true, true,false,true,true};\n    public int rotatedDigits(int N) {\n        char[] cs = Integer.toString(N).toCharArray();\n        int len = cs.length, count = 0;        \n        boolean exclude = true;\n        for(int i = 0, mul = len; i<len; i++, mul--)\n        {\n            if(cs[i] == '0'&& i != len-1 )continue;\n            int index = i == len-1? cs[i]-'0': cs[i]-'0'-1;\n            double c =  allPossibleCount[index]*Math.pow(7,mul-1);   \n            double e =  exclude ? excludeNumCount[index]*Math.pow(3,mul-1) : 0; // # of numbers which only contain 0,1,8\n            count+=c-e;\n            if(!isValid[cs[i]-'0'])break;\n            exclude = exclude & isExclude[cs[i]-'0'];\n        }\n        return count;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    private int[] allPossibleCount =  new int[]{1,2,3,3,3,4,5,5,6,7}; // 0,1,2,5,6,8,9\n    private int[] excludeNumCount = new int[]{1,2,2,2,2,2,2,2,3,3}; // 0, 1, 8\n    private boolean[] isExclude = new boolean[] {true,true,false,false,false,false,false,false,true,false};\n    private boolean[] isValid = new boolean[]{true, true, true, false,false,true, true,false,true,true};\n    public int rotatedDigits(int N) {\n        char[] cs = Integer.toString(N).toCharArray();\n        int len = cs.length, count = 0;        \n        boolean exclude = true;\n        for(int i = 0, mul = len; i<len; i++, mul--)\n        {\n            if(cs[i] == '0'&& i != len-1 )continue;\n            int index = i == len-1? cs[i]-'0': cs[i]-'0'-1;\n            double c =  allPossibleCount[index]*Math.pow(7,mul-1);   \n            double e =  exclude ? excludeNumCount[index]*Math.pow(3,mul-1) : 0; // # of numbers which only contain 0,1,8\n            count+=c-e;\n            if(!isValid[cs[i]-'0'])break;\n            exclude = exclude & isExclude[cs[i]-'0'];\n        }\n        return count;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307796,
                "title": "stupid-solution-to-stupid-problem-java",
                "content": "Basically, if you your number contains any digits that cannot be rotated, it becomes invalid (3, 4, 7)\\nIf it contains any of the digits that can be rotated that creates a new digit (2, 5, 6, 9), then rotating it will always create a new overall number.\\nThe ones that can rotate and do not create a new digit (0, 1, 8) don\\'t do anything to the overall number. 808 flipped is still 808. The only way a new number can be created is if the number contains a 2, 5, 6, or 9.\\n\\n```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n      int count = 0;\\n      for(int i = 0; i <= N; i++) {\\n        String s = String.valueOf(i);\\n        if(s.contains(\"3\")) continue;\\n        if(s.contains(\"4\")) continue;\\n        if(s.contains(\"7\")) continue;\\n        \\n        if(s.contains(\"2\") || s.contains(\"5\") || s.contains(\"6\") || s.contains(\"9\")) count++;\\n        \\n      }\\n      return count;\\n    }\\n}\\n```\\nUpvote if this helped you \\uD83D\\uDC4D",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n      int count = 0;\\n      for(int i = 0; i <= N; i++) {\\n        String s = String.valueOf(i);\\n        if(s.contains(\"3\")) continue;\\n        if(s.contains(\"4\")) continue;\\n        if(s.contains(\"7\")) continue;\\n        \\n        if(s.contains(\"2\") || s.contains(\"5\") || s.contains(\"6\") || s.contains(\"9\")) count++;\\n        \\n      }\\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116519,
                "title": "python-solution",
                "content": "```\ndef rotatedDigits(self, N):\n    def isValidRotation(num):\n        return (not any(s in {'3', '4', '7'} for s in num)) and any(s in {'2', '5', '6', '9'} for s in num)\n\n    return sum([isValidRotation(str(i)) for i in range(1, N+1)])\n```",
                "solutionTags": [],
                "code": "```\ndef rotatedDigits(self, N):\n    def isValidRotation(num):\n        return (not any(s in {'3', '4', '7'} for s in num)) and any(s in {'2', '5', '6', '9'} for s in num)\n\n    return sum([isValidRotation(str(i)) for i in range(1, N+1)])\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1286139,
                "title": "100-faster-very-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int ans=0;\\n        for(int i=2;i<=N;i++)\\n        {\\n            ans+=check(i);\\n        }\\n        return ans;\\n    }\\n    \\n    bool check(int n)\\n    {\\n        int t;\\n        bool flag=0;\\n        while(n)\\n        {\\n            t=n%10;\\n            if(t==3 || t==4 || t==7 )return 0;\\n            if(t==2 || t==5 || t==6 || t==9) flag=1;\\n            n/=10;\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int ans=0;\\n        for(int i=2;i<=N;i++)\\n        {\\n            ans+=check(i);\\n        }\\n        return ans;\\n    }\\n    \\n    bool check(int n)\\n    {\\n        int t;\\n        bool flag=0;\\n        while(n)\\n        {\\n            t=n%10;\\n            if(t==3 || t==4 || t==7 )return 0;\\n            if(t==2 || t==5 || t==6 || t==9) flag=1;\\n            n/=10;\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 335145,
                "title": "python-maybe-o-log-n-with-comments",
                "content": "This turned out quite complicated as there are a few edge-cases. The basic idea is this:\\n\\nSay you have the number `N = 6789`.  We will break the count into two parts:\\n1. We will first count all of the good numbers in `{0000, 0001, ..., 5999}`. For each choice of first digit in `{0, 1, ..., 5}` we do the following:\\n\\t* If it is not rotatable (i.e. it is 3, 4, or 7), we add nothing to the count.\\n\\t* If it is rotatable and not symmetric (i.e. it is 2, 5, 6, or 9), we add 7^3 to the count -- this is the number of good numbers in `{000, 001, ..., 999}` when you include those that transform to themselves.\\n\\t* If it is rotatable and symmetric (i.e. it is 0, 1, or 8), we add (7^3 - 3^3) to the count -- this is the number of good numbers in `{000, 001, ..., 999}` when you exclude those that transform to themselves.\\n2. We will then count all of the good numbers in `{6000, 6001, ..., 6789}`. We can do this part recursively as we just need to count the good numbers in `{000, 001, ..., 789}`. But because 6 is not symmetric, we will include numbers that transform to themselves. If the first digit were 0, 1, or 8, we would exclude from the count numbers that transform to themselves.\\n\\nI\\'m fairly sure this algorithm is either O(log(n)) or O((log(n))<sup>2</sup>). If anyone wants to do the analysis, feel free to leave it in the comments.\\n\\n```python\\nrotatable_digits = (0, 1, 2, 5, 6, 8, 9)\\nsymmetric_digits = (0, 1, 8)\\n\\ndef count_good_numbers(n, must_change=True):\\n    \"\"\"Count how many \\'good\\' numbers there are in {1, ... , n}.\\n\\n    A number is considered \\'good\\' if rotating all of it\\'s digits\\n    individually produces a valid number.  If must_change, the\\n    resultant number must be different from the original number.\\n\\n     - The digits 0, 1, and 8 rotate to produce themselves.\\n     - The digit 2 rotates to produce 5, and vice-versa.\\n     - The digit 6 rotates to produce 9, and vice-versa.\\n    \"\"\"\\n    digits      = str(n)\\n    first_digit = int(digits[0])\\n    total       = 0\\n\\n    # First, we will count all of the \\'good\\' numbers up to, but not including\\n    # first_digit * 10^k, where k = len(digits)-1.\\n    \\n    # For example, if n = 6789, we will count all of the good numbers in \\n    # {0, ..., 5999}. (We include 0 to simplify the implementation, but as it is not a\\n    # good number, it will not be counted.)\\n\\n    for digit in range(first_digit):\\n        # We add the numbers that start with `digit`, and have the same number of digits\\n        # as n (after adding leading zeroes), and are composed of only rotatable digits.\\n\\n        # How many are there? There are seven rotatable digits, so the number\\n        # of ways of building a length-i sequence of them is 7^i.\\n\\n        if digit in rotatable_digits:\\n            total += 7**(len(digits)-1)\\n\\n        # We subtract out the numbers that are composed of only symmetric digits. \\n        # (These numbers are not \\'good\\' as they transform to themselves.)  We only \\n        # do this if `must_change` is True.\\n\\n        # How many are there? There are three symmetric digits, so the number of \\n        # ways of building a length-i sequence of them is 3^i.\\n\\n        if must_change and (digit in symmetric_digits):\\n            total -= 3**(len(digits)-1)\\n\\n    # If n is a multi-digit number, we might not yet have counted all the \\'good\\' numbers.\\n\\n    # For example, if n = 6789, we\\'ve counted all the good numbers in {0, ..., 5999},\\n    # but we\\'ve not yet counted all the good numbers in {6000, ..., 6789}.\\n\\n    # But we only need to do this if the first digit is rotatable, as otherwise none of\\n    # these numbers are \\'good\\'.\\n\\n    if (len(digits) > 1) and (first_digit in rotatable_digits):\\n        rest_of_digits = int(digits[1:])\\n        total += count_good_numbers(\\n            rest_of_digits,\\n            # If the first digit is non-symmetric, then the transformed number\\n\\t\\t\\t# will be different from the original number regardless of whether the\\n\\t\\t\\t# rest of the digits are symmetric.\\n            must_change = False if (first_digit not in symmetric_digits) else must_change\\n        )\\n\\n    # Otherwise, if n is a single-digit number, we may need to include  n itself in the \\n    # count.\\n    \\n    # For example, if n = 6, so far we have only counted 2 and 5, and we need to include 6.\\n\\n    if (len(digits) == 1) and (first_digit in rotatable_digits):\\n        if (not must_change) or (first_digit not in symmetric_digits):\\n            total += 1\\n\\n    return total\\n```",
                "solutionTags": [],
                "code": "```python\\nrotatable_digits = (0, 1, 2, 5, 6, 8, 9)\\nsymmetric_digits = (0, 1, 8)\\n\\ndef count_good_numbers(n, must_change=True):\\n    \"\"\"Count how many \\'good\\' numbers there are in {1, ... , n}.\\n\\n    A number is considered \\'good\\' if rotating all of it\\'s digits\\n    individually produces a valid number.  If must_change, the\\n    resultant number must be different from the original number.\\n\\n     - The digits 0, 1, and 8 rotate to produce themselves.\\n     - The digit 2 rotates to produce 5, and vice-versa.\\n     - The digit 6 rotates to produce 9, and vice-versa.\\n    \"\"\"\\n    digits      = str(n)\\n    first_digit = int(digits[0])\\n    total       = 0\\n\\n    # First, we will count all of the \\'good\\' numbers up to, but not including\\n    # first_digit * 10^k, where k = len(digits)-1.\\n    \\n    # For example, if n = 6789, we will count all of the good numbers in \\n    # {0, ..., 5999}. (We include 0 to simplify the implementation, but as it is not a\\n    # good number, it will not be counted.)\\n\\n    for digit in range(first_digit):\\n        # We add the numbers that start with `digit`, and have the same number of digits\\n        # as n (after adding leading zeroes), and are composed of only rotatable digits.\\n\\n        # How many are there? There are seven rotatable digits, so the number\\n        # of ways of building a length-i sequence of them is 7^i.\\n\\n        if digit in rotatable_digits:\\n            total += 7**(len(digits)-1)\\n\\n        # We subtract out the numbers that are composed of only symmetric digits. \\n        # (These numbers are not \\'good\\' as they transform to themselves.)  We only \\n        # do this if `must_change` is True.\\n\\n        # How many are there? There are three symmetric digits, so the number of \\n        # ways of building a length-i sequence of them is 3^i.\\n\\n        if must_change and (digit in symmetric_digits):\\n            total -= 3**(len(digits)-1)\\n\\n    # If n is a multi-digit number, we might not yet have counted all the \\'good\\' numbers.\\n\\n    # For example, if n = 6789, we\\'ve counted all the good numbers in {0, ..., 5999},\\n    # but we\\'ve not yet counted all the good numbers in {6000, ..., 6789}.\\n\\n    # But we only need to do this if the first digit is rotatable, as otherwise none of\\n    # these numbers are \\'good\\'.\\n\\n    if (len(digits) > 1) and (first_digit in rotatable_digits):\\n        rest_of_digits = int(digits[1:])\\n        total += count_good_numbers(\\n            rest_of_digits,\\n            # If the first digit is non-symmetric, then the transformed number\\n\\t\\t\\t# will be different from the original number regardless of whether the\\n\\t\\t\\t# rest of the digits are symmetric.\\n            must_change = False if (first_digit not in symmetric_digits) else must_change\\n        )\\n\\n    # Otherwise, if n is a single-digit number, we may need to include  n itself in the \\n    # count.\\n    \\n    # For example, if n = 6, so far we have only counted 2 and 5, and we need to include 6.\\n\\n    if (len(digits) == 1) and (first_digit in rotatable_digits):\\n        if (not must_change) or (first_digit not in symmetric_digits):\\n            total += 1\\n\\n    return total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 144466,
                "title": "javascript-solution-68ms-beats-82-02-use-regular-expression-simple-and-straightforward",
                "content": "```\\nvar rotatedDigits = function(N) {\\n    let count = 0;\\n    for(let i=1; i<=N; i++){\\n    \\tlet tmp = i+\\'\\';\\n    \\tif(!/[347]/g.test(tmp) && /[2569]/g.test(tmp)) count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rotatedDigits = function(N) {\\n    let count = 0;\\n    for(let i=1; i<=N; i++){\\n    \\tlet tmp = i+\\'\\';\\n    \\tif(!/[347]/g.test(tmp) && /[2569]/g.test(tmp)) count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 264282,
                "title": "java-o-logn-0ms-100",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int[] rotate = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\\n        List<Integer> ds = new ArrayList();\\n        while (N > 0) {\\n            ds.add(N % 10);\\n            N /= 10;\\n        }\\n        int count = 0;\\n        boolean diff = false;\\n        for (int i = ds.size() - 1; i > -1; --i) {\\n            int good = 0, soso = 0, d = ds.get(i);\\n            for (int j = 0; j < d; ++j) {\\n                if (rotate[j] == 1) ++good;\\n                else if (rotate[j] == 0) ++soso;\\n            }\\n            count += (good + soso) * Math.pow(7, i);\\n            if (!diff) count -= soso * Math.pow(3, i);\\n            if (rotate[d] == -1) return count;\\n            if (rotate[d] == 1) diff = true;\\n        }\\n        return diff && rotate[ds.get(0)] > -1 ? count + 1 : count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int[] rotate = {0, 0, 1, -1, -1, 1, 1, -1, 0, 1};\\n        List<Integer> ds = new ArrayList();\\n        while (N > 0) {\\n            ds.add(N % 10);\\n            N /= 10;\\n        }\\n        int count = 0;\\n        boolean diff = false;\\n        for (int i = ds.size() - 1; i > -1; --i) {\\n            int good = 0, soso = 0, d = ds.get(i);\\n            for (int j = 0; j < d; ++j) {\\n                if (rotate[j] == 1) ++good;\\n                else if (rotate[j] == 0) ++soso;\\n            }\\n            count += (good + soso) * Math.pow(7, i);\\n            if (!diff) count -= soso * Math.pow(3, i);\\n            if (rotate[d] == -1) return count;\\n            if (rotate[d] == 1) diff = true;\\n        }\\n        return diff && rotate[ds.get(0)] > -1 ? count + 1 : count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172132,
                "title": "java-clean-dfs-solution-with-interview-tips",
                "content": "This problem for me should not be under \"Easy\" tag. It is a similar problem to the Strobogrammatic Number\\'s series that I mentioned below. I recommand checking this solution and get familiar with the structure of dfs algorithm. \\n\\nIt\\'s worth mentioning that, as mentioned in many other posts, there are mathematics-based solutions of this questions, achieving O(logN) time complexity. However, this article is devoted to the dfs solution for a couple of reasons. \\n\\nThis dfs solution works more generally; its structure is applied in many similar questions, including those mentioned below. It\\'s indeed lucky if we see this exact question in a real interview. Chances are that, however, the question might be in a modified version. Thus instead of finding the mathematic rule based on each question, mastering writing **your own** version of dfs solution seems like a safer choice. \\n\\nBesides its robustness, the dfs solution is very natural. You can easily introduce the thought process and demo your algorithm to the interviewer. This is in particularly true if you only have the access to an online doc. As you might not have a pen and a white board, a math-based solution can be sometimes tricky to understand.  \\n\\nThus this article is on my version of dfs solution. This is my \"go-to\" guideline if I can\\'t make up a clever solution or can\\'t convince myself its correctness. It\\'s great if you might take something from my solution to generate yours. \\n\\nThis structure of code works very well in all similar problems:\\n\\n* [1088. Confusing Number II](https://leetcode.com/problems/confusing-number-ii/discuss/1117746/Java-Clean-Backtracking-Solution-oror-with-detailed-explanation)\\n* [247. Strobogrammatic Number II](https://leetcode.com/problems/strobogrammatic-number-ii/discuss/1117755/Java-clean-Backtracking-Solution-oror-with-comments) \\n* [248. Strobogrammatic Number III](https://leetcode.com/problems/strobogrammatic-number-iii/discuss/1117750/Java-clean-Backtracking-Solution-oror-with-comments)\\n\\n```\\nclass Solution {\\n    private static final char[] ROTATE_SAME = {\\'0\\', \\'1\\', \\'8\\'};\\n    private static final char[] ROTATE_DIFF = {\\'2\\', \\'5\\', \\'6\\', \\'9\\'};\\n    private int count = 0;\\n    private String high;\\n    \\n    public int rotatedDigits(int N) {\\n        this.high = String.valueOf(N);\\n        \\n        for (int len = 1; len <= high.length(); len++) \\n            dfs(0, new char[len], false);\\n        \\n        return count;\\n    }\\n    \\n    private void dfs(int idx, char[] arr, boolean valid) {\\n        if (idx == arr.length) {\\n            if (!valid) return;\\n            String res = new String(arr);\\n            if (!(res.length() == high.length() && res.compareTo(high) > 0)) count++;\\n            return;\\n        }\\n        \\n        for (char c : ROTATE_SAME) {\\n            if (idx == 0 && c == \\'0\\') continue;\\n            arr[idx] = c;\\n            dfs(idx + 1, arr, valid);\\n        }\\n        \\n        for (char c : ROTATE_DIFF) {\\n            arr[idx] = c;\\n            dfs(idx + 1, arr, true);\\n        }\\n    }\\n}\\n```\\n\\n**Time Complexity:**\\n\\nGiven an input N, we know it\\'s length (number of digits) is of O(logN). The time complexity of the main function is determined by the for-loop. The for-loop iterating through different lengths **len** from 1 to logN.  \\n\\nFor each length **len**, the helper function dfs() does these two things:\\n```\\n1. (recursive step)  try each of 7 options at each digit             (from index 0 to len - 1)\\n\\t\\t==> O(7 ^ len)  time\\n2. (base case)       construct new String() and compare each digit   (after index len - 1)\\n\\t\\t==> O(len)  time\\n```\\nThus the dfs() call with length **len** takes O(7 ^ len * len) time. \\n\\nNow we return to the main function and denote\\n```\\n// O(T) := total time complexity \\nT  =  7 ^ 1 * 1  +  7 ^ 2 * 2  +  ...  +  7 ^ (logN) * (logN)\\n  >=  7 ^ (logN) * (logN)\\n   =  O(N * logN)\\n\\n// Also from the other direction of the Squeeze Theorem: \\nT  <=  7 ^ 1 * (logN)  +  7 ^ 2 * (logN)  +  ...  + 7 ^ (logN) * (logN)\\n    =  (logN)  *  (7 ^ 1  +  7 ^ 2  +  ...  + 7 ^ logN)\\n    =  (logN)  * (7 ^ logN * 7 - 7) / 6\\n    =  (logN)  * O(7 ^ logN)\\n\\t=  O(N * logN)\\n```\\nThus the total time complexity is **O(N * logN)**.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private static final char[] ROTATE_SAME = {\\'0\\', \\'1\\', \\'8\\'};\\n    private static final char[] ROTATE_DIFF = {\\'2\\', \\'5\\', \\'6\\', \\'9\\'};\\n    private int count = 0;\\n    private String high;\\n    \\n    public int rotatedDigits(int N) {\\n        this.high = String.valueOf(N);\\n        \\n        for (int len = 1; len <= high.length(); len++) \\n            dfs(0, new char[len], false);\\n        \\n        return count;\\n    }\\n    \\n    private void dfs(int idx, char[] arr, boolean valid) {\\n        if (idx == arr.length) {\\n            if (!valid) return;\\n            String res = new String(arr);\\n            if (!(res.length() == high.length() && res.compareTo(high) > 0)) count++;\\n            return;\\n        }\\n        \\n        for (char c : ROTATE_SAME) {\\n            if (idx == 0 && c == \\'0\\') continue;\\n            arr[idx] = c;\\n            dfs(idx + 1, arr, valid);\\n        }\\n        \\n        for (char c : ROTATE_DIFF) {\\n            arr[idx] = c;\\n            dfs(idx + 1, arr, true);\\n        }\\n    }\\n}\\n```\n```\\n1. (recursive step)  try each of 7 options at each digit             (from index 0 to len - 1)\\n\\t\\t==> O(7 ^ len)  time\\n2. (base case)       construct new String() and compare each digit   (after index len - 1)\\n\\t\\t==> O(len)  time\\n```\n```\\n// O(T) := total time complexity \\nT  =  7 ^ 1 * 1  +  7 ^ 2 * 2  +  ...  +  7 ^ (logN) * (logN)\\n  >=  7 ^ (logN) * (logN)\\n   =  O(N * logN)\\n\\n// Also from the other direction of the Squeeze Theorem: \\nT  <=  7 ^ 1 * (logN)  +  7 ^ 2 * (logN)  +  ...  + 7 ^ (logN) * (logN)\\n    =  (logN)  *  (7 ^ 1  +  7 ^ 2  +  ...  + 7 ^ logN)\\n    =  (logN)  * (7 ^ logN * 7 - 7) / 6\\n    =  (logN)  * O(7 ^ logN)\\n\\t=  O(N * logN)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075957,
                "title": "java-o-n-straight-forward-solution",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for (int i = 1;i<=N;i++) if (getCount(i) > 0) count++;\\n        return count;\\n    }\\n    \\n    public int getCount(int num){\\n        int count  = 0;\\n        while (num > 0){\\n                int r = num % 10;\\n                if (r == 3 || r == 4 || r == 7) return 0;\\n                if (r == 2 || r == 5 || r == 6 || r == 9) count++;\\n                num = num / 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for (int i = 1;i<=N;i++) if (getCount(i) > 0) count++;\\n        return count;\\n    }\\n    \\n    public int getCount(int num){\\n        int count  = 0;\\n        while (num > 0){\\n                int r = num % 10;\\n                if (r == 3 || r == 4 || r == 7) return 0;\\n                if (r == 2 || r == 5 || r == 6 || r == 9) count++;\\n                num = num / 10;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845786,
                "title": "c-clean-code-dp",
                "content": "```\\nint rotatedDigits(int N) {\\n  //3,4,7 invalid ->0\\n  //0,1,8 valid ->1\\n  //2,5,6,9 good ->2\\n  vector<int> dp(N+1,0);\\n  int cnt=0;\\n  for(int i=0;i<=N;++i){\\n\\tif(i<10){\\n\\t  if(i==0 || i==1 || i==8) dp[i]=1;\\n\\t  else if(i==2 || i==5 || i==6 || i==9) dp[i]=2,++cnt; \\n\\t}else{\\n\\t  if(dp[i/10]==1 && dp[i%10]==1) dp[i]=1;\\n\\t  else if(dp[i/10]>=1 && dp[i%10]>=1) dp[i]=2,++cnt;\\n\\t}\\n  }\\n  return cnt;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint rotatedDigits(int N) {\\n  //3,4,7 invalid ->0\\n  //0,1,8 valid ->1\\n  //2,5,6,9 good ->2\\n  vector<int> dp(N+1,0);\\n  int cnt=0;\\n  for(int i=0;i<=N;++i){\\n\\tif(i<10){\\n\\t  if(i==0 || i==1 || i==8) dp[i]=1;\\n\\t  else if(i==2 || i==5 || i==6 || i==9) dp[i]=2,++cnt; \\n\\t}else{\\n\\t  if(dp[i/10]==1 && dp[i%10]==1) dp[i]=1;\\n\\t  else if(dp[i/10]>=1 && dp[i%10]>=1) dp[i]=2,++cnt;\\n\\t}\\n  }\\n  return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508130,
                "title": "javascript-straight-forward-solution",
                "content": "```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar rotatedDigits = function(N) {\\n  let counter = 0;\\n  for (let i = 1; i <= N; i++) {\\n    if (isValid(i)) counter++;\\n  }\\n  return counter;\\n};\\n\\nconst isValid = n => {\\n  let valid = false;\\n  while (n) {\\n    const a = n % 10;\\n    if (a === 3 || a === 4 || a === 7) return false;\\n    if (a === 2 || a === 5 || a === 6 || a === 9) valid = true;\\n    n = Math.trunc(n / 10);\\n  }\\n  return valid;\\n};\\n```\\n\\n* 50/50 cases passed (48 ms)\\n* Your runtime beats 100 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (34.2 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar rotatedDigits = function(N) {\\n  let counter = 0;\\n  for (let i = 1; i <= N; i++) {\\n    if (isValid(i)) counter++;\\n  }\\n  return counter;\\n};\\n\\nconst isValid = n => {\\n  let valid = false;\\n  while (n) {\\n    const a = n % 10;\\n    if (a === 3 || a === 4 || a === 7) return false;\\n    if (a === 2 || a === 5 || a === 6 || a === 9) valid = true;\\n    n = Math.trunc(n / 10);\\n  }\\n  return valid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116655,
                "title": "simple-easy-to-understand-code-in-c",
                "content": "```\n#define SAME 0 // 0, 1, 8\n#define VALID 1 // 2, 6, 8, 9\n#define INVALID 2 // 3, 4, 7\n\nint rotatedDigits(int n) {\n    int i, num, count = 0, is_valid[] = {SAME, SAME, VALID, INVALID, INVALID, VALID, VALID, INVALID, SAME, VALID};\n    bool found = false;\n    \n    for(i = 2; i <= n; i++){\n        num = i; found = false;\n        while(num){\n           if(is_valid[num % 10] == INVALID) {found = false; break;}\n           if(is_valid[num % 10] == VALID) found = true; \n           num = num/10;\n        }\n        if(found == true) count++;\n    }\n    \n    return count;\n}\n```",
                "solutionTags": [],
                "code": "```\n#define SAME 0 // 0, 1, 8\n#define VALID 1 // 2, 6, 8, 9\n#define INVALID 2 // 3, 4, 7\n\nint rotatedDigits(int n) {\n    int i, num, count = 0, is_valid[] = {SAME, SAME, VALID, INVALID, INVALID, VALID, VALID, INVALID, SAME, VALID};\n    bool found = false;\n    \n    for(i = 2; i <= n; i++){\n        num = i; found = false;\n        while(num){\n           if(is_valid[num % 10] == INVALID) {found = false; break;}\n           if(is_valid[num % 10] == VALID) found = true; \n           num = num/10;\n        }\n        if(found == true) count++;\n    }\n    \n    return count;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602721,
                "title": "python3-7-lines-sets-t-m-63-100",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n\\n        count = 0\\n        \\n        for i in range(1,n+1):\\n            nSet = set(str(i))\\n            \\n            if (not nSet.intersection({\\'3\\',\\'4\\',\\'7\\'}) and \\n                    nSet.intersection({\\'2\\',\\'5\\',\\'6\\',\\'9\\'})):\\n                count += 1\\n                \\n        return count\\n```\\n[https://leetcode.com/problems/rotated-digits/submissions/1006307495/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*log*N*), in which *N* ~ `n`.",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n\\n        count = 0\\n        \\n        for i in range(1,n+1):\\n            nSet = set(str(i))\\n            \\n            if (not nSet.intersection({\\'3\\',\\'4\\',\\'7\\'}) and \\n                    nSet.intersection({\\'2\\',\\'5\\',\\'6\\',\\'9\\'})):\\n                count += 1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320211,
                "title": "easy-approach-dynamic-programming-c",
                "content": "there are following steps to solve this question easily.\\nDivide your problem in two halves.\\n1.Less than 10\\n2.greater than 10\\n\\n1. Fill you dp table by default 0 in whole.\\nFilling zeros will tell you that by default all the numbers are invalid.\\n2.Fill 1 in your dp to esure that numbers are valid but they are same after flipping\\n3.Fill 2 in your dp array once you find valid and different number after rotating.\\n4.Finally do it for all the n and return the count,you have to keep increasing count whenever you fill 2 in your table because this is the case for which you are solving this problem.\\n \\n```\\nclass Solution {\\npublic:\\n \\n    int rotatedDigits(int n) {\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        int count=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i<10)\\n            {\\n                if(i==0 || i==1 || i==8)\\n                     dp[i]=1;\\n                else if(i==2 || i==5 || i==6 || i==9)\\n                {\\n                     dp[i]=2;\\n                      count++;\\n                }\\n\\n            }\\n            else\\n            {\\n                int a=dp[i/10];\\n                int b=dp[i%10];\\n                if(a==1 && b==1)\\n                    dp[i]=1;\\n                else if(a>=1 && b>=1)\\n                {\\n                    dp[i]=2;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n \\n    int rotatedDigits(int n) {\\n        int dp[n+1];\\n        memset(dp,0,sizeof(dp));\\n        int count=0;\\n        for(int i=0;i<=n;i++)\\n        {\\n            if(i<10)\\n            {\\n                if(i==0 || i==1 || i==8)\\n                     dp[i]=1;\\n                else if(i==2 || i==5 || i==6 || i==9)\\n                {\\n                     dp[i]=2;\\n                      count++;\\n                }\\n\\n            }\\n            else\\n            {\\n                int a=dp[i/10];\\n                int b=dp[i%10];\\n                if(a==1 && b==1)\\n                    dp[i]=1;\\n                else if(a>=1 && b>=1)\\n                {\\n                    dp[i]=2;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205605,
                "title": "python3-simple-solution-using-two-approaches",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for x in range(1, N+1):\\n            x = str(x)\\n            if \\'3\\' in x or \\'4\\' in x or \\'7\\' in x:\\n                continue\\n            if \\'2\\' in x or \\'5\\' in x or \\'6\\' in x or \\'9\\' in x:\\n                count+=1\\n        return count\\n```\\n\\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        d = {\\'0\\':\\'0\\',\\'1\\':\\'1\\',\\'2\\':\\'5\\',\\'5\\':\\'2\\',\\'6\\':\\'9\\',\\'8\\':\\'8\\',\\'9\\':\\'6\\'}\\n        count = 0\\n        for i in range(1,N+1):\\n            x = \\'\\'\\n            flag = True\\n            for j in str(i):\\n                if j not in d.keys():\\n                    flag = False\\n                    break\\n                else:\\n                    x += d[j]\\n            if flag and x != str(i):\\n                count += 1\\n        return count\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for x in range(1, N+1):\\n            x = str(x)\\n            if \\'3\\' in x or \\'4\\' in x or \\'7\\' in x:\\n                continue\\n            if \\'2\\' in x or \\'5\\' in x or \\'6\\' in x or \\'9\\' in x:\\n                count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        d = {\\'0\\':\\'0\\',\\'1\\':\\'1\\',\\'2\\':\\'5\\',\\'5\\':\\'2\\',\\'6\\':\\'9\\',\\'8\\':\\'8\\',\\'9\\':\\'6\\'}\\n        count = 0\\n        for i in range(1,N+1):\\n            x = \\'\\'\\n            flag = True\\n            for j in str(i):\\n                if j not in d.keys():\\n                    flag = False\\n                    break\\n                else:\\n                    x += d[j]\\n            if flag and x != str(i):\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116562,
                "title": "java-regex-one-line-java8",
                "content": "Simple, but poor performance.\n\n    public int rotatedDigits(int N) {\n        int count = 0;\n        for(int i = 1; i <= N; i++) {\n            if (Integer.toString(i).matches(\"^([018]*[2569]+[018]*)+$\"))\n                count++;\n        }\n        return count;\n    }\n\nOne line in java 8:\n\n    public int rotatedDigits(int N) {\n        return IntStream.range(1, N+1).map(i -> Integer.toString(i).matches(\"^([018]*[2569]+[018]*)+$\") ? 1 : 0).sum();\n    }\n\nA much faster solution:\n```\n   public int rotatedDigits(int N) {\n        int ans = 0;\n        outer: for(int i = 1; i <= N; i++) {\n            int d = 0;\n            for(char ch : Integer.toString(i).toCharArray()) {\n                if (ch == '3' || ch == '4' || ch == '7')\n                    continue outer;\n                if (ch == '2' || ch == '5' || ch == '6' || ch == '9')\n                    d = 1;\n            }\n            ans += d;\n        }\n        return ans;\n    }\n```",
                "solutionTags": [],
                "code": "```\n   public int rotatedDigits(int N) {\n        int ans = 0;\n        outer: for(int i = 1; i <= N; i++) {\n            int d = 0;\n            for(char ch : Integer.toString(i).toCharArray()) {\n                if (ch == '3' || ch == '4' || ch == '7')\n                    continue outer;\n                if (ch == '2' || ch == '5' || ch == '6' || ch == '9')\n                    d = 1;\n            }\n            ans += d;\n        }\n        return ans;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3557037,
                "title": "easy-understandable-python-code",
                "content": "\\n\\n# Approach\\n-  Valid if N contains ATLEAST ```ONE 2, 5, 6, 9```\\n AND ``` NO 3, 4 or 7```\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        invalid = [3,4,7]\\n        good = 0\\n        check = False\\n\\n        for i in range(1,n+1):\\n            j = i\\n        \\n            while j != 0:\\n                d = j % 10\\n                \\n                if d == 2 or d == 5 or d == 6 or d == 9:\\n                    check = True\\n                \\n                elif d in invalid:\\n                    check = False\\n                    break\\n                \\n                j = j // 10\\n\\n            if check:\\n                good += 1\\n\\n            check = False        \\n        \\n        return good\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```ONE 2, 5, 6, 9```\n``` NO 3, 4 or 7```\n```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        invalid = [3,4,7]\\n        good = 0\\n        check = False\\n\\n        for i in range(1,n+1):\\n            j = i\\n        \\n            while j != 0:\\n                d = j % 10\\n                \\n                if d == 2 or d == 5 or d == 6 or d == 9:\\n                    check = True\\n                \\n                elif d in invalid:\\n                    check = False\\n                    break\\n                \\n                j = j // 10\\n\\n            if check:\\n                good += 1\\n\\n            check = False        \\n        \\n        return good\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446920,
                "title": "simple-python-using-sets-o-n",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        valid = {\\'2\\',\\'5\\',\\'6\\',\\'9\\'}\\n        invalid = {\\'3\\',\\'4\\',\\'7\\'}\\n        result = 0\\n        for num in range(2, N+1):\\n            s = set(str(num))\\n            if s & invalid:\\n                continue\\n            elif s & valid:\\n                result += 1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        valid = {\\'2\\',\\'5\\',\\'6\\',\\'9\\'}\\n        invalid = {\\'3\\',\\'4\\',\\'7\\'}\\n        result = 0\\n        for num in range(2, N+1):\\n            s = set(str(num))\\n            if s & invalid:\\n                continue\\n            elif s & valid:\\n                result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288300,
                "title": "javascript-clear-simple-faster-than-100-56ms",
                "content": "```\\n\\nvar rotatedDigits = function(N) {\\n    count = 0\\n    for(i=1;i<N+1;i++){\\n        x = (\"\"+i).split(\"\")\\n        if(x.includes(\\'2\\') || x.includes(\\'5\\') || x.includes(\\'6\\') || x.includes(\\'9\\')){\\n            count += 1\\n            if(x.includes(\\'3\\') || x.includes(\\'4\\') || x.includes(\\'7\\')){\\n                count -= 1\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvar rotatedDigits = function(N) {\\n    count = 0\\n    for(i=1;i<N+1;i++){\\n        x = (\"\"+i).split(\"\")\\n        if(x.includes(\\'2\\') || x.includes(\\'5\\') || x.includes(\\'6\\') || x.includes(\\'9\\')){\\n            count += 1\\n            if(x.includes(\\'3\\') || x.includes(\\'4\\') || x.includes(\\'7\\')){\\n                count -= 1\\n            }\\n        }\\n    }\\n    return count\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 116527,
                "title": "o-len-n-method",
                "content": "Clearly we can do better than O(N) by reuse results from shorter numbers.\nHere is my O(len(N)) method. Took me some time in the contest...\n```\nclass Solution(object):\n    def rotatedDigits(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        same = [1, 2, 2, 2, 2, 2, 2, 2, 3, 3]\n        diff = [0, 0, 1, 1, 1, 2, 3, 3, 3, 4]\n        \n        def calc(num):\n            if len(num)==1:\n                return same[int(num)], diff[int(num)]\n            lead = int(num[0])\n            if lead == 0:\n                return calc(num[1:])\n            else:\n                n_s, n_d = calc('9'*(len(num)-1))\n                nxt_same, nxt_diff = calc(num[1:])\n                \n                s = same[lead-1] * n_s\n                if lead in [0, 1, 8]:\n                    s += nxt_same\n                \n                d = (same[lead-1]+diff[lead-1]) * n_d + diff[lead-1] * n_s\n                if lead in [0, 1, 8]:\n                    d += nxt_diff\n                if lead in [2, 5, 6, 9]:\n                    d += nxt_diff + nxt_same\n                \n                return s, d\n        \n        return calc(str(N))[1]\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def rotatedDigits(self, N):\n        \"\"\"\n        :type N: int\n        :rtype: int\n        \"\"\"\n        same = [1, 2, 2, 2, 2, 2, 2, 2, 3, 3]\n        diff = [0, 0, 1, 1, 1, 2, 3, 3, 3, 4]\n        \n        def calc(num):\n            if len(num)==1:\n                return same[int(num)], diff[int(num)]\n            lead = int(num[0])\n            if lead == 0:\n                return calc(num[1:])\n            else:\n                n_s, n_d = calc('9'*(len(num)-1))\n                nxt_same, nxt_diff = calc(num[1:])\n                \n                s = same[lead-1] * n_s\n                if lead in [0, 1, 8]:\n                    s += nxt_same\n                \n                d = (same[lead-1]+diff[lead-1]) * n_d + diff[lead-1] * n_s\n                if lead in [0, 1, 8]:\n                    d += nxt_diff\n                if lead in [2, 5, 6, 9]:\n                    d += nxt_diff + nxt_same\n                \n                return s, d\n        \n        return calc(str(N))[1]\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618289,
                "title": "c-easy-0ms-solution-with-comments-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        \\n        int count = 0 ;\\n        \\n        for(int i = 1 ; i<= n ; i++)\\n        {\\n            // Copy The Number\\n            int x = i;\\n            \\n            // We will be checking two conditions\\n            bool flag1 = false , flag = true ;\\n            \\n            while(x)\\n            {\\n                // get last digit of the number and remove that digit from current number\\n                int k = x%10;\\n                x = x/10;\\n                \\n                \\n                // if digit is 3 , 4 or  7 then there rotation will be invalid so break the loop\\n                // and make flag false\\n                if(k == 3 || k == 4 || k == 7 )\\n                {\\n                     flag = false ;\\n                      break;\\n                }\\n                \\n                // if digit is 6 , 9 , 5 or 2 there rotaion will be valid and value will be changed so make flag1 true\\n                else if( k == 6 || k == 9 || k == 5 || k == 2  )\\n                {\\n                   flag1 = true;\\n                }\\n                \\n            }\\n            \\n            // this condition says that if we encountered all valid digits and at least \\n            // one digit whose value changes after rotation than increment the answer\\n            if(flag && flag1)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/01cc07e2-4a14-4890-87dd-8dbbd12e0bdf_1664026410.8298378.png)\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        \\n        int count = 0 ;\\n        \\n        for(int i = 1 ; i<= n ; i++)\\n        {\\n            // Copy The Number\\n            int x = i;\\n            \\n            // We will be checking two conditions\\n            bool flag1 = false , flag = true ;\\n            \\n            while(x)\\n            {\\n                // get last digit of the number and remove that digit from current number\\n                int k = x%10;\\n                x = x/10;\\n                \\n                \\n                // if digit is 3 , 4 or  7 then there rotation will be invalid so break the loop\\n                // and make flag false\\n                if(k == 3 || k == 4 || k == 7 )\\n                {\\n                     flag = false ;\\n                      break;\\n                }\\n                \\n                // if digit is 6 , 9 , 5 or 2 there rotaion will be valid and value will be changed so make flag1 true\\n                else if( k == 6 || k == 9 || k == 5 || k == 2  )\\n                {\\n                   flag1 = true;\\n                }\\n                \\n            }\\n            \\n            // this condition says that if we encountered all valid digits and at least \\n            // one digit whose value changes after rotation than increment the answer\\n            if(flag && flag1)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137269,
                "title": "c-digit-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int, int> rotationMap;\\n\\n    int dp[10004][2][2];\\n\\n\\n    int solve(int pos, bool bound, int hasChanged, string &s) {\\n        if (pos == s.length()) {\\n\\n            if (hasChanged) return 1;\\n            return 0;\\n        }\\n\\n        int ans = 0;\\n        if (dp[pos][bound][hasChanged] != -1) return  dp[pos][bound][hasChanged];\\n\\n        int maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n        for (int digit = 0; digit <= maxDigit; digit++) {\\n            if (rotationMap.count(digit)) {\\n                ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), hasChanged || (rotationMap[digit] != digit), s);\\n            }\\n        }\\n\\n        return dp[pos][bound][hasChanged] = ans;\\n    }\\n\\n    int rotatedDigits(int n) {\\n        rotationMap[0] = 0;\\n        rotationMap[1] = 1;\\n        rotationMap[8] = 8;\\n\\n        rotationMap[2] = 5;\\n        rotationMap[5] = 2;\\n\\n        rotationMap[6] = 9;\\n        rotationMap[9] = 6;\\n        memset(dp, -1, sizeof(dp));\\n\\n        string s = to_string(n);\\n        return solve(0, true, false, s);\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, int> rotationMap;\\n\\n    int dp[10004][2][2];\\n\\n\\n    int solve(int pos, bool bound, int hasChanged, string &s) {\\n        if (pos == s.length()) {\\n\\n            if (hasChanged) return 1;\\n            return 0;\\n        }\\n\\n        int ans = 0;\\n        if (dp[pos][bound][hasChanged] != -1) return  dp[pos][bound][hasChanged];\\n\\n        int maxDigit = bound ? s[pos] - \\'0\\' : 9;\\n        for (int digit = 0; digit <= maxDigit; digit++) {\\n            if (rotationMap.count(digit)) {\\n                ans += solve(pos + 1, bound && (digit == s[pos] - \\'0\\'), hasChanged || (rotationMap[digit] != digit), s);\\n            }\\n        }\\n\\n        return dp[pos][bound][hasChanged] = ans;\\n    }\\n\\n    int rotatedDigits(int n) {\\n        rotationMap[0] = 0;\\n        rotationMap[1] = 1;\\n        rotationMap[8] = 8;\\n\\n        rotationMap[2] = 5;\\n        rotationMap[5] = 2;\\n\\n        rotationMap[6] = 9;\\n        rotationMap[9] = 6;\\n        memset(dp, -1, sizeof(dp));\\n\\n        string s = to_string(n);\\n        return solve(0, true, false, s);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399229,
                "title": "c-easy-digitdp-solution",
                "content": "The dp will we as follows::\\n\\t\\t\\t`dp[index][flag][leading_zeroes][mask] `\\n*index = index of the number which we are currently at \\nflag  = it tells us whether we are inside the limits \\nleadingzeroes = it tells us whether the number has started or we are still at the leading zeroes\\nmask  = keeps the track of the numbers which we have encountered at the current recussion \\n*\\n**AFTER ROTATION  ::**\\n*the invalid numbers *                         : :     `3 4 7`\\nthe numbers which remains same       : :       `0 1 8`\\nthe numbers which change                : :      `2 5 6 9`\\n\\n\\n**CODE EXPLANATION :: **\\n\\nAll the numbers are produced by using the index and flag parameters and (basic of DIGIT DP)\\nTo read more upon Digit Dp you may refer to this blog :: \\nhttps://codeforces.com/blog/entry/53960\\n\\nBase case :: \\n\\n\\t\\t1. we check whether the number contains any invalid digits or no if present we return 0\\n\\t\\t2. we check if it contains any digit which ehrn rotated gives another number then we return 1 because if these digits are there then it is guaranteed to produce a new number \\n\\t\\t3. if above conditions are not met then we return 0. \\n\\n\\n\\n###     CODE STARTS HERE :: \\n\\n```\\nlong long dp[6][2][2][1<<10];\\n    string s;\\n    int digitDP(int ind , int flag , int lead , int mask)\\n    {\\n        if (ind == s.size()) {\\n            if(mask&(1<<3) or mask&(1<<4) or mask&(1<<7))   return 0;\\n            if(mask&(1<<2) or mask&(1<<5) or mask&(1<<6) or mask&(1<<9))   return 1;\\n            return 0;\\n        }\\n        \\n        long long &ans = dp[ind][flag][lead][mask];\\n        if(ans != -1)   return ans;\\n        ans = 0 ;\\n        int limit = (flag==0) ? s[ind] - \\'0\\' : 9;\\n\\n        for (int i = 0; i <= limit; i++)\\n        {\\n            \\n            int nl = lead || (i>0);   //new_lead\\n            int nf = flag || (i<limit) ;  //new_flag\\n            \\n           if(nl)\\n               ans += digitDP(ind+1 , nf , nl , mask|(1<<i));\\n            else\\n                ans += digitDP(ind+1 , nf , nl , mask);\\n        }\\n        return ans;\\n    }\\n    \\n    int rotatedDigits(int n) {\\n        memset(dp , -1 , sizeof dp);\\n        while(n)\\n            s+= to_string(n%10) , n/=10;\\n        reverse(s.begin() , s.end());\\n        return digitDP(0 , 0 , 0 , 0);  //flag 0 mane within limit nite parbo\\n    }\\n```\\n\\nPlease upvote if this solution is of any help to you . \\n\\nKeep coding ..\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nlong long dp[6][2][2][1<<10];\\n    string s;\\n    int digitDP(int ind , int flag , int lead , int mask)\\n    {\\n        if (ind == s.size()) {\\n            if(mask&(1<<3) or mask&(1<<4) or mask&(1<<7))   return 0;\\n            if(mask&(1<<2) or mask&(1<<5) or mask&(1<<6) or mask&(1<<9))   return 1;\\n            return 0;\\n        }\\n        \\n        long long &ans = dp[ind][flag][lead][mask];\\n        if(ans != -1)   return ans;\\n        ans = 0 ;\\n        int limit = (flag==0) ? s[ind] - \\'0\\' : 9;\\n\\n        for (int i = 0; i <= limit; i++)\\n        {\\n            \\n            int nl = lead || (i>0);   //new_lead\\n            int nf = flag || (i<limit) ;  //new_flag\\n            \\n           if(nl)\\n               ans += digitDP(ind+1 , nf , nl , mask|(1<<i));\\n            else\\n                ans += digitDP(ind+1 , nf , nl , mask);\\n        }\\n        return ans;\\n    }\\n    \\n    int rotatedDigits(int n) {\\n        memset(dp , -1 , sizeof dp);\\n        while(n)\\n            s+= to_string(n%10) , n/=10;\\n        reverse(s.begin() , s.end());\\n        return digitDP(0 , 0 , 0 , 0);  //flag 0 mane within limit nite parbo\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1277567,
                "title": "super-simple-java-dfs-faster-than100",
                "content": "```\\nclass Solution {\\n    int count = 0;\\n    public int rotatedDigits(int n) {\\n        dfs(n, 0, 0);\\n        return count;\\n    }\\n    public void dfs(int n, int num, int d) {\\n        if (num > n) {\\n            return;\\n        }\\n        if (d > 0) {\\n            count++;\\n        }\\n        if (num > 0) {\\n            dfs(n, num * 10, d);\\n        }\\n        dfs(n, num * 10 + 8, d);\\n        dfs(n, num * 10 + 1, d);\\n        dfs(n, num * 10 + 2, d + 1);\\n        dfs(n, num * 10 + 5, d + 1);\\n        dfs(n, num * 10 + 6, d + 1);\\n        dfs(n, num * 10 + 9, d + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int rotatedDigits(int n) {\\n        dfs(n, 0, 0);\\n        return count;\\n    }\\n    public void dfs(int n, int num, int d) {\\n        if (num > n) {\\n            return;\\n        }\\n        if (d > 0) {\\n            count++;\\n        }\\n        if (num > 0) {\\n            dfs(n, num * 10, d);\\n        }\\n        dfs(n, num * 10 + 8, d);\\n        dfs(n, num * 10 + 1, d);\\n        dfs(n, num * 10 + 2, d + 1);\\n        dfs(n, num * 10 + 5, d + 1);\\n        dfs(n, num * 10 + 6, d + 1);\\n        dfs(n, num * 10 + 9, d + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747637,
                "title": "c-faster-than-100-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int c=0;\\n       for(int i=1;i<=N;i++)\\n       {\\n           if(check(i)==0)\\n               continue;\\n           else\\n               c++;\\n       }\\n        return c;\\n        \\n    }\\n    int check(int num)\\n    {\\n        int count=0;\\n        while(num>0)\\n        {\\n            int a=num%10;\\n            if(a==3||a==7||a==4)\\n                return 0;\\n            if(a==5||a==2||a==6||a==9)\\n                count++;\\n            num/=10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int c=0;\\n       for(int i=1;i<=N;i++)\\n       {\\n           if(check(i)==0)\\n               continue;\\n           else\\n               c++;\\n       }\\n        return c;\\n        \\n    }\\n    int check(int num)\\n    {\\n        int count=0;\\n        while(num>0)\\n        {\\n            int a=num%10;\\n            if(a==3||a==7||a==4)\\n                return 0;\\n            if(a==5||a==2||a==6||a==9)\\n                count++;\\n            num/=10;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746350,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int goodNumbers = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (isRotatedNumber(i))\\n                goodNumbers++;\\n        }\\n        return goodNumbers;\\n    }\\nprivate:\\n    bool isRotatedNumber(int n) {\\n        bool bRotated = false;\\n        while (n) {\\n            int digit = n % 10;\\n            if (digit == 3 || digit == 4 || digit == 7)\\n                return false;\\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9)\\n                bRotated = true;\\n            n /= 10;\\n        }\\n        return bRotated;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int goodNumbers = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (isRotatedNumber(i))\\n                goodNumbers++;\\n        }\\n        return goodNumbers;\\n    }\\nprivate:\\n    bool isRotatedNumber(int n) {\\n        bool bRotated = false;\\n        while (n) {\\n            int digit = n % 10;\\n            if (digit == 3 || digit == 4 || digit == 7)\\n                return false;\\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9)\\n                bRotated = true;\\n            n /= 10;\\n        }\\n        return bRotated;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 666800,
                "title": "easy-to-understand-c-code-100-time-100-space",
                "content": "**There are 3 cases that can affect solution.\\na) 1, 8,0 -> No affect to numbers.\\nb) 2,5,6,9 ->Changes values of numbers.\\nc) 3,4,7 -> makes number invalid.**\\n\\nWe should include all numbers containing case b except all numbers of case c.\\n\\n* Check for each number if it has any one of case b -> can be answer.\\n* Check for case c -> it will discard the number as answer. \\n\\n```\\nint rotatedDigits(int N) {\\n        int ans = 0, dig,temp,flag;\\n        for(int i=1;i<=N;i++){\\n            temp = i;\\n            flag =0;\\n            while(temp){\\n                dig = temp%10;\\n                if(dig == 2 ||dig == 5 ||dig == 6 ||dig == 9){\\n                    flag = 1;\\n                }\\n                else if(dig == 3 ||dig == 4 ||dig == 7 ){\\n                    flag = 2;\\n                    break;\\n                }\\n                temp = temp/10;\\n            }\\n            if(flag == 1)   ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint rotatedDigits(int N) {\\n        int ans = 0, dig,temp,flag;\\n        for(int i=1;i<=N;i++){\\n            temp = i;\\n            flag =0;\\n            while(temp){\\n                dig = temp%10;\\n                if(dig == 2 ||dig == 5 ||dig == 6 ||dig == 9){\\n                    flag = 1;\\n                }\\n                else if(dig == 3 ||dig == 4 ||dig == 7 ){\\n                    flag = 2;\\n                    break;\\n                }\\n                temp = temp/10;\\n            }\\n            if(flag == 1)   ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 564593,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean change(int n)\\n    {\\n        boolean res=false;\\n        while(n>0)\\n        {\\n            int i=n%10;\\n            if(i==3 || i==4 || i==7)\\n                return false;\\n            if(i==2 || i==5 || i==6 || i==9)\\n                res=true;\\n            n/=10;\\n        }\\n        return res;\\n    }\\n    public int rotatedDigits(int N) {\\n        int count=0;\\n        for(int i=1;i<=N;i++)\\n        {\\n            if(change(i))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean change(int n)\\n    {\\n        boolean res=false;\\n        while(n>0)\\n        {\\n            int i=n%10;\\n            if(i==3 || i==4 || i==7)\\n                return false;\\n            if(i==2 || i==5 || i==6 || i==9)\\n                res=true;\\n            n/=10;\\n        }\\n        return res;\\n    }\\n    public int rotatedDigits(int N) {\\n        int count=0;\\n        for(int i=1;i<=N;i++)\\n        {\\n            if(change(i))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494436,
                "title": "easy-python-100",
                "content": "```Python\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        self.good = set([2,5,6,9])\\n        self.bad = set([3,4,7])\\n        def isGoodNo(N):\\n            ans = False\\n            while N:\\n                if N%10 in self.bad:\\n                    return False\\n                if N%10 in self.good:\\n                    ans = True\\n                N//=10\\n            return ans   \\n        count = 0\\n        for i in range(1,N+1):\\n            if isGoodNo(i):\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        self.good = set([2,5,6,9])\\n        self.bad = set([3,4,7])\\n        def isGoodNo(N):\\n            ans = False\\n            while N:\\n                if N%10 in self.bad:\\n                    return False\\n                if N%10 in self.good:\\n                    ans = True\\n                N//=10\\n            return ans   \\n        count = 0\\n        for i in range(1,N+1):\\n            if isGoodNo(i):\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116541,
                "title": "c-3-ms-o-log10-n-solution",
                "content": "```\nclass Solution {\npublic:\n    int rotatedDigits(int N) {\n        static int goodsame[10] = {1,2,2,2,2,2,2,2,3,3};\n        static int gooddiff[10] = {0,0,1,1,1,2,3,3,3,4};\n        static int digittype[10]= {0,0,1,2,2,1,1,2,0,1};\n        if (N>9999)\n            return 0;\n        int count=0;\n        int foundfirst=0;\n        int vartype=0;\n        int nn=N;\n        int d=nn/1000;\n        if (d > 0) {\n            foundfirst=1;\n            vartype=digittype[d];\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += (goods*7*7*7 - goodsame[d-1]*3*3*3);\n        }\n        nn -= d*1000;\n        d=nn/100;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d > 0) {\n            foundfirst=1;\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += goods*7*7;\n            if (vartype==0)\n                count -= goodsame[d-1]*3*3;\n            vartype=(digittype[d] > vartype)? digittype[d]:vartype;\n        }\n        nn -= d*100;\n        d=nn/10;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d > 0) {\n            foundfirst=1;\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += goods*7;\n            if (vartype==0)\n                count -= goodsame[d-1]*3;\n            vartype=(digittype[d] > vartype)? digittype[d]:vartype;\n        }\n        nn -= d*10;\n        d = nn;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d >= 0) {\n            int goods=goodsame[d]+gooddiff[d];\n            count += goods;\n            if (vartype==0)\n                count -= goodsame[d];\n        }\n        return count;\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    int rotatedDigits(int N) {\n        static int goodsame[10] = {1,2,2,2,2,2,2,2,3,3};\n        static int gooddiff[10] = {0,0,1,1,1,2,3,3,3,4};\n        static int digittype[10]= {0,0,1,2,2,1,1,2,0,1};\n        if (N>9999)\n            return 0;\n        int count=0;\n        int foundfirst=0;\n        int vartype=0;\n        int nn=N;\n        int d=nn/1000;\n        if (d > 0) {\n            foundfirst=1;\n            vartype=digittype[d];\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += (goods*7*7*7 - goodsame[d-1]*3*3*3);\n        }\n        nn -= d*1000;\n        d=nn/100;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d > 0) {\n            foundfirst=1;\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += goods*7*7;\n            if (vartype==0)\n                count -= goodsame[d-1]*3*3;\n            vartype=(digittype[d] > vartype)? digittype[d]:vartype;\n        }\n        nn -= d*100;\n        d=nn/10;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d > 0) {\n            foundfirst=1;\n            int goods=goodsame[d-1]+gooddiff[d-1];\n            count += goods*7;\n            if (vartype==0)\n                count -= goodsame[d-1]*3;\n            vartype=(digittype[d] > vartype)? digittype[d]:vartype;\n        }\n        nn -= d*10;\n        d = nn;\n        if ((!foundfirst || (foundfirst && vartype<2)) && d >= 0) {\n            int goods=goodsame[d]+gooddiff[d];\n            count += goods;\n            if (vartype==0)\n                count -= goodsame[d];\n        }\n        return count;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822534,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int res = 0;\\n        while(n){\\n            int temp = n,judge = 1,diff = 0;\\n            while(temp){\\n                int y = temp % 10;\\n                if(y == 3 || y == 4 || y == 7){\\n                    judge = 0;\\n                    break;\\n                }\\n                if(y == 2 || y == 5 || y == 6 || y == 9){\\n                    diff = 1;\\n                }\\n                temp /= 10;\\n            }\\n            if(judge && diff){\\n                res++;\\n            }\\n            n--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int res = 0;\\n        while(n){\\n            int temp = n,judge = 1,diff = 0;\\n            while(temp){\\n                int y = temp % 10;\\n                if(y == 3 || y == 4 || y == 7){\\n                    judge = 0;\\n                    break;\\n                }\\n                if(y == 2 || y == 5 || y == 6 || y == 9){\\n                    diff = 1;\\n                }\\n                temp /= 10;\\n            }\\n            if(judge && diff){\\n                res++;\\n            }\\n            n--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465692,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool good(int x)\\n    {\\n        bool ans=false;\\n        int y;\\n        while(x>0)\\n        {\\n            y=x%10;\\n            switch(y)\\n            {\\n                case 0:\\n                case 1:\\n                case 8:\\n                    break;\\n                case 2:\\n                case 5:\\n                case 6:\\n                case 9:\\n                    ans=true;\\n                    break;\\n                default:\\n                    return false;\\n            }\\n            x/=10;\\n        }\\n        return ans;\\n    }\\n    int rotatedDigits(int n) {\\n        int c=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(good(i))\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def restrictedNumbersUsingDigits(self, n: int, digits: list) -> int:\\n        s = str(n)\\n        num_smaller_first_digits = len([d for d in digits if d <= int(s[0])])\\n        num_strictly_smaller_first_digits = len([d for d in digits if d < int(s[0])])\\n        num_digits = len(digits)\\n        if len(s) == 1:\\n            return num_smaller_first_digits\\n        if int(s[0]) in digits:\\n            same_first_digit_number =  self.restrictedNumbersUsingDigits(int(s[1:]), digits)\\n        else:\\n            same_first_digit_number = 0\\n        different_first_digit_number = num_strictly_smaller_first_digits * num_digits ** (len(s) - 1)\\n        return same_first_digit_number + different_first_digit_number\\n        \\n    def rotatedDigits(self, n: int) -> int:\\n        all_digits = [0, 1, 2, 5, 6, 8, 9]\\n        mediocre_digits = [0, 1, 8]\\n        total_numbers = self.restrictedNumbersUsingDigits(n, all_digits)\\n        mediocre_numbers = self.restrictedNumbersUsingDigits(n, mediocre_digits)\\n        return total_numbers - mediocre_numbers\\n```\\n\\n```Java []\\nclass Solution {\\n    int[] available = new int[]{0,1,2,5,6,8,9};\\n    int[] swaps = new int[]{2,5,6,9};\\n    public int rotatedDigits(int n) {\\n        List<Integer> arr = new ArrayList();\\n        int a = n;\\n        while(a > 0){\\n            arr.add(a % 10);\\n            a/=10;\\n        }\\n        int[] nums = new int[arr.size()];\\n        for(int i = 0; i < arr.size(); i++){\\n            nums[i] = arr.get(arr.size() - 1 - i);\\n        }\\n        return g(nums,0, false);\\n    }\\n    int g(int[] A, int index, boolean allowed){\\n        int ans = 0;\\n        if(index == A.length - 1){\\n            for(int i = 0; i <  available.length && available[i] <= A[index]; i++){\\n                if(swapsToDifferent(available[i]) || allowed) {\\n                    ans++;\\n                }\\n            }\\n        }else{\\n            for(int i = 0; i <  available.length && available[i] <= A[index]; i++){\\n                if(available[i] == A[index]){\\n                    int res = g(A, index + 1, allowed || swapsToDifferent(A[index]));\\n                    ans += res;\\n                }else{\\n                    int res = f(A.length - index - 1, allowed || swapsToDifferent(available[i]));\\n                    ans += res;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean swapsToDifferent(int number){\\n        for(int i : swaps){\\n            if(number == i) return true;\\n        }\\n        return false;\\n    }\\n    int f(int digits, boolean swapsToDifferent){\\n        if(digits == 0) return 0;\\n        if(digits == 1 && !swapsToDifferent) return 4;\\n        if(digits == 1 && swapsToDifferent) return 7;\\n        if(digits == 2 && !swapsToDifferent) return 40;\\n        if(digits == 2 && swapsToDifferent) return 49;\\n        if(digits == 3 && !swapsToDifferent) return 316;\\n        if(digits == 3 && swapsToDifferent) return 343;\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool good(int x)\\n    {\\n        bool ans=false;\\n        int y;\\n        while(x>0)\\n        {\\n            y=x%10;\\n            switch(y)\\n            {\\n                case 0:\\n                case 1:\\n                case 8:\\n                    break;\\n                case 2:\\n                case 5:\\n                case 6:\\n                case 9:\\n                    ans=true;\\n                    break;\\n                default:\\n                    return false;\\n            }\\n            x/=10;\\n        }\\n        return ans;\\n    }\\n    int rotatedDigits(int n) {\\n        int c=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(good(i))\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def restrictedNumbersUsingDigits(self, n: int, digits: list) -> int:\\n        s = str(n)\\n        num_smaller_first_digits = len([d for d in digits if d <= int(s[0])])\\n        num_strictly_smaller_first_digits = len([d for d in digits if d < int(s[0])])\\n        num_digits = len(digits)\\n        if len(s) == 1:\\n            return num_smaller_first_digits\\n        if int(s[0]) in digits:\\n            same_first_digit_number =  self.restrictedNumbersUsingDigits(int(s[1:]), digits)\\n        else:\\n            same_first_digit_number = 0\\n        different_first_digit_number = num_strictly_smaller_first_digits * num_digits ** (len(s) - 1)\\n        return same_first_digit_number + different_first_digit_number\\n        \\n    def rotatedDigits(self, n: int) -> int:\\n        all_digits = [0, 1, 2, 5, 6, 8, 9]\\n        mediocre_digits = [0, 1, 8]\\n        total_numbers = self.restrictedNumbersUsingDigits(n, all_digits)\\n        mediocre_numbers = self.restrictedNumbersUsingDigits(n, mediocre_digits)\\n        return total_numbers - mediocre_numbers\\n```\n```Java []\\nclass Solution {\\n    int[] available = new int[]{0,1,2,5,6,8,9};\\n    int[] swaps = new int[]{2,5,6,9};\\n    public int rotatedDigits(int n) {\\n        List<Integer> arr = new ArrayList();\\n        int a = n;\\n        while(a > 0){\\n            arr.add(a % 10);\\n            a/=10;\\n        }\\n        int[] nums = new int[arr.size()];\\n        for(int i = 0; i < arr.size(); i++){\\n            nums[i] = arr.get(arr.size() - 1 - i);\\n        }\\n        return g(nums,0, false);\\n    }\\n    int g(int[] A, int index, boolean allowed){\\n        int ans = 0;\\n        if(index == A.length - 1){\\n            for(int i = 0; i <  available.length && available[i] <= A[index]; i++){\\n                if(swapsToDifferent(available[i]) || allowed) {\\n                    ans++;\\n                }\\n            }\\n        }else{\\n            for(int i = 0; i <  available.length && available[i] <= A[index]; i++){\\n                if(available[i] == A[index]){\\n                    int res = g(A, index + 1, allowed || swapsToDifferent(A[index]));\\n                    ans += res;\\n                }else{\\n                    int res = f(A.length - index - 1, allowed || swapsToDifferent(available[i]));\\n                    ans += res;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean swapsToDifferent(int number){\\n        for(int i : swaps){\\n            if(number == i) return true;\\n        }\\n        return false;\\n    }\\n    int f(int digits, boolean swapsToDifferent){\\n        if(digits == 0) return 0;\\n        if(digits == 1 && !swapsToDifferent) return 4;\\n        if(digits == 1 && swapsToDifferent) return 7;\\n        if(digits == 2 && !swapsToDifferent) return 40;\\n        if(digits == 2 && swapsToDifferent) return 49;\\n        if(digits == 3 && !swapsToDifferent) return 316;\\n        if(digits == 3 && swapsToDifferent) return 343;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400716,
                "title": "rotated-digits-java-easy-approach",
                "content": "In this approach we run a loop from 1 to given number and call our function isGood which checks whether the no. contain 2,5,6,9 if it is then it returns a true, otherwise false. And we keep counting through count variable if it is true.\\n\\n```\\nclass Solution {\\n     public int rotatedDigits(int n) {\\n        int ans = 0;\\n        for (int i = 1; i <= n; i++)\\n            if (isGood(i))\\n                ans++;\\n            return ans;\\n     }\\n      public boolean isGood(int n) {\\n           boolean check = false;\\n        while (n > 0)\\n        {\\n            int k = n % 10;\\n            if (k == 2 || k == 5 || k == 6 || k == 9)\\n                check = true;\\n            if (k == 3 || k == 4 || k == 7)\\n                return false;\\n            n /= 10;\\n        }\\n        return check;\\n     }\\n}\\n```\\nSpace Complexity: - O(1)\\nTime complexity: - O(N)\\n\\n**Please upvote if you find the solution helpful.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public int rotatedDigits(int n) {\\n        int ans = 0;\\n        for (int i = 1; i <= n; i++)\\n            if (isGood(i))\\n                ans++;\\n            return ans;\\n     }\\n      public boolean isGood(int n) {\\n           boolean check = false;\\n        while (n > 0)\\n        {\\n            int k = n % 10;\\n            if (k == 2 || k == 5 || k == 6 || k == 9)\\n                check = true;\\n            if (k == 3 || k == 4 || k == 7)\\n                return false;\\n            n /= 10;\\n        }\\n        return check;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107725,
                "title": "0ms-faster-than-100-cpp-easy-solution",
                "content": "Basic idea behind this question is-\\n i) a number containing **3,4,7** can never be a good number.\\n ii) a number containing **only 0,1,8** can never be a good number.\\n iii) Rest all numbers are good numbers.\\n Here is the Code->\\n \\n\\t\\t  bool f(int k){\\n\\t\\t\\t\\tint n=k;\\n\\t\\t\\t\\tint total=0,c=0;\\n\\t\\t\\t\\tint a;\\n\\t\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\t\\t\\t\\ttotal++; //counts total digits in number k\\n\\t\\t\\t\\t\\t\\t\\ta = n%10;\\n\\t\\t\\t\\t\\t\\t\\tif(a==3 || a==4 || a==7) return false;  // return false if number k contains 3,4,7\\n\\t\\t\\t\\t\\t\\t\\tif(a==0 || a==1 || a==8 ) c++; //counts number of 0,1,8 in number k\\n            \\n\\t\\t\\t\\t\\t\\t\\tn=n/10;\\n        }\\n        return (c==total)?false:true;   //checks if number k contains only 0,1,8\\n    }\\n    int rotatedDigits(int n) {\\n        long long ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(f(i)) ans++;\\n        }\\n        return ans;\\n    }\\n Please Do upvote this, if you find this solution helping.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "Basic idea behind this question is-\\n i) a number containing **3,4,7** can never be a good number.\\n ii) a number containing **only 0,1,8** can never be a good number.\\n iii) Rest all numbers are good numbers.\\n Here is the Code->\\n \\n\\t\\t  bool f(int k){\\n\\t\\t\\t\\tint n=k;\\n\\t\\t\\t\\tint total=0,c=0;\\n\\t\\t\\t\\tint a;\\n\\t\\t\\t\\twhile(n!=0){\\n\\t\\t\\t\\t\\t\\t\\ttotal++; //counts total digits in number k\\n\\t\\t\\t\\t\\t\\t\\ta = n%10;\\n\\t\\t\\t\\t\\t\\t\\tif(a==3 || a==4 || a==7) return false;  // return false if number k contains 3,4,7\\n\\t\\t\\t\\t\\t\\t\\tif(a==0 || a==1 || a==8 ) c++; //counts number of 0,1,8 in number k\\n            \\n\\t\\t\\t\\t\\t\\t\\tn=n/10;\\n        }\\n        return (c==total)?false:true;   //checks if number k contains only 0,1,8\\n    }\\n    int rotatedDigits(int n) {\\n        long long ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(f(i)) ans++;\\n        }\\n        return ans;\\n    }\\n Please Do upvote this, if you find this solution helping.",
                "codeTag": "Unknown"
            },
            {
                "id": 1792438,
                "title": "very-easy-c-implementation-with-easy-to-understand-explanation",
                "content": "**Observations-**\\n* We know that if a number contains 3, 4 or 7 then it\\'s not a good number.\\n* And if the number contains 2, 5, 6 or 9 then it can be rotated hence it can be a good number unless there is 3, 4 or 7 in the number.\\n\\nSo we will iterate through the digits of the number and check each digit for the conditions stated in the observations.\\n\\nBelow is C++ implementation of the approach-\\n\\n```\\nclass Solution {\\npublic:\\n    bool isGood(string s){\\n        bool isChanged=false;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'3\\' ||s[i]==\\'4\\' ||s[i]==\\'7\\')return false;\\n            if(s[i]==\\'2\\'|| s[i]==\\'5\\' || s[i]==\\'6\\'||s[i]==\\'9\\'){\\n                isChanged=true;\\n            }\\n        }\\n        return isChanged;\\n    }\\n    int rotatedDigits(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(isGood(to_string(i)))ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you liked it... :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGood(string s){\\n        bool isChanged=false;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'3\\' ||s[i]==\\'4\\' ||s[i]==\\'7\\')return false;\\n            if(s[i]==\\'2\\'|| s[i]==\\'5\\' || s[i]==\\'6\\'||s[i]==\\'9\\'){\\n                isChanged=true;\\n            }\\n        }\\n        return isChanged;\\n    }\\n    int rotatedDigits(int n) {\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            if(isGood(to_string(i)))ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392591,
                "title": "easy-to-understand-100ms-digit-dp-c",
                "content": "class Solution {\\npublic:\\n\\n\\n\\n    int dp[6][2][2];\\n    int digit(string s, int n, bool tight, bool newnum)\\n    {\\n        if(n==0)\\n        {\\n            if(newnum)// to check have we ever incorporated a rotatable digit\\n                return 1;\\n            else\\n                return 0;\\n        }\\n        \\n        if(dp[n][tight][newnum]!=-1)\\n            return dp[n][tight][newnum];\\n            \\n            int ans=0;\\n        \\n            int ub= tight? s[s.size()-n]-\\'0\\': 9;\\n        \\n          for(int dig=0; dig<=ub; dig++)\\n          {\\n              if(dig==3 || dig == 7 || dig==4 )// we know if we incorporate these digits into our digit formation we will never be able to rotate it.\\n                  continue;\\n              \\n              if((dig==2 || dig==5 || dig==6 || dig==9))// if have atleast one of the rotateable digit we will be getting some new digit after rotation.\\n                  ans+= digit(s, n-1, tight && (dig== ub), 1);\\n              else\\n                  ans+= digit(s, n-1, tight && (dig==ub), newnum);\\n          }\\n        \\n        return dp[n][tight][newnum]= ans;\\n    }\\n    int rotatedDigits(int n) {\\n        \\n        string s= to_string(n);\\n        memset(dp, -1, sizeof(dp));\\n        return digit(s, s.size(), 1, 0);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n\\n    int dp[6][2][2];\\n    int digit(string s, int n, bool tight, bool newnum)\\n    {\\n        if(n==0)\\n        {\\n            if(newnum)// to check have we ever incorporated a rotatable digit\\n                return 1;\\n            else\\n                return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1389730,
                "title": "java-soln-faster-than-94-6-using-dynamic-programming",
                "content": "\\tpublic int rotatedDigits(int n) {\\n\\t\\t\\n\\t\\tint dp[] = new int[n+1];\\n        if(n<=1){\\n            return 0;\\n        }else if(n<=4){\\n            return 1;\\n        }else if(n<=5){\\n            return 2;\\n        }else if(n<=8){\\n            return 3;\\n        }else if(n<=10){\\n            return 4;\\n        }\\n        \\n        for(int i = 0 ; i<10; i++){\\n            if(i == 2 || i == 5 || i == 6 || i == 9){\\n                dp[i] = 1;\\n            }else if(i==0 || i == 1 || i==8){\\n                dp[i] = 2;                \\n            }\\n        }\\n        \\n        for(int i = 10 ; i<n+1; i++){\\n            int up = i%10;\\n            int rod = i /10;\\n            \\n            if(dp[up] == 0 || dp[rod] == 0){\\n                dp[i] = 0;\\n            }else if( (dp[up] == 1 && (dp[rod] == 1 || dp[rod] == 2)) || (dp[rod] ==1 && (dp[rod] == 2 || dp[rod] == 1)) ) {\\n                dp[i] = 1;\\n            }else if( (dp[up] == 2 && dp[rod] == 2) || (dp[rod]==2 && dp[up] ==2)){\\n                dp[i] = 2;\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i =2; i< n+1; i++){\\n            if(dp[i] == 1) count++;\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int rotatedDigits(int n) {\\n\\t\\t\\n\\t\\tint dp[] = new int[n+1];\\n        if(n<=1){\\n            return 0;\\n        }else if(n<=4){\\n            return 1;\\n        }else if(n<=5){\\n            return 2;\\n        }else if(n<=8){\\n            return 3;\\n        }else if(n<=10){\\n            return 4;\\n        }\\n        \\n        for(int i = 0 ; i<10; i++){\\n            if(i == 2 || i == 5 || i == 6 || i == 9){\\n                dp[i] = 1;\\n            }else if(i==0 || i == 1 || i==8){\\n                dp[i] = 2;                \\n            }\\n        }\\n        \\n        for(int i = 10 ; i<n+1; i++){\\n            int up = i%10;\\n            int rod = i /10;\\n            \\n            if(dp[up] == 0 || dp[rod] == 0){\\n                dp[i] = 0;\\n            }else if( (dp[up] == 1 && (dp[rod] == 1 || dp[rod] == 2)) || (dp[rod] ==1 && (dp[rod] == 2 || dp[rod] == 1)) ) {\\n                dp[i] = 1;\\n            }else if( (dp[up] == 2 && dp[rod] == 2) || (dp[rod]==2 && dp[up] ==2)){\\n                dp[i] = 2;\\n            }\\n        }\\n        \\n        int count = 0;\\n        for(int i =2; i< n+1; i++){\\n            if(dp[i] == 1) count++;\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1300065,
                "title": "c-easy-2-approach",
                "content": "class Solution {\\npublic:\\n    \\n\\t\\n# \\tMethod 1:\\n    //using dp\\n    /*\\n    0--invalid 3 4 7 \\n    1--valid 1 8 0\\n    2--good 2 5 6 9\\n    */\\n    int rotatedDigitsHelper(int n){\\n        int count=0;\\n        int *dp=new int[n+1];\\n        for(int i=0;i<=n;i++){\\n            if(i<10){\\n                if(i==0||i==1||i==8){ //valid \\n                    dp[i]=1;\\n                }\\n                else if(i==2||i==5||i==6||i==9){//good\\n                    count++;\\n                    dp[i]=2;\\n                }\\n                else{dp[i]=0;} //invalid\\n            }\\n            else{\\n                int digit=dp[i%10];\\n                int num=dp[i/10];\\n                if(num==1 && digit==1) dp[i]=1; //contain valid only\\n                else if(num>=1 && digit>=1) {count++; dp[i]=2;} \\n            }\\n        }\\n        //free memory\\n        delete[] dp; \\n        return count;\\n    }\\n    int rotatedDigits(int n){\\n        return rotatedDigitsHelper(n);\\n    }\\n    \\n# \\tMethod2:\\n\\t\\n    //brute force\\n    bool isGood(int n){\\n        int rotating =false;\\n        while(n){\\n            int d=n%10;\\n            if(d==3||d==4||d==7) return false;\\n            if(d==2||d==5||d==6||d==9) rotating =true;\\n            n/=10;\\n        }\\n        return rotating;\\n    }\\n    \\n    int rotatedDigitsRec(int n) {\\n      int count=0;  \\n      for(int i=1;i<=n;i++)  \\n        if(isGood(i)) count++;\\n      return count;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n\\t\\n# \\tMethod 1:\\n    //using dp\\n    /*\\n    0--invalid 3 4 7 \\n    1--valid 1 8 0\\n    2--good 2 5 6 9\\n    */\\n    int rotatedDigitsHelper(int n){\\n        int count=0;\\n        int *dp=new int[n+1];\\n        for(int i=0;i<=n;i++){\\n            if(i<10){\\n                if(i==0||i==1||i==8){ //valid \\n                    dp[i]=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1248603,
                "title": "python-easy-implementation-commented-line-wise",
                "content": "class Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        \\n\\t\\tcount = 0\\n        for i in range(1, n+1):\\n\\t\\t    #convert in string, easy to work with digit of varying length\\n            i = str(i)\\n\\t\\t\\t# if any value in between contain 3,4,7 then that value becomes invalid, should not be counted\\n            if \\'3\\' in i or \\'4\\' in i or \\'7\\' in i:\\n                continue\\n\\t\\t\\t#only for 2,5,6,9 we can see change happen, and when there\\'s a change number will change.\\n            if \\'2\\' in i or \\'5\\' in i or \\'6\\' in i or \\'9\\' in i:\\n                count+=1\\n        return count\\n                    \\n                    \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        \\n\\t\\tcount = 0\\n        for i in range(1, n+1):\\n\\t\\t    #convert in string, easy to work with digit of varying length\\n            i = str(i)\\n\\t\\t\\t# if any value in between contain 3,4,7 then that value becomes invalid, should not be counted\\n            if \\'3\\' in i or \\'4\\' in i or \\'7\\' in i:\\n                continue\\n\\t\\t\\t#only for 2,5,6,9 we can see change happen, and when there\\'s a change number will change.\\n            if \\'2\\' in i or \\'5\\' in i or \\'6\\' in i or \\'9\\' in i:\\n                count+=1\\n        return count\\n                    \\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1167460,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n\\n    public int rotatedDigits(int N) {\\n        \\n        int count = 0;\\n        \\n        for (int i = 1; i <= N; i++) {\\n            \\n            if (canRotate(i) && hasRotatableDigit(i)) {\\n                count++;\\n            } \\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    \\n    private boolean canRotate(int num) {\\n        \\n        while (num > 0) {\\n            int r = num % 10;\\n            if (r == 3 || r == 4 || r == 7) {\\n                return false;\\n            }\\n            \\n            num /= 10;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    private boolean hasRotatableDigit(int num) {\\n        \\n        while (num > 0) {\\n            int r = num % 10;\\n            if (r == 2 || r == 5 || r == 6 || r == 9) {\\n                return true;\\n            }\\n            \\n            num /= 10;\\n        }\\n        \\n        return false;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int rotatedDigits(int N) {\\n        \\n        int count = 0;\\n        \\n        for (int i = 1; i <= N; i++) {\\n            \\n            if (canRotate(i) && hasRotatableDigit(i)) {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1049060,
                "title": "simple-c-using-strings",
                "content": "```\\n    int rotatedDigits(int N) {\\n        int count = 0;\\n        \\n        for (int i = 1; i <= N; i++) {\\n            bool isgood = false;\\n            \\n            string s = to_string(i);\\n            for (char& c : s) {\\n                if ( == \\'3\\' || c == \\'4\\' || c == \\'7\\') {\\n                    isgood = false;\\n                    break;\\n                }\\n                else if (c == \\'2\\' || c == \\'5\\' || c == \\'6\\' || c == \\'9\\')\\n                    isgood = true;\\n            }\\n            if (isgood)\\n                count++;\\n        }\\n        return count;      \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int rotatedDigits(int N) {\\n        int count = 0;\\n        \\n        for (int i = 1; i <= N; i++) {\\n            bool isgood = false;\\n            \\n            string s = to_string(i);\\n            for (char& c : s) {\\n                if ( == \\'3\\' || c == \\'4\\' || c == \\'7\\') {\\n                    isgood = false;\\n                    break;\\n                }\\n                else if (c == \\'2\\' || c == \\'5\\' || c == \\'6\\' || c == \\'9\\')\\n                    isgood = true;\\n            }\\n            if (isgood)\\n                count++;\\n        }\\n        return count;      \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 829096,
                "title": "ruby-solution-with-explanation-104ms",
                "content": "```\\n# @param {Integer} n\\n# @return {Integer}\\n\\n# Runtime: 104 ms, faster than 82.35% of Ruby online submissions for Rotated Digits.\\n# Memory Usage: 10.1 MB, less than 35.29% of Ruby online submissions for Rotated Digits.\\ndef rotated_digits(n)\\n  return (1..n).count do |i|\\n    digits = i.digits\\n     \\n    # if [3,4,7] is inside digits, it is no good\\n    # if [0,1,8] are the only types of numbers that \"digits\" have it is no good\\n    !digits.any? { |digit| [3, 4, 7].include?(digit) } && !digits.all? { |digit| [0, 1, 8].include?(digit) }\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer}\\n\\n# Runtime: 104 ms, faster than 82.35% of Ruby online submissions for Rotated Digits.\\n# Memory Usage: 10.1 MB, less than 35.29% of Ruby online submissions for Rotated Digits.\\ndef rotated_digits(n)\\n  return (1..n).count do |i|\\n    digits = i.digits\\n     \\n    # if [3,4,7] is inside digits, it is no good\\n    # if [0,1,8] are the only types of numbers that \"digits\" have it is no good\\n    !digits.any? { |digit| [3, 4, 7].include?(digit) } && !digits.all? { |digit| [0, 1, 8].include?(digit) }\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 756817,
                "title": "python-simple-solution-in-one-line",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        \\n        return len([i  for i in range(1, N+1) if (\\'2\\' in str(i) or  \\'5\\' in str(i) or  \\'6\\' in str(i) or  \\'9\\' in str(i)) and (\\'3\\' not in str(i) and  \\'4\\' not in str(i) and  \\'7\\' not in str(i))]) \\n```\\n\\nIncase it\\'s not clear, feel free to ask!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        \\n        return len([i  for i in range(1, N+1) if (\\'2\\' in str(i) or  \\'5\\' in str(i) or  \\'6\\' in str(i) or  \\'9\\' in str(i)) and (\\'3\\' not in str(i) and  \\'4\\' not in str(i) and  \\'7\\' not in str(i))]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 670117,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int fans=0;\\n        for(int i=1;i<= N;i++){\\n            int mult=1;\\n            int ans=0;\\n            int num = i;\\n            if(isvalid(num)){\\n                 while(num !=0){\\n                     int rem= num %10;\\n                     ans = ans+ mult* afterrotation(rem);\\n                     mult=mult*10;\\n                     num=num/10;\\n                 }\\n                if(ans != i) fans++;\\n            }\\n            \\n            \\n        }\\n        \\n        return fans;\\n        \\n        \\n    }\\n    \\n    \\n    public int afterrotation(int n){\\n       if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==8) return 8;\\n        if(n==2) return 5;\\n        if(n==5) return 2;\\n        if(n==6) return 9;\\n        if(n==9) return 6;\\n        return -1;\\n    }\\n    \\n    \\n    \\n    public boolean isvalid(int n){\\n        while(n!=0){\\n            int rem= n%10;\\n            if(rem == 3 || rem == 4 || rem==7){\\n                return false;\\n            }\\n            n=n/10;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int fans=0;\\n        for(int i=1;i<= N;i++){\\n            int mult=1;\\n            int ans=0;\\n            int num = i;\\n            if(isvalid(num)){\\n                 while(num !=0){\\n                     int rem= num %10;\\n                     ans = ans+ mult* afterrotation(rem);\\n                     mult=mult*10;\\n                     num=num/10;\\n                 }\\n                if(ans != i) fans++;\\n            }\\n            \\n            \\n        }\\n        \\n        return fans;\\n        \\n        \\n    }\\n    \\n    \\n    public int afterrotation(int n){\\n       if(n==0) return 0;\\n        if(n==1) return 1;\\n        if(n==8) return 8;\\n        if(n==2) return 5;\\n        if(n==5) return 2;\\n        if(n==6) return 9;\\n        if(n==9) return 6;\\n        return -1;\\n    }\\n    \\n    \\n    \\n    public boolean isvalid(int n){\\n        while(n!=0){\\n            int rem= n%10;\\n            if(rem == 3 || rem == 4 || rem==7){\\n                return false;\\n            }\\n            n=n/10;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 618941,
                "title": "java-dp",
                "content": "orig: https://leetcode.com/problems/rotated-digits/discuss/117975/Java-dp-solution-9ms\\n```\\n    public int rotatedDigits(int N) {\\n        int[] dp = new int[N+1];\\n        int res = 0;\\n        Set<Integer> s1 = Set.of(0, 1, 8), s2 = Set.of(2, 5, 6, 9);\\n        for (int i = 0; i < Math.min(10, N + 1); i++) {\\n            if (s1.contains(i)) dp[i] = 1;\\n            else if (s2.contains(i)) {\\n                dp[i] = 2;\\n                res++;\\n            }\\n        }\\n        for (int i = 10; i <= N; i++) {\\n            int a = dp[i / 10],  b = dp[i % 10];\\n            if (a == 1 && b == 1) dp[i] = 1;\\n            else if (a >= 1 && b >= 1) {\\n                dp[i] = 2;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int rotatedDigits(int N) {\\n        int[] dp = new int[N+1];\\n        int res = 0;\\n        Set<Integer> s1 = Set.of(0, 1, 8), s2 = Set.of(2, 5, 6, 9);\\n        for (int i = 0; i < Math.min(10, N + 1); i++) {\\n            if (s1.contains(i)) dp[i] = 1;\\n            else if (s2.contains(i)) {\\n                dp[i] = 2;\\n                res++;\\n            }\\n        }\\n        for (int i = 10; i <= N; i++) {\\n            int a = dp[i / 10],  b = dp[i % 10];\\n            if (a == 1 && b == 1) dp[i] = 1;\\n            else if (a >= 1 && b >= 1) {\\n                dp[i] = 2;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 573571,
                "title": "python-intuitive-code",
                "content": "```\\ndict_ = {0:0,1:1,2:5,5:2,6:9,8:8,9:6} # mirrors - 180 degrees\\ns = str(N)\\ncount = 0\\n\\nfor i in range(1, N+1):\\n\\tclone = \"\"\\n\\ts = str(i)\\n\\tnot_in_dict = True\\n\\tfor digit in s:\\n\\t\\ta = int(digit)\\n\\t\\tif a in dict_:\\n\\t\\t\\tclone += str(dict_[a])\\n\\t\\telse:\\n\\t\\t\\tnot_in_dict = False\\n\\n\\tif not_in_dict == True:\\n\\t\\tnew_image_number = int(clone)\\n\\t\\tif new_image_number != i:\\n\\t\\t\\tcount += 1\\n\\nprint(count)\\nreturn count\\n```",
                "solutionTags": [],
                "code": "```\\ndict_ = {0:0,1:1,2:5,5:2,6:9,8:8,9:6} # mirrors - 180 degrees\\ns = str(N)\\ncount = 0\\n\\nfor i in range(1, N+1):\\n\\tclone = \"\"\\n\\ts = str(i)\\n\\tnot_in_dict = True\\n\\tfor digit in s:\\n\\t\\ta = int(digit)\\n\\t\\tif a in dict_:\\n\\t\\t\\tclone += str(dict_[a])\\n\\t\\telse:\\n\\t\\t\\tnot_in_dict = False\\n\\n\\tif not_in_dict == True:\\n\\t\\tnew_image_number = int(clone)\\n\\t\\tif new_image_number != i:\\n\\t\\t\\tcount += 1\\n\\nprint(count)\\nreturn count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 551837,
                "title": "python3-solution-using-a-string-conversion",
                "content": "Convert the number to a string, then check for any() and all() of the filtering digits.\\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        quantity = 0\\n        for num in range(1, N+1):\\n            tally = str(num)\\n            if any([True if x in \\'347\\' else False for x in tally]):\\n                continue\\n            if all([True if x in \\'018\\' else False for x in tally]):\\n                continue\\n            quantity += 1\\n        return quantity\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        quantity = 0\\n        for num in range(1, N+1):\\n            tally = str(num)\\n            if any([True if x in \\'347\\' else False for x in tally]):\\n                continue\\n            if all([True if x in \\'018\\' else False for x in tally]):\\n                continue\\n            quantity += 1\\n        return quantity\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538741,
                "title": "simple-java-explained",
                "content": "```\\n//Check if the number contains the desired digits ( 2 5 6 9 ). If yes, just make sure that no remaining digits are invalid. \\n//Else, false\\npublic int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(!isGoodNumber(i)) continue;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    private boolean isGoodNumber(int N) {\\n        boolean foundGoodDigit = false;\\n        while(N > 0) {\\n            int rem = N%10;\\n            N /= 10;\\n            if(rem == 2 || rem == 5 || rem == 6 || rem == 9) {\\n                foundGoodDigit = true;\\n            }\\n            if(rem == 3 || rem == 4 || rem == 7) return false;\\n        }\\n        return foundGoodDigit;\\n    }",
                "solutionTags": [],
                "code": "```\\n//Check if the number contains the desired digits ( 2 5 6 9 ). If yes, just make sure that no remaining digits are invalid. \\n//Else, false\\npublic int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(!isGoodNumber(i)) continue;\\n            count++;\\n        }\\n        return count;\\n    }\\n\\n    private boolean isGoodNumber(int N) {\\n        boolean foundGoodDigit = false;\\n        while(N > 0) {\\n            int rem = N%10;\\n            N /= 10;\\n            if(rem == 2 || rem == 5 || rem == 6 || rem == 9) {\\n                foundGoodDigit = true;\\n            }\\n            if(rem == 3 || rem == 4 || rem == 7) return false;\\n        }\\n        return foundGoodDigit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 435449,
                "title": "c-o-logn-time-code-similar-as-lc1012",
                "content": "get intution from lee215\\'s post:\\n[1012. Count the Number Without Repeated Digit]( https://leetcode.com/problems/numbers-with-repeated-digits/discuss/256725/JavaPython-Count-the-Number-Without-Repeated-Digiot)\\nTheir structure is very similar\\n\\nif you have read the post above, it would be easy to understand my code \\n```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        vector<int> digits;\\n        int res = 0;\\n        \\n        for (int i = N + 1; i > 0; i /= 10) {\\n            digits.push_back(i % 10);\\n        }\\n        reverse(digits.begin(), digits.end());\\n        \\n        int n = digits.size();\\n        int flag = 0, j =0, k = 0;\\n        int spNum[7] = {0, 1, 2, 5, 6, 8, 9};\\n        \\n        for (int i = 0; i < n; i++){\\n            for (j = 0, k = 0; spNum[j] < digits[i]; j++){\\n                if (flag) continue;\\n                if (spNum[j] == 0 || spNum[j] == 1 || spNum[j] == 8) k++;\\n            }\\n            res += j * pow(7, n - i - 1) - k * pow(3, n - i - 1);\\n            if (digits[i] == 2 || digits[i] == 5 || digits[i] == 6 || digits[i] == 9) flag = 1;\\n            if (digits[i] == 3 || digits[i] == 4 || digits[i] == 7) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        vector<int> digits;\\n        int res = 0;\\n        \\n        for (int i = N + 1; i > 0; i /= 10) {\\n            digits.push_back(i % 10);\\n        }\\n        reverse(digits.begin(), digits.end());\\n        \\n        int n = digits.size();\\n        int flag = 0, j =0, k = 0;\\n        int spNum[7] = {0, 1, 2, 5, 6, 8, 9};\\n        \\n        for (int i = 0; i < n; i++){\\n            for (j = 0, k = 0; spNum[j] < digits[i]; j++){\\n                if (flag) continue;\\n                if (spNum[j] == 0 || spNum[j] == 1 || spNum[j] == 8) k++;\\n            }\\n            res += j * pow(7, n - i - 1) - k * pow(3, n - i - 1);\\n            if (digits[i] == 2 || digits[i] == 5 || digits[i] == 6 || digits[i] == 9) flag = 1;\\n            if (digits[i] == 3 || digits[i] == 4 || digits[i] == 7) break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378707,
                "title": "java-2ms-solution-with-explanation",
                "content": "/*\\nthe problem can be rephrased as:\\nfind numbers from [1,N], which should:\\n1. Can\\'t contain any one digit of 3,4,7   (invalid digits)\\n2. Must contain at least one digit in:  2,5,6,9        (update digits)    \\n\\ndigits of 0,1,8 doesn\\'t matter to this problem. \\n\\nin order to achieve above.\\n1. first create a table to init value for digit 0 -9 as below: -1 means invalid numbers, 1 means it change values, 0 doesn\\'t matter\\n        int[] validTable= {0,0,1,-1,-1,1,1,-1,0,1};\\n2. check each number i, by check each digits of i against it.\\n\\n*/\\n```\\nclass Solution {   \\n    \\n    public int rotatedDigits(int N) {\\n        \\n        //need contains one of 2,5,6,9, can\\'t container 3,4,7         \\n        //0,1,8 will be 0,  2,5,6,9 will be 1,  3,4,7:2\\n        int[] validTable= {0,0,1,-1,-1,1,1,-1,0,1};\\n        int res = 0;\\n        for(int i=2; i<=N; i++) {\\n            if(isGoodNumber(validTable,i)) res++;            \\n        }\\n        return res;\\n        \\n    }\\n    \\n    private boolean isGoodNumber(int[] validTable,int num) {\\n        //in order to be a good number, num mustn\\'t contain any digits of 3,4,7, \\n        //and must contain one of 2,5,6,9\\n        //0,1,8 has no effect on the result;\\n        \\n        boolean isDifferent = false;\\n        while(num>0){\\n            int digit = num%10;\\n            if(validTable[digit]==-1) return false;\\n            else if (validTable[digit]==1) isDifferent=true;\\n            num/=10;\\n        }\\n        return isDifferent;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {   \\n    \\n    public int rotatedDigits(int N) {\\n        \\n        //need contains one of 2,5,6,9, can\\'t container 3,4,7         \\n        //0,1,8 will be 0,  2,5,6,9 will be 1,  3,4,7:2\\n        int[] validTable= {0,0,1,-1,-1,1,1,-1,0,1};\\n        int res = 0;\\n        for(int i=2; i<=N; i++) {\\n            if(isGoodNumber(validTable,i)) res++;            \\n        }\\n        return res;\\n        \\n    }\\n    \\n    private boolean isGoodNumber(int[] validTable,int num) {\\n        //in order to be a good number, num mustn\\'t contain any digits of 3,4,7, \\n        //and must contain one of 2,5,6,9\\n        //0,1,8 has no effect on the result;\\n        \\n        boolean isDifferent = false;\\n        while(num>0){\\n            int digit = num%10;\\n            if(validTable[digit]==-1) return false;\\n            else if (validTable[digit]==1) isDifferent=true;\\n            num/=10;\\n        }\\n        return isDifferent;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352128,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count=0;\\n        for(int i=1; i<=N; i++)\\n            if(isValid(i)) count++;\\n        return count;\\n    }\\n    \\n    public boolean isValid(int n){\\n        boolean valid = false;\\n        while(n > 0){\\n        if((n % 10) == 2 || (n % 10) == 5 || (n % 10) == 6 || (n % 10) == 9)\\n            valid = true; \\n        if((n % 10) == 3 || (n % 10) == 4 || (n % 10) == 7)\\n            return false;\\n        n /= 10;\\n        }    \\n        return valid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count=0;\\n        for(int i=1; i<=N; i++)\\n            if(isValid(i)) count++;\\n        return count;\\n    }\\n    \\n    public boolean isValid(int n){\\n        boolean valid = false;\\n        while(n > 0){\\n        if((n % 10) == 2 || (n % 10) == 5 || (n % 10) == 6 || (n % 10) == 9)\\n            valid = true; \\n        if((n % 10) == 3 || (n % 10) == 4 || (n % 10) == 7)\\n            return false;\\n        n /= 10;\\n        }    \\n        return valid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343982,
                "title": "solution-in-python-3-beats-100-o-log-n-combinatoric-solution-not-brute-force",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n    \\tN, t, c = str(N), 0, 1\\n    \\tL, a, b = len(N) - 1, [1,2,3,3,3,4,5,5,6,7], [1,2,2,2,2,2,2,2,3,3] \\n    \\t\\n    \\tfor i in range(L):\\n    \\t\\tif N[i] == \\'0\\': continue\\n    \\t\\tt += a[int(N[i])-1]*7**(L-i) - c*b[int(N[i])-1]*3**(L-i)\\n    \\t\\tif N[i] in \\'347\\': return t\\n    \\t\\tif N[i] not in \\'18\\': c = 0\\n    \\treturn t + a[int(N[-1])] - c*b[int(N[-1])]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n    \\tN, t, c = str(N), 0, 1\\n    \\tL, a, b = len(N) - 1, [1,2,3,3,3,4,5,5,6,7], [1,2,2,2,2,2,2,2,3,3] \\n    \\t\\n    \\tfor i in range(L):\\n    \\t\\tif N[i] == \\'0\\': continue\\n    \\t\\tt += a[int(N[i])-1]*7**(L-i) - c*b[int(N[i])-1]*3**(L-i)\\n    \\t\\tif N[i] in \\'347\\': return t\\n    \\t\\tif N[i] not in \\'18\\': c = 0\\n    \\treturn t + a[int(N[-1])] - c*b[int(N[-1])]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 325162,
                "title": "simple-java-solution-using-regex",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int ans =0;\\n        int minus=0;\\n        for(int i=1;i<=N;++i){\\n            String temp = String.valueOf(i);\\n            if(temp.matches(\"^[1082569]*$\")){\\n                ans++;\\n            }\\n            if(temp.matches(\"^[108]*$\")){ // We need to subtact the count of those numbers which on roation remains the same, i.e all number formed by ONLY 1, 0 or 8.\\n                minus++;\\n            }\\n        }\\n        return ans-minus;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int ans =0;\\n        int minus=0;\\n        for(int i=1;i<=N;++i){\\n            String temp = String.valueOf(i);\\n            if(temp.matches(\"^[1082569]*$\")){\\n                ans++;\\n            }\\n            if(temp.matches(\"^[108]*$\")){ // We need to subtact the count of those numbers which on roation remains the same, i.e all number formed by ONLY 1, 0 or 8.\\n                minus++;\\n            }\\n        }\\n        return ans-minus;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238808,
                "title": "simple-o-ln-n",
                "content": "Suppose:\\n   `R7` - numbers, consisting only of digits `0,1,2,5,6,8,9`, on the interval `1..N`\\n   `R3` - numbers, consisting only of digits `0,1,8`, on the interval `1..N`\\n   `r7` and `r3` - their sizes respectevely\\nSo we must find `r7 - r3`\\nAll numbers from `R7` can be represented as consequent numbers of 7-based number system. So if `N7` is the biggest number from `R7`, the value of N7, interpreted as 7-based number, is `r7`\\nThe same correct about `r3`\\nFor searching `N7` ( `N3`) we can start from the most significant digit of `N`, let\\'s call it `n`. If `n` is a digit from the set `0,1,2,5,6,8,9` (`0,1,8`) we can keep it unchanged and go the the next digit. If `n` is not from the set, we must replace it by the biggest digit from the set, which is smaller than `n` and replace the rest of digits by the max digit from the set - `9` (`8`). Example:\\nN:   12345\\nN7: 12299\\nN3: 11888\\n```\\t\\nval floor7 = Array(0, 1, 2, 2, 2, 3, 4, 4, 5, 6) // floorN(i) - value, represented by digit i in N-based system\\nval floor3 = Array(0, 1, 1, 1, 1, 1, 1, 1, 2, 2) \\nval set7 = Array(true, true, true, false, false, true, true, false, true, true) // setN(i) - if digit i is a member of a N-set\\nval set3 = Array(true, true, false, false, false, false, false, false, true, false)\\ncase class State(res7: Int, res3: Int, turbo7: Boolean, turbo3: Boolean) //turboN - if we must use the max digit from the N-set\\n    \\ndef rotatedDigits(N: Int): Int = {\\n\\tval res = (State(0, 0, false, false) /: toDigits(N)){ (s, n) => State(\\n\\t\\tres7    = s.res7 * 7 + (if (s.turbo7) 6 else floor7(n)),\\n\\t\\tres3    = s.res3 * 3 + (if (s.turbo3) 2 else floor3(n)),\\n\\t\\tturbo7  = s.turbo7 || !set7(n),\\n\\t\\tturbo3  = s.turbo3 || !set3(n)\\n\\t)}\\n\\tres.res7 - res.res3\\n}\\n\\nprivate def toDigits(N: Int, res: Seq[Int] = Seq.empty[Int]): Seq[Int] = \\n\\tif (N==0) res \\n\\telse toDigits(N/10, (N % 10) +: res)\\n```",
                "solutionTags": [],
                "code": "```\\t\\nval floor7 = Array(0, 1, 2, 2, 2, 3, 4, 4, 5, 6) // floorN(i) - value, represented by digit i in N-based system\\nval floor3 = Array(0, 1, 1, 1, 1, 1, 1, 1, 2, 2) \\nval set7 = Array(true, true, true, false, false, true, true, false, true, true) // setN(i) - if digit i is a member of a N-set\\nval set3 = Array(true, true, false, false, false, false, false, false, true, false)\\ncase class State(res7: Int, res3: Int, turbo7: Boolean, turbo3: Boolean) //turboN - if we must use the max digit from the N-set\\n    \\ndef rotatedDigits(N: Int): Int = {\\n\\tval res = (State(0, 0, false, false) /: toDigits(N)){ (s, n) => State(\\n\\t\\tres7    = s.res7 * 7 + (if (s.turbo7) 6 else floor7(n)),\\n\\t\\tres3    = s.res3 * 3 + (if (s.turbo3) 2 else floor3(n)),\\n\\t\\tturbo7  = s.turbo7 || !set7(n),\\n\\t\\tturbo3  = s.turbo3 || !set3(n)\\n\\t)}\\n\\tres.res7 - res.res3\\n}\\n\\nprivate def toDigits(N: Int, res: Seq[Int] = Seq.empty[Int]): Seq[Int] = \\n\\tif (N==0) res \\n\\telse toDigits(N/10, (N % 10) +: res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 238427,
                "title": "o-logn-time-o-1-space-java-solution",
                "content": "There are at most around hundred iterations in this question.\\n\\n```\\npublic int rotatedDigits(int N) {\\n    int[] sum = new int[2];\\n    sum[1] = 1;\\n\\n    int[][] dp = new int[2][10];\\n    dp[1][0] = 1;\\n    while (N > 0) {\\n        // update dp\\n        for (int i = 1; i < 10; i++) {\\n            if (i == 3 || i == 4 || i == 7) {\\n                dp[0][i] = dp[0][i - 1];\\n                dp[1][i] = dp[1][i - 1];\\n            } else if (i == 0 || i == 1 || i == 8) {\\n                dp[0][i] = dp[0][i - 1] + dp[0][0];\\n                dp[1][i] = dp[1][i - 1] + dp[1][0];\\n            } else { // i == 2 || 5 || 6 || 9\\n                dp[0][i] = dp[0][i - 1] + dp[1][0];\\n                dp[1][i] = dp[1][i - 1] + dp[1][0];\\n            }\\n        }\\n\\n        int d = N % 10;\\n        // update sum\\n        if (d == 0) {\\n\\n        } else if (d == 3 || d == 4 || d == 7) {\\n            sum[0] = dp[0][d];\\n            sum[1] = dp[1][d];\\n        } else if (d == 1 || d == 8) {\\n            sum[0] = dp[0][d - 1] + sum[0];\\n            sum[1] = dp[1][d - 1] + sum[1];\\n        } else { // d == 2 || 5 || 6 || 9\\n            sum[0] = dp[0][d - 1] + sum[1];\\n            sum[1] = dp[1][d - 1] + sum[1];   \\n        }\\n\\n        // update dp\\n        dp[0][0] = dp[0][9];\\n        dp[1][0] = dp[1][9];\\n        // update N\\n        N /= 10;\\n    }\\n    return sum[0];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int rotatedDigits(int N) {\\n    int[] sum = new int[2];\\n    sum[1] = 1;\\n\\n    int[][] dp = new int[2][10];\\n    dp[1][0] = 1;\\n    while (N > 0) {\\n        // update dp\\n        for (int i = 1; i < 10; i++) {\\n            if (i == 3 || i == 4 || i == 7) {\\n                dp[0][i] = dp[0][i - 1];\\n                dp[1][i] = dp[1][i - 1];\\n            } else if (i == 0 || i == 1 || i == 8) {\\n                dp[0][i] = dp[0][i - 1] + dp[0][0];\\n                dp[1][i] = dp[1][i - 1] + dp[1][0];\\n            } else { // i == 2 || 5 || 6 || 9\\n                dp[0][i] = dp[0][i - 1] + dp[1][0];\\n                dp[1][i] = dp[1][i - 1] + dp[1][0];\\n            }\\n        }\\n\\n        int d = N % 10;\\n        // update sum\\n        if (d == 0) {\\n\\n        } else if (d == 3 || d == 4 || d == 7) {\\n            sum[0] = dp[0][d];\\n            sum[1] = dp[1][d];\\n        } else if (d == 1 || d == 8) {\\n            sum[0] = dp[0][d - 1] + sum[0];\\n            sum[1] = dp[1][d - 1] + sum[1];\\n        } else { // d == 2 || 5 || 6 || 9\\n            sum[0] = dp[0][d - 1] + sum[1];\\n            sum[1] = dp[1][d - 1] + sum[1];   \\n        }\\n\\n        // update dp\\n        dp[0][0] = dp[0][9];\\n        dp[1][0] = dp[1][9];\\n        // update N\\n        N /= 10;\\n    }\\n    return sum[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 212259,
                "title": "4ms-java-dp-solution",
                "content": "To simplify the question, a number is good if it has 2,5,6 or 9, and a number is invalid if it has 3,4 or 7\\nSo we only need to look at digits 0,1,2,4,6,8,9 and do a dp for all number < N\\nif there exists a good digit (i.e. 2,5,6 or 9), the numbers after that recursion are also good.\\n\\n\\tclass Solution {\\n\\t\\tpublic int rotatedDigits(int N) {\\n\\t\\t\\treturn rotatedDigits(N, 0, false);\\n\\t\\t}\\n\\n\\t\\tpublic int rotatedDigits(int N, int i, boolean isGood) {\\n\\t\\t\\tif (i > N) return 0;\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j : new int[]{2, 5, 6, 9}) {\\n\\t\\t\\t\\tcount += rotatedDigits(N, i * 10 + j, true);\\n\\t\\t\\t}\\n\\t\\t\\tfor (int j : new int[]{0, 1, 8}) {\\n\\t\\t\\t\\tif (i == 0 && j == 0) continue;\\n\\t\\t\\t\\tcount += rotatedDigits(N, i * 10 + j, isGood);\\n\\t\\t\\t}\\n\\t\\t\\tif (isGood) count++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int rotatedDigits(int N) {\\n\\t\\t\\treturn rotatedDigits(N, 0, false);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 205213,
                "title": "java-3-line-o-log-n-beats-100",
                "content": "...because the O(1) solution wouldn\\'t fit!\\n```\\n    public int rotatedDigits(int N) {\\n        int n = Arrays.binarySearch( x, N );\\n        return n<0?-2-n:n;\\n    }\\n\\nprivate static final int[] x = { 0, 2, 5, 6, 9, 12, 15, 16, 19, 20, 21, 22, 25, 26, 28, 29, 50, 51, 52, 55, 56, 58, 59, 60, 61, 62, 65, 66, 68, 69, 82, 85, 86, 89, 90, 91, 92, 95, 96, 98, 99, 102, 105, 106, 109, 112, 115, 116, 119, 120, 121, 122, 125, 126, 128, 129, 150, 151, 152, 155, 156, 158, 159, 160, 161, 162, 165, 166, 168, 169, 182, 185, 186, 189, 190, 191, 192, 195, 196, 198, 199, 200, 201, 202, 205, 206, 208, 209, 210, 211, 212, 215, 216, 218, 219, 220, 221, 222, 225, 226, 228, 229, 250, 251, 252, 255, 256, 258, 259, 260, 261, 262, 265, 266, 268, 269, 280, 281, 282, 285, 286, 288, 289, 290, 291, 292, 295, 296, 298, 299, 500, 501, 502, 505, 506, 508, 509, 510, 511, 512, 515, 516, 518, 519, 520, 521, 522, 525, 526, 528, 529, 550, 551, 552, 555, 556, 558, 559, 560, 561, 562, 565, 566, 568, 569, 580, 581, 582, 585, 586, 588, 589, 590, 591, 592, 595, 596, 598, 599, 600, 601, 602, 605, 606, 608, 609, 610, 611, 612, 615, 616, 618, 619, 620, 621, 622, 625, 626, 628, 629, 650, 651, 652, 655, 656, 658, 659, 660, 661, 662, 665, 666, 668, 669, 680, 681, 682, 685, 686, 688, 689, 690, 691, 692, 695, 696, 698, 699, 802, 805, 806, 809, 812, 815, 816, 819, 820, 821, 822, 825, 826, 828, 829, 850, 851, 852, 855, 856, 858, 859, 860, 861, 862, 865, 866, 868, 869, 882, 885, 886, 889, 890, 891, 892, 895, 896, 898, 899, 900, 901, 902, 905, 906, 908, 909, 910, 911, 912, 915, 916, 918, 919, 920, 921, 922, 925, 926, 928, 929, 950, 951, 952, 955, 956, 958, 959, 960, 961, 962, 965, 966, 968, 969, 980, 981, 982, 985, 986, 988, 989, 990, 991, 992, 995, 996, 998, 999, 1002, 1005, 1006, 1009, 1012, 1015, 1016, 1019, 1020, 1021, 1022, 1025, 1026, 1028, 1029, 1050, 1051, 1052, 1055, 1056, 1058, 1059, 1060, 1061, 1062, 1065, 1066, 1068, 1069, 1082, 1085, 1086, 1089, 1090, 1091, 1092, 1095, 1096, 1098, 1099, 1102, 1105, 1106, 1109, 1112, 1115, 1116, 1119, 1120, 1121, 1122, 1125, 1126, 1128, 1129, 1150, 1151, 1152, 1155, 1156, 1158, 1159, 1160, 1161, 1162, 1165, 1166, 1168, 1169, 1182, 1185, 1186, 1189, 1190, 1191, 1192, 1195, 1196, 1198, 1199, 1200, 1201, 1202, 1205, 1206, 1208, 1209, 1210, 1211, 1212, 1215, 1216, 1218, 1219, 1220, 1221, 1222, 1225, 1226, 1228, 1229, 1250, 1251, 1252, 1255, 1256, 1258, 1259, 1260, 1261, 1262, 1265, 1266, 1268, 1269, 1280, 1281, 1282, 1285, 1286, 1288, 1289, 1290, 1291, 1292, 1295, 1296, 1298, 1299, 1500, 1501, 1502, 1505, 1506, 1508, 1509, 1510, 1511, 1512, 1515, 1516, 1518, 1519, 1520, 1521, 1522, 1525, 1526, 1528, 1529, 1550, 1551, 1552, 1555, 1556, 1558, 1559, 1560, 1561, 1562, 1565, 1566, 1568, 1569, 1580, 1581, 1582, 1585, 1586, 1588, 1589, 1590, 1591, 1592, 1595, 1596, 1598, 1599, 1600, 1601, 1602, 1605, 1606, 1608, 1609, 1610, 1611, 1612, 1615, 1616, 1618, 1619, 1620, 1621, 1622, 1625, 1626, 1628, 1629, 1650, 1651, 1652, 1655, 1656, 1658, 1659, 1660, 1661, 1662, 1665, 1666, 1668, 1669, 1680, 1681, 1682, 1685, 1686, 1688, 1689, 1690, 1691, 1692, 1695, 1696, 1698, 1699, 1802, 1805, 1806, 1809, 1812, 1815, 1816, 1819, 1820, 1821, 1822, 1825, 1826, 1828, 1829, 1850, 1851, 1852, 1855, 1856, 1858, 1859, 1860, 1861, 1862, 1865, 1866, 1868, 1869, 1882, 1885, 1886, 1889, 1890, 1891, 1892, 1895, 1896, 1898, 1899, 1900, 1901, 1902, 1905, 1906, 1908, 1909, 1910, 1911, 1912, 1915, 1916, 1918, 1919, 1920, 1921, 1922, 1925, 1926, 1928, 1929, 1950, 1951, 1952, 1955, 1956, 1958, 1959, 1960, 1961, 1962, 1965, 1966, 1968, 1969, 1980, 1981, 1982, 1985, 1986, 1988, 1989, 1990, 1991, 1992, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2015, 2016, 2018, 2019, 2020, 2021, 2022, 2025, 2026, 2028, 2029, 2050, 2051, 2052, 2055, 2056, 2058, 2059, 2060, 2061, 2062, 2065, 2066, 2068, 2069, 2080, 2081, 2082, 2085, 2086, 2088, 2089, 2090, 2091, 2092, 2095, 2096, 2098, 2099, 2100, 2101, 2102, 2105, 2106, 2108, 2109, 2110, 2111, 2112, 2115, 2116, 2118, 2119, 2120, 2121, 2122, 2125, 2126, 2128, 2129, 2150, 2151, 2152, 2155, 2156, 2158, 2159, 2160, 2161, 2162, 2165, 2166, 2168, 2169, 2180, 2181, 2182, 2185, 2186, 2188, 2189, 2190, 2191, 2192, 2195, 2196, 2198, 2199, 2200, 2201, 2202, 2205, 2206, 2208, 2209, 2210, 2211, 2212, 2215, 2216, 2218, 2219, 2220, 2221, 2222, 2225, 2226, 2228, 2229, 2250, 2251, 2252, 2255, 2256, 2258, 2259, 2260, 2261, 2262, 2265, 2266, 2268, 2269, 2280, 2281, 2282, 2285, 2286, 2288, 2289, 2290, 2291, 2292, 2295, 2296, 2298, 2299, 2500, 2501, 2502, 2505, 2506, 2508, 2509, 2510, 2511, 2512, 2515, 2516, 2518, 2519, 2520, 2521, 2522, 2525, 2526, 2528, 2529, 2550, 2551, 2552, 2555, 2556, 2558, 2559, 2560, 2561, 2562, 2565, 2566, 2568, 2569, 2580, 2581, 2582, 2585, 2586, 2588, 2589, 2590, 2591, 2592, 2595, 2596, 2598, 2599, 2600, 2601, 2602, 2605, 2606, 2608, 2609, 2610, 2611, 2612, 2615, 2616, 2618, 2619, 2620, 2621, 2622, 2625, 2626, 2628, 2629, 2650, 2651, 2652, 2655, 2656, 2658, 2659, 2660, 2661, 2662, 2665, 2666, 2668, 2669, 2680, 2681, 2682, 2685, 2686, 2688, 2689, 2690, 2691, 2692, 2695, 2696, 2698, 2699, 2800, 2801, 2802, 2805, 2806, 2808, 2809, 2810, 2811, 2812, 2815, 2816, 2818, 2819, 2820, 2821, 2822, 2825, 2826, 2828, 2829, 2850, 2851, 2852, 2855, 2856, 2858, 2859, 2860, 2861, 2862, 2865, 2866, 2868, 2869, 2880, 2881, 2882, 2885, 2886, 2888, 2889, 2890, 2891, 2892, 2895, 2896, 2898, 2899, 2900, 2901, 2902, 2905, 2906, 2908, 2909, 2910, 2911, 2912, 2915, 2916, 2918, 2919, 2920, 2921, 2922, 2925, 2926, 2928, 2929, 2950, 2951, 2952, 2955, 2956, 2958, 2959, 2960, 2961, 2962, 2965, 2966, 2968, 2969, 2980, 2981, 2982, 2985, 2986, 2988, 2989, 2990, 2991, 2992, 2995, 2996, 2998, 2999, 5000, 5001, 5002, 5005, 5006, 5008, 5009, 5010, 5011, 5012, 5015, 5016, 5018, 5019, 5020, 5021, 5022, 5025, 5026, 5028, 5029, 5050, 5051, 5052, 5055, 5056, 5058, 5059, 5060, 5061, 5062, 5065, 5066, 5068, 5069, 5080, 5081, 5082, 5085, 5086, 5088, 5089, 5090, 5091, 5092, 5095, 5096, 5098, 5099, 5100, 5101, 5102, 5105, 5106, 5108, 5109, 5110, 5111, 5112, 5115, 5116, 5118, 5119, 5120, 5121, 5122, 5125, 5126, 5128, 5129, 5150, 5151, 5152, 5155, 5156, 5158, 5159, 5160, 5161, 5162, 5165, 5166, 5168, 5169, 5180, 5181, 5182, 5185, 5186, 5188, 5189, 5190, 5191, 5192, 5195, 5196, 5198, 5199, 5200, 5201, 5202, 5205, 5206, 5208, 5209, 5210, 5211, 5212, 5215, 5216, 5218, 5219, 5220, 5221, 5222, 5225, 5226, 5228, 5229, 5250, 5251, 5252, 5255, 5256, 5258, 5259, 5260, 5261, 5262, 5265, 5266, 5268, 5269, 5280, 5281, 5282, 5285, 5286, 5288, 5289, 5290, 5291, 5292, 5295, 5296, 5298, 5299, 5500, 5501, 5502, 5505, 5506, 5508, 5509, 5510, 5511, 5512, 5515, 5516, 5518, 5519, 5520, 5521, 5522, 5525, 5526, 5528, 5529, 5550, 5551, 5552, 5555, 5556, 5558, 5559, 5560, 5561, 5562, 5565, 5566, 5568, 5569, 5580, 5581, 5582, 5585, 5586, 5588, 5589, 5590, 5591, 5592, 5595, 5596, 5598, 5599, 5600, 5601, 5602, 5605, 5606, 5608, 5609, 5610, 5611, 5612, 5615, 5616, 5618, 5619, 5620, 5621, 5622, 5625, 5626, 5628, 5629, 5650, 5651, 5652, 5655, 5656, 5658, 5659, 5660, 5661, 5662, 5665, 5666, 5668, 5669, 5680, 5681, 5682, 5685, 5686, 5688, 5689, 5690, 5691, 5692, 5695, 5696, 5698, 5699, 5800, 5801, 5802, 5805, 5806, 5808, 5809, 5810, 5811, 5812, 5815, 5816, 5818, 5819, 5820, 5821, 5822, 5825, 5826, 5828, 5829, 5850, 5851, 5852, 5855, 5856, 5858, 5859, 5860, 5861, 5862, 5865, 5866, 5868, 5869, 5880, 5881, 5882, 5885, 5886, 5888, 5889, 5890, 5891, 5892, 5895, 5896, 5898, 5899, 5900, 5901, 5902, 5905, 5906, 5908, 5909, 5910, 5911, 5912, 5915, 5916, 5918, 5919, 5920, 5921, 5922, 5925, 5926, 5928, 5929, 5950, 5951, 5952, 5955, 5956, 5958, 5959, 5960, 5961, 5962, 5965, 5966, 5968, 5969, 5980, 5981, 5982, 5985, 5986, 5988, 5989, 5990, 5991, 5992, 5995, 5996, 5998, 5999, 6000, 6001, 6002, 6005, 6006, 6008, 6009, 6010, 6011, 6012, 6015, 6016, 6018, 6019, 6020, 6021, 6022, 6025, 6026, 6028, 6029, 6050, 6051, 6052, 6055, 6056, 6058, 6059, 6060, 6061, 6062, 6065, 6066, 6068, 6069, 6080, 6081, 6082, 6085, 6086, 6088, 6089, 6090, 6091, 6092, 6095, 6096, 6098, 6099, 6100, 6101, 6102, 6105, 6106, 6108, 6109, 6110, 6111, 6112, 6115, 6116, 6118, 6119, 6120, 6121, 6122, 6125, 6126, 6128, 6129, 6150, 6151, 6152, 6155, 6156, 6158, 6159, 6160, 6161, 6162, 6165, 6166, 6168, 6169, 6180, 6181, 6182, 6185, 6186, 6188, 6189, 6190, 6191, 6192, 6195, 6196, 6198, 6199, 6200, 6201, 6202, 6205, 6206, 6208, 6209, 6210, 6211, 6212, 6215, 6216, 6218, 6219, 6220, 6221, 6222, 6225, 6226, 6228, 6229, 6250, 6251, 6252, 6255, 6256, 6258, 6259, 6260, 6261, 6262, 6265, 6266, 6268, 6269, 6280, 6281, 6282, 6285, 6286, 6288, 6289, 6290, 6291, 6292, 6295, 6296, 6298, 6299, 6500, 6501, 6502, 6505, 6506, 6508, 6509, 6510, 6511, 6512, 6515, 6516, 6518, 6519, 6520, 6521, 6522, 6525, 6526, 6528, 6529, 6550, 6551, 6552, 6555, 6556, 6558, 6559, 6560, 6561, 6562, 6565, 6566, 6568, 6569, 6580, 6581, 6582, 6585, 6586, 6588, 6589, 6590, 6591, 6592, 6595, 6596, 6598, 6599, 6600, 6601, 6602, 6605, 6606, 6608, 6609, 6610, 6611, 6612, 6615, 6616, 6618, 6619, 6620, 6621, 6622, 6625, 6626, 6628, 6629, 6650, 6651, 6652, 6655, 6656, 6658, 6659, 6660, 6661, 6662, 6665, 6666, 6668, 6669, 6680, 6681, 6682, 6685, 6686, 6688, 6689, 6690, 6691, 6692, 6695, 6696, 6698, 6699, 6800, 6801, 6802, 6805, 6806, 6808, 6809, 6810, 6811, 6812, 6815, 6816, 6818, 6819, 6820, 6821, 6822, 6825, 6826, 6828, 6829, 6850, 6851, 6852, 6855, 6856, 6858, 6859, 6860, 6861, 6862, 6865, 6866, 6868, 6869, 6880, 6881, 6882, 6885, 6886, 6888, 6889, 6890, 6891, 6892, 6895, 6896, 6898, 6899, 6900, 6901, 6902, 6905, 6906, 6908, 6909, 6910, 6911, 6912, 6915, 6916, 6918, 6919, 6920, 6921, 6922, 6925, 6926, 6928, 6929, 6950, 6951, 6952, 6955, 6956, 6958, 6959, 6960, 6961, 6962, 6965, 6966, 6968, 6969, 6980, 6981, 6982, 6985, 6986, 6988, 6989, 6990, 6991, 6992, 6995, 6996, 6998, 6999, 8002, 8005, 8006, 8009, 8012, 8015, 8016, 8019, 8020, 8021, 8022, 8025, 8026, 8028, 8029, 8050, 8051, 8052, 8055, 8056, 8058, 8059, 8060, 8061, 8062, 8065, 8066, 8068, 8069, 8082, 8085, 8086, 8089, 8090, 8091, 8092, 8095, 8096, 8098, 8099, 8102, 8105, 8106, 8109, 8112, 8115, 8116, 8119, 8120, 8121, 8122, 8125, 8126, 8128, 8129, 8150, 8151, 8152, 8155, 8156, 8158, 8159, 8160, 8161, 8162, 8165, 8166, 8168, 8169, 8182, 8185, 8186, 8189, 8190, 8191, 8192, 8195, 8196, 8198, 8199, 8200, 8201, 8202, 8205, 8206, 8208, 8209, 8210, 8211, 8212, 8215, 8216, 8218, 8219, 8220, 8221, 8222, 8225, 8226, 8228, 8229, 8250, 8251, 8252, 8255, 8256, 8258, 8259, 8260, 8261, 8262, 8265, 8266, 8268, 8269, 8280, 8281, 8282, 8285, 8286, 8288, 8289, 8290, 8291, 8292, 8295, 8296, 8298, 8299, 8500, 8501, 8502, 8505, 8506, 8508, 8509, 8510, 8511, 8512, 8515, 8516, 8518, 8519, 8520, 8521, 8522, 8525, 8526, 8528, 8529, 8550, 8551, 8552, 8555, 8556, 8558, 8559, 8560, 8561, 8562, 8565, 8566, 8568, 8569, 8580, 8581, 8582, 8585, 8586, 8588, 8589, 8590, 8591, 8592, 8595, 8596, 8598, 8599, 8600, 8601, 8602, 8605, 8606, 8608, 8609, 8610, 8611, 8612, 8615, 8616, 8618, 8619, 8620, 8621, 8622, 8625, 8626, 8628, 8629, 8650, 8651, 8652, 8655, 8656, 8658, 8659, 8660, 8661, 8662, 8665, 8666, 8668, 8669, 8680, 8681, 8682, 8685, 8686, 8688, 8689, 8690, 8691, 8692, 8695, 8696, 8698, 8699, 8802, 8805, 8806, 8809, 8812, 8815, 8816, 8819, 8820, 8821, 8822, 8825, 8826, 8828, 8829, 8850, 8851, 8852, 8855, 8856, 8858, 8859, 8860, 8861, 8862, 8865, 8866, 8868, 8869, 8882, 8885, 8886, 8889, 8890, 8891, 8892, 8895, 8896, 8898, 8899, 8900, 8901, 8902, 8905, 8906, 8908, 8909, 8910, 8911, 8912, 8915, 8916, 8918, 8919, 8920, 8921, 8922, 8925, 8926, 8928, 8929, 8950, 8951, 8952, 8955, 8956, 8958, 8959, 8960, 8961, 8962, 8965, 8966, 8968, 8969, 8980, 8981, 8982, 8985, 8986, 8988, 8989, 8990, 8991, 8992, 8995, 8996, 8998, 8999, 9000, 9001, 9002, 9005, 9006, 9008, 9009, 9010, 9011, 9012, 9015, 9016, 9018, 9019, 9020, 9021, 9022, 9025, 9026, 9028, 9029, 9050, 9051, 9052, 9055, 9056, 9058, 9059, 9060, 9061, 9062, 9065, 9066, 9068, 9069, 9080, 9081, 9082, 9085, 9086, 9088, 9089, 9090, 9091, 9092, 9095, 9096, 9098, 9099, 9100, 9101, 9102, 9105, 9106, 9108, 9109, 9110, 9111, 9112, 9115, 9116, 9118, 9119, 9120, 9121, 9122, 9125, 9126, 9128, 9129, 9150, 9151, 9152, 9155, 9156, 9158, 9159, 9160, 9161, 9162, 9165, 9166, 9168, 9169, 9180, 9181, 9182, 9185, 9186, 9188, 9189, 9190, 9191, 9192, 9195, 9196, 9198, 9199, 9200, 9201, 9202, 9205, 9206, 9208, 9209, 9210, 9211, 9212, 9215, 9216, 9218, 9219, 9220, 9221, 9222, 9225, 9226, 9228, 9229, 9250, 9251, 9252, 9255, 9256, 9258, 9259, 9260, 9261, 9262, 9265, 9266, 9268, 9269, 9280, 9281, 9282, 9285, 9286, 9288, 9289, 9290, 9291, 9292, 9295, 9296, 9298, 9299, 9500, 9501, 9502, 9505, 9506, 9508, 9509, 9510, 9511, 9512, 9515, 9516, 9518, 9519, 9520, 9521, 9522, 9525, 9526, 9528, 9529, 9550, 9551, 9552, 9555, 9556, 9558, 9559, 9560, 9561, 9562, 9565, 9566, 9568, 9569, 9580, 9581, 9582, 9585, 9586, 9588, 9589, 9590, 9591, 9592, 9595, 9596, 9598, 9599, 9600, 9601, 9602, 9605, 9606, 9608, 9609, 9610, 9611, 9612, 9615, 9616, 9618, 9619, 9620, 9621, 9622, 9625, 9626, 9628, 9629, 9650, 9651, 9652, 9655, 9656, 9658, 9659, 9660, 9661, 9662, 9665, 9666, 9668, 9669, 9680, 9681, 9682, 9685, 9686, 9688, 9689, 9690, 9691, 9692, 9695, 9696, 9698, 9699, 9800, 9801, 9802, 9805, 9806, 9808, 9809, 9810, 9811, 9812, 9815, 9816, 9818, 9819, 9820, 9821, 9822, 9825, 9826, 9828, 9829, 9850, 9851, 9852, 9855, 9856, 9858, 9859, 9860, 9861, 9862, 9865, 9866, 9868, 9869, 9880, 9881, 9882, 9885, 9886, 9888, 9889, 9890, 9891, 9892, 9895, 9896, 9898, 9899, 9900, 9901, 9902, 9905, 9906, 9908, 9909, 9910, 9911, 9912, 9915, 9916, 9918, 9919, 9920, 9921, 9922, 9925, 9926, 9928, 9929, 9950, 9951, 9952, 9955, 9956, 9958, 9959, 9960, 9961, 9962, 9965, 9966, 9968, 9969, 9980, 9981, 9982, 9985, 9986, 9988, 9989, 9990, 9991, 9992, 9995, 9996, 9998, 9999\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    public int rotatedDigits(int N) {\\n        int n = Arrays.binarySearch( x, N );\\n        return n<0?-2-n:n;\\n    }\\n\\nprivate static final int[] x = { 0, 2, 5, 6, 9, 12, 15, 16, 19, 20, 21, 22, 25, 26, 28, 29, 50, 51, 52, 55, 56, 58, 59, 60, 61, 62, 65, 66, 68, 69, 82, 85, 86, 89, 90, 91, 92, 95, 96, 98, 99, 102, 105, 106, 109, 112, 115, 116, 119, 120, 121, 122, 125, 126, 128, 129, 150, 151, 152, 155, 156, 158, 159, 160, 161, 162, 165, 166, 168, 169, 182, 185, 186, 189, 190, 191, 192, 195, 196, 198, 199, 200, 201, 202, 205, 206, 208, 209, 210, 211, 212, 215, 216, 218, 219, 220, 221, 222, 225, 226, 228, 229, 250, 251, 252, 255, 256, 258, 259, 260, 261, 262, 265, 266, 268, 269, 280, 281, 282, 285, 286, 288, 289, 290, 291, 292, 295, 296, 298, 299, 500, 501, 502, 505, 506, 508, 509, 510, 511, 512, 515, 516, 518, 519, 520, 521, 522, 525, 526, 528, 529, 550, 551, 552, 555, 556, 558, 559, 560, 561, 562, 565, 566, 568, 569, 580, 581, 582, 585, 586, 588, 589, 590, 591, 592, 595, 596, 598, 599, 600, 601, 602, 605, 606, 608, 609, 610, 611, 612, 615, 616, 618, 619, 620, 621, 622, 625, 626, 628, 629, 650, 651, 652, 655, 656, 658, 659, 660, 661, 662, 665, 666, 668, 669, 680, 681, 682, 685, 686, 688, 689, 690, 691, 692, 695, 696, 698, 699, 802, 805, 806, 809, 812, 815, 816, 819, 820, 821, 822, 825, 826, 828, 829, 850, 851, 852, 855, 856, 858, 859, 860, 861, 862, 865, 866, 868, 869, 882, 885, 886, 889, 890, 891, 892, 895, 896, 898, 899, 900, 901, 902, 905, 906, 908, 909, 910, 911, 912, 915, 916, 918, 919, 920, 921, 922, 925, 926, 928, 929, 950, 951, 952, 955, 956, 958, 959, 960, 961, 962, 965, 966, 968, 969, 980, 981, 982, 985, 986, 988, 989, 990, 991, 992, 995, 996, 998, 999, 1002, 1005, 1006, 1009, 1012, 1015, 1016, 1019, 1020, 1021, 1022, 1025, 1026, 1028, 1029, 1050, 1051, 1052, 1055, 1056, 1058, 1059, 1060, 1061, 1062, 1065, 1066, 1068, 1069, 1082, 1085, 1086, 1089, 1090, 1091, 1092, 1095, 1096, 1098, 1099, 1102, 1105, 1106, 1109, 1112, 1115, 1116, 1119, 1120, 1121, 1122, 1125, 1126, 1128, 1129, 1150, 1151, 1152, 1155, 1156, 1158, 1159, 1160, 1161, 1162, 1165, 1166, 1168, 1169, 1182, 1185, 1186, 1189, 1190, 1191, 1192, 1195, 1196, 1198, 1199, 1200, 1201, 1202, 1205, 1206, 1208, 1209, 1210, 1211, 1212, 1215, 1216, 1218, 1219, 1220, 1221, 1222, 1225, 1226, 1228, 1229, 1250, 1251, 1252, 1255, 1256, 1258, 1259, 1260, 1261, 1262, 1265, 1266, 1268, 1269, 1280, 1281, 1282, 1285, 1286, 1288, 1289, 1290, 1291, 1292, 1295, 1296, 1298, 1299, 1500, 1501, 1502, 1505, 1506, 1508, 1509, 1510, 1511, 1512, 1515, 1516, 1518, 1519, 1520, 1521, 1522, 1525, 1526, 1528, 1529, 1550, 1551, 1552, 1555, 1556, 1558, 1559, 1560, 1561, 1562, 1565, 1566, 1568, 1569, 1580, 1581, 1582, 1585, 1586, 1588, 1589, 1590, 1591, 1592, 1595, 1596, 1598, 1599, 1600, 1601, 1602, 1605, 1606, 1608, 1609, 1610, 1611, 1612, 1615, 1616, 1618, 1619, 1620, 1621, 1622, 1625, 1626, 1628, 1629, 1650, 1651, 1652, 1655, 1656, 1658, 1659, 1660, 1661, 1662, 1665, 1666, 1668, 1669, 1680, 1681, 1682, 1685, 1686, 1688, 1689, 1690, 1691, 1692, 1695, 1696, 1698, 1699, 1802, 1805, 1806, 1809, 1812, 1815, 1816, 1819, 1820, 1821, 1822, 1825, 1826, 1828, 1829, 1850, 1851, 1852, 1855, 1856, 1858, 1859, 1860, 1861, 1862, 1865, 1866, 1868, 1869, 1882, 1885, 1886, 1889, 1890, 1891, 1892, 1895, 1896, 1898, 1899, 1900, 1901, 1902, 1905, 1906, 1908, 1909, 1910, 1911, 1912, 1915, 1916, 1918, 1919, 1920, 1921, 1922, 1925, 1926, 1928, 1929, 1950, 1951, 1952, 1955, 1956, 1958, 1959, 1960, 1961, 1962, 1965, 1966, 1968, 1969, 1980, 1981, 1982, 1985, 1986, 1988, 1989, 1990, 1991, 1992, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2005, 2006, 2008, 2009, 2010, 2011, 2012, 2015, 2016, 2018, 2019, 2020, 2021, 2022, 2025, 2026, 2028, 2029, 2050, 2051, 2052, 2055, 2056, 2058, 2059, 2060, 2061, 2062, 2065, 2066, 2068, 2069, 2080, 2081, 2082, 2085, 2086, 2088, 2089, 2090, 2091, 2092, 2095, 2096, 2098, 2099, 2100, 2101, 2102, 2105, 2106, 2108, 2109, 2110, 2111, 2112, 2115, 2116, 2118, 2119, 2120, 2121, 2122, 2125, 2126, 2128, 2129, 2150, 2151, 2152, 2155, 2156, 2158, 2159, 2160, 2161, 2162, 2165, 2166, 2168, 2169, 2180, 2181, 2182, 2185, 2186, 2188, 2189, 2190, 2191, 2192, 2195, 2196, 2198, 2199, 2200, 2201, 2202, 2205, 2206, 2208, 2209, 2210, 2211, 2212, 2215, 2216, 2218, 2219, 2220, 2221, 2222, 2225, 2226, 2228, 2229, 2250, 2251, 2252, 2255, 2256, 2258, 2259, 2260, 2261, 2262, 2265, 2266, 2268, 2269, 2280, 2281, 2282, 2285, 2286, 2288, 2289, 2290, 2291, 2292, 2295, 2296, 2298, 2299, 2500, 2501, 2502, 2505, 2506, 2508, 2509, 2510, 2511, 2512, 2515, 2516, 2518, 2519, 2520, 2521, 2522, 2525, 2526, 2528, 2529, 2550, 2551, 2552, 2555, 2556, 2558, 2559, 2560, 2561, 2562, 2565, 2566, 2568, 2569, 2580, 2581, 2582, 2585, 2586, 2588, 2589, 2590, 2591, 2592, 2595, 2596, 2598, 2599, 2600, 2601, 2602, 2605, 2606, 2608, 2609, 2610, 2611, 2612, 2615, 2616, 2618, 2619, 2620, 2621, 2622, 2625, 2626, 2628, 2629, 2650, 2651, 2652, 2655, 2656, 2658, 2659, 2660, 2661, 2662, 2665, 2666, 2668, 2669, 2680, 2681, 2682, 2685, 2686, 2688, 2689, 2690, 2691, 2692, 2695, 2696, 2698, 2699, 2800, 2801, 2802, 2805, 2806, 2808, 2809, 2810, 2811, 2812, 2815, 2816, 2818, 2819, 2820, 2821, 2822, 2825, 2826, 2828, 2829, 2850, 2851, 2852, 2855, 2856, 2858, 2859, 2860, 2861, 2862, 2865, 2866, 2868, 2869, 2880, 2881, 2882, 2885, 2886, 2888, 2889, 2890, 2891, 2892, 2895, 2896, 2898, 2899, 2900, 2901, 2902, 2905, 2906, 2908, 2909, 2910, 2911, 2912, 2915, 2916, 2918, 2919, 2920, 2921, 2922, 2925, 2926, 2928, 2929, 2950, 2951, 2952, 2955, 2956, 2958, 2959, 2960, 2961, 2962, 2965, 2966, 2968, 2969, 2980, 2981, 2982, 2985, 2986, 2988, 2989, 2990, 2991, 2992, 2995, 2996, 2998, 2999, 5000, 5001, 5002, 5005, 5006, 5008, 5009, 5010, 5011, 5012, 5015, 5016, 5018, 5019, 5020, 5021, 5022, 5025, 5026, 5028, 5029, 5050, 5051, 5052, 5055, 5056, 5058, 5059, 5060, 5061, 5062, 5065, 5066, 5068, 5069, 5080, 5081, 5082, 5085, 5086, 5088, 5089, 5090, 5091, 5092, 5095, 5096, 5098, 5099, 5100, 5101, 5102, 5105, 5106, 5108, 5109, 5110, 5111, 5112, 5115, 5116, 5118, 5119, 5120, 5121, 5122, 5125, 5126, 5128, 5129, 5150, 5151, 5152, 5155, 5156, 5158, 5159, 5160, 5161, 5162, 5165, 5166, 5168, 5169, 5180, 5181, 5182, 5185, 5186, 5188, 5189, 5190, 5191, 5192, 5195, 5196, 5198, 5199, 5200, 5201, 5202, 5205, 5206, 5208, 5209, 5210, 5211, 5212, 5215, 5216, 5218, 5219, 5220, 5221, 5222, 5225, 5226, 5228, 5229, 5250, 5251, 5252, 5255, 5256, 5258, 5259, 5260, 5261, 5262, 5265, 5266, 5268, 5269, 5280, 5281, 5282, 5285, 5286, 5288, 5289, 5290, 5291, 5292, 5295, 5296, 5298, 5299, 5500, 5501, 5502, 5505, 5506, 5508, 5509, 5510, 5511, 5512, 5515, 5516, 5518, 5519, 5520, 5521, 5522, 5525, 5526, 5528, 5529, 5550, 5551, 5552, 5555, 5556, 5558, 5559, 5560, 5561, 5562, 5565, 5566, 5568, 5569, 5580, 5581, 5582, 5585, 5586, 5588, 5589, 5590, 5591, 5592, 5595, 5596, 5598, 5599, 5600, 5601, 5602, 5605, 5606, 5608, 5609, 5610, 5611, 5612, 5615, 5616, 5618, 5619, 5620, 5621, 5622, 5625, 5626, 5628, 5629, 5650, 5651, 5652, 5655, 5656, 5658, 5659, 5660, 5661, 5662, 5665, 5666, 5668, 5669, 5680, 5681, 5682, 5685, 5686, 5688, 5689, 5690, 5691, 5692, 5695, 5696, 5698, 5699, 5800, 5801, 5802, 5805, 5806, 5808, 5809, 5810, 5811, 5812, 5815, 5816, 5818, 5819, 5820, 5821, 5822, 5825, 5826, 5828, 5829, 5850, 5851, 5852, 5855, 5856, 5858, 5859, 5860, 5861, 5862, 5865, 5866, 5868, 5869, 5880, 5881, 5882, 5885, 5886, 5888, 5889, 5890, 5891, 5892, 5895, 5896, 5898, 5899, 5900, 5901, 5902, 5905, 5906, 5908, 5909, 5910, 5911, 5912, 5915, 5916, 5918, 5919, 5920, 5921, 5922, 5925, 5926, 5928, 5929, 5950, 5951, 5952, 5955, 5956, 5958, 5959, 5960, 5961, 5962, 5965, 5966, 5968, 5969, 5980, 5981, 5982, 5985, 5986, 5988, 5989, 5990, 5991, 5992, 5995, 5996, 5998, 5999, 6000, 6001, 6002, 6005, 6006, 6008, 6009, 6010, 6011, 6012, 6015, 6016, 6018, 6019, 6020, 6021, 6022, 6025, 6026, 6028, 6029, 6050, 6051, 6052, 6055, 6056, 6058, 6059, 6060, 6061, 6062, 6065, 6066, 6068, 6069, 6080, 6081, 6082, 6085, 6086, 6088, 6089, 6090, 6091, 6092, 6095, 6096, 6098, 6099, 6100, 6101, 6102, 6105, 6106, 6108, 6109, 6110, 6111, 6112, 6115, 6116, 6118, 6119, 6120, 6121, 6122, 6125, 6126, 6128, 6129, 6150, 6151, 6152, 6155, 6156, 6158, 6159, 6160, 6161, 6162, 6165, 6166, 6168, 6169, 6180, 6181, 6182, 6185, 6186, 6188, 6189, 6190, 6191, 6192, 6195, 6196, 6198, 6199, 6200, 6201, 6202, 6205, 6206, 6208, 6209, 6210, 6211, 6212, 6215, 6216, 6218, 6219, 6220, 6221, 6222, 6225, 6226, 6228, 6229, 6250, 6251, 6252, 6255, 6256, 6258, 6259, 6260, 6261, 6262, 6265, 6266, 6268, 6269, 6280, 6281, 6282, 6285, 6286, 6288, 6289, 6290, 6291, 6292, 6295, 6296, 6298, 6299, 6500, 6501, 6502, 6505, 6506, 6508, 6509, 6510, 6511, 6512, 6515, 6516, 6518, 6519, 6520, 6521, 6522, 6525, 6526, 6528, 6529, 6550, 6551, 6552, 6555, 6556, 6558, 6559, 6560, 6561, 6562, 6565, 6566, 6568, 6569, 6580, 6581, 6582, 6585, 6586, 6588, 6589, 6590, 6591, 6592, 6595, 6596, 6598, 6599, 6600, 6601, 6602, 6605, 6606, 6608, 6609, 6610, 6611, 6612, 6615, 6616, 6618, 6619, 6620, 6621, 6622, 6625, 6626, 6628, 6629, 6650, 6651, 6652, 6655, 6656, 6658, 6659, 6660, 6661, 6662, 6665, 6666, 6668, 6669, 6680, 6681, 6682, 6685, 6686, 6688, 6689, 6690, 6691, 6692, 6695, 6696, 6698, 6699, 6800, 6801, 6802, 6805, 6806, 6808, 6809, 6810, 6811, 6812, 6815, 6816, 6818, 6819, 6820, 6821, 6822, 6825, 6826, 6828, 6829, 6850, 6851, 6852, 6855, 6856, 6858, 6859, 6860, 6861, 6862, 6865, 6866, 6868, 6869, 6880, 6881, 6882, 6885, 6886, 6888, 6889, 6890, 6891, 6892, 6895, 6896, 6898, 6899, 6900, 6901, 6902, 6905, 6906, 6908, 6909, 6910, 6911, 6912, 6915, 6916, 6918, 6919, 6920, 6921, 6922, 6925, 6926, 6928, 6929, 6950, 6951, 6952, 6955, 6956, 6958, 6959, 6960, 6961, 6962, 6965, 6966, 6968, 6969, 6980, 6981, 6982, 6985, 6986, 6988, 6989, 6990, 6991, 6992, 6995, 6996, 6998, 6999, 8002, 8005, 8006, 8009, 8012, 8015, 8016, 8019, 8020, 8021, 8022, 8025, 8026, 8028, 8029, 8050, 8051, 8052, 8055, 8056, 8058, 8059, 8060, 8061, 8062, 8065, 8066, 8068, 8069, 8082, 8085, 8086, 8089, 8090, 8091, 8092, 8095, 8096, 8098, 8099, 8102, 8105, 8106, 8109, 8112, 8115, 8116, 8119, 8120, 8121, 8122, 8125, 8126, 8128, 8129, 8150, 8151, 8152, 8155, 8156, 8158, 8159, 8160, 8161, 8162, 8165, 8166, 8168, 8169, 8182, 8185, 8186, 8189, 8190, 8191, 8192, 8195, 8196, 8198, 8199, 8200, 8201, 8202, 8205, 8206, 8208, 8209, 8210, 8211, 8212, 8215, 8216, 8218, 8219, 8220, 8221, 8222, 8225, 8226, 8228, 8229, 8250, 8251, 8252, 8255, 8256, 8258, 8259, 8260, 8261, 8262, 8265, 8266, 8268, 8269, 8280, 8281, 8282, 8285, 8286, 8288, 8289, 8290, 8291, 8292, 8295, 8296, 8298, 8299, 8500, 8501, 8502, 8505, 8506, 8508, 8509, 8510, 8511, 8512, 8515, 8516, 8518, 8519, 8520, 8521, 8522, 8525, 8526, 8528, 8529, 8550, 8551, 8552, 8555, 8556, 8558, 8559, 8560, 8561, 8562, 8565, 8566, 8568, 8569, 8580, 8581, 8582, 8585, 8586, 8588, 8589, 8590, 8591, 8592, 8595, 8596, 8598, 8599, 8600, 8601, 8602, 8605, 8606, 8608, 8609, 8610, 8611, 8612, 8615, 8616, 8618, 8619, 8620, 8621, 8622, 8625, 8626, 8628, 8629, 8650, 8651, 8652, 8655, 8656, 8658, 8659, 8660, 8661, 8662, 8665, 8666, 8668, 8669, 8680, 8681, 8682, 8685, 8686, 8688, 8689, 8690, 8691, 8692, 8695, 8696, 8698, 8699, 8802, 8805, 8806, 8809, 8812, 8815, 8816, 8819, 8820, 8821, 8822, 8825, 8826, 8828, 8829, 8850, 8851, 8852, 8855, 8856, 8858, 8859, 8860, 8861, 8862, 8865, 8866, 8868, 8869, 8882, 8885, 8886, 8889, 8890, 8891, 8892, 8895, 8896, 8898, 8899, 8900, 8901, 8902, 8905, 8906, 8908, 8909, 8910, 8911, 8912, 8915, 8916, 8918, 8919, 8920, 8921, 8922, 8925, 8926, 8928, 8929, 8950, 8951, 8952, 8955, 8956, 8958, 8959, 8960, 8961, 8962, 8965, 8966, 8968, 8969, 8980, 8981, 8982, 8985, 8986, 8988, 8989, 8990, 8991, 8992, 8995, 8996, 8998, 8999, 9000, 9001, 9002, 9005, 9006, 9008, 9009, 9010, 9011, 9012, 9015, 9016, 9018, 9019, 9020, 9021, 9022, 9025, 9026, 9028, 9029, 9050, 9051, 9052, 9055, 9056, 9058, 9059, 9060, 9061, 9062, 9065, 9066, 9068, 9069, 9080, 9081, 9082, 9085, 9086, 9088, 9089, 9090, 9091, 9092, 9095, 9096, 9098, 9099, 9100, 9101, 9102, 9105, 9106, 9108, 9109, 9110, 9111, 9112, 9115, 9116, 9118, 9119, 9120, 9121, 9122, 9125, 9126, 9128, 9129, 9150, 9151, 9152, 9155, 9156, 9158, 9159, 9160, 9161, 9162, 9165, 9166, 9168, 9169, 9180, 9181, 9182, 9185, 9186, 9188, 9189, 9190, 9191, 9192, 9195, 9196, 9198, 9199, 9200, 9201, 9202, 9205, 9206, 9208, 9209, 9210, 9211, 9212, 9215, 9216, 9218, 9219, 9220, 9221, 9222, 9225, 9226, 9228, 9229, 9250, 9251, 9252, 9255, 9256, 9258, 9259, 9260, 9261, 9262, 9265, 9266, 9268, 9269, 9280, 9281, 9282, 9285, 9286, 9288, 9289, 9290, 9291, 9292, 9295, 9296, 9298, 9299, 9500, 9501, 9502, 9505, 9506, 9508, 9509, 9510, 9511, 9512, 9515, 9516, 9518, 9519, 9520, 9521, 9522, 9525, 9526, 9528, 9529, 9550, 9551, 9552, 9555, 9556, 9558, 9559, 9560, 9561, 9562, 9565, 9566, 9568, 9569, 9580, 9581, 9582, 9585, 9586, 9588, 9589, 9590, 9591, 9592, 9595, 9596, 9598, 9599, 9600, 9601, 9602, 9605, 9606, 9608, 9609, 9610, 9611, 9612, 9615, 9616, 9618, 9619, 9620, 9621, 9622, 9625, 9626, 9628, 9629, 9650, 9651, 9652, 9655, 9656, 9658, 9659, 9660, 9661, 9662, 9665, 9666, 9668, 9669, 9680, 9681, 9682, 9685, 9686, 9688, 9689, 9690, 9691, 9692, 9695, 9696, 9698, 9699, 9800, 9801, 9802, 9805, 9806, 9808, 9809, 9810, 9811, 9812, 9815, 9816, 9818, 9819, 9820, 9821, 9822, 9825, 9826, 9828, 9829, 9850, 9851, 9852, 9855, 9856, 9858, 9859, 9860, 9861, 9862, 9865, 9866, 9868, 9869, 9880, 9881, 9882, 9885, 9886, 9888, 9889, 9890, 9891, 9892, 9895, 9896, 9898, 9899, 9900, 9901, 9902, 9905, 9906, 9908, 9909, 9910, 9911, 9912, 9915, 9916, 9918, 9919, 9920, 9921, 9922, 9925, 9926, 9928, 9929, 9950, 9951, 9952, 9955, 9956, 9958, 9959, 9960, 9961, 9962, 9965, 9966, 9968, 9969, 9980, 9981, 9982, 9985, 9986, 9988, 9989, 9990, 9991, 9992, 9995, 9996, 9998, 9999\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 173248,
                "title": "c-write-an-elegant-solution-using-hashset-issubsetof-api",
                "content": "Sept. 22, 2018\\nIt is an easy level string algorithm. I studied one of most popular post in the discuss and wrote the one using the same idea. \\n\\n```\\npublic class Solution {\\n    /// <summary>\\n        /// convert integer to string\\n        /// go over each string to determine if it is a good number\\n        /// 0, 1, 8 -> rotate to itself\\n        /// 2<->5\\n        /// 6<->9\\n        /// 3, 4, 7, 8 does not apply rotation\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n    public int RotatedDigits(int N)\\n        {\\n            if (N <= 0)\\n                return -1;\\n\\n            int goodNumberCount = 0;           \\n            \\n            var rotateToItself = new HashSet<char>(\"018\".ToCharArray());\\n            var rotable = new HashSet<char>(\"2569018\".ToCharArray());\\n\\n            for(int i = 1; i <= N; i++)\\n            {     \\n                var digits = new HashSet<char>(i.ToString().ToCharArray());\\n                if (digits.IsSubsetOf(rotable) && !digits.IsSubsetOf(rotateToItself))\\n                    goodNumberCount++;                                 \\n            }\\n\\n            return goodNumberCount;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /// <summary>\\n        /// convert integer to string\\n        /// go over each string to determine if it is a good number\\n        /// 0, 1, 8 -> rotate to itself\\n        /// 2<->5\\n        /// 6<->9\\n        /// 3, 4, 7, 8 does not apply rotation\\n        /// </summary>\\n        /// <param name=\"N\"></param>\\n        /// <returns></returns>\\n    public int RotatedDigits(int N)\\n        {\\n            if (N <= 0)\\n                return -1;\\n\\n            int goodNumberCount = 0;           \\n            \\n            var rotateToItself = new HashSet<char>(\"018\".ToCharArray());\\n            var rotable = new HashSet<char>(\"2569018\".ToCharArray());\\n\\n            for(int i = 1; i <= N; i++)\\n            {     \\n                var digits = new HashSet<char>(i.ToString().ToCharArray());\\n                if (digits.IsSubsetOf(rotable) && !digits.IsSubsetOf(rotateToItself))\\n                    goodNumberCount++;                                 \\n            }\\n\\n            return goodNumberCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159921,
                "title": "python-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        counter = 0\\n        \\n        # digits that are valid after rotation\\n        valid_digits = set([0,1,2,5,6,8,9])\\n        # digits that are different after rotation\\n        flip_different = set([2,5,6,9])\\n        \\n        # iterate thru numbers\\n        for num in range(0,N+1):\\n            digits = [int(i) for i in str(num)]\\n            # to have a good number: 1) all digits have to be valid, 2) at least one digit is differnt after rotation\\n            if (set(digits).issubset(valid_digits) and set(digits).intersection(flip_different)):\\n                counter += 1\\n        \\n        return counter\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        counter = 0\\n        \\n        # digits that are valid after rotation\\n        valid_digits = set([0,1,2,5,6,8,9])\\n        # digits that are different after rotation\\n        flip_different = set([2,5,6,9])\\n        \\n        # iterate thru numbers\\n        for num in range(0,N+1):\\n            digits = [int(i) for i in str(num)]\\n            # to have a good number: 1) all digits have to be valid, 2) at least one digit is differnt after rotation\\n            if (set(digits).issubset(valid_digits) and set(digits).intersection(flip_different)):\\n                counter += 1\\n        \\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005982,
                "title": "simple-string-based-beginners-approach",
                "content": "# Approach\\nWe go through all the integer values from [1,n] range and then check if rotated string satifies the condition\\n\\nif it does then increment the count and simply return the count value\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string rotate(string s){\\n        string temp=\"\";\\n        bool check=true;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'0\\' || s[i]==\\'1\\' || s[i]==\\'8\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]==\\'2\\'){\\n                temp+=\\'5\\';\\n            }\\n            else if(s[i]==\\'5\\'){\\n                temp+=\\'2\\';\\n            }\\n            else if(s[i]==\\'6\\'){\\n                temp+=\\'9\\';\\n            }\\n            else if(s[i]==\\'9\\'){\\n                temp+=\\'6\\';\\n            }\\n            else{\\n                check=false;\\n                break;\\n            }\\n        }\\n        if(check==false){\\n            return \"-1\";\\n        }\\n        return temp;\\n    }\\n    int rotatedDigits(int n) {\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            string s=to_string(i);\\n            string check=rotate(s);\\n            if(s!=check && check!=\"-1\"){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string rotate(string s){\\n        string temp=\"\";\\n        bool check=true;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'0\\' || s[i]==\\'1\\' || s[i]==\\'8\\'){\\n                temp+=s[i];\\n            }\\n            else if(s[i]==\\'2\\'){\\n                temp+=\\'5\\';\\n            }\\n            else if(s[i]==\\'5\\'){\\n                temp+=\\'2\\';\\n            }\\n            else if(s[i]==\\'6\\'){\\n                temp+=\\'9\\';\\n            }\\n            else if(s[i]==\\'9\\'){\\n                temp+=\\'6\\';\\n            }\\n            else{\\n                check=false;\\n                break;\\n            }\\n        }\\n        if(check==false){\\n            return \"-1\";\\n        }\\n        return temp;\\n    }\\n    int rotatedDigits(int n) {\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n            string s=to_string(i);\\n            string check=rotate(s);\\n            if(s!=check && check!=\"-1\"){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769647,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n     public int rotatedDigits(int n) {\\n        int count = 0;\\n\\n        for(int i = 1; i <= n; i++){\\n            String temp = String.valueOf(i) ;\\n            if(temp.contains(\"2\") || temp.contains(\"5\") || temp.contains(\"6\") || temp.contains(\"9\")) {\\n                if(!temp.contains(\"3\") && !temp.contains(\"7\") && !temp.contains(\"4\")){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int rotatedDigits(int n) {\\n        int count = 0;\\n\\n        for(int i = 1; i <= n; i++){\\n            String temp = String.valueOf(i) ;\\n            if(temp.contains(\"2\") || temp.contains(\"5\") || temp.contains(\"6\") || temp.contains(\"9\")) {\\n                if(!temp.contains(\"3\") && !temp.contains(\"7\") && !temp.contains(\"4\")){\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669936,
                "title": "typical-digit-dp",
                "content": "If you know digit dp then this is trivial\\n\\nIf you contain a 3 or 4 or 7 then this number cannot be good\\n\\nIf you contain 2 or 5 or 6 or 9 then this number is automatically good provided that it doesnt contain any 3 or 4 or 7\\n\\n0,1,8 do nothing. \\n\\nStore pareamter good, good = True means that the number is going to be good\\n\\n# Code\\n```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        \\n        n = str(n)\\n        def helper(strict, pointer, good):\\n            if pointer == len(n) and good:\\n                return 1\\n            if pointer == len(n) and not good: return 0\\n            currentBound = int(n[pointer])\\n            s = 0\\n            if strict:\\n                for i in [0,1,8]:\\n                    if i < currentBound: s+= helper(False, pointer + 1, good)\\n                    elif i == currentBound: s += helper(True, pointer + 1, good)\\n                    else: pass\\n                for i in [2,5,6,9]:\\n                    if i < currentBound: s+= helper(False, pointer + 1, True)\\n                    elif i == currentBound: s += helper(True, pointer + 1, True)\\n                    else: pass\\n            else:\\n                for i in [0,1,8]:\\n                    s += helper(False, pointer + 1, good)\\n                for i in [2,5,6,9]:\\n                    s += helper(False, pointer + 1, True)            \\n            return s\\n\\n        return helper(True, 0, False)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        \\n        n = str(n)\\n        def helper(strict, pointer, good):\\n            if pointer == len(n) and good:\\n                return 1\\n            if pointer == len(n) and not good: return 0\\n            currentBound = int(n[pointer])\\n            s = 0\\n            if strict:\\n                for i in [0,1,8]:\\n                    if i < currentBound: s+= helper(False, pointer + 1, good)\\n                    elif i == currentBound: s += helper(True, pointer + 1, good)\\n                    else: pass\\n                for i in [2,5,6,9]:\\n                    if i < currentBound: s+= helper(False, pointer + 1, True)\\n                    elif i == currentBound: s += helper(True, pointer + 1, True)\\n                    else: pass\\n            else:\\n                for i in [0,1,8]:\\n                    s += helper(False, pointer + 1, good)\\n                for i in [2,5,6,9]:\\n                    s += helper(False, pointer + 1, True)            \\n            return s\\n\\n        return helper(True, 0, False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136317,
                "title": "very-easy-to-understand-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int rotatedDigits(int n) \\n    {\\n        map<int,int> m;\\n        m[0]=0; m[1]=1; m[8]=8; m[6]=9; m[9]=6; m[2]=5; m[5]=2;\\n        int count=0;\\n        for(int x=1; x<=n; x++)\\n        {\\n            string s=to_string(x);\\n            auto i1=s.find(\"2\"), i2=s.find(\"5\"), i3=s.find(\"6\"), i4=s.find(\"9\"), i5=s.find(\"3\"), i6=s.find(\"4\"), i7=s.find(\"7\");\\n            if((i1!=string::npos || i2!=string::npos || i3!=string::npos || i4!=string::npos) && (i5==string::npos && i6==string::npos && i7==string::npos)) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int rotatedDigits(int n) \\n    {\\n        map<int,int> m;\\n        m[0]=0; m[1]=1; m[8]=8; m[6]=9; m[9]=6; m[2]=5; m[5]=2;\\n        int count=0;\\n        for(int x=1; x<=n; x++)\\n        {\\n            string s=to_string(x);\\n            auto i1=s.find(\"2\"), i2=s.find(\"5\"), i3=s.find(\"6\"), i4=s.find(\"9\"), i5=s.find(\"3\"), i6=s.find(\"4\"), i7=s.find(\"7\");\\n            if((i1!=string::npos || i2!=string::npos || i3!=string::npos || i4!=string::npos) && (i5==string::npos && i6==string::npos && i7==string::npos)) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097809,
                "title": "brute-force-method-java",
                "content": "class Solution {\\n    public int rotatedDigits(int n) {\\n        int count=0;\\n        for(int i=2;i<=n;i++){\\n            int temp=i;\\n            int flag=0;\\n            \\n            while(temp!=0){\\n                int d=temp%10;\\n                \\n                if(d==3 || d==4 || d==7){\\n                    break;\\n                }else if(d==2||d==5||d==6||d==9){\\n                    flag++;\\n                }\\n                \\n                \\n                temp=temp/10;\\n            }\\n            if(temp==0 && flag>0){\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int rotatedDigits(int n) {\\n        int count=0;\\n        for(int i=2;i<=n;i++){\\n            int temp=i;\\n            int flag=0;\\n            \\n            while(temp!=0){\\n                int d=temp%10;\\n                \\n                if(d==3 || d==4 || d==7){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2063497,
                "title": "python-straightforward-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        ans = 0\\n        for i in range(1, n+1):\\n            p = \\'\\'\\n            if \\'3\\' in str(i) or \\'4\\' in str(i) or \\'7\\' in str(i):\\n                continue\\n            for j in str(i):\\n                if j == \\'0\\':\\n                    p += \\'0\\'\\n                elif j == \\'1\\':\\n                    p += \\'1\\'\\n                elif j == \\'8\\':\\n                    p += \\'8\\'\\n                \\n                elif j == \\'2\\':\\n                    p += \\'5\\'\\n                elif j == \\'5\\':\\n                    p += \\'2\\'\\n                \\n                elif j == \\'6\\':\\n                    p += \\'9\\'\\n                elif j == \\'9\\':\\n                    p += \\'6\\'\\n                    \\n            if p != str(i):\\n                ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        ans = 0\\n        for i in range(1, n+1):\\n            p = \\'\\'\\n            if \\'3\\' in str(i) or \\'4\\' in str(i) or \\'7\\' in str(i):\\n                continue\\n            for j in str(i):\\n                if j == \\'0\\':\\n                    p += \\'0\\'\\n                elif j == \\'1\\':\\n                    p += \\'1\\'\\n                elif j == \\'8\\':\\n                    p += \\'8\\'\\n                \\n                elif j == \\'2\\':\\n                    p += \\'5\\'\\n                elif j == \\'5\\':\\n                    p += \\'2\\'\\n                \\n                elif j == \\'6\\':\\n                    p += \\'9\\'\\n                elif j == \\'9\\':\\n                    p += \\'6\\'\\n                    \\n            if p != str(i):\\n                ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032388,
                "title": "easy-python-again",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        res = 0\\n        for i in range(n+1):\\n            tmp = set(str(i))\\n            if (tmp - {\\'1\\', \\'0\\', \\'8\\'}) and not tmp & {\\'3\\', \\'7\\', \\'4\\'}:\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        res = 0\\n        for i in range(n+1):\\n            tmp = set(str(i))\\n            if (tmp - {\\'1\\', \\'0\\', \\'8\\'}) and not tmp & {\\'3\\', \\'7\\', \\'4\\'}:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678352,
                "title": "c-n-log10-n-100-fast",
                "content": "// idea is simple \\n// just go through each numbers digit and as soon as we encounter a digit \\n// that\\'s rotation is not valid according to the conditions that is given in the\\n// problem we simply say that, that number is not the answer and we move ahead\\n// to next number\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n           int ans = 0;\\n        \\n          for(int i = 1; i<=n; i++){\\n               bool flag = false;\\n               int num = i;\\n               while(num > 0){\\n                   int dig = num % 10;\\n                   if( dig == 3 || dig == 4 || dig == 7)\\n                   { flag = false; break;}\\n                   \\n                   if(dig == 2 || dig == 5 || dig == 6 || dig == 9)\\n                       flag = true;\\n                   num /= 10;\\n               }\\n              \\n              if(flag) ans++;\\n          }\\n            return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n           int ans = 0;\\n        \\n          for(int i = 1; i<=n; i++){\\n               bool flag = false;\\n               int num = i;\\n               while(num > 0){\\n                   int dig = num % 10;\\n                   if( dig == 3 || dig == 4 || dig == 7)\\n                   { flag = false; break;}",
                "codeTag": "Java"
            },
            {
                "id": 1586850,
                "title": "c-simple-o-nlogn-sol-well-commented-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(int n){\\n        int arr[10];\\n        memset(arr,0, sizeof(arr));\\n        \\n        //Extract all digits present in n\\n        while(n){\\n            arr[n%10] = 1;\\n            n /= 10;\\n        }\\n        \\n        //If number contains digit 3,4 or 7 then it will not give a valid number after rotation\\n        for(int i=0; i<10; i++){\\n            if(arr[i] && (i==3 || i == 4 || i == 7))\\n                return false;\\n        }\\n        \\n        //If number doesn\\'t have 3,4 or 7 mean all other digits are rotatable\\n        //If number have digits other then 0,1 & 8 then it will always give different number after rotation\\n        for(int i=0; i<10; i++){\\n            if(arr[i] && i != 0 && i!=1 && i!=8 )\\n                return true;\\n        }\\n        //If digits are just 0,1 or 8 then number will be the same after rotation, thatswhy return false\\n        return false;\\n    }\\n    \\n    int rotatedDigits(int n) {\\n        int c=0;\\n        \\n        //Check for each good number from 2 to n\\n        for(int i=2; i<=n; i++){\\n            if(check(i))\\n                c++;\\n        }\\n        \\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool check(int n){\\n        int arr[10];\\n        memset(arr,0, sizeof(arr));\\n        \\n        //Extract all digits present in n\\n        while(n){\\n            arr[n%10] = 1;\\n            n /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1498691,
                "title": "python3-accepted-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        count=0\\n        li = []\\n        for i in range(1,n+1):\\n            if(str(i).count(\"3\")>0 or str(i).count(\"4\")>0 or str(i).count(\"7\")>0):\\n                continue\\n            elif(str(i).count(\"0\") + str(i).count(\"1\") + str(i).count(\"8\") == len(str(i))):\\n                continue\\n            else:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        count=0\\n        li = []\\n        for i in range(1,n+1):\\n            if(str(i).count(\"3\")>0 or str(i).count(\"4\")>0 or str(i).count(\"7\")>0):\\n                continue\\n            elif(str(i).count(\"0\") + str(i).count(\"1\") + str(i).count(\"8\") == len(str(i))):\\n                continue\\n            else:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472757,
                "title": "c-0ms-100-faster-digit-dp-top-down-method",
                "content": "step 1: convert integer to string\\nstep 2: for each character, check \"are we under tight contraint\" :\\n\\t\\t\\ttight contraint means have we reached its max value ie its upper bound\\n\\t\\t\\tif we are under tight contraint then set ub = s[i] (s[i] is max value it can go, if it goes greater than s[i] then it will not be in range [1, n])\\n\\t\\t\\telse set ub = 9\\nstep 3: if we are geting j == 3 or j == 4 or j ==7, we simply continue because they are not good.\\nstep 4: when i am calling solve(), i am passing  \" p | rot[j] \":\\n\\t\\t\\tif that is true or 1, then we have already found good number and we have got 1 good number so return 1\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\tstring s;\\n    unordered_map <int, bool> rot;\\n    int dp[10001][2][2];\\n    int solve(int i, int t, int p) {\\n        \\n        if (i == s.length()) {\\n            if (p)\\n                return 1;\\n            else \\n                return 0;\\n        }\\n        \\n        if (dp[i][t][p] != -1)\\n            return dp[i][t][p];\\n        \\n        int ub = t ? s[i]-\\'0\\' : 9;\\n        int ans = 0;\\n        for (int j = 0; j <= ub; j++) {\\n            if (j == 3 || j == 4 || j == 7)\\n                continue;\\n            \\n            ans += solve(i+1, t&(j==ub), p|rot[j]);\\n        }\\n        \\n        return dp[i][t][p] = ans;\\n    }\\n    int rotatedDigits(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        s = to_string(n);\\n        rot[2] = true;\\n        rot[5] = true;\\n        rot[6] = true;\\n        rot[9] = true;\\n        return solve(0,1,0);\\n    }",
                "solutionTags": [],
                "code": "step 1: convert integer to string\\nstep 2: for each character, check \"are we under tight contraint\" :\\n\\t\\t\\ttight contraint means have we reached its max value ie its upper bound\\n\\t\\t\\tif we are under tight contraint then set ub = s[i] (s[i] is max value it can go, if it goes greater than s[i] then it will not be in range [1, n])\\n\\t\\t\\telse set ub = 9\\nstep 3: if we are geting j == 3 or j == 4 or j ==7, we simply continue because they are not good.\\nstep 4: when i am calling solve(), i am passing  \" p | rot[j] \":\\n\\t\\t\\tif that is true or 1, then we have already found good number and we have got 1 good number so return 1\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\tstring s;\\n    unordered_map <int, bool> rot;\\n    int dp[10001][2][2];\\n    int solve(int i, int t, int p) {\\n        \\n        if (i == s.length()) {\\n            if (p)\\n                return 1;\\n            else \\n                return 0;\\n        }\\n        \\n        if (dp[i][t][p] != -1)\\n            return dp[i][t][p];\\n        \\n        int ub = t ? s[i]-\\'0\\' : 9;\\n        int ans = 0;\\n        for (int j = 0; j <= ub; j++) {\\n            if (j == 3 || j == 4 || j == 7)\\n                continue;\\n            \\n            ans += solve(i+1, t&(j==ub), p|rot[j]);\\n        }\\n        \\n        return dp[i][t][p] = ans;\\n    }\\n    int rotatedDigits(int n) {\\n        memset(dp, -1, sizeof(dp));\\n        s = to_string(n);\\n        rot[2] = true;\\n        rot[5] = true;\\n        rot[6] = true;\\n        rot[9] = true;\\n        return solve(0,1,0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1427945,
                "title": "c-solution-easy-solution-just-comparing-the-digits-of-num-with-the-digits-given-in-condition",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int c=0,i;\\n        for(int j=1;j<=n;j++)\\n        {\\n            bool f=false;\\n            i=j;\\n            while(i>0)\\n            {\\n                int r=i%10;\\n                if(r==3 || r==4 || r==7)\\n                {\\n                   f=false;\\n                   break;\\n                } \\n                else if(r==2 || r==5 || r==6 || r==9)\\n                   f=true;\\n                i=i/10;\\n            }\\n            if(f)\\n              c+=1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int c=0,i;\\n        for(int j=1;j<=n;j++)\\n        {\\n            bool f=false;\\n            i=j;\\n            while(i>0)\\n            {\\n                int r=i%10;\\n                if(r==3 || r==4 || r==7)\\n                {\\n                   f=false;\\n                   break;\\n                } \\n                else if(r==2 || r==5 || r==6 || r==9)\\n                   f=true;\\n                i=i/10;\\n            }\\n            if(f)\\n              c+=1;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343888,
                "title": "simple-memorization-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        vector<int> vec(n+10,-1);\\n        \\n        int count = 0;\\n        vec[0]=0;\\n        for(int i=1;i<=n;i++){\\n            \\n            int a=i%10;\\n            int b=i/10;\\n            if(a==2||a==5||a==6||a==9) vec[a]=1;\\n            \\n            if(a==0||a==1||a==8) vec[a]=0;\\n            \\n            if(a==4||a==7||a==3) {\\n                vec[i]=-1;\\n                continue;\\n            }\\n            if(vec[b]==-1) continue;\\n            \\n            if(vec[a]==1 || vec[b]==1){\\n                count++;\\n                vec[i]=1;\\n            }\\n            \\n            else vec[i]=0;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        vector<int> vec(n+10,-1);\\n        \\n        int count = 0;\\n        vec[0]=0;\\n        for(int i=1;i<=n;i++){\\n            \\n            int a=i%10;\\n            int b=i/10;\\n            if(a==2||a==5||a==6||a==9) vec[a]=1;\\n            \\n            if(a==0||a==1||a==8) vec[a]=0;\\n            \\n            if(a==4||a==7||a==3) {\\n                vec[i]=-1;\\n                continue;\\n            }\\n            if(vec[b]==-1) continue;\\n            \\n            if(vec[a]==1 || vec[b]==1){\\n                count++;\\n                vec[i]=1;\\n            }\\n            \\n            else vec[i]=0;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1306240,
                "title": "python-simplest-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        count = 0\\n        for i in range(1, n + 1):\\n            num = str(i)\\n            if \\'3\\' in num or \\'7\\' in num or \\'4\\' in num: \\n                continue\\n            if \\'2\\' in num or \\'5\\' in num or \\'6\\' in num or \\'9\\' in num:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, n: int) -> int:\\n        count = 0\\n        for i in range(1, n + 1):\\n            num = str(i)\\n            if \\'3\\' in num or \\'7\\' in num or \\'4\\' in num: \\n                continue\\n            if \\'2\\' in num or \\'5\\' in num or \\'6\\' in num or \\'9\\' in num:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296633,
                "title": "self-explanatory-c-easy-faster-than-100-00-of-c-online-submissions",
                "content": "```\\n// x is a good number if after rotating each digit individually by 180 degrees,\\n// we get a valid number that is different from x\\n//logic is give in second para of the question \\n//  1 and 10 are not good numbers, since they remain unchanged after rotating\\n// 2 and 5 rotate to each other\\n// 6 and 9 rotate to each other\\nclass Solution {\\npublic:\\n    bool checkdigit(int n){\\n        int t;\\n        bool f=0;\\n        while(n){\\n            t=n%10;\\n            if(t==3 || t==4 || t==7) return 0;\\n            if(t==2 || t==5 || t==6 || t==9) f=1;     \\n            n/=10;\\n        }\\n        return f;\\n    }\\n    int rotatedDigits(int N) {\\n        int ans=0;\\n        for(int i=2;i<=N;i++){\\n            ans+=checkdigit(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// x is a good number if after rotating each digit individually by 180 degrees,\\n// we get a valid number that is different from x\\n//logic is give in second para of the question \\n//  1 and 10 are not good numbers, since they remain unchanged after rotating\\n// 2 and 5 rotate to each other\\n// 6 and 9 rotate to each other\\nclass Solution {\\npublic:\\n    bool checkdigit(int n){\\n        int t;\\n        bool f=0;\\n        while(n){\\n            t=n%10;\\n            if(t==3 || t==4 || t==7) return 0;\\n            if(t==2 || t==5 || t==6 || t==9) f=1;     \\n            n/=10;\\n        }\\n        return f;\\n    }\\n    int rotatedDigits(int N) {\\n        int ans=0;\\n        for(int i=2;i<=N;i++){\\n            ans+=checkdigit(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278012,
                "title": "c-solution-0-ms",
                "content": "```\\n\\n\\nint rotatedDigits(int n){\\n    int i,c=0;\\n    bool flg=false;\\n    char* is_valid[]={\"same\",\"same\",\"valid\",\"invalid\",\"invalid\",\"valid\",\"valid\",\"invalid\",\"same\",\"valid\"};\\n    for(i=2;i<=n;i++)\\n    {\\n        int r=i,flg=false;\\n        while(r>0){\\n            int t=r%10;\\n            if(is_valid[t]==\"invalid\") {flg=false;break;}\\n            if(is_valid[t]==\"valid\") flg=true;\\n            r=r/10;\\n        }\\n        if(flg) c++;\\n    }\\n    return c;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nint rotatedDigits(int n){\\n    int i,c=0;\\n    bool flg=false;\\n    char* is_valid[]={\"same\",\"same\",\"valid\",\"invalid\",\"invalid\",\"valid\",\"valid\",\"invalid\",\"same\",\"valid\"};\\n    for(i=2;i<=n;i++)\\n    {\\n        int r=i,flg=false;\\n        while(r>0){\\n            int t=r%10;\\n            if(is_valid[t]==\"invalid\") {flg=false;break;}\\n            if(is_valid[t]==\"valid\") flg=true;\\n            r=r/10;\\n        }\\n        if(flg) c++;\\n    }\\n    return c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1259978,
                "title": "python-simple-solution-using-sets",
                "content": "```python\\ndef rotatedDigits(self, n: int) -> int:\\n        invalid_nums = set([3,4,7])\\n        change_nums = set([2,5,6,9])\\n        \\n        def isGood(num):\\n            changed_num = False\\n            while num:\\n                num, rem = divmod(num, 10)\\n                if rem in invalid_nums:\\n                    return False\\n                if rem in change_nums:\\n                    changed_num = True\\n            return changed_num\\n    \\n        return sum(isGood(i) for i in range(1,n+1))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef rotatedDigits(self, n: int) -> int:\\n        invalid_nums = set([3,4,7])\\n        change_nums = set([2,5,6,9])\\n        \\n        def isGood(num):\\n            changed_num = False\\n            while num:\\n                num, rem = divmod(num, 10)\\n                if rem in invalid_nums:\\n                    return False\\n                if rem in change_nums:\\n                    changed_num = True\\n            return changed_num\\n    \\n        return sum(isGood(i) for i in range(1,n+1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1238923,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool numberRotates(int num){\\n        bool rotates = false;\\n        while (num > 0) {\\n\\t\\t    int t = num % 10;\\n            \\n            if (t == 2 || t == 5 || t == 6 || t == 9)\\n\\t\\t\\t    rotates = true;\\n\\t\\t\\t\\n            if (t == 3 || t == 4 || t == 7) \\n                return false;\\n            \\n            num /= 10;\\n\\t\\t}\\n        \\n        return rotates;\\n    }\\n    \\npublic:\\n\\tint rotatedDigits(int n) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 1; i <= n; i++)\\n            if(numberRotates(i)) count++;\\n\\t\\t\\t\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool numberRotates(int num){\\n        bool rotates = false;\\n        while (num > 0) {\\n\\t\\t    int t = num % 10;\\n            \\n            if (t == 2 || t == 5 || t == 6 || t == 9)\\n\\t\\t\\t    rotates = true;\\n\\t\\t\\t\\n            if (t == 3 || t == 4 || t == 7) \\n                return false;\\n            \\n            num /= 10;\\n\\t\\t}\\n        \\n        return rotates;\\n    }\\n    \\npublic:\\n\\tint rotatedDigits(int n) {\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 1; i <= n; i++)\\n            if(numberRotates(i)) count++;\\n\\t\\t\\t\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222475,
                "title": "c-hashsets",
                "content": "```\\npublic class Solution {\\n    public int RotatedDigits(int n) {\\n        \\n        var good = new HashSet<int>() {2, 5, 6, 9 };\\n        var set = new HashSet<int>() {0, 1, 8};\\n        \\n        int count = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            var isGood = false;\\n            var num = i; //gotcha           \\n            while(num > 0)\\n            {\\n                var digit = num%10; \\n                if(!good.Contains(digit) && !set.Contains(digit))\\n                    break;\\n                \\n                if (good.Contains(digit))\\n                {\\n                    isGood = true;\\n                }                   \\n                num = num/10;\\n            }\\n            if(num == 0 && isGood)\\n            {               \\n                count++;   \\n            }                           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int RotatedDigits(int n) {\\n        \\n        var good = new HashSet<int>() {2, 5, 6, 9 };\\n        var set = new HashSet<int>() {0, 1, 8};\\n        \\n        int count = 0;\\n        for(int i = 1; i <= n; i++)\\n        {\\n            var isGood = false;\\n            var num = i; //gotcha           \\n            while(num > 0)\\n            {\\n                var digit = num%10; \\n                if(!good.Contains(digit) && !set.Contains(digit))\\n                    break;\\n                \\n                if (good.Contains(digit))\\n                {\\n                    isGood = true;\\n                }                   \\n                num = num/10;\\n            }\\n            if(num == 0 && isGood)\\n            {               \\n                count++;   \\n            }                           \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203054,
                "title": "c-speed-o-log-n-space-o-log-n",
                "content": "Since n <= 10000, any O(n x log(n)) solution would pass, but if this is a Google interview, most likely such a solution would be considered sub-optimal, so here is the O(log(n)) solution.\\n\\nThere are 7 valid digits, i.e. 0, 1, 2, 5, 6, 8, 9;\\nand 3 valid, non-rotatable digits, i.e. 0,1,8.\\n\\nFor n = 1234, we count as follows:\\n-- aaa: 7^3-3^3\\n7^3 for aaa, a = 0,1,2,5,6,8,9\\nover counting: 3^3 for aaa, a = 0,1,8\\n\\n-- 1baa, b < 2: 7^2x2 - 3^2x2\\n7^2 for each of 10aa and 11aa, a = 0,1,2,5,6,8,9\\nover counting: 3^2 for each of 10aa and 11aa, a = 0,1,8\\n\\n-- 12ca, c < 3; 7x3 = 21\\n7 for each of 120a, 121a and 122a, a = 0,1,2,5,6,8,9\\nno over counting\\n\\n-- 123a: 0\\nno valid numer\\n\\n```\\npublic:\\n    int rotatedDigits(int n) {\\n        vector<int> digits;\\n        int m = n+1, ans = 0, p7 = 1, p3 = 1;;\\n        while (m > 0) {\\n            int d = m%10;\\n            digits.push_back(d);\\n            m = (m-d)/10;\\n            p7 *= 7, p3 *= 3;\\n        }\\n        \\n        bool prefix = false;\\n        while (!digits.empty()) {\\n            int d = digits.back();\\n            digits.pop_back();\\n            p7 /= 7;\\n            p3 /= 3;\\n            \\n            ans += b[d]*p7 - (prefix ? 0 : a[d]*p3);\\n            \\n            if (d == 3 || d == 4 || d == 7) break;\\n            prefix = prefix || d == 2 || d == 5 || d == 6 || d == 9;\\n        }\\n        return ans;\\n    }\\nprivate:\\n    // counting 0, 1, 8\\n    int a [10] = {0, 1, 2, 2, 2, 2, 2, 2, 2, 3};\\n    \\n    // counting 0, 1, 2, 5, 6, 8, 9\\n    int b [10] = {0, 1, 2, 3, 3, 3, 4, 5, 5, 6};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    int rotatedDigits(int n) {\\n        vector<int> digits;\\n        int m = n+1, ans = 0, p7 = 1, p3 = 1;;\\n        while (m > 0) {\\n            int d = m%10;\\n            digits.push_back(d);\\n            m = (m-d)/10;\\n            p7 *= 7, p3 *= 3;\\n        }\\n        \\n        bool prefix = false;\\n        while (!digits.empty()) {\\n            int d = digits.back();\\n            digits.pop_back();\\n            p7 /= 7;\\n            p3 /= 3;\\n            \\n            ans += b[d]*p7 - (prefix ? 0 : a[d]*p3);\\n            \\n            if (d == 3 || d == 4 || d == 7) break;\\n            prefix = prefix || d == 2 || d == 5 || d == 6 || d == 9;\\n        }\\n        return ans;\\n    }\\nprivate:\\n    // counting 0, 1, 8\\n    int a [10] = {0, 1, 2, 2, 2, 2, 2, 2, 2, 3};\\n    \\n    // counting 0, 1, 2, 5, 6, 8, 9\\n    int b [10] = {0, 1, 2, 3, 3, 3, 4, 5, 5, 6};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167312,
                "title": "javascript-easy-and-short-solution-90-80",
                "content": "Runtime: 80 ms, faster than 90.68% of JavaScript online submissions for Rotated Digits.\\nMemory Usage: 39 MB, less than 80.12% of JavaScript online submissions for Rotated Digits.\\n```\\nvar rotatedDigits = function(N) {\\n    var res = 0\\n    for(i=1;i<=N;i++){\\n        let j = i.toString()\\n        if(j.includes(\"3\")||j.includes(\"4\")||j.includes(\"7\")) continue;\\n        if(j.includes(\"2\")||j.includes(\"5\")||j.includes(\"6\")||j.includes(\"9\")) res++\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotatedDigits = function(N) {\\n    var res = 0\\n    for(i=1;i<=N;i++){\\n        let j = i.toString()\\n        if(j.includes(\"3\")||j.includes(\"4\")||j.includes(\"7\")) continue;\\n        if(j.includes(\"2\")||j.includes(\"5\")||j.includes(\"6\")||j.includes(\"9\")) res++\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1072163,
                "title": "4-ms-faster-than-73-54-of-java",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(isGoodNumber(i)) {\\n                count++;\\n            }\\n        }\\n        return count;        \\n    }\\n    \\n    private boolean isGoodNumber(int num) {\\n        boolean isValid = false;\\n        \\n        int n = num;\\n        while(n > 0) {\\n            int rem = n % 10;\\n            if(rem == 3 || rem == 4 || rem == 7) return false;\\n            if(rem == 2 || rem == 5 || rem == 6 || rem == 9) isValid = true;\\n            n /= 10;\\n        }\\n        return isValid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(isGoodNumber(i)) {\\n                count++;\\n            }\\n        }\\n        return count;        \\n    }\\n    \\n    private boolean isGoodNumber(int num) {\\n        boolean isValid = false;\\n        \\n        int n = num;\\n        while(n > 0) {\\n            int rem = n % 10;\\n            if(rem == 3 || rem == 4 || rem == 7) return false;\\n            if(rem == 2 || rem == 5 || rem == 6 || rem == 9) isValid = true;\\n            n /= 10;\\n        }\\n        return isValid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1026037,
                "title": "java-4ms-solution",
                "content": "class Solution\\n{\\n    public int rotatedDigits(int N) \\n    {\\n        int ans=0;\\n        for(int i=1;i<=N;i++)\\n        {\\n            ans+=check(i);\\n        }\\n        return ans;\\n    }\\n    int check(int n)\\n    {\\n        boolean flag=false;\\n        while(n!=0)\\n        {\\n            int a=n%10;\\n            if(a==2 || a==5 || a==6 || a==9) flag=true;\\n            if(a==3 || a==4 || a==7) return 0;\\n            n=n/10;\\n        }\\n        return flag?1:0;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution\\n{\\n    public int rotatedDigits(int N) \\n    {\\n        int ans=0;\\n        for(int i=1;i<=N;i++)\\n        {\\n            ans+=check(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 957783,
                "title": "0ms-100-faster-simple-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool good(int x){\\n        int y;\\n        bool rotated=false;\\n        while(x>0){\\n            y=x%10;\\n            switch(y){\\n                case 0:\\n                case 1:\\n                case 8:\\n                    break;\\n                case 2:\\n                case 5:\\n                case 6:\\n                case 9:\\n                    rotated = true;\\n                    break;\\n                default:\\n                    return false;\\n            }\\n            x=x/10;\\n        }\\n        return rotated;\\n    }\\n    \\n    int rotatedDigits(int N) {\\n        int count =0;\\n        for(int i=1;i<=N;i++){\\n            if(good(i)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool good(int x){\\n        int y;\\n        bool rotated=false;\\n        while(x>0){\\n            y=x%10;\\n            switch(y){\\n                case 0:\\n                case 1:\\n                case 8:\\n                    break;\\n                case 2:\\n                case 5:\\n                case 6:\\n                case 9:\\n                    rotated = true;\\n                    break;\\n                default:\\n                    return false;\\n            }\\n            x=x/10;\\n        }\\n        return rotated;\\n    }\\n    \\n    int rotatedDigits(int N) {\\n        int count =0;\\n        for(int i=1;i<=N;i++){\\n            if(good(i)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937182,
                "title": "javascript-solution-brute-force-solution",
                "content": "```\\nvar rotatedDigits = function(N) {\\n    let count = 0;\\n    \\n    for (let i = 1; i <= N; i++) {\\n        if (isValidDiffNum(i)) count++;\\n    }\\n\\n    return count;\\n        \\n    function isValidDiffNum(num) {\\n        let isValid = true;\\n        let isDiff = false;\\n        \\n        while (num > 0) {\\n            const lastDig = num % 10;\\n            \\n            if (lastDig === 3 || lastDig === 4 || lastDig === 7) {\\n                isValid = false;\\n                break;\\n            }\\n            else if (lastDig === 2 || lastDig === 5 || lastDig === 6 || lastDig === 9) {\\n                isDiff = true;\\n            }\\n            \\n            num = Math.floor(num / 10);\\n        }\\n        \\n        return isValid && isDiff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar rotatedDigits = function(N) {\\n    let count = 0;\\n    \\n    for (let i = 1; i <= N; i++) {\\n        if (isValidDiffNum(i)) count++;\\n    }\\n\\n    return count;\\n        \\n    function isValidDiffNum(num) {\\n        let isValid = true;\\n        let isDiff = false;\\n        \\n        while (num > 0) {\\n            const lastDig = num % 10;\\n            \\n            if (lastDig === 3 || lastDig === 4 || lastDig === 7) {\\n                isValid = false;\\n                break;\\n            }\\n            else if (lastDig === 2 || lastDig === 5 || lastDig === 6 || lastDig === 9) {\\n                isDiff = true;\\n            }\\n            \\n            num = Math.floor(num / 10);\\n        }\\n        \\n        return isValid && isDiff;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 925355,
                "title": "python-3-easy-understanding-explained-80-ms-faster-100-mem",
                "content": "Note that the ten individual digits (0-9) can be classified into three catagaries: rotatable digits that become different digits ([\"2\", \"5\", \"6\", \"9\"]), non-rotatable digits ([\"3\", \"4\", \"7\"]), and rotate-to-themselves ones ([\"0\", \"1\", \"8\"]). Based on these catagaries, we can come up with the below solution to determine if the number as a whole is rotatable or in other words, number X is a good number.\\nWe iterate the number digit by digit.\\nIf the digit is in the non-rotatable digits list, e.g. for number 359, the first digit 3 is in the non-rotatable digits list, then we can conclude this number as a whole is invalid because \"**each digit must be rotated**\". In this case, we can move on to the next number.\\nThen if the digit is in the rotatable digits list, we add 1 to the counter \"rotated\".\\nThen if the digit is in the rotate-to-themselves list, we add 1 to the counter \"same\".\\nAfter iterating this number, we need to make a conclusion about whether this number is rotatable or not.\\nHere we need to consider three different scenarios. The *first* one is that all the digits of this number are rotated, e.g. for number 596, it becomes 269 showing all three digits are rotated. So the number is rotatable. We make the conclusion based on the fact that the counter \"rotated\" (in this example, it is 3) is equal to the length of the number (3). Then the *second* scenario is that some digits of this number are rotated and some digits are themselves, e.g. number 2160, it becomes 5190 showing \\'2\\' and \\'6\\' are rotated, and \\'1\\' and \\'0\\' are themselves, this number 2160 counts. The conclusion is made based on the fact that the counter \"rotated\" (in this example, it is 2) plus the counter \"same\" (it is 2) is equal to the length of the number (2+2=4). The *last* scenario is that all the digits are themselves after the rotation, e.g. number 1810. This number doesn\\'t count. The conclusion is made based on the fact that the counter \"rotated\" is zero.\\nSo we combine the above three scenarios, the logic implemention in the code is such \"**(rotated == slen) or (((rotated+same) == slen) and (rotated > 0))**\".\\nAnd don\\'t forget to reset both counters after each number iteration.\\n~~~\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count, rotated, same = 0, 0, 0\\n        rotation = [\"2\", \"5\", \"6\", \"9\"]\\n        themselves = [\"0\", \"1\", \"8\"]\\n        non_rot = [\"3\", \"4\", \"7\"]\\n        for i in range(1, N+1, 1):\\n            nth = str(i)\\n            slen = len(nth)\\n            for char in nth:\\n                if char in non_rot:\\n                    break\\n                elif char in rotation:\\n                    rotated +=1\\n                elif char in themselves:\\n                    same += 1\\n            if (rotated == slen) or (((rotated+same) == slen) and (rotated > 0)):\\n                count += 1\\n            rotated = 0\\n            same = 0\\n        return count\\n~~~",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Note that the ten individual digits (0-9) can be classified into three catagaries: rotatable digits that become different digits ([\"2\", \"5\", \"6\", \"9\"]), non-rotatable digits ([\"3\", \"4\", \"7\"]), and rotate-to-themselves ones ([\"0\", \"1\", \"8\"]). Based on these catagaries, we can come up with the below solution to determine if the number as a whole is rotatable or in other words, number X is a good number.\\nWe iterate the number digit by digit.\\nIf the digit is in the non-rotatable digits list, e.g. for number 359, the first digit 3 is in the non-rotatable digits list, then we can conclude this number as a whole is invalid because \"**each digit must be rotated**\". In this case, we can move on to the next number.\\nThen if the digit is in the rotatable digits list, we add 1 to the counter \"rotated\".\\nThen if the digit is in the rotate-to-themselves list, we add 1 to the counter \"same\".\\nAfter iterating this number, we need to make a conclusion about whether this number is rotatable or not.\\nHere we need to consider three different scenarios. The *first* one is that all the digits of this number are rotated, e.g. for number 596, it becomes 269 showing all three digits are rotated. So the number is rotatable. We make the conclusion based on the fact that the counter \"rotated\" (in this example, it is 3) is equal to the length of the number (3). Then the *second* scenario is that some digits of this number are rotated and some digits are themselves, e.g. number 2160, it becomes 5190 showing \\'2\\' and \\'6\\' are rotated, and \\'1\\' and \\'0\\' are themselves, this number 2160 counts. The conclusion is made based on the fact that the counter \"rotated\" (in this example, it is 2) plus the counter \"same\" (it is 2) is equal to the length of the number (2+2=4). The *last* scenario is that all the digits are themselves after the rotation, e.g. number 1810. This number doesn\\'t count. The conclusion is made based on the fact that the counter \"rotated\" is zero.\\nSo we combine the above three scenarios, the logic implemention in the code is such \"**(rotated == slen) or (((rotated+same) == slen) and (rotated > 0))**\".\\nAnd don\\'t forget to reset both counters after each number iteration.\\n~~~\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count, rotated, same = 0, 0, 0\\n        rotation = [\"2\", \"5\", \"6\", \"9\"]\\n        themselves = [\"0\", \"1\", \"8\"]\\n        non_rot = [\"3\", \"4\", \"7\"]\\n        for i in range(1, N+1, 1):\\n            nth = str(i)\\n            slen = len(nth)\\n            for char in nth:\\n                if char in non_rot:\\n                    break\\n                elif char in rotation:\\n                    rotated +=1\\n                elif char in themselves:\\n                    same += 1\\n            if (rotated == slen) or (((rotated+same) == slen) and (rotated > 0)):\\n                count += 1\\n            rotated = 0\\n            same = 0\\n        return count\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 891924,
                "title": "python-simple-checking",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for num in range(1, N+1):\\n            s = str(num)\\n            if \\'3\\' in s or \\'4\\' in s or \\'7\\' in s:\\n                continue\\n            if \\'2\\' in s or \\'5\\' in s or \\'6\\' in s or \\'9\\' in s:\\n                count += 1\\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count = 0\\n        for num in range(1, N+1):\\n            s = str(num)\\n            if \\'3\\' in s or \\'4\\' in s or \\'7\\' in s:\\n                continue\\n            if \\'2\\' in s or \\'5\\' in s or \\'6\\' in s or \\'9\\' in s:\\n                count += 1\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882659,
                "title": "javascript-3-lines-solution",
                "content": "```\\nvar rotatedDigits = function(N) {\\n  let counter = 0;\\n  for (let i = 1; i <= N; i++) if((/2|5|6|9/g).test(i) && !(/3|4|7/).test(i)) counter++;\\n  return counter;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rotatedDigits = function(N) {\\n  let counter = 0;\\n  for (let i = 1; i <= N; i++) if((/2|5|6|9/g).test(i) && !(/3|4|7/).test(i)) counter++;\\n  return counter;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 878807,
                "title": "c-memory-usage",
                "content": "Does somebody know why for the solution below the platform tells me:\\n\\n**Memory Usage: 6.2 MB, less than 22.61% of C++ online submissions for Rotated Digits.**\\n\\nWhat occupies so much memory? There\\'s no recursivity, only the 3 arrays occupy 4 * 10 * 3 = 120 bytes and the array inside rotatedDigits, which occupies 5 * 4 = 20 bytes..\\n\\n```\\n//\\n// \\'same\\' digit = 0/1/8\\n// \\'good\\' digit = 2/5/6/9\\n// \\'invalid\\' digit = 3/4/7\\n//\\n// Given functions:\\n//      v(N) = valids between [0, N]    (easily computable for N ending in 9s)\\n//      s(N) = sames between [0, N]     (easily computable for N ending in 9s)\\n//      g(N) = goods between [0, N]     (easily computable for N ending in 9s)\\n// , we make use of the following facts:\\n//\\n//  1) g(N) = g(number ending in 9s below N) + g(N without 1st digit), if N starts with \\'same\\' digit\\n//      e.g. for N = 8253, since first digit is 8, i.e. \\'same\\' => g(8253) = g(7999) + g(253)\\n//      we can then easily compute g(7999) = v(7999) - s(7999) = D_V[7] * 7^3 + D_S[7] * 3^3\\n//\\n//  2) g(N) = g(number ending in 9s below N) + v(N without 1st digit), if N starts with \\'good\\' digit\\n//      e.g. for n = 253: g(253) = g(199) + v(53)\\n//      we can then easily compute g(199) = v(199) - s(199) = D_V[1] * 7^2 + D_S[1] * 3^2\\n//\\n//  3) Finally, g(N) = g(number ending in 9s below N), if N starts with \\'invalid\\' digit\\n//      e.g. for n = 377: g(377) = g(299)\\n//      we can then easily compute g(299) = v(299) - s(299) = D_V[2] * 7^2 + D_S[2] * 3^2\\n//\\n// More natural to implement recursively, but consumes more memory.\\n// Below solution is iterative.\\n//\\n\\nclass Solution\\n{\\nprivate:\\n    // Precomputed goods/valids/sames counts from 0 to 9.\\n    static constexpr int D_G[] = { 0, 0, 1, 1, 1, 2, 3, 3, 3, 4 };\\n    static constexpr int D_V[] = { 1, 2, 3, 3, 3, 4, 5, 5, 6, 7 };\\n    static constexpr int D_S[] = { 1, 2, 2, 2, 2, 2, 2, 2, 3, 3 };\\n\\nprivate:\\n    static inline int pow(int p, int n)\\n    {\\n        int r = 1;\\n        for (int i = 0; i < n; i++) r *= p;\\n        return r;\\n    }\\n    \\n    static inline bool is_inv_d(int d)\\n    {\\n        switch(d)\\n        {\\n            case 3:\\n            case 4:\\n            case 7:\\n                return true;\\n            default: return false;\\n        }\\n    }\\n\\npublic:\\n    int rotatedDigits(int N)\\n    {\\n        constexpr int MAX_DIGITS_COUNT = 5; // N <= 10000\\n\\n        if (N < 10) return D_G[N];\\n\\n        // Extract digits of N\\n        int ds[MAX_DIGITS_COUNT];\\n        int dc_dec = 0, N_cpy = N;\\n        while (N_cpy > 9)\\n        {\\n            ds[dc_dec++] = (N_cpy % 10);\\n            N_cpy /= 10;\\n        }\\n        ds[dc_dec] = N_cpy;\\n\\n        // Count goods.\\n        int goods = 0;\\n        int p7 = pow(7, dc_dec), p3 = pow(3, dc_dec);\\n        int i = dc_dec;\\n        bool switched_to_valids = false;\\n        while(i > 0 && !switched_to_valids)\\n        {\\n            int d = ds[i--];\\n            if (d != 0)\\n            {\\n                goods += p7 * D_V[d-1] - p3 * D_S[d-1];\\n                switched_to_valids = true;\\n                if (is_inv_d(d)) return goods;\\n                if (d == 1 || d == 8) switched_to_valids = false;\\n            }\\n            p7 /= 7; p3 /= 3;\\n        }\\n\\n        // Switch to counting valids instead.\\n        while (i > 0)\\n        {\\n            int d = ds[i--];\\n            if (d != 0)\\n            {\\n                goods += p7 * D_V[d-1];\\n                if (is_inv_d(d)) return goods;\\n            }\\n            p7 /= 7;\\n        }\\n\\n        // We need to add either goods or valids for the last digit.\\n        int last_d = ds[0];\\n        goods += (switched_to_valids ? D_V[last_d] : D_G[last_d]);\\n        return goods;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//\\n// \\'same\\' digit = 0/1/8\\n// \\'good\\' digit = 2/5/6/9\\n// \\'invalid\\' digit = 3/4/7\\n//\\n// Given functions:\\n//      v(N) = valids between [0, N]    (easily computable for N ending in 9s)\\n//      s(N) = sames between [0, N]     (easily computable for N ending in 9s)\\n//      g(N) = goods between [0, N]     (easily computable for N ending in 9s)\\n// , we make use of the following facts:\\n//\\n//  1) g(N) = g(number ending in 9s below N) + g(N without 1st digit), if N starts with \\'same\\' digit\\n//      e.g. for N = 8253, since first digit is 8, i.e. \\'same\\' => g(8253) = g(7999) + g(253)\\n//      we can then easily compute g(7999) = v(7999) - s(7999) = D_V[7] * 7^3 + D_S[7] * 3^3\\n//\\n//  2) g(N) = g(number ending in 9s below N) + v(N without 1st digit), if N starts with \\'good\\' digit\\n//      e.g. for n = 253: g(253) = g(199) + v(53)\\n//      we can then easily compute g(199) = v(199) - s(199) = D_V[1] * 7^2 + D_S[1] * 3^2\\n//\\n//  3) Finally, g(N) = g(number ending in 9s below N), if N starts with \\'invalid\\' digit\\n//      e.g. for n = 377: g(377) = g(299)\\n//      we can then easily compute g(299) = v(299) - s(299) = D_V[2] * 7^2 + D_S[2] * 3^2\\n//\\n// More natural to implement recursively, but consumes more memory.\\n// Below solution is iterative.\\n//\\n\\nclass Solution\\n{\\nprivate:\\n    // Precomputed goods/valids/sames counts from 0 to 9.\\n    static constexpr int D_G[] = { 0, 0, 1, 1, 1, 2, 3, 3, 3, 4 };\\n    static constexpr int D_V[] = { 1, 2, 3, 3, 3, 4, 5, 5, 6, 7 };\\n    static constexpr int D_S[] = { 1, 2, 2, 2, 2, 2, 2, 2, 3, 3 };\\n\\nprivate:\\n    static inline int pow(int p, int n)\\n    {\\n        int r = 1;\\n        for (int i = 0; i < n; i++) r *= p;\\n        return r;\\n    }\\n    \\n    static inline bool is_inv_d(int d)\\n    {\\n        switch(d)\\n        {\\n            case 3:\\n            case 4:\\n            case 7:\\n                return true;\\n            default: return false;\\n        }\\n    }\\n\\npublic:\\n    int rotatedDigits(int N)\\n    {\\n        constexpr int MAX_DIGITS_COUNT = 5; // N <= 10000\\n\\n        if (N < 10) return D_G[N];\\n\\n        // Extract digits of N\\n        int ds[MAX_DIGITS_COUNT];\\n        int dc_dec = 0, N_cpy = N;\\n        while (N_cpy > 9)\\n        {\\n            ds[dc_dec++] = (N_cpy % 10);\\n            N_cpy /= 10;\\n        }\\n        ds[dc_dec] = N_cpy;\\n\\n        // Count goods.\\n        int goods = 0;\\n        int p7 = pow(7, dc_dec), p3 = pow(3, dc_dec);\\n        int i = dc_dec;\\n        bool switched_to_valids = false;\\n        while(i > 0 && !switched_to_valids)\\n        {\\n            int d = ds[i--];\\n            if (d != 0)\\n            {\\n                goods += p7 * D_V[d-1] - p3 * D_S[d-1];\\n                switched_to_valids = true;\\n                if (is_inv_d(d)) return goods;\\n                if (d == 1 || d == 8) switched_to_valids = false;\\n            }\\n            p7 /= 7; p3 /= 3;\\n        }\\n\\n        // Switch to counting valids instead.\\n        while (i > 0)\\n        {\\n            int d = ds[i--];\\n            if (d != 0)\\n            {\\n                goods += p7 * D_V[d-1];\\n                if (is_inv_d(d)) return goods;\\n            }\\n            p7 /= 7;\\n        }\\n\\n        // We need to add either goods or valids for the last digit.\\n        int last_d = ds[0];\\n        goods += (switched_to_valids ? D_V[last_d] : D_G[last_d]);\\n        return goods;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820734,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        number_of_rotated = 0\\n\\n        for i in range(1, N + 1):\\n            flag = False\\n            while i > 0:\\n                if i % 10 in [2, 5, 6, 9]:\\n                     flag = True\\n                elif i % 10 in [3,4,7]:\\n                    flag = False\\n                    break\\n                        \\n                i //= 10       \\n            number_of_rotated += 1 if flag else 0\\n                    \\n                \\n\\n        return number_of_rotated\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        number_of_rotated = 0\\n\\n        for i in range(1, N + 1):\\n            flag = False\\n            while i > 0:\\n                if i % 10 in [2, 5, 6, 9]:\\n                     flag = True\\n                elif i % 10 in [3,4,7]:\\n                    flag = False\\n                    break\\n                        \\n                i //= 10       \\n            number_of_rotated += 1 if flag else 0\\n                    \\n                \\n\\n        return number_of_rotated\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 779395,
                "title": "java-o-log-n-time-and-space-solution-expalined",
                "content": "Explanation: We consider 2 cases; When a number is valid after rotation, and when a number is both valid and good after rotation. From 0 to the max n-digit number, the amount of numbers that would remain valid after rotation would be 7^n since they can only contain (0,1,2,5,6,8,9). While the number that are both valid and good after rotation would be 7^n - 3^n since they have to be valid and must not all be (0,1,8). \\n\\nLet\\'s say we have an (n+1)-digit number. We take the only first digit A and iterate for 0 to A - 1 and consider cases where the number could be good. For each iteration. if the first digit is not valid, we skip all entire numbers starting with that digit, If the first digit is valid but not good, we use the formular(7^n - 3^n) to determine the total numbers that start with that digit but is valid and good since one of the corresponding digits have to be valid and good. If the first digit is valid and good, then we use (7^n) since all of the corresponding digits just have to be valid.\\n\\nFinally we consider numbers where first digit is A. Since it doesn\\'t cover all the n + 1 digit numbers that start with A, we use recursion to get the number of Valid and good digits up to N.\\n\\nExample: Suppose we want to find the valid and good numbers up to 5378;\\nValidAndGood( 5378 )\\nIt is a 4 digit number, so n = 3.\\nThe first digit is 5, so we iterate from 0 to 4:\\nAt iteration 0: 0 is valid but not good so total valid and good numbers from 0000 to 0999 is 7^3 - 3^3 = 316\\nAt iteration 1: 1 is also valid but not good, so total valid and good numbers from 1000 to 1999 is 7^3 - 3^3 = 316\\nAt iteration 2: 2 is valid and good, so total valid and good numbers from 2000 to 2999 is 7^3 =343\\nAt ieration 3: 3 is not valid, so we skip\\nAt iteration 4: 4 is also not valid so we skip\\n\\nSo total valid numbers from 0 to 4999 is 316 + 316 + 343 = 975\\n\\nFinally for the digit 5, Since 5 is valid and good we use recursion to find the number of valid and good from 5000 to 5378\\nvalidAndGood(5378) = 975 + validButNotNecessarilyGood( 378 )\\n\\nIn the solution a boolean value checkValChanged is passed to determine if the method should return all valid numbers or numbers that are both valid and good.\\n```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        return validRotatedCount (N, true);\\n    }\\n    \\n    // Returns all rotated Numbers that are valid and changed(good) if checkValChanged is true\\n    // Returns all rotated Numbers that are valid but may or may not be changed when checkValChanged is false\\n    public int validRotatedCount(int N, boolean checkValChanged) {\\n        \\n        // For single digits numbers\\n        if (N < 0)\\n            return 0;\\n        else if (N < 10 ) {\\n            int totalNums = 0;\\n            int numValid;\\n            for (int i = 0; i <= N; ++i){\\n                numValid = numberValid(i);\\n                if (numValid == -1){\\n                    continue;\\n                }\\n                if (!checkValChanged || numValid == 1)\\n                    ++totalNums;\\n            \\n            }\\n            return totalNums;\\n        }\\n        \\n        \\n        String num = N + \"\";\\n        int val = num.charAt(0) - 48; // First Digit\\n        int index = num.length() - 1;\\n        int total = 0;\\n        int valid;\\n        \\n        //Iterate from 0 to the number before the first Digit\\n        for (int i = 0; i < val; ++i){\\n            valid = numberValid(i);\\n            if (valid == -1){\\n                continue;\\n            }\\n            else if (valid == 1 || !checkValChanged) {\\n                total += Math.pow(7 , index);\\n            } else {\\n                total += Math.pow(7 , index) -  Math.pow(3 , index);\\n            }\\n        }\\n        \\n        // Handles the final iteration for the first Digit\\n        valid = numberValid(val);\\n        if (valid == -1){\\n            return total;\\n        } else if (valid == 1 || !checkValChanged ) {\\n            total += validRotatedCount((int) (N % Math.pow(10 , index) ) , false);\\n        } else {\\n            total += validRotatedCount( (int) (N % Math.pow(10 , index) ), true);\\n        }\\n        \\n        return total;\\n        \\n    }\\n    \\n    public int numberValid(int n){\\n        switch(n) {\\n            case 2:\\n            case 5:\\n            case 6:\\n            case 9:\\n                return 1;\\n            case 3:\\n            case 4:\\n            case 7:\\n                return -1;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        return validRotatedCount (N, true);\\n    }\\n    \\n    // Returns all rotated Numbers that are valid and changed(good) if checkValChanged is true\\n    // Returns all rotated Numbers that are valid but may or may not be changed when checkValChanged is false\\n    public int validRotatedCount(int N, boolean checkValChanged) {\\n        \\n        // For single digits numbers\\n        if (N < 0)\\n            return 0;\\n        else if (N < 10 ) {\\n            int totalNums = 0;\\n            int numValid;\\n            for (int i = 0; i <= N; ++i){\\n                numValid = numberValid(i);\\n                if (numValid == -1){\\n                    continue;\\n                }\\n                if (!checkValChanged || numValid == 1)\\n                    ++totalNums;\\n            \\n            }\\n            return totalNums;\\n        }\\n        \\n        \\n        String num = N + \"\";\\n        int val = num.charAt(0) - 48; // First Digit\\n        int index = num.length() - 1;\\n        int total = 0;\\n        int valid;\\n        \\n        //Iterate from 0 to the number before the first Digit\\n        for (int i = 0; i < val; ++i){\\n            valid = numberValid(i);\\n            if (valid == -1){\\n                continue;\\n            }\\n            else if (valid == 1 || !checkValChanged) {\\n                total += Math.pow(7 , index);\\n            } else {\\n                total += Math.pow(7 , index) -  Math.pow(3 , index);\\n            }\\n        }\\n        \\n        // Handles the final iteration for the first Digit\\n        valid = numberValid(val);\\n        if (valid == -1){\\n            return total;\\n        } else if (valid == 1 || !checkValChanged ) {\\n            total += validRotatedCount((int) (N % Math.pow(10 , index) ) , false);\\n        } else {\\n            total += validRotatedCount( (int) (N % Math.pow(10 , index) ), true);\\n        }\\n        \\n        return total;\\n        \\n    }\\n    \\n    public int numberValid(int n){\\n        switch(n) {\\n            case 2:\\n            case 5:\\n            case 6:\\n            case 9:\\n                return 1;\\n            case 3:\\n            case 4:\\n            case 7:\\n                return -1;\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777744,
                "title": "c-0ms",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int help[]={1,1,2,0,0,2,2,0,1,2};\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            int s=1;\\n            int p=i;\\n            while(p){\\n                s*=help[p%10];\\n                p/=10;\\n            }\\n            if(s>=2)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int help[]={1,1,2,0,0,2,2,0,1,2};\\n        int ans=0;\\n        for(int i=1;i<=n;i++){\\n            int s=1;\\n            int p=i;\\n            while(p){\\n                s*=help[p%10];\\n                p/=10;\\n            }\\n            if(s>=2)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747625,
                "title": "c-very-easy-and-simple-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGood(int n)\\n    {\\n        if(n == 2 || n == 5 || n == 6 || n == 9)\\n            return true;\\n        int unchanged = 0, digits = 0;\\n        while(n > 0)\\n        {\\n            int rem = n % 10;\\n            n /= 10;\\n            digits++;\\n            if(rem == 3 || rem == 4 || rem == 7)\\n                return false;\\n            else if(rem == 0 || rem == 1 || rem == 8)\\n                unchanged++;\\n        }\\n        if(unchanged == digits)\\n            return false;\\n        else\\n            return true;\\n    }\\n    int rotatedDigits(int N) {\\n        if(N <= 1)\\n            return 0;\\n        int count = 0;\\n        for(int i=2; i<=N; i++)\\n        {\\n            if(isGood(i))\\n                count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isGood(int n)\\n    {\\n        if(n == 2 || n == 5 || n == 6 || n == 9)\\n            return true;\\n        int unchanged = 0, digits = 0;\\n        while(n > 0)\\n        {\\n            int rem = n % 10;\\n            n /= 10;\\n            digits++;\\n            if(rem == 3 || rem == 4 || rem == 7)\\n                return false;\\n            else if(rem == 0 || rem == 1 || rem == 8)\\n                unchanged++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 732911,
                "title": "c-brute-force-solution-explaining-question-s-meaning",
                "content": "***Runtime: 52 ms, faster than 16.67% of C++ online submissions for Rotated Digits.\\nMemory Usage: 5.9 MB, less than 90.00% of C++ online submissions for Rotated Digits.***\\n```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int result = 0;\\n        for(int i=1; i<=N ;i++){\\n            if(isGoodNumber(i)){\\n                result ++;\\n            }\\n        }\\n        return result;\\n    }\\n    bool isGoodNumber(int N){\\n        string s = to_string(N);\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            switch(s[i]){                    \\n                case \\'0\\':   temp += \\'0\\';    break;\\n                case \\'1\\':   temp += \\'1\\';    break;\\n                case \\'2\\':   temp += \\'5\\';    break;\\n                case \\'5\\':   temp += \\'2\\';    break;\\n                case \\'6\\':   temp += \\'9\\';    break;\\n                case \\'8\\':   temp += \\'8\\';    break;\\n                case \\'9\\':   temp += \\'6\\';    break;\\n                default :   return false;\\n            }\\n        }\\n        return temp != s;\\n    }\\n};\\n```\\nReally struggled a lot (like Ananya Pandey) to get the meaning of this question.\\nThis question describes a `good number` as write the number on a piece of paper, then digit by digit perform transformation (180\\' rotation), \\nDo transitions as ::\\n0 -> 0\\n1 -> 1\\n2 -> 5\\n3 -> NOT POSSIBLE\\n4 -> NOT POSSIBLE\\n5 -> 2\\n6 -> 9\\n7 -> NOT POSSIBLE\\n8 -> 8\\n9 -> 9\\n\\n(God knows on which earth, 180\\' rotation of 2 makes 5 or vice versa).\\nSimply, you have to count the number of good numbers in range [1, N] both inclusive.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int result = 0;\\n        for(int i=1; i<=N ;i++){\\n            if(isGoodNumber(i)){\\n                result ++;\\n            }\\n        }\\n        return result;\\n    }\\n    bool isGoodNumber(int N){\\n        string s = to_string(N);\\n        string temp;\\n        for(int i=0;i<s.size();i++){\\n            switch(s[i]){                    \\n                case \\'0\\':   temp += \\'0\\';    break;\\n                case \\'1\\':   temp += \\'1\\';    break;\\n                case \\'2\\':   temp += \\'5\\';    break;\\n                case \\'5\\':   temp += \\'2\\';    break;\\n                case \\'6\\':   temp += \\'9\\';    break;\\n                case \\'8\\':   temp += \\'8\\';    break;\\n                case \\'9\\':   temp += \\'6\\';    break;\\n                default :   return false;\\n            }\\n        }\\n        return temp != s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685227,
                "title": "java-o-logn-solution",
                "content": "The general idea into three parts :\\n1. If there are ```m``` digits remaining to be chosen, then there are ```(3+4)^m``` possible valid numbers.\\n2. If a flipable number i.e **{2,5,6,9}** has been seen, each of the remaining ```(3+4)^m``` possible valid numbers are good numbers; otherwise, ```3^m``` of those valid numbers are not good numbers and must be subtracted from the over estimation.\\n3. The less significant digits do not affect the good numbers contained in the more significant digits.\\n ```Consider an example of n = 424; we can break this number into [0,400), [400, 420), [420, 425). The least significant numbers 2 & 4 will have minimum effect as compared to [0, 400). ```\\n```\\nclass Solution {\\n    int[] type = {0,0,1,2,2,1,1,2,0,1};    //whether number is self-rotating, mirror-rotating or invalid\\n    int[] validRotation = {1,2,3,3,3,4,5,5,6,7};    //valid rotations {0,1,2,5,6,8,9}\\n    int[] sameRotation = {1,2,2,2,2,2,2,2,3,3};    //0,1,8 have same rotations\\n    int[] differentRotation = {0,0,1,1,1,2,3,3,3,4};     //to check if valid number i.e 2,5,6,9 is present in the digit\\n    public int rotatedDigits(int N) {\\n        String number = String.valueOf(N);\\n        return rotatedDigitsUtility(number, false);\\n    }\\n    \\n    public int rotatedDigitsUtility(String number, boolean isFlipable){\\n        int digit = number.charAt(0) - \\'0\\';\\n        \\n        if(number.length() == 1) return (isFlipable) ? validRotation[digit] : differentRotation[digit];\\n        \\n        int countGoodNumbers = 0;\\n        if(digit != 0){\\n            //Total number of valid counts will always be (3 + 4)^m, where 3 -> {0,1,8}; 4 -> {2,5,6,9}; m -> length of string;\\n            //we don\\'t consider invalid number i.e {3,4,7}\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0countGoodNumbers += (validRotation[digit - 1] * Math.pow(7, number.length() - 1)); \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n            //if {2,5,6,9} haven\\'t occured yet, then we subtract 3 from the total estimation since there are 7 valid rotations out of which 4 rotations gives us a good number i.e {2,5,6,9}.\\n            if(!isFlipable) countGoodNumbers -= (sameRotation[digit - 1] * Math.pow(3, number.length() - 1));\\n        }\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0//if the digit is a validRotation i.e {2,5,6,9}\\n        if(type[digit] == 1) isFlipable = true;\\n        \\n        if(type[digit] != 2) countGoodNumbers += rotatedDigitsUtility(number.substring(1, number.length()), isFlipable);\\n        \\n        return countGoodNumbers;\\n    }\\n}\\n```\\n##### Click [here](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/) for concise explanation.!",
                "solutionTags": [],
                "code": "```m```\n```(3+4)^m```\n```(3+4)^m```\n```3^m```\n```Consider an example of n = 424; we can break this number into [0,400), [400, 420), [420, 425). The least significant numbers 2 & 4 will have minimum effect as compared to [0, 400). ```\n```\\nclass Solution {\\n    int[] type = {0,0,1,2,2,1,1,2,0,1};    //whether number is self-rotating, mirror-rotating or invalid\\n    int[] validRotation = {1,2,3,3,3,4,5,5,6,7};    //valid rotations {0,1,2,5,6,8,9}\\n    int[] sameRotation = {1,2,2,2,2,2,2,2,3,3};    //0,1,8 have same rotations\\n    int[] differentRotation = {0,0,1,1,1,2,3,3,3,4};     //to check if valid number i.e 2,5,6,9 is present in the digit\\n    public int rotatedDigits(int N) {\\n        String number = String.valueOf(N);\\n        return rotatedDigitsUtility(number, false);\\n    }\\n    \\n    public int rotatedDigitsUtility(String number, boolean isFlipable){\\n        int digit = number.charAt(0) - \\'0\\';\\n        \\n        if(number.length() == 1) return (isFlipable) ? validRotation[digit] : differentRotation[digit];\\n        \\n        int countGoodNumbers = 0;\\n        if(digit != 0){\\n            //Total number of valid counts will always be (3 + 4)^m, where 3 -> {0,1,8}; 4 -> {2,5,6,9}; m -> length of string;\\n            //we don\\'t consider invalid number i.e {3,4,7}\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0countGoodNumbers += (validRotation[digit - 1] * Math.pow(7, number.length() - 1)); \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n            //if {2,5,6,9} haven\\'t occured yet, then we subtract 3 from the total estimation since there are 7 valid rotations out of which 4 rotations gives us a good number i.e {2,5,6,9}.\\n            if(!isFlipable) countGoodNumbers -= (sameRotation[digit - 1] * Math.pow(3, number.length() - 1));\\n        }\\n        \\n \\xA0 \\xA0 \\xA0 \\xA0//if the digit is a validRotation i.e {2,5,6,9}\\n        if(type[digit] == 1) isFlipable = true;\\n        \\n        if(type[digit] != 2) countGoodNumbers += rotatedDigitsUtility(number.substring(1, number.length()), isFlipable);\\n        \\n        return countGoodNumbers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683891,
                "title": "java-standard-solution",
                "content": "### Theory\\nHave a mapping defined from original digit to the rotated version. This will make our algoirthm have O(1) lookups.\\nWe basically go through the numbers [1, N] and check to see if the current number `i` is good.\\n\\n### Solution\\n```\\n    private int[] rotations = new int[] {0, 1, 5 , -1, -1, 2, 9, -1, 8, 6};\\n    \\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for (int i = 1; i <= N; i++) if (isGood(i)) count++;\\n        return count;        \\n    }\\n    \\n    private boolean isGood(int num) {\\n        int copy = num, rotatedNum = 0, place = 1;\\n        while (copy > 0) {\\n            int lastDigit = copy % 10;\\n            if (rotations[lastDigit] == -1) return false;\\n            else rotatedNum += place * rotations[lastDigit];\\n            copy /= 10;\\n            place *= 10;\\n        }\\n        return rotatedNum != num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int[] rotations = new int[] {0, 1, 5 , -1, -1, 2, 9, -1, 8, 6};\\n    \\n    public int rotatedDigits(int N) {\\n        int count = 0;\\n        for (int i = 1; i <= N; i++) if (isGood(i)) count++;\\n        return count;        \\n    }\\n    \\n    private boolean isGood(int num) {\\n        int copy = num, rotatedNum = 0, place = 1;\\n        while (copy > 0) {\\n            int lastDigit = copy % 10;\\n            if (rotations[lastDigit] == -1) return false;\\n            else rotatedNum += place * rotations[lastDigit];\\n            copy /= 10;\\n            place *= 10;\\n        }\\n        return rotatedNum != num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 579348,
                "title": "go-clean-code-0ms-beats-100",
                "content": "```\\nfunc rotatedDigits(N int) int {\\n\\tvar cnt int\\n\\tfor i := 2; i <= N; i++ {\\n\\t\\tif isValid(i) {\\n\\t\\t\\tcnt++\\n\\t\\t}\\n\\t}\\n\\treturn cnt\\n}\\n\\nfunc isValid(num int) bool {\\n\\tvar ret bool\\n\\tfor ; num > 0; num /= 10 {\\n\\t\\tswitch num % 10 {\\n\\t\\tcase 2, 5, 6, 9:\\n\\t\\t\\tret = true\\n\\t\\tcase 3, 4, 7:\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc rotatedDigits(N int) int {\\n\\tvar cnt int\\n\\tfor i := 2; i <= N; i++ {\\n\\t\\tif isValid(i) {\\n\\t\\t\\tcnt++\\n\\t\\t}\\n\\t}\\n\\treturn cnt\\n}\\n\\nfunc isValid(num int) bool {\\n\\tvar ret bool\\n\\tfor ; num > 0; num /= 10 {\\n\\t\\tswitch num % 10 {\\n\\t\\tcase 2, 5, 6, 9:\\n\\t\\t\\tret = true\\n\\t\\tcase 3, 4, 7:\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560601,
                "title": "python-digit-dp-pattern-for-similar-questions",
                "content": "Theory: https://codeforces.com/blog/entry/53960\\n\\nMore of the same approach:\\n[1012. Numbers With Repeated Digits](https://leetcode.com/problems/numbers-with-repeated-digits/discuss/560346/python-digit-dp)\\n[357. Count Numbers with Unique Digits](https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/560898/Python-Digit-DP)\\n[902. Numbers At Most N Given Digit Set](https://leetcode.com/problems/numbers-at-most-n-given-digit-set/discuss/559624/python-digit-dp)\\n[1397. Find All Good Strings](https://leetcode.com/problems/find-all-good-strings/discuss/560841/Python-Digit-DP)\\n[233. Number of Digit One](https://leetcode.com/problems/number-of-digit-one/discuss/560876/Python-Digit-DP)\\n[600. Non-negative Integers without Consecutive Ones](https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/discuss/584350/Python-Digit-DP-(Pattern-For-Similar-Questions))\\n\\nAt each recursive call (adding digit to less significant position) compute:\\n\\nisPrefix - if the new number is the prefix of N\\nisBigger - if the new number will be bigger than N when we reach final position\\nrepeated - there exists repeated digit\\nAnyone has an idea how to optimize when current number is lower than N?  I tried addig this but without luck:\\n```\\n\\tif hasRotating and not isPrefix and not isBigger:\\n\\t\\treturn int(pow(7, len(N) - pos))\\n```\\nCode:\\n```\\n    def rotatedDigits(self, N: int) -> int:\\n        N = list(map(int, str(N)))\\n        rotatings = {2, 5, 6, 9}\\n        nonrotatings = {0, 1, 8}\\n\\n        @functools.lru_cache(None)\\n        def dp(pos, isPrefix, isBigger, hasRotating):\\n            if pos == len(N):\\n                return 0\\n            result = 0\\n            for i in range(0 if pos > 0 else 1, 10):\\n                if i not in rotatings and i not in nonrotatings:\\n                    continue\\n                _isPrefix = isPrefix and i == N[pos]\\n                _isBigger = isBigger or (isPrefix and i > N[pos])\\n\\n                _hasRotating = hasRotating or i in rotatings\\n                if _hasRotating and not (pos == len(N) - 1 and _isBigger):\\n                    result += 1\\n                result += dp(pos + 1, _isPrefix, _isBigger, _hasRotating)\\n            return result\\n        return dp(0, True, False, False)",
                "solutionTags": [],
                "code": "```\\n\\tif hasRotating and not isPrefix and not isBigger:\\n\\t\\treturn int(pow(7, len(N) - pos))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519025,
                "title": "ez-understood-java-dfs-log-n-solution",
                "content": "The idea is start from 0 and add one digit at the end of the current number. If the parent number is already valid, the rest numbers that generate from it are all valid. To make a number valid, you just need to insert 2 or 5 or 6 or 9.\\n```\\nstatic final int[] key = new int[]{0, 1, 8, 2, 5, 6, 9};\\n    int res = 0;\\n    public int rotatedDigits(int N) {\\n        if(N<2) return 0;\\n        dfs(0, N, false);\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int N, boolean valid){\\n        cur*=10;\\n        if(cur>N) return;\\n        for(int i=0; i<key.length; i++){\\n            boolean va = valid || i>2;\\n            int next = cur+key[i];\\n            if(next==0 || next>N) continue;\\n            if(va)\\n                res++;\\n            dfs(next, N, va);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nstatic final int[] key = new int[]{0, 1, 8, 2, 5, 6, 9};\\n    int res = 0;\\n    public int rotatedDigits(int N) {\\n        if(N<2) return 0;\\n        dfs(0, N, false);\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int N, boolean valid){\\n        cur*=10;\\n        if(cur>N) return;\\n        for(int i=0; i<key.length; i++){\\n            boolean va = valid || i>2;\\n            int next = cur+key[i];\\n            if(next==0 || next>N) continue;\\n            if(va)\\n                res++;\\n            dfs(next, N, va);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516104,
                "title": "easy-solution-with-explanation-python",
                "content": "The idea is to count all numbers (<=N) made of numbers {0,1,2,5,6,8,9} minus those made of {0,1,8}.  Notice that we don\\'t really care about leading zeros. \\n\\n\\n\\n\\n```\\nimport math\\ndef f(k,s):\\n    if k<10:\\n        return len({i for i in s if i<=k})\\n    digit=int(math.log10(k))\\n    lead_digit=k//10**digit\\n    k-=lead_digit*10**digit\\n    num=len(s)**digit*len({i for i in s if i<lead_digit})\\n    if lead_digit in s:\\n        return num+f(k,s)\\n    return num\\n\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        s1={1,2,5,6,8,9,0}\\n        s2={1,8,0}\\n        return f(N,s1)-f(N,s2)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\ndef f(k,s):\\n    if k<10:\\n        return len({i for i in s if i<=k})\\n    digit=int(math.log10(k))\\n    lead_digit=k//10**digit\\n    k-=lead_digit*10**digit\\n    num=len(s)**digit*len({i for i in s if i<lead_digit})\\n    if lead_digit in s:\\n        return num+f(k,s)\\n    return num\\n\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        s1={1,2,5,6,8,9,0}\\n        s2={1,8,0}\\n        return f(N,s1)-f(N,s2)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 515458,
                "title": "accepted-straightforward-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private bool Check(int num)\\n        {\\n            bool contains2569 = false;\\n            while (num > 0)\\n            {\\n                int digit = num % 10;\\n                num /= 10;\\n\\n                if (digit == 2 || digit == 5 || digit == 6 || digit == 9)\\n                {\\n                    contains2569 = true;\\n                    continue;\\n                }\\n\\n                if (digit == 0 || digit == 1 || digit == 8)\\n                {\\n                    continue;\\n                }\\n\\n                return false;\\n            }\\n\\n            return contains2569;\\n        }\\n\\n        public int RotatedDigits(int n)\\n        {\\n            int res = 0;\\n\\n            for (int i = 1; i <= n; i++)\\n            {\\n                if (Check(i))\\n                {\\n                    res++;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        private bool Check(int num)\\n        {\\n            bool contains2569 = false;\\n            while (num > 0)\\n            {\\n                int digit = num % 10;\\n                num /= 10;\\n\\n                if (digit == 2 || digit == 5 || digit == 6 || digit == 9)\\n                {\\n                    contains2569 = true;\\n                    continue;\\n                }\\n\\n                if (digit == 0 || digit == 1 || digit == 8)\\n                {\\n                    continue;\\n                }\\n\\n                return false;\\n            }\\n\\n            return contains2569;\\n        }\\n\\n        public int RotatedDigits(int n)\\n        {\\n            int res = 0;\\n\\n            for (int i = 1; i <= n; i++)\\n            {\\n                if (Check(i))\\n                {\\n                    res++;\\n                }\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507882,
                "title": "python-set",
                "content": "```\\n    def rotatedDigits(self, N: int) -> int:\\n        ans = 0\\n        for num in range(1, N+1):\\n            num_s = str(num)\\n            if not set(\\'347\\').intersection(set(num_s)) and not set(num_s).issubset(set(\\'018\\')):\\n                ans += 1\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def rotatedDigits(self, N: int) -> int:\\n        ans = 0\\n        for num in range(1, N+1):\\n            num_s = str(num)\\n            if not set(\\'347\\').intersection(set(num_s)) and not set(num_s).issubset(set(\\'018\\')):\\n                ans += 1\\n                \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 494760,
                "title": "python-simple-sol-by-digit-scan-with-comment",
                "content": "Python simple sol. by digit scan.\\n\\n---\\n\\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        \\n        counter = 0\\n        for i in range(1, N+1):\\n            \\n            # convert number i to digit character array\\n            str_num_list = list( str(i) )\\n            \\n            # flag for good number judgement\\n            is_good_number = False\\n            \\n            for digit in str_num_list:\\n                \\n                if digit in {\\'3\\',\\'4\\',\\'7\\'}:\\n                    # invalid number after rotation\\n                    is_good_number = False\\n                    break\\n                elif digit in {\\'2\\',\\'5\\',\\'6\\',\\'9\\'}:\\n                    is_good_number = True\\n                    \\n                    \\n            if is_good_number:\\n                # update conter for good number\\n                counter += 1\\n                    \\n            \\n        return counter\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        \\n        counter = 0\\n        for i in range(1, N+1):\\n            \\n            # convert number i to digit character array\\n            str_num_list = list( str(i) )\\n            \\n            # flag for good number judgement\\n            is_good_number = False\\n            \\n            for digit in str_num_list:\\n                \\n                if digit in {\\'3\\',\\'4\\',\\'7\\'}:\\n                    # invalid number after rotation\\n                    is_good_number = False\\n                    break\\n                elif digit in {\\'2\\',\\'5\\',\\'6\\',\\'9\\'}:\\n                    is_good_number = True\\n                    \\n                    \\n            if is_good_number:\\n                # update conter for good number\\n                counter += 1\\n                    \\n            \\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454860,
                "title": "python3-20ms-99-86-faster-12-7mb-100-memory",
                "content": "If you are curious about algorithm, please leave your comment below and I will update description with detailed algorithm.\\n```python\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        smallSet = {0,1,8}\\n        bigSet = {2,5,6,9}\\n        smallNum = [0,0,1,1,1,2,3,3,3,4][N % 10]\\n        bigNum = [1,2,3,3,3,4,5,5,6,7][N % 10]\\n        N = N // 10\\n        smInc, bgInc = 4, 7\\n        while N:\\n            x = N % 10\\n            N = N // 10\\n            sm, bg = 0, 0\\n            for i in range(x):\\n                if i in smallSet:\\n                    sm += smInc\\n                    bg += bgInc\\n                elif i in bigSet:\\n                    sm += bgInc\\n                    bg += bgInc\\n            if x in smallSet:\\n                smallNum += sm\\n                bigNum += bg\\n            elif x in bigSet:\\n                smallNum = bigNum + sm\\n                bigNum += bg\\n            else:\\n                smallNum = sm\\n                bigNum = bg\\n            smInc, bgInc = 4*bgInc + 3*smInc, bgInc * 7\\n        return smallNum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        smallSet = {0,1,8}\\n        bigSet = {2,5,6,9}\\n        smallNum = [0,0,1,1,1,2,3,3,3,4][N % 10]\\n        bigNum = [1,2,3,3,3,4,5,5,6,7][N % 10]\\n        N = N // 10\\n        smInc, bgInc = 4, 7\\n        while N:\\n            x = N % 10\\n            N = N // 10\\n            sm, bg = 0, 0\\n            for i in range(x):\\n                if i in smallSet:\\n                    sm += smInc\\n                    bg += bgInc\\n                elif i in bigSet:\\n                    sm += bgInc\\n                    bg += bgInc\\n            if x in smallSet:\\n                smallNum += sm\\n                bigNum += bg\\n            elif x in bigSet:\\n                smallNum = bigNum + sm\\n                bigNum += bg\\n            else:\\n                smallNum = sm\\n                bigNum = bg\\n            smInc, bgInc = 4*bgInc + 3*smInc, bgInc * 7\\n        return smallNum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439436,
                "title": "java-simple-solution",
                "content": "```\\npublic int rotatedDigits(int N) {\\n\\tint count = 0;\\n\\n\\tfor (int i = 1; i <= N; i ++) \\n\\t\\tif (isValid(i)) count ++;\\n\\n\\treturn count;\\n}\\n\\npublic boolean isValid(int N) {\\n\\t/*\\n\\t Valid if N contains ATLEAST ONE 2, 5, 6, 9\\n\\t AND NO 3, 4 or 7s\\n\\t */\\n\\tboolean validFound = false;\\n\\twhile (N > 0) {\\n\\t\\tint d = N%10;\\n\\t\\tif (d==2 || d==5 || d==6 || d==9) validFound = true;\\n\\t\\tif (d==3 || d==4 || d==7) return false;\\n\\t\\tN = N / 10;\\n\\t}\\n\\treturn validFound;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int rotatedDigits(int N) {\\n\\tint count = 0;\\n\\n\\tfor (int i = 1; i <= N; i ++) \\n\\t\\tif (isValid(i)) count ++;\\n\\n\\treturn count;\\n}\\n\\npublic boolean isValid(int N) {\\n\\t/*\\n\\t Valid if N contains ATLEAST ONE 2, 5, 6, 9\\n\\t AND NO 3, 4 or 7s\\n\\t */\\n\\tboolean validFound = false;\\n\\twhile (N > 0) {\\n\\t\\tint d = N%10;\\n\\t\\tif (d==2 || d==5 || d==6 || d==9) validFound = true;\\n\\t\\tif (d==3 || d==4 || d==7) return false;\\n\\t\\tN = N / 10;\\n\\t}\\n\\treturn validFound;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 373397,
                "title": "simple-c-solution",
                "content": "```\\npublic class Solution {\\n    public int RotatedDigits (int N) {\\n        int counter = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (isGoodNumber (i)) {\\n                counter++;\\n            }\\n        }\\n        return counter;\\n    }\\n\\n    private bool isGoodNumber (int num) {\\n        int origNum = num;\\n        int newNum = 0;\\n        int p = 0;\\n        while (num > 0) {\\n            int rem = num % 10;\\n            int rotatedDigit = getRotatedDigit (rem);\\n            if (rotatedDigit < 0) {\\n                return false;\\n            }\\n            newNum = newNum + rotatedDigit * (int) System.Math.Pow (10.0, p);\\n            num = num / 10;\\n            p++;\\n        }\\n        return origNum != newNum;\\n    }\\n    private int getRotatedDigit (int digit) {\\n        if (digit == 0 || digit == 1 || digit == 8) {\\n            return digit;\\n        }\\n        if (digit == 2) {\\n            return 5;\\n        }\\n        if (digit == 5) {\\n            return 2;\\n        }\\n        if (digit == 6) {\\n            return 9;\\n        }\\n        if (digit == 9) {\\n            return 6;\\n        }\\n        return -1;\\n\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int RotatedDigits (int N) {\\n        int counter = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (isGoodNumber (i)) {\\n                counter++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 369220,
                "title": "c-beats-100-speed-and-memory",
                "content": "```\\nclass Solution {\\n    \\n    // from 0 to 9\\n    int single_digit_code (int x){\\n        if(x==3 || x==4 || x==7) return 0;\\n        if(x==2 || x==5 || x==6 || x==9) return 1;\\n        return 2;\\n        \\n    }\\n    \\npublic:\\n    int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i=1; i<=N; i++){\\n            bool is_good = false;\\n            int x=i;\\n            while(x>0){\\n                int code = single_digit_code(x%10);\\n                if(code==0) {\\n                    is_good = false; \\n                    break;\\n                }\\n                if(code==1){\\n                    is_good = true;\\n                }\\n                x/=10;\\n            }\\n            if(is_good) ++count;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // from 0 to 9\\n    int single_digit_code (int x){\\n        if(x==3 || x==4 || x==7) return 0;\\n        if(x==2 || x==5 || x==6 || x==9) return 1;\\n        return 2;\\n        \\n    }\\n    \\npublic:\\n    int rotatedDigits(int N) {\\n        int count = 0;\\n        for(int i=1; i<=N; i++){\\n            bool is_good = false;\\n            int x=i;\\n            while(x>0){\\n                int code = single_digit_code(x%10);\\n                if(code==0) {\\n                    is_good = false; \\n                    break;\\n                }\\n                if(code==1){\\n                    is_good = true;\\n                }\\n                x/=10;\\n            }\\n            if(is_good) ++count;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364386,
                "title": "lg-n-same-as-lc902",
                "content": "```\\nclass Solution:\\n     def rotatedDigits(self, N: int) -> int:          \\n        N = str(N)\\n        def cal(num):\\n            dp = [0 for _ in N]\\n            dp.append(1)\\n            for i in range(len(N)-1,-1,-1):\\n                res = 0\\n                for j in num:\\n                    if j<int(N[i]):\\n                        res += 1\\n                    elif j == int(N[i]):\\n                        dp[i] = dp[i+1]\\n                if i == 0:\\n                    res -= 1\\n                dp[i] += res*(len(num)**(len(N)-i-1))\\n             return dp[0] + sum([len(num) ** i - len(num) **(i-1) for i in range(1,len(N))])\\n        return cal([0,1,2,5,6,8,9]) -cal([0,1,8])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n     def rotatedDigits(self, N: int) -> int:          \\n        N = str(N)\\n        def cal(num):\\n            dp = [0 for _ in N]\\n            dp.append(1)\\n            for i in range(len(N)-1,-1,-1):\\n                res = 0\\n                for j in num:\\n                    if j<int(N[i]):\\n                        res += 1\\n                    elif j == int(N[i]):\\n                        dp[i] = dp[i+1]\\n                if i == 0:\\n                    res -= 1\\n                dp[i] += res*(len(num)**(len(N)-i-1))\\n             return dp[0] + sum([len(num) ** i - len(num) **(i-1) for i in range(1,len(N))])\\n        return cal([0,1,2,5,6,8,9]) -cal([0,1,8])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329264,
                "title": "simple-with-contains",
                "content": "```\\npublic class Solution {\\n    public int RotatedDigits(int N) {\\n        int counter = 0;\\n            for (int i = 0; i <= N; i++)\\n            {\\n                Boolean compare = false;\\n                foreach (var item in i.ToString())\\n                {\\n                    if (\"347\".Contains(item))\\n                    {compare = false;\\n                        break;\\n                    }\\n                    if (\"2569\".Contains(item))\\n                    {\\n                        compare=true;\\n                    }\\n                }\\n                if (compare)\\n                {\\n                    counter++;\\n                }\\n            }\\n            return counter;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int RotatedDigits(int N) {\\n        int counter = 0;\\n            for (int i = 0; i <= N; i++)\\n            {\\n                Boolean compare = false;\\n                foreach (var item in i.ToString())\\n                {\\n                    if (\"347\".Contains(item))\\n                    {compare = false;\\n                        break;\\n                    }\\n                    if (\"2569\".Contains(item))\\n                    {\\n                        compare=true;\\n                    }\\n                }\\n                if (compare)\\n                {\\n                    counter++;\\n                }\\n            }\\n            return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325844,
                "title": "java-backtracking",
                "content": "I like DP solution better. Just post another way as food for thought.\\n```\\nclass Solution {\\n    int[] rotate = new int[]{0, 1, 5, -1, -1, 2, 9, -1, 8, 6};\\n    int[] digits = new int[]{0, 1, 2, 5, 6, 8, 9};\\n    \\n    int res;\\n    public int rotatedDigits(int N) {\\n        res = 0;\\n        dfs(0, N);\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int N) {\\n        if (cur > 0 && check(cur)) {\\n            res++;\\n        }\\n        \\n        for (int i = (cur == 0 ? 1 : 0); i < digits.length; i++) {\\n            if (cur * 10 + digits[i] <= N) {\\n                dfs(cur * 10 + digits[i], N);\\n            }\\n        }\\n    }\\n    \\n    private boolean check(int N) {\\n        int t = N, r = 0, k = 1;\\n        \\n        while (t > 0) {\\n            r = r + rotate[t % 10] * k;\\n            k *= 10;\\n            t /= 10;\\n        }\\n        \\n        return r != N;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] rotate = new int[]{0, 1, 5, -1, -1, 2, 9, -1, 8, 6};\\n    int[] digits = new int[]{0, 1, 2, 5, 6, 8, 9};\\n    \\n    int res;\\n    public int rotatedDigits(int N) {\\n        res = 0;\\n        dfs(0, N);\\n        return res;\\n    }\\n    \\n    private void dfs(int cur, int N) {\\n        if (cur > 0 && check(cur)) {\\n            res++;\\n        }\\n        \\n        for (int i = (cur == 0 ? 1 : 0); i < digits.length; i++) {\\n            if (cur * 10 + digits[i] <= N) {\\n                dfs(cur * 10 + digits[i], N);\\n            }\\n        }\\n    }\\n    \\n    private boolean check(int N) {\\n        int t = N, r = 0, k = 1;\\n        \\n        while (t > 0) {\\n            r = r + rotate[t % 10] * k;\\n            k *= 10;\\n            t /= 10;\\n        }\\n        \\n        return r != N;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325045,
                "title": "python-solution-using-dictionary",
                "content": "Please comment for any doubt\\n\\n```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count=0\\n        d={0:0,1:1,2:5,3:-1,4:-1,5:2,6:9,7:-1,8:8,9:6}\\n        for i in range(1,N+1):\\n            l=list(str(i))\\n            res=[]\\n            for j in l:\\n                if d[int(j)]!=-1:\\n                    res.append(str(d[int(j)]))\\n                else:break\\n            if len(res)==len(l) and int(\\'\\'.join(res))!=i:\\n                count+=1\\n        return count\\n                        \\n                    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N: int) -> int:\\n        count=0\\n        d={0:0,1:1,2:5,3:-1,4:-1,5:2,6:9,7:-1,8:8,9:6}\\n        for i in range(1,N+1):\\n            l=list(str(i))\\n            res=[]\\n            for j in l:\\n                if d[int(j)]!=-1:\\n                    res.append(str(d[int(j)]))\\n                else:break\\n            if len(res)==len(l) and int(\\'\\'.join(res))!=i:\\n                count+=1\\n        return count\\n                        \\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 303213,
                "title": "c-solution-with-o-logn-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int same[10] = {1, 2, 2, 2, 2, 2, 2, 2, 3, 3};\\n        int dif[10] = {0, 0, 1, 1, 1, 2, 3, 3, 3, 4};\\n        int judge[10] = {2, 2, 1, 0, 0, 1, 1, 0, 2, 1};\\n        \\n        int res = 0;\\n        int valid = 2;\\n        int first = 0;\\n        \\n        for (int i = 4; i >= 1; i--) {\\n            int div = pow(10, i);\\n            int num = N / div;\\n            if (num > 0 && (first == 0 || (first != 0 && valid > 0))) {\\n                if (first == 0)\\n                    first = 1;\\n                if (valid == 2)\\n                    res += (same[num - 1] + dif[num - 1]) * pow(7, i) - same[num - 1] * pow(3, i);\\n                else if (valid == 1) \\n                    res += (same[num - 1] + dif[num - 1]) * pow(7, i);\\n                valid = min(valid, judge[num]);\\n                N -= num * div;\\n            }     \\n        }\\n        \\n\\t\\t// When it comes to ones place, we need some changes.\\n        if (N >= 0 && (first == 0 || (first != 0 && valid > 0))) {\\n            if (valid == 2)\\n                res += dif[N];\\n            else if (valid == 1) {\\n                res += dif[N] + same[N];\\n            }\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int N) {\\n        int same[10] = {1, 2, 2, 2, 2, 2, 2, 2, 3, 3};\\n        int dif[10] = {0, 0, 1, 1, 1, 2, 3, 3, 3, 4};\\n        int judge[10] = {2, 2, 1, 0, 0, 1, 1, 0, 2, 1};\\n        \\n        int res = 0;\\n        int valid = 2;\\n        int first = 0;\\n        \\n        for (int i = 4; i >= 1; i--) {\\n            int div = pow(10, i);\\n            int num = N / div;\\n            if (num > 0 && (first == 0 || (first != 0 && valid > 0))) {\\n                if (first == 0)\\n                    first = 1;\\n                if (valid == 2)\\n                    res += (same[num - 1] + dif[num - 1]) * pow(7, i) - same[num - 1] * pow(3, i);\\n                else if (valid == 1) \\n                    res += (same[num - 1] + dif[num - 1]) * pow(7, i);\\n                valid = min(valid, judge[num]);\\n                N -= num * div;\\n            }     \\n        }\\n        \\n\\t\\t// When it comes to ones place, we need some changes.\\n        if (N >= 0 && (first == 0 || (first != 0 && valid > 0))) {\\n            if (valid == 2)\\n                res += dif[N];\\n            else if (valid == 1) {\\n                res += dif[N] + same[N];\\n            }\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289369,
                "title": "12-lines-solution-regex-too-slow-but-i-like-use-it-hhh",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        String regexOfGoodNum = \"([018]*[2569]+[018]*)*\";\\n        int ans = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (Integer.toString(i).matches(regexOfGoodNum)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        String regexOfGoodNum = \"([018]*[2569]+[018]*)*\";\\n        int ans = 0;\\n        for (int i = 1; i <= N; i++) {\\n            if (Integer.toString(i).matches(regexOfGoodNum)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279346,
                "title": "python-self-explanatory",
                "content": "```\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(1,N+1):\\n            s = str(i)\\n            # print s \\n            if \\'3\\' in  s or \\'4\\' in s or  \\'7\\' in s :\\n                count += 0\\n            elif  \\'2\\' in s or \\'5\\' in s or \\'6\\' in s or \\'9\\' in s:\\n                count += 1\\n                # print \\'count\\'\\n            # print i\\n        return count\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(1,N+1):\\n            s = str(i)\\n            # print s \\n            if \\'3\\' in  s or \\'4\\' in s or  \\'7\\' in s :\\n                count += 0\\n            elif  \\'2\\' in s or \\'5\\' in s or \\'6\\' in s or \\'9\\' in s:\\n                count += 1\\n                # print \\'count\\'\\n            # print i\\n        return count\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 264053,
                "title": "python-solution",
                "content": "\\t\\'\\'\\'\\n\\tclass Solution:\\n\\t\\tdef rotatedDigits(self, N: int) -> int:\\n\\t\\t\\tgood_numbers = []\\n\\t\\t\\tnums = [str(i) for i in range(N+1)]\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif (\\'3\\' not in num and \\'4\\' not in num and \\'7\\' not in num) and (\\'2\\' in num or \\'5\\' in num or \\'6\\' in num or \\'9\\' in num):\\n\\t\\t\\t\\t\\tgood_numbers.append(num)\\n\\n\\t\\t\\treturn len(good_numbers)\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\t\\'\\'\\'\\n\\tclass Solution:\\n\\t\\tdef rotatedDigits(self, N: int) -> int:\\n\\t\\t\\tgood_numbers = []\\n\\t\\t\\tnums = [str(i) for i in range(N+1)]\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tif (\\'3\\' not in num and \\'4\\' not in num and \\'7\\' not in num) and (\\'2\\' in num or \\'5\\' in num or \\'6\\' in num or \\'9\\' in num):\\n\\t\\t\\t\\t\\tgood_numbers.append(num)\\n\\n\\t\\t\\treturn len(good_numbers)\\n\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 243992,
                "title": "a-simple-java-solution",
                "content": "```\\n\\nclass Solution {\\n    boolean is(int n) {\\n        int[] tab = new int[10];\\n        for(char c: Integer.toString(n).toCharArray()) {\\n            tab[c - \\'0\\'] = 1;\\n        }\\n        if (tab[3] == 1 || tab[4] == 1 || tab[7] == 1) return false;\\n        if (tab[6] + tab[9] + tab[2] + tab[5] == 0 && tab[1] + tab[0] + tab[8] > 0) return false;\\n        return true;\\n    }\\n    public int rotatedDigits(int N) {\\n        int res = 0;\\n        for(int i = 0; i <= N; i++) {\\n            if (is(i)) res++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    boolean is(int n) {\\n        int[] tab = new int[10];\\n        for(char c: Integer.toString(n).toCharArray()) {\\n            tab[c - \\'0\\'] = 1;\\n        }\\n        if (tab[3] == 1 || tab[4] == 1 || tab[7] == 1) return false;\\n        if (tab[6] + tab[9] + tab[2] + tab[5] == 0 && tab[1] + tab[0] + tab[8] > 0) return false;\\n        return true;\\n    }\\n    public int rotatedDigits(int N) {\\n        int res = 0;\\n        for(int i = 0; i <= N; i++) {\\n            if (is(i)) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214588,
                "title": "clean-c-solution-beats-100-o-n-helper-func",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canRotate(int N){\\n        bool dif{false};\\n        while(N){\\n            int cur = N%10;\\n            if (cur == 2 || cur == 5 || cur == 6 || cur == 9)\\n                dif = true;\\n            else if (cur == 3 || cur == 4 || cur == 7)\\n                return false;\\n            N /= 10;\\n        }\\n        return dif;\\n    }\\n    int rotatedDigits(int N) {\\n        int count{0};\\n        for (int i = 1; i <= N; i++)\\n            if (canRotate(i)) count++;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canRotate(int N){\\n        bool dif{false};\\n        while(N){\\n            int cur = N%10;\\n            if (cur == 2 || cur == 5 || cur == 6 || cur == 9)\\n                dif = true;\\n            else if (cur == 3 || cur == 4 || cur == 7)\\n                return false;\\n            N /= 10;\\n        }\\n        return dif;\\n    }\\n    int rotatedDigits(int N) {\\n        int count{0};\\n        for (int i = 1; i <= N; i++)\\n            if (canRotate(i)) count++;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211747,
                "title": "rust-12ms-solution",
                "content": "```Rust\\nimpl Solution {\\n    pub fn rotated_digits(n: i32) -> i32 {\\n        let mut count = 0;\\n        for i in 1..(n + 1) {\\n            let n_s = i.to_string();\\n            if n_s.contains(\"3\") || n_s.contains(\"7\") || n_s.contains(\"4\") {\\n                continue;\\n            }\\n            \\n            if n_s.contains(\"2\") || n_s.contains(\"5\") || n_s.contains(\"6\") || n_s.contains(\"9\") {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nimpl Solution {\\n    pub fn rotated_digits(n: i32) -> i32 {\\n        let mut count = 0;\\n        for i in 1..(n + 1) {\\n            let n_s = i.to_string();\\n            if n_s.contains(\"3\") || n_s.contains(\"7\") || n_s.contains(\"4\") {\\n                continue;\\n            }\\n            \\n            if n_s.contains(\"2\") || n_s.contains(\"5\") || n_s.contains(\"6\") || n_s.contains(\"9\") {\\n                count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208065,
                "title": "java-easiest-simplest",
                "content": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        Set<Integer> good = new HashSet<Integer>(Arrays.asList(2,5,6,9));\\n        Set<Integer> bad = new HashSet<Integer>(Arrays.asList(3,4,7));\\n        int count=0;\\n        for(int i=1;i<=N;i++) {\\n            boolean gud=false;\\n            int num=i;\\n            while(num!=0) {\\n                int digit = num%10;\\n                if(bad.contains(digit))\\n                {\\n                    gud=false; break;\\n                }\\n                else if(good.contains(digit))\\n                       gud=true;\\n                num=num/10;\\n            }\\n            if(gud)\\n                count++; \\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int rotatedDigits(int N) {\\n        Set<Integer> good = new HashSet<Integer>(Arrays.asList(2,5,6,9));\\n        Set<Integer> bad = new HashSet<Integer>(Arrays.asList(3,4,7));\\n        int count=0;\\n        for(int i=1;i<=N;i++) {\\n            boolean gud=false;\\n            int num=i;\\n            while(num!=0) {\\n                int digit = num%10;\\n                if(bad.contains(digit))\\n                {\\n                    gud=false; break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 146290,
                "title": "788-rotated-digits-java-c-python",
                "content": "Firstly, keep rotation for 0-9. 3, 4, 7 don`t have valid rotation. When we check a number, check if each digit rotation is valid. When we meet with a invalid roation, just return false. 127, because it has 7, so it is not good. Also, we should exclude the ones which is equal to itself after rotation. For example, 10, 101, 1081, etc. In that case, return false.\\n#### C++\\n```cpp\\nclass Solution {\\nprivate:\\n    char rotates[10] = {\\'0\\', \\'1\\', \\'5\\', \\'-\\', \\'-\\', \\'2\\', \\'9\\', \\'-\\', \\'8\\', \\'6\\'};\\npublic:\\n    int rotatedDigits(int N) {\\n        int cnt = 0;\\n        for(int i = 1; i <= N; i++) {\\n            cnt += good(i);\\n        }\\n        return cnt;\\n    }\\n    \\n    bool good(int N) {\\n        string s = to_string(N);\\n        int same = 0;\\n        for(auto c : s) {\\n            if(rotates[c-\\'0\\'] == \\'-\\') {//invalid rotation, return false\\n                return false;\\n            }\\n            else if(rotates[c-\\'0\\'] == c){\\n                same++; // keep identical after rotation\\n            }\\n        }\\n        return same != s.size();\\n    }\\n};\\n```\\n#### Java\\n```java\\nclass Solution {\\n    private char rotates[] = {\\'0\\', \\'1\\', \\'5\\', \\'-\\', \\'-\\', \\'2\\', \\'9\\', \\'-\\', \\'8\\', \\'6\\'};// keep rotate num for each num\\n    public int rotatedDigits(int N) {\\n        int cnt = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(good(i)) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    private boolean good(int N) {\\n        String s = String.valueOf(N);\\n        int same = 0;\\n        int len = s.length();\\n        for(int i = 0; i < len; i++) {\\n            if(rotates[s.charAt(i)-\\'0\\'] == s.charAt(i)) {// keep identical after rotation\\n                same++;\\n            }\\n            else if(rotates[s.charAt(i)-\\'0\\'] == \\'-\\'){// invalid rotation\\n                return false;\\n            }\\n        }\\n        return same != len;\\n    }\\n}\\n```\\n#### Python\\n```python\\nclass Solution(object):\\n    rotates = \"015--29-86\"\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        for i in range(1, N+1):\\n            if self.good(i):\\n                cnt += 1\\n        return cnt\\n                \\n    \\n    def good(self, N):\\n        strN = str(N)\\n        same = 0\\n        for c in strN:\\n            if self.rotates[int(c)] == \\'-\\': # invalid rotation\\n                return False\\n            elif self.rotates[int(c)] == c: # identical after rotation\\n                same += 1\\n        return same != len(strN)\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    char rotates[10] = {\\'0\\', \\'1\\', \\'5\\', \\'-\\', \\'-\\', \\'2\\', \\'9\\', \\'-\\', \\'8\\', \\'6\\'};\\npublic:\\n    int rotatedDigits(int N) {\\n        int cnt = 0;\\n        for(int i = 1; i <= N; i++) {\\n            cnt += good(i);\\n        }\\n        return cnt;\\n    }\\n    \\n    bool good(int N) {\\n        string s = to_string(N);\\n        int same = 0;\\n        for(auto c : s) {\\n            if(rotates[c-\\'0\\'] == \\'-\\') {//invalid rotation, return false\\n                return false;\\n            }\\n            else if(rotates[c-\\'0\\'] == c){\\n                same++; // keep identical after rotation\\n            }\\n        }\\n        return same != s.size();\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    private char rotates[] = {\\'0\\', \\'1\\', \\'5\\', \\'-\\', \\'-\\', \\'2\\', \\'9\\', \\'-\\', \\'8\\', \\'6\\'};// keep rotate num for each num\\n    public int rotatedDigits(int N) {\\n        int cnt = 0;\\n        for(int i = 1; i <= N; i++) {\\n            if(good(i)) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    private boolean good(int N) {\\n        String s = String.valueOf(N);\\n        int same = 0;\\n        int len = s.length();\\n        for(int i = 0; i < len; i++) {\\n            if(rotates[s.charAt(i)-\\'0\\'] == s.charAt(i)) {// keep identical after rotation\\n                same++;\\n            }\\n            else if(rotates[s.charAt(i)-\\'0\\'] == \\'-\\'){// invalid rotation\\n                return false;\\n            }\\n        }\\n        return same != len;\\n    }\\n}\\n```\n```python\\nclass Solution(object):\\n    rotates = \"015--29-86\"\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        cnt = 0\\n        for i in range(1, N+1):\\n            if self.good(i):\\n                cnt += 1\\n        return cnt\\n                \\n    \\n    def good(self, N):\\n        strN = str(N)\\n        same = 0\\n        for c in strN:\\n            if self.rotates[int(c)] == \\'-\\': # invalid rotation\\n                return False\\n            elif self.rotates[int(c)] == c: # identical after rotation\\n                same += 1\\n        return same != len(strN)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142756,
                "title": "python-beats-87",
                "content": "```\\ndef rotatedDigits(self, N):\\n\\tcount = 0\\n\\tfor i in range(1, N + 1):\\n\\t\\tif self.rotate(str(i)):\\n\\t\\t    count += 1\\n        return count\\n```\\n\\n```\\ndef rotate(self, n):\\n            if \\'4\\' in n or \\'7\\' in n or \\'3\\' in n:\\n                return False\\n            elif \\'2\\' in n or \\'5\\' in n or \\'6\\' in n or \\'9\\' in n:\\n                return True\\n            else:\\n                return None\\n```",
                "solutionTags": [],
                "code": "```\\ndef rotatedDigits(self, N):\\n\\tcount = 0\\n\\tfor i in range(1, N + 1):\\n\\t\\tif self.rotate(str(i)):\\n\\t\\t    count += 1\\n        return count\\n```\n```\\ndef rotate(self, n):\\n            if \\'4\\' in n or \\'7\\' in n or \\'3\\' in n:\\n                return False\\n            elif \\'2\\' in n or \\'5\\' in n or \\'6\\' in n or \\'9\\' in n:\\n                return True\\n            else:\\n                return None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 139574,
                "title": "rotated-digits-simple-python-with-explanation",
                "content": "* A number is invalid if it contains at least one of (3, 4, 7)\\n* A number is valid and counted if it contains at least on of (2, 5, 6, 9)\\n* A number is valid, but not counted if all it\\u2019s digits comprise only (0, 1, 8)\\n\\n**Step 1:**\\nConsider numbers in batches of 10, they either have 4, 7 or 0 good numbers.\\n\\tExample:\\n\\tFrom 10 to 19, there are 4 good numbers\\n\\tFrom 20 to 29, there are 7 good numbers\\n\\tFrom 30 to 39, there are 0 good numbers etc.\\n**Step 2:**\\nAfter completing all batches of 10, count the remaining good numbers left in N-9 to N\\n i.e count increases by 1 only if the number is one of (2, 5, 6, 9)\\n\\n```\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        if N < 10:\\n            return self.rotated(1, N+1, 1, 0)\\n        else:\\n            return self.rotated(0, N//10, 7, 4) + self.rotated(N-(N%10), N+1, 1, 0)\\n        \\n    def rotated(self, start, end, valid_res, invalid_res):\\n        invalid, valid, result = {3,4,7}, {2,5,6,9}, 0\\n        for i in range(start, end):\\n            digits = {int(x) for x in str(i)}\\n            if bool(digits & invalid):\\n                continue\\n            result += valid_res if bool(digits & valid) else invalid_res\\n        return result\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        if N < 10:\\n            return self.rotated(1, N+1, 1, 0)\\n        else:\\n            return self.rotated(0, N//10, 7, 4) + self.rotated(N-(N%10), N+1, 1, 0)\\n        \\n    def rotated(self, start, end, valid_res, invalid_res):\\n        invalid, valid, result = {3,4,7}, {2,5,6,9}, 0\\n        for i in range(start, end):\\n            digits = {int(x) for x in str(i)}\\n            if bool(digits & invalid):\\n                continue\\n            result += valid_res if bool(digits & valid) else invalid_res\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 138543,
                "title": "my-python-solution",
                "content": "```\\nclass Solution:\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        ret=0\\n        for i in range(1, N + 1):\\n            l = 0\\n            flag = 1\\n            for v in str(i):\\n                if v not in \\'0182569\\':\\n                    flag = 0\\n                    break\\n                if v in \\'018\\':\\n                    l += 1\\n            if l == len(str(i)):\\n                flag = 0\\n            if flag:\\n                ret+=1\\n        return ret\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        ret=0\\n        for i in range(1, N + 1):\\n            l = 0\\n            flag = 1\\n            for v in str(i):\\n                if v not in \\'0182569\\':\\n                    flag = 0\\n                    break\\n                if v in \\'018\\':\\n                    l += 1\\n            if l == len(str(i)):\\n                flag = 0\\n            if flag:\\n                ret+=1\\n        return ret\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 131565,
                "title": "easy-java",
                "content": "public int rotatedDigits(int N) {\\n    int result = 0;\\n\\n    for (int i = 2; i <= N; i++) {\\n      String str = \"\" + i;\\n      str = str.replace(\\'3\\', \\' \\').replace(\\'4\\', \\' \\').replace(\\'7\\', \\' \\');\\n      if (!str.equals(\"\" + i)) {\\n        continue;\\n      }\\n      str = str.replace(\\'2\\', \\'3\\').replace(\\'5\\', \\'2\\').replace(\\'3\\', \\'5\\');\\n      str = str.replace(\\'6\\', \\'3\\').replace(\\'9\\', \\'6\\').replace(\\'3\\', \\'9\\');\\n      if (!str.equals(\"\" + i)) {\\n        result++;\\n      }\\n    }\\n    return result;\\n  }",
                "solutionTags": [],
                "code": "public int rotatedDigits(int N) {\\n    int result = 0;\\n\\n    for (int i = 2; i <= N; i++) {\\n      String str = \"\" + i;\\n      str = str.replace(\\'3\\', \\' \\').replace(\\'4\\', \\' \\').replace(\\'7\\', \\' \\');\\n      if (!str.equals(\"\" + i)) {\\n        continue;\\n      }\\n      str = str.replace(\\'2\\', \\'3\\').replace(\\'5\\', \\'2\\').replace(\\'3\\', \\'5\\');\\n      str = str.replace(\\'6\\', \\'3\\').replace(\\'9\\', \\'6\\').replace(\\'3\\', \\'9\\');\\n      if (!str.equals(\"\" + i)) {\\n        result++;\\n      }\\n    }\\n    return result;\\n  }",
                "codeTag": "Unknown"
            },
            {
                "id": 130879,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun rotatedDigits(N: Int): Int {\\n        return (1..N).map {\\n            val original = it.toString()\\n            val rotated = rotate(original)\\n            rotated != null && rotated != original\\n        }.count { it }\\n    }\\n\\n    private fun rotate(s: String): String? {\\n        return if (s.map { rules.containsKey(it) }.all { it }) s.map { rules[it] }.joinToString(\"\") else null\\n    }\\n\\n    companion object {\\n        val rules = hashMapOf(\\n                Pair(\\'0\\', \\'0\\'),\\n                Pair(\\'1\\', \\'1\\'),\\n                Pair(\\'8\\', \\'8\\'),\\n                Pair(\\'2\\', \\'5\\'),\\n                Pair(\\'5\\', \\'2\\'),\\n                Pair(\\'6\\', \\'9\\'),\\n                Pair(\\'9\\', \\'6\\'))\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun rotatedDigits(N: Int): Int {\\n        return (1..N).map {\\n            val original = it.toString()\\n            val rotated = rotate(original)\\n            rotated != null && rotated != original\\n        }.count { it }\\n    }\\n\\n    private fun rotate(s: String): String? {\\n        return if (s.map { rules.containsKey(it) }.all { it }) s.map { rules[it] }.joinToString(\"\") else null\\n    }\\n\\n    companion object {\\n        val rules = hashMapOf(\\n                Pair(\\'0\\', \\'0\\'),\\n                Pair(\\'1\\', \\'1\\'),\\n                Pair(\\'8\\', \\'8\\'),\\n                Pair(\\'2\\', \\'5\\'),\\n                Pair(\\'5\\', \\'2\\'),\\n                Pair(\\'6\\', \\'9\\'),\\n                Pair(\\'9\\', \\'6\\'))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 130513,
                "title": "beats-99-64-short-python-solution-o-log10n-complexity",
                "content": "    def rotatedDigits(self, N):\\n        possible=set([0,1,2,5,6,8,9])\\n        not_possible=set([0,1,8])\\n        digits=[int(x) for x in str(N)]\\n        n=len(digits)\\n        def getCount(i,p):\\n            if i==n:return 1\\n            if p: return (len([x for x in possible if x<digits[i]])*(7**(len(digits)-1-i)))+\\\\\\n                        (getCount(i+1,True) if digits[i] in possible else 0)\\n            else: return (len([x for x in not_possible if x<digits[i]])*(3**(len(digits)-1-i)))+\\\\\\n                        (getCount(i+1,False) if digits[i] in not_possible else 0)\\n        return getCount(0,True)-getCount(0,False)",
                "solutionTags": [],
                "code": "    def rotatedDigits(self, N):\\n        possible=set([0,1,2,5,6,8,9])\\n        not_possible=set([0,1,8])\\n        digits=[int(x) for x in str(N)]\\n        n=len(digits)\\n        def getCount(i,p):\\n            if i==n:return 1\\n            if p: return (len([x for x in possible if x<digits[i]])*(7**(len(digits)-1-i)))+\\\\\\n                        (getCount(i+1,True) if digits[i] in possible else 0)\\n            else: return (len([x for x in not_possible if x<digits[i]])*(3**(len(digits)-1-i)))+\\\\\\n                        (getCount(i+1,False) if digits[i] in not_possible else 0)\\n        return getCount(0,True)-getCount(0,False)",
                "codeTag": "Python3"
            },
            {
                "id": 125583,
                "title": "my-python-solution-fast-and-simple",
                "content": "if any digit in {3,4,7} in a num, the num must not valid after rotate.\\nbut if any digit in {2,5,6,9} in a num, the num  is a good number.\\n```\\ncount=0\\nfor i in range(1,N+1):\\n\\ts =str(i) \\n        if \\'3\\' in s or \\'4\\' in s or\\'7\\' in s :\\n\\t\\tcontinue\\n        elif \\'2\\' in s or \\'5\\' in s or\\'6\\' in s or \\'9\\' in s:\\n                count+=1   \\nreturn count\\n```\\n        ",
                "solutionTags": [],
                "code": "```\\ncount=0\\nfor i in range(1,N+1):\\n\\ts =str(i) \\n        if \\'3\\' in s or \\'4\\' in s or\\'7\\' in s :\\n\\t\\tcontinue\\n        elif \\'2\\' in s or \\'5\\' in s or\\'6\\' in s or \\'9\\' in s:\\n                count+=1   \\nreturn count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 124512,
                "title": "python-code-beats-99-over-submissions",
                "content": "This problem is in fact a combinatoric problem.\\n```\\nclass Solution(object):\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        N += 1\\n        \\n        sym = [0,1,2,5,6,8,9]\\n        sym1 = [0,1,8]\\n        \\n        my_list = list(str(N))\\n        \\n        result = 0\\n        flag = True\\n        for i,c in enumerate(my_list):\\n            tmp = [x for x in sym if x < int(c)]\\n            if tmp != []:\\n                result += len(tmp) * (len(sym))**(len(my_list)-1-i) \\\\\\n                    - (flag == True) * len(set(tmp) & set(sym1)) * (len(sym1))**(len(my_list)-1-i)\\n                    \\n            if int(c) not in sym1:\\n                flag = False\\n            if int(c) not in sym:\\n                break\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def rotatedDigits(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        N += 1\\n        \\n        sym = [0,1,2,5,6,8,9]\\n        sym1 = [0,1,8]\\n        \\n        my_list = list(str(N))\\n        \\n        result = 0\\n        flag = True\\n        for i,c in enumerate(my_list):\\n            tmp = [x for x in sym if x < int(c)]\\n            if tmp != []:\\n                result += len(tmp) * (len(sym))**(len(my_list)-1-i) \\\\\\n                    - (flag == True) * len(set(tmp) & set(sym1)) * (len(sym1))**(len(my_list)-1-i)\\n                    \\n            if int(c) not in sym1:\\n                flag = False\\n            if int(c) not in sym:\\n                break\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123567,
                "title": "regex-simple-short",
                "content": "Number is valid if both conditions are true:\\n1. It does not contain any of the digits 3,4,7\\n2. It contains at least one of the digits 2,5,6,9\\n```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n      int res = 0;\\n      for (int i = 1; i <= N; i++) {\\n        String s = \"\" + i;\\n        if (!s.matches(\".*[347]+.*\") && s.matches(\".*[2569]+.*\")) res++;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n      int res = 0;\\n      for (int i = 1; i <= N; i++) {\\n        String s = \"\" + i;\\n        if (!s.matches(\".*[347]+.*\") && s.matches(\".*[2569]+.*\")) res++;\\n      }\\n      return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118887,
                "title": "python-solution-use-set",
                "content": "according to the question, the good number must have at least one of (2, 5, 9, 6) and may be exist anyone or None of (1, 0, 8)\\n\\n```\\n        must_set = set(\\'2596\\')\\n        optional_set = set(\\'108\\')\\n        good_number = 0\\n        for i in range(1, N + 1):\\n            number_set = set(str(i))\\n            if (number_set & must_set) == set(\\'\\'):\\n                continue\\n            if (number_set | must_set) == must_set:\\n                good_number += 1\\n            elif ((number_set - must_set) | optional_set) == optional_set:\\n                good_number += 1\\n\\n        return good_number\\n```",
                "solutionTags": [],
                "code": "```\\n        must_set = set(\\'2596\\')\\n        optional_set = set(\\'108\\')\\n        good_number = 0\\n        for i in range(1, N + 1):\\n            number_set = set(str(i))\\n            if (number_set & must_set) == set(\\'\\'):\\n                continue\\n            if (number_set | must_set) == must_set:\\n                good_number += 1\\n            elif ((number_set - must_set) | optional_set) == optional_set:\\n                good_number += 1\\n\\n        return good_number\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 118431,
                "title": "my-dfs-java-solution",
                "content": "Pretty StraightForward. Starting from 0, always append new candidate to the end of current number. If it\\'s larger than N, return; If it\\'s valid, increament res.\\nI think the time complexity is O(res), cause we just find the exact res numbers.\\n```\\nclass Solution {\\n    \\n    int res = 0;\\n    int[] candidates = {0, 1, 2, 5, 6, 8, 9};\\n    Set<Integer> difWithSelf = new HashSet<>(Arrays.asList(2, 5, 6, 9));\\n    \\n    public int rotatedDigits(int N) {\\n        if (N == 1) {\\n            return 0;\\n        }\\n        count(N, 0, false);\\n        return res;\\n    }\\n    \\n    public void count(int N, int curVal, boolean valid) {\\n        if (curVal > N) {\\n            return;\\n        }\\n        if (curVal >= 1 && valid) {\\n            res++;\\n        }\\n        for (int candidate : candidates) {\\n            if (curVal == 0 && candidate == 0) {\\n                continue;\\n            }\\n            count(N, curVal * 10 + candidate, valid || difWithSelf.contains(candidate));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int res = 0;\\n    int[] candidates = {0, 1, 2, 5, 6, 8, 9};\\n    Set<Integer> difWithSelf = new HashSet<>(Arrays.asList(2, 5, 6, 9));\\n    \\n    public int rotatedDigits(int N) {\\n        if (N == 1) {\\n            return 0;\\n        }\\n        count(N, 0, false);\\n        return res;\\n    }\\n    \\n    public void count(int N, int curVal, boolean valid) {\\n        if (curVal > N) {\\n            return;\\n        }\\n        if (curVal >= 1 && valid) {\\n            res++;\\n        }\\n        for (int candidate : candidates) {\\n            if (curVal == 0 && candidate == 0) {\\n                continue;\\n            }\\n            count(N, curVal * 10 + candidate, valid || difWithSelf.contains(candidate));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118419,
                "title": "python-one-liner-but-not-efficient-for-space-complexity-128ms",
                "content": "Storing every good number might not be efficient but here it is: \\n\\t\\t\\t\\n\\tclass Solution:\\n\\t\\tdef rotatedDigits(self, N):\\n\\t\\t\\treturn len([num for num in range(1, N+1) if not set(str(num)) & {\"3\",\"4\",\"7\"} and set(str(num)) & {\"2\",\"5\",\"6\",\"9\"}])",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef rotatedDigits(self, N):\\n\\t\\t\\treturn len([num for num in range(1, N+1) if not set(str(num)) & {\"3\",\"4\",\"7\"}",
                "codeTag": "Java"
            },
            {
                "id": 118243,
                "title": "easy-to-understand-java-solution",
                "content": "The idea is to count the number of invalid numbers. Iterate from 1 to N. Convert it to string. Iterate over the string. If there is any character 3,4,7 consider it invalid straighaway and so break out of the loop as we dont need to iterate over remaining part of string. If you encounter 2,5,6 or 9; do nothing. For that particular number if you encounter 1,8 or 0, count the number of such occurences. When you are done iterating over the string of particular number, if such occurences is equal to string length, that number is invalid .\\n```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int i = 1;\\n        int count = 0;\\n        while(i <= N){\\n            String s = Integer.toString(i);\\n            int unchanged = 0;\\n            for(int j=0; j<s.length(); j++){\\n                \\n                if(s.charAt(j) == \\'3\\' || s.charAt(j) == \\'4\\' || s.charAt(j) == \\'7\\'){\\n                    count++;\\n                    break;\\n                }\\n                else if(s.charAt(j) == \\'2\\' || s.charAt(j) == \\'5\\' || s.charAt(j) == \\'6\\' || s.charAt(j) == \\'9\\'){\\n                }\\n                else{\\n                    unchanged++;\\n                }\\n                \\n            }\\n            if(unchanged == s.length()){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return N-count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int N) {\\n        int i = 1;\\n        int count = 0;\\n        while(i <= N){\\n            String s = Integer.toString(i);\\n            int unchanged = 0;\\n            for(int j=0; j<s.length(); j++){\\n                \\n                if(s.charAt(j) == \\'3\\' || s.charAt(j) == \\'4\\' || s.charAt(j) == \\'7\\'){\\n                    count++;\\n                    break;\\n                }\\n                else if(s.charAt(j) == \\'2\\' || s.charAt(j) == \\'5\\' || s.charAt(j) == \\'6\\' || s.charAt(j) == \\'9\\'){\\n                }\\n                else{\\n                    unchanged++;\\n                }\\n                \\n            }\\n            if(unchanged == s.length()){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return N-count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117148,
                "title": "c-easy-to-understand-unordered-set",
                "content": "The idea here is to use ```unordered_set<int>``` to keep track of which are \n1. `st` -- numbers which can be rotated\n2. `non_st` -- numbers that cannot be rotated\n3. `sp` -- special numbers that are the same as it's rotation\n\nNow once we have this we just need to check if \n1. If there is a `non_st` number it cannot be rotated thus ```return false```\n2. If there is a `sp` number but no `st` number then it's the same so ```return false```\n3. If there is a `sp` number and a `st` number then it can possibly make a different number so ```return true```\n4. If there is only ```st``` numbers then ```return true```\n```\n bool checkDigits(const unordered_set<int>& st, const unordered_set<int>& not_st,const unordered_set<int>& sp, int pos) {\n        int st_count=0, sp_count = 0;\n        \n        while(pos > 0) {\n            int digit = pos%10;\n            \n            if(not_st.find(digit) != not_st.end())\n                return false;\n            \n            if(st.find(digit) != st.end())\n                ++st_count;\n            \n            if(sp.find(digit) != sp.end())\n                ++sp_count;\n            \n            pos /= 10;\n        }\n\n        if(sp_count > 0 && st_count < 1) {\n            return false;\n        }\n            \n        \n        return true;\n    }\n    \n    int rotatedDigits(int N) {\n        unordered_set<int>not_st{3,4,7}, st{2,5,6,9}, sp{0,1,8};\n        int valid =0;\n        for(int i=1; i<=N; ++i) {\n            if(checkDigits(st, not_st, sp, i)) {\n                //cout << i << \" \";\n                ++valid;\n            }\n        }\n        //cout << endl;\n        return valid;\n    }\n\n```",
                "solutionTags": [],
                "code": "```unordered_set<int>```\n```return false```\n```return false```\n```return true```\n```st```\n```return true```\n```\n bool checkDigits(const unordered_set<int>& st, const unordered_set<int>& not_st,const unordered_set<int>& sp, int pos) {\n        int st_count=0, sp_count = 0;\n        \n        while(pos > 0) {\n            int digit = pos%10;\n            \n            if(not_st.find(digit) != not_st.end())\n                return false;\n            \n            if(st.find(digit) != st.end())\n                ++st_count;\n            \n            if(sp.find(digit) != sp.end())\n                ++sp_count;\n            \n            pos /= 10;\n        }\n\n        if(sp_count > 0 && st_count < 1) {\n            return false;\n        }\n            \n        \n        return true;\n    }\n    \n    int rotatedDigits(int N) {\n        unordered_set<int>not_st{3,4,7}, st{2,5,6,9}, sp{0,1,8};\n        int valid =0;\n        for(int i=1; i<=N; ++i) {\n            if(checkDigits(st, not_st, sp, i)) {\n                //cout << i << \" \";\n                ++valid;\n            }\n        }\n        //cout << endl;\n        return valid;\n    }\n\n```",
                "codeTag": "C++"
            },
            {
                "id": 116596,
                "title": "c-4-ms-bit-mask",
                "content": "```\nclass Solution {\npublic:\n  int isValid(int n) {    \n    constexpr int kInValidMask = (1 << 3) | (1 << 4) | (1 << 7);\n    constexpr int kValidMask = (1 << 2) | (1 << 5) | (1 << 6) | (1 << 9);\n    \n    int valid = 0;\n    \n    while (n > 0) {\n      int r = 1 << (n % 10);\n      if (r & kInValidMask)\n        return 0;\n      else if (r & kValidMask)\n        valid = 1;\n      n /= 10;\n    }\n      \n    return valid;\n  }\n  \n  int rotatedDigits(int N) {\n    int ans = 0;\n    for (int i = 1; i <= N; ++i)\n      ans += isValid(i);\n    return ans;\n  }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n  int isValid(int n) {    \n    constexpr int kInValidMask = (1 << 3) | (1 << 4) | (1 << 7);\n    constexpr int kValidMask = (1 << 2) | (1 << 5) | (1 << 6) | (1 << 9);\n    \n    int valid = 0;\n    \n    while (n > 0) {\n      int r = 1 << (n % 10);\n      if (r & kInValidMask)\n        return 0;\n      else if (r & kValidMask)\n        valid = 1;\n      n /= 10;\n    }\n      \n    return valid;\n  }\n  \n  int rotatedDigits(int N) {\n    int ans = 0;\n    for (int i = 1; i <= N; ++i)\n      ans += isValid(i);\n    return ans;\n  }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 116501,
                "title": "java-solution",
                "content": "```\nclass Solution {\n    static int[] map = {0, 1, 5, -1, -1, 2, 9, -1, 8, 6};\n    public int rotatedDigits(int N) {\n        int result = 0;\n        for (int i = 2; i <= N; i++) {\n            if (isGoodNumber(i)) result++;\n        }\n        return result;\n    }\n    private boolean isGoodNumber(int n) {\n        int t = n, m = 0, base = 1;\n        while (t > 0) {\n            if (map[t % 10] == -1) return false;\n            m = m + map[t % 10] * base;\n            t /= 10;\n            base *= 10;\n        }\n        return n != m;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    static int[] map = {0, 1, 5, -1, -1, 2, 9, -1, 8, 6};\n    public int rotatedDigits(int N) {\n        int result = 0;\n        for (int i = 2; i <= N; i++) {\n            if (isGoodNumber(i)) result++;\n        }\n        return result;\n    }\n    private boolean isGoodNumber(int n) {\n        int t = n, m = 0, base = 1;\n        while (t > 0) {\n            if (map[t % 10] == -1) return false;\n            m = m + map[t % 10] * base;\n            t /= 10;\n            base *= 10;\n        }\n        return n != m;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100506,
                "title": "simple-digit-dp-faster-than-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[6][3][3][3];\\n    int solve(int ind,int tight,int leading_zero,string &s,vector<int> &digit,bool change){\\n        if(ind==s.size()){\\n            if(change)return 1;\\n            return 0;\\n        }\\n        if(dp[ind][tight][leading_zero][change]!=-1)return dp[ind][tight][leading_zero][change];\\n        int limit=9;\\n        if(tight)limit=s[ind]-\\'0\\';\\n        int ans=0;\\n        if(leading_zero){\\n            ans+=solve(ind+1,0,1,s,digit,change);\\n        }\\n        for(int i=0;i<digit.size();i++){\\n            if(digit[i]>limit)break;\\n            if(leading_zero && digit[i]==0){\\n                continue;\\n            }\\n            if(digit[i]==2 ||digit[i]==5 ||digit[i]==6 ||digit[i]==9 )\\n            ans+=solve(ind+1,(tight&&(limit==digit[i])),0,s,digit,1);\\n            else ans+=solve(ind+1,(tight&&(limit==digit[i])),0,s,digit,change);\\n        }return dp[ind][tight][leading_zero][change]=ans;\\n    }\\n    int rotatedDigits(int n) {\\n        string s=to_string(n);\\n        vector<int> digit={0,1,2,5,6,8,9};\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,1,1,s,digit,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[6][3][3][3];\\n    int solve(int ind,int tight,int leading_zero,string &s,vector<int> &digit,bool change){\\n        if(ind==s.size()){\\n            if(change)return 1;\\n            return 0;\\n        }\\n        if(dp[ind][tight][leading_zero][change]!=-1)return dp[ind][tight][leading_zero][change];\\n        int limit=9;\\n        if(tight)limit=s[ind]-\\'0\\';\\n        int ans=0;\\n        if(leading_zero){\\n            ans+=solve(ind+1,0,1,s,digit,change);\\n        }\\n        for(int i=0;i<digit.size();i++){\\n            if(digit[i]>limit)break;\\n            if(leading_zero && digit[i]==0){\\n                continue;\\n            }\\n            if(digit[i]==2 ||digit[i]==5 ||digit[i]==6 ||digit[i]==9 )\\n            ans+=solve(ind+1,(tight&&(limit==digit[i])),0,s,digit,1);\\n            else ans+=solve(ind+1,(tight&&(limit==digit[i])),0,s,digit,change);\\n        }return dp[ind][tight][leading_zero][change]=ans;\\n    }\\n    int rotatedDigits(int n) {\\n        string s=to_string(n);\\n        vector<int> digit={0,1,2,5,6,8,9};\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,1,1,s,digit,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063988,
                "title": "overcomplicated-js-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nconst rotatedDigits = function(n) {\\n    \\n    let hash = {\\n        0: 0,\\n        1: 1,\\n        2: 5,\\n        5: 2,\\n        6: 9,\\n        8: 8,\\n        9: 6,\\n    }\\n    \\n    let res = 0\\n      \\n    for (let i = 1; i <= n; i++) {\\n        \\n       const str  = i + \\'\\'\\n       \\n       let counter = 0\\n       \\n       for (let k = 0; k < str.length; k++) {\\n           \\n           if (str[k] == 3 || str[k] == 4 || str[k] == 7) {\\n               break\\n           } else {\\n               counter++\\n           }\\n              \\n       }\\n        \\n        if (counter === str.length) {\\n            \\n            let arr = []\\n            \\n            for (let i = 0; i < str.length; i++) {\\n                \\n                arr.push(hash[str[i]])\\n                \\n            }\\n            \\n            if (arr.join(\\'\\') !== str) res++\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    return res\\n    \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nconst rotatedDigits = function(n) {\\n    \\n    let hash = {\\n        0: 0,\\n        1: 1,\\n        2: 5,\\n        5: 2,\\n        6: 9,\\n        8: 8,\\n        9: 6,\\n    }\\n    \\n    let res = 0\\n      \\n    for (let i = 1; i <= n; i++) {\\n        \\n       const str  = i + \\'\\'\\n       \\n       let counter = 0\\n       \\n       for (let k = 0; k < str.length; k++) {\\n           \\n           if (str[k] == 3 || str[k] == 4 || str[k] == 7) {\\n               break\\n           } else {\\n               counter++\\n           }\\n              \\n       }\\n        \\n        if (counter === str.length) {\\n            \\n            let arr = []\\n            \\n            for (let i = 0; i < str.length; i++) {\\n                \\n                arr.push(hash[str[i]])\\n                \\n            }\\n            \\n            if (arr.join(\\'\\') !== str) res++\\n            \\n        }\\n        \\n        \\n    }\\n    \\n    return res\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054337,
                "title": "simple-and-optimum-java-based-solution",
                "content": "# Approach\\nMy first thought was to divide this problem and conquer one problem at a time. So I created a function that finds if a given number is a good number. I concluded from the description of question that a number would be good only if it does not contain any invalid digit (3,4,7) and any one of the digit of the number is a good number (2,5,6,9).\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int goodNumberCounter = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (isGoodNumber(i)) {\\n                goodNumberCounter++;\\n            }\\n        }\\n        return goodNumberCounter;\\n    }\\n\\n    public boolean isGoodNumber(int num) {\\n        boolean hasGoodDigit = false;\\n        while (num > 0) {\\n            int digit = num % 10;\\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {\\n                hasGoodDigit = true;\\n            } else if (digit == 3 || digit == 4 || digit == 7) {\\n                return false; // If it contains invalid digits, return false immediately\\n            }\\n            num /= 10;\\n        }\\n        return hasGoodDigit;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int goodNumberCounter = 0;\\n        for (int i = 1; i <= n; i++) {\\n            if (isGoodNumber(i)) {\\n                goodNumberCounter++;\\n            }\\n        }\\n        return goodNumberCounter;\\n    }\\n\\n    public boolean isGoodNumber(int num) {\\n        boolean hasGoodDigit = false;\\n        while (num > 0) {\\n            int digit = num % 10;\\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {\\n                hasGoodDigit = true;\\n            } else if (digit == 3 || digit == 4 || digit == 7) {\\n                return false; // If it contains invalid digits, return false immediately\\n            }\\n            num /= 10;\\n        }\\n        return hasGoodDigit;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033060,
                "title": "rotated-digits-java-solution",
                "content": "```\\nclass Solution {\\n    public static int rotatedDigits(int n) {\\n        int start = 2;\\n        int count = 0;\\n        boolean isRotated = false;\\n        String str = \"\";\\n\\n        while (start <= n) {\\n            isRotated = false;\\n            str = Integer.toString(start);\\n            int sub_start = 0;\\n\\n            while (sub_start < str.length()) {\\n                if (str.charAt(sub_start) == \\'2\\' || str.charAt(sub_start) == \\'5\\' || \\n                    str.charAt(sub_start) == \\'6\\' || str.charAt(sub_start) == \\'9\\') {\\n                    isRotated = true;\\n                } \\n                else if (str.charAt(sub_start) == \\'3\\' || str.charAt(sub_start) == \\'4\\' || \\n                         str.charAt(sub_start) == \\'7\\') {\\n                    isRotated = false;\\n                    break;\\n                }\\n                sub_start++;\\n            }\\n\\n            if (isRotated) {\\n                count++;\\n            }\\n\\n            start++;\\n        }\\n\\n        return count;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public static int rotatedDigits(int n) {\\n        int start = 2;\\n        int count = 0;\\n        boolean isRotated = false;\\n        String str = \"\";\\n\\n        while (start <= n) {\\n            isRotated = false;\\n            str = Integer.toString(start);\\n            int sub_start = 0;\\n\\n            while (sub_start < str.length()) {\\n                if (str.charAt(sub_start) == \\'2\\' || str.charAt(sub_start) == \\'5\\' || \\n                    str.charAt(sub_start) == \\'6\\' || str.charAt(sub_start) == \\'9\\') {\\n                    isRotated = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4023008,
                "title": "easy-solution-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each number k in 1 to n\\ncheck the digits of k and decide accordingly\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf digits of a number are 3/4/7 they cannot rotate to valid digit -> therefore they do not contibute to the ans\\n\\nOther case if number has digits 2/5/6/9 then they rotate and form a valid digit -> if number has these digits and do not have 3/4/7 -> they contribute towards the ans.\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int ans=0;\\n        vector<int> v(10,1);\\n        v[0]=0,v[1]=0,v[8]=0; //rotate to themselves\\n        v[3]=-1,v[4]=-1,v[7]=-1; // when these are rotated they do not form valid digits\\n\\n        // check for digits in x\\n        while(n){\\n            int x=n;\\n            bool key=false;\\n            while(x){\\n                int d=x%10;\\n                if(v[d]==1){\\n                    key=true;\\n                }\\n                else if(v[d]==-1){\\n                    // case of 3/4/7\\n                    key=false;\\n                    break;\\n                }\\n                x/=10;\\n            }\\n            if(key) ans++;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rotatedDigits(int n) {\\n        int ans=0;\\n        vector<int> v(10,1);\\n        v[0]=0,v[1]=0,v[8]=0; //rotate to themselves\\n        v[3]=-1,v[4]=-1,v[7]=-1; // when these are rotated they do not form valid digits\\n\\n        // check for digits in x\\n        while(n){\\n            int x=n;\\n            bool key=false;\\n            while(x){\\n                int d=x%10;\\n                if(v[d]==1){\\n                    key=true;\\n                }\\n                else if(v[d]==-1){\\n                    // case of 3/4/7\\n                    key=false;\\n                    break;\\n                }\\n                x/=10;\\n            }\\n            if(key) ans++;\\n            n--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997522,
                "title": "java-fast-solution-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int ans = 0;\\n        for(int i =1;n>=i;i++){\\n            ans += check(i);\\n        }\\n        return ans;\\n    }public int check(int i){\\n        int count=-1;\\n        while(i>0){\\n            int c = i%10;\\n            if(c==4||c==3||c==7)return 0;\\n            else if(c==2||c==5||c==6||c==9){\\n                count=1;\\n            }\\n            i/=10;\\n        }\\n        if(count>0)return 1;\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int ans = 0;\\n        for(int i =1;n>=i;i++){\\n            ans += check(i);\\n        }\\n        return ans;\\n    }public int check(int i){\\n        int count=-1;\\n        while(i>0){\\n            int c = i%10;\\n            if(c==4||c==3||c==7)return 0;\\n            else if(c==2||c==5||c==6||c==9){\\n                count=1;\\n            }\\n            i/=10;\\n        }\\n        if(count>0)return 1;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980814,
                "title": "best-solution-for-beginners-very-easy-highly-understandable-tc-o-n-log-n-java",
                "content": "# Intuition\\nFor each number in range we will check if the number id valid or not.\\n# Approach\\nIf a number contains 3,4, 7 then it is invalid. If a number contains at least 1  of them in any counts{2,5,6,9} then the number by rotating will get us a unique value.\\n\\nSo we will check if the number contains 3,4,7 then it will return false if the number contains any muber of (2,5,7,8) then it will return us true. \\n\\n# Complexity\\n- Time complexity:\\nthe digits of number is always less then the number itself except for 1.\\n\\nso at max the checking complexity will take O(n) or precisely we can say that the digits in number is around log n\\n\\nso total time complexity is O(n log n).\\n\\n- Space complexity:\\nspace complexity is constant i.e O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int countvalid = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (check(i)){\\n                countvalid++;\\n            }\\n        }\\n        return countvalid;\\n    }\\n\\n    //this function checks if the number is valid or not\\n\\n    private boolean check(int n){\\n        int count = 0; //count of {2,5,6,9} in the number\\n        while (n > 0){\\n            if (n % 10 == 2 || n % 10 == 5 || n % 10 == 6 || n % 10 == 9){\\n                count++;\\n            }\\n            \\n            else if(n % 10 == 0 || n % 10 == 1 || n % 10 == 8){}\\n\\n            else{\\n                return false;\\n            }\\n            n = n/10;\\n        }\\n        if (count > 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rotatedDigits(int n) {\\n        int countvalid = 0;\\n        for (int i = 1; i <= n; i++){\\n            if (check(i)){\\n                countvalid++;\\n            }\\n        }\\n        return countvalid;\\n    }\\n\\n    //this function checks if the number is valid or not\\n\\n    private boolean check(int n){\\n        int count = 0; //count of {2,5,6,9} in the number\\n        while (n > 0){\\n            if (n % 10 == 2 || n % 10 == 5 || n % 10 == 6 || n % 10 == 9){\\n                count++;\\n            }\\n            \\n            else if(n % 10 == 0 || n % 10 == 1 || n % 10 == 8){}\\n\\n            else{\\n                return false;\\n            }\\n            n = n/10;\\n        }\\n        if (count > 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564759,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1565675,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1565164,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1676058,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1573766,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1569229,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1569211,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1571911,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1917071,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1571920,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1564759,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1565675,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1565164,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1676058,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1573766,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1569229,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1569211,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1571911,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1917071,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            },
            {
                "id": 1571920,
                "content": [
                    {
                        "username": "edzaferovic",
                        "content": "The question says that a number is good if each individual number is rotated and the original number is different to the rotated number.\\n\\nHere is how rotations work:\\n\\n0 rotates to 0\\n1 rotates to 1\\n8 rotates to 8\\n\\n2 rotates to 5\\n5 rotates to 2\\n6 rotates to 9\\n9 rotates to 6 \\n\\nEvery other number 3,4 and 7 do not rotate and are invalid meaning if the number contains one of these it cannot be changed. \\n\\nSO this means that 20 would rotate to 50 bc 2 rotates to 5 and 0 stays the same. This number is good since 20 != 50.\\nAnother example is 33, since 3 is the first int it becomes invalid. Another example of this is 23, since 3 is the second int in the number it becomes invalid meaning even tho 2 changes to 5 and the number is 53, and 53 != 23, the 3 invalidates the number making it no good.\\n\\nHope this helps you guys understand what the question is asking for!\\n"
                    },
                    {
                        "username": "companion",
                        "content": "After rotating 180, 2 is still 2?"
                    },
                    {
                        "username": "shashwatpandeyy",
                        "content": "it become 5"
                    },
                    {
                        "username": "fmadrid",
                        "content": "[A Ludic Fallacy - Rotating Digits (Leet Code 788)](http://www.frankmadrid.com/ALudicFallacy/2018/02/28/rotated-digits-leet-code-788/)\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "guys the link is showing Ads don\\'t open ! It is un-relevant "
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they should add in example 1 - > \\n[1,10] -> 2 , 5 ,  6  , 9 \\n\\n1 , `8` and 10 are not good numbers .\\nThey forgot to mention that 8 also comes under the range [1,10] and remains same after the rotation."
                    },
                    {
                        "username": "prajapatikunal7",
                        "content": "Can someone help me in understanding of \"180 degree of digit\" ?\\n\\nLike \\n1) How 2 can be rotated 180 degree to 5? \\n2) How 1 or 8 can be rotated 180 degree to digit themeselves ?\\n\\nThanks in advance"
                    },
                    {
                        "username": "mchim",
                        "content": "Flip it upside down, then 2 becomes 5."
                    },
                    {
                        "username": "yuweila",
                        "content": "I input 22 and 23 into testcase and get the result 11 and 11 respectively, \\nthat meas the nubmer 23 is a bad number. Is it? 2 to 5 and 3 to 3, so 23 to 53?\\n\\nIs it a bug or the problem is the definition of **rotating each digit individually by 180 degrees** is not clear? I think the roatation might be:\\n\\n**1. rotate clockwise/counterclockwise?**\\n(X) 2 and 5 rotate to itself, and it is conflict with the problem description.\\n\\n**2. flip vertically** (Put a mirror besides the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(X) 6 and 9 roate to itself, conflict.\\n\\n**3. flip horizontally** (Put a mirror under the number and see what inside)\\n(O) 2 and 5 rotate to each other.\\n(O) 6 and 9 roate to each other. (If 9 is wirtten like a lollipop)\\n**How about 3, 4, and 7?** \\n4 and 7 can not get a valid number, and 3 can rotate to itself. But the problem description does not mention about 3 and the testcase shows 3 is a bad number. Does that mean the rotation is not flip horizontally? So what is **rotating each digit individually by 180 degrees**?"
                    },
                    {
                        "username": "leetcode_yao",
                        "content": "2 and 5 rotate each other? why?\\nwhy 2->2 5->5 ?"
                    },
                    {
                        "username": "heesub",
                        "content": "This question makes me post my first comment here. I tried to understand this question and derive an optimal solution, but it was just a waste of time. Only brute-force solution exists. If this can be solved in a more efficient way, please enlighten me."
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "brute force is working without tle"
                    },
                    {
                        "username": "genegenehou",
                        "content": "I think `69` is not a good number, since if we rotate it by 180 degree, it\\'s still `69`.\\n\\nBut if you print out the good numbers with the AC solution, you\\'ll find `69` is a good number. Why?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "we all know why it is a `good number` pun intended.\\n\\nactually -> 69 becomes 96 according to description."
                    }
                ]
            }
        ]
    },
    {
        "title": "Alphabet Board Path",
        "question_content": "<p>On an alphabet board, we start at position <code>(0, 0)</code>, corresponding to character&nbsp;<code>board[0][0]</code>.</p>\r\n\r\n<p>Here, <code>board = [&quot;abcde&quot;, &quot;fghij&quot;, &quot;klmno&quot;, &quot;pqrst&quot;, &quot;uvwxy&quot;, &quot;z&quot;]</code>, as shown in the diagram below.</p>\r\n\r\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/07/28/azboard.png\" style=\"width: 250px; height: 317px;\" /></p>\r\n\r\n<p>We may make the following moves:</p>\r\n\r\n<ul>\r\n\t<li><code>&#39;U&#39;</code> moves our position up one row, if the position exists on the board;</li>\r\n\t<li><code>&#39;D&#39;</code> moves our position down one row, if the position exists on the board;</li>\r\n\t<li><code>&#39;L&#39;</code> moves our position left one column, if the position exists on the board;</li>\r\n\t<li><code>&#39;R&#39;</code> moves our position right one column, if the position exists on the board;</li>\r\n\t<li><code>&#39;!&#39;</code>&nbsp;adds the character <code>board[r][c]</code> at our current position <code>(r, c)</code>&nbsp;to the&nbsp;answer.</li>\r\n</ul>\r\n\r\n<p>(Here, the only positions that exist on the board are positions with letters on them.)</p>\r\n\r\n<p>Return a sequence of moves that makes our answer equal to <code>target</code>&nbsp;in the minimum number of moves.&nbsp; You may return any path that does so.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n<pre><strong>Input:</strong> target = \"leet\"\r\n<strong>Output:</strong> \"DDR!UURRR!!DDD!\"\r\n</pre><p><strong class=\"example\">Example 2:</strong></p>\r\n<pre><strong>Input:</strong> target = \"code\"\r\n<strong>Output:</strong> \"RR!DDRR!UUL!R!\"\r\n</pre>\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= target.length &lt;= 100</code></li>\r\n\t<li><code>target</code> consists only of English lowercase letters.</li>\r\n</ul>",
        "solutions": [
            {
                "id": 345278,
                "title": "c-java-o-n",
                "content": "Determine the coordinate and move there. Note that \\'z\\' is tricky as you cannot move left or right in the last row.\\n\\nTo account for that, make sure we move up before moving right, and move left before moving down.\\n## C++\\n```\\nstring alphabetBoardPath(string target, int x = 0, int y = 0) {\\n  string res;\\n  for (auto ch : target) {\\n    int x1 = (ch - \\'a\\') % 5, y1 = (ch - \\'a\\') / 5;\\n    res += string(max(0, y - y1), \\'U\\') + string(max(0, x1 - x), \\'R\\') +\\n      string(max(0, x - x1), \\'L\\') + string(max(0, y1 - y), \\'D\\') + \"!\";\\n    x = x1, y = y1;\\n  }\\n  return res;\\n}\\n```\\n## Java\\n> Would be nice to have Java 11 support, so we can just do ```\"U\".repeat(Math.max(0, y - y1));```\\n```\\npublic String alphabetBoardPath(String target) {\\n  int x = 0, y = 0;\\n  StringBuilder sb = new StringBuilder();\\n  for (char ch : target.toCharArray()) {\\n    int x1 = (ch - \\'a\\') % 5, y1 = (ch - \\'a\\') / 5;\\n    sb.append(String.join(\"\", Collections.nCopies(Math.max(0, y - y1), \"U\")) +\\n      String.join(\"\", Collections.nCopies(Math.max(0, x1 - x), \"R\")) +\\n      String.join(\"\", Collections.nCopies(Math.max(0, x - x1), \"L\")) +\\n      String.join(\"\", Collections.nCopies(Math.max(0, y1 - y), \"D\")) + \"!\");\\n    x = x1; y = y1;\\n  }\\n  return sb.toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring alphabetBoardPath(string target, int x = 0, int y = 0) {\\n  string res;\\n  for (auto ch : target) {\\n    int x1 = (ch - \\'a\\') % 5, y1 = (ch - \\'a\\') / 5;\\n    res += string(max(0, y - y1), \\'U\\') + string(max(0, x1 - x), \\'R\\') +\\n      string(max(0, x - x1), \\'L\\') + string(max(0, y1 - y), \\'D\\') + \"!\";\\n    x = x1, y = y1;\\n  }\\n  return res;\\n}\\n```\n```\"U\".repeat(Math.max(0, y - y1));```\n```\\npublic String alphabetBoardPath(String target) {\\n  int x = 0, y = 0;\\n  StringBuilder sb = new StringBuilder();\\n  for (char ch : target.toCharArray()) {\\n    int x1 = (ch - \\'a\\') % 5, y1 = (ch - \\'a\\') / 5;\\n    sb.append(String.join(\"\", Collections.nCopies(Math.max(0, y - y1), \"U\")) +\\n      String.join(\"\", Collections.nCopies(Math.max(0, x1 - x), \"R\")) +\\n      String.join(\"\", Collections.nCopies(Math.max(0, x - x1), \"L\")) +\\n      String.join(\"\", Collections.nCopies(Math.max(0, y1 - y), \"D\")) + \"!\");\\n    x = x1; y = y1;\\n  }\\n  return sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345235,
                "title": "python-easy-solution",
                "content": "## **Intuition**\\nCalculate this difference of coordinates.\\n<br>\\n\\n## **Explanation**\\nNotice that moving down and moving right,\\nmay move into a square that doesn\\'t exist.\\nTo avoid this, we put `L U` before `R D`.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Python:**\\n```python\\n    def alphabetBoardPath(self, target):\\n        m = {c: [i / 5, i % 5] for i, c in enumerate(\"abcdefghijklmnopqrstuvwxyz\")}\\n        x0, y0 = 0, 0\\n        res = []\\n        for c in target:\\n            x, y = m[c]\\n            if y < y0: res.append(\\'L\\' * (y0 - y))\\n            if x < x0: res.append(\\'U\\' * (x0 - x))\\n            if x > x0: res.append(\\'D\\' * (x - x0))\\n            if y > y0: res.append(\\'R\\' * (y - y0))\\n            res.append(\\'!\\')\\n            x0, y0 = x, y\\n        return \"\".join(res)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n    def alphabetBoardPath(self, target):\\n        m = {c: [i / 5, i % 5] for i, c in enumerate(\"abcdefghijklmnopqrstuvwxyz\")}\\n        x0, y0 = 0, 0\\n        res = []\\n        for c in target:\\n            x, y = m[c]\\n            if y < y0: res.append(\\'L\\' * (y0 - y))\\n            if x < x0: res.append(\\'U\\' * (x0 - x))\\n            if x > x0: res.append(\\'D\\' * (x - x0))\\n            if y > y0: res.append(\\'R\\' * (y - y0))\\n            res.append(\\'!\\')\\n            x0, y0 = x, y\\n        return \"\".join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 345312,
                "title": "java-clean-and-short-solution-easy-to-understand",
                "content": "I tried to store the whole board first, then realized that we could just caculate the indices directly.\\nBy comparing the current indices and the previous ones, the path could be found. \\n```\\npublic String alphabetBoardPath(String target) {\\n        if(target == null) return \"\";\\n        char[] chs = target.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        int previ = 0, prevj = 0;\\n        for(int i = 0; i < chs.length; i++) {\\n            int curi = (chs[i] - \\'a\\') / 5;\\n            int curj = (chs[i] - \\'a\\') % 5;\\n            if(curi == previ && curj == prevj) {\\n                sb.append(\"!\");\\n            } else {\\n                printPath(sb, previ, prevj, curi, curj); \\n                sb.append(\"!\");\\n                previ = curi; prevj = curj;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private void printPath(StringBuilder sb, int previ, int prevj, int curi, int curj) {       \\n        while(curi < previ) {\\n            sb.append(\"U\"); curi++;\\n        } \\n        while(curj > prevj) {\\n            sb.append(\"R\"); curj--;\\n        } \\n        while(curj < prevj) {\\n            sb.append(\"L\"); curj++;\\n        }  \\n        while(curi > previ) {\\n            sb.append(\"D\"); curi--;\\n        }                      \\n    }",
                "solutionTags": [],
                "code": "I tried to store the whole board first, then realized that we could just caculate the indices directly.\\nBy comparing the current indices and the previous ones, the path could be found. \\n```\\npublic String alphabetBoardPath(String target) {\\n        if(target == null) return \"\";\\n        char[] chs = target.toCharArray();\\n        StringBuilder sb = new StringBuilder();\\n        int previ = 0, prevj = 0;\\n        for(int i = 0; i < chs.length; i++) {\\n            int curi = (chs[i] - \\'a\\') / 5;\\n            int curj = (chs[i] - \\'a\\') % 5;\\n            if(curi == previ && curj == prevj) {\\n                sb.append(\"!\");\\n            } else {\\n                printPath(sb, previ, prevj, curi, curj); \\n                sb.append(\"!\");\\n                previ = curi; prevj = curj;\\n            }\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private void printPath(StringBuilder sb, int previ, int prevj, int curi, int curj) {       \\n        while(curi < previ) {\\n            sb.append(\"U\"); curi++;\\n        } \\n        while(curj > prevj) {\\n            sb.append(\"R\"); curj--;\\n        } \\n        while(curj < prevj) {\\n            sb.append(\"L\"); curj++;\\n        }  \\n        while(curi > previ) {\\n            sb.append(\"D\"); curi--;\\n        }                      \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 385202,
                "title": "python-bfs-solution",
                "content": "do multiple times bfs to search a letter from given place(x,y)\\n```\\nfrom collections import deque\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        res=[]\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        def bfs(x,y,target):\\n            if board[x][y]==target:\\n                return x,y,\\'!\\'\\n            q=deque([(x,y,\"\")])\\n            visited={(x,y)}\\n            while q:\\n                x,y,path=q.popleft()\\n                for i,j,s in [(1,0,\\'D\\'),(0,1,\\'R\\'),(-1,0,\\'U\\'),(0,-1,\\'L\\')]:\\n                    if 0<=x+i<=5 and 0<=y+j<len(board[x+i]) and (x+i,y+j) not in visited:\\n                        visited.add((x+i,y+j))\\n                        if board[x+i][y+j]==target:\\n                            return x+i,y+j,path+s+\\'!\\'\\n                        else:\\n                            q.append((x+i,y+j,path+s))\\n        \\n        x,y=0,0\\n        for ch in target:\\n            x,y,path=bfs(x,y,ch)\\n            res.append(path)\\n        return \\'\\'.join(res)",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def alphabetBoardPath(self, target):\\n        res=[]\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        def bfs(x,y,target):\\n            if board[x][y]==target:\\n                return x,y,\\'!\\'\\n            q=deque([(x,y,\"\")])\\n            visited={(x,y)}",
                "codeTag": "Java"
            },
            {
                "id": 345291,
                "title": "java-python-3-simple-code-for-indices-manipulation-w-explanation-and-analysis",
                "content": "1. `(i, j)`, `(row, col)` are current and next coordinates of the letters, respectively.\\n2. Map `[a-z]` to `[0-25]`, and use `pos` to denote the positon of a letter, then compute the letter\\'s coordinates: `row = pos / 5, col = pos % 5`.\\n3. If current letter is `z`, we must move upward before moving right; if next letter is `z`, must move left before moving downward.\\n\\n```java\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int n = 0, i = 0, j = 0; n < target.length(); ++n) {\\n            int pos = target.charAt(n) - \\'a\\', row = pos / 5, col = pos % 5;\\n            while (j > col) { // while loop of left (L) move before that of downward (D) move.\\n                sb.append(\\'L\\');\\n                --j;\\n            }\\n            while (i > row) { // while loop of upward (U) move before that of right (R) move.\\n                sb.append(\\'U\\');\\n                --i;\\n            }\\n            while (i < row) { // while loop of downward (D) move.\\n                sb.append(\\'D\\');\\n                ++i;\\n            }\\n            while (j < col) { // while loop of right (R) move.\\n                sb.append(\\'R\\');\\n                ++j;\\n            }\\n            sb.append(\\'!\\');   \\n        }\\n        return sb.toString();\\n```\\n```python\\n    def alphabetBoardPath(self, target: str) -> str:\\n        i = j = 0\\n        ans = []\\n        for c in target:\\n            diff = ord(c) - ord(\\'a\\')\\n            row, col = divmod(diff, 5)\\n            while i > row:\\n                i -= 1\\n                ans.append(\\'U\\')\\n            while j > col:\\n                j -= 1\\n                ans.append(\\'L\\')\\n            while i < row:\\n                i += 1\\n                ans.append(\\'D\\')\\n            while j < col:\\n                j += 1\\n                ans.append(\\'R\\')\\n            ans.append(\\'!\\')   \\n        return \\'\\'.join(ans) \\n```\\n\\n----\\n\\n**Analysis:**\\n\\n```\\n[\"abcde\", \\n \"fghij\", \\n \"klmno\", \\n \"pqrst\", \\n \"uvwxy\", \\n \"z\"]\\n ```\\nFor each char in `target`, we move at most `5 + 5 = 10` times and use at most `10` letters to save.\\n\\nTime & space: O(n), where n = target.length().",
                "solutionTags": [],
                "code": "```java\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int n = 0, i = 0, j = 0; n < target.length(); ++n) {\\n            int pos = target.charAt(n) - \\'a\\', row = pos / 5, col = pos % 5;\\n            while (j > col) { // while loop of left (L) move before that of downward (D) move.\\n                sb.append(\\'L\\');\\n                --j;\\n            }\\n            while (i > row) { // while loop of upward (U) move before that of right (R) move.\\n                sb.append(\\'U\\');\\n                --i;\\n            }\\n            while (i < row) { // while loop of downward (D) move.\\n                sb.append(\\'D\\');\\n                ++i;\\n            }\\n            while (j < col) { // while loop of right (R) move.\\n                sb.append(\\'R\\');\\n                ++j;\\n            }\\n            sb.append(\\'!\\');   \\n        }\\n        return sb.toString();\\n```\n```python\\n    def alphabetBoardPath(self, target: str) -> str:\\n        i = j = 0\\n        ans = []\\n        for c in target:\\n            diff = ord(c) - ord(\\'a\\')\\n            row, col = divmod(diff, 5)\\n            while i > row:\\n                i -= 1\\n                ans.append(\\'U\\')\\n            while j > col:\\n                j -= 1\\n                ans.append(\\'L\\')\\n            while i < row:\\n                i += 1\\n                ans.append(\\'D\\')\\n            while j < col:\\n                j += 1\\n                ans.append(\\'R\\')\\n            ans.append(\\'!\\')   \\n        return \\'\\'.join(ans) \\n```\n```\\n[\"abcde\", \\n \"fghij\", \\n \"klmno\", \\n \"pqrst\", \\n \"uvwxy\", \\n \"z\"]\\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 347835,
                "title": "c-short-and-clean-code-beat-100",
                "content": "move UP and LEFT before DOWN and RIGHT to avoid \"trapped\" in \\'z\\'. Add \\'a\\' to string for initialization.\\n\\n```\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char, pair<int,int>> mp;\\n        for(int i = 0; i < 26; ++i) {\\n            mp[i+\\'a\\'] = {i/5, i%5};\\n        }\\n        target = \\'a\\' + target;\\n        string path;\\n        int dx = 0, dy = 0;\\n        for(int i = 1; i < target.size(); ++i) {\\n            auto cur = mp[target[i]];\\n            auto prev = mp[target[i-1]];\\n            dx = cur.first - prev.first;\\n            dy = cur.second - prev.second;\\n            if(dy < 0) path += string(-dy, \\'L\\');\\n            if(dx < 0) path += string(-dx, \\'U\\');\\n            if(dy > 0) path += string(dy, \\'R\\');\\n            if(dx > 0) path += string(dx, \\'D\\');\\n            path += \\'!\\';\\n        }\\n        return path;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char, pair<int,int>> mp;\\n        for(int i = 0; i < 26; ++i) {\\n            mp[i+\\'a\\'] = {i/5, i%5};\\n        }\\n        target = \\'a\\' + target;\\n        string path;\\n        int dx = 0, dy = 0;\\n        for(int i = 1; i < target.size(); ++i) {\\n            auto cur = mp[target[i]];\\n            auto prev = mp[target[i-1]];\\n            dx = cur.first - prev.first;\\n            dy = cur.second - prev.second;\\n            if(dy < 0) path += string(-dy, \\'L\\');\\n            if(dx < 0) path += string(-dx, \\'U\\');\\n            if(dy > 0) path += string(dy, \\'R\\');\\n            if(dx > 0) path += string(dx, \\'D\\');\\n            path += \\'!\\';\\n        }\\n        return path;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1373604,
                "title": "python-bfs-manhattan-distance-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS**\\n- For each chacter `c` in `target`: \\n\\t- Do BFS to find the shortest path from `src` to `dst`.\\n\\t- Where `src` = `lastPos`, `dst = getPos(c)`.\\n\\t- Update `lastPos = getPos(c)`.\\n- But, there are some notices:\\n\\t- We need to prioritize to move `UP` first, because you can see the position of character `z` in the board, it can\\'t move to the right side.\\n\\t- Then we prioritize to move to the `RIGHT` second, because you can see the position of character `v` or `w` or `x` or `y`, it can\\'t move down.\\n\\n![image](https://assets.leetcode.com/users/images/333667b5-8665-44bc-b5c4-7c9c6d9c9f99_1627711578.6819215.png)\\n\\n```python\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        nRows, nCols = 6, 5\\n\\n        def getPos(c):\\n            index = ord(c) - ord(\\'a\\')\\n            return index // nCols, index % nCols\\n\\n        def neighbors(pos):\\n            for dir in [[-1, 0, \\'U\\'], [0, -1, \\'L\\'], [0, 1, \\'R\\'], [1, 0, \\'D\\'], ]:\\n                nr, nc = pos[0] + dir[0], pos[1] + dir[1]\\n                if nr < 0 or nr == nRows or nc < 0 or nc == nCols: continue\\n                yield (nr, nc), dir[2]\\n\\n        def bfs(src, dst):\\n            q = deque([(src, \"\")])\\n            seen = {src}\\n            while q:\\n                pos, path = q.popleft()\\n                if pos == dst:\\n                    return path\\n\\n                for nei, d in neighbors(pos):\\n                    if nei not in seen:\\n                        seen.add(nei)\\n                        q.append((nei, path + d))\\n\\n        lastPos = (0, 0)\\n        ans = []\\n        for c in target:\\n            ans.append(bfs(lastPos, getPos(c)))\\n            ans.append(\"!\")\\n            lastPos = getPos(c)\\n        return \"\".join(ans)\\n```\\n**Complexity**\\n- Time: `O(N * (E + V))` ~ `O(N  * 5 * 26)`, where `E = 4 * V`, `V = 26`, `N <= 100` is length of `target` string.\\n- Space: `O(ouput + E + V)` ~ `O(5 * 26)`\\n\\n--- \\n\\n**\\u2714\\uFE0F Solution 2: Manhattan distance**\\n- For each chacter `c` in `target`: \\n\\t- We find the shortest path from `src` to `dst`, by moving as manhattan distance.\\n\\t- Where `src` = `lastPos`, `dst = getPos(c)`.\\n\\t- Update `lastPos = getPos(c)`.\\n- But, there are some notices:\\n\\t- We need to prioritize to move `UP` first, because you can see the position of character `z` in the board, it can\\'t move to the right side.\\n\\t- Then we prioritize to move to the `RIGHT` second, because you can see the position of character `v` or `w` or `x` or `y`, it can\\'t move down.\\n\\n![image](https://assets.leetcode.com/users/images/333667b5-8665-44bc-b5c4-7c9c6d9c9f99_1627711578.6819215.png)\\n\\n```python\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        nRows, nCols = 6, 5\\n\\n        def getPos(c):\\n            index = ord(c) - ord(\\'a\\')\\n            return index // nCols, index % nCols\\n\\n        def manhattan(src, dst):\\n            ans = \"\"\\n            if src[0] > dst[0]: ans += \"U\" * (src[0] - dst[0])  # src[0] > dst[0] -> Move U, src[0] - dst[0] times\\n            if src[1] > dst[1]: ans += \"L\" * (src[1] - dst[1])  # src[1] > dst[2] -> Move L, src[1] - dst[1] times\\n            if src[0] < dst[0]: ans += \"D\" * (dst[0] - src[0])  # src[0] < dst[0] -> Move D, dst[0] - src[0] times\\n            if src[1] < dst[1]: ans += \"R\" * (dst[1] - src[1])  # src[1] < dst[1] -> Move R, dst[1] - src[1] times\\n            return ans\\n\\n        lastPos = (0, 0)\\n        ans = []\\n        for c in target:\\n            ans.append(manhattan(lastPos, getPos(c)))\\n            ans.append(\"!\")\\n            lastPos = getPos(c)\\n        return \"\".join(ans)\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 100` is length of `target` string.\\n- Space: `O(output)`.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        nRows, nCols = 6, 5\\n\\n        def getPos(c):\\n            index = ord(c) - ord(\\'a\\')\\n            return index // nCols, index % nCols\\n\\n        def neighbors(pos):\\n            for dir in [[-1, 0, \\'U\\'], [0, -1, \\'L\\'], [0, 1, \\'R\\'], [1, 0, \\'D\\'], ]:\\n                nr, nc = pos[0] + dir[0], pos[1] + dir[1]\\n                if nr < 0 or nr == nRows or nc < 0 or nc == nCols: continue\\n                yield (nr, nc), dir[2]\\n\\n        def bfs(src, dst):\\n            q = deque([(src, \"\")])\\n            seen = {src}\\n            while q:\\n                pos, path = q.popleft()\\n                if pos == dst:\\n                    return path\\n\\n                for nei, d in neighbors(pos):\\n                    if nei not in seen:\\n                        seen.add(nei)\\n                        q.append((nei, path + d))\\n\\n        lastPos = (0, 0)\\n        ans = []\\n        for c in target:\\n            ans.append(bfs(lastPos, getPos(c)))\\n            ans.append(\"!\")\\n            lastPos = getPos(c)\\n        return \"\".join(ans)\\n```\n```python\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        nRows, nCols = 6, 5\\n\\n        def getPos(c):\\n            index = ord(c) - ord(\\'a\\')\\n            return index // nCols, index % nCols\\n\\n        def manhattan(src, dst):\\n            ans = \"\"\\n            if src[0] > dst[0]: ans += \"U\" * (src[0] - dst[0])  # src[0] > dst[0] -> Move U, src[0] - dst[0] times\\n            if src[1] > dst[1]: ans += \"L\" * (src[1] - dst[1])  # src[1] > dst[2] -> Move L, src[1] - dst[1] times\\n            if src[0] < dst[0]: ans += \"D\" * (dst[0] - src[0])  # src[0] < dst[0] -> Move D, dst[0] - src[0] times\\n            if src[1] < dst[1]: ans += \"R\" * (dst[1] - src[1])  # src[1] < dst[1] -> Move R, dst[1] - src[1] times\\n            return ans\\n\\n        lastPos = (0, 0)\\n        ans = []\\n        for c in target:\\n            ans.append(manhattan(lastPos, getPos(c)))\\n            ans.append(\"!\")\\n            lastPos = getPos(c)\\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891117,
                "title": "python-o-n-without-bfs-faster-than-90-less-space-than-100",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str):\\n        size = 5\\n        curx, cury = 0, 0\\n        offset = ord(\\'a\\')\\n        ans = \\'\\'\\n        \\n        for i in target:\\n            row = (ord(i)-offset)//size\\n            col = (ord(i)-offset)%size\\n            \\n            if curx > col: ans += \\'L\\'*(curx-col)\\n            if row > cury: ans += \\'D\\'*(row-cury)\\n            if cury > row: ans += \\'U\\'*(cury-row)    \\n            if col > curx: ans += \\'R\\'*(col-curx)\\n            \\n            ans += \\'!\\'\\n            curx, cury = col, row\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str):\\n        size = 5\\n        curx, cury = 0, 0\\n        offset = ord(\\'a\\')\\n        ans = \\'\\'\\n        \\n        for i in target:\\n            row = (ord(i)-offset)//size\\n            col = (ord(i)-offset)%size\\n            \\n            if curx > col: ans += \\'L\\'*(curx-col)\\n            if row > cury: ans += \\'D\\'*(row-cury)\\n            if cury > row: ans += \\'U\\'*(cury-row)    \\n            if col > curx: ans += \\'R\\'*(col-curx)\\n            \\n            ans += \\'!\\'\\n            curx, cury = col, row\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090457,
                "title": "javascript-o-n-time-elegant-solution",
                "content": "Time: `O(N)`, `N` = size of `target`\\nSpace: `O(26)` technically `O(1)`\\n```javascript\\nvar alphabetBoardPath = function(target) {\\n    const board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n    const coordinate = new Map();\\n    \\n    for(let r = 0; r < board.length; r++) {\\n        for(let c = 0; c < board[r].length; c++) {\\n            coordinate.set(board[r][c], [r, c]);\\n        }\\n    }\\n    \\n    let r = 0, c = 0;\\n    let output = \\'\\';\\n    \\n    for(let char of target) {\\n        const [r1, c1] = coordinate.get(char);\\n        \\n        if(c > c1) output += \\'L\\'.repeat(c - c1);\\n        if(r > r1) output += \\'U\\'.repeat(r - r1);\\n        if(c < c1) output += \\'R\\'.repeat(c1 - c);\\n        if(r < r1) output += \\'D\\'.repeat(r1 - r);\\n        output += \\'!\\'\\n        r = r1;\\n        c = c1;\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar alphabetBoardPath = function(target) {\\n    const board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n    const coordinate = new Map();\\n    \\n    for(let r = 0; r < board.length; r++) {\\n        for(let c = 0; c < board[r].length; c++) {\\n            coordinate.set(board[r][c], [r, c]);\\n        }\\n    }\\n    \\n    let r = 0, c = 0;\\n    let output = \\'\\';\\n    \\n    for(let char of target) {\\n        const [r1, c1] = coordinate.get(char);\\n        \\n        if(c > c1) output += \\'L\\'.repeat(c - c1);\\n        if(r > r1) output += \\'U\\'.repeat(r - r1);\\n        if(c < c1) output += \\'R\\'.repeat(c1 - c);\\n        if(r < r1) output += \\'D\\'.repeat(r1 - r);\\n        output += \\'!\\'\\n        r = r1;\\n        c = c1;\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3119821,
                "title": "bfs-is-pretty-slow-c-common-template-used-to-travel-in-bfs",
                "content": "**Here is a Common Template used for BFS when you want to travel in 4 directions** \\n```\\nstring move = \"ULDR\";\\nint dx[4] = {-1, 0, 1, 0};\\nint dy[4] = {0, -1, 0, 1};\\nbool isValidDirection(int x, int y, int n, int m){\\n    return  (x >= 0 && y >= 0 && x < n && y < m);\\n}\\n```\\n> Using BFS in this question is not a optimal choice but it is possible\\n> BFS gives the shortest path as it traverse level-wise\\n---\\n> First Store the board in a vector of string or 2D vector\\n> Call BFS for every charater in target string for the shortest path\\n> We need a visited array for every BFS call because we need to travel the matrix / grid multiple times\\n> Make a queue of current location...i.e (x, y) and current path string\\n> If we find the target char then update the values of (x,y) with current location and add the path string to total path string\\n---\\n**We know how to traverse in 4 directions... after checking the validity of move and that it is not visited\\nadd that move to the string and push it to the queue\\nafter that we need to pop the last inserted move \\nWHY... because we are on same level and some other moves can still be performed so that the original path change we need to pop the last char at same level** \\n\\n\\n# C++ CODE\\n\\n```\\nclass Solution {\\nstruct val{\\n    int x, y;\\n    string s;\\n};\\nprivate:\\n    string move = \"ULDR\";\\n    int dx[4] = {-1, 0, 1, 0};\\n    int dy[4] = {0, -1, 0, 1};\\n    bool isValidDirection(int X, int Y, int n, int m){\\n        return  (X >= 0 && Y >= 0 && X < n && Y < m);\\n    }\\npublic:\\n    void bfs(char &ch,int &x, int &y, vector<vector<char>> &key, string &res){\\n        vector<vector<bool>> vis(6, vector<bool>(5, 0));\\n        queue<val> q1;\\n        q1.push({x, y, \"\"});\\n        vis[x][y] = 1;\\n\\n        while(!q1.empty()){\\n            int X = q1.front().x;\\n            int Y = q1.front().y;\\n            string S = q1.front().s;\\n            q1.pop();\\n\\n            if(key[X][Y]==ch){\\n                S += \\'!\\';\\n                res += S, x = X, y = Y;\\n                return;\\n            }\\n\\n            for(int i = 0; i < 4; i++){\\n                int XD = dx[i] + X;\\n                int YD = dy[i] + Y;\\n                if(isValidDirection(XD, YD, 6, 5) and !vis[XD][YD] and key[XD][YD]!=\\'#\\'){\\n                    vis[XD][YD] = 1;\\n                    S += move[i];\\n                    q1.push({XD,YD,S});\\n                    S.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    string alphabetBoardPath(string &target) {\\n        string res = \"\";\\n        int x = 0, y = 0;\\n        vector<vector<char>> key = {\\n            {\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n            {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n            {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n            {\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n            {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n            {\\'z\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}   };\\n        for(char &ch: target){\\n            bfs(ch, x, y, key, res);\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Any optimization in this approach is appreciated",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nstring move = \"ULDR\";\\nint dx[4] = {-1, 0, 1, 0};\\nint dy[4] = {0, -1, 0, 1};\\nbool isValidDirection(int x, int y, int n, int m){\\n    return  (x >= 0 && y >= 0 && x < n && y < m);\\n}\\n```\n```\\nclass Solution {\\nstruct val{\\n    int x, y;\\n    string s;\\n};\\nprivate:\\n    string move = \"ULDR\";\\n    int dx[4] = {-1, 0, 1, 0};\\n    int dy[4] = {0, -1, 0, 1};\\n    bool isValidDirection(int X, int Y, int n, int m){\\n        return  (X >= 0 && Y >= 0 && X < n && Y < m);\\n    }\\npublic:\\n    void bfs(char &ch,int &x, int &y, vector<vector<char>> &key, string &res){\\n        vector<vector<bool>> vis(6, vector<bool>(5, 0));\\n        queue<val> q1;\\n        q1.push({x, y, \"\"});\\n        vis[x][y] = 1;\\n\\n        while(!q1.empty()){\\n            int X = q1.front().x;\\n            int Y = q1.front().y;\\n            string S = q1.front().s;\\n            q1.pop();\\n\\n            if(key[X][Y]==ch){\\n                S += \\'!\\';\\n                res += S, x = X, y = Y;\\n                return;\\n            }\\n\\n            for(int i = 0; i < 4; i++){\\n                int XD = dx[i] + X;\\n                int YD = dy[i] + Y;\\n                if(isValidDirection(XD, YD, 6, 5) and !vis[XD][YD] and key[XD][YD]!=\\'#\\'){\\n                    vis[XD][YD] = 1;\\n                    S += move[i];\\n                    q1.push({XD,YD,S});\\n                    S.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    string alphabetBoardPath(string &target) {\\n        string res = \"\";\\n        int x = 0, y = 0;\\n        vector<vector<char>> key = {\\n            {\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n            {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n            {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n            {\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n            {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n            {\\'z\\', \\'#\\', \\'#\\', \\'#\\', \\'#\\'}   };\\n        for(char &ch: target){\\n            bfs(ch, x, y, key, res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077310,
                "title": "c-simple-beats-100",
                "content": "If we are in last row, then we should first move up before moving left/right, otherwise, first adjust left/right then do up/down .\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int cur = 0;\\n        string ans = \"\";\\n        for(int i=0; i<target.size(); ++i) {\\n            int index = target[i] - \\'a\\';\\n            if (index == cur) {\\n                ans += \\'!\\';\\n                continue;\\n            } \\n\\n           \\n            int r = cur/5;\\n            int c = cur%5;\\n\\t\\t\\tint r_new = index/5;\\n            int c_new = index %5;\\n            \\n            if (r == 5) {                \\n                ans.append(abs(r_new-r), r_new < r ? \\'U\\' : \\'D\\');\\n                ans.append(abs(c_new-c), c_new < c ? \\'L\\' : \\'R\\');\\n            } else {\\n                ans.append(abs(c_new-c), c_new < c ? \\'L\\' : \\'R\\');\\n                ans.append(abs(r_new-r), r_new < r ? \\'U\\' : \\'D\\');\\n            }            \\n            ans += \\'!\\';\\n            cur = index;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int cur = 0;\\n        string ans = \"\";\\n        for(int i=0; i<target.size(); ++i) {\\n            int index = target[i] - \\'a\\';\\n            if (index == cur) {\\n                ans += \\'!\\';\\n                continue;\\n            } \\n\\n           \\n            int r = cur/5;\\n            int c = cur%5;\\n\\t\\t\\tint r_new = index/5;\\n            int c_new = index %5;\\n            \\n            if (r == 5) {                \\n                ans.append(abs(r_new-r), r_new < r ? \\'U\\' : \\'D\\');\\n                ans.append(abs(c_new-c), c_new < c ? \\'L\\' : \\'R\\');\\n            } else {\\n                ans.append(abs(c_new-c), c_new < c ? \\'L\\' : \\'R\\');\\n                ans.append(abs(r_new-r), r_new < r ? \\'U\\' : \\'D\\');\\n            }            \\n            ans += \\'!\\';\\n            cur = index;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801072,
                "title": "python-clean-and-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        position = {}\\n        \\n        for r in range(6):\\n            for c in range(len(board[r])):\\n                position[board[r][c]] = (r, c)\\n        \\n        ans = \\'\\'\\n        \\n        x, y = 0, 0\\n        \\n        for char in target:\\n            dx, dy = position[char]\\n            ups = max(0, x - dx)\\n            rights = max(0, dy - y)\\n            lefts = max(0, y - dy)\\n            downs = max(0, dx - x)\\n            ans += \\'U\\' * ups + \\'L\\' * lefts + \\'R\\' * rights + \\'D\\' * downs + \\'!\\'\\n            x, y = dx, dy\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        position = {}\\n        \\n        for r in range(6):\\n            for c in range(len(board[r])):\\n                position[board[r][c]] = (r, c)\\n        \\n        ans = \\'\\'\\n        \\n        x, y = 0, 0\\n        \\n        for char in target:\\n            dx, dy = position[char]\\n            ups = max(0, x - dx)\\n            rights = max(0, dy - y)\\n            lefts = max(0, y - dy)\\n            downs = max(0, dx - x)\\n            ans += \\'U\\' * ups + \\'L\\' * lefts + \\'R\\' * rights + \\'D\\' * downs + \\'!\\'\\n            x, y = dx, dy\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362797,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\tstring alphabetBoardPath(string target) \\n    {\\n\\t\\tstring ans;\\n\\t\\tint x = 0, y = 0;\\n\\t\\tfor (auto ch : target) \\n        {\\n\\t\\t\\tint x1 = (ch - \\'a\\') % 5 , y1 = (ch - \\'a\\') / 5;\\n\\t\\t\\tans += string(max(0, y - y1), \\'U\\') + string(max(0, x - x1), \\'L\\') + string(max(0, y1 - y), \\'D\\') + string(max(0, x1 - x), \\'R\\') + \"!\";\\n\\t\\t\\tx = x1, y = y1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring alphabetBoardPath(string target) \\n    {\\n\\t\\tstring ans;\\n\\t\\tint x = 0, y = 0;\\n\\t\\tfor (auto ch : target) \\n        {\\n\\t\\t\\tint x1 = (ch - \\'a\\') % 5 , y1 = (ch - \\'a\\') / 5;\\n\\t\\t\\tans += string(max(0, y - y1), \\'U\\') + string(max(0, x - x1), \\'L\\') + string(max(0, y1 - y), \\'D\\') + string(max(0, x1 - x), \\'R\\') + \"!\";\\n\\t\\t\\tx = x1, y = y1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969212,
                "title": "python-7-lines-w-comments-t-m-95-99",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n       \\n        rTrgt, cTrgt, ans = 0, 0, \\'\\'                        # <-- initialize some stuff\\n        f = lambda x: (abs(x)+x)//2                         # <-- f returns the appropriate coefficient for\\n                                                            #     computing the path for each target element\\n      \\n        for ch in target:\\n            rCurr, cCurr = rTrgt, cTrgt                     # <-- update current position on board\\n            rTrgt, cTrgt = divmod(ord(ch)-97, 5)            # <-- determine the 2D coordinates for target\\n                                \\n\\n            r, c = rTrgt - rCurr, cTrgt - cCurr             # <-- row, col displacements when moving from \\n                                                            #     current to target\\n\\n            ans+= f(-r)*\"U\"+f(-c)*\"L\"+f(c)*\\'R\\'+f(r)*\\'D\\'+\"!\" # <-- increments ans with directions to the target\\n```\\n[https://leetcode.com/submissions/detail/837045447/](http://)\\n\\nI could be wrong, but I think it\\'s *O*(*n*) / *O*(*n*)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n       \\n        rTrgt, cTrgt, ans = 0, 0, \\'\\'                        # <-- initialize some stuff\\n        f = lambda x: (abs(x)+x)//2                         # <-- f returns the appropriate coefficient for\\n                                                            #     computing the path for each target element\\n      \\n        for ch in target:\\n            rCurr, cCurr = rTrgt, cTrgt                     # <-- update current position on board\\n            rTrgt, cTrgt = divmod(ord(ch)-97, 5)            # <-- determine the 2D coordinates for target\\n                                \\n\\n            r, c = rTrgt - rCurr, cTrgt - cCurr             # <-- row, col displacements when moving from \\n                                                            #     current to target\\n\\n            ans+= f(-r)*\"U\"+f(-c)*\"L\"+f(c)*\\'R\\'+f(r)*\\'D\\'+\"!\" # <-- increments ans with directions to the target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977228,
                "title": "c-solution",
                "content": "The trick is \\'z\\', so we have to move left before down, move up before right, to avoid out of the boundary because of \\'z\\'.\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string res;\\n        //for letter ?, the row index is (?-\\'a\\') / 5, the row index is (?- \\'a\\') % 5.\\n        int row1 = 0, col1 = 0;\\n        for(int i = 0; i < target.size(); i++){\\n            int row2 = (target[i] - \\'a\\') / 5;\\n            int col2 = (target[i] - \\'a\\') % 5;\\n            \\n            if(col2 < col1){  \\n                 res.append(string(col1 - col2, \\'L\\'));\\n            }\\n            if(row2 > row1){                \\n                 res.append(string(row2 - row1, \\'D\\'));\\n            }\\n            if(row2 < row1){  \\n                 res.append(string (row1 - row2, \\'U\\'));\\n            }\\n            if(col2 > col1){   \\n                 res.append(string (col2 - col1, \\'R\\'));\\n            }                        \\n            res.push_back(\\'!\\');\\n            row1 = row2;\\n            col1 = col2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string res;\\n        //for letter ?, the row index is (?-\\'a\\') / 5, the row index is (?- \\'a\\') % 5.\\n        int row1 = 0, col1 = 0;\\n        for(int i = 0; i < target.size(); i++){\\n            int row2 = (target[i] - \\'a\\') / 5;\\n            int col2 = (target[i] - \\'a\\') % 5;\\n            \\n            if(col2 < col1){  \\n                 res.append(string(col1 - col2, \\'L\\'));\\n            }\\n            if(row2 > row1){                \\n                 res.append(string(row2 - row1, \\'D\\'));\\n            }\\n            if(row2 < row1){  \\n                 res.append(string (row1 - row2, \\'U\\'));\\n            }\\n            if(col2 > col1){   \\n                 res.append(string (col2 - col1, \\'R\\'));\\n            }                        \\n            res.push_back(\\'!\\');\\n            row1 = row2;\\n            col1 = col2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345227,
                "title": "java-solution-simple-straightforward-o-1-space-o-n-time",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder ans = new StringBuilder();\\n        int x = 0, y = 0;\\n        for (char c : target.toCharArray()) {\\n            int i = ((int)c - 97)/5;\\n            int j = ((int)c - 97)%5;\\n            if(i > x) {\\n                while(x != i) {                                      \\n                    if(x == 4 && y > 0 )\\n                        break;                    \\n                    ans.append(\"D\");  \\n                    x++;\\n                }\\n            } else {\\n                while (x != i) {\\n                    ans.append(\"U\");\\n                    x--;\\n                }\\n            }\\n            if(j > y) {\\n                while(y != j) {\\n                    ans.append(\"R\");\\n                    y++;\\n                }\\n            } else {\\n                while(y != j) {\\n                    ans.append(\"L\");\\n                    y--;\\n                }\\n            }\\n            if(x != i) {\\n                ans.append(\"D\");\\n                x++;\\n            }\\n            ans.append(\"!\");\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder ans = new StringBuilder();\\n        int x = 0, y = 0;\\n        for (char c : target.toCharArray()) {\\n            int i = ((int)c - 97)/5;\\n            int j = ((int)c - 97)%5;\\n            if(i > x) {\\n                while(x != i) {                                      \\n                    if(x == 4 && y > 0 )\\n                        break;                    \\n                    ans.append(\"D\");  \\n                    x++;\\n                }\\n            } else {\\n                while (x != i) {\\n                    ans.append(\"U\");\\n                    x--;\\n                }\\n            }\\n            if(j > y) {\\n                while(y != j) {\\n                    ans.append(\"R\");\\n                    y++;\\n                }\\n            } else {\\n                while(y != j) {\\n                    ans.append(\"L\");\\n                    y--;\\n                }\\n            }\\n            if(x != i) {\\n                ans.append(\"D\");\\n                x++;\\n            }\\n            ans.append(\"!\");\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120261,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943285,
                "title": "java-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int[] current = {0,0};\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : target.toCharArray()) {\\n            int row = (c - \\'a\\') / 5;\\n            int col = (c - \\'a\\') % 5;\\n            \\n            int xDiff = current[0] - row;\\n            int yDiff = current[1] - col;\\n            \\n            while(yDiff > 0) {\\n                sb.append(\"L\");\\n                yDiff--;\\n            }\\n            while(xDiff > 0) {\\n                sb.append(\"U\");\\n                xDiff--;\\n            }\\n            \\n            while(yDiff < 0) {\\n                sb.append(\"R\");\\n                yDiff++;\\n            }\\n            while(xDiff < 0) {\\n                sb.append(\"D\");\\n                xDiff++;\\n            }\\n            \\n            if(xDiff == 0 && yDiff == 0) {\\n                sb.append(\"!\");\\n            }\\n            \\n            current = new int[] {row, col};\\n        }\\n        \\n       \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int[] current = {0,0};\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : target.toCharArray()) {\\n            int row = (c - \\'a\\') / 5;\\n            int col = (c - \\'a\\') % 5;\\n            \\n            int xDiff = current[0] - row;\\n            int yDiff = current[1] - col;\\n            \\n            while(yDiff > 0) {\\n                sb.append(\"L\");\\n                yDiff--;\\n            }\\n            while(xDiff > 0) {\\n                sb.append(\"U\");\\n                xDiff--;\\n            }\\n            \\n            while(yDiff < 0) {\\n                sb.append(\"R\");\\n                yDiff++;\\n            }\\n            while(xDiff < 0) {\\n                sb.append(\"D\");\\n                xDiff++;\\n            }\\n            \\n            if(xDiff == 0 && yDiff == 0) {\\n                sb.append(\"!\");\\n            }\\n            \\n            current = new int[] {row, col};\\n        }\\n        \\n       \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841418,
                "title": "java-solution",
                "content": "```\\n public String alphabetBoardPath(String target) {\\n    int x_From = 0,y_From = 0;\\n        StringBuilder res = new StringBuilder();\\n        // U -> R -> L -> D\\n        //this is to account for Z traversal\\n        for(char c : target.toCharArray()){\\n            //Remainder of char value when divided by five is xPos\\n            //Quotient is yPos\\n            \\n            int x_To = (c - \\'a\\')%5 ;\\n            int y_To = (c - \\'a\\')/5;\\n            //caluculate distance of target from start\\n            int U_Path = Math.max(0,(y_From - y_To));\\n            int D_Path = Math.max(0,(y_To - y_From));\\n            int R_Path = Math.max(0,(x_To - x_From));\\n            int L_Path = Math.max(0,(x_From - x_To));\\n            \\n            //append Directions to the list\\n            while(U_Path>0){res.append(\"U\");U_Path--;}\\n            while(R_Path>0){res.append(\"R\");R_Path--;}\\n            while(L_Path>0){res.append(\"L\");;L_Path--;}\\n            while(D_Path>0){res.append(\"D\");D_Path--;}\\n            \\n            //add ! because we reached our target\\n            res.append(\"\").append(\"!\");\\n            \\n            //make current pos as start\\n            x_From = x_To;\\n            y_From = y_To;\\n        }\\n        return res.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public String alphabetBoardPath(String target) {\\n    int x_From = 0,y_From = 0;\\n        StringBuilder res = new StringBuilder();\\n        // U -> R -> L -> D\\n        //this is to account for Z traversal\\n        for(char c : target.toCharArray()){\\n            //Remainder of char value when divided by five is xPos\\n            //Quotient is yPos\\n            \\n            int x_To = (c - \\'a\\')%5 ;\\n            int y_To = (c - \\'a\\')/5;\\n            //caluculate distance of target from start\\n            int U_Path = Math.max(0,(y_From - y_To));\\n            int D_Path = Math.max(0,(y_To - y_From));\\n            int R_Path = Math.max(0,(x_To - x_From));\\n            int L_Path = Math.max(0,(x_From - x_To));\\n            \\n            //append Directions to the list\\n            while(U_Path>0){res.append(\"U\");U_Path--;}\\n            while(R_Path>0){res.append(\"R\");R_Path--;}\\n            while(L_Path>0){res.append(\"L\");;L_Path--;}\\n            while(D_Path>0){res.append(\"D\");D_Path--;}\\n            \\n            //add ! because we reached our target\\n            res.append(\"\").append(\"!\");\\n            \\n            //make current pos as start\\n            x_From = x_To;\\n            y_From = y_To;\\n        }\\n        return res.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 815122,
                "title": "python-simplest-easy-to-understand-solution-100-faster",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        curr = [0, 0]\\n        res = \"\"\\n        for letter in target:\\n            # find position of letter in board:\\n            ind = ord(letter) - ord(\\'a\\')\\n            next_pos = [ind//5, ind % 5]\\n\\n            while curr != next_pos:\\n                \\n                # go to next_pos column:\\n                while curr[1] != next_pos[1]:\\n                    if curr[1] < next_pos[1]:\\n                        if curr[0] == 5:\\n                            break\\n                        res += \"R\"\\n                        curr[1]+=1\\n                    elif curr[1] > next_pos[1]:\\n                        res += \"L\"\\n                        curr[1]-=1\\n                    \\n                # go to next_pos row:\\n                while curr[0] != next_pos[0]:\\n                    if curr[0] < next_pos[0]:\\n                        if curr[0] == 4 and curr[1] != 0:\\n                            break\\n                        res += \"D\"\\n                        curr[0]+=1\\n                    elif curr[0] > next_pos[0]:\\n                        res += \"U\"\\n                        curr[0]-=1\\n                    \\n            if curr == next_pos:\\n                res += \"!\"\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        curr = [0, 0]\\n        res = \"\"\\n        for letter in target:\\n            # find position of letter in board:\\n            ind = ord(letter) - ord(\\'a\\')\\n            next_pos = [ind//5, ind % 5]\\n\\n            while curr != next_pos:\\n                \\n                # go to next_pos column:\\n                while curr[1] != next_pos[1]:\\n                    if curr[1] < next_pos[1]:\\n                        if curr[0] == 5:\\n                            break\\n                        res += \"R\"\\n                        curr[1]+=1\\n                    elif curr[1] > next_pos[1]:\\n                        res += \"L\"\\n                        curr[1]-=1\\n                    \\n                # go to next_pos row:\\n                while curr[0] != next_pos[0]:\\n                    if curr[0] < next_pos[0]:\\n                        if curr[0] == 4 and curr[1] != 0:\\n                            break\\n                        res += \"D\"\\n                        curr[0]+=1\\n                    elif curr[0] > next_pos[0]:\\n                        res += \"U\"\\n                        curr[0]-=1\\n                    \\n            if curr == next_pos:\\n                res += \"!\"\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440899,
                "title": "c-easy-solution-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n\\tstring alphabetBoardPath(string target) {\\n\\t\\tstring ans;\\n\\t\\tint x = 0, y = 0;\\n\\t\\tfor (auto ch : target) {\\n\\t\\t\\tint x1 = (ch - \\'a\\') % 5 , y1 = (ch - \\'a\\') / 5;\\n\\t\\t\\tans += string(max(0, y - y1), \\'U\\') + string(max(0, x - x1), \\'L\\') + string(max(0, y1 - y), \\'D\\') + string(max(0, x1 - x), \\'R\\') + \"!\";\\n\\t\\t\\tx = x1, y = y1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tstring alphabetBoardPath(string target) {\\n\\t\\tstring ans;\\n\\t\\tint x = 0, y = 0;\\n\\t\\tfor (auto ch : target) {\\n\\t\\t\\tint x1 = (ch - \\'a\\') % 5 , y1 = (ch - \\'a\\') / 5;\\n\\t\\t\\tans += string(max(0, y - y1), \\'U\\') + string(max(0, x - x1), \\'L\\') + string(max(0, y1 - y), \\'D\\') + string(max(0, x1 - x), \\'R\\') + \"!\";\\n\\t\\t\\tx = x1, y = y1;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345339,
                "title": "easy-bfs-solution-in-python",
                "content": "Basic idea:\\nUse BFS to find one shortest path for each character one time, and then connect all paths.\\n1) Stand at index (x, y) first, initially it\\'s (0, 0)\\n2) Then did BFS to find targeted character, record the shortest path\\n3) update x, y \\n\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        board = [\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z0000\"] # fill \"0\" in blank\\n        res = []\\n        x0, y0 = 0, 0\\n        for s in target: #each time, find shorest path for one char\\n                x, y, path = self.bfs(board, x0, y0, s)\\n                x0, y0 = x, y # update intial index\\n                res.append(path)\\n        return \"\".join(res)\\n                \\n        \\n    # Input: initial index (indx, idy), one char (goal this time)\\n    # Output: index and path for the goal char\\n    def bfs(self, board, idx, idy, goal):\\n        m, n = len(board), len(board[0])\\n        queue = collections.deque([(idx, idy,\"\")])\\n        visited = set() # array will TLE\\n        dirt = {\\'U\\':(-1, 0),\"D\":(1,0),\"L\":(0, -1),\"R\":(0, 1)}\\n        while queue:\\n                a, b, path = queue.popleft()\\n                visited.add(path)\\n                if board[a][b] == goal:\\n                        return (a, b, path+\"!\") #return path and index\\n                for sign in dirt:\\n                        i, j = a + dirt[sign][0], b + dirt[sign][1]\\n                        if 0<=i<m and 0<=j<n and board[i][j]!=\"0\" and path+sign not in visited:\\n                                queue.append((i, j, path+sign))\\n        return -1\\n```\\n\\n61 / 61 test cases passed.\\nStatus: Accepted\\nRuntime: 708 ms\\nMemory Usage: 20.4 MB",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        board = [\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z0000\"] # fill \"0\" in blank\\n        res = []\\n        x0, y0 = 0, 0\\n        for s in target: #each time, find shorest path for one char\\n                x, y, path = self.bfs(board, x0, y0, s)\\n                x0, y0 = x, y # update intial index\\n                res.append(path)\\n        return \"\".join(res)\\n                \\n        \\n    # Input: initial index (indx, idy), one char (goal this time)\\n    # Output: index and path for the goal char\\n    def bfs(self, board, idx, idy, goal):\\n        m, n = len(board), len(board[0])\\n        queue = collections.deque([(idx, idy,\"\")])\\n        visited = set() # array will TLE\\n        dirt = {\\'U\\':(-1, 0),\"D\":(1,0),\"L\":(0, -1),\"R\":(0, 1)}\\n        while queue:\\n                a, b, path = queue.popleft()\\n                visited.add(path)\\n                if board[a][b] == goal:\\n                        return (a, b, path+\"!\") #return path and index\\n                for sign in dirt:\\n                        i, j = a + dirt[sign][0], b + dirt[sign][1]\\n                        if 0<=i<m and 0<=j<n and board[i][j]!=\"0\" and path+sign not in visited:\\n                                queue.append((i, j, path+sign))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345276,
                "title": "easy-solution-binary-search-to-find-each-char",
                "content": "To find the char postion i used binary search \\nDon\\'t forget exception case i.e \\'z\\' \\n```\\n\\n    public static int[] search(char[][] board, char c) {\\n        int x = 0;\\n        int y = board[0].length - 1;\\n        if (c == \\'z\\') return new int[]{5, 0};\\n        while (true) {\\n            if (board[x][y] == c) {\\n                return new int[]{x, y};\\n            }\\n            if (board[x][y] < c) x++;\\n            else y--;\\n        }\\n    }\\n```\\n\\nAfter getting postion i moved my current position char Position\\n\\n```\\n\\n    public static String alphabetBoardPath(String target) {\\n        char[][] board = {\\n\\t\\t\\t\\t{\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n                {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n                {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n\\t\\t\\t\\t{\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n                {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n                {\\'z\\'}\\n\\t\\t\\t\\t};\\n\\n        String res = \"\";\\n        int x = 0, y = 0;\\n        for (char c : target.toCharArray()) {\\n            int[] pos = search(board, c);\\n            boolean isDown = false;\\n            while (pos[0] != x) {\\n                if (pos[0] > x) {\\n                    x++;\\n                    if (x == 5) {\\n                        isDown = true;\\n                        break;\\n                    }\\n                    res += \"D\";\\n                } else {\\n                    x--;\\n                    res += \"U\";\\n                }\\n                isDown = false;\\n            }\\n            while (pos[1] != y) {\\n                if (pos[1] > y) {\\n                    y++;\\n                    res += \"R\";\\n                } else {\\n                    y--;\\n                    res += \"L\";\\n                }\\n            }\\n            if (isDown) res += \"D\";\\n            res += \"!\";\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n\\n    public static int[] search(char[][] board, char c) {\\n        int x = 0;\\n        int y = board[0].length - 1;\\n        if (c == \\'z\\') return new int[]{5, 0};\\n        while (true) {\\n            if (board[x][y] == c) {\\n                return new int[]{x, y};\\n            }\\n            if (board[x][y] < c) x++;\\n            else y--;\\n        }\\n    }\\n```\n```\\n\\n    public static String alphabetBoardPath(String target) {\\n        char[][] board = {\\n\\t\\t\\t\\t{\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n                {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n                {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n\\t\\t\\t\\t{\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n                {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n                {\\'z\\'}\\n\\t\\t\\t\\t};\\n\\n        String res = \"\";\\n        int x = 0, y = 0;\\n        for (char c : target.toCharArray()) {\\n            int[] pos = search(board, c);\\n            boolean isDown = false;\\n            while (pos[0] != x) {\\n                if (pos[0] > x) {\\n                    x++;\\n                    if (x == 5) {\\n                        isDown = true;\\n                        break;\\n                    }\\n                    res += \"D\";\\n                } else {\\n                    x--;\\n                    res += \"U\";\\n                }\\n                isDown = false;\\n            }\\n            while (pos[1] != y) {\\n                if (pos[1] > y) {\\n                    y++;\\n                    res += \"R\";\\n                } else {\\n                    y--;\\n                    res += \"L\";\\n                }\\n            }\\n            if (isDown) res += \"D\";\\n            res += \"!\";\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345269,
                "title": "updated-shorter-code-simple-and-intuitive-c-simulation-beat-100-both-time-and-space",
                "content": "* Approach:\\n\\t* Step1: Map the relation of alphabet -> position\\n\\t* Step2: Traverse the string, and calculate the needed direction, if the previsous position is the same as now, just add !, otherwise, go there and add !\\n\\t\\t* For the tricky z-related test case like \\u2018zdz\\u2019, for entering z, we may first go left and down and for leaving z we may first go up then right to avoid out of board.\\n\\nWA\\n```\\nInput:\\n\"zdz\"\\nOutput:\\n\"DDDDD!UUUUURRR!DDDDDLLL!\"\\nExpected:\\n\"DDDDD!UUUUURRR!DDDDLLLD!\"\\n```\\n\\n* Analysis:\\n\\t* Time complexity: O(len(target)), since the longest path will be e to z and is fixed to a constant, so O(Constant * len(target)) = O(len(target)). **Feel free to correct me if I am wrong**\\n\\t* Space complexity: O(len(target))\\n```cpp\\n#define mp make_pair\\nclass Solution \\n{\\npublic:\\n    string alphabetBoardPath(string tg) \\n    {\\n        vector<string>b = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char, pair<int, int>>m; // char -> (row, col)\\n        \\n        for(int i = 0; i < 6; i++)\\n        {\\n            for(int j = 0; j < b[i].size(); j++)\\n            {\\n                m[b[i][j]] = mp(i, j);\\n            }\\n        }\\n        \\n        pair<int, int> last;\\n        pair<int, int> now;\\n        last = mp(0, 0);\\n        string res;\\n        for(auto s : tg)\\n        {\\n            now = m[s];\\n            int r = now.first, c = now.second;\\n            if(last == now)\\n            {\\n                res += \"!\";\\n            }\\n            else\\n            {\\n                int dr = r - last.first, dc = c - last.second;\\n                int postr = 0;\\n                \\n                for(int i = -1; i >= dr; i--)\\n                {\\n                    res += \"U\";\\n                }\\n                \\n                for(int i = 1; i <= dc; i++)\\n                {\\n                    res += \"R\";\\n                }\\n                \\n                for(int i = -1; i >= dc; i--)\\n                {\\n                    res += \"L\";\\n                }\\n                \\n                for(int i = 1; i <= dr; i++)\\n                {\\n                    res += \"D\";\\n                }\\n                res += \"!\";\\n            }\\n            last = now;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nInput:\\n\"zdz\"\\nOutput:\\n\"DDDDD!UUUUURRR!DDDDDLLL!\"\\nExpected:\\n\"DDDDD!UUUUURRR!DDDDLLLD!\"\\n```\n```cpp\\n#define mp make_pair\\nclass Solution \\n{\\npublic:\\n    string alphabetBoardPath(string tg) \\n    {\\n        vector<string>b = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char, pair<int, int>>m; // char -> (row, col)\\n        \\n        for(int i = 0; i < 6; i++)\\n        {\\n            for(int j = 0; j < b[i].size(); j++)\\n            {\\n                m[b[i][j]] = mp(i, j);\\n            }\\n        }\\n        \\n        pair<int, int> last;\\n        pair<int, int> now;\\n        last = mp(0, 0);\\n        string res;\\n        for(auto s : tg)\\n        {\\n            now = m[s];\\n            int r = now.first, c = now.second;\\n            if(last == now)\\n            {\\n                res += \"!\";\\n            }\\n            else\\n            {\\n                int dr = r - last.first, dc = c - last.second;\\n                int postr = 0;\\n                \\n                for(int i = -1; i >= dr; i--)\\n                {\\n                    res += \"U\";\\n                }\\n                \\n                for(int i = 1; i <= dc; i++)\\n                {\\n                    res += \"R\";\\n                }\\n                \\n                for(int i = -1; i >= dc; i--)\\n                {\\n                    res += \"L\";\\n                }\\n                \\n                for(int i = 1; i <= dr; i++)\\n                {\\n                    res += \"D\";\\n                }\\n                res += \"!\";\\n            }\\n            last = now;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551694,
                "title": "python-elegant-short-o-n-1-pass",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    MAPPING = {\\n        ltr: (i // 5, i % 5)\\n        for i, ltr in enumerate(ascii_lowercase)\\n    }\\n\\n    def alphabetBoardPath(self, target: str) -> str:\\n        x, y = 0, 0\\n        path = \\'\\'\\n\\n        for c in target:\\n            n_x, n_y = self.MAPPING[c]\\n\\n            if n_y < y:\\n                path += \\'L\\' * (y - n_y)\\n            if n_x < x:\\n                path += \\'U\\' * (x - n_x)\\n            if n_x > x:\\n                path += \\'D\\' * (n_x - x)\\n            if n_y > y:\\n                path += \\'R\\' * (n_y - y)\\n\\n            path += \\'!\\'\\n            x, y = n_x, n_y\\n\\n        return path\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    MAPPING = {\\n        ltr: (i // 5, i % 5)\\n        for i, ltr in enumerate(ascii_lowercase)\\n    }\\n\\n    def alphabetBoardPath(self, target: str) -> str:\\n        x, y = 0, 0\\n        path = \\'\\'\\n\\n        for c in target:\\n            n_x, n_y = self.MAPPING[c]\\n\\n            if n_y < y:\\n                path += \\'L\\' * (y - n_y)\\n            if n_x < x:\\n                path += \\'U\\' * (x - n_x)\\n            if n_x > x:\\n                path += \\'D\\' * (n_x - x)\\n            if n_y > y:\\n                path += \\'R\\' * (n_y - y)\\n\\n            path += \\'!\\'\\n            x, y = n_x, n_y\\n\\n        return path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375094,
                "title": "0ms-100-faster-easy-soln",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<string> b;\\n    string alphabetBoardPath(string t) {\\n        b.push_back(\"abcde\");\\n        b.push_back(\"fghij\");\\n        b.push_back(\"klmno\");\\n        b.push_back(\"pqrst\");\\n        b.push_back(\"uvwxy\");\\n        b.push_back(\"z\");\\n        string v;\\n        int i=0,j=0;\\n        for(int x=0;x<t.size();x++)\\n        {\\n            while((t[x]-\\'a\\')!=(b[i][j]-\\'a\\'))\\n            {\\n                if((t[x]-\\'a\\')>(b[i][j]-\\'a\\'))\\n            { \\n                                \\n                if((t[x]==\\'z\\')&&((b[i][j]-\\'a\\')/5==4)&&((b[i][j]-\\'a\\')%5)!=0) \\n                {  \\n                    j--;\\n                    v.push_back(\\'L\\');\\n                }   \\n                \\n                else if((t[x]-\\'a\\')/5==(b[i][j]-\\'a\\')/5)\\n                {\\n                    j++;\\n                    v.push_back(\\'R\\');\\n                }\\n                else\\n                {\\n                    i++;\\n                    v.push_back(\\'D\\');\\n                }\\n            }\\n            else if((t[x]-\\'a\\')<(b[i][j]-\\'a\\'))\\n            {\\n                if((t[x]-\\'a\\')/5==(b[i][j]-\\'a\\')/5)\\n                {\\n                    j--;\\n                    v.push_back(\\'L\\');\\n                }\\n                else\\n                {\\n                    i--;\\n                    v.push_back(\\'U\\');\\n                }\\n            }\\n            }\\n            v.push_back(\\'!\\');\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> b;\\n    string alphabetBoardPath(string t) {\\n        b.push_back(\"abcde\");\\n        b.push_back(\"fghij\");\\n        b.push_back(\"klmno\");\\n        b.push_back(\"pqrst\");\\n        b.push_back(\"uvwxy\");\\n        b.push_back(\"z\");\\n        string v;\\n        int i=0,j=0;\\n        for(int x=0;x<t.size();x++)\\n        {\\n            while((t[x]-\\'a\\')!=(b[i][j]-\\'a\\'))\\n            {\\n                if((t[x]-\\'a\\')>(b[i][j]-\\'a\\'))\\n            { \\n                                \\n                if((t[x]==\\'z\\')&&((b[i][j]-\\'a\\')/5==4)&&((b[i][j]-\\'a\\')%5)!=0) \\n                {  \\n                    j--;\\n                    v.push_back(\\'L\\');\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1690297,
                "title": "simple-and-short-python-solution-faster-than-97",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        output = \"\" \\n        a,b = 0,0 # current position \\n        for char in target: \\n            i = ord(char) - ord(\"a\")\\n            c = i // 5; d = i % 5 # target position \\n            x = a-c; y = b-d # distance in the up-down and left-right position  \\n            output += max(x,0)*\"U\"+max(y,0)*\"L\"+max(-y,0)*\"R\"+max(-x,0)*\"D\"+\"!\"\\n            a,b = c,d  \\n        return output \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        output = \"\" \\n        a,b = 0,0 # current position \\n        for char in target: \\n            i = ord(char) - ord(\"a\")\\n            c = i // 5; d = i % 5 # target position \\n            x = a-c; y = b-d # distance in the up-down and left-right position  \\n            output += max(x,0)*\"U\"+max(y,0)*\"L\"+max(-y,0)*\"R\"+max(-x,0)*\"D\"+\"!\"\\n            a,b = c,d  \\n        return output \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482353,
                "title": "python3-quick-simple",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        d = {\\'a\\': (0, 0), \\'b\\': (0, 1), \\'c\\': (0, 2), \\'d\\': (0, 3), \\'e\\': (0, 4), \\'f\\': (1, 0), \\'g\\': (1, 1), \\'h\\': (1, 2), \\'i\\': (1, 3), \\'j\\': (1, 4), \\'k\\': (2, 0), \\'l\\': (2, 1), \\'m\\': (2, 2), \\'n\\': (2, 3), \\'o\\': (2, 4), \\'p\\': (3, 0), \\'q\\': (3, 1), \\'r\\': (3, 2), \\'s\\': (3, 3), \\'t\\': (3, 4), \\'u\\': (4, 0), \\'v\\': (4, 1), \\'w\\': (4, 2), \\'x\\': (4, 3), \\'y\\': (4, 4), \\'z\\': (5, 0)}\\n\\n        cur_idx = (0,0)\\n        ret = \\'\\'\\n        for c in target:\\n            go_to_idx = d[c]\\n            \\n            x = go_to_idx[0] - cur_idx[0]\\n            y = go_to_idx[1] - cur_idx[1]\\n            \\n            if c == \\'z\\':\\n                if y > 0: ret += y*\\'R\\'\\n                elif y < 0: ret += -y*\\'L\\'\\n\\n                if x > 0: ret += x*\\'D\\'\\n                elif x < 0: ret += -x*\\'U\\'\\n            else:\\n                if x > 0: ret += x*\\'D\\'\\n                elif x < 0: ret += -x*\\'U\\'\\n                    \\n                if y > 0: ret += y*\\'R\\'\\n                elif y < 0: ret += -y*\\'L\\'\\n            \\n        \\n            ret += \\'!\\'\\n            \\n            cur_idx = go_to_idx\\n        \\n        return ret",
                "solutionTags": [],
                "code": "class Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        d = {\\'a\\': (0, 0), \\'b\\': (0, 1), \\'c\\': (0, 2), \\'d\\': (0, 3), \\'e\\': (0, 4), \\'f\\': (1, 0), \\'g\\': (1, 1), \\'h\\': (1, 2), \\'i\\': (1, 3), \\'j\\': (1, 4), \\'k\\': (2, 0), \\'l\\': (2, 1), \\'m\\': (2, 2), \\'n\\': (2, 3), \\'o\\': (2, 4), \\'p\\': (3, 0), \\'q\\': (3, 1), \\'r\\': (3, 2), \\'s\\': (3, 3), \\'t\\': (3, 4), \\'u\\': (4, 0), \\'v\\': (4, 1), \\'w\\': (4, 2), \\'x\\': (4, 3), \\'y\\': (4, 4), \\'z\\': (5, 0)}",
                "codeTag": "Java"
            },
            {
                "id": 916541,
                "title": "java-o-n",
                "content": "\\tpublic String alphabetBoardPath(String target) {\\n        \\n\\t\\t// first character \\'a\\' index\\'s\\n        int fromRowIndex = 0, fromColIndex = 0;\\n        StringBuilder res = new StringBuilder();\\n        \\n        for (int i=0;i<target.length();i++) {\\n            \\n\\t\\t\\t// find the x and y coordinate of the destination character using the dist \\n            int dist = target.charAt(i) - \\'a\\';\\n            int toRowIndex = dist / 5, toColIndex = dist % 5;\\n            \\n\\t\\t\\t// if from char position and to char position is same \\n            if ((fromRowIndex == toRowIndex) && (fromColIndex == toColIndex)) {\\n                res.append(\"!\");\\n            } else {\\n\\t\\t\\t    // calculate the row and col diff between from char position\\n\\t\\t\\t\\t// and to char position\\n                int rowDiff = toRowIndex - fromRowIndex;\\n                int colDiff = toColIndex - fromColIndex;\\n                \\n\\t\\t\\t\\t// Notice that the order L U R D is very important to\\n\\t\\t\\t\\t// take care of the corner case \\'z\\' i.e. either when \\n\\t\\t\\t\\t// from char position is \\'z\\' OR to char position is \\'z\\'\\n                while (colDiff < 0) {res.append(\\'L\\');colDiff++;}\\n                while (rowDiff < 0) {res.append(\\'U\\');rowDiff++;}\\n                while (colDiff > 0) {res.append(\\'R\\');colDiff--;}\\n                while (rowDiff > 0) {res.append(\\'D\\');rowDiff--;}\\n                \\n\\t\\t\\t\\t// Make to char pos the from pos for next iteration\\n                fromRowIndex = toRowIndex;fromColIndex = toColIndex;\\n                res.append(\"!\");\\n            }\\n        }\\n        \\n        return res.toString();\\n    }",
                "solutionTags": [],
                "code": "\\tpublic String alphabetBoardPath(String target) {\\n        \\n\\t\\t// first character \\'a\\' index\\'s\\n        int fromRowIndex = 0, fromColIndex = 0;\\n        StringBuilder res = new StringBuilder();\\n        \\n        for (int i=0;i<target.length();i++) {\\n            \\n\\t\\t\\t// find the x and y coordinate of the destination character using the dist \\n            int dist = target.charAt(i) - \\'a\\';\\n            int toRowIndex = dist / 5, toColIndex = dist % 5;\\n            \\n\\t\\t\\t// if from char position and to char position is same \\n            if ((fromRowIndex == toRowIndex) && (fromColIndex == toColIndex)) {\\n                res.append(\"!\");\\n            } else {\\n\\t\\t\\t    // calculate the row and col diff between from char position\\n\\t\\t\\t\\t// and to char position\\n                int rowDiff = toRowIndex - fromRowIndex;\\n                int colDiff = toColIndex - fromColIndex;\\n                \\n\\t\\t\\t\\t// Notice that the order L U R D is very important to\\n\\t\\t\\t\\t// take care of the corner case \\'z\\' i.e. either when \\n\\t\\t\\t\\t// from char position is \\'z\\' OR to char position is \\'z\\'\\n                while (colDiff < 0) {res.append(\\'L\\');colDiff++;}\\n                while (rowDiff < 0) {res.append(\\'U\\');rowDiff++;}\\n                while (colDiff > 0) {res.append(\\'R\\');colDiff--;}\\n                while (rowDiff > 0) {res.append(\\'D\\');rowDiff--;}\\n                \\n\\t\\t\\t\\t// Make to char pos the from pos for next iteration\\n                fromRowIndex = toRowIndex;fromColIndex = toColIndex;\\n                res.append(\"!\");\\n            }\\n        }\\n        \\n        return res.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 837601,
                "title": "python-3-straight-forward-solution-explanations",
                "content": "### Explanation\\n- Use dictionary to store location of each letter\\n- Numbers of `LRUD`s can be calculated using mahattan distance\\n- Update `prev` for each letter\\n- Watch out for `z` since it\\'s the only char on row 5, meaning you can\\'t travel to its right side, so\\n\\t- from `z` to other letter, do `U` first, then `R`\\n\\t- from other letters to `z`, do `L` first, then `D`\\n### Implementation\\n```\\nclass Solution:\\n    def __init__(self):\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        self.d = {c:(i, j) for i, row in enumerate(board) for j, c in enumerate(row)}\\n                \\n    def alphabetBoardPath(self, target: str) -> str:\\n        ans, prev = \\'\\', (0, 0)\\n        for c in target:\\n            cur = self.d[c]\\n            delta_x, delta_y = cur[0]-prev[0], cur[1]-prev[1]\\n            h = \\'R\\'*delta_y if delta_y > 0 else \\'L\\'*(-delta_y)                    \\n            v = \\'D\\'*delta_x if delta_x > 0 else \\'U\\'*(-delta_x)                    \\n            ans += (h+v if cur == (5,0) else v+h) + \\'!\\'\\n            prev = cur\\n        return ans    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        self.d = {c:(i, j) for i, row in enumerate(board) for j, c in enumerate(row)}\\n                \\n    def alphabetBoardPath(self, target: str) -> str:\\n        ans, prev = \\'\\', (0, 0)\\n        for c in target:\\n            cur = self.d[c]\\n            delta_x, delta_y = cur[0]-prev[0], cur[1]-prev[1]\\n            h = \\'R\\'*delta_y if delta_y > 0 else \\'L\\'*(-delta_y)                    \\n            v = \\'D\\'*delta_x if delta_x > 0 else \\'U\\'*(-delta_x)                    \\n            ans += (h+v if cur == (5,0) else v+h) + \\'!\\'\\n            prev = cur\\n        return ans    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 547052,
                "title": "c-beats-100-space-and-time",
                "content": "```\\nstring alphabetBoardPath(string target) {\\n        vector<string> board = initializer_list<string>{\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z\"};\\n        unordered_map<char,pair<int,int>> hash;\\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[i].size();j++)\\n                hash[board[i][j]]={i,j};\\n        char prev = \\'a\\';\\n        string res = \"\";\\n        for(auto curr: target){\\n            int rowDiff = hash[curr].first - hash[prev].first;\\n            int colDiff = hash[curr].second - hash[prev].second;\\n            char rval=(rowDiff<0)?\\'U\\':\\'D\\';\\n            char cval=(colDiff<0)?\\'L\\':\\'R\\';\\n            vector<int> diff = {rowDiff,colDiff};\\n            vector<char> val  = {rval,cval};\\n            if(curr == \\'z\\'){\\n                diff = {colDiff,rowDiff};\\n                val  = {cval,rval};\\n            }\\n            for(auto e:{0,1})\\n                for(int i=0;i<abs(diff[e]);i++,res+=val[e]);\\n            res+=\"!\";\\n            prev = curr;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring alphabetBoardPath(string target) {\\n        vector<string> board = initializer_list<string>{\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z\"};\\n        unordered_map<char,pair<int,int>> hash;\\n        for(int i=0;i<board.size();i++)\\n            for(int j=0;j<board[i].size();j++)\\n                hash[board[i][j]]={i,j};\\n        char prev = \\'a\\';\\n        string res = \"\";\\n        for(auto curr: target){\\n            int rowDiff = hash[curr].first - hash[prev].first;\\n            int colDiff = hash[curr].second - hash[prev].second;\\n            char rval=(rowDiff<0)?\\'U\\':\\'D\\';\\n            char cval=(colDiff<0)?\\'L\\':\\'R\\';\\n            vector<int> diff = {rowDiff,colDiff};\\n            vector<char> val  = {rval,cval};\\n            if(curr == \\'z\\'){\\n                diff = {colDiff,rowDiff};\\n                val  = {cval,rval};\\n            }\\n            for(auto e:{0,1})\\n                for(int i=0;i<abs(diff[e]);i++,res+=val[e]);\\n            res+=\"!\";\\n            prev = curr;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 545510,
                "title": "clear-python-bfs-solution",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        board = [\\n            [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'],\\n            [\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'],\\n            [\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'],\\n            [\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'],\\n            [\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'],\\n            [\\'z\\',\\'\\',\\'\\',\\'\\',\\'\\']\\n        ] \\n        saved = {}\\n        finalPath = \\'\\'\\n        pos = (0,0)\\n        for letter in target:\\n            if (pos, letter) not in saved:\\n                saved[(pos,letter)] = self.BFS(board, pos, letter)\\n            (pos, path) = saved[(pos,letter)]\\n            finalPath += path + \\'!\\'\\n        return finalPath\\n    \\n    def getNeighbors(self, board, pos):\\n        M, N = len(board), len(board[0])\\n        neighbors = []\\n        for v in [(0,1),(1,0),(-1,0),(0,-1)]:\\n            (r,c) = (pos[0]+v[0],pos[1]+v[1])\\n            if r in range(M) and c in range(N) and board[r][c] != \\'\\':\\n                neighbors.append((r,c))\\n        return neighbors\\n    \\n    def getDirection(self, currPos, nextPos):\\n        table = {(0,1):\\'R\\',(1,0):\\'D\\',(-1,0):\\'U\\',(0,-1):\\'L\\'}\\n        (r0,c0) = currPos\\n        (r1,c1) = nextPos\\n        return table[(r1-r0, c1-c0)]\\n    \\n    def BFS(self, board, start, target):\\n        visited = {start}\\n        q = [(start, \\'\\')]\\n        while q:\\n            (curr, path) = q.pop(0)\\n            if board[curr[0]][curr[1]] == target:\\n                return (curr, path)\\n            neighbors = self.getNeighbors(board, curr)\\n            for neighbor in neighbors:\\n                if neighbor not in visited:\\n                    visited.add(neighbor)\\n                    q.append((neighbor, path + self.getDirection(curr, neighbor) ))\\n    \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        board = [\\n            [\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'],\\n            [\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'],\\n            [\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'],\\n            [\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'],\\n            [\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'],\\n            [\\'z\\',\\'\\',\\'\\',\\'\\',\\'\\']\\n        ] \\n        saved = {}\\n        finalPath = \\'\\'\\n        pos = (0,0)\\n        for letter in target:\\n            if (pos, letter) not in saved:\\n                saved[(pos,letter)] = self.BFS(board, pos, letter)\\n            (pos, path) = saved[(pos,letter)]\\n            finalPath += path + \\'!\\'\\n        return finalPath\\n    \\n    def getNeighbors(self, board, pos):\\n        M, N = len(board), len(board[0])\\n        neighbors = []\\n        for v in [(0,1),(1,0),(-1,0),(0,-1)]:\\n            (r,c) = (pos[0]+v[0],pos[1]+v[1])\\n            if r in range(M) and c in range(N) and board[r][c] != \\'\\':\\n                neighbors.append((r,c))\\n        return neighbors\\n    \\n    def getDirection(self, currPos, nextPos):\\n        table = {(0,1):\\'R\\',(1,0):\\'D\\',(-1,0):\\'U\\',(0,-1):\\'L\\'}\\n        (r0,c0) = currPos\\n        (r1,c1) = nextPos\\n        return table[(r1-r0, c1-c0)]\\n    \\n    def BFS(self, board, start, target):\\n        visited = {start}\\n        q = [(start, \\'\\')]\\n        while q:\\n            (curr, path) = q.pop(0)\\n            if board[curr[0]][curr[1]] == target:\\n                return (curr, path)\\n            neighbors = self.getNeighbors(board, curr)\\n            for neighbor in neighbors:\\n                if neighbor not in visited:\\n                    visited.add(neighbor)\\n                    q.append((neighbor, path + self.getDirection(curr, neighbor) ))\\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 535601,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int[] cur = {0, 0};\\n        \\n       StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : target.toCharArray()) {\\n            int[] nc = getC(c);\\n            \\n            while (nc[0]<cur[0]) {sb.append(\\'U\\'); nc[0]++;}\\n            while (nc[1]<cur[1]) {sb.append(\\'L\\'); nc[1]++;}\\n            while (nc[0]>cur[0]) {sb.append(\\'D\\'); nc[0]--;}\\n            while (nc[1]>cur[1]) {sb.append(\\'R\\'); nc[1]--;}\\n            \\n            cur = getC(c);\\n            sb.append(\"!\");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    \\n    private int[] getC(char c) {\\n        return new int[]{(c-\\'a\\')/5, (c-\\'a\\')%5};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int[] cur = {0, 0};\\n        \\n       StringBuilder sb = new StringBuilder();\\n        \\n        for (char c : target.toCharArray()) {\\n            int[] nc = getC(c);\\n            \\n            while (nc[0]<cur[0]) {sb.append(\\'U\\'); nc[0]++;}\\n            while (nc[1]<cur[1]) {sb.append(\\'L\\'); nc[1]++;}\\n            while (nc[0]>cur[0]) {sb.append(\\'D\\'); nc[0]--;}\\n            while (nc[1]>cur[1]) {sb.append(\\'R\\'); nc[1]--;}\\n            \\n            cur = getC(c);\\n            sb.append(\"!\");\\n        }\\n        return sb.toString();\\n    }\\n    \\n    \\n    private int[] getC(char c) {\\n        return new int[]{(c-\\'a\\')/5, (c-\\'a\\')%5};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382726,
                "title": "i-don-t-think-my-code-is-run-same-length-path-anyone-meet-same-problem",
                "content": "`\\n\\n\\tclass Solution:\\n    def walk(self,pos1,pos2):\\n        y,x=pos2[0]-pos1[0],pos2[1]-pos1[1]\\n        \\n        lr=\\'L\\'\\n        ud=\\'U\\'\\n        if x>0:\\n            lr=\\'R\\'\\n        else:\\n            x=-x\\n        if y>0:\\n            ud=\\'D\\'\\n        else:\\n            y=-y\\n\\n        res=\"\"\\n\\n        while y:\\n            res+=ud\\n            y-=1\\n        while x:\\n            res+=lr\\n            x-=1\\n        return res+\\'!\\'\\n\\n    def alphabetBoardPath(self, target: str) -> str:\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        char2pos={}\\n        for i,s in enumerate(board):\\n            for j,c in enumerate(s):\\n                char2pos[c]=(i,j)\\n\\n        res=\"\"\\n        pre_pos=(0,0)\\n        for c in target:\\n            # print(pre_pos,char2pos[c])\\n            res+=self.walk(pre_pos,char2pos[c])\\n            pre_pos=char2pos[c]\\n\\n        return res\\n\\n\\n`\\n\\nInput\\n\"zdz\"\\nOutput\\n\"DDDDD!UUUUURRR!DDDDDLLL!\"\\nExpected\\n\"DDDDD!UUUUURRR!DDDDLLLD!\"\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def walk(self,pos1,pos2):\\n        y,x=pos2[0]-pos1[0],pos2[1]-pos1[1]\\n        \\n        lr=\\'L\\'\\n        ud=\\'U\\'\\n        if x>0:\\n            lr=\\'R\\'\\n        else:\\n            x=-x\\n        if y>0:\\n            ud=\\'D\\'\\n        else:\\n            y=-y\\n\\n        res=\"\"\\n\\n        while y:\\n            res+=ud\\n            y-=1\\n        while x:\\n            res+=lr\\n            x-=1\\n        return res+\\'!\\'\\n\\n    def alphabetBoardPath(self, target: str) -> str:\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        char2pos={}",
                "codeTag": "Java"
            },
            {
                "id": 345649,
                "title": "simple-java-code",
                "content": "```\\n// Since there is only one available place \\'z\\' in the last row, \\n// we should move UP before RIGHT and move LEFT before DOWN\\n\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int sx = 0, sy = 0; // source x, y \\n        char[] s = target.toCharArray();\\n        for (int i = 0; i < s.length; i++) {\\n            int dx = (s[i] - \\'a\\') / 5;   //destination x, y\\n            int dy = (s[i] - \\'a\\') % 5;\\n            if (dx < sx) {\\n                for (int j = sx - dx; j > 0; j--)  sb.append(\\'U\\');\\n            }\\n            if (dy > sy) {\\n                for (int j = dy - sy; j > 0; j--)  sb.append(\\'R\\');\\n            }\\n            if (dy < sy) {\\n                for (int j = sy - dy; j > 0; j--)  sb.append(\\'L\\');\\n            }\\n            if (dx > sx) {\\n                for (int j = dx - sx; j > 0; j--)  sb.append(\\'D\\');\\n            }\\n            sb.append(\\'!\\');\\n            sx = dx; sy = dy;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Since there is only one available place \\'z\\' in the last row, \\n// we should move UP before RIGHT and move LEFT before DOWN\\n\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int sx = 0, sy = 0; // source x, y \\n        char[] s = target.toCharArray();\\n        for (int i = 0; i < s.length; i++) {\\n            int dx = (s[i] - \\'a\\') / 5;   //destination x, y\\n            int dy = (s[i] - \\'a\\') % 5;\\n            if (dx < sx) {\\n                for (int j = sx - dx; j > 0; j--)  sb.append(\\'U\\');\\n            }\\n            if (dy > sy) {\\n                for (int j = dy - sy; j > 0; j--)  sb.append(\\'R\\');\\n            }\\n            if (dy < sy) {\\n                for (int j = sy - dy; j > 0; j--)  sb.append(\\'L\\');\\n            }\\n            if (dx > sx) {\\n                for (int j = dx - sx; j > 0; j--)  sb.append(\\'D\\');\\n            }\\n            sb.append(\\'!\\');\\n            sx = dx; sy = dy;\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345300,
                "title": "why-did-i-fail-on-zdz",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        def getLocation(s):\\n            diff = ord(s)-ord(\"a\")\\n            row = diff // 5\\n            col = diff % 5 - 1\\n            \\n            return (row,col)\\n        \\n        def pathOfTwo(start, end):\\n            row = end[0] - start[0]\\n            col = end[1] - start[1]\\n            \\n            res = \"\"\\n            \\n            if row > 0:\\n                res += row*\"D\"\\n            else:\\n                res += abs(row)*\"U\"\\n            \\n            if col > 0:\\n                res += col*\"R\"\\n            else:\\n                res += abs(col)*\"L\"\\n            \\n            return res+\"!\"\\n        \\n        target = \"a\"+target\\n        res = \"\"\\n        for i in range(len(target)-1):\\n            res += pathOfTwo(getLocation(target[i]), getLocation(target[i+1]))\\n        return res\\n```\\n\\nOutput: \\n`\"DDDDD!UUUUURRR!DDDDDLLL!\"`\\n\\nExpected:\\n`\"DDDDD!UUUUURRR!DDDDLLLD!\"`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        def getLocation(s):\\n            diff = ord(s)-ord(\"a\")\\n            row = diff // 5\\n            col = diff % 5 - 1\\n            \\n            return (row,col)\\n        \\n        def pathOfTwo(start, end):\\n            row = end[0] - start[0]\\n            col = end[1] - start[1]\\n            \\n            res = \"\"\\n            \\n            if row > 0:\\n                res += row*\"D\"\\n            else:\\n                res += abs(row)*\"U\"\\n            \\n            if col > 0:\\n                res += col*\"R\"\\n            else:\\n                res += abs(col)*\"L\"\\n            \\n            return res+\"!\"\\n        \\n        target = \"a\"+target\\n        res = \"\"\\n        for i in range(len(target)-1):\\n            res += pathOfTwo(getLocation(target[i]), getLocation(target[i+1]))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097676,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // My Solution\\n  /*  static String helper(String s){\\n         StringBuilder ans = new StringBuilder(\"\");\\n\\n        HashMap<Character,int[]> hp = new HashMap<>();\\n\\n        int n = s.length();\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++){\\n            int a = i-97;\\n            int r = a/5;\\n            int c = a%5;\\n            int x[] = {r,c};\\n            hp.put(i,x);\\n        }\\n\\n        char prev = \\'a\\';\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch==prev){\\n                ans.append(\"!\");\\n                prev = ch;\\n            }else{\\n                int a[] = hp.get(prev);\\n                int b[] = hp.get(ch);\\n\\n                int r = b[0]-a[0];\\n                int c = b[1]-a[1];\\n\\n                if(ch==\\'z\\'){\\n                    ans.append(\"D\".repeat(r-1));\\n                    ans.append(\"L\".repeat(-c));\\n                    ans.append(\"D\");\\n                    ans.append(\"!\");\\n                    prev = ch;\\n                    continue;\\n                }\\n\\n                if(r>=0 && c>=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"R\".repeat(c));\\n                }else if(r<=0 && c<=0){\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else if(r>=0 && c<=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else{\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"R\".repeat(c));\\n                }\\n                ans.append(\"!\");\\n                prev = ch;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n    */\\n    public String alphabetBoardPath(String s) {\\n       int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    // My Solution\\n  /*  static String helper(String s){\\n         StringBuilder ans = new StringBuilder(\"\");\\n\\n        HashMap<Character,int[]> hp = new HashMap<>();\\n\\n        int n = s.length();\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++){\\n            int a = i-97;\\n            int r = a/5;\\n            int c = a%5;\\n            int x[] = {r,c};\\n            hp.put(i,x);\\n        }\\n\\n        char prev = \\'a\\';\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch==prev){\\n                ans.append(\"!\");\\n                prev = ch;\\n            }else{\\n                int a[] = hp.get(prev);\\n                int b[] = hp.get(ch);\\n\\n                int r = b[0]-a[0];\\n                int c = b[1]-a[1];\\n\\n                if(ch==\\'z\\'){\\n                    ans.append(\"D\".repeat(r-1));\\n                    ans.append(\"L\".repeat(-c));\\n                    ans.append(\"D\");\\n                    ans.append(\"!\");\\n                    prev = ch;\\n                    continue;\\n                }\\n\\n                if(r>=0 && c>=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"R\".repeat(c));\\n                }else if(r<=0 && c<=0){\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else if(r>=0 && c<=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else{\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"R\".repeat(c));\\n                }\\n                ans.append(\"!\");\\n                prev = ch;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n    */\\n    public String alphabetBoardPath(String s) {\\n       int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097648,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String s) {\\n        StringBuilder ans = new StringBuilder(\"\");\\n\\n        HashMap<Character,int[]> hp = new HashMap<>();\\n\\n        int n = s.length();\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++){\\n            int a = i-97;\\n            int r = a/5;\\n            int c = a%5;\\n            int x[] = {r,c};\\n            hp.put(i,x);\\n        }\\n\\n        char prev = \\'a\\';\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch==prev){\\n                ans.append(\"!\");\\n                prev = ch;\\n            }else{\\n                int a[] = hp.get(prev);\\n                int b[] = hp.get(ch);\\n\\n                int r = b[0]-a[0];\\n                int c = b[1]-a[1];\\n\\n                if(ch==\\'z\\'){\\n                    ans.append(\"D\".repeat(r-1));\\n                    ans.append(\"L\".repeat(-c));\\n                    ans.append(\"D\");\\n                    ans.append(\"!\");\\n                    prev = ch;\\n                    continue;\\n                }\\n\\n                if(r>=0 && c>=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"R\".repeat(c));\\n                }else if(r<=0 && c<=0){\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else if(r>=0 && c<=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else{\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"R\".repeat(c));\\n                }\\n                ans.append(\"!\");\\n                prev = ch;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String s) {\\n        StringBuilder ans = new StringBuilder(\"\");\\n\\n        HashMap<Character,int[]> hp = new HashMap<>();\\n\\n        int n = s.length();\\n\\n        for(char i=\\'a\\'; i<=\\'z\\'; i++){\\n            int a = i-97;\\n            int r = a/5;\\n            int c = a%5;\\n            int x[] = {r,c};\\n            hp.put(i,x);\\n        }\\n\\n        char prev = \\'a\\';\\n\\n        for(int i=0; i<n; i++){\\n            char ch = s.charAt(i);\\n            if(ch==prev){\\n                ans.append(\"!\");\\n                prev = ch;\\n            }else{\\n                int a[] = hp.get(prev);\\n                int b[] = hp.get(ch);\\n\\n                int r = b[0]-a[0];\\n                int c = b[1]-a[1];\\n\\n                if(ch==\\'z\\'){\\n                    ans.append(\"D\".repeat(r-1));\\n                    ans.append(\"L\".repeat(-c));\\n                    ans.append(\"D\");\\n                    ans.append(\"!\");\\n                    prev = ch;\\n                    continue;\\n                }\\n\\n                if(r>=0 && c>=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"R\".repeat(c));\\n                }else if(r<=0 && c<=0){\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else if(r>=0 && c<=0){\\n                    ans.append(\"D\".repeat(r));\\n                    ans.append(\"L\".repeat(-c));\\n                }else{\\n                    ans.append(\"U\".repeat(-r));\\n                    ans.append(\"R\".repeat(c));\\n                }\\n                ans.append(\"!\");\\n                prev = ch;\\n            }\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713787,
                "title": "hash-table-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstore the position of each character and calculate the path for one character to next character.\\n\\n - **Ex:- target = \"abc\"**\\n1. calculate the path from (0,0) to \\'a\\' (0,0), path = \"!\" \\n2.  calculate the path from \\'a\\'(0,0) to \\'b\\' (0,1) path = \\'R!\\'\\n3.  calculate the path from \\'b\\'(0,1) to \\'c\\' (0,3) path  = \\'R!\\'\\n    **return Path =  \"!R!R!\"**\\n\\n**Note :- Take care of the special case of \\'Z\\'**\\n\\n\\n\\n# Complexity\\n- Time complexity:O(26+N*10)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string solve(int srcx,int srcy,int destx,int desty)\\n    {\\n       if(srcx==destx && srcy==desty) return \"!\";\\n       string ans = \"\";\\n       bool fleg = false;\\n      \\n       if(destx==5)\\n       {\\n           destx-=1;\\n           fleg = true;\\n       }\\n\\n       if(srcx<destx)\\n       for(int i = srcx;i<destx;i++) ans+=\\'D\\';\\n       else\\n       for(int i = destx;i<srcx;i++) ans+=\\'U\\';\\n\\n       if(srcy<desty)\\n       for(int i = srcy;i<desty;i++) ans+=\\'R\\';\\n       else\\n       for(int i = desty;i<srcy;i++) ans+=\\'L\\';\\n\\n       if(fleg) ans+=\\'D\\';   \\n       return ans;  \\n    }\\n    string alphabetBoardPath(string t) {\\n\\n        vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        vector<pair<int,int>> pos(26);\\n        string ans = \"\";\\n        for(int i = 0;i<board.size();i++)\\n        {\\n            for(int j = 0;j<board[i].size();j++)\\n            pos[board[i][j]-\\'a\\'] = {i,j};\\n        }\\n\\n        int x = 0,y = 0;\\n        for(int i = 0;i<t.size();i++)\\n        {\\n            if(x==pos[t[i]-\\'a\\'].first && y==pos[t[i]-\\'a\\'].second)\\n            ans+=\"!\";\\n            else\\n            {\\n             ans+=solve(x,y,pos[t[i]-\\'a\\'].first,pos[t[i]-\\'a\\'].second);\\n             ans+=\\'!\\';\\n            }\\n            x = pos[t[i]-\\'a\\'].first;\\n            y = pos[t[i]-\\'a\\'].second;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/e3988040-f0b8-4ea2-8ae6-cf95183ef026_1688403562.4923952.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string solve(int srcx,int srcy,int destx,int desty)\\n    {\\n       if(srcx==destx && srcy==desty) return \"!\";\\n       string ans = \"\";\\n       bool fleg = false;\\n      \\n       if(destx==5)\\n       {\\n           destx-=1;\\n           fleg = true;\\n       }\\n\\n       if(srcx<destx)\\n       for(int i = srcx;i<destx;i++) ans+=\\'D\\';\\n       else\\n       for(int i = destx;i<srcx;i++) ans+=\\'U\\';\\n\\n       if(srcy<desty)\\n       for(int i = srcy;i<desty;i++) ans+=\\'R\\';\\n       else\\n       for(int i = desty;i<srcy;i++) ans+=\\'L\\';\\n\\n       if(fleg) ans+=\\'D\\';   \\n       return ans;  \\n    }\\n    string alphabetBoardPath(string t) {\\n\\n        vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        vector<pair<int,int>> pos(26);\\n        string ans = \"\";\\n        for(int i = 0;i<board.size();i++)\\n        {\\n            for(int j = 0;j<board[i].size();j++)\\n            pos[board[i][j]-\\'a\\'] = {i,j};\\n        }\\n\\n        int x = 0,y = 0;\\n        for(int i = 0;i<t.size();i++)\\n        {\\n            if(x==pos[t[i]-\\'a\\'].first && y==pos[t[i]-\\'a\\'].second)\\n            ans+=\"!\";\\n            else\\n            {\\n             ans+=solve(x,y,pos[t[i]-\\'a\\'].first,pos[t[i]-\\'a\\'].second);\\n             ans+=\\'!\\';\\n            }\\n            x = pos[t[i]-\\'a\\'].first;\\n            y = pos[t[i]-\\'a\\'].second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649309,
                "title": "c-simple-o-n-solution-0ms-beats-100-using-only-vectors-and-no-other-stls",
                "content": "# Approach\\n1. Obtain row and column number of each character in target using basic math.\\n2. Use pos = {0, 0} to store the current position of every character. This will be considered our target row and column.\\n3. Obtain the absolute difference between <row, column> from current position pos{int, int}.\\n4. If the target row is greater than the current row(pos[0]), it means that the target character is below the current position. Hence we go down and add the respective number of D\\'s.\\n5. If the target row is lesser than the current row(pos[0]), it means that the target character is above the current position. Hence we go up and add the respective number of U\\'s.\\n6. We apply the logic followed in steps 4 and 5 to the column numbers as well, by comparing with pos[1].\\n7. Apply check constraints when then character is z.\\n8. Note that we do not need to apply constraints for arrays as the pointers can never go out of bounds as we are obtaining the target within the array itself.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        string path;\\n        //current position\\n        vector<int> pos = {0,0};\\n        for(int i=0; i<target.size(); i++){\\n            char c = target[i];\\n            //target position\\n            int row = (c-97)/5;\\n            int col = (c-97)%5;\\n            //absolute difference\\n            int drow = abs(row - pos[0]);\\n            int dcol = abs(col - pos[1]);\\n            if(i>0 && c==target[i-1]) {\\n                path+=\\'!\\';\\n                continue;\\n            }\\n            string t;\\n            if(pos[0]<row) {\\n                if(c==\\'z\\') drow--;\\n                //string(int, char) stores the character integer times\\n                t = string(drow, \\'D\\');\\n                pos[0] += drow;\\n            }\\n            else if(pos[0]>=row){\\n                t = string(drow, \\'U\\');\\n                pos[0] -= drow;\\n            }\\n            path+=t;\\n            t = \"\";\\n            if(pos[1]<col){\\n                t = string(dcol, \\'R\\');\\n                pos[1] += dcol;\\n            }\\n            else if(pos[1]>=col){\\n                t = string(dcol, \\'L\\');\\n                pos[1] -= dcol;\\n            }\\n            path+=t;\\n            t = \"\";\\n            if(c==\\'z\\') {path += \\'D\\'; pos[0]++;}\\n            path+=\\'!\\';\\n            \\n        }\\n        return path;\\n    }\\n};\\n```\\nPlease upvote if it helped!!",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        string path;\\n        //current position\\n        vector<int> pos = {0,0};\\n        for(int i=0; i<target.size(); i++){\\n            char c = target[i];\\n            //target position\\n            int row = (c-97)/5;\\n            int col = (c-97)%5;\\n            //absolute difference\\n            int drow = abs(row - pos[0]);\\n            int dcol = abs(col - pos[1]);\\n            if(i>0 && c==target[i-1]) {\\n                path+=\\'!\\';\\n                continue;\\n            }\\n            string t;\\n            if(pos[0]<row) {\\n                if(c==\\'z\\') drow--;\\n                //string(int, char) stores the character integer times\\n                t = string(drow, \\'D\\');\\n                pos[0] += drow;\\n            }\\n            else if(pos[0]>=row){\\n                t = string(drow, \\'U\\');\\n                pos[0] -= drow;\\n            }\\n            path+=t;\\n            t = \"\";\\n            if(pos[1]<col){\\n                t = string(dcol, \\'R\\');\\n                pos[1] += dcol;\\n            }\\n            else if(pos[1]>=col){\\n                t = string(dcol, \\'L\\');\\n                pos[1] -= dcol;\\n            }\\n            path+=t;\\n            t = \"\";\\n            if(c==\\'z\\') {path += \\'D\\'; pos[0]++;}\\n            path+=\\'!\\';\\n            \\n        }\\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418559,
                "title": "runtime-0-ms-beats-100-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) \\n    {\\n        vector<string>board =  {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char,pair<int,int>>mp;\\n        \\n        for(int i=0;i<board.size();i++)\\n        {\\n            string str = board[i];\\n            for(int j=0;j<str.length();j++)\\n            {\\n                char ch = str[j];\\n                mp[ch] = {i,j};\\n            }\\n        }\\n        int row = 0;\\n        int col = 0;\\n        int idx = 0;\\n        string ans=\"\";\\n\\n        while(idx < target.length())\\n        {\\n            char target_ch  = target[idx];\\n            int  target_row = mp[target_ch].first;\\n            int  target_col = mp[target_ch].second;\\n            \\n            if(target_ch == \\'z\\')\\n            {\\n                //first we will be on the col 0;\\n                \\n                //doing the horizontal traversal\\n                int count = abs(col - target_col);\\n                while(count > 0)\\n                {\\n                    ans.push_back(\\'L\\');\\n                    count--;\\n                }\\n\\n                //doing the vertical traversal\\n                count = abs(row - target_row);\\n                while(count > 0)\\n                {\\n                    ans.push_back(\\'D\\');\\n                    count--;\\n                }\\n                ans.push_back(\\'!\\');\\n                row = target_row;\\n                col = target_col;\\n                idx++;\\n            }\\n            else\\n            {\\n                char curr_ch   = board[row][col];\\n                //checking the horizontal moves\\n                if(row < target_row)\\n                {\\n                    int count = abs(row - target_row);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'D\\');\\n                    }\\n                }\\n                else if(row > target_row)\\n                {\\n                    int count = abs(row - target_row);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'U\\');\\n                    }\\n                }\\n\\n                //checking the horizontal moves\\n                if(col < target_col)\\n                {\\n                    int count = abs(col - target_col);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'R\\');\\n                    }\\n                }\\n                else if(col > target_col)\\n                {\\n                    int count = abs(col - target_col);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'L\\');\\n                    }\\n                }\\n                ans.push_back(\\'!\\');\\n                row = target_row;\\n                col = target_col;\\n                idx++;\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) \\n    {\\n        vector<string>board =  {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char,pair<int,int>>mp;\\n        \\n        for(int i=0;i<board.size();i++)\\n        {\\n            string str = board[i];\\n            for(int j=0;j<str.length();j++)\\n            {\\n                char ch = str[j];\\n                mp[ch] = {i,j};\\n            }\\n        }\\n        int row = 0;\\n        int col = 0;\\n        int idx = 0;\\n        string ans=\"\";\\n\\n        while(idx < target.length())\\n        {\\n            char target_ch  = target[idx];\\n            int  target_row = mp[target_ch].first;\\n            int  target_col = mp[target_ch].second;\\n            \\n            if(target_ch == \\'z\\')\\n            {\\n                //first we will be on the col 0;\\n                \\n                //doing the horizontal traversal\\n                int count = abs(col - target_col);\\n                while(count > 0)\\n                {\\n                    ans.push_back(\\'L\\');\\n                    count--;\\n                }\\n\\n                //doing the vertical traversal\\n                count = abs(row - target_row);\\n                while(count > 0)\\n                {\\n                    ans.push_back(\\'D\\');\\n                    count--;\\n                }\\n                ans.push_back(\\'!\\');\\n                row = target_row;\\n                col = target_col;\\n                idx++;\\n            }\\n            else\\n            {\\n                char curr_ch   = board[row][col];\\n                //checking the horizontal moves\\n                if(row < target_row)\\n                {\\n                    int count = abs(row - target_row);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'D\\');\\n                    }\\n                }\\n                else if(row > target_row)\\n                {\\n                    int count = abs(row - target_row);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'U\\');\\n                    }\\n                }\\n\\n                //checking the horizontal moves\\n                if(col < target_col)\\n                {\\n                    int count = abs(col - target_col);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'R\\');\\n                    }\\n                }\\n                else if(col > target_col)\\n                {\\n                    int count = abs(col - target_col);\\n                    while(count--)\\n                    {\\n                        ans.push_back(\\'L\\');\\n                    }\\n                }\\n                ans.push_back(\\'!\\');\\n                row = target_row;\\n                col = target_col;\\n                idx++;\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315754,
                "title": "python3-solution",
                "content": "\\n# Code\\n```\\nclass Board:\\n    def __init__(self):\\n        self.board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        self.r=0\\n        self.c=0\\n    def down(self):\\n        try:\\n            self.board[self.r+1][self.c]\\n        except:\\n            return\\n        else:\\n            self.r+=1\\n    def up(self):\\n        try:\\n            self.board[self.r-1][self.c]\\n        except:\\n            return\\n        else:\\n            self.r-=1\\n    def left(self):\\n        try:\\n            self.board[self.r][self.c-1]\\n        except:\\n            return\\n        else:\\n            self.c-=1\\n    def right(self):\\n        try:\\n            self.board[self.r][self.c+1]\\n        except:\\n            return\\n        else:\\n            self.c+=1\\n    def cur(self):\\n        return self.board[self.r][self.c]\\n\\n\\n\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        b = Board()\\n        ans=\"\"\\n        for i in target:\\n            steps=\"\"\\n            if i==\"z\":\\n                \\n                while b.c!=0:\\n                    b.left()\\n                    steps+=\"L\"\\n                while b.cur()!=\"z\":\\n                    b.down()\\n                    steps+=\"D\"\\n                steps+=\"!\"\\n                \\n            else:\\n                while True:\\n                    if i==b.cur():\\n                        steps+=\"!\"\\n                        break\\n                    elif i in b.board[b.r]:\\n                        if b.cur()<i:\\n                            b.right()\\n                            steps+=\"R\"\\n                        else:\\n                            b.left()\\n                            steps+=\"L\"\\n                    else:\\n                        if b.cur()<i:\\n                            b.down()\\n                            steps+=\"D\"\\n                        else:\\n                            b.up()\\n                            steps+=\"U\"\\n            ans+=steps\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Board:\\n    def __init__(self):\\n        self.board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        self.r=0\\n        self.c=0\\n    def down(self):\\n        try:\\n            self.board[self.r+1][self.c]\\n        except:\\n            return\\n        else:\\n            self.r+=1\\n    def up(self):\\n        try:\\n            self.board[self.r-1][self.c]\\n        except:\\n            return\\n        else:\\n            self.r-=1\\n    def left(self):\\n        try:\\n            self.board[self.r][self.c-1]\\n        except:\\n            return\\n        else:\\n            self.c-=1\\n    def right(self):\\n        try:\\n            self.board[self.r][self.c+1]\\n        except:\\n            return\\n        else:\\n            self.c+=1\\n    def cur(self):\\n        return self.board[self.r][self.c]\\n\\n\\n\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        b = Board()\\n        ans=\"\"\\n        for i in target:\\n            steps=\"\"\\n            if i==\"z\":\\n                \\n                while b.c!=0:\\n                    b.left()\\n                    steps+=\"L\"\\n                while b.cur()!=\"z\":\\n                    b.down()\\n                    steps+=\"D\"\\n                steps+=\"!\"\\n                \\n            else:\\n                while True:\\n                    if i==b.cur():\\n                        steps+=\"!\"\\n                        break\\n                    elif i in b.board[b.r]:\\n                        if b.cur()<i:\\n                            b.right()\\n                            steps+=\"R\"\\n                        else:\\n                            b.left()\\n                            steps+=\"L\"\\n                    else:\\n                        if b.cur()<i:\\n                            b.down()\\n                            steps+=\"D\"\\n                        else:\\n                            b.up()\\n                            steps+=\"U\"\\n            ans+=steps\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196051,
                "title": "clean-python-high-speed-o-n-time-o-1-space-beats-98-9",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        i = j = 0\\n        ans = []\\n        for c in target:\\n            diff = ord(c) - ord(\\'a\\')\\n            row, col = divmod(diff, 5)\\n            while i > row:\\n                i -= 1\\n                ans.append(\\'U\\')\\n            while j > col:\\n                j -= 1\\n                ans.append(\\'L\\')\\n            while i < row:\\n                i += 1\\n                ans.append(\\'D\\')\\n            while j < col:\\n                j += 1\\n                ans.append(\\'R\\')\\n            ans.append(\\'!\\')   \\n        return \\'\\'.join(ans) \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        i = j = 0\\n        ans = []\\n        for c in target:\\n            diff = ord(c) - ord(\\'a\\')\\n            row, col = divmod(diff, 5)\\n            while i > row:\\n                i -= 1\\n                ans.append(\\'U\\')\\n            while j > col:\\n                j -= 1\\n                ans.append(\\'L\\')\\n            while i < row:\\n                i += 1\\n                ans.append(\\'D\\')\\n            while j < col:\\n                j += 1\\n                ans.append(\\'R\\')\\n            ans.append(\\'!\\')   \\n        return \\'\\'.join(ans) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187654,
                "title": "java-easy-and-concise-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int currX = 0;\\n        int currY = 0;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : target.toCharArray()) {\\n            int i = (c - \\'a\\') / 5; // x coordinate is the floor\\n            int j = (c - \\'a\\') % 5; // y coordinate is exact modulo 5 position\\n\\n            if (c == \\'z\\') { // edge case since we can only within the bounds of the board\\n                while (currY > j) { // move as left as possible to get to z\\n                    sb.append(\\'L\\'); \\n                    currY--;   \\n                }\\n                while (currX < i) { // move as down as possible to get to z\\n                    sb.append(\\'D\\');\\n                    currX++;\\n                }\\n            }\\n            while (currX < i) {\\n                sb.append(\\'D\\');\\n                currX++;\\n            }\\n            while (currX > i) {\\n                sb.append(\\'U\\');\\n                currX--;\\n            } \\n            while (currY < j) {\\n                sb.append(\\'R\\');\\n                currY++;\\n            }  \\n            while (currY > j) {\\n                sb.append(\\'L\\');\\n                currY--;\\n            }                                                \\n            sb.append(\\'!\\'); // add character at end of for loop\\n\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int currX = 0;\\n        int currY = 0;\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : target.toCharArray()) {\\n            int i = (c - \\'a\\') / 5; // x coordinate is the floor\\n            int j = (c - \\'a\\') % 5; // y coordinate is exact modulo 5 position\\n\\n            if (c == \\'z\\') { // edge case since we can only within the bounds of the board\\n                while (currY > j) { // move as left as possible to get to z\\n                    sb.append(\\'L\\'); \\n                    currY--;   \\n                }\\n                while (currX < i) { // move as down as possible to get to z\\n                    sb.append(\\'D\\');\\n                    currX++;\\n                }\\n            }\\n            while (currX < i) {\\n                sb.append(\\'D\\');\\n                currX++;\\n            }\\n            while (currX > i) {\\n                sb.append(\\'U\\');\\n                currX--;\\n            } \\n            while (currY < j) {\\n                sb.append(\\'R\\');\\n                currY++;\\n            }  \\n            while (currY > j) {\\n                sb.append(\\'L\\');\\n                currY--;\\n            }                                                \\n            sb.append(\\'!\\'); // add character at end of for loop\\n\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160446,
                "title": "simple-beginner-friendly-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans=\"\";\\n        int curr_row=0,curr_col=0;\\n\\n        for(int i=0;i<target.length();i++){\\n            int row=(target[i]-97)/5;\\n            int col=(target[i]-97)%5;\\n            if(curr_row==row && curr_col==col){\\n                ans+=\"!\";\\n            }\\n            else if(row==5){\\n                while(curr_row<4){\\n                    curr_row++;\\n                    ans+=\"D\";\\n                }\\n                while(curr_col>0){\\n                    curr_col--;\\n                    ans+=\"L\";\\n                }\\n                curr_row=5;\\n                ans+=\"D!\";\\n            }\\n            else{\\n                while(row>curr_row){\\n                curr_row++;\\n                ans+=\"D\";\\n                }\\n                while(row<curr_row){\\n                    curr_row--;\\n                    ans+=\"U\";\\n                }\\n                while(col>curr_col){\\n                    curr_col++;\\n                    ans+=\"R\";\\n                }\\n                while(col<curr_col){\\n                    curr_col--;\\n                    ans+=\"L\";\\n                }\\n                if(curr_row==row && curr_col==col){\\n                    ans+=\"!\";\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans=\"\";\\n        int curr_row=0,curr_col=0;\\n\\n        for(int i=0;i<target.length();i++){\\n            int row=(target[i]-97)/5;\\n            int col=(target[i]-97)%5;\\n            if(curr_row==row && curr_col==col){\\n                ans+=\"!\";\\n            }\\n            else if(row==5){\\n                while(curr_row<4){\\n                    curr_row++;\\n                    ans+=\"D\";\\n                }\\n                while(curr_col>0){\\n                    curr_col--;\\n                    ans+=\"L\";\\n                }\\n                curr_row=5;\\n                ans+=\"D!\";\\n            }\\n            else{\\n                while(row>curr_row){\\n                curr_row++;\\n                ans+=\"D\";\\n                }\\n                while(row<curr_row){\\n                    curr_row--;\\n                    ans+=\"U\";\\n                }\\n                while(col>curr_col){\\n                    curr_col++;\\n                    ans+=\"R\";\\n                }\\n                while(col<curr_col){\\n                    curr_col--;\\n                    ans+=\"L\";\\n                }\\n                if(curr_row==row && curr_col==col){\\n                    ans+=\"!\";\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124944,
                "title": "c-0ms-faster-than-100-o-1-space-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthere is same grid every time and eash letter is only once in the grid (so no need of bfs), that too in sequence (which means we can calculate indexes of any letter in the grid in O(1) time, we don\\'t even need to store the grid)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nto calculate any letters position in grid in O(1) time:\\nfirst we will calculate index of letter (0 to 26), notice each row of grid have 5 letters except last one. so the row of our target letter will be index/5. and for column we can subract number of letter in previous rows from index i.e. index-5*row.\\n\\nnow we have index of our target letter, we are on x1,y1.\\n\\nlet\\'s say we are on position x1,y1 and we want to go on position x2,y2\\nfirst we can go left(if y2<y1) or right(if y2>y1) then up(x2<x1) or down(if x1>x2), the order doesn\\'t matter of left,right,up or down. initially x1 and y1 will be 0,0.\\n\\nonly edge case is \\'z\\'.\\n\\nif we have to go from some other letter to \\'z\\' then we don\\'t need to do anything if we first travel horizontally that means left or right, because if we have to go to z then we will automatically come to 0th column(if we travel horizontaly first) the we will just travel down.\\n\\nbut if we have to go from z to any other letter then first we can simply go up once then we can travel to any letter.\\n\\n# Complexity\\n- Time complexity: O(n), where n is length of \\'target\\'.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans;\\n        int x1=0,y1=0;\\n\\n        for(int i=0 ; i<target.length() ; i++){\\n            int letter = target[i]-\\'a\\';\\n            int x2 = (letter)/5;\\n            int y2 = (letter-5*x2);\\n\\n            // edge case when have to move from z to some other letter\\n            if(x1==5 && y1==0 && x2!=5){\\n                ans.push_back(\\'U\\');\\n                x1--;\\n            }\\n\\n            // horizontally\\n            while(y1!=y2){\\n                if(y1>y2){\\n                    ans.push_back(\\'L\\');\\n                    y1--;\\n                }\\n                else{\\n                    ans.push_back(\\'R\\');\\n                    y1++;\\n                }\\n            }\\n\\n            // vertically\\n            while(x1!=x2){\\n                if(x1>x2){\\n                    ans.push_back(\\'U\\');\\n                    x1--;\\n                }\\n                else{\\n                    ans.push_back(\\'D\\');\\n                    x1++;\\n                }\\n            }\\n            \\n            ans.push_back(\\'!\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans;\\n        int x1=0,y1=0;\\n\\n        for(int i=0 ; i<target.length() ; i++){\\n            int letter = target[i]-\\'a\\';\\n            int x2 = (letter)/5;\\n            int y2 = (letter-5*x2);\\n\\n            // edge case when have to move from z to some other letter\\n            if(x1==5 && y1==0 && x2!=5){\\n                ans.push_back(\\'U\\');\\n                x1--;\\n            }\\n\\n            // horizontally\\n            while(y1!=y2){\\n                if(y1>y2){\\n                    ans.push_back(\\'L\\');\\n                    y1--;\\n                }\\n                else{\\n                    ans.push_back(\\'R\\');\\n                    y1++;\\n                }\\n            }\\n\\n            // vertically\\n            while(x1!=x2){\\n                if(x1>x2){\\n                    ans.push_back(\\'U\\');\\n                    x1--;\\n                }\\n                else{\\n                    ans.push_back(\\'D\\');\\n                    x1++;\\n                }\\n            }\\n            \\n            ans.push_back(\\'!\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116362,
                "title": "c-0-ms-faster-than-100-of-solution-easy-using-hash-table",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string tar) {\\n        vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char,pair<int,int>> mp;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                mp[board[i][j]]={i,j};\\n            }\\n        }\\n        string ans=\"\";\\n        auto r=mp[tar[0]];\\n        int x=r.first;\\n        int y=r.second;\\n        while(x--){\\n            ans+=\"D\";\\n        }\\n        while(y--){\\n            ans+=\"R\";\\n        }\\n        ans+=\"!\";\\n        for(int i=1;i<tar.size();i++){\\n            int x=r.first-mp[tar[i]].first;\\n            int y=r.second-mp[tar[i]].second;\\n            int flag=0;\\n            if(tar[i]==\\'z\\'){\\n                flag=1;\\n            }\\n            r=mp[tar[i]];\\n            if(x==0 and y==0){\\n                ans+=\"!\";\\n                continue;\\n            }\\n            if(x>0){\\n                while(x>0){\\n                    ans+=\"U\";\\n                    x--;\\n                }\\n            }\\n            else{\\n                while(x<0){\\n                    ans+=\"D\";\\n                    x++;\\n                }\\n            }\\n            if(flag==1){\\n                ans.pop_back();\\n            }\\n            if(y>0){\\n                while(y>0){\\n                    ans+=\"L\";\\n                    y--;\\n                }\\n            }\\n            else{\\n                while(y<0){\\n                    ans+=\"R\";\\n                    y++;\\n                }\\n            }\\n            if(flag==1){\\n                ans+=\"D\";\\n            }\\n            ans+=\"!\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string tar) {\\n        vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char,pair<int,int>> mp;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                mp[board[i][j]]={i,j};\\n            }\\n        }\\n        string ans=\"\";\\n        auto r=mp[tar[0]];\\n        int x=r.first;\\n        int y=r.second;\\n        while(x--){\\n            ans+=\"D\";\\n        }\\n        while(y--){\\n            ans+=\"R\";\\n        }\\n        ans+=\"!\";\\n        for(int i=1;i<tar.size();i++){\\n            int x=r.first-mp[tar[i]].first;\\n            int y=r.second-mp[tar[i]].second;\\n            int flag=0;\\n            if(tar[i]==\\'z\\'){\\n                flag=1;\\n            }\\n            r=mp[tar[i]];\\n            if(x==0 and y==0){\\n                ans+=\"!\";\\n                continue;\\n            }\\n            if(x>0){\\n                while(x>0){\\n                    ans+=\"U\";\\n                    x--;\\n                }\\n            }\\n            else{\\n                while(x<0){\\n                    ans+=\"D\";\\n                    x++;\\n                }\\n            }\\n            if(flag==1){\\n                ans.pop_back();\\n            }\\n            if(y>0){\\n                while(y>0){\\n                    ans+=\"L\";\\n                    y--;\\n                }\\n            }\\n            else{\\n                while(y<0){\\n                    ans+=\"R\";\\n                    y++;\\n                }\\n            }\\n            if(flag==1){\\n                ans+=\"D\";\\n            }\\n            ans+=\"!\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116289,
                "title": "simple-typescript-solution-using-a-pre-computed-reverse-map-of-the-character-positions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first though was to use the old school trick of doing the byte offset but I could not remember how to do it typescript/javascript so I opted to do a map approach.\\n\\n# Approach\\nPretty much this is a simple reverse mapping solution of the characters to a position.\\n\\nAnd also uses an array of strings to later concatenate into a single string in order to avoid the recreation of the string every time a character gets addded.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Pre-compute char position map\\nconst charPositions: Map<string, [number, number]> = new  Map<string, [number, number]>();\\nconst alphabet = [\\'abcde\\',\\'fghij\\',\\'klmno\\',\\'pqrst\\',\\'uvwxy\\' , \\'z\\'];\\nfor(let i = 0; i < alphabet.length; i++) {\\n    for(let j = 0; j < alphabet[i].length; j++) {\\n        charPositions.set(alphabet[i][j], [i, j]);\\n    }\\n}\\n\\nfunction alphabetBoardPath(target: string): string {\\n    let curx = 0;\\n    let cury = 0;\\n    let result: string[] = [];\\n    for(let i = 0; i < target.length; i++) {\\n        const [tx, ty] = charPositions.get(target[i]);\\n        let diffx = tx - curx;\\n        let diffy = ty - cury;\\n\\n        // The ordering of the fill operations is important.\\n        // This order handles when the position goes in and out of \\'z\\'.\\n        if(diffx < 0) result.push(...fill(diffx * - 1, \\'U\\'));\\n        if(diffy < 0) result.push(...fill(diffy * -1, \\'L\\'));\\n        \\n        result.push(...fill(diffx, \\'D\\'));\\n        result.push(...fill(diffy, \\'R\\'));\\n\\n        result.push(\\'!\\');\\n\\n        curx = tx;\\n        cury = ty;\\n    }\\n\\n    return result.join(\\'\\');\\n};\\n\\nfunction fill(repeats: number, str: string): string[] {\\n    let result: string[] = [];\\n    while(repeats > 0) {\\n        result.push(str);\\n        repeats--;\\n    }\\n    return result;\\n}\\n```\\n\\n# Alternative faster solution\\nThis solution is the initially faster code that I though about but I could not remember the char encoding liberary.\\nIt is faster but I would not say by that much. The fastest time I saw was 59ms but it\\'s just a bit harder to understand.\\n\\n```typescript\\nlet utf8Encode = new TextEncoder();\\nconst offset = utf8Encode.encode(\\'a\\')[0];\\n\\nfunction alphabetBoardPath(target: string): string {\\n    const targetBytes = utf8Encode.encode(target);\\n    let curx = 0;\\n    let cury = 0;\\n    let result: string[] = [];\\n    for(let i = 0; i < targetBytes.length; i++) {\\n        const linearPosition = targetBytes[i] - offset;\\n        const ty = linearPosition % 5;\\n        const tx = Math.floor(linearPosition / 5);\\n        const diffx = tx - curx;\\n        const diffy = ty - cury;\\n\\n        if(diffx < 0) result.push(\\'U\\'.repeat(diffx * -1));\\n        if(diffy < 0) result.push(\\'L\\'.repeat(diffy * -1));\\n        \\n        if(diffx > 0) result.push(\\'D\\'.repeat(diffx));\\n        if(diffy > 0) result.push(\\'R\\'.repeat(diffy));\\n\\n        result.push(\\'!\\');\\n        curx = tx;\\n        cury = ty;\\n    }\\n\\n    return result.join(\\'\\');\\n}\\n```\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// Pre-compute char position map\\nconst charPositions: Map<string, [number, number]> = new  Map<string, [number, number]>();\\nconst alphabet = [\\'abcde\\',\\'fghij\\',\\'klmno\\',\\'pqrst\\',\\'uvwxy\\' , \\'z\\'];\\nfor(let i = 0; i < alphabet.length; i++) {\\n    for(let j = 0; j < alphabet[i].length; j++) {\\n        charPositions.set(alphabet[i][j], [i, j]);\\n    }\\n}\\n\\nfunction alphabetBoardPath(target: string): string {\\n    let curx = 0;\\n    let cury = 0;\\n    let result: string[] = [];\\n    for(let i = 0; i < target.length; i++) {\\n        const [tx, ty] = charPositions.get(target[i]);\\n        let diffx = tx - curx;\\n        let diffy = ty - cury;\\n\\n        // The ordering of the fill operations is important.\\n        // This order handles when the position goes in and out of \\'z\\'.\\n        if(diffx < 0) result.push(...fill(diffx * - 1, \\'U\\'));\\n        if(diffy < 0) result.push(...fill(diffy * -1, \\'L\\'));\\n        \\n        result.push(...fill(diffx, \\'D\\'));\\n        result.push(...fill(diffy, \\'R\\'));\\n\\n        result.push(\\'!\\');\\n\\n        curx = tx;\\n        cury = ty;\\n    }\\n\\n    return result.join(\\'\\');\\n};\\n\\nfunction fill(repeats: number, str: string): string[] {\\n    let result: string[] = [];\\n    while(repeats > 0) {\\n        result.push(str);\\n        repeats--;\\n    }\\n    return result;\\n}\\n```\n```typescript\\nlet utf8Encode = new TextEncoder();\\nconst offset = utf8Encode.encode(\\'a\\')[0];\\n\\nfunction alphabetBoardPath(target: string): string {\\n    const targetBytes = utf8Encode.encode(target);\\n    let curx = 0;\\n    let cury = 0;\\n    let result: string[] = [];\\n    for(let i = 0; i < targetBytes.length; i++) {\\n        const linearPosition = targetBytes[i] - offset;\\n        const ty = linearPosition % 5;\\n        const tx = Math.floor(linearPosition / 5);\\n        const diffx = tx - curx;\\n        const diffy = ty - cury;\\n\\n        if(diffx < 0) result.push(\\'U\\'.repeat(diffx * -1));\\n        if(diffy < 0) result.push(\\'L\\'.repeat(diffy * -1));\\n        \\n        if(diffx > 0) result.push(\\'D\\'.repeat(diffx));\\n        if(diffy > 0) result.push(\\'R\\'.repeat(diffy));\\n\\n        result.push(\\'!\\');\\n        curx = tx;\\n        cury = ty;\\n    }\\n\\n    return result.join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2179170,
                "title": "simple-c-code-o-n-100-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int row = 0;\\n        string ans = \"\";\\n        int five = 5;\\n        //int tfive = 0;\\n        for(int i = 0; i < target.size(); i++)\\n        {\\n            char ch = target[i];\\n            string s = \"\";\\n            int val = ch-\\'a\\';\\n            int LR = val % 5; \\n            while(LR > row)     //O(5)\\n            {\\n                s += \\'R\\';\\n                row++;\\n            }\\n            while(LR < row)     //O(5)\\n            {\\n                s += \\'L\\';\\n                row--;\\n            }\\n            val++;\\n            while(val > five)     //O(5)\\n            {\\n                s += \\'D\\';\\n                five += 5;\\n            }\\n            int tfive = five-4;\\n            //cout << tfive << \" \";\\n            while(val < tfive)     //O(5)\\n            {\\n                s += \\'U\\';\\n                tfive -= 5;\\n            }\\n            five = tfive+4;\\n            if(i != 0 && target[i-1] == \\'z\\')\\n            {\\n                s.insert(0, \"U\");\\n                int sz = s.size()-1;\\n                s.erase(sz,1);\\n            }\\n            ans += s;\\n            ans += \\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int row = 0;\\n        string ans = \"\";\\n        int five = 5;\\n        //int tfive = 0;\\n        for(int i = 0; i < target.size(); i++)\\n        {\\n            char ch = target[i];\\n            string s = \"\";\\n            int val = ch-\\'a\\';\\n            int LR = val % 5; \\n            while(LR > row)     //O(5)\\n            {\\n                s += \\'R\\';\\n                row++;\\n            }\\n            while(LR < row)     //O(5)\\n            {\\n                s += \\'L\\';\\n                row--;\\n            }\\n            val++;\\n            while(val > five)     //O(5)\\n            {\\n                s += \\'D\\';\\n                five += 5;\\n            }\\n            int tfive = five-4;\\n            //cout << tfive << \" \";\\n            while(val < tfive)     //O(5)\\n            {\\n                s += \\'U\\';\\n                tfive -= 5;\\n            }\\n            five = tfive+4;\\n            if(i != 0 && target[i-1] == \\'z\\')\\n            {\\n                s.insert(0, \"U\");\\n                int sz = s.size()-1;\\n                s.erase(sz,1);\\n            }\\n            ans += s;\\n            ans += \\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2044398,
                "title": "python-one-liner",
                "content": "**zip**\\n\\n```\\nclass Solution:\\n\\tdef alphabetBoardPath_v3(self, target: str) -> str:\\n        return \\'\\'.join([\\'\\'.join([\\'U\\'*(x-xx), \\'L\\'*(y-yy), \\'D\\'*(xx-x), \\'R\\'*(yy-y), \\'!\\']) for (x, y), (xx, yy) in zip([(0, 0)]+[divmod(ord(char) - ord(\\'a\\'), 5) for char in target], [divmod(ord(char) - ord(\\'a\\'), 5) for char in target])])\\n```\\n\\n![image](https://assets.leetcode.com/users/images/64bd36ad-ee47-44b2-a1ff-2fb634933411_1652694082.7600403.png)\\n\\n\\n**pairwise**\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        return \\'\\'.join([\\'\\'.join([\\'U\\'*(x-xx), \\'L\\'*(y-yy), \\'D\\'*(xx-x), \\'R\\'*(yy-y), \\'!\\']) for (x, y), (xx, yy) in pairwise([divmod(ord(char) - ord(\\'a\\'), 5) for char in target]))\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7c144465-bfed-4226-b0b4-578d0777ed5f_1652694140.9233458.png)\\n\\n**Next Submit with the same code:**\\n\\n![image](https://assets.leetcode.com/users/images/4af0622a-b7ea-4e5d-8b8b-d5132d7a446c_1652694236.5079198.png)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\tdef alphabetBoardPath_v3(self, target: str) -> str:\\n        return \\'\\'.join([\\'\\'.join([\\'U\\'*(x-xx), \\'L\\'*(y-yy), \\'D\\'*(xx-x), \\'R\\'*(yy-y), \\'!\\']) for (x, y), (xx, yy) in zip([(0, 0)]+[divmod(ord(char) - ord(\\'a\\'), 5) for char in target], [divmod(ord(char) - ord(\\'a\\'), 5) for char in target])])\\n```\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        return \\'\\'.join([\\'\\'.join([\\'U\\'*(x-xx), \\'L\\'*(y-yy), \\'D\\'*(xx-x), \\'R\\'*(yy-y), \\'!\\']) for (x, y), (xx, yy) in pairwise([divmod(ord(char) - ord(\\'a\\'), 5) for char in target]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021655,
                "title": "easy-java-soln-to-understand",
                "content": "```\\n    public String alphabetBoardPath(String s) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int a=0,b=0,c=0,d=0;\\n        \\n        for(char ch : s.toCharArray())\\n        {\\n            int val = ch - \\'a\\';\\n            \\n            c= val/5;\\n            d= val%5;\\n            \\n            int val1 = c-a;\\n            int val2 = d-b;\\n            boolean istrue =false;\\n            for(int i=0;i<Math.abs(val1);i++)\\n            {    \\n                if(val==25 && i==Math.abs(val1)-1){\\n                    istrue=true;\\n                    continue;\\n                } \\n                if(val1<0) sb.append(\\'U\\');\\n                 else   sb.append(\\'D\\');\\n            }\\n            \\n            \\n            for(int i=0;i<Math.abs(val2);i++)\\n            {\\n                if(val2<0) sb.append(\\'L\\');\\n                 else   sb.append(\\'R\\');\\n            }\\n            \\n            if(istrue) sb.append(\\'D\\');\\n            \\n            a=c;\\n            b=d;\\n            sb.append(\\'!\\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String alphabetBoardPath(String s) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int a=0,b=0,c=0,d=0;\\n        \\n        for(char ch : s.toCharArray())\\n        {\\n            int val = ch - \\'a\\';\\n            \\n            c= val/5;\\n            d= val%5;\\n            \\n            int val1 = c-a;\\n            int val2 = d-b;\\n            boolean istrue =false;\\n            for(int i=0;i<Math.abs(val1);i++)\\n            {    \\n                if(val==25 && i==Math.abs(val1)-1){\\n                    istrue=true;\\n                    continue;\\n                } \\n                if(val1<0) sb.append(\\'U\\');\\n                 else   sb.append(\\'D\\');\\n            }\\n            \\n            \\n            for(int i=0;i<Math.abs(val2);i++)\\n            {\\n                if(val2<0) sb.append(\\'L\\');\\n                 else   sb.append(\\'R\\');\\n            }\\n            \\n            if(istrue) sb.append(\\'D\\');\\n            \\n            a=c;\\n            b=d;\\n            sb.append(\\'!\\');\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1625795,
                "title": "java-not-a-fancy-solution",
                "content": "This may help someone. I felt that this solution was a bit more expressive of my thought process.\\n\\n```\\nclass Solution {\\n    private static final String[] ALPHABET_BOARD = new String[] {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"}; \\n    private static final int[] BOUNDARIES = new int[] {5,4,4,4,4};\\n    public String alphabetBoardPath(String target) {\\n        Map<Character, int[]> map = new HashMap<>();\\n        for (int i = 0; i < ALPHABET_BOARD.length; i++) {\\n            String row = ALPHABET_BOARD[i];\\n            for (int j = 0; j < row.length(); j++) {\\n                map.put(row.charAt(j), new int[]{i,j});\\n            }\\n        }\\n        \\n        StringBuilder direction = new StringBuilder();\\n        \\n        int row = 0, col = 0;\\n        for (char c : target.toCharArray()) {\\n            int[] cLocation = map.get(c);\\n            int newRow = cLocation[0], newCol = cLocation[1];\\n            while (row != newRow || col != newCol) {\\n                while (row < newRow && row < BOUNDARIES[col]) {\\n                    direction.append(\\'D\\');\\n                    row++;\\n                 }\\n            \\n                while (row > newRow) {\\n                    direction.append(\\'U\\');\\n                    row--;\\n                }\\n                \\n                while (col < newCol) {\\n                    direction.append(\\'R\\');\\n                    col++;\\n\\n                }\\n            \\n                while (col > newCol) {\\n                    direction.append(\\'L\\');\\n                    col--;\\n                }\\n            }\\n\\n            direction.append(\\'!\\');\\n        }\\n        \\n        return direction.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static final String[] ALPHABET_BOARD = new String[] {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"}; \\n    private static final int[] BOUNDARIES = new int[] {5,4,4,4,4};\\n    public String alphabetBoardPath(String target) {\\n        Map<Character, int[]> map = new HashMap<>();\\n        for (int i = 0; i < ALPHABET_BOARD.length; i++) {\\n            String row = ALPHABET_BOARD[i];\\n            for (int j = 0; j < row.length(); j++) {\\n                map.put(row.charAt(j), new int[]{i,j});\\n            }\\n        }\\n        \\n        StringBuilder direction = new StringBuilder();\\n        \\n        int row = 0, col = 0;\\n        for (char c : target.toCharArray()) {\\n            int[] cLocation = map.get(c);\\n            int newRow = cLocation[0], newCol = cLocation[1];\\n            while (row != newRow || col != newCol) {\\n                while (row < newRow && row < BOUNDARIES[col]) {\\n                    direction.append(\\'D\\');\\n                    row++;\\n                 }\\n            \\n                while (row > newRow) {\\n                    direction.append(\\'U\\');\\n                    row--;\\n                }\\n                \\n                while (col < newCol) {\\n                    direction.append(\\'R\\');\\n                    col++;\\n\\n                }\\n            \\n                while (col > newCol) {\\n                    direction.append(\\'L\\');\\n                    col--;\\n                }\\n            }\\n\\n            direction.append(\\'!\\');\\n        }\\n        \\n        return direction.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569761,
                "title": "clean-and-fast-0ms-cpp",
                "content": "Travel along the axes to cover the path from `target[i]` to `target[i+1]`.\\n\\nWhen visiting `z`, be careful to move horizontally before going vertically.\\nOtherwise, in all cases we go vertically first (this handles the case when the source is `z`)\\n``` cpp\\nclass Solution {\\npublic:\\n    pair<int, int> pos(char ch) {\\n        int val = ch - \\'a\\';\\n        int j = val % 5;\\n        int i = val / 5;\\n        return {i,j};\\n    }\\n    \\n    string path(pair<int, int> startPos, pair<int, int> endPos) {\\n        string horizontal, vertical;\\n        int dx = endPos.first - startPos.first;\\n        if (dx > 0)\\n            vertical = string(dx, \\'D\\');\\n        else if (dx < 0)\\n            vertical = string(-dx, \\'U\\');\\n        \\n        int dy = endPos.second - startPos.second;\\n        if (dy > 0)\\n            horizontal = string(dy, \\'R\\');\\n        else if (dy < 0)\\n            horizontal = string(-dy, \\'L\\');\\n        \\n        if (endPos == pos(\\'z\\')) {\\n            return horizontal + vertical;\\n        } else {\\n            return vertical + horizontal;\\n        }\\n    }\\n\\n    string alphabetBoardPath(string target) {\\n        string ans;\\n        pair<int, int> currPos = {0,0};\\n        \\n        for (int i = 0; i < target.length(); i++) {\\n            pair<int, int> endPos = pos(target[i]);\\n            ans.append(path(currPos, endPos));\\n            ans.push_back(\\'!\\');\\n            currPos = endPos;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` cpp\\nclass Solution {\\npublic:\\n    pair<int, int> pos(char ch) {\\n        int val = ch - \\'a\\';\\n        int j = val % 5;\\n        int i = val / 5;\\n        return {i,j};\\n    }\\n    \\n    string path(pair<int, int> startPos, pair<int, int> endPos) {\\n        string horizontal, vertical;\\n        int dx = endPos.first - startPos.first;\\n        if (dx > 0)\\n            vertical = string(dx, \\'D\\');\\n        else if (dx < 0)\\n            vertical = string(-dx, \\'U\\');\\n        \\n        int dy = endPos.second - startPos.second;\\n        if (dy > 0)\\n            horizontal = string(dy, \\'R\\');\\n        else if (dy < 0)\\n            horizontal = string(-dy, \\'L\\');\\n        \\n        if (endPos == pos(\\'z\\')) {\\n            return horizontal + vertical;\\n        } else {\\n            return vertical + horizontal;\\n        }\\n    }\\n\\n    string alphabetBoardPath(string target) {\\n        string ans;\\n        pair<int, int> currPos = {0,0};\\n        \\n        for (int i = 0; i < target.length(); i++) {\\n            pair<int, int> endPos = pos(target[i]);\\n            ans.append(path(currPos, endPos));\\n            ans.push_back(\\'!\\');\\n            currPos = endPos;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562883,
                "title": "c-0ms-100-simple-easy-small",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Alphabet Board Path.\\nMemory Usage: 8.1 MB, less than 9.71% of C++ online submissions for Alphabet Board Path.\\n**General idea :**\\n**1.** Only once construct table of all minimal movies from current letter to another\\n**2.** Will movie through target and  add variant from table\\n```\\nclass Solution {\\npublic:\\n  string alphabetBoardPath(string target) {\\n    vector<vector<string>>table(26,vector<string>(26));\\n    \\n    for(int i = 0; i != 26; i++)\\n      for(int j = i+1, k = i/; j != 26; j++){\\n        int dy = j/5 - i/5, dx = j%5 - i%5;\\n        table[i][j] = (dx > 0? string(dx,\\'R\\') : string(-dx,\\'L\\')) + string(dy,\\'D\\');\\n        table[j][i] = string(dy,\\'U\\') + (dx > 0? string(dx,\\'L\\') : string(-dx,\\'R\\'));\\n      }\\n    \\n    string answer;\\n    for(int i = 0, j = 0, k; j != target.size(); i = k)\\n      answer += table[i][k = target[j++] - \\'a\\'] + \\'!\\';\\n    \\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string alphabetBoardPath(string target) {\\n    vector<vector<string>>table(26,vector<string>(26));\\n    \\n    for(int i = 0; i != 26; i++)\\n      for(int j = i+1, k = i/; j != 26; j++){\\n        int dy = j/5 - i/5, dx = j%5 - i%5;\\n        table[i][j] = (dx > 0? string(dx,\\'R\\') : string(-dx,\\'L\\')) + string(dy,\\'D\\');\\n        table[j][i] = string(dy,\\'U\\') + (dx > 0? string(dx,\\'L\\') : string(-dx,\\'R\\'));\\n      }\\n    \\n    string answer;\\n    for(int i = 0, j = 0, k; j != target.size(); i = k)\\n      answer += table[i][k = target[j++] - \\'a\\'] + \\'!\\';\\n    \\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548280,
                "title": "easy-to-understand-java-0ms-solution-with-explanation",
                "content": "class Solution {\\n    \\n\\tpublic String alphabetBoardPath(String target) {\\n        int row = 0 , col = 0; // mark current row and current col\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(char ch : target.toCharArray()){\\n\\t\\t\\t//find target row , target col , dist from current row and current col\\n            int targetRow = (ch-97)/5 , targetCol = (ch-97)%5 , distRow = targetRow - row , distCol = targetCol - col; \\n\\t\\t\\t\\n            //Now the main idea is to check if we want to move up or down\\n\\t\\t\\t//If we want to move up we must consider the \\'z\\' case for which we first need to move up then left or right\\n\\t\\t\\t//If we want to move down we must again consider \\'z\\' case for which we fisrt need to move left or right then move down\\n\\t\\t\\t\\n            if(distRow < 0){\\n                res.append(\"U\".repeat((int)Math.abs(distRow))); //first move up because we can be at \\'z\\'\\n                res.append((distCol > 0 ? \"R\" : \"L\").repeat((int)Math.abs(distCol))); //then move left or right\\n            }\\n            \\n            else{\\n                res.append((distCol > 0 ? \"R\" : \"L\").repeat((int)Math.abs(distCol))); //first move left or right because target might be \\'z\\'\\n                res.append(\"D\".repeat((int)Math.abs(distRow)));//then move down\\n            }\\n            \\n            res.append(\\'!\\'); //append ! to specify we found the target\\n            \\n\\t\\t\\t//change current row and current col\\n            row = targetRow; \\n            col = targetCol;\\n        }\\n        \\n        return res.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\tpublic String alphabetBoardPath(String target) {\\n        int row = 0 , col = 0; // mark current row and current col\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(char ch : target.toCharArray()){\\n\\t\\t\\t//find target row , target col , dist from current row and current col\\n            int targetRow = (ch-97)/5 , targetCol = (ch-97)%5 , distRow = targetRow - row , distCol = targetCol - col; \\n\\t\\t\\t\\n            //Now the main idea is to check if we want to move up or down\\n\\t\\t\\t//If we want to move up we must consider the \\'z\\' case for which we first need to move up then left or right\\n\\t\\t\\t//If we want to move down we must again consider \\'z\\' case for which we fisrt need to move left or right then move down\\n\\t\\t\\t\\n            if(distRow < 0){\\n                res.append(\"U\".repeat((int)Math.abs(distRow))); //first move up because we can be at \\'z\\'\\n                res.append((distCol > 0 ? \"R\" : \"L\").repeat((int)Math.abs(distCol))); //then move left or right\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1530782,
                "title": "easy-c-o-n",
                "content": "1. because the characters\\' positions on the board are fixed, **we can find the minimal number of steps from one character to another in O(1) time**\\n2. for example, let the current character be c and and the next be n, then their positions on board are [(c-\\'a\\')/5,(c-\\'a\\')%5] and [(n-\\'a\\')/5,(n-\\'a\\')%5]\\n3. after knowing the position, we know the steps to move from the current char to the next;\\n4. the only exception is z, when moving to z, we should move horizontally first, then vertically; when moving from z to other characters, we move vertically first then horizontally\\n```\\n\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        \\n        int lastx = 0;\\n        int lasty = 0;\\n        for(int i = 0; i < target.size(); ++i){\\n            int x = (target[i]-\\'a\\')/5 - lastx;\\n            int y = (target[i]-\\'a\\')%5 - lasty;\\n            if(lastx == 5){\\n                move(false,x);\\n                move(true,y);\\n            }\\n            else{\\n                move(true,y);\\n                move(false,x);\\n            }\\n            ans += \\'!\\';\\n            lastx = (target[i]-\\'a\\')/5;\\n            lasty = (target[i]-\\'a\\')%5;\\n        }\\n        return ans;\\n    }\\n    void move(bool horizontal, int steps){\\n        if(horizontal){\\n            if(steps > 0){\\n                string temp(steps,\\'R\\');\\n                ans += temp;\\n            }\\n            else if(steps < 0){\\n                string temp(-steps,\\'L\\');\\n                ans += temp;\\n            }\\n        }\\n        else{\\n            if(steps > 0){\\n                string temp(steps,\\'D\\');\\n                ans += temp;\\n            }\\n            else if(steps < 0){\\n                string temp(-steps,\\'U\\');\\n                ans += temp;\\n            }\\n        }\\n    }\\nprivate:\\n    string ans = \"\";\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        \\n        int lastx = 0;\\n        int lasty = 0;\\n        for(int i = 0; i < target.size(); ++i){\\n            int x = (target[i]-\\'a\\')/5 - lastx;\\n            int y = (target[i]-\\'a\\')%5 - lasty;\\n            if(lastx == 5){\\n                move(false,x);\\n                move(true,y);\\n            }\\n            else{\\n                move(true,y);\\n                move(false,x);\\n            }\\n            ans += \\'!\\';\\n            lastx = (target[i]-\\'a\\')/5;\\n            lasty = (target[i]-\\'a\\')%5;\\n        }\\n        return ans;\\n    }\\n    void move(bool horizontal, int steps){\\n        if(horizontal){\\n            if(steps > 0){\\n                string temp(steps,\\'R\\');\\n                ans += temp;\\n            }\\n            else if(steps < 0){\\n                string temp(-steps,\\'L\\');\\n                ans += temp;\\n            }\\n        }\\n        else{\\n            if(steps > 0){\\n                string temp(steps,\\'D\\');\\n                ans += temp;\\n            }\\n            else if(steps < 0){\\n                string temp(-steps,\\'U\\');\\n                ans += temp;\\n            }\\n        }\\n    }\\nprivate:\\n    string ans = \"\";\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507075,
                "title": "javascript-beats-100",
                "content": "```\\nvar alphabetBoardPath = function(target) {\\n    let board_rows = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n    let board_cols = [\"afkpuz\", \"bglqv\", \"chmrw\", \"dinsx\", \"ejoty\"]\\n    let row = t => Math.floor(\"abcdefghijklmnopqrstuvwxyz\".indexOf(t) / 5)\\n    let col = t => t == \"z\" ? 0 : Math.floor(\"afkpubglqvchmrwdinsxejoty\".indexOf(t) / 5)\\n    \\n    let pos = [0,0]\\n    let str = \"\"\\n    for (var i of target) {\\n        let dify = row(i) - pos[0]\\n        pos[0] += dify\\n        dify = dify > 0 ? \"D\".repeat(dify) : \"U\".repeat(Math.abs(dify))\\n        let difx = col(i) - pos[1]\\n        pos[1] += difx\\n        difx = difx > 0 ? \"R\".repeat(difx) : \"L\".repeat(Math.abs(difx))\\n        str += (i == \"z\" ? difx + dify : dify + difx) + \"!\"\\n    }\\n    return str\\n};```",
                "solutionTags": [],
                "code": "```\\nvar alphabetBoardPath = function(target) {\\n    let board_rows = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n    let board_cols = [\"afkpuz\", \"bglqv\", \"chmrw\", \"dinsx\", \"ejoty\"]\\n    let row = t => Math.floor(\"abcdefghijklmnopqrstuvwxyz\".indexOf(t) / 5)\\n    let col = t => t == \"z\" ? 0 : Math.floor(\"afkpubglqvchmrwdinsxejoty\".indexOf(t) / 5)\\n    \\n    let pos = [0,0]\\n    let str = \"\"\\n    for (var i of target) {\\n        let dify = row(i) - pos[0]\\n        pos[0] += dify\\n        dify = dify > 0 ? \"D\".repeat(dify) : \"U\".repeat(Math.abs(dify))\\n        let difx = col(i) - pos[1]\\n        pos[1] += difx\\n        difx = difx > 0 ? \"R\".repeat(difx) : \"L\".repeat(Math.abs(difx))\\n        str += (i == \"z\" ? difx + dify : dify + difx) + \"!\"\\n    }\\n    return str\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 1497464,
                "title": "java-beat-100-with-comments",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] current = new int[]{0, 0}, next;\\n        \\n        for (int idx = 0; idx < target.length(); idx++) {\\n            next = getCoordinate(target.charAt(idx));\\n            if (current[1] < next[1]) {\\n                // If going right, always go up/down first and then go right. This will cover corner case of \\'z\\' being the source.\\n                append(sb, Math.abs(current[0] - next[0]), current[0] < next[0] ? \\'D\\' : \\'U\\');\\n                append(sb, next[1] - current[1], \\'R\\');\\n            } else {\\n                // If going left, always go left first and then go up/down. This will cover corner case of \\'z\\' being the destination.\\n                append(sb, current[1] - next[1], \\'L\\');\\n                append(sb, Math.abs(current[0] - next[0]), current[0] < next[0] ? \\'D\\' : \\'U\\');\\n            }\\n            \\n            sb.append(\\'!\\');\\n            current = next;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private int[] getCoordinate(char ch) {\\n        return new int[]{(ch - \\'a\\') / 5, (ch - \\'a\\') % 5};\\n    }\\n    \\n    private void append(StringBuilder sb, int steps, char ch) {\\n        for (int count = 0; count < steps; count++) {\\n            sb.append(ch);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] current = new int[]{0, 0}, next;\\n        \\n        for (int idx = 0; idx < target.length(); idx++) {\\n            next = getCoordinate(target.charAt(idx));\\n            if (current[1] < next[1]) {\\n                // If going right, always go up/down first and then go right. This will cover corner case of \\'z\\' being the source.\\n                append(sb, Math.abs(current[0] - next[0]), current[0] < next[0] ? \\'D\\' : \\'U\\');\\n                append(sb, next[1] - current[1], \\'R\\');\\n            } else {\\n                // If going left, always go left first and then go up/down. This will cover corner case of \\'z\\' being the destination.\\n                append(sb, current[1] - next[1], \\'L\\');\\n                append(sb, Math.abs(current[0] - next[0]), current[0] < next[0] ? \\'D\\' : \\'U\\');\\n            }\\n            \\n            sb.append(\\'!\\');\\n            current = next;\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private int[] getCoordinate(char ch) {\\n        return new int[]{(ch - \\'a\\') / 5, (ch - \\'a\\') % 5};\\n    }\\n    \\n    private void append(StringBuilder sb, int steps, char ch) {\\n        for (int count = 0; count < steps; count++) {\\n            sb.append(ch);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326022,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    \\n    private int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    char[] letters = new char[]{\\'U\\', \\'D\\', \\'L\\', \\'R\\'};\\n    \\n    char[][] board = new char[][] {\\n        {\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n        {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n        {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n        {\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n        {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n        {\\'z\\', \\'0\\', \\'0\\', \\'0\\', \\'0\\'}\\n    };\\n    \\n\\n    public String alphabetBoardPath(String target) {\\n        Queue<Node> queue = new LinkedList<>();\\n        Node start = new Node(0, 0, 0, \"\");\\n        queue.add(start);\\n        \\n        while (!queue.isEmpty()) {\\n            Node curr = queue.poll();\\n            \\n            while (curr.pos < target.length() && board[curr.r][curr.c] == target.charAt(curr.pos)) {\\n                curr.path += \"!\";\\n                curr.pos++;\\n                queue.clear();\\n            }\\n                        \\n            if (curr.pos == target.length()) {\\n                return curr.path;\\n            }\\n            \\n            for (int i = 0; i < 4; i++) {\\n                int[] dir = dirs[i];\\n                int x = curr.r + dir[0];\\n                int y = curr.c + dir[1];\\n                \\n                if (isValid(x, y)) {\\n                    Node next = new Node(x, y, curr.pos, curr.path + letters[i]);\\n                    queue.add(next);\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n        \\n    }\\n    \\n    private boolean isValid(int r, int c) {\\n        return (r >= 0 && r <= 4 && c >= 0 && c <= 4) || (r == 5 && c == 0);\\n    }\\n        \\n}\\n\\nclass Node {\\n    int r;\\n    int c;\\n    int pos;\\n    String path;\\n    \\n    public Node(int r, int c, int pos, String path) {\\n        this.r = r;\\n        this.c = c;\\n        this.pos = pos;\\n        this.path = path;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    private int[][] dirs = new int[][]{{-1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 1238082,
                "title": "simple-explained-javascript-solution",
                "content": "```\\n/**\\n * @param {string} target\\n * @return {string}\\n */\\nvar alphabetBoardPath = function(target) {\\n    let map={},row,col,path=\"\",pos=[0,0],char,direction,distance,sign;\\n    for(let i=0;i<26;i++){\\n        col = i%5;\\n        row = Math.floor(i/5);\\n        map[String.fromCharCode(\"a\".charCodeAt(0)+i)]=[row,col]\\n    }\\n    for(let i=0;i<target.length;i++){\\n        char = target[i];\\n        //Verticle movement Process U,D\\n        if(map[char][0]>pos[0]){\\n            sign = 1;\\n            direction = \"D\";\\n        }else{\\n            sign = -1;\\n            direction = \"U\";\\n        }\\n        distance = Math.abs(map[char][0]-pos[0]);\\n        for(let p=1;p<=distance;p++){\\n            if(pos[0]+sign===5 && pos[1]>0){/*Checking the corner case, when we\\xA0have no cell right size to \\'z\\'. Then we need to move in the left-most cell on the current row. \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ***NOTE: As we are doing the verticle movement first so we just need to take care of this corner case here only. We need not to take care while doing the horizontal movement.*/\\n                let temp = pos[1];\\n                for(let e=0;e<temp;e++){\\n                    path+=\"L\";\\n                    pos[1]--;\\n                }\\n            }\\n            pos[0] = pos[0] + sign;\\n            path+=direction;\\n        }\\n        //Horizontal moment, Process L,R\\n        if(map[char][1]>pos[1]){\\n            direction = \"R\";\\n        }else{\\n            direction = \"L\";\\n        }\\n        distance = Math.abs(map[char][1]-pos[1]);\\n        for(let p=1;p<=distance;p++){\\n            path+=direction;\\n        }\\n        path+=\"!\";\\n        pos[1]=map[char][1];\\n    }\\n    return path;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} target\\n * @return {string}\\n */\\nvar alphabetBoardPath = function(target) {\\n    let map={},row,col,path=\"\",pos=[0,0],char,direction,distance,sign;\\n    for(let i=0;i<26;i++){\\n        col = i%5;\\n        row = Math.floor(i/5);\\n        map[String.fromCharCode(\"a\".charCodeAt(0)+i)]=[row,col]\\n    }\\n    for(let i=0;i<target.length;i++){\\n        char = target[i];\\n        //Verticle movement Process U,D\\n        if(map[char][0]>pos[0]){\\n            sign = 1;\\n            direction = \"D\";\\n        }else{\\n            sign = -1;\\n            direction = \"U\";\\n        }\\n        distance = Math.abs(map[char][0]-pos[0]);\\n        for(let p=1;p<=distance;p++){\\n            if(pos[0]+sign===5 && pos[1]>0){/*Checking the corner case, when we\\xA0have no cell right size to \\'z\\'. Then we need to move in the left-most cell on the current row. \\n\\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 ***NOTE: As we are doing the verticle movement first so we just need to take care of this corner case here only. We need not to take care while doing the horizontal movement.*/\\n                let temp = pos[1];\\n                for(let e=0;e<temp;e++){\\n                    path+=\"L\";\\n                    pos[1]--;\\n                }\\n            }\\n            pos[0] = pos[0] + sign;\\n            path+=direction;\\n        }\\n        //Horizontal moment, Process L,R\\n        if(map[char][1]>pos[1]){\\n            direction = \"R\";\\n        }else{\\n            direction = \"L\";\\n        }\\n        distance = Math.abs(map[char][1]-pos[1]);\\n        for(let p=1;p<=distance;p++){\\n            path+=direction;\\n        }\\n        path+=\"!\";\\n        pos[1]=map[char][1];\\n    }\\n    return path;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1146649,
                "title": "python-solution-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/fbaa8d3f-68ec-4375-a8c6-fa517d7eb1cf_1617782323.1195993.png)\\n\\'\\'\\'class Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        \\n        path = \"\"\\n        n = len(target)\\n        abs_pos = {}\\n        inetial_pos = [0, 0]\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        for ele in board:\\n            for char in ele:\\n                dn = board.index(ele)\\n                rn = ele.index(char)\\n                abs_pos.update({char: [dn, rn]})\\n \\n        \\n        def rel_pos(cur, nxt):\\n            return [nxt[0] - cur[0], nxt[1] - cur[1]]\\n        \\n        def update_path(new_pos):\\n            temp_path = \"\"\\n            if new_pos[0] > 0:\\n  \\n                temp_path += \"D\"*new_pos[0]\\n            elif new_pos[0] < 0:\\n  \\n                temp_path += \"U\"*abs(new_pos[0])\\n            else: \\n                pass\\n            if new_pos[1] > 0:\\n          \\n                temp_path += \"R\"*new_pos[1]\\n            elif new_pos[1] < 0:\\n          \\n                temp_path += \"L\"*abs(new_pos[1])\\n            else:\\n                pass\\n            temp_path += \"!\"\\n            return temp_path\\n        \\n        for i in range(n):\\n            if i == 0:\\n                relative_pos = abs_pos[target[i]]\\n            else:\\n                relative_pos = rel_pos(abs_pos[target[i-1]], abs_pos[target[i]])\\n                print(\"relative position of {} wrt {}: {}\".format(target[i], target[i-1], relative_pos))\\n            print(relative_pos)\\n            temp = update_path(relative_pos)\\n            dm = temp.count(\"D\")\\n            lm = temp.count(\"L\")\\n            rm = temp.count(\"R\")\\n            um = temp.count(\"U\")\\n            if target[i] == \"z\" and target[i-1] == \"z\":\\n                pass\\n            elif target[i] == \"z\":\\n                \\n                temp = \"L\"*lm + \"D\"*dm + \"R\"*rm + \"U\"*um + \"!\"\\n            elif target[i-1] == \"z\":\\n                up_moves = temp.count(\"U\")\\n                right_moves = temp.count(\"R\")\\n                temp = \"U\"*up_moves + \"R\"*right_moves + \"L\"*lm + \"D\"*dm + \"!\"\\n            print(\"updating path... {}\".format(path))\\n            path += temp\\n        return path\\n                \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        \\n        path = \"\"\\n        n = len(target)\\n        abs_pos = {}",
                "codeTag": "Java"
            },
            {
                "id": 1128531,
                "title": "python-greedy",
                "content": "# Idea\\nWe essentially move greedily towards the next position all the time, only making sure to avoid invalid moves because of a position of `\\'z\\'` character. To avoid illegal moves, if we are going down, we first do the necessary horizontal moves and then vertical. When we go up we first do the vertical move and then the horizontal one.\\n```\\ndef alphabetBoardPath(self, target: str) -> str:\\n\\txchars = [\\'U\\', \\'D\\']\\n\\tychars = [\\'L\\', \\'R\\']\\n\\tposdict = {chr(ord(\\'a\\') + i):divmod(i, 5) for i in range(26)}\\n\\tx, y = 0, 0\\n\\tmoves = []\\n\\tfor ch in target:\\n\\t\\tnx, ny = posdict[ch]\\n\\t\\tymove = ychars[ny > y] * abs(ny - y)\\n\\t\\txmove = xchars[nx > x] * abs(nx - x)\\n\\t\\tmoves.append(((ymove + xmove) if nx > x else (xmove + ymove)) + \\'!\\')\\n\\t\\tx, y = nx, ny\\n\\n\\treturn \\'\\'.join(moves)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef alphabetBoardPath(self, target: str) -> str:\\n\\txchars = [\\'U\\', \\'D\\']\\n\\tychars = [\\'L\\', \\'R\\']\\n\\tposdict = {chr(ord(\\'a\\') + i):divmod(i, 5) for i in range(26)}\\n\\tx, y = 0, 0\\n\\tmoves = []\\n\\tfor ch in target:\\n\\t\\tnx, ny = posdict[ch]\\n\\t\\tymove = ychars[ny > y] * abs(ny - y)\\n\\t\\txmove = xchars[nx > x] * abs(nx - x)\\n\\t\\tmoves.append(((ymove + xmove) if nx > x else (xmove + ymove)) + \\'!\\')\\n\\t\\tx, y = nx, ny\\n\\n\\treturn \\'\\'.join(moves)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1106759,
                "title": "java-0-ms-using-manhattan-distance",
                "content": "```\\nclass Solution {\\n    StringBuilder sb;\\n    public String alphabetBoardPath(String target) {\\n        int curr = 0, next=0, r1=0, c1=0, r2=0, c2=0;\\n        sb = new StringBuilder();\\n        for(int j=0; j<target.length(); j++){\\n            // get the next Character\\n            next = target.charAt(j)-\\'a\\';\\n            \\n            // get the columns and rows for manhattan distance Calculation\\n            c2 = next%5; r2 = next/5;\\n            c1 = curr%5; r1 = curr/5;\\n            // if char is \\'Z\\' then move up first then move sideways\\n            if(curr == 25){\\n                addChar(r1-r2, \\'D\\', \\'U\\');\\n                addChar(c1-c2, \\'R\\', \\'L\\');\\n            }else{\\n                addChar(c1-c2, \\'R\\', \\'L\\');\\n                addChar(r1-r2, \\'D\\', \\'U\\');\\n            }\\n            sb.append(\\'!\\');\\n            curr = next;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public void addChar(int diff, char ch1, char ch2){\\n        if(diff<0){\\n            for(int i=0; i>diff; i--){\\n                sb.append(ch1);\\n            }\\n        }else if(diff>0){\\n            for(int i=0; i<diff; i++){\\n                sb.append(ch2);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    StringBuilder sb;\\n    public String alphabetBoardPath(String target) {\\n        int curr = 0, next=0, r1=0, c1=0, r2=0, c2=0;\\n        sb = new StringBuilder();\\n        for(int j=0; j<target.length(); j++){\\n            // get the next Character\\n            next = target.charAt(j)-\\'a\\';\\n            \\n            // get the columns and rows for manhattan distance Calculation\\n            c2 = next%5; r2 = next/5;\\n            c1 = curr%5; r1 = curr/5;\\n            // if char is \\'Z\\' then move up first then move sideways\\n            if(curr == 25){\\n                addChar(r1-r2, \\'D\\', \\'U\\');\\n                addChar(c1-c2, \\'R\\', \\'L\\');\\n            }else{\\n                addChar(c1-c2, \\'R\\', \\'L\\');\\n                addChar(r1-r2, \\'D\\', \\'U\\');\\n            }\\n            sb.append(\\'!\\');\\n            curr = next;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public void addChar(int diff, char ch1, char ch2){\\n        if(diff<0){\\n            for(int i=0; i>diff; i--){\\n                sb.append(ch1);\\n            }\\n        }else if(diff>0){\\n            for(int i=0; i<diff; i++){\\n                sb.append(ch2);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101180,
                "title": "java-0-ms-o-n-some-what-bigger-but-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private StringBuilder res;\\n    public String alphabetBoardPath(String target) {\\n        MyMap[] map=new MyMap[26];\\n        setPosition(map);\\n        \\n        res=new StringBuilder();\\n        \\n        char[] str=target.toCharArray();\\n        int n=str.length;\\n        \\n        makeDecision(0,0,map[str[0]-\\'a\\'].row,map[str[0]-\\'a\\'].col);\\n        res.append(\\'!\\');\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(str[i]==\\'z\\'){\\n                makeDecisionForZ(map[str[i]-\\'a\\'].row,map[str[i]-\\'a\\'].col,map[str[i+1]-\\'a\\'].row,map[str[i+1]-\\'a\\'].col);\\n            }else{\\n                makeDecision(map[str[i]-\\'a\\'].row,map[str[i]-\\'a\\'].col,map[str[i+1]-\\'a\\'].row,map[str[i+1]-\\'a\\'].col);\\n            }\\n            res.append(\\'!\\');\\n        }\\n        return new String(res);\\n        //return \"RDD!RRRUU!!DDD!\";\\n    }\\n    \\n    private void makeDecision(int srow,int scol,int frow,int fcol){\\n        \\n        if(fcol - scol < 0){// if target character and source character column is negative then target character is exist LEFT of source character\\n            add(Math.abs(fcol-scol),\\'L\\');\\n        }else if(fcol - scol >= 0){// if target character and source character column is Positive then target character is exist RIGHT of source character\\n            add(Math.abs(fcol-scol),\\'R\\');\\n        }\\n\\n        if(frow - srow < 0){// if target character and source character row is negative then target character is exist UP of source character\\n            add(Math.abs(frow-srow),\\'U\\');\\n        }else if(frow-srow >= 0){// if target character and source character row is negative then target character is exist DOWN of source character\\n            add(Math.abs(frow-srow),\\'D\\');\\n        }\\n    }\\n    \\n    private void makeDecisionForZ(int srow,int scol,int frow,int fcol){\\n       // since z is last corner character if i want to go any where from z then i have first go upward and then rightward there is no chance to go down and left .\\n            add(Math.abs(frow-srow),\\'U\\');\\n            add(Math.abs(fcol-scol),\\'R\\');\\n    }\\n    \\n    private void add(int n,char c){\\n        for(int i=0;i<n;i++){\\n            res.append(c);\\n        }\\n    }\\n    \\n    private void setPosition(MyMap[] map){\\n\\t// This function is to store all the position of character in array. Declaration of MyMap is below this function\\n        char c=\\'a\\';\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<5;j++){\\n                map[c-\\'a\\']=new MyMap(c,i,j);\\n                c++;\\n            }\\n        }\\n        map[c-\\'a\\']=new MyMap(c,5,0);\\n    }\\n}\\nclass MyMap{\\n    char val;\\n    int row;\\n    int col;\\n    MyMap(char val,int row,int col){\\n        this.val=val;\\n        this.row=row;\\n        this.col=col;\\n    }\\n}\\n/* \\n\\n\\nif(fcol - scol < 0){\\n    L\\n}else if(fcol - scol >= 0){\\n    R\\n}\\n\\n\\n\\nif(frow - srow < 0){\\n    U\\n}else if(frow-srow >= 0){\\n    D\\n}\\n\\n\\n\\n*/\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private StringBuilder res;\\n    public String alphabetBoardPath(String target) {\\n        MyMap[] map=new MyMap[26];\\n        setPosition(map);\\n        \\n        res=new StringBuilder();\\n        \\n        char[] str=target.toCharArray();\\n        int n=str.length;\\n        \\n        makeDecision(0,0,map[str[0]-\\'a\\'].row,map[str[0]-\\'a\\'].col);\\n        res.append(\\'!\\');\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(str[i]==\\'z\\'){\\n                makeDecisionForZ(map[str[i]-\\'a\\'].row,map[str[i]-\\'a\\'].col,map[str[i+1]-\\'a\\'].row,map[str[i+1]-\\'a\\'].col);\\n            }else{\\n                makeDecision(map[str[i]-\\'a\\'].row,map[str[i]-\\'a\\'].col,map[str[i+1]-\\'a\\'].row,map[str[i+1]-\\'a\\'].col);\\n            }\\n            res.append(\\'!\\');\\n        }\\n        return new String(res);\\n        //return \"RDD!RRRUU!!DDD!\";\\n    }\\n    \\n    private void makeDecision(int srow,int scol,int frow,int fcol){\\n        \\n        if(fcol - scol < 0){// if target character and source character column is negative then target character is exist LEFT of source character\\n            add(Math.abs(fcol-scol),\\'L\\');\\n        }else if(fcol - scol >= 0){// if target character and source character column is Positive then target character is exist RIGHT of source character\\n            add(Math.abs(fcol-scol),\\'R\\');\\n        }\\n\\n        if(frow - srow < 0){// if target character and source character row is negative then target character is exist UP of source character\\n            add(Math.abs(frow-srow),\\'U\\');\\n        }else if(frow-srow >= 0){// if target character and source character row is negative then target character is exist DOWN of source character\\n            add(Math.abs(frow-srow),\\'D\\');\\n        }\\n    }\\n    \\n    private void makeDecisionForZ(int srow,int scol,int frow,int fcol){\\n       // since z is last corner character if i want to go any where from z then i have first go upward and then rightward there is no chance to go down and left .\\n            add(Math.abs(frow-srow),\\'U\\');\\n            add(Math.abs(fcol-scol),\\'R\\');\\n    }\\n    \\n    private void add(int n,char c){\\n        for(int i=0;i<n;i++){\\n            res.append(c);\\n        }\\n    }\\n    \\n    private void setPosition(MyMap[] map){\\n\\t// This function is to store all the position of character in array. Declaration of MyMap is below this function\\n        char c=\\'a\\';\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<5;j++){\\n                map[c-\\'a\\']=new MyMap(c,i,j);\\n                c++;\\n            }\\n        }\\n        map[c-\\'a\\']=new MyMap(c,5,0);\\n    }\\n}\\nclass MyMap{\\n    char val;\\n    int row;\\n    int col;\\n    MyMap(char val,int row,int col){\\n        this.val=val;\\n        this.row=row;\\n        this.col=col;\\n    }\\n}\\n/* \\n\\n\\nif(fcol - scol < 0){\\n    L\\n}else if(fcol - scol >= 0){\\n    R\\n}\\n\\n\\n\\nif(frow - srow < 0){\\n    U\\n}else if(frow-srow >= 0){\\n    D\\n}\\n\\n\\n\\n*/\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064369,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    char[][] board = new char[][]{{\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'},{\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'}, {\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'}, {\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'},{\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'} ,{\\'z\\'}};\\n    int[][] dirs = new int[][]{{0,1},{1,0},{-1,0},{0,-1}};\\n    String[] sDir = new String[]{\"R\",\"D\",\"U\",\"L\"};\\n    public String alphabetBoardPath(String target) {\\n        Queue<Tuple> queue = new LinkedList<>();\\n        StringBuilder sb = new StringBuilder();\\n        queue.offer(new Tuple(0,0,\"\"));\\n        for(int i=0;i<target.length();i++){\\n            if(i>0 && target.charAt(i)==target.charAt(i-1)){\\n                sb.append(\"!\");\\n                continue;\\n            }\\n            bfs(target.charAt(i),queue,sb);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public void bfs(char target,Queue<Tuple> queue,StringBuilder sb){\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                Tuple cur = queue.poll();\\n                if(board[cur.x][cur.y]==target){\\n                    sb.append(cur.dir+\"!\");\\n                    queue.clear();\\n                    queue.offer(new Tuple(cur.x,cur.y,\"\"));\\n                    return;\\n                }\\n                for(int k=0;k<dirs.length;k++){\\n                    int[] dir = dirs[k];\\n                    String d = sDir[k];\\n                    int x = cur.x + dir[0];\\n                    int y = cur.y + dir[1];\\n                    if(x>=0 && y>=0 && x<board.length && y<board[x].length){\\n                        queue.offer(new Tuple(x,y,cur.dir+d));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nclass Tuple{\\n    int x;\\n    int y;\\n    String dir;\\n    \\n    public Tuple(int x,int y,String dir){\\n        this.x = x;\\n        this.y = y;\\n        this.dir = dir;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[][] board = new char[][]{{\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'},{\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'}, {\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'}, {\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'},{\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'} ,{\\'z\\'}};\\n    int[][] dirs = new int[][]{{0,1},{1,0},{-1,0},{0,-1}};\\n    String[] sDir = new String[]{\"R\",\"D\",\"U\",\"L\"};\\n    public String alphabetBoardPath(String target) {\\n        Queue<Tuple> queue = new LinkedList<>();\\n        StringBuilder sb = new StringBuilder();\\n        queue.offer(new Tuple(0,0,\"\"));\\n        for(int i=0;i<target.length();i++){\\n            if(i>0 && target.charAt(i)==target.charAt(i-1)){\\n                sb.append(\"!\");\\n                continue;\\n            }\\n            bfs(target.charAt(i),queue,sb);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public void bfs(char target,Queue<Tuple> queue,StringBuilder sb){\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                Tuple cur = queue.poll();\\n                if(board[cur.x][cur.y]==target){\\n                    sb.append(cur.dir+\"!\");\\n                    queue.clear();\\n                    queue.offer(new Tuple(cur.x,cur.y,\"\"));\\n                    return;\\n                }\\n                for(int k=0;k<dirs.length;k++){\\n                    int[] dir = dirs[k];\\n                    String d = sDir[k];\\n                    int x = cur.x + dir[0];\\n                    int y = cur.y + dir[1];\\n                    if(x>=0 && y>=0 && x<board.length && y<board[x].length){\\n                        queue.offer(new Tuple(x,y,cur.dir+d));\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nclass Tuple{\\n    int x;\\n    int y;\\n    String dir;\\n    \\n    public Tuple(int x,int y,String dir){\\n        this.x = x;\\n        this.y = y;\\n        this.dir = dir;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050215,
                "title": "python-beats-99-9-space-80-time",
                "content": "O(N) runtime, O(N) space\\n\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n            \\n        s_x, s_y = 0, 0\\n        res = []\\n        for char in target:\\n            offset = ord(char) - ord(\\'a\\')\\n            d_x, d_y = offset // 5, offset % 5\\n            \\n            if d_x < s_x:\\n                res += [\\'U\\'] * (s_x - d_x)\\n            if d_y < s_y:\\n                res += [\\'L\\'] * (s_y - d_y)\\n            if d_y > s_y:\\n                res += [\\'R\\'] * (d_y - s_y)\\n            if d_x > s_x:\\n                res += [\\'D\\'] * (d_x - s_x)\\n                \\n            res += [\\'!\\']\\n            s_x, s_y = d_x, d_y\\n            \\n        return \\'\\'.join(res)",
                "solutionTags": [],
                "code": "O(N) runtime, O(N) space\\n\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n            \\n        s_x, s_y = 0, 0\\n        res = []\\n        for char in target:\\n            offset = ord(char) - ord(\\'a\\')\\n            d_x, d_y = offset // 5, offset % 5\\n            \\n            if d_x < s_x:\\n                res += [\\'U\\'] * (s_x - d_x)\\n            if d_y < s_y:\\n                res += [\\'L\\'] * (s_y - d_y)\\n            if d_y > s_y:\\n                res += [\\'R\\'] * (d_y - s_y)\\n            if d_x > s_x:\\n                res += [\\'D\\'] * (d_x - s_x)\\n                \\n            res += [\\'!\\']\\n            s_x, s_y = d_x, d_y\\n            \\n        return \\'\\'.join(res)",
                "codeTag": "Java"
            },
            {
                "id": 1048142,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int pos = 0;\\n        \\n        for (char c : target.toCharArray()) {\\n            int cpos = c - \\'a\\';\\n\\n            if (cpos != pos) {\\n                int x = pos % 5 - cpos % 5;\\n                int y = pos / 5 - cpos / 5;\\n\\n                while (x > 0) {\\n                    x--;\\n                    sb.append(\\'L\\');\\n                }\\n                \\n                while (y > 0) {\\n                    y--;\\n                    sb.append(\\'U\\');\\n                }\\n                \\n                while (x < 0) {\\n                    x++;\\n                    sb.append(\\'R\\');\\n                }\\n                \\n                while (y < 0) {\\n                    y++;\\n                    sb.append(\\'D\\');\\n                }                \\n            }\\n            \\n            sb.append(\\'!\\');\\n            pos = cpos;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int pos = 0;\\n        \\n        for (char c : target.toCharArray()) {\\n            int cpos = c - \\'a\\';\\n\\n            if (cpos != pos) {\\n                int x = pos % 5 - cpos % 5;\\n                int y = pos / 5 - cpos / 5;\\n\\n                while (x > 0) {\\n                    x--;\\n                    sb.append(\\'L\\');\\n                }\\n                \\n                while (y > 0) {\\n                    y--;\\n                    sb.append(\\'U\\');\\n                }\\n                \\n                while (x < 0) {\\n                    x++;\\n                    sb.append(\\'R\\');\\n                }\\n                \\n                while (y < 0) {\\n                    y++;\\n                    sb.append(\\'D\\');\\n                }                \\n            }\\n            \\n            sb.append(\\'!\\');\\n            pos = cpos;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1017534,
                "title": "swift-o-n-solution-without-using-a-dictionary-with-comments",
                "content": "```\\n func alphabetBoardPath(_ target: String) -> String {\\n        // gets the location for each character\\n        func location(for char: Character) -> (Int,Int) {\\n            let asciiValue = Int(char.asciiValue!)\\n            let diff = asciiValue - Int(Character(\"a\").asciiValue!)\\n            let rem = diff % 5\\n            let quo = diff / 5\\n            return (quo, rem)\\n        }\\n        \\n        func moveString(forRowDiff diff: Int) -> String {\\n            guard diff != 0 else { return \"\" }\\n            return String(repeating: diff > 0 ? \"D\" : \"U\", count: abs(diff))\\n        }\\n        \\n        func moveString(forColDiff diff: Int) -> String {\\n            guard diff != 0 else { return \"\" }\\n            return String(repeating: diff > 0 ? \"R\" : \"L\", count: abs(diff))\\n        }\\n        \\n        var result = \"\"\\n        var prev: Character = \"a\"\\n        for char in target {\\n            // we only need to calculate the locations if the source and destination characters\\n            // are different\\n            if char != prev {\\n                let prevLoc = location(for: prev)\\n                let nextLoc = location(for: char)\\n\\n                let locDiffR = nextLoc.0 - prevLoc.0\\n                let locDiffC = nextLoc.1 - prevLoc.1\\n                \\n                // if the destination is \"z\" we might want to perform the col\\n                // moves first and then the row moves\\n                if char == \"z\" {\\n                    result += moveString(forColDiff: locDiffC)\\n                    result += moveString(forRowDiff: locDiffR)\\n                } else {\\n                    result += moveString(forRowDiff: locDiffR)\\n                    result += moveString(forColDiff: locDiffC)\\n                }\\n            \\n            }\\n            result += \"!\"\\n            prev = char\\n        }\\n        return result\\n    }",
                "solutionTags": [],
                "code": "```\\n func alphabetBoardPath(_ target: String) -> String {\\n        // gets the location for each character\\n        func location(for char: Character) -> (Int,Int) {\\n            let asciiValue = Int(char.asciiValue!)\\n            let diff = asciiValue - Int(Character(\"a\").asciiValue!)\\n            let rem = diff % 5\\n            let quo = diff / 5\\n            return (quo, rem)\\n        }\\n        \\n        func moveString(forRowDiff diff: Int) -> String {\\n            guard diff != 0 else { return \"\" }\\n            return String(repeating: diff > 0 ? \"D\" : \"U\", count: abs(diff))\\n        }\\n        \\n        func moveString(forColDiff diff: Int) -> String {\\n            guard diff != 0 else { return \"\" }\\n            return String(repeating: diff > 0 ? \"R\" : \"L\", count: abs(diff))\\n        }\\n        \\n        var result = \"\"\\n        var prev: Character = \"a\"\\n        for char in target {\\n            // we only need to calculate the locations if the source and destination characters\\n            // are different\\n            if char != prev {\\n                let prevLoc = location(for: prev)\\n                let nextLoc = location(for: char)\\n\\n                let locDiffR = nextLoc.0 - prevLoc.0\\n                let locDiffC = nextLoc.1 - prevLoc.1\\n                \\n                // if the destination is \"z\" we might want to perform the col\\n                // moves first and then the row moves\\n                if char == \"z\" {\\n                    result += moveString(forColDiff: locDiffC)\\n                    result += moveString(forRowDiff: locDiffR)\\n                } else {\\n                    result += moveString(forRowDiff: locDiffR)\\n                    result += moveString(forColDiff: locDiffC)\\n                }\\n            \\n            }\\n            result += \"!\"\\n            prev = char\\n        }\\n        return result\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1015330,
                "title": "o-n-100-faster-0ms-rac101ran",
                "content": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n       vector<string> table = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n       map<char,pair<int,int>> alpha; \\n       for(int i=0; i<table.size(); i++) {\\n          for(int j=0; j<table[i].size(); j++) {\\n              alpha[table[i][j]]=make_pair(i,j);\\n          }\\n       }\\n        pair<int,int> curr={0,0};\\n        string ans=\"\";\\n        for(int i=0; i<target.size(); i++) {\\n            string cur=\"\";\\n            int cdiff=abs(alpha[target[i]].second-curr.second);\\n            int rdiff=abs(alpha[target[i]].first-curr.first);\\n          if(target[i]==\\'z\\') {\\n              cur+=curr.second<alpha[target[i]].second?make(cdiff,\\'R\\'):make(cdiff,\\'L\\');\\n              cur+=curr.first<alpha[target[i]].first?make(rdiff,\\'D\\'):make(rdiff,\\'U\\');\\n          }else {\\n              cur+=curr.first<alpha[target[i]].first?make(rdiff,\\'D\\'):make(rdiff,\\'U\\');\\n              cur+=curr.second<alpha[target[i]].second?make(cdiff,\\'R\\'):make(cdiff,\\'L\\');\\n          }\\n            cur+=\\'!\\';\\n            ans+=cur;\\n            curr=alpha[target[i]];\\n        }\\n        return ans;\\n    }\\n    string make(int len,char x) {\\n        string ans=\"\";\\n        for(int i=0; i<len; i++) {\\n            ans+=x;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n       vector<string> table = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n       map<char,pair<int,int>> alpha; \\n       for(int i=0; i<table.size(); i++) {\\n          for(int j=0; j<table[i].size(); j++) {\\n              alpha[table[i][j]]=make_pair(i,j);\\n          }\\n       }\\n        pair<int,int> curr={0,0};\\n        string ans=\"\";\\n        for(int i=0; i<target.size(); i++) {\\n            string cur=\"\";\\n            int cdiff=abs(alpha[target[i]].second-curr.second);\\n            int rdiff=abs(alpha[target[i]].first-curr.first);\\n          if(target[i]==\\'z\\') {\\n              cur+=curr.second<alpha[target[i]].second?make(cdiff,\\'R\\'):make(cdiff,\\'L\\');\\n              cur+=curr.first<alpha[target[i]].first?make(rdiff,\\'D\\'):make(rdiff,\\'U\\');\\n          }else {\\n              cur+=curr.first<alpha[target[i]].first?make(rdiff,\\'D\\'):make(rdiff,\\'U\\');\\n              cur+=curr.second<alpha[target[i]].second?make(cdiff,\\'R\\'):make(cdiff,\\'L\\');\\n          }\\n            cur+=\\'!\\';\\n            ans+=cur;\\n            curr=alpha[target[i]];\\n        }\\n        return ans;\\n    }\\n    string make(int len,char x) {\\n        string ans=\"\";\\n        for(int i=0; i<len; i++) {\\n            ans+=x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011381,
                "title": "c-bfs",
                "content": "# Approach\\nSince this is a shortest path problem, I decided to use a bfs to find each letter, given the last letter. I was able to save some space by not storing the board but instead encoding the letters based on the row and col. 5*r* + *c*  + \\'a\\' will produce the board that is presented in the problem. You may be able to speed up the time to reach a solution by terminating the bfs early (i.e., when you first spot the target char as opposed to waiting until it is popped off the queue).\\n\\n\\n# Complexity\\nTime: O(N*(V+E)) ~ O(N) where N is the lenght of the input string. The number of verticies is constant and the number of edges which is 4*V* is alose constant.\\nSpace: O(V) to store the visited array. Since this is a constant, you could optimize some space by storing it within a bit field and doing bit manipulation.\\n\\n# Solution\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string output = \"\";\\n        int i = 0;\\n        \\n        int r = 0;\\n        int c = 0;\\n        \\n        while(i<target.size()){\\n            output += bfs(target[i++],r,c);\\n        }\\n        return output;\\n        \\n    }\\n    \\n    string bfs (char x, int& r, int& c){\\n        \\n        vector<vector<bool>> visited(6,vector<bool>(5,false));\\n        queue<pair<char,string>> q;\\n        string steps = \"\";\\n        q.push(make_pair(5*r+c + \\'a\\',steps));\\n        visited[r][c] = true;\\n\\n        while(q.front().first != x){\\n            int i = (q.front().first - \\'a\\')/5;\\n            int j = (q.front().first - \\'a\\')%5;\\n            \\n            if(i-1>=0 && !visited[i-1][j]){\\n                q.push(make_pair(5*(i-1)+j +\\'a\\',q.front().second+\\'U\\'));\\n                visited[i-1][j] = true;   \\n            }\\n            if(j-1>=0 && !visited[i][j-1]){\\n                q.push(make_pair(5*i+(j-1) +\\'a\\',q.front().second+\\'L\\'));\\n                visited[i][j-1] = true;   \\n            }\\n            if(((i+1 == 5 && j == 0) || i+1 < 5) && !visited[i+1][j]){\\n                q.push(make_pair(5*(i+1)+j +\\'a\\',q.front().second+\\'D\\'));\\n                visited[i+1][j] = true;   \\n            }\\n            if(i != 5 && j+1 < 5 && !visited[i][j+1]){\\n                q.push(make_pair(5*i+(j+1) + \\'a\\',q.front().second+\\'R\\'));\\n                visited[i][j+1] = true;   \\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        r = (x - \\'a\\')/5;\\n        c = (x - \\'a\\')%5;\\n        return q.front().second + \\'!\\';\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string output = \"\";\\n        int i = 0;\\n        \\n        int r = 0;\\n        int c = 0;\\n        \\n        while(i<target.size()){\\n            output += bfs(target[i++],r,c);\\n        }\\n        return output;\\n        \\n    }\\n    \\n    string bfs (char x, int& r, int& c){\\n        \\n        vector<vector<bool>> visited(6,vector<bool>(5,false));\\n        queue<pair<char,string>> q;\\n        string steps = \"\";\\n        q.push(make_pair(5*r+c + \\'a\\',steps));\\n        visited[r][c] = true;\\n\\n        while(q.front().first != x){\\n            int i = (q.front().first - \\'a\\')/5;\\n            int j = (q.front().first - \\'a\\')%5;\\n            \\n            if(i-1>=0 && !visited[i-1][j]){\\n                q.push(make_pair(5*(i-1)+j +\\'a\\',q.front().second+\\'U\\'));\\n                visited[i-1][j] = true;   \\n            }\\n            if(j-1>=0 && !visited[i][j-1]){\\n                q.push(make_pair(5*i+(j-1) +\\'a\\',q.front().second+\\'L\\'));\\n                visited[i][j-1] = true;   \\n            }\\n            if(((i+1 == 5 && j == 0) || i+1 < 5) && !visited[i+1][j]){\\n                q.push(make_pair(5*(i+1)+j +\\'a\\',q.front().second+\\'D\\'));\\n                visited[i+1][j] = true;   \\n            }\\n            if(i != 5 && j+1 < 5 && !visited[i][j+1]){\\n                q.push(make_pair(5*i+(j+1) + \\'a\\',q.front().second+\\'R\\'));\\n                visited[i][j+1] = true;   \\n            }\\n            \\n            q.pop();\\n        }\\n        \\n        r = (x - \\'a\\')/5;\\n        c = (x - \\'a\\')%5;\\n        return q.front().second + \\'!\\';\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989553,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        String[] board = new String[]{\\n            \"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"\\n        };\\n        Map<Character, int[]> map = new HashMap<>();\\n        List<Character> list = new ArrayList<>();\\n        char last = \\'a\\';\\n        map.put(\\'a\\', new int[]{0, 0});\\n        for(char c : target.toCharArray()){\\n            int i = -1, j = -1;\\n            if(c >= \\'a\\' && c <= \\'e\\'){\\n                i = 0;\\n                j = board[i].indexOf(c);\\n            }\\n            else if(c >= \\'f\\' && c <= \\'j\\'){\\n                 i = 1;\\n                j = board[i].indexOf(c);\\n            }else if(c >= \\'k\\' && c <= \\'o\\'){\\n                 i = 2;\\n                j = board[i].indexOf(c);\\n            }else if(c >= \\'p\\' && c <= \\'t\\'){\\n                 i = 3;\\n                j = board[i].indexOf(c);\\n            }else if(c >= \\'u\\' && c <= \\'y\\'){\\n                 i = 4;\\n                j = board[i].indexOf(c);\\n            }else if(c == \\'z\\'){\\n                i = 5;\\n                j = 0;\\n            }\\n            list.add(c);\\n            map.put(c, new int[]{i , j});\\n        }\\n        String str = \"\";\\n        for(char c : list){\\n            int[] curr = map.get(c);\\n            int[] prev = map.get(last);\\n            int row = Math.abs(curr[0] - prev[0]);\\n            int col = Math.abs(curr[1] - prev[1]);\\n            if(curr[0] == 5 && col != 0){\\n                for(int i = 0; i < col; i++){\\n                    if(curr[1] - prev[1] > 0){\\n                        str += \\'R\\';\\n                    }else{\\n                        str += \\'L\\';\\n                    }\\n                }\\n                \\n                for(int i = 0; i < row; i++){\\n                    if(curr[0] - prev[0] > 0){\\n                        str += \\'D\\';\\n                        \\n                    }else{\\n                        str += \\'U\\';\\n                    }\\n                }\\n            }else{\\n                for(int i = 0; i < row; i++){\\n                    if(curr[0] - prev[0] > 0){\\n                        str += \\'D\\';\\n                        \\n                    }else{\\n                        str += \\'U\\';\\n                    }\\n                }\\n                for(int i = 0; i < col; i++){\\n                    if(curr[1] - prev[1] > 0){\\n                        str += \\'R\\';\\n                    }else{\\n                        str += \\'L\\';\\n                    }\\n                    }\\n            }\\n            str += \\'!\\';\\n            last = c;\\n        }\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        String[] board = new String[]{\\n            \"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"\\n        };\\n        Map<Character, int[]> map = new HashMap<>();\\n        List<Character> list = new ArrayList<>();\\n        char last = \\'a\\';\\n        map.put(\\'a\\', new int[]{0, 0});\\n        for(char c : target.toCharArray()){\\n            int i = -1, j = -1;\\n            if(c >= \\'a\\' && c <= \\'e\\'){\\n                i = 0;\\n                j = board[i].indexOf(c);\\n            }\\n            else if(c >= \\'f\\' && c <= \\'j\\'){\\n                 i = 1;\\n                j = board[i].indexOf(c);\\n            }else if(c >= \\'k\\' && c <= \\'o\\'){\\n                 i = 2;\\n                j = board[i].indexOf(c);\\n            }else if(c >= \\'p\\' && c <= \\'t\\'){\\n                 i = 3;\\n                j = board[i].indexOf(c);\\n            }else if(c >= \\'u\\' && c <= \\'y\\'){\\n                 i = 4;\\n                j = board[i].indexOf(c);\\n            }else if(c == \\'z\\'){\\n                i = 5;\\n                j = 0;\\n            }\\n            list.add(c);\\n            map.put(c, new int[]{i , j});\\n        }\\n        String str = \"\";\\n        for(char c : list){\\n            int[] curr = map.get(c);\\n            int[] prev = map.get(last);\\n            int row = Math.abs(curr[0] - prev[0]);\\n            int col = Math.abs(curr[1] - prev[1]);\\n            if(curr[0] == 5 && col != 0){\\n                for(int i = 0; i < col; i++){\\n                    if(curr[1] - prev[1] > 0){\\n                        str += \\'R\\';\\n                    }else{\\n                        str += \\'L\\';\\n                    }\\n                }\\n                \\n                for(int i = 0; i < row; i++){\\n                    if(curr[0] - prev[0] > 0){\\n                        str += \\'D\\';\\n                        \\n                    }else{\\n                        str += \\'U\\';\\n                    }\\n                }\\n            }else{\\n                for(int i = 0; i < row; i++){\\n                    if(curr[0] - prev[0] > 0){\\n                        str += \\'D\\';\\n                        \\n                    }else{\\n                        str += \\'U\\';\\n                    }\\n                }\\n                for(int i = 0; i < col; i++){\\n                    if(curr[1] - prev[1] > 0){\\n                        str += \\'R\\';\\n                    }else{\\n                        str += \\'L\\';\\n                    }\\n                    }\\n            }\\n            str += \\'!\\';\\n            last = c;\\n        }\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920985,
                "title": "easy-to-understand-python-bfs-solution",
                "content": "```\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        def helper(board,x,y,ch):\\n            m = len(board)\\n            n = len(board[0])\\n            q = collections.deque()\\n            q.append([x,y,\\'\\'])\\n            seen = set()\\n            while len(q) > 0:\\n                x,y,st = q.popleft()\\n                if x<0 or x>=m or y<0 or y>=n or board[x][y] == \\'.\\': # skip the moves to \\'.\\'\\n                    continue\\n                if board[x][y] == ch:\\n                    return x,y,st+\\'!\\'\\n                if (x+1,y) not in seen:\\n                    q.append([x+1,y,st+\\'D\\'])\\n                    seen.add((x+1,y))\\n                if (x-1,y) not in seen:\\n                    q.append([x-1,y,st+\\'U\\'])\\n                    seen.add((x-1,y))\\n                if (x,y+1) not in seen:\\n                    q.append([x,y+1,st+\\'R\\'])\\n                    seen.add((x,y+1))\\n                if (x,y-1) not in seen:\\n                    q.append([x,y-1,st+\\'L\\'])\\n                    seen.add((x,y-1))\\n                    \\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z....\"] # added . to last row to make the column equal\\n        x,y = 0,0\\n        ret =\\'\\'\\n        for ch in target:\\n            x,y,temp = helper(board,x,y,ch)\\n            ret += temp\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        def helper(board,x,y,ch):\\n            m = len(board)\\n            n = len(board[0])\\n            q = collections.deque()\\n            q.append([x,y,\\'\\'])\\n            seen = set()\\n            while len(q) > 0:\\n                x,y,st = q.popleft()\\n                if x<0 or x>=m or y<0 or y>=n or board[x][y] == \\'.\\': # skip the moves to \\'.\\'\\n                    continue\\n                if board[x][y] == ch:\\n                    return x,y,st+\\'!\\'\\n                if (x+1,y) not in seen:\\n                    q.append([x+1,y,st+\\'D\\'])\\n                    seen.add((x+1,y))\\n                if (x-1,y) not in seen:\\n                    q.append([x-1,y,st+\\'U\\'])\\n                    seen.add((x-1,y))\\n                if (x,y+1) not in seen:\\n                    q.append([x,y+1,st+\\'R\\'])\\n                    seen.add((x,y+1))\\n                if (x,y-1) not in seen:\\n                    q.append([x,y-1,st+\\'L\\'])\\n                    seen.add((x,y-1))\\n                    \\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z....\"] # added . to last row to make the column equal\\n        x,y = 0,0\\n        ret =\\'\\'\\n        for ch in target:\\n            x,y,temp = helper(board,x,y,ch)\\n            ret += temp\\n        return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 904984,
                "title": "java-100-a-bit-lengthy-but-hopefully-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder result = new StringBuilder();\\n        \\n        int currRow = 0, currCol = 0;\\n        for (int i = 0; i < target.length(); i++) {\\n            char c = target.charAt(i);\\n            int cInt = (int) (c - \\'a\\');\\n\\n            int targetRow = cInt / 5;\\n            int targetCol = cInt % 5;\\n            \\n            StringBuilder path = buildPath(currRow, currCol, targetRow, targetCol);\\n            \\n            result.append(path);\\n            \\n            currRow = targetRow;\\n            currCol = targetCol;\\n        }\\n        \\n        return result.toString();\\n    }\\n    \\n    private StringBuilder buildPath(int currRow, int currCol, int targetRow, int targetCol) {\\n        char verDir = currRow > targetRow ? \\'U\\' : \\'D\\';\\n        char horDir = currCol > targetCol ? \\'L\\' : \\'R\\';\\n        \\n        StringBuilder verMoves = new StringBuilder();\\n        for (int i = 0; i < Math.abs(currRow - targetRow); i++) {\\n            verMoves.append(verDir);\\n        }\\n        \\n        StringBuilder horMoves = new StringBuilder();\\n        for (int i = 0; i < Math.abs(currCol - targetCol); i++) {\\n            horMoves.append(horDir);\\n        }\\n        \\n        if (horDir == \\'L\\') {\\n            return horMoves.append(verMoves).append(\\'!\\');\\n        } else {\\n            return verMoves.append(horMoves).append(\\'!\\');\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder result = new StringBuilder();\\n        \\n        int currRow = 0, currCol = 0;\\n        for (int i = 0; i < target.length(); i++) {\\n            char c = target.charAt(i);\\n            int cInt = (int) (c - \\'a\\');\\n\\n            int targetRow = cInt / 5;\\n            int targetCol = cInt % 5;\\n            \\n            StringBuilder path = buildPath(currRow, currCol, targetRow, targetCol);\\n            \\n            result.append(path);\\n            \\n            currRow = targetRow;\\n            currCol = targetCol;\\n        }\\n        \\n        return result.toString();\\n    }\\n    \\n    private StringBuilder buildPath(int currRow, int currCol, int targetRow, int targetCol) {\\n        char verDir = currRow > targetRow ? \\'U\\' : \\'D\\';\\n        char horDir = currCol > targetCol ? \\'L\\' : \\'R\\';\\n        \\n        StringBuilder verMoves = new StringBuilder();\\n        for (int i = 0; i < Math.abs(currRow - targetRow); i++) {\\n            verMoves.append(verDir);\\n        }\\n        \\n        StringBuilder horMoves = new StringBuilder();\\n        for (int i = 0; i < Math.abs(currCol - targetCol); i++) {\\n            horMoves.append(horDir);\\n        }\\n        \\n        if (horDir == \\'L\\') {\\n            return horMoves.append(verMoves).append(\\'!\\');\\n        } else {\\n            return verMoves.append(horMoves).append(\\'!\\');\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892485,
                "title": "simple-o-n-solution-using-hashmap",
                "content": "public class Solution {\\n    public string AlphabetBoardPath(string target) \\n    {\\n       \\n        StringBuilder result = new StringBuilder();\\n        \\n        // build the board\\n        var board = new Dictionary<char, BoardInfo>();\\n        for (int i=0; i<26; i++)\\n        {\\n            int row = i/5;\\n            int col = i%5;\\n            board[(char)(\\'a\\' + i)] = new BoardInfo(row, col);\\n        }\\n        \\n        // start with \\'a\\'\\n        BoardInfo currInfo = board[\\'a\\'];\\n        foreach (char destChar in target)\\n        {\\n            if (!board.ContainsKey(destChar))\\n            {\\n                throw new Exception(\"invalid input!\");\\n            }\\n            \\n            BoardInfo destInfo = board[destChar];\\n            int rowDiff = destInfo.row - currInfo.row;\\n            int colDiff = destInfo.col - currInfo.col;\\n            \\n            // PROCESS THE MOVE LEFT AND UP FIRST.\\n            // THIS IS DONE TO HANDLE Z. \\n            // AS FROM v-y, WE CAN\\'T MOVE DOWN.\\n            // AS FROM z, WE CAN\\'t MOVE RIGHT.\\n            \\n            while (colDiff < 0) // move left\\n            {\\n                result.Append(\\'L\\');\\n                colDiff++;\\n            } \\n            \\n            while (rowDiff < 0) // move up\\n            {\\n                result.Append(\\'U\\');\\n                rowDiff++;\\n            }\\n            \\n            while (colDiff > 0) // move right\\n            {\\n                result.Append(\\'R\\');\\n                colDiff--;\\n            }\\n            \\n            while (rowDiff > 0) // move down\\n            {\\n                result.Append(\\'D\\');\\n                rowDiff--;\\n            }\\n            \\n            result.Append(\\'!\\');\\n            currInfo = destInfo; //<<--- change the new curr\\n        }\\n        \\n        return result.ToString();\\n    }\\n    \\n    public class BoardInfo\\n    {\\n        public BoardInfo(int r, int c)\\n        {\\n            row = r;\\n            col = c;\\n        }\\n        \\n        public int row { get; private set; }\\n        public int col { get; private set; }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public string AlphabetBoardPath(string target) \\n    {\\n       \\n        StringBuilder result = new StringBuilder();\\n        \\n        // build the board\\n        var board = new Dictionary<char, BoardInfo>();\\n        for (int i=0; i<26; i++)\\n        {\\n            int row = i/5;\\n            int col = i%5;\\n            board[(char)(\\'a\\' + i)] = new BoardInfo(row, col);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 871320,
                "title": "python-just-another-intuitive-solution",
                "content": "Obviously it\\'s not the most optimal solution but something from a very natural thought process.\\n\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        # 1. Convert the board into letter -> (r, c) map\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        cd = dict()\\n        for r in range(6):\\n            for c in range(len(board[r])):\\n                cd[board[r][c]] = (r, c)\\n        \\n        # 2. Go through the letters and add up the shortest paths\\n        # 2-a. Always move along the columns first, then the rows, except, when you\\'re coming out from \\'z\\'\\n        ans = \\'\\'\\n        cr, cc = 0, 0\\n        for dest in target:\\n            dr, dc = cd[dest]\\n            move_r = \\'\\'\\n            if dr > cr:\\n                move_r = \\'D\\'\\n            elif dr < cr:\\n                move_r = \\'U\\'\\n            move_c = \\'\\'\\n            if dc > cc:\\n                move_c = \\'R\\'\\n            elif dc < cc:\\n                move_c = \\'L\\'\\n            \\n            if cr != 5: # You\\'re coming out from \\'z\\' if cr is 5\\n                ans += (move_c * abs(dc - cc) + move_r * abs(dr - cr) + \\'!\\')\\n            else:\\n                ans += (move_r * abs(dr - cr) + move_c * abs(dc - cc) + \\'!\\')\\n            \\n            cr, cc = dr, dc\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        # 1. Convert the board into letter -> (r, c) map\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        cd = dict()\\n        for r in range(6):\\n            for c in range(len(board[r])):\\n                cd[board[r][c]] = (r, c)\\n        \\n        # 2. Go through the letters and add up the shortest paths\\n        # 2-a. Always move along the columns first, then the rows, except, when you\\'re coming out from \\'z\\'\\n        ans = \\'\\'\\n        cr, cc = 0, 0\\n        for dest in target:\\n            dr, dc = cd[dest]\\n            move_r = \\'\\'\\n            if dr > cr:\\n                move_r = \\'D\\'\\n            elif dr < cr:\\n                move_r = \\'U\\'\\n            move_c = \\'\\'\\n            if dc > cc:\\n                move_c = \\'R\\'\\n            elif dc < cc:\\n                move_c = \\'L\\'\\n            \\n            if cr != 5: # You\\'re coming out from \\'z\\' if cr is 5\\n                ans += (move_c * abs(dc - cc) + move_r * abs(dr - cr) + \\'!\\')\\n            else:\\n                ans += (move_r * abs(dr - cr) + move_c * abs(dc - cc) + \\'!\\')\\n            \\n            cr, cc = dr, dc\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865327,
                "title": "java-solution-accepted-but-verbose-and-not-so-good-code",
                "content": "I am using internal data structure to hold the entire board and hashmap, to map keys to position.\\nThere is an inner class Position, which abstracts concept of comparing currentPosition and targetPosition.\\nI have written utility methods to append directions, with num of times.\\nAll went well, until I found the targetPosition , which is (5,0), as part of input, for which my initial solution failed. Then I had to write some hack code, which is dirty....\\nI guess, the solution shared by others , containing ascii value of a-z and doing modulo, that is a good solution, less verbose and neat.  To be honest, I do not know, how to talk, in terms of complexity here.. Time complexity wise, I am running through the input only once. But space complexity wise, I am using some additional data structures, probably, they could be saved.\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        \\n        // store keyboard into a data structure.\\n        HashMap<Character,Position> keyboardPosition = new HashMap<>();\\n    \\n        // for this, store alphabet into an array\\n        \\n        char alphabet[] = \"abcdefghijklmnopqrstuvwxyz\".toCharArray();\\n        int count = 0; // for resetting to 5\\n        int row = 0;\\n        int col = 0;\\n        \\n        for(int i = 0; i< alphabet.length;i++){\\n            \\n            Position keyPosition = new Position(row,col);\\n            keyboardPosition.put(alphabet[i],keyPosition);\\n            col++;\\n            count++;\\n            if(count == 5){\\n                row++;\\n                col = 0;\\n                count = 0;\\n            }\\n            \\n        }// end of for\\n        \\n        //System.out.println(keyboardPosition.toString());\\n        \\n        // process my input target\\n        Position currentPosition = new Position(0,0);\\n        StringBuilder commandOutput = new StringBuilder();\\n        for(int i = 0; i<target.length();i++){\\n            char c = target.charAt(i);           \\n            \\n            Position targetPosition = keyboardPosition.get(c);\\n            while(!currentPosition.equals(targetPosition)){            \\n                // if currentRow < targetRow, then go down\\n            if(currentPosition.getRow() < targetPosition.getRow() && targetPosition.getRow() == 5){\\n            // special handling\\n                // target column should become 0 and targetRow should become 4.\\n                if(currentPosition.getRow()!=4){\\n                    // we have come to 4th row. , now, need to go to 0th column\\n                    commandOutput.append(getCommandString(\\'D\\',Math.abs(currentPosition.getRow() - 4)));                              \\n                }\\n                if(currentPosition.getCol()!=0){\\n                    commandOutput.append(getCommandString(\\'L\\',Math.abs(currentPosition.getCol() - 0)));                              \\n                }\\n                // we have gone to 0th column and 4th row, now, just go to 5th row. \\n                commandOutput.append(getCommandString(\\'D\\',1));                              \\n                currentPosition.setRow(targetPosition.getRow());              \\n                currentPosition.setCol(targetPosition.getCol());              \\n                // then, continue.. \\n            }\\n            else if(currentPosition.getRow() < targetPosition.getRow() && !(targetPosition.getRow() == 5)){\\n              commandOutput.append(getCommandString(\\'D\\',Math.abs(currentPosition.getRow() - targetPosition.getRow())));                 currentPosition.setRow(targetPosition.getRow());              \\n            }\\n            \\n            if(currentPosition.getRow() > targetPosition.getRow()){\\n                // if currentRow > targetRow, then go up\\n                commandOutput.append(getCommandString(\\'U\\',Math.abs(currentPosition.getRow() - targetPosition.getRow())));                 currentPosition.setRow(targetPosition.getRow());              \\n            }    \\n            \\n            if(currentPosition.getCol() < targetPosition.getCol()){\\n            // if currentCol < targetCol, then go right\\n                commandOutput.append(getCommandString(\\'R\\',Math.abs(currentPosition.getCol() - targetPosition.getCol())));                 currentPosition.setCol(targetPosition.getCol());              \\n            }\\n            \\n                \\n            if(currentPosition.getCol() > targetPosition.getCol()){\\n            // if currentCol > targetCol, then go left\\n                commandOutput.append(getCommandString(\\'L\\',Math.abs(currentPosition.getCol() - targetPosition.getCol())));                 currentPosition.setCol(targetPosition.getCol());              \\n            }\\n                \\n            }\\n            \\n            commandOutput.append(\\'!\\');\\n            \\n        }\\n        \\n        return commandOutput.toString();\\n        \\n    }\\n    \\n    public String getCommandString(char c, int numTimes){\\n        StringBuilder sb = new StringBuilder();        \\n        for(int i = 0; i<numTimes; i++){\\n            sb.append(c);\\n        }        \\n        return sb.toString();\\n    }\\n    \\n    private class Position{\\n        \\n        int row, col;\\n        public Position(int row, int col){this.row = row; this.col = col;}\\n        public int getRow(){return row;}\\n        public int getCol(){return col;}\\n        public void setRow(int row){this.row = row;}\\n        public void setCol(int col){this.col = col;}\\n        @Override\\n        public boolean equals(Object o){\\n            //return Objects.equals(o,this);\\n            if(o instanceof Position){\\n                Position position = (Position)o;\\n                if(position.getRow() == this.getRow() && position.getCol() == this.getCol()){\\n                    return true;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n            \\n        }\\n        @Override\\n        public int hashCode(){\\n            return Objects.hashCode(this);\\n        }\\n        \\n        @Override\\n        public String toString(){\\n            return \"r = \"+this.getRow() + \" c =\" + this.getCol() + \" \\\\n\";\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        \\n        // store keyboard into a data structure.\\n        HashMap<Character,Position> keyboardPosition = new HashMap<>();\\n    \\n        // for this, store alphabet into an array\\n        \\n        char alphabet[] = \"abcdefghijklmnopqrstuvwxyz\".toCharArray();\\n        int count = 0; // for resetting to 5\\n        int row = 0;\\n        int col = 0;\\n        \\n        for(int i = 0; i< alphabet.length;i++){\\n            \\n            Position keyPosition = new Position(row,col);\\n            keyboardPosition.put(alphabet[i],keyPosition);\\n            col++;\\n            count++;\\n            if(count == 5){\\n                row++;\\n                col = 0;\\n                count = 0;\\n            }\\n            \\n        }// end of for\\n        \\n        //System.out.println(keyboardPosition.toString());\\n        \\n        // process my input target\\n        Position currentPosition = new Position(0,0);\\n        StringBuilder commandOutput = new StringBuilder();\\n        for(int i = 0; i<target.length();i++){\\n            char c = target.charAt(i);           \\n            \\n            Position targetPosition = keyboardPosition.get(c);\\n            while(!currentPosition.equals(targetPosition)){            \\n                // if currentRow < targetRow, then go down\\n            if(currentPosition.getRow() < targetPosition.getRow() && targetPosition.getRow() == 5){\\n            // special handling\\n                // target column should become 0 and targetRow should become 4.\\n                if(currentPosition.getRow()!=4){\\n                    // we have come to 4th row. , now, need to go to 0th column\\n                    commandOutput.append(getCommandString(\\'D\\',Math.abs(currentPosition.getRow() - 4)));                              \\n                }\\n                if(currentPosition.getCol()!=0){\\n                    commandOutput.append(getCommandString(\\'L\\',Math.abs(currentPosition.getCol() - 0)));                              \\n                }\\n                // we have gone to 0th column and 4th row, now, just go to 5th row. \\n                commandOutput.append(getCommandString(\\'D\\',1));                              \\n                currentPosition.setRow(targetPosition.getRow());              \\n                currentPosition.setCol(targetPosition.getCol());              \\n                // then, continue.. \\n            }\\n            else if(currentPosition.getRow() < targetPosition.getRow() && !(targetPosition.getRow() == 5)){\\n              commandOutput.append(getCommandString(\\'D\\',Math.abs(currentPosition.getRow() - targetPosition.getRow())));                 currentPosition.setRow(targetPosition.getRow());              \\n            }\\n            \\n            if(currentPosition.getRow() > targetPosition.getRow()){\\n                // if currentRow > targetRow, then go up\\n                commandOutput.append(getCommandString(\\'U\\',Math.abs(currentPosition.getRow() - targetPosition.getRow())));                 currentPosition.setRow(targetPosition.getRow());              \\n            }    \\n            \\n            if(currentPosition.getCol() < targetPosition.getCol()){\\n            // if currentCol < targetCol, then go right\\n                commandOutput.append(getCommandString(\\'R\\',Math.abs(currentPosition.getCol() - targetPosition.getCol())));                 currentPosition.setCol(targetPosition.getCol());              \\n            }\\n            \\n                \\n            if(currentPosition.getCol() > targetPosition.getCol()){\\n            // if currentCol > targetCol, then go left\\n                commandOutput.append(getCommandString(\\'L\\',Math.abs(currentPosition.getCol() - targetPosition.getCol())));                 currentPosition.setCol(targetPosition.getCol());              \\n            }\\n                \\n            }\\n            \\n            commandOutput.append(\\'!\\');\\n            \\n        }\\n        \\n        return commandOutput.toString();\\n        \\n    }\\n    \\n    public String getCommandString(char c, int numTimes){\\n        StringBuilder sb = new StringBuilder();        \\n        for(int i = 0; i<numTimes; i++){\\n            sb.append(c);\\n        }        \\n        return sb.toString();\\n    }\\n    \\n    private class Position{\\n        \\n        int row, col;\\n        public Position(int row, int col){this.row = row; this.col = col;}\\n        public int getRow(){return row;}\\n        public int getCol(){return col;}\\n        public void setRow(int row){this.row = row;}\\n        public void setCol(int col){this.col = col;}\\n        @Override\\n        public boolean equals(Object o){\\n            //return Objects.equals(o,this);\\n            if(o instanceof Position){\\n                Position position = (Position)o;\\n                if(position.getRow() == this.getRow() && position.getCol() == this.getCol()){\\n                    return true;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n            \\n        }\\n        @Override\\n        public int hashCode(){\\n            return Objects.hashCode(this);\\n        }\\n        \\n        @Override\\n        public String toString(){\\n            return \"r = \"+this.getRow() + \" c =\" + this.getCol() + \" \\\\n\";\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783054,
                "title": "typescript-for-bginners-from-taiwanese",
                "content": "Beginner\\'s guide\\n\\n```\\nlet board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\nlet tempInd = [1,1]; // \\u66AB\\u6642\\u7684\\u4F4D\\u7F6E [Y , X]\\nlet targetInd: any[] = []; // target \\u6BCF\\u500B\\u55AE\\u5B57\\u89E3\\u6790\\n\\nlet answer = \\'\\';\\n\\n// \\u7D50\\u8AD6\\u51FD\\u5F0F\\nfunction alphabetBoardPath(target: string){\\n    tempInd = [1,1];\\n    targetInd = [];\\n    answer = \\'\\';\\n    targetPerIndex(target); // targetInd\\u5DF2\\u5C07\\u4F86\\u6E90\\u5B57\\u4E32\\u4F4D\\u7F6E\\u5206\\u6790\\u5B8C\\u7562\\n    \\n    targetInd.forEach((element , i)=>{\\n        // \\u5224\\u65B7element\\u662F\\u4E0D\\u662Fz\\n        if(target.substring(i , i+1) === \\'z\\'){\\n            moveZ(element);\\n        } else {\\n            moveY(element);\\n            moveX(element);  \\n        }\\n\\n    });\\n    \\n    return answer;\\n};\\n\\n// \\u628A\\u984C\\u76EE\\u6BCF\\u500B\\u5B57\\u5143\\u7684\\u4F4D\\u7F6E\\u5B58\\u8D77\\u4F86\\nfunction targetPerIndex(target: string){\\n    for(let x = 0 ; x < target.length ; x++){\\n        let word = \\'\\';\\n        word = target.substring(x , x+1);\\n        targetInd.push(searchFromBoard(word))\\n    }\\n    console.log(\\'targetInd : \\' , targetInd);\\n}\\n\\n// \\u5C0D\\u7167board\\u8868\\nfunction searchFromBoard(word: string){\\n    let wordPosition: any[] = [];\\n    board.forEach((a,b)=>{\\n        if(a.indexOf(word , 0) >= 0){\\n            wordPosition = [b+1 , a.indexOf(word , 0)+1]\\n        }\\n    });\\n    return wordPosition;\\n}\\n\\n// \\u79FB\\u52D5Y\\u8EF8\\nfunction moveY(perPosition: any[]){\\n    let times = 0 ;\\n    if(tempInd[0] < perPosition[0]){\\n        times = perPosition[0] - tempInd[0];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'D\\' ;\\n        }\\n        \\n    } else if(tempInd[0] > perPosition[0]){\\n        times = tempInd[0] - perPosition[0];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'U\\' ;\\n        }\\n\\n    } else if(tempInd[0] === perPosition[0]){\\n\\n    }\\n}\\n\\n// \\u79FB\\u52D5X\\u8EF8\\nfunction moveX(perPosition: any[]){\\n    let times = 0 ;\\n    if(tempInd[1] < perPosition[1]){\\n        times = perPosition[1] - tempInd[1];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'R\\' ;\\n        }\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[1] > perPosition[1]){\\n        times = tempInd[1] - perPosition[1];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'L\\' ;\\n        }\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[1] === perPosition[1]){\\n        answer = answer + \\'!\\' ;\\n    }\\n    tempInd = perPosition;\\n}\\n\\n// Z : \\u79FB\\u52D5Y\\u8EF8\\n// perPosition \\u4E00\\u5B9A\\u662F[6,1]\\nfunction moveZ(perPosition: any[]){\\n    if(tempInd[0] < perPosition[0] && tempInd[1] === perPosition[1]){\\n        let times = 0 ;\\n        times = perPosition[0] - tempInd[0] ;\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'D\\' ;\\n        }\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[0] === perPosition[0] && tempInd[1] === perPosition[1]){\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[0] < perPosition[0] && tempInd[1] > perPosition[1]){\\n        let yTimes = 0 ;\\n        let xTimes = 0 ;\\n        yTimes = perPosition[0] - tempInd[0] -1;\\n        xTimes = tempInd[1] - perPosition[1] ;\\n        if(yTimes === 0){\\n            for(let x = 1 ; x <= xTimes ; x++){\\n                answer = answer + \\'L\\' ;\\n            }\\n            answer = answer + \\'D!\\' ;\\n        } else {\\n            for(let x = 1 ; x <= yTimes ; x++){\\n                answer = answer + \\'D\\' ;\\n            }\\n            for(let x = 1 ; x <= xTimes ; x++){\\n                answer = answer + \\'L\\' ;\\n            }\\n            answer = answer + \\'D!\\' ;\\n        }\\n    }\\n    tempInd = perPosition;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlet board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\nlet tempInd = [1,1]; // \\u66AB\\u6642\\u7684\\u4F4D\\u7F6E [Y , X]\\nlet targetInd: any[] = []; // target \\u6BCF\\u500B\\u55AE\\u5B57\\u89E3\\u6790\\n\\nlet answer = \\'\\';\\n\\n// \\u7D50\\u8AD6\\u51FD\\u5F0F\\nfunction alphabetBoardPath(target: string){\\n    tempInd = [1,1];\\n    targetInd = [];\\n    answer = \\'\\';\\n    targetPerIndex(target); // targetInd\\u5DF2\\u5C07\\u4F86\\u6E90\\u5B57\\u4E32\\u4F4D\\u7F6E\\u5206\\u6790\\u5B8C\\u7562\\n    \\n    targetInd.forEach((element , i)=>{\\n        // \\u5224\\u65B7element\\u662F\\u4E0D\\u662Fz\\n        if(target.substring(i , i+1) === \\'z\\'){\\n            moveZ(element);\\n        } else {\\n            moveY(element);\\n            moveX(element);  \\n        }\\n\\n    });\\n    \\n    return answer;\\n};\\n\\n// \\u628A\\u984C\\u76EE\\u6BCF\\u500B\\u5B57\\u5143\\u7684\\u4F4D\\u7F6E\\u5B58\\u8D77\\u4F86\\nfunction targetPerIndex(target: string){\\n    for(let x = 0 ; x < target.length ; x++){\\n        let word = \\'\\';\\n        word = target.substring(x , x+1);\\n        targetInd.push(searchFromBoard(word))\\n    }\\n    console.log(\\'targetInd : \\' , targetInd);\\n}\\n\\n// \\u5C0D\\u7167board\\u8868\\nfunction searchFromBoard(word: string){\\n    let wordPosition: any[] = [];\\n    board.forEach((a,b)=>{\\n        if(a.indexOf(word , 0) >= 0){\\n            wordPosition = [b+1 , a.indexOf(word , 0)+1]\\n        }\\n    });\\n    return wordPosition;\\n}\\n\\n// \\u79FB\\u52D5Y\\u8EF8\\nfunction moveY(perPosition: any[]){\\n    let times = 0 ;\\n    if(tempInd[0] < perPosition[0]){\\n        times = perPosition[0] - tempInd[0];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'D\\' ;\\n        }\\n        \\n    } else if(tempInd[0] > perPosition[0]){\\n        times = tempInd[0] - perPosition[0];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'U\\' ;\\n        }\\n\\n    } else if(tempInd[0] === perPosition[0]){\\n\\n    }\\n}\\n\\n// \\u79FB\\u52D5X\\u8EF8\\nfunction moveX(perPosition: any[]){\\n    let times = 0 ;\\n    if(tempInd[1] < perPosition[1]){\\n        times = perPosition[1] - tempInd[1];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'R\\' ;\\n        }\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[1] > perPosition[1]){\\n        times = tempInd[1] - perPosition[1];\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'L\\' ;\\n        }\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[1] === perPosition[1]){\\n        answer = answer + \\'!\\' ;\\n    }\\n    tempInd = perPosition;\\n}\\n\\n// Z : \\u79FB\\u52D5Y\\u8EF8\\n// perPosition \\u4E00\\u5B9A\\u662F[6,1]\\nfunction moveZ(perPosition: any[]){\\n    if(tempInd[0] < perPosition[0] && tempInd[1] === perPosition[1]){\\n        let times = 0 ;\\n        times = perPosition[0] - tempInd[0] ;\\n        for(let x = 1 ; x <= times ; x++){\\n          answer = answer + \\'D\\' ;\\n        }\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[0] === perPosition[0] && tempInd[1] === perPosition[1]){\\n        answer = answer + \\'!\\' ;\\n    } else if(tempInd[0] < perPosition[0] && tempInd[1] > perPosition[1]){\\n        let yTimes = 0 ;\\n        let xTimes = 0 ;\\n        yTimes = perPosition[0] - tempInd[0] -1;\\n        xTimes = tempInd[1] - perPosition[1] ;\\n        if(yTimes === 0){\\n            for(let x = 1 ; x <= xTimes ; x++){\\n                answer = answer + \\'L\\' ;\\n            }\\n            answer = answer + \\'D!\\' ;\\n        } else {\\n            for(let x = 1 ; x <= yTimes ; x++){\\n                answer = answer + \\'D\\' ;\\n            }\\n            for(let x = 1 ; x <= xTimes ; x++){\\n                answer = answer + \\'L\\' ;\\n            }\\n            answer = answer + \\'D!\\' ;\\n        }\\n    }\\n    tempInd = perPosition;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 682819,
                "title": "my-100-java-solution",
                "content": "The corner case is the movement from `z` to the other chars. Pay attention to always move to `D` for x and `L` for y to make sure it doesn\\'t move out of the board.\\n\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] prev = new int[]{0, 0};\\n        for (char c : target.toCharArray()) {\\n            int[] curr = getPos(c);\\n            sb.append(getPath(prev, curr));\\n            sb.append(\\'!\\');\\n            prev = curr;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int[] getPos(char c) {\\n        int offset = c - \\'a\\';\\n        int x = offset/5;\\n        int y = offset%5;\\n        return new int[]{x, y};\\n    }\\n    \\n    private String getPath(int[] from, int[] to) {\\n        // TODO\\n        char x = to[0] >= from[0] ? \\'D\\' : \\'U\\';\\n        char y = to[1] >= from[1] ? \\'R\\' : \\'L\\';\\n        int xOff = Math.abs(to[0] - from[0]);\\n        int yOff = Math.abs(to[1] - from[1]);\\n        StringBuilder sb = new StringBuilder();\\n        if (x == \\'U\\') {\\n            for (int i = 0; i < xOff; i++) { sb.append(x);}\\n            for (int i = 0; i < yOff; i++) { sb.append(y);}\\n        } else {\\n            for (int i = 0; i < yOff; i++) { sb.append(y);}\\n            for (int i = 0; i < xOff; i++) { sb.append(x);}            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] prev = new int[]{0, 0};\\n        for (char c : target.toCharArray()) {\\n            int[] curr = getPos(c);\\n            sb.append(getPath(prev, curr));\\n            sb.append(\\'!\\');\\n            prev = curr;\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int[] getPos(char c) {\\n        int offset = c - \\'a\\';\\n        int x = offset/5;\\n        int y = offset%5;\\n        return new int[]{x, y};\\n    }\\n    \\n    private String getPath(int[] from, int[] to) {\\n        // TODO\\n        char x = to[0] >= from[0] ? \\'D\\' : \\'U\\';\\n        char y = to[1] >= from[1] ? \\'R\\' : \\'L\\';\\n        int xOff = Math.abs(to[0] - from[0]);\\n        int yOff = Math.abs(to[1] - from[1]);\\n        StringBuilder sb = new StringBuilder();\\n        if (x == \\'U\\') {\\n            for (int i = 0; i < xOff; i++) { sb.append(x);}\\n            for (int i = 0; i < yOff; i++) { sb.append(y);}\\n        } else {\\n            for (int i = 0; i < yOff; i++) { sb.append(y);}\\n            for (int i = 0; i < xOff; i++) { sb.append(x);}            \\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 636167,
                "title": "well-structured-python-solution",
                "content": "```\\ndef _getPosition(c):\\n    order = ord(c) - ord(\\'a\\')\\n    i = order / 5\\n    j = order % 5\\n    return (i, j)\\n\\ndef _getLateralMoves(lateral_diff):\\n    return (\\'L\\' if lateral_diff < 0 else \\'R\\') * abs(lateral_diff)\\n\\ndef _getVerticalMoves(vertical_diff):\\n    return (\\'U\\' if vertical_diff < 0 else \\'D\\') * abs(vertical_diff)\\n\\ndef _getMoves(pos1, pos2):\\n    lateral = pos2[1] - pos1[1]\\n    vertical = pos2[0] - pos1[0]\\n    moves = \\'\\'\\n\\n    if lateral < 0:\\n        # need to move left first\\n        moves += _getLateralMoves(lateral)\\n        moves += _getVerticalMoves(vertical)\\n    else:\\n        # do vertical moves first\\n        moves += _getVerticalMoves(vertical)\\n        moves += _getLateralMoves(lateral)\\n    return moves\\n\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        cur_pos = (0, 0)\\n        moves = \\'\\'\\n        for c in target:\\n            next_pos = _getPosition(c)\\n            cur_moves = _getMoves(cur_pos, next_pos)\\n            moves += cur_moves + \\'!\\'\\n            cur_pos = next_pos\\n            \\n        return moves\\n```",
                "solutionTags": [],
                "code": "```\\ndef _getPosition(c):\\n    order = ord(c) - ord(\\'a\\')\\n    i = order / 5\\n    j = order % 5\\n    return (i, j)\\n\\ndef _getLateralMoves(lateral_diff):\\n    return (\\'L\\' if lateral_diff < 0 else \\'R\\') * abs(lateral_diff)\\n\\ndef _getVerticalMoves(vertical_diff):\\n    return (\\'U\\' if vertical_diff < 0 else \\'D\\') * abs(vertical_diff)\\n\\ndef _getMoves(pos1, pos2):\\n    lateral = pos2[1] - pos1[1]\\n    vertical = pos2[0] - pos1[0]\\n    moves = \\'\\'\\n\\n    if lateral < 0:\\n        # need to move left first\\n        moves += _getLateralMoves(lateral)\\n        moves += _getVerticalMoves(vertical)\\n    else:\\n        # do vertical moves first\\n        moves += _getVerticalMoves(vertical)\\n        moves += _getLateralMoves(lateral)\\n    return moves\\n\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        cur_pos = (0, 0)\\n        moves = \\'\\'\\n        for c in target:\\n            next_pos = _getPosition(c)\\n            cur_moves = _getMoves(cur_pos, next_pos)\\n            moves += cur_moves + \\'!\\'\\n            cur_pos = next_pos\\n            \\n        return moves\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629938,
                "title": "javascript-easy-understand-solution",
                "content": "```js\\n/*\\n * @lc app=leetcode id=1138 lang=javascript\\n *\\n * [1138] Alphabet Board Path\\n */\\n\\n// @lc code=start\\n/**\\n * @param {string} target\\n * @return {string}\\n */\\nvar alphabetBoardPath = function(target) {\\n    var board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\n    var map = new Array(128).fill([]);\\n    for (var i = 0; i < board.length; i++) {\\n        var line = board[i];\\n        for (var j = 0; j < line.length; j++) {\\n            map[board[i][j].charCodeAt()] = [i, j];\\n        }\\n    }\\n\\n    var currentChar = \\'a\\';\\n    var idx = 0;\\n    var resultArr = [];\\n    while (idx < target.length) {\\n        if (target[idx] !== currentChar) {\\n            var [fromX, fromY] = map[currentChar.charCodeAt()];\\n            var [toX, toY] = map[target[idx].charCodeAt()];\\n            if (fromX === 5) {\\n                resultArr.push(\\'U\\'.repeat(fromX - toX));\\n                resultArr.push(fromY > toY ? \\'L\\'.repeat(fromY - toY) : \\'R\\'.repeat(toY - fromY));\\n            } else {\\n                resultArr.push(fromY > toY ? \\'L\\'.repeat(fromY - toY) : \\'R\\'.repeat(toY - fromY));\\n                resultArr.push(fromX > toX ? \\'U\\'.repeat(fromX - toX) : \\'D\\'.repeat(toX - fromX));\\n            }\\n        }\\n        currentChar = target[idx];\\n        resultArr.push(\\'!\\');\\n        idx++;\\n    }\\n    return resultArr.join(\\'\\');\\n};\\n// @lc code=end\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/*\\n * @lc app=leetcode id=1138 lang=javascript\\n *\\n * [1138] Alphabet Board Path\\n */\\n\\n// @lc code=start\\n/**\\n * @param {string} target\\n * @return {string}\\n */\\nvar alphabetBoardPath = function(target) {\\n    var board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\n    var map = new Array(128).fill([]);\\n    for (var i = 0; i < board.length; i++) {\\n        var line = board[i];\\n        for (var j = 0; j < line.length; j++) {\\n            map[board[i][j].charCodeAt()] = [i, j];\\n        }\\n    }\\n\\n    var currentChar = \\'a\\';\\n    var idx = 0;\\n    var resultArr = [];\\n    while (idx < target.length) {\\n        if (target[idx] !== currentChar) {\\n            var [fromX, fromY] = map[currentChar.charCodeAt()];\\n            var [toX, toY] = map[target[idx].charCodeAt()];\\n            if (fromX === 5) {\\n                resultArr.push(\\'U\\'.repeat(fromX - toX));\\n                resultArr.push(fromY > toY ? \\'L\\'.repeat(fromY - toY) : \\'R\\'.repeat(toY - fromY));\\n            } else {\\n                resultArr.push(fromY > toY ? \\'L\\'.repeat(fromY - toY) : \\'R\\'.repeat(toY - fromY));\\n                resultArr.push(fromX > toX ? \\'U\\'.repeat(fromX - toX) : \\'D\\'.repeat(toX - fromX));\\n            }\\n        }\\n        currentChar = target[idx];\\n        resultArr.push(\\'!\\');\\n        idx++;\\n    }\\n    return resultArr.join(\\'\\');\\n};\\n// @lc code=end\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 607627,
                "title": "java-simple-solution",
                "content": "```\\npublic String alphabetBoardPath(String target) {\\n    StringBuffer sb = new StringBuffer();\\n    int i = 0, j = 0;\\n    for (char c : target.toCharArray()) {\\n      int pos = c - \\'a\\';\\n      int k = pos / 5, l = pos % 5;\\n      sb.append(\"U\".repeat(Math.max(0, i - k)))\\n              .append(\"R\".repeat(Math.max(0, l - j)))\\n              .append(\"L\".repeat(Math.max(0, j - l)))\\n              .append(\"D\".repeat(Math.max(0, k - i)))\\n              .append(\\'!\\');\\n      i = k;\\n      j = l;\\n    }\\n    return sb.toString();\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\npublic String alphabetBoardPath(String target) {\\n    StringBuffer sb = new StringBuffer();\\n    int i = 0, j = 0;\\n    for (char c : target.toCharArray()) {\\n      int pos = c - \\'a\\';\\n      int k = pos / 5, l = pos % 5;\\n      sb.append(\"U\".repeat(Math.max(0, i - k)))\\n              .append(\"R\".repeat(Math.max(0, l - j)))\\n              .append(\"L\".repeat(Math.max(0, j - l)))\\n              .append(\"D\".repeat(Math.max(0, k - i)))\\n              .append(\\'!\\');\\n      i = k;\\n      j = l;\\n    }\\n    return sb.toString();\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 570767,
                "title": "python-easy-100-100",
                "content": "Credit @https://leetcode.com/problems/alphabet-board-path/discuss/345291/Java-simple-code-for-Indices-manipulation-w-explanation-and-analysis.\\n\\n```python\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        S = []\\n        i,j = 0,0\\n        for n in range(len(target)):\\n            pos = ord(target[n]) - ord(\\'a\\')\\n            row = pos // 5\\n            col = pos % 5\\n            print(pos,row,col)\\n            while (i > row):\\n                S.append(\\'U\\')\\n                i -= 1\\n            while (j > col): \\n                S.append(\\'L\\')\\n                j -= 1\\n            while (j < col):\\n                S.append(\\'R\\')\\n                j += 1\\n            while (i < row):\\n                S.append(\\'D\\')\\n                i += 1\\n            S.append(\\'!\\')\\n        return \"\".join(S)\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        S = []\\n        i,j = 0,0\\n        for n in range(len(target)):\\n            pos = ord(target[n]) - ord(\\'a\\')\\n            row = pos // 5\\n            col = pos % 5\\n            print(pos,row,col)\\n            while (i > row):\\n                S.append(\\'U\\')\\n                i -= 1\\n            while (j > col): \\n                S.append(\\'L\\')\\n                j -= 1\\n            while (j < col):\\n                S.append(\\'R\\')\\n                j += 1\\n            while (i < row):\\n                S.append(\\'D\\')\\n                i += 1\\n            S.append(\\'!\\')\\n        return \"\".join(S)\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 530759,
                "title": "c-bfs-easy-solution",
                "content": "Idea is to build the matrix and treat it as graph.\\nlet\\'s say leet is target.\\nSo first find (0,0) to location of l. --> return the answer for it.\\nthen find from location of l to location of e, --> return for it.\\nSimilarly keep doing it.\\nNow bfs will ensure shortest distance so for each step use BFS and keep on appending the answer.\\nMake sure that isValid is correct and you don\\'t want to traverse wrong candidate in matrix i.e in the row of Z.\\n```\\nclass Solution {\\npublic:\\n    vector<string> graph={\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z****\"};\\n    unordered_map<string,pair<int,int>> controller={{\"L\",{0,-1}},{\"R\",{0,1}},{\"U\",{-1,0}},{\"D\",{1,0}}};\\n    \\n    bool isValid(int x,int y){\\n        if(x>=6 || y>=5 || x<0 || y<0)\\n            return false;\\n        return true;\\n    }\\n    \\n    pair<string,pair<int,int>> bfs(int curr,int x,int y,string target){\\n        queue<pair<string,pair<int,int>>> q;\\n        q.push({\"\",{x,y}});\\n        while(!q.empty()){\\n            pair<string,pair<int,int>> ele=q.front();\\n            q.pop();\\n            string currStr=ele.first;\\n            int nx=ele.second.first;\\n            int ny=ele.second.second;\\n            if(graph[nx][ny]==target[curr]){\\n                return {currStr+\\'!\\',{nx,ny}};\\n            }\\n            for(auto i:controller){\\n                int newX=nx+i.second.first;\\n                int newY=ny+i.second.second;\\n                if(isValid(newX,newY) && graph[newX][newY]!=\\'*\\'){\\n                    q.push({currStr+i.first,{newX,newY}});\\n                }\\n            }\\n        }\\n        return {\"\",{-1,-1}};\\n    }\\n    \\n    string alphabetBoardPath(string target) {\\n        if(target.size()==0)\\n            return \"\";\\n        int sx=0,sy=0;\\n        string ans=\"\";\\n        for(int i=0;i<target.size();i++){\\n            pair<string,pair<int,int>> ele=bfs(i,sx,sy,target);\\n            ans+=ele.first;\\n            sx=ele.second.first;\\n            sy=ele.second.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> graph={\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z****\"};\\n    unordered_map<string,pair<int,int>> controller={{\"L\",{0,-1}},{\"R\",{0,1}},{\"U\",{-1,0}},{\"D\",{1,0}}};\\n    \\n    bool isValid(int x,int y){\\n        if(x>=6 || y>=5 || x<0 || y<0)\\n            return false;\\n        return true;\\n    }\\n    \\n    pair<string,pair<int,int>> bfs(int curr,int x,int y,string target){\\n        queue<pair<string,pair<int,int>>> q;\\n        q.push({\"\",{x,y}});\\n        while(!q.empty()){\\n            pair<string,pair<int,int>> ele=q.front();\\n            q.pop();\\n            string currStr=ele.first;\\n            int nx=ele.second.first;\\n            int ny=ele.second.second;\\n            if(graph[nx][ny]==target[curr]){\\n                return {currStr+\\'!\\',{nx,ny}};\\n            }\\n            for(auto i:controller){\\n                int newX=nx+i.second.first;\\n                int newY=ny+i.second.second;\\n                if(isValid(newX,newY) && graph[newX][newY]!=\\'*\\'){\\n                    q.push({currStr+i.first,{newX,newY}});\\n                }\\n            }\\n        }\\n        return {\"\",{-1,-1}};\\n    }\\n    \\n    string alphabetBoardPath(string target) {\\n        if(target.size()==0)\\n            return \"\";\\n        int sx=0,sy=0;\\n        string ans=\"\";\\n        for(int i=0;i<target.size();i++){\\n            pair<string,pair<int,int>> ele=bfs(i,sx,sy,target);\\n            ans+=ele.first;\\n            sx=ele.second.first;\\n            sy=ele.second.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477604,
                "title": "easy-java-solution-100-runtime-and-100-memory",
                "content": "```\\npublic String alphabetBoardPath(String target) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        int x = 0, y = 0;\\n        for (char c : target.toCharArray()) {\\n            int[] next = getLetterCoord(c);\\n            if (c != \\'z\\') {\\n                x = moveHoriz(x, next[0], res);\\n                y = moveVert(y, next[1], res);\\n            }\\n            else {\\n                y = moveVert(y, next[1], res);\\n                x = moveHoriz(x, next[0], res);\\n            }\\n            res.append(\"!\");\\n        }\\n        return res.toString();\\n    }\\n    \\n    // [0] - x         [1] - y\\n    private int[] getLetterCoord(char c) {\\n        int ind = c - \\'a\\';\\n        return new int[] {ind % 5, ind / 5};\\n    }\\n    \\n    private int moveHoriz(int oldX, int newX, StringBuilder res) {\\n        char move = \\'L\\';\\n        if (newX > oldX) {\\n            move = \\'R\\';\\n        }\\n        for (int i = 0; i < Math.abs(newX - oldX); i++) {\\n            res.append(move);\\n        }\\n        return newX;\\n    }\\n    \\n    private int moveVert(int oldY, int newY, StringBuilder res) {\\n        char move = \\'U\\';\\n        if (newY > oldY) {\\n            move = \\'D\\';\\n        }\\n        for (int i = 0; i < Math.abs(newY - oldY); i++) {\\n            res.append(move);\\n        }\\n        return newY;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String alphabetBoardPath(String target) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        int x = 0, y = 0;\\n        for (char c : target.toCharArray()) {\\n            int[] next = getLetterCoord(c);\\n            if (c != \\'z\\') {\\n                x = moveHoriz(x, next[0], res);\\n                y = moveVert(y, next[1], res);\\n            }\\n            else {\\n                y = moveVert(y, next[1], res);\\n                x = moveHoriz(x, next[0], res);\\n            }\\n            res.append(\"!\");\\n        }\\n        return res.toString();\\n    }\\n    \\n    // [0] - x         [1] - y\\n    private int[] getLetterCoord(char c) {\\n        int ind = c - \\'a\\';\\n        return new int[] {ind % 5, ind / 5};\\n    }\\n    \\n    private int moveHoriz(int oldX, int newX, StringBuilder res) {\\n        char move = \\'L\\';\\n        if (newX > oldX) {\\n            move = \\'R\\';\\n        }\\n        for (int i = 0; i < Math.abs(newX - oldX); i++) {\\n            res.append(move);\\n        }\\n        return newX;\\n    }\\n    \\n    private int moveVert(int oldY, int newY, StringBuilder res) {\\n        char move = \\'U\\';\\n        if (newY > oldY) {\\n            move = \\'D\\';\\n        }\\n        for (int i = 0; i < Math.abs(newY - oldY); i++) {\\n            res.append(move);\\n        }\\n        return newY;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 446646,
                "title": "python-beats-90",
                "content": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        output = []\\n        currPosX, currPosY = 0,0\\n        \\n        for t in target:\\n            targetX = (ord(t) - ord(\\'a\\')) % 5\\n            targetY = (ord(t) - ord(\\'a\\')) // 5\\n            while currPosY != targetY or currPosX != targetX:\\n                if currPosY != targetY:\\n                    if currPosY < targetY and not (currPosY == 4 and currPosX > 0):\\n                        output.append(\\'D\\')\\n                        currPosY += 1\\n                    elif currPosY > targetY:\\n                        output.append(\\'U\\')\\n                        currPosY -= 1\\n                if currPosX != targetX:\\n                    if currPosX < targetX and currPosY != 5:\\n                        output.append(\\'R\\')\\n                        currPosX += 1\\n                    elif currPosX > targetX:\\n                        output.append(\\'L\\')\\n                        currPosX -= 1\\n            output.append(\\'!\\')\\n        \\n        return \\'\\'.join(output)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        output = []\\n        currPosX, currPosY = 0,0\\n        \\n        for t in target:\\n            targetX = (ord(t) - ord(\\'a\\')) % 5\\n            targetY = (ord(t) - ord(\\'a\\')) // 5\\n            while currPosY != targetY or currPosX != targetX:\\n                if currPosY != targetY:\\n                    if currPosY < targetY and not (currPosY == 4 and currPosX > 0):\\n                        output.append(\\'D\\')\\n                        currPosY += 1\\n                    elif currPosY > targetY:\\n                        output.append(\\'U\\')\\n                        currPosY -= 1\\n                if currPosX != targetX:\\n                    if currPosX < targetX and currPosY != 5:\\n                        output.append(\\'R\\')\\n                        currPosX += 1\\n                    elif currPosX > targetX:\\n                        output.append(\\'L\\')\\n                        currPosX -= 1\\n            output.append(\\'!\\')\\n        \\n        return \\'\\'.join(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382942,
                "title": "thinking-process",
                "content": "> The board is special because of its fixed layout. We can tell the coordinate of a given character.\\n\\n> `z` in the board is special because it has move limitations. To move from `z`,  we move up then move right. To move to `z`, we move left then move down. That\\'s promised to be valid.\\n\\n****\\n```\\n    private StringBuilder result;\\n    \\n    public String alphabetBoardPath(String target) {\\n        result = new StringBuilder();\\n        int x = 0, y = 0; // current position\\n        for (char ch : target.toCharArray()) {\\n            int nx = (ch - \\'a\\') / 5;\\n            int ny = (ch - \\'a\\') % 5;\\n            // from (x, y) to (nx, ny)\\n            moveTo(x, y, nx, ny);\\n            result.append(\"!\");\\n            x = nx;\\n            y = ny;\\n        }\\n        return result.toString();\\n    }\\n    \\n    private void moveTo(int x, int y, int nx, int ny) {\\n        while (nx < x) {\\n            // U\\n            x--;\\n            result.append(\"U\");\\n        }\\n        while (ny > y) {\\n            // R\\n            y++;\\n            result.append(\"R\");\\n        }\\n        while (y > ny) {\\n            // L\\n            y--;\\n            result.append(\"L\");\\n        }\\n        while (x < nx) {\\n            // D\\n            x++;\\n            result.append(\"D\");\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private StringBuilder result;\\n    \\n    public String alphabetBoardPath(String target) {\\n        result = new StringBuilder();\\n        int x = 0, y = 0; // current position\\n        for (char ch : target.toCharArray()) {\\n            int nx = (ch - \\'a\\') / 5;\\n            int ny = (ch - \\'a\\') % 5;\\n            // from (x, y) to (nx, ny)\\n            moveTo(x, y, nx, ny);\\n            result.append(\"!\");\\n            x = nx;\\n            y = ny;\\n        }\\n        return result.toString();\\n    }\\n    \\n    private void moveTo(int x, int y, int nx, int ny) {\\n        while (nx < x) {\\n            // U\\n            x--;\\n            result.append(\"U\");\\n        }\\n        while (ny > y) {\\n            // R\\n            y++;\\n            result.append(\"R\");\\n        }\\n        while (y > ny) {\\n            // L\\n            y--;\\n            result.append(\"L\");\\n        }\\n        while (x < nx) {\\n            // D\\n            x++;\\n            result.append(\"D\");\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346616,
                "title": "swift-using-dictionary-4-ms",
                "content": "```\\nclass Solution {\\n    func alphabetBoardPath(_ target: String) -> String {\\n        let board: [Character: (row: Int, col: Int)] = [\"a\": (0, 0), \"b\": (0, 1), \"c\": (0, 2), \"d\": (0, 3), \"e\": (0, 4),\\n                                                    \"f\": (1, 0), \"g\": (1, 1), \"h\": (1, 2), \"i\": (1, 3), \"j\": (1, 4),\\n                                                    \"k\": (2, 0), \"l\": (2, 1), \"m\": (2, 2), \"n\": (2, 3), \"o\": (2, 4),\\n                                                    \"p\": (3, 0), \"q\": (3, 1), \"r\": (3, 2), \"s\": (3, 3), \"t\": (3, 4),\\n                                                    \"u\": (4, 0), \"v\": (4, 1), \"w\": (4, 2), \"x\": (4, 3), \"y\": (4, 4),\\n                                                    \"z\": (5, 0)\\n                                                    ]\\n    \\n        var prevChar: Character = \"a\"\\n        var moves: String = \"\"\\n    \\n        for eachChar in [Character](target) {\\n\\n            while eachChar != prevChar {\\n                switch prevChar {\\n                    case \"z\":\\n                        moves += \"U\"\\n                        prevChar = \"u\"\\n                        continue\\n\\n                    default:\\n                        let leftOrRight = board[eachChar]!.col - board[prevChar]!.col\\n                        let upOrDown = board[eachChar]!.row - board[prevChar]!.row\\n\\n                        switch leftOrRight.signum() { // Move Left or Right\\n                            case -1:\\n                                moves += repeatElement(\"L\", count: -leftOrRight)\\n                            case 1:\\n                                moves += repeatElement(\"R\", count:  leftOrRight)\\n                            default:\\n                                moves.append(\"\")\\n                        }\\n\\n                        switch upOrDown.signum() { // Then Move Up or Down\\n                            case -1:\\n                                moves += repeatElement(\"U\", count: -upOrDown)\\n                            case 1:\\n                                moves += repeatElement(\"D\", count:  upOrDown)\\n                            default:\\n                                moves.append(\"\")\\n                    }\\n                }\\n                prevChar = eachChar\\n            }\\n            moves += \"!\"\\n        }\\n        return moves    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func alphabetBoardPath(_ target: String) -> String {\\n        let board: [Character: (row: Int, col: Int)] = [\"a\": (0, 0), \"b\": (0, 1), \"c\": (0, 2), \"d\": (0, 3), \"e\": (0, 4),\\n                                                    \"f\": (1, 0), \"g\": (1, 1), \"h\": (1, 2), \"i\": (1, 3), \"j\": (1, 4),\\n                                                    \"k\": (2, 0), \"l\": (2, 1), \"m\": (2, 2), \"n\": (2, 3), \"o\": (2, 4),\\n                                                    \"p\": (3, 0), \"q\": (3, 1), \"r\": (3, 2), \"s\": (3, 3), \"t\": (3, 4),\\n                                                    \"u\": (4, 0), \"v\": (4, 1), \"w\": (4, 2), \"x\": (4, 3), \"y\": (4, 4),\\n                                                    \"z\": (5, 0)\\n                                                    ]\\n    \\n        var prevChar: Character = \"a\"\\n        var moves: String = \"\"\\n    \\n        for eachChar in [Character](target) {\\n\\n            while eachChar != prevChar {\\n                switch prevChar {\\n                    case \"z\":\\n                        moves += \"U\"\\n                        prevChar = \"u\"\\n                        continue\\n\\n                    default:\\n                        let leftOrRight = board[eachChar]!.col - board[prevChar]!.col\\n                        let upOrDown = board[eachChar]!.row - board[prevChar]!.row\\n\\n                        switch leftOrRight.signum() { // Move Left or Right\\n                            case -1:\\n                                moves += repeatElement(\"L\", count: -leftOrRight)\\n                            case 1:\\n                                moves += repeatElement(\"R\", count:  leftOrRight)\\n                            default:\\n                                moves.append(\"\")\\n                        }\\n\\n                        switch upOrDown.signum() { // Then Move Up or Down\\n                            case -1:\\n                                moves += repeatElement(\"U\", count: -upOrDown)\\n                            case 1:\\n                                moves += repeatElement(\"D\", count:  upOrDown)\\n                            default:\\n                                moves.append(\"\")\\n                    }\\n                }\\n                prevChar = eachChar\\n            }\\n            moves += \"!\"\\n        }\\n        return moves    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346127,
                "title": "c-o-n-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Cord {\\n        int x; int y;\\n    };\\n    Cord getCord(char c) {\\n        int val = c-\\'a\\';\\n        Cord Cd;\\n        Cd.x = val % 5;\\n        Cd.y = val/5;\\n        return Cd;\\n    }\\n    void getPath(Cord a, Cord b, string &result) {\\n        while(a.x!=b.x || a.y!=b.y) {\\n            if (a.y > b.y) {\\n                result+=\\'U\\';\\n                a.y--;\\n                \\n            }\\n            else if ( b.x < a.x) {\\n                result+=\\'L\\';\\n                a.x--;\\n            }\\n            else if (a.y < b.y) {\\n                result+=\\'D\\';\\n                a.y++;\\n            }\\n            else {\\n                result+=\\'R\\';\\n                a.x++;\\n            }\\n        }\\n        result+=\\'!\\';\\n    }\\n    string alphabetBoardPath(string target) {\\n        Cord begin;\\n        begin.x = 0;\\n        begin.y = 0;\\n        string result;\\n        \\n        for (int i =0; i< target.size(); i++) {\\n            Cord to = getCord(target[i]);\\n            getPath(begin,to, result);\\n            begin = to;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Cord {\\n        int x; int y;\\n    };\\n    Cord getCord(char c) {\\n        int val = c-\\'a\\';\\n        Cord Cd;\\n        Cd.x = val % 5;\\n        Cd.y = val/5;\\n        return Cd;\\n    }\\n    void getPath(Cord a, Cord b, string &result) {\\n        while(a.x!=b.x || a.y!=b.y) {\\n            if (a.y > b.y) {\\n                result+=\\'U\\';\\n                a.y--;\\n                \\n            }\\n            else if ( b.x < a.x) {\\n                result+=\\'L\\';\\n                a.x--;\\n            }\\n            else if (a.y < b.y) {\\n                result+=\\'D\\';\\n                a.y++;\\n            }\\n            else {\\n                result+=\\'R\\';\\n                a.x++;\\n            }\\n        }\\n        result+=\\'!\\';\\n    }\\n    string alphabetBoardPath(string target) {\\n        Cord begin;\\n        begin.x = 0;\\n        begin.y = 0;\\n        string result;\\n        \\n        for (int i =0; i< target.size(); i++) {\\n            Cord to = getCord(target[i]);\\n            getPath(begin,to, result);\\n            begin = to;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345531,
                "title": "java-straightforward-solution",
                "content": "```\\n\\tint[][] alphabet = new int[][]{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {1, 0}, {1, 1}\\n            , {1, 2}, {1, 3}, {1, 4}, {2, 0}, {2, 1}, {2, 2}, {2, 3}, {2, 4}, {3, 0}, {3, 1}, {3, 2}, {3, 3}\\n            , {3, 4}, {4, 0}, {4, 1}, {4, 2}, {4, 3}, {4, 4}, {5, 0}};\\n\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t// Current location.\\n        int[] location = new int[]{0, 0};\\n\\t\\t// Starting alphabet.\\n        char s = \\' \\';\\n        for (char c : target.toCharArray()) {\\n            sb.append(findNextAlphabet(location, c, s));\\n            s = c;\\n        }\\n        return sb.toString();\\n    }\\n\\n\\t// c represents the alphabet we want to reach.\\n    private String findNextAlphabet(int[] location, char c, char s) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] nextLocation = alphabet[c - \\'a\\'];\\n        int nextI = nextLocation[0];\\n        int nextJ = nextLocation[1];\\n        // If the starting alphabet is \\'z\\', then moves vertically first.\\n        // Otherwise, moves horizontally first.\\n        if (s == \\'z\\') {\\n            if (nextI > location[0]) {\\n                for (int i = 0; i < (nextI - location[0]); i++) {\\n                    sb.append(\"D\");\\n                }\\n            } else if (nextI < location[0]) {\\n                for (int i = 0; i < (location[0] - nextI); i++) {\\n                    sb.append(\"U\");\\n                }\\n            }\\n            if (nextJ > location[1]) {\\n                for (int i = 0; i < (nextJ - location[1]); i++) {\\n                    sb.append(\"R\");\\n                }\\n            } else if (nextJ < location[1]) {\\n                for (int i = 0; i < (location[1] - nextJ); i++) {\\n                    sb.append(\"L\");\\n                }\\n            }\\n        } else {\\n            if (nextJ > location[1]) {\\n                for (int i = 0; i < (nextJ - location[1]); i++) {\\n                    sb.append(\"R\");\\n                }\\n            } else if (nextJ < location[1]) {\\n                for (int i = 0; i < (location[1] - nextJ); i++) {\\n                    sb.append(\"L\");\\n                }\\n            }\\n            if (nextI > location[0]) {\\n                for (int i = 0; i < (nextI - location[0]); i++) {\\n                    sb.append(\"D\");\\n                }\\n            } else if (nextI < location[0]) {\\n                for (int i = 0; i < (location[0] - nextI); i++) {\\n                    sb.append(\"U\");\\n                }\\n            }\\n        }\\n\\n        sb.append(\"!\");\\n        location[0] = nextI;\\n        location[1] = nextJ;\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint[][] alphabet = new int[][]{{0, 0}, {0, 1}, {0, 2}, {0, 3}, {0, 4}, {1, 0}, {1, 1}\\n            , {1, 2}, {1, 3}, {1, 4}, {2, 0}, {2, 1}, {2, 2}, {2, 3}, {2, 4}, {3, 0}, {3, 1}, {3, 2}, {3, 3}\\n            , {3, 4}, {4, 0}, {4, 1}, {4, 2}, {4, 3}, {4, 4}, {5, 0}};\\n\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder sb = new StringBuilder();\\n\\t\\t// Current location.\\n        int[] location = new int[]{0, 0};\\n\\t\\t// Starting alphabet.\\n        char s = \\' \\';\\n        for (char c : target.toCharArray()) {\\n            sb.append(findNextAlphabet(location, c, s));\\n            s = c;\\n        }\\n        return sb.toString();\\n    }\\n\\n\\t// c represents the alphabet we want to reach.\\n    private String findNextAlphabet(int[] location, char c, char s) {\\n        StringBuilder sb = new StringBuilder();\\n        int[] nextLocation = alphabet[c - \\'a\\'];\\n        int nextI = nextLocation[0];\\n        int nextJ = nextLocation[1];\\n        // If the starting alphabet is \\'z\\', then moves vertically first.\\n        // Otherwise, moves horizontally first.\\n        if (s == \\'z\\') {\\n            if (nextI > location[0]) {\\n                for (int i = 0; i < (nextI - location[0]); i++) {\\n                    sb.append(\"D\");\\n                }\\n            } else if (nextI < location[0]) {\\n                for (int i = 0; i < (location[0] - nextI); i++) {\\n                    sb.append(\"U\");\\n                }\\n            }\\n            if (nextJ > location[1]) {\\n                for (int i = 0; i < (nextJ - location[1]); i++) {\\n                    sb.append(\"R\");\\n                }\\n            } else if (nextJ < location[1]) {\\n                for (int i = 0; i < (location[1] - nextJ); i++) {\\n                    sb.append(\"L\");\\n                }\\n            }\\n        } else {\\n            if (nextJ > location[1]) {\\n                for (int i = 0; i < (nextJ - location[1]); i++) {\\n                    sb.append(\"R\");\\n                }\\n            } else if (nextJ < location[1]) {\\n                for (int i = 0; i < (location[1] - nextJ); i++) {\\n                    sb.append(\"L\");\\n                }\\n            }\\n            if (nextI > location[0]) {\\n                for (int i = 0; i < (nextI - location[0]); i++) {\\n                    sb.append(\"D\");\\n                }\\n            } else if (nextI < location[0]) {\\n                for (int i = 0; i < (location[0] - nextI); i++) {\\n                    sb.append(\"U\");\\n                }\\n            }\\n        }\\n\\n        sb.append(\"!\");\\n        location[0] = nextI;\\n        location[1] = nextJ;\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345343,
                "title": "simple-bfs-solution",
                "content": "``` csharp\\n class BoardPoint\\n {\\n        public int X;\\n        public int Y;\\n        public List<char> Directions;\\n\\n        public BoardPoint(int x, int y)\\n        {\\n\\t\\t\\t\\tX = x;\\n\\t\\t\\t\\tY = y;\\n\\t\\t\\t\\tDirections = new List<char>();\\n        }\\n\\n        public BoardPoint(int x, int y, List<char> directions) : this(x, y)\\n        {            \\n            Directions = directions;\\n        }\\n}\\n\\npublic class Solution \\n{\\n\\t\\tpublic string AlphabetBoardPath(string target)\\n        {\\n            char[][] board = new char[][] { \"abcde\".ToCharArray(), \"fghij\".ToCharArray(), \"klmno\".ToCharArray(), \"pqrst\".ToCharArray(), \"uvwxy\".ToCharArray(), \"z\".ToCharArray() };\\n\\n            if (target == null || target.Length == 0)\\n            {\\n                return null;\\n            }\\n            return BFS(board, target);\\n        }\\n\\n        public string BFS(char[][] board, string target)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            bool[] visited = new bool[26];\\n            Queue<BoardPoint> q = new Queue<BoardPoint>();\\n\\n            int[,] directions = new int[,] { { 0, -1 }, { -1, 0 }, { 0, 1 }, { 1, 0 } };\\n            char[] chard = new char[] { \\'L\\', \\'U\\', \\'R\\', \\'D\\' };\\n\\n            q.Enqueue(new BoardPoint(0, 0));\\n            visited[0] = true;\\n\\n            int nextchar = 0;\\n            char d = target[nextchar++];\\n\\n            while (q.Count > 0)\\n            {\\n                var pair = q.Dequeue();\\n                if (board[pair.X][pair.Y] == d)\\n                {\\n                    q.Clear();\\n                    sb.Append(new string(pair.Directions.ToArray()));\\n                    sb.Append(\\'!\\');\\n                    if (nextchar == target.Length)\\n                    {\\n                        return sb.ToString();\\n                    }\\n\\n                    for (int i = 0; i < visited.Length; i++)\\n                    {\\n                        visited[i] = false;\\n                    }\\n\\n                    d = target[nextchar++];\\n                    q.Enqueue(new BoardPoint(pair.X, pair.Y));\\n                    continue;\\n                }\\n\\n                for (int i = 0; i < directions.GetLength(0); i++)\\n                {\\n                    int x = pair.X + directions[i, 0];\\n                    int y = pair.Y + directions[i, 1];\\n                    if (x >= 0 && x < board.GetLength(0) && y >= 0 && y < board[x].Length && !visited[board[x][y] - \\'a\\'])\\n                    {\\n                        visited[board[x][y] - \\'a\\'] = true;\\n                        var pairDirections = pair.Directions.Select(p => p).ToList();\\n                        pairDirections.Add(chard[i]);\\n                        BoardPoint point = new BoardPoint(x, y, pairDirections);\\n                        q.Enqueue(point);\\n                    }\\n                }\\n            }\\n            return null;\\n        }\\n}\\n\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "``` csharp\\n class BoardPoint\\n {\\n        public int X;\\n        public int Y;\\n        public List<char> Directions;\\n\\n        public BoardPoint(int x, int y)\\n        {\\n\\t\\t\\t\\tX = x;\\n\\t\\t\\t\\tY = y;\\n\\t\\t\\t\\tDirections = new List<char>();\\n        }\\n\\n        public BoardPoint(int x, int y, List<char> directions) : this(x, y)\\n        {            \\n            Directions = directions;\\n        }\\n}\\n\\npublic class Solution \\n{\\n\\t\\tpublic string AlphabetBoardPath(string target)\\n        {\\n            char[][] board = new char[][] { \"abcde\".ToCharArray(), \"fghij\".ToCharArray(), \"klmno\".ToCharArray(), \"pqrst\".ToCharArray(), \"uvwxy\".ToCharArray(), \"z\".ToCharArray() };\\n\\n            if (target == null || target.Length == 0)\\n            {\\n                return null;\\n            }\\n            return BFS(board, target);\\n        }\\n\\n        public string BFS(char[][] board, string target)\\n        {\\n            StringBuilder sb = new StringBuilder();\\n            bool[] visited = new bool[26];\\n            Queue<BoardPoint> q = new Queue<BoardPoint>();\\n\\n            int[,] directions = new int[,] { { 0, -1 }, { -1, 0 }, { 0, 1 }, { 1, 0 } };\\n            char[] chard = new char[] { \\'L\\', \\'U\\', \\'R\\', \\'D\\' };\\n\\n            q.Enqueue(new BoardPoint(0, 0));\\n            visited[0] = true;\\n\\n            int nextchar = 0;\\n            char d = target[nextchar++];\\n\\n            while (q.Count > 0)\\n            {\\n                var pair = q.Dequeue();\\n                if (board[pair.X][pair.Y] == d)\\n                {\\n                    q.Clear();\\n                    sb.Append(new string(pair.Directions.ToArray()));\\n                    sb.Append(\\'!\\');\\n                    if (nextchar == target.Length)\\n                    {\\n                        return sb.ToString();\\n                    }\\n\\n                    for (int i = 0; i < visited.Length; i++)\\n                    {\\n                        visited[i] = false;\\n                    }\\n\\n                    d = target[nextchar++];\\n                    q.Enqueue(new BoardPoint(pair.X, pair.Y));\\n                    continue;\\n                }\\n\\n                for (int i = 0; i < directions.GetLength(0); i++)\\n                {\\n                    int x = pair.X + directions[i, 0];\\n                    int y = pair.Y + directions[i, 1];\\n                    if (x >= 0 && x < board.GetLength(0) && y >= 0 && y < board[x].Length && !visited[board[x][y] - \\'a\\'])\\n                    {\\n                        visited[board[x][y] - \\'a\\'] = true;\\n                        var pairDirections = pair.Directions.Select(p => p).ToList();\\n                        pairDirections.Add(chard[i]);\\n                        BoardPoint point = new BoardPoint(x, y, pairDirections);\\n                        q.Enqueue(point);\\n                    }\\n                }\\n            }\\n            return null;\\n        }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345316,
                "title": "10-line-python-solution",
                "content": "Note that since `border` elements are all distinct, there is a unique length of the shortest path between any two cells.\\n\\nTo avoid paths across undefined territory, always move left or up before moving right or down.\\n\\n```\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        r, c = 0, 0\\n        ret = \"\"\\n        for char in target:\\n            idx = ord(char) - ord(\\'a\\')\\n            rr, cc = idx/5, idx%5\\n            ret += \\'U\\'*max(0, r-rr)\\n            ret += \\'L\\'*max(0, c-cc)\\n            ret += \\'D\\'*max(0, rr-r)\\n            ret += \\'R\\'*max(0, cc-c)\\n            r, c = rr, cc\\n            ret += \\'!\\'\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        r, c = 0, 0\\n        ret = \"\"\\n        for char in target:\\n            idx = ord(char) - ord(\\'a\\')\\n            rr, cc = idx/5, idx%5\\n            ret += \\'U\\'*max(0, r-rr)\\n            ret += \\'L\\'*max(0, c-cc)\\n            ret += \\'D\\'*max(0, rr-r)\\n            ret += \\'R\\'*max(0, cc-c)\\n            r, c = rr, cc\\n            ret += \\'!\\'\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345296,
                "title": "easy-c-solution-with-explanation",
                "content": "**Important point to notice**\\n* i,j ---> current row,column number.\\n* p,q --->  row,column number of our destination\\n* r,s ---> how much we have to move UP/DOWN or LEFT/RIGHT \\n* If i==5 i.e. we are currently in \\'z\\', then  move UP before doing anything.\\n* Otherwise choose LEFT/RIGHT first, then UP/DOWN\\n\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int i=0,j=0;\\n        string result=\"\";\\n        for(auto x : target){\\n            int p=(x-\\'a\\')/5,q=(x-\\'a\\')%5;\\n            \\n            int r=i-p,s=j-q;\\n            \\n            if(i!=5){\\n                if(s>0) while(s--) result+=\\'L\\';\\n                else while(s++) result+=\\'R\\';\\n                if(r>0) while(r--) result+=\\'U\\';\\n                else while(r++) result+=\\'D\\';\\n            }\\n            else{\\n                if(r>0) while(r--) result+=\\'U\\';\\n                else while(r++) result+=\\'D\\';\\n                if(s>0) while(s--) result+=\\'L\\';\\n                else while(s++) result+=\\'R\\';\\n            }\\n            result+=\\'!\\';\\n            i=p;j=q;\\n                \\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int i=0,j=0;\\n        string result=\"\";\\n        for(auto x : target){\\n            int p=(x-\\'a\\')/5,q=(x-\\'a\\')%5;\\n            \\n            int r=i-p,s=j-q;\\n            \\n            if(i!=5){\\n                if(s>0) while(s--) result+=\\'L\\';\\n                else while(s++) result+=\\'R\\';\\n                if(r>0) while(r--) result+=\\'U\\';\\n                else while(r++) result+=\\'D\\';\\n            }\\n            else{\\n                if(r>0) while(r--) result+=\\'U\\';\\n                else while(r++) result+=\\'D\\';\\n                if(s>0) while(s--) result+=\\'L\\';\\n                else while(s++) result+=\\'R\\';\\n            }\\n            result+=\\'!\\';\\n            i=p;j=q;\\n                \\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345282,
                "title": "javascript-easy-to-understand-solution",
                "content": "Steps:\\n1. build index of characters\\n2. calculate diff between characters\\n3. generate instructions (handle case of z)\\n\\n```js\\n/**\\n * @param {string} target\\n * @return {string}\\n */\\nvar alphabetBoardPath = function(target) {\\n  const board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\n  const boardIndex = {};\\n  for (var i = 0; i < board.length; i++) {\\n    row = board[i];\\n    for (var j = 0; j < row.length; j++) {\\n      boardIndex[row[j]] = [i, j];\\n    }\\n  }\\n\\n  target = \\'a\\' + target;\\n\\n  let ans = \\'\\';\\n  for (var i = 0; i < target.length - 1; i++) {\\n    const diff = getDiff(target[i], target[i+1]);\\n    const inst = getInst(diff, target[i], target[i+1]);\\n    ans = ans + inst + \\'!\\';\\n  }\\n  return ans;\\n\\n  function getDiff(start, end) {\\n    return [boardIndex[end][0] - boardIndex[start][0], boardIndex[end][1] - boardIndex[start][1]];\\n  }\\n\\n  function genX(diff) {\\n    let ins = \\'\\';\\n    const letter = diff > 0 ? \\'R\\' : \\'L\\';\\n    diff = Math.abs(diff);\\n    for (var i = 0; i < diff; i++) {\\n      ins = ins + letter;\\n    }\\n    return ins;\\n  }\\n\\n  function genY(diff) {\\n    let ins = \\'\\';\\n    const letter = diff > 0 ? \\'D\\' : \\'U\\';\\n    diff = Math.abs(diff);\\n    for (var i = 0; i < diff; i++) {\\n      ins = ins + letter;\\n    }\\n    return ins;\\n  }\\n\\n  function getInst(diff, start, end) {\\n    let ins;\\n    if (start === \\'z\\') {\\n      ins = genY(diff[0]);\\n      ins = ins + genX(diff[1]);\\n    } else {\\n      ins = genX(diff[1]);\\n      ins = ins + genY(diff[0]);\\n    }\\n    return ins;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {string} target\\n * @return {string}\\n */\\nvar alphabetBoardPath = function(target) {\\n  const board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\n  const boardIndex = {};\\n  for (var i = 0; i < board.length; i++) {\\n    row = board[i];\\n    for (var j = 0; j < row.length; j++) {\\n      boardIndex[row[j]] = [i, j];\\n    }\\n  }\\n\\n  target = \\'a\\' + target;\\n\\n  let ans = \\'\\';\\n  for (var i = 0; i < target.length - 1; i++) {\\n    const diff = getDiff(target[i], target[i+1]);\\n    const inst = getInst(diff, target[i], target[i+1]);\\n    ans = ans + inst + \\'!\\';\\n  }\\n  return ans;\\n\\n  function getDiff(start, end) {\\n    return [boardIndex[end][0] - boardIndex[start][0], boardIndex[end][1] - boardIndex[start][1]];\\n  }\\n\\n  function genX(diff) {\\n    let ins = \\'\\';\\n    const letter = diff > 0 ? \\'R\\' : \\'L\\';\\n    diff = Math.abs(diff);\\n    for (var i = 0; i < diff; i++) {\\n      ins = ins + letter;\\n    }\\n    return ins;\\n  }\\n\\n  function genY(diff) {\\n    let ins = \\'\\';\\n    const letter = diff > 0 ? \\'D\\' : \\'U\\';\\n    diff = Math.abs(diff);\\n    for (var i = 0; i < diff; i++) {\\n      ins = ins + letter;\\n    }\\n    return ins;\\n  }\\n\\n  function getInst(diff, start, end) {\\n    let ins;\\n    if (start === \\'z\\') {\\n      ins = genY(diff[0]);\\n      ins = ins + genX(diff[1]);\\n    } else {\\n      ins = genX(diff[1]);\\n      ins = ins + genY(diff[0]);\\n    }\\n    return ins;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 345262,
                "title": "java-straightforward-bfs-solution",
                "content": "The key to solve this problem is to break down this problem into subproblems.\\n1.Have a function that find a target character in the board in the minimum number of moves from some (x,y) coordinate\\n2.Iterate through the target string and append the subfunction\\'s path to final answer, update coordinate along the way\\n```\\nclass Solution {\\n    char[][] board = new char[][]{{\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'}, {\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'}, {\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'}, {\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'}, {\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'},{\\'z\\'}};\\n    int[][] dirs = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    String[] s_dirs = new String[]{\"D\",\"R\",\"U\",\"L\"};\\n    \\n    class Result{\\n        String s;\\n        int x;\\n        int y;\\n        public Result(String s, int x, int y){\\n            this.s = s;\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    public String alphabetBoardPath(String target) {\\n        StringBuilder stb = new StringBuilder();\\n        int x = 0, y = 0;\\n        for(char c:target.toCharArray()){\\n            Result res = traverse(c, x, y);\\n            stb.append(res.s);\\n            stb.append(\\'!\\');\\n            x = res.x;\\n            y = res.y;\\n        }\\n        return stb.toString();\\n    }\\n    \\n    public Result traverse(char c, int i, int j){\\n        Queue<int[]> queue = new LinkedList<>();\\n        Queue<String> s_queue = new LinkedList<>();\\n        queue.offer(new int[]{i,j});\\n        s_queue.offer(\"\");\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int l=0;l<size;l++){\\n                int[] curr = queue.poll();\\n                String path = s_queue.poll();\\n                if(board[curr[0]][curr[1]]==c){\\n                    return new Result(path, curr[0], curr[1]);\\n                }\\n                for(int k=0;k<dirs.length;k++){\\n                    int[] dir = dirs[k];\\n                    String s_dir = s_dirs[k];\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x>=0 && x<board.length && y>=0 && y<board[x].length){\\n                        queue.offer(new int[]{x,y});\\n                        s_queue.offer(path+s_dir);\\n                    }\\n                }\\n            }\\n        }\\n        return new Result(\"\", -1, -1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[][] board = new char[][]{{\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'}, {\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'}, {\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'}, {\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'}, {\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'},{\\'z\\'}};\\n    int[][] dirs = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    String[] s_dirs = new String[]{\"D\",\"R\",\"U\",\"L\"};\\n    \\n    class Result{\\n        String s;\\n        int x;\\n        int y;\\n        public Result(String s, int x, int y){\\n            this.s = s;\\n            this.x = x;\\n            this.y = y;\\n        }\\n    }\\n    \\n    public String alphabetBoardPath(String target) {\\n        StringBuilder stb = new StringBuilder();\\n        int x = 0, y = 0;\\n        for(char c:target.toCharArray()){\\n            Result res = traverse(c, x, y);\\n            stb.append(res.s);\\n            stb.append(\\'!\\');\\n            x = res.x;\\n            y = res.y;\\n        }\\n        return stb.toString();\\n    }\\n    \\n    public Result traverse(char c, int i, int j){\\n        Queue<int[]> queue = new LinkedList<>();\\n        Queue<String> s_queue = new LinkedList<>();\\n        queue.offer(new int[]{i,j});\\n        s_queue.offer(\"\");\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int l=0;l<size;l++){\\n                int[] curr = queue.poll();\\n                String path = s_queue.poll();\\n                if(board[curr[0]][curr[1]]==c){\\n                    return new Result(path, curr[0], curr[1]);\\n                }\\n                for(int k=0;k<dirs.length;k++){\\n                    int[] dir = dirs[k];\\n                    String s_dir = s_dirs[k];\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x>=0 && x<board.length && y>=0 && y<board[x].length){\\n                        queue.offer(new int[]{x,y});\\n                        s_queue.offer(path+s_dir);\\n                    }\\n                }\\n            }\\n        }\\n        return new Result(\"\", -1, -1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345216,
                "title": "java-straightforward-simulation-solution-w-explanation",
                "content": "It\\'s ugly but it works.\\nThe only \"tricky part\" of the solution is to make sure the ordering of the moves are right. You always want \"up\" before \"right\" in the case that you\\'re at `z` and need to move elsewhere. This is to ensure you don\\'t go out of bound.\\n\\nSimilarly, you want \"left\" before \"down\" in the case that you\\'re elsewhere and you want to go to `z`.\\n\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        HashMap<Character, int[]> map = new HashMap<Character, int[]>();\\n        populateMap(map);\\n        StringBuilder sb = new StringBuilder();\\n        getSequence(target, 0, sb, map, 0, 0);\\n        return sb.toString();\\n    }\\n    \\n    private void populateMap(HashMap<Character, int[]>map) {\\n        map.put(\\'a\\', new int[]{0, 0});\\n        map.put(\\'b\\', new int[]{0, 1});\\n        map.put(\\'c\\', new int[]{0, 2});\\n        map.put(\\'d\\', new int[]{0, 3});\\n        map.put(\\'e\\', new int[]{0, 4});\\n        \\n        map.put(\\'f\\', new int[]{1, 0});\\n        map.put(\\'g\\', new int[]{1, 1});\\n        map.put(\\'h\\', new int[]{1, 2});\\n        map.put(\\'i\\', new int[]{1, 3});\\n        map.put(\\'j\\', new int[]{1, 4});\\n        \\n        map.put(\\'k\\', new int[]{2, 0});\\n        map.put(\\'l\\', new int[]{2, 1});\\n        map.put(\\'m\\', new int[]{2, 2});\\n        map.put(\\'n\\', new int[]{2, 3});\\n        map.put(\\'o\\', new int[]{2, 4});\\n        \\n        map.put(\\'p\\', new int[]{3, 0});\\n        map.put(\\'q\\', new int[]{3, 1});\\n        map.put(\\'r\\', new int[]{3, 2});\\n        map.put(\\'s\\', new int[]{3, 3});\\n        map.put(\\'t\\', new int[]{3, 4});\\n        \\n        map.put(\\'u\\', new int[]{4, 0});\\n        map.put(\\'v\\', new int[]{4, 1});\\n        map.put(\\'w\\', new int[]{4, 2});\\n        map.put(\\'x\\', new int[]{4, 3});\\n        map.put(\\'y\\', new int[]{4, 4});\\n        \\n        map.put(\\'z\\', new int[]{5, 0});\\n\\n    }\\n    \\n    private void getSequence(String target, int idx, StringBuilder sb, HashMap<Character, int[]> map, int x, int y) {\\n        if (idx == target.length())\\n            return;\\n        char c = target.charAt(idx);\\n        int targX = map.get(c)[1];\\n        int targY = map.get(c)[0];\\n        \\n        while(y > targY) {\\n            sb.append(\\'U\\');\\n            y--;\\n        }\\n        \\n        while (x < targX) {\\n            sb.append(\\'R\\');\\n            x++;\\n        }\\n        while (x > targX) {\\n            sb.append(\\'L\\');\\n            x--;\\n        }\\n        while(y < targY) {\\n            sb.append(\\'D\\');\\n            y++;\\n        }\\n        sb.append(\\'!\\');\\n        getSequence(target, idx+1, sb, map, targX, targY);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        HashMap<Character, int[]> map = new HashMap<Character, int[]>();\\n        populateMap(map);\\n        StringBuilder sb = new StringBuilder();\\n        getSequence(target, 0, sb, map, 0, 0);\\n        return sb.toString();\\n    }\\n    \\n    private void populateMap(HashMap<Character, int[]>map) {\\n        map.put(\\'a\\', new int[]{0, 0});\\n        map.put(\\'b\\', new int[]{0, 1});\\n        map.put(\\'c\\', new int[]{0, 2});\\n        map.put(\\'d\\', new int[]{0, 3});\\n        map.put(\\'e\\', new int[]{0, 4});\\n        \\n        map.put(\\'f\\', new int[]{1, 0});\\n        map.put(\\'g\\', new int[]{1, 1});\\n        map.put(\\'h\\', new int[]{1, 2});\\n        map.put(\\'i\\', new int[]{1, 3});\\n        map.put(\\'j\\', new int[]{1, 4});\\n        \\n        map.put(\\'k\\', new int[]{2, 0});\\n        map.put(\\'l\\', new int[]{2, 1});\\n        map.put(\\'m\\', new int[]{2, 2});\\n        map.put(\\'n\\', new int[]{2, 3});\\n        map.put(\\'o\\', new int[]{2, 4});\\n        \\n        map.put(\\'p\\', new int[]{3, 0});\\n        map.put(\\'q\\', new int[]{3, 1});\\n        map.put(\\'r\\', new int[]{3, 2});\\n        map.put(\\'s\\', new int[]{3, 3});\\n        map.put(\\'t\\', new int[]{3, 4});\\n        \\n        map.put(\\'u\\', new int[]{4, 0});\\n        map.put(\\'v\\', new int[]{4, 1});\\n        map.put(\\'w\\', new int[]{4, 2});\\n        map.put(\\'x\\', new int[]{4, 3});\\n        map.put(\\'y\\', new int[]{4, 4});\\n        \\n        map.put(\\'z\\', new int[]{5, 0});\\n\\n    }\\n    \\n    private void getSequence(String target, int idx, StringBuilder sb, HashMap<Character, int[]> map, int x, int y) {\\n        if (idx == target.length())\\n            return;\\n        char c = target.charAt(idx);\\n        int targX = map.get(c)[1];\\n        int targY = map.get(c)[0];\\n        \\n        while(y > targY) {\\n            sb.append(\\'U\\');\\n            y--;\\n        }\\n        \\n        while (x < targX) {\\n            sb.append(\\'R\\');\\n            x++;\\n        }\\n        while (x > targX) {\\n            sb.append(\\'L\\');\\n            x--;\\n        }\\n        while(y < targY) {\\n            sb.append(\\'D\\');\\n            y++;\\n        }\\n        sb.append(\\'!\\');\\n        getSequence(target, idx+1, sb, map, targX, targY);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063449,
                "title": "simple-solution-if-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n\\n        StringBuilder ask = new StringBuilder();\\n        int currPositionX = 0;\\n        int currPositionY = 0;\\n\\n        for(char c: target.toCharArray()){\\n\\n            int targetOffsetX =  (c-\\'a\\') % 5;\\n            int targetOffsetY = (c-\\'a\\') / 5;\\n            int offsetX = targetOffsetX-currPositionX;\\n            int offsetY = targetOffsetY - currPositionY;\\n\\n            if(offsetY>0){\\n                if(targetOffsetY==5 && offsetX <0 ) {\\n                    ask.append(\"D\".repeat(offsetY-1));\\n                    ask.append(\"L\".repeat(Math.abs(offsetX)));\\n                    ask.append(\"D\");\\n                    ask.append(\\'!\\');\\n                    currPositionX = targetOffsetX;\\n                    currPositionY = targetOffsetY;\\n                    continue;\\n\\n\\n                } else ask.append(\"D\".repeat(offsetY));\\n            } else{\\n                ask.append(\"U\".repeat(Math.abs(offsetY)));\\n            }\\n\\n            if(offsetX>0){\\n                ask.append(\"R\".repeat(offsetX));\\n            } else if (offsetX < 0){\\n                ask.append(\"L\".repeat(Math.abs(offsetX)));\\n            }\\n            ask.append(\\'!\\');\\n        currPositionX = targetOffsetX;\\n        currPositionY = targetOffsetY;\\n\\n\\n        }\\n        return ask.toString();\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n\\n        StringBuilder ask = new StringBuilder();\\n        int currPositionX = 0;\\n        int currPositionY = 0;\\n\\n        for(char c: target.toCharArray()){\\n\\n            int targetOffsetX =  (c-\\'a\\') % 5;\\n            int targetOffsetY = (c-\\'a\\') / 5;\\n            int offsetX = targetOffsetX-currPositionX;\\n            int offsetY = targetOffsetY - currPositionY;\\n\\n            if(offsetY>0){\\n                if(targetOffsetY==5 && offsetX <0 ) {\\n                    ask.append(\"D\".repeat(offsetY-1));\\n                    ask.append(\"L\".repeat(Math.abs(offsetX)));\\n                    ask.append(\"D\");\\n                    ask.append(\\'!\\');\\n                    currPositionX = targetOffsetX;\\n                    currPositionY = targetOffsetY;\\n                    continue;\\n\\n\\n                } else ask.append(\"D\".repeat(offsetY));\\n            } else{\\n                ask.append(\"U\".repeat(Math.abs(offsetY)));\\n            }\\n\\n            if(offsetX>0){\\n                ask.append(\"R\".repeat(offsetX));\\n            } else if (offsetX < 0){\\n                ask.append(\"L\".repeat(Math.abs(offsetX)));\\n            }\\n            ask.append(\\'!\\');\\n        currPositionX = targetOffsetX;\\n        currPositionY = targetOffsetY;\\n\\n\\n        }\\n        return ask.toString();\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062126,
                "title": "c-time-o-n-space-o-1",
                "content": "```C []\\ntypedef struct Point{\\n\\tint row;\\n\\tint col;\\n} Point;\\n\\n#define BUF_LEN 1000\\n\\nchar * alphabetBoardPath(const char * const target){\\n\\tchar * const ret = (char *)malloc(sizeof (char) * BUF_LEN);\\n\\tint retLen = 0;\\n\\n\\tPoint prev = {0, 0};\\n\\tfor (int i = 0; target[i] != \\'\\\\0\\'; i += 1){\\n\\t\\tassert(target[i] >= \\'a\\' && target[i] <= \\'z\\');\\n\\t\\tconst int curIdx = target[i] - \\'a\\';\\n\\t\\tconst Point cur = {curIdx / 5, curIdx % 5};\\n\\n\\t\\tconst Point diff = {cur.row - prev.row, cur.col - prev.col};\\n\\t\\tif (\\n\\t\\t\\t!(5 == prev.row && 0 == prev.col) &&\\n\\t\\t\\t(5 == cur.row && 0 == cur.col)\\n\\t\\t){\\n\\t\\t\\tif (diff.col < 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'L\\', -diff.col);\\n\\t\\t\\t\\tretLen += -diff.col;\\n\\t\\t\\t}\\n\\t\\t\\tif (diff.row > 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'D\\', diff.row);\\n\\t\\t\\t\\tretLen += diff.row;\\n\\t\\t\\t}\\n\\t\\t}else {\\n\\t\\t\\tif (diff.row > 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'D\\', diff.row);\\n\\t\\t\\t\\tretLen += diff.row;\\n\\t\\t\\t}else if (diff.row < 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'U\\', -diff.row);\\n\\t\\t\\t\\tretLen += -diff.row;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (diff.col > 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'R\\', diff.col);\\n\\t\\t\\t\\tretLen += diff.col;\\n\\t\\t\\t}else if (diff.col < 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'L\\', -diff.col);\\n\\t\\t\\t\\tretLen += -diff.col;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tret[retLen] = \\'!\\';\\n\\t\\tretLen += 1;\\n\\n\\t\\tprev = cur;\\n\\t}\\n\\n\\tret[retLen] = \\'\\\\0\\';\\n\\treturn ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C []\\ntypedef struct Point{\\n\\tint row;\\n\\tint col;\\n} Point;\\n\\n#define BUF_LEN 1000\\n\\nchar * alphabetBoardPath(const char * const target){\\n\\tchar * const ret = (char *)malloc(sizeof (char) * BUF_LEN);\\n\\tint retLen = 0;\\n\\n\\tPoint prev = {0, 0};\\n\\tfor (int i = 0; target[i] != \\'\\\\0\\'; i += 1){\\n\\t\\tassert(target[i] >= \\'a\\' && target[i] <= \\'z\\');\\n\\t\\tconst int curIdx = target[i] - \\'a\\';\\n\\t\\tconst Point cur = {curIdx / 5, curIdx % 5};\\n\\n\\t\\tconst Point diff = {cur.row - prev.row, cur.col - prev.col};\\n\\t\\tif (\\n\\t\\t\\t!(5 == prev.row && 0 == prev.col) &&\\n\\t\\t\\t(5 == cur.row && 0 == cur.col)\\n\\t\\t){\\n\\t\\t\\tif (diff.col < 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'L\\', -diff.col);\\n\\t\\t\\t\\tretLen += -diff.col;\\n\\t\\t\\t}\\n\\t\\t\\tif (diff.row > 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'D\\', diff.row);\\n\\t\\t\\t\\tretLen += diff.row;\\n\\t\\t\\t}\\n\\t\\t}else {\\n\\t\\t\\tif (diff.row > 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'D\\', diff.row);\\n\\t\\t\\t\\tretLen += diff.row;\\n\\t\\t\\t}else if (diff.row < 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'U\\', -diff.row);\\n\\t\\t\\t\\tretLen += -diff.row;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (diff.col > 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'R\\', diff.col);\\n\\t\\t\\t\\tretLen += diff.col;\\n\\t\\t\\t}else if (diff.col < 0){\\n\\t\\t\\t\\tmemset(ret + retLen, \\'L\\', -diff.col);\\n\\t\\t\\t\\tretLen += -diff.col;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tret[retLen] = \\'!\\';\\n\\t\\tretLen += 1;\\n\\n\\t\\tprev = cur;\\n\\t}\\n\\n\\tret[retLen] = \\'\\\\0\\';\\n\\treturn ret;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3971050,
                "title": "by-07chrono-c-the-best-solution-ever-oms-beats-1oo-click-to-see-now",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        vector<int> hang = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6};\\n        vector<int> cot = {1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1};\\n\\n        int h = 1, c = 1, hnew, cnew, denta_h, denta_c;\\n        bool flag = false;\\n\\n        string path = \"\";\\n        for(char x: target)\\n        {\\n            hnew = hang[x - 97];\\n            cnew = cot[x - 97];\\n\\n            if(hnew == h && cnew == c)\\n                path += \"!\";\\n            else\\n            {\\n                if(hnew > h)\\n                {\\n                    if(hnew == 6 && c != 1)\\n                    {\\n                        flag = true;\\n                        for(int i = 0; i < 5 - h; i++)\\n                        {\\n                            path += \"D\";\\n                        }\\n                    }\\n                    else\\n                    {\\n                        for(int i = 0; i < hnew - h; ++i)\\n                        {\\n                            path += \"D\";\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    for(int i = 0; i < h - hnew; ++i)\\n                    {\\n                        path += \"U\";\\n                    }\\n                }\\n\\n                if(cnew > c)\\n                {\\n                    for(int i = 0; i < cnew - c; ++i)\\n                    {\\n                        path += \"R\";\\n                    }\\n                }\\n                else\\n                {\\n                    for(int i = 0; i < c - cnew; ++i)\\n                    {\\n                        path += \"L\";\\n                    }\\n\\n                    if(flag == true)\\n                    {\\n                        flag = false;\\n                        path += \"D\";\\n                    }\\n                }\\n                path += \"!\";\\n                h = hnew;\\n                c = cnew;\\n            }\\n        }\\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        vector<int> hang = {1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6};\\n        vector<int> cot = {1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1};\\n\\n        int h = 1, c = 1, hnew, cnew, denta_h, denta_c;\\n        bool flag = false;\\n\\n        string path = \"\";\\n        for(char x: target)\\n        {\\n            hnew = hang[x - 97];\\n            cnew = cot[x - 97];\\n\\n            if(hnew == h && cnew == c)\\n                path += \"!\";\\n            else\\n            {\\n                if(hnew > h)\\n                {\\n                    if(hnew == 6 && c != 1)\\n                    {\\n                        flag = true;\\n                        for(int i = 0; i < 5 - h; i++)\\n                        {\\n                            path += \"D\";\\n                        }\\n                    }\\n                    else\\n                    {\\n                        for(int i = 0; i < hnew - h; ++i)\\n                        {\\n                            path += \"D\";\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    for(int i = 0; i < h - hnew; ++i)\\n                    {\\n                        path += \"U\";\\n                    }\\n                }\\n\\n                if(cnew > c)\\n                {\\n                    for(int i = 0; i < cnew - c; ++i)\\n                    {\\n                        path += \"R\";\\n                    }\\n                }\\n                else\\n                {\\n                    for(int i = 0; i < c - cnew; ++i)\\n                    {\\n                        path += \"L\";\\n                    }\\n\\n                    if(flag == true)\\n                    {\\n                        flag = false;\\n                        path += \"D\";\\n                    }\\n                }\\n                path += \"!\";\\n                h = hnew;\\n                c = cnew;\\n            }\\n        }\\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928273,
                "title": "0ms-c-beat-100-of-users",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        \\n        unordered_map<char,int>rowMp;\\n        unordered_map<char,int>colMp;\\n         char ch =  \\'a\\';\\n         \\n        for(int i =0; i<5; i++){\\n            \\n           for(int j =0; j < 5; j++){\\n\\n              rowMp[ch]=i;\\n              colMp[ch]=j;\\n              ch++;\\n          } \\n         \\n        }\\n       rowMp[\\'z\\']=5;\\n       colMp[\\'z\\']=0;\\n     string ans = \"\";\\n        \\n        int sR =0;\\n        int sC =0;\\n        char star=\\'*\\';\\n       for(int i =0; i<target.length(); i++){\\n           \\n           char it = target[i];\\n           \\n          if(star==it){\\n              ans.push_back(\\'!\\');\\n              continue;\\n          }\\n           int r = rowMp[it];\\n           int c = colMp[it];\\n           int alongY = r - sR;\\n           int alongX = c - sC;\\n\\n     if(sR==5 && sC==0){\\n\\n        //------\\n             if(alongY>0){\\n                  while(alongY>0){\\n                  ans.push_back(\\'D\\');\\n                  alongY--;\\n            }\\n           }else{\\n               while(alongY<0){\\n                ans.push_back(\\'U\\');\\n                 alongY++;\\n            }\\n           }\\n         //---------------\\n        if(alongX>0){\\n            while(alongX>0){\\n                ans.push_back(\\'R\\');\\n                alongX--;\\n            }\\n           }else{\\n               while(alongX<0){\\n                ans.push_back(\\'L\\');\\n                 alongX++;\\n            }\\n           }\\n\\n    }   \\n//------------------------------------------------\\n        \\n        else{\\n           if(alongX>0){\\n            while(alongX>0){\\n                ans.push_back(\\'R\\');\\n                alongX--;\\n            }\\n           }else{\\n               while(alongX<0){\\n                ans.push_back(\\'L\\');\\n                 alongX++;\\n            }\\n           }\\n\\n            if(alongY>0){\\n            while(alongY>0){\\n                ans.push_back(\\'D\\');\\n                alongY--;\\n            }\\n           }else{\\n               while(alongY<0){\\n                ans.push_back(\\'U\\');\\n                 alongY++;\\n            }\\n        }\\n\\n    }      \\n           star=it;\\n         ans.push_back(\\'!\\');\\n            sR=r;\\n             sC=c;\\n\\n}\\n\\n\\nreturn ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        \\n        unordered_map<char,int>rowMp;\\n        unordered_map<char,int>colMp;\\n         char ch =  \\'a\\';\\n         \\n        for(int i =0; i<5; i++){\\n            \\n           for(int j =0; j < 5; j++){\\n\\n              rowMp[ch]=i;\\n              colMp[ch]=j;\\n              ch++;\\n          } \\n         \\n        }\\n       rowMp[\\'z\\']=5;\\n       colMp[\\'z\\']=0;\\n     string ans = \"\";\\n        \\n        int sR =0;\\n        int sC =0;\\n        char star=\\'*\\';\\n       for(int i =0; i<target.length(); i++){\\n           \\n           char it = target[i];\\n           \\n          if(star==it){\\n              ans.push_back(\\'!\\');\\n              continue;\\n          }\\n           int r = rowMp[it];\\n           int c = colMp[it];\\n           int alongY = r - sR;\\n           int alongX = c - sC;\\n\\n     if(sR==5 && sC==0){\\n\\n        //------\\n             if(alongY>0){\\n                  while(alongY>0){\\n                  ans.push_back(\\'D\\');\\n                  alongY--;\\n            }\\n           }else{\\n               while(alongY<0){\\n                ans.push_back(\\'U\\');\\n                 alongY++;\\n            }\\n           }\\n         //---------------\\n        if(alongX>0){\\n            while(alongX>0){\\n                ans.push_back(\\'R\\');\\n                alongX--;\\n            }\\n           }else{\\n               while(alongX<0){\\n                ans.push_back(\\'L\\');\\n                 alongX++;\\n            }\\n           }\\n\\n    }   \\n//------------------------------------------------\\n        \\n        else{\\n           if(alongX>0){\\n            while(alongX>0){\\n                ans.push_back(\\'R\\');\\n                alongX--;\\n            }\\n           }else{\\n               while(alongX<0){\\n                ans.push_back(\\'L\\');\\n                 alongX++;\\n            }\\n           }\\n\\n            if(alongY>0){\\n            while(alongY>0){\\n                ans.push_back(\\'D\\');\\n                alongY--;\\n            }\\n           }else{\\n               while(alongY<0){\\n                ans.push_back(\\'U\\');\\n                 alongY++;\\n            }\\n        }\\n\\n    }      \\n           star=it;\\n         ans.push_back(\\'!\\');\\n            sR=r;\\n             sC=c;\\n\\n}\\n\\n\\nreturn ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887735,
                "title": "alphabet-board-path",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- use difference of target row and col and current row and col to move through th board and make target the current .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Brute Force Solution (Suboptimal):\\nFor each character in the target, calculate the row and column differences from the current position. Generate strings of \\'U\\', \\'D\\', \\'L\\', \\'R\\' moves based on the differences, adding \\'!\\' at the end. Time complexity is O(n^2) due to nested loops for the board.\\n\\nOptimal Solution:\\nIterate through the target, Use ASCII mapping of  the board character ie  c-\\'a\\'/5 for row and c-\\'a\\'%5 for col , to get the target row and col  and  calculate row and column differences, and append directions accordingly. Special case for \\'z\\': move to its first column, then traverse to target. Time complexity is O(n), linear due to single iteration over the target. S-1 , if used map space would have been increased.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- 1\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans;\\n        int curr = 0;\\n        int curc = 0;\\n\\n        // Iterate through each character in the target string\\n        for (auto target_ch : target) {\\n            // Calculate the target row and column using simple arithmetic based on ASCII values\\n            int target_row = (target_ch - \\'a\\') / 5;//using 5 as the number of rows in the 2D array / gives row , % gives col\\n            int target_col = (target_ch - \\'a\\') % 5;\\n\\n            // Calculate row and column differences between current position and target\\n            int row_diff = target_row - curr;\\n            int col_diff = target_col - curc;\\n\\n            // Special case for \\'z\\': handle column movement separately\\n            if (target_ch == \\'z\\') {\\n                // Move to the first column of \\'z\\'\\n                ans += string(max(col_diff, 0), \\'R\\');\\n                ans += string(max(-col_diff, 0), \\'L\\');\\n                // Move through the first column\\n                ans += string(max(row_diff, 0), \\'D\\');\\n                ans += string(max(-row_diff, 0), \\'U\\');\\n            } else {\\n                // Append the appropriate \\'U\\' or \\'D\\' moves based on the row difference\\n                ans += string(max(row_diff, 0), \\'D\\');\\n                ans += string(max(-row_diff, 0), \\'U\\');\\n\\n                // Append the appropriate \\'L\\' or \\'R\\' moves based on the column difference\\n                ans += string(max(col_diff, 0), \\'R\\');\\n                ans += string(max(-col_diff, 0), \\'L\\');\\n            }\\n\\n            // Append \\'!\\' to indicate collecting the current character\\n            ans += \\'!\\';\\n\\n            // Update the current row and column positions\\n            curr = target_row;\\n            curc = target_col;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n// class Solution {\\n// public:\\n//     string alphabetBoardPath(string target) {\\n//         // Define the alphabet board layout as a vector of strings\\n//         vector<string> board = {\\n//             \"abcde\",\\n//             \"fghij\",\\n//             \"klmno\",\\n//             \"pqrst\",\\n//             \"uvwxy\",\\n//             \"z\"\\n//         };\\n        \\n//         // Create a mapping of characters to their corresponding row and column positions\\n//         unordered_map<char, pair<int, int>> mp;\\n\\n//         // Populate the mapping using nested loops over rows and columns\\n//         for (int i = 0; i < board.size(); i++) {\\n//             for (int j = 0; j < board[0].size(); j++) {\\n//                 mp[board[i][j]] = make_pair(i, j);\\n//             }\\n//         }\\n        \\n//         // Initialize variables to keep track of current row and column\\n//         int curr = 0;\\n//         int curc = 0;\\n//         // Initialize the string to store the sequence of directions and characters\\n//         string direction;\\n\\n//         // Loop through each character in the target word\\n//         for (auto c : target) {\\n//             // Calculate the differences in rows and columns between the current position and the target\\n//             int rd = mp[c].first - curr;\\n//             int cd = mp[c].second - curc;\\n\\n//             // Special case for \\'z\\': handle column movement separately\\n//             if (c == \\'z\\') {// if we have to go to z , we have to first go to oth col and then traverse from their to z, ie ve havr to go first \\n// \\t\\t\\t\\t\\t\\t              //cols and then row wise \\n\\n//                 // Move to the first column of \\'z\\'\\n//                 direction += string(max(cd, 0), \\'R\\');\\n//                 direction += string(max(-cd, 0), \\'L\\');\\n//                 // Move through the first column\\n//                 direction += string(max(rd, 0), \\'D\\');\\n//                 direction += string(max(-rd, 0), \\'U\\');\\n//             } else {\\n//                 // Append the appropriate \\'U\\' or \\'D\\' moves based on the row difference\\n//                 direction += string(max(rd, 0), \\'D\\');\\n//                 direction += string(max(-rd, 0), \\'U\\');\\n\\n//                 // Append the appropriate \\'L\\' or \\'R\\' moves based on the column difference\\n//                 direction += string(max(cd, 0), \\'R\\');\\n//                 direction += string(max(-cd, 0), \\'L\\');\\n//             }\\n\\n//             // Append \\'!\\' to indicate collecting the current character\\n//             direction += \\'!\\';\\n\\n//             // Update the current row and column positions\\n//             curr = mp[c].first;\\n//             curc = mp[c].second;\\n//         }\\n\\n//         // Return the final sequence of directions and collected characters\\n//         return direction;\\n//     }\\n// };\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans;\\n        int curr = 0;\\n        int curc = 0;\\n\\n        // Iterate through each character in the target string\\n        for (auto target_ch : target) {\\n            // Calculate the target row and column using simple arithmetic based on ASCII values\\n            int target_row = (target_ch - \\'a\\') / 5;//using 5 as the number of rows in the 2D array / gives row , % gives col\\n            int target_col = (target_ch - \\'a\\') % 5;\\n\\n            // Calculate row and column differences between current position and target\\n            int row_diff = target_row - curr;\\n            int col_diff = target_col - curc;\\n\\n            // Special case for \\'z\\': handle column movement separately\\n            if (target_ch == \\'z\\') {\\n                // Move to the first column of \\'z\\'\\n                ans += string(max(col_diff, 0), \\'R\\');\\n                ans += string(max(-col_diff, 0), \\'L\\');\\n                // Move through the first column\\n                ans += string(max(row_diff, 0), \\'D\\');\\n                ans += string(max(-row_diff, 0), \\'U\\');\\n            } else {\\n                // Append the appropriate \\'U\\' or \\'D\\' moves based on the row difference\\n                ans += string(max(row_diff, 0), \\'D\\');\\n                ans += string(max(-row_diff, 0), \\'U\\');\\n\\n                // Append the appropriate \\'L\\' or \\'R\\' moves based on the column difference\\n                ans += string(max(col_diff, 0), \\'R\\');\\n                ans += string(max(-col_diff, 0), \\'L\\');\\n            }\\n\\n            // Append \\'!\\' to indicate collecting the current character\\n            ans += \\'!\\';\\n\\n            // Update the current row and column positions\\n            curr = target_row;\\n            curc = target_col;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n// class Solution {\\n// public:\\n//     string alphabetBoardPath(string target) {\\n//         // Define the alphabet board layout as a vector of strings\\n//         vector<string> board = {\\n//             \"abcde\",\\n//             \"fghij\",\\n//             \"klmno\",\\n//             \"pqrst\",\\n//             \"uvwxy\",\\n//             \"z\"\\n//         };\\n        \\n//         // Create a mapping of characters to their corresponding row and column positions\\n//         unordered_map<char, pair<int, int>> mp;\\n\\n//         // Populate the mapping using nested loops over rows and columns\\n//         for (int i = 0; i < board.size(); i++) {\\n//             for (int j = 0; j < board[0].size(); j++) {\\n//                 mp[board[i][j]] = make_pair(i, j);\\n//             }\\n//         }\\n        \\n//         // Initialize variables to keep track of current row and column\\n//         int curr = 0;\\n//         int curc = 0;\\n//         // Initialize the string to store the sequence of directions and characters\\n//         string direction;\\n\\n//         // Loop through each character in the target word\\n//         for (auto c : target) {\\n//             // Calculate the differences in rows and columns between the current position and the target\\n//             int rd = mp[c].first - curr;\\n//             int cd = mp[c].second - curc;\\n\\n//             // Special case for \\'z\\': handle column movement separately\\n//             if (c == \\'z\\') {// if we have to go to z , we have to first go to oth col and then traverse from their to z, ie ve havr to go first \\n// \\t\\t\\t\\t\\t\\t              //cols and then row wise \\n\\n//                 // Move to the first column of \\'z\\'\\n//                 direction += string(max(cd, 0), \\'R\\');\\n//                 direction += string(max(-cd, 0), \\'L\\');\\n//                 // Move through the first column\\n//                 direction += string(max(rd, 0), \\'D\\');\\n//                 direction += string(max(-rd, 0), \\'U\\');\\n//             } else {\\n//                 // Append the appropriate \\'U\\' or \\'D\\' moves based on the row difference\\n//                 direction += string(max(rd, 0), \\'D\\');\\n//                 direction += string(max(-rd, 0), \\'U\\');\\n\\n//                 // Append the appropriate \\'L\\' or \\'R\\' moves based on the column difference\\n//                 direction += string(max(cd, 0), \\'R\\');\\n//                 direction += string(max(-cd, 0), \\'L\\');\\n//             }\\n\\n//             // Append \\'!\\' to indicate collecting the current character\\n//             direction += \\'!\\';\\n\\n//             // Update the current row and column positions\\n//             curr = mp[c].first;\\n//             curc = mp[c].second;\\n//         }\\n\\n//         // Return the final sequence of directions and collected characters\\n//         return direction;\\n//     }\\n// };\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882304,
                "title": "c-o-n-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void alongy(string &ans, int move, int &i, int &j) {\\n        char c = \\'D\\';\\n        if(move <= 0) {\\n            c = \\'U\\';\\n        }\\n\\n        for(int i=0;i<abs(move);i++) {\\n            ans += c;\\n        }\\n        i+=move;\\n    }\\n\\n    void alongx(string &ans, int move, int &i, int &j) {\\n        char c = \\'R\\';\\n        if(move <= 0) {\\n            c = \\'L\\';\\n        }\\n\\n        for(int i=0;i<abs(move);i++) {\\n            ans += c;\\n        }\\n        j+=move;\\n    }\\n    string alphabetBoardPath(string target) {\\n        char c = \\'a\\';\\n        unordered_map<char, pair<int,int>> pos;\\n\\n        for(int i=0;i<6;i++) {\\n            for(int j=0;j<5;j++) {\\n                if(c>\\'z\\') {\\n                    break;\\n                }\\n                pos[c]={i, j};\\n                c++;\\n            }\\n        }\\n        string ans = \"\";\\n        c = \\'a\\';\\n        int i=0,j=0;\\n        for(char cur: target) {\\n            int dy = pos[cur].first - pos[c].first;\\n            int dx = pos[cur].second - pos[c].second;\\n            cout<<dx<<\" \"<<dy<<endl;\\n            if(c == \\'z\\') {\\n                alongy(ans, dy, i, j);\\n                alongx(ans,dx, i, j);\\n            } else {\\n                alongx(ans,dx, i, j);\\n                alongy(ans, dy, i, j);\\n            }\\n            c = cur;\\n            ans += \\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void alongy(string &ans, int move, int &i, int &j) {\\n        char c = \\'D\\';\\n        if(move <= 0) {\\n            c = \\'U\\';\\n        }\\n\\n        for(int i=0;i<abs(move);i++) {\\n            ans += c;\\n        }\\n        i+=move;\\n    }\\n\\n    void alongx(string &ans, int move, int &i, int &j) {\\n        char c = \\'R\\';\\n        if(move <= 0) {\\n            c = \\'L\\';\\n        }\\n\\n        for(int i=0;i<abs(move);i++) {\\n            ans += c;\\n        }\\n        j+=move;\\n    }\\n    string alphabetBoardPath(string target) {\\n        char c = \\'a\\';\\n        unordered_map<char, pair<int,int>> pos;\\n\\n        for(int i=0;i<6;i++) {\\n            for(int j=0;j<5;j++) {\\n                if(c>\\'z\\') {\\n                    break;\\n                }\\n                pos[c]={i, j};\\n                c++;\\n            }\\n        }\\n        string ans = \"\";\\n        c = \\'a\\';\\n        int i=0,j=0;\\n        for(char cur: target) {\\n            int dy = pos[cur].first - pos[c].first;\\n            int dx = pos[cur].second - pos[c].second;\\n            cout<<dx<<\" \"<<dy<<endl;\\n            if(c == \\'z\\') {\\n                alongy(ans, dy, i, j);\\n                alongx(ans,dx, i, j);\\n            } else {\\n                alongx(ans,dx, i, j);\\n                alongy(ans, dy, i, j);\\n            }\\n            c = cur;\\n            ans += \\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3877119,
                "title": "ok",
                "content": "```\\nstring alphabetBoardPath(string s)\\n{\\n\\tstring out;\\n\\tfor(int t{\\'a\\'}; const auto & c : s)\\n\\t{\\n\\t\\tint  dx = (c-\\'a\\')/5-(t-\\'a\\')/5,\\n\\t\\t\\t dy = (c-\\'a\\')%5-(t-\\'a\\')%5;\\n\\t\\tout += string(max(-dx,0),\\'U\\') + string(max(dy,0),\\'R\\') + string(max(-dy,0),\\'L\\') + string(max(dx,0),\\'D\\') + \"!\"s;\\n\\t\\tt=c;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring alphabetBoardPath(string s)\\n{\\n\\tstring out;\\n\\tfor(int t{\\'a\\'}; const auto & c : s)\\n\\t{\\n\\t\\tint  dx = (c-\\'a\\')/5-(t-\\'a\\')/5,\\n\\t\\t\\t dy = (c-\\'a\\')%5-(t-\\'a\\')%5;\\n\\t\\tout += string(max(-dx,0),\\'U\\') + string(max(dy,0),\\'R\\') + string(max(-dy,0),\\'L\\') + string(max(dx,0),\\'D\\') + \"!\"s;\\n\\t\\tt=c;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831621,
                "title": "java-clean-solution-based-on-moving-to-z-or-not-to-z",
                "content": "# Approach\\n1. initiate start X and Y as 0\\n1. for each character in target, find target X and Y using division\\n2. if target char is \\'z\\', move Y first, then move X, to avoid moving out of index\\n3. otherwise, move X first, then move Y (to handle the case of moving from \\'z\\')\\n\\ntips: \\n1. write two helper method to reduce repetitive lines\\n2. need to manually update current row and column to target row and column since integer is not reference type\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder answer = new StringBuilder();\\n        int currX = 0, currY = 0;\\n        for(char c : target.toCharArray()) {\\n            int currChar = c - \\'a\\';\\n            int targetX = currChar / 5;\\n            int targetY = currChar % 5;\\n            \\n            // if not move to z, first move row then move column\\n            if (currChar != 25) {\\n                moveX(currX, targetX, answer);\\n                moveY(currY, targetY, answer);\\n            }\\n            // if move to \\'z\\', first move column then move row\\n            else {\\n                moveY(currY, targetY, answer);\\n                moveX(currX, targetX, answer);\\n            }\\n\\n            // update current row and column cause integer is not reference type\\n            currX = targetX;\\n            currY = targetY;\\n            \\n            answer.append(\\'!\\');\\n        }\\n        return answer.toString();\\n    }\\n\\n    private void moveX(int currX, int targetX, StringBuilder answer) {\\n        while(currX < targetX) {\\n            answer.append(\\'D\\');\\n            currX++;\\n        }\\n        while(currX > targetX) {\\n            answer.append(\\'U\\');\\n            currX--;\\n        }\\n    }\\n\\n    private void moveY(int currY, int targetY, StringBuilder answer) {\\n        while(currY < targetY) {\\n            answer.append(\\'R\\');\\n            currY++;\\n        }\\n            \\n        while(currY > targetY) {\\n            answer.append(\\'L\\');\\n            currY--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder answer = new StringBuilder();\\n        int currX = 0, currY = 0;\\n        for(char c : target.toCharArray()) {\\n            int currChar = c - \\'a\\';\\n            int targetX = currChar / 5;\\n            int targetY = currChar % 5;\\n            \\n            // if not move to z, first move row then move column\\n            if (currChar != 25) {\\n                moveX(currX, targetX, answer);\\n                moveY(currY, targetY, answer);\\n            }\\n            // if move to \\'z\\', first move column then move row\\n            else {\\n                moveY(currY, targetY, answer);\\n                moveX(currX, targetX, answer);\\n            }\\n\\n            // update current row and column cause integer is not reference type\\n            currX = targetX;\\n            currY = targetY;\\n            \\n            answer.append(\\'!\\');\\n        }\\n        return answer.toString();\\n    }\\n\\n    private void moveX(int currX, int targetX, StringBuilder answer) {\\n        while(currX < targetX) {\\n            answer.append(\\'D\\');\\n            currX++;\\n        }\\n        while(currX > targetX) {\\n            answer.append(\\'U\\');\\n            currX--;\\n        }\\n    }\\n\\n    private void moveY(int currY, int targetY, StringBuilder answer) {\\n        while(currY < targetY) {\\n            answer.append(\\'R\\');\\n            currY++;\\n        }\\n            \\n        while(currY > targetY) {\\n            answer.append(\\'L\\');\\n            currY--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827646,
                "title": "ruby-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef alphabet_board_path(target)\\n  x = 0\\n  y = 0\\n  ans = \"\"\\n  target.chars.each do |c|\\n    idx = c.ord - \\'a\\'.ord\\n    ty, tx = idx.divmod(5)\\n\\n    ans += \"U\" * [0, y - ty].max\\n    ans += \"L\" * [0, x - tx].max\\n    ans += \"D\" * [0, ty - y].max\\n    ans += \"R\" * [0, tx - x].max\\n    ans += \"!\"\\n\\n    y, x = ty, tx\\n  end\\n\\n  ans\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef alphabet_board_path(target)\\n  x = 0\\n  y = 0\\n  ans = \"\"\\n  target.chars.each do |c|\\n    idx = c.ord - \\'a\\'.ord\\n    ty, tx = idx.divmod(5)\\n\\n    ans += \"U\" * [0, y - ty].max\\n    ans += \"L\" * [0, x - tx].max\\n    ans += \"D\" * [0, ty - y].max\\n    ans += \"R\" * [0, tx - x].max\\n    ans += \"!\"\\n\\n    y, x = ty, tx\\n  end\\n\\n  ans\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3772110,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public string AlphabetBoardPath(string target) {\\n        var currPos = (0, 0);\\n        var res = new StringBuilder();\\n        var map = new Dictionary<char, (int, int)> {\\n            { \\'a\\', (0, 0) }, { \\'b\\', (0, 1) }, { \\'c\\', (0, 2) }, { \\'d\\', (0, 3) }, { \\'e\\', (0, 4) },\\n            { \\'f\\', (1, 0) }, { \\'g\\', (1, 1) }, { \\'h\\', (1, 2) }, { \\'i\\', (1, 3) }, { \\'j\\', (1, 4) },\\n            { \\'k\\', (2, 0) }, { \\'l\\', (2, 1) }, { \\'m\\', (2, 2) }, { \\'n\\', (2, 3) }, { \\'o\\', (2, 4) },\\n            { \\'p\\', (3, 0) }, { \\'q\\', (3, 1) }, { \\'r\\', (3, 2) }, { \\'s\\', (3, 3) }, { \\'t\\', (3, 4) },\\n            { \\'u\\', (4, 0) }, { \\'v\\', (4, 1) }, { \\'w\\', (4, 2) }, { \\'x\\', (4, 3) }, { \\'y\\', (4, 4) },\\n            { \\'z\\', (5, 0) }\\n        };\\n\\n        foreach (var chr in target) {\\n            var x = map[chr].Item1 - currPos.Item1;\\n            var y = map[chr].Item2 - currPos.Item2;\\n\\n            var first = x < 0 ? \\'U\\' : \\'D\\';\\n            var second = y < 0 ? \\'L\\' : \\'R\\';\\n\\n            if (chr == \\'z\\') {\\n                Print(res, Math.Abs(y), second);\\n                Print(res, Math.Abs(x), first);\\n            }\\n            else {\\n                Print(res, Math.Abs(x), first);\\n                Print(res, Math.Abs(y), second);\\n            }\\n            \\n\\n            res.Append(\\'!\\');\\n            currPos = (map[chr].Item1, map[chr].Item2);\\n        }\\n\\n        return res.ToString();\\n    }\\n\\n    private static void Print(StringBuilder res, int num, char chr) {\\n        for (int idx = 0; idx < num; idx++)\\n            res.Append(chr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public string AlphabetBoardPath(string target) {\\n        var currPos = (0, 0);\\n        var res = new StringBuilder();\\n        var map = new Dictionary<char, (int, int)> {\\n            { \\'a\\', (0, 0) }, { \\'b\\', (0, 1) }, { \\'c\\', (0, 2) }, { \\'d\\', (0, 3) }, { \\'e\\', (0, 4) },\\n            { \\'f\\', (1, 0) }, { \\'g\\', (1, 1) }, { \\'h\\', (1, 2) }, { \\'i\\', (1, 3) }, { \\'j\\', (1, 4) },\\n            { \\'k\\', (2, 0) }, { \\'l\\', (2, 1) }, { \\'m\\', (2, 2) }, { \\'n\\', (2, 3) }, { \\'o\\', (2, 4) },\\n            { \\'p\\', (3, 0) }, { \\'q\\', (3, 1) }, { \\'r\\', (3, 2) }, { \\'s\\', (3, 3) }, { \\'t\\', (3, 4) },\\n            { \\'u\\', (4, 0) }, { \\'v\\', (4, 1) }, { \\'w\\', (4, 2) }, { \\'x\\', (4, 3) }, { \\'y\\', (4, 4) },\\n            { \\'z\\', (5, 0) }\\n        };\\n\\n        foreach (var chr in target) {\\n            var x = map[chr].Item1 - currPos.Item1;\\n            var y = map[chr].Item2 - currPos.Item2;\\n\\n            var first = x < 0 ? \\'U\\' : \\'D\\';\\n            var second = y < 0 ? \\'L\\' : \\'R\\';\\n\\n            if (chr == \\'z\\') {\\n                Print(res, Math.Abs(y), second);\\n                Print(res, Math.Abs(x), first);\\n            }\\n            else {\\n                Print(res, Math.Abs(x), first);\\n                Print(res, Math.Abs(y), second);\\n            }\\n            \\n\\n            res.Append(\\'!\\');\\n            currPos = (map[chr].Item1, map[chr].Item2);\\n        }\\n\\n        return res.ToString();\\n    }\\n\\n    private static void Print(StringBuilder res, int num, char chr) {\\n        for (int idx = 0; idx < num; idx++)\\n            res.Append(chr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719198,
                "title": "solution-that-will-give-you-second-hand-embarrasment",
                "content": "# Intuition\\nMake a map of character , pair . Pair stores x and y index of the character . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor example , you have to go from a to g\\na --> 0,0\\ng --> 1,1\\na-g --> -1,-1\\nso , you will go 1 down and 1 right\\nif it was 1,1 . you would go 1 up and 1 left\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        // min path to reach target.charAt(0)\\n        // find smallest path from cur to next\\n        // a->0,0\\n        // l->2,1 . start-end gives minus . so 2 down\\n        HashMap<Character,Pair<Integer,Integer>> hm = new HashMap();\\n        hm.put(\\'a\\', new Pair<>(0, 0));\\n        hm.put(\\'b\\', new Pair<>(0, 1));\\n        hm.put(\\'c\\', new Pair<>(0, 2));\\n        hm.put(\\'d\\', new Pair<>(0, 3));\\n        hm.put(\\'e\\', new Pair<>(0, 4));\\n        hm.put(\\'f\\', new Pair<>(1, 0));\\n        hm.put(\\'g\\', new Pair<>(1, 1));\\n        hm.put(\\'h\\', new Pair<>(1, 2));\\n        hm.put(\\'i\\', new Pair<>(1, 3));\\n        hm.put(\\'j\\', new Pair<>(1, 4));\\n        hm.put(\\'k\\', new Pair<>(2, 0));\\n        hm.put(\\'l\\', new Pair<>(2, 1));\\n        hm.put(\\'m\\', new Pair<>(2, 2));\\n        hm.put(\\'n\\', new Pair<>(2, 3));\\n        hm.put(\\'o\\', new Pair<>(2, 4));\\n        hm.put(\\'p\\', new Pair<>(3, 0));\\n        hm.put(\\'q\\', new Pair<>(3, 1));\\n        hm.put(\\'r\\', new Pair<>(3, 2));\\n        hm.put(\\'s\\', new Pair<>(3, 3));\\n        hm.put(\\'t\\', new Pair<>(3, 4));\\n        hm.put(\\'u\\', new Pair<>(4, 0));\\n        hm.put(\\'v\\', new Pair<>(4, 1));\\n        hm.put(\\'w\\', new Pair<>(4, 2));\\n        hm.put(\\'x\\', new Pair<>(4, 3));\\n        hm.put(\\'y\\', new Pair<>(4, 4));\\n        hm.put(\\'z\\', new Pair<>(5, 0));\\n        StringBuilder ans = new StringBuilder(\"\");\\n        char prev=\\'a\\';\\n        for(int i=0;i<target.length();i++){\\n                // go from prev to target[0]\\n               if(target.charAt(i)==\\'z\\'){\\n                   // first do all the left stuff then down      \\nint x=hm.get(prev).getKey()-hm.get(target.charAt(i)).getKey();\\nint y=hm.get(prev).getValue()-hm.get(target.charAt(i)).getValue();\\nchar ch=\\'R\\';\\nif(y>0) ch=\\'L\\';\\nfor(int j=1;j<=Math.abs(y);++j) ans.append(ch);\\n\\nch=\\'D\\';\\nif(x>0) ch=\\'U\\';\\nfor(int j=1;j<=Math.abs(x);++j) ans.append(ch);\\n\\nans.append(\"!\");\\nprev=target.charAt(i);\\ncontinue;\\n               }\\nint x=hm.get(prev).getKey()-hm.get(target.charAt(i)).getKey();\\nint y=hm.get(prev).getValue()-hm.get(target.charAt(i)).getValue();\\nchar ch=\\'D\\';\\nif(x>0) ch=\\'U\\';\\nfor(int j=1;j<=Math.abs(x);++j) ans.append(ch);\\nch=\\'R\\';\\nif(y>0) ch=\\'L\\';\\nfor(int j=1;j<=Math.abs(y);++j) ans.append(ch);\\nans.append(\"!\");\\nprev=target.charAt(i);\\n        }\\n        return new String(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        // min path to reach target.charAt(0)\\n        // find smallest path from cur to next\\n        // a->0,0\\n        // l->2,1 . start-end gives minus . so 2 down\\n        HashMap<Character,Pair<Integer,Integer>> hm = new HashMap();\\n        hm.put(\\'a\\', new Pair<>(0, 0));\\n        hm.put(\\'b\\', new Pair<>(0, 1));\\n        hm.put(\\'c\\', new Pair<>(0, 2));\\n        hm.put(\\'d\\', new Pair<>(0, 3));\\n        hm.put(\\'e\\', new Pair<>(0, 4));\\n        hm.put(\\'f\\', new Pair<>(1, 0));\\n        hm.put(\\'g\\', new Pair<>(1, 1));\\n        hm.put(\\'h\\', new Pair<>(1, 2));\\n        hm.put(\\'i\\', new Pair<>(1, 3));\\n        hm.put(\\'j\\', new Pair<>(1, 4));\\n        hm.put(\\'k\\', new Pair<>(2, 0));\\n        hm.put(\\'l\\', new Pair<>(2, 1));\\n        hm.put(\\'m\\', new Pair<>(2, 2));\\n        hm.put(\\'n\\', new Pair<>(2, 3));\\n        hm.put(\\'o\\', new Pair<>(2, 4));\\n        hm.put(\\'p\\', new Pair<>(3, 0));\\n        hm.put(\\'q\\', new Pair<>(3, 1));\\n        hm.put(\\'r\\', new Pair<>(3, 2));\\n        hm.put(\\'s\\', new Pair<>(3, 3));\\n        hm.put(\\'t\\', new Pair<>(3, 4));\\n        hm.put(\\'u\\', new Pair<>(4, 0));\\n        hm.put(\\'v\\', new Pair<>(4, 1));\\n        hm.put(\\'w\\', new Pair<>(4, 2));\\n        hm.put(\\'x\\', new Pair<>(4, 3));\\n        hm.put(\\'y\\', new Pair<>(4, 4));\\n        hm.put(\\'z\\', new Pair<>(5, 0));\\n        StringBuilder ans = new StringBuilder(\"\");\\n        char prev=\\'a\\';\\n        for(int i=0;i<target.length();i++){\\n                // go from prev to target[0]\\n               if(target.charAt(i)==\\'z\\'){\\n                   // first do all the left stuff then down      \\nint x=hm.get(prev).getKey()-hm.get(target.charAt(i)).getKey();\\nint y=hm.get(prev).getValue()-hm.get(target.charAt(i)).getValue();\\nchar ch=\\'R\\';\\nif(y>0) ch=\\'L\\';\\nfor(int j=1;j<=Math.abs(y);++j) ans.append(ch);\\n\\nch=\\'D\\';\\nif(x>0) ch=\\'U\\';\\nfor(int j=1;j<=Math.abs(x);++j) ans.append(ch);\\n\\nans.append(\"!\");\\nprev=target.charAt(i);\\ncontinue;\\n               }\\nint x=hm.get(prev).getKey()-hm.get(target.charAt(i)).getKey();\\nint y=hm.get(prev).getValue()-hm.get(target.charAt(i)).getValue();\\nchar ch=\\'D\\';\\nif(x>0) ch=\\'U\\';\\nfor(int j=1;j<=Math.abs(x);++j) ans.append(ch);\\nch=\\'R\\';\\nif(y>0) ch=\\'L\\';\\nfor(int j=1;j<=Math.abs(y);++j) ans.append(ch);\\nans.append(\"!\");\\nprev=target.charAt(i);\\n        }\\n        return new String(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702495,
                "title": "o-n-solution-beats-100-time-must-see-you-won-t-regret-easy-intutive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        map<char, pair<int, int>>mp;\\n        string ans=\"\";\\n        \\n        int k=0, j=0;\\n        for(int i=0; i<26; i++){\\n            mp[char(i+97)] = {k, j};\\n            j++;\\n            if(j!=0 && j%5==0){\\n                k++;\\n                j=0;\\n            }\\n        }\\n        \\n        // Printing elements in map \\n        // for(auto it: mp){\\n        //     cout<<it.first<<\" \"<<it.second.first<<\" \"<<it.second.second<<endl;\\n        // }\\n\\n        pair<int, int>l = {0, 0};\\n\\n        for(int i=0; i<target.length(); i++){\\n            pair<int, int>h = mp[target[i]];\\n\\n            int x1 = l.first;\\n            int y1 = l.second;\\n            int x2 = h.first;\\n            int y2 = h.second;\\n\\n            // This order matters for z when we are going from some letter to z OR from letter z to some other letter\\n\\n            // Left Down Up Right -> try on some example testcases\\n            //Eg: leetz(t->z), lzeet(z->e)\\n\\n            // Left -> taking care of z\\n            for(int j=y2; j<y1; j++){\\n                ans+=\\'L\\';\\n            }\\n            // Down\\n            for(int j=x1; j<x2; j++){\\n                ans+=\\'D\\';\\n            }\\n            // Up\\n            for(int j=x2; j<x1; j++){\\n                ans+=\\'U\\';\\n            }\\n            // Right\\n            for(int j=y1; j<y2; j++){\\n                ans+=\\'R\\';\\n            }\\n\\n            ans+=\"!\";// After reaching destination add \\'!\\'\\n\\n            l = h;// Changing low to high\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        map<char, pair<int, int>>mp;\\n        string ans=\"\";\\n        \\n        int k=0, j=0;\\n        for(int i=0; i<26; i++){\\n            mp[char(i+97)] = {k, j};\\n            j++;\\n            if(j!=0 && j%5==0){\\n                k++;\\n                j=0;\\n            }\\n        }\\n        \\n        // Printing elements in map \\n        // for(auto it: mp){\\n        //     cout<<it.first<<\" \"<<it.second.first<<\" \"<<it.second.second<<endl;\\n        // }\\n\\n        pair<int, int>l = {0, 0};\\n\\n        for(int i=0; i<target.length(); i++){\\n            pair<int, int>h = mp[target[i]];\\n\\n            int x1 = l.first;\\n            int y1 = l.second;\\n            int x2 = h.first;\\n            int y2 = h.second;\\n\\n            // This order matters for z when we are going from some letter to z OR from letter z to some other letter\\n\\n            // Left Down Up Right -> try on some example testcases\\n            //Eg: leetz(t->z), lzeet(z->e)\\n\\n            // Left -> taking care of z\\n            for(int j=y2; j<y1; j++){\\n                ans+=\\'L\\';\\n            }\\n            // Down\\n            for(int j=x1; j<x2; j++){\\n                ans+=\\'D\\';\\n            }\\n            // Up\\n            for(int j=x2; j<x1; j++){\\n                ans+=\\'U\\';\\n            }\\n            // Right\\n            for(int j=y1; j<y2; j++){\\n                ans+=\\'R\\';\\n            }\\n\\n            ans+=\"!\";// After reaching destination add \\'!\\'\\n\\n            l = h;// Changing low to high\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3692739,
                "title": "faster-than-100-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs long as we do not take any missteps,any path from 1 point to another will be shortest.\\nJust need to take care \\'z\\' character, from where we can\\'t move left or right, only up / down.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int sum = 0,p1 = 0,p2 = 0;\\n        map <char,pair <int,int>> mp;\\n        string ans;\\n        for (int a = 0,x = 0,y = 0;a < 26;a++,y++)\\n            y == 5 ? x++,y = 0 : y = y,mp[char (a + \\'a\\')] = {x,y};\\n        auto calc1 = [&] (char i) {\\n            while (p1 < mp[i].first)\\n                ans += \\'D\\',p1++;\\n            while (p1 > mp[i].first)\\n                ans += \\'U\\',p1--;\\n        };\\n        auto calc2 = [&] (char i) {\\n            while (p2 < mp[i].second)\\n                ans += \\'R\\',p2++;\\n            while (p2 > mp[i].second)\\n                ans += \\'L\\',p2--;\\n        };\\n        for (int a = 0;a < int (target.size());a++) {\\n            if (a > 0 && target[a - 1] == \\'z\\')\\n                calc1(target[a]),calc2(target[a]);\\n            else\\n                calc2(target[a]),calc1(target[a]);\\n            ans += \\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        int sum = 0,p1 = 0,p2 = 0;\\n        map <char,pair <int,int>> mp;\\n        string ans;\\n        for (int a = 0,x = 0,y = 0;a < 26;a++,y++)\\n            y == 5 ? x++,y = 0 : y = y,mp[char (a + \\'a\\')] = {x,y};\\n        auto calc1 = [&] (char i) {\\n            while (p1 < mp[i].first)\\n                ans += \\'D\\',p1++;\\n            while (p1 > mp[i].first)\\n                ans += \\'U\\',p1--;\\n        };\\n        auto calc2 = [&] (char i) {\\n            while (p2 < mp[i].second)\\n                ans += \\'R\\',p2++;\\n            while (p2 > mp[i].second)\\n                ans += \\'L\\',p2--;\\n        };\\n        for (int a = 0;a < int (target.size());a++) {\\n            if (a > 0 && target[a - 1] == \\'z\\')\\n                calc1(target[a]),calc2(target[a]);\\n            else\\n                calc2(target[a]),calc1(target[a]);\\n            ans += \\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684541,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638627,
                "title": "clever-c-solution-o-n-beats-100-submissions",
                "content": "# Intuition\\nIntuition for the solution is simple. Make 2 arrays of lenght = 26. These arrays will store the index (x,y) for each alphabet in the given grid. \\n***NOTE: CODE IS BULKY BUT CAN BE MADE MORE MODULAR.***\\n# Approach\\nTraverse the characters of the given string and check if our alphabet at our position matches the characters of string. If yes simple add \\'!\\' to our ans and move forward in our required string. Else we calculate the characters indices in the grid as target_row and target col. If the character is not \\'z\\' we first move in vertical direction and then in horizontal direction. If it is \\'z\\' we first move in horizontal direction and then in vertical direction as \\'z\\' is in horizontally confined position. Please read the code to get better understanding. An dthe code can be made more modular (less bulky visually) but it have done so to make others understand. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(size of string)\\n \\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int row[26]={0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5};\\n    int col[26]={0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0};\\npublic:\\n    void helper(string& ans, char x, int count){\\n        for(int i=0;i<count;i++)ans+=x;\\n        return;\\n    }\\n    string alphabetBoardPath(string target) {\\n        string ans=\"\";\\n        int i=0,j=0;\\n        for(int index=0;index<target.size();){\\n            if(i==row[target[index]-\\'a\\'] && j==col[target[index]-\\'a\\']){\\n                ans+=\\'!\\';\\n                index++;\\n            }else{\\n                if(target[index]!=\\'z\\'){\\n                    int target_row = row[target[index]-\\'a\\'];\\n                    int target_col = col[target[index]-\\'a\\'];\\n                    if(target_row-i>0){\\n                        helper(ans,\\'D\\',target_row-i);\\n                    }else if(target_row-i<0){\\n                        helper(ans,\\'U\\',i-target_row);\\n                    }\\n                    i=target_row;\\n                    if(target_col-j>0){\\n                        helper(ans,\\'R\\',target_col-j);\\n                    }else if(target_col-j<0){\\n                        helper(ans,\\'L\\',j-target_col);\\n                    }\\n                    j=target_col;\\n                }else{\\n                    int target_row = row[target[index]-\\'a\\'];\\n                    int target_col = col[target[index]-\\'a\\'];\\n                    if(target_col-j>0){\\n                        helper(ans,\\'R\\',target_col-j);\\n                    }else if(target_col-j<0){\\n                        helper(ans,\\'L\\',j-target_col);\\n                    }\\n                    j=target_col;\\n                    \\n                    if(target_row-i>0){\\n                        helper(ans,\\'D\\',target_row-i);\\n                    }else if(target_row-i<0){\\n                        helper(ans,\\'U\\',i-target_row);\\n                    }\\n                    i=target_row;\\n                }  \\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int row[26]={0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4,5};\\n    int col[26]={0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0};\\npublic:\\n    void helper(string& ans, char x, int count){\\n        for(int i=0;i<count;i++)ans+=x;\\n        return;\\n    }\\n    string alphabetBoardPath(string target) {\\n        string ans=\"\";\\n        int i=0,j=0;\\n        for(int index=0;index<target.size();){\\n            if(i==row[target[index]-\\'a\\'] && j==col[target[index]-\\'a\\']){\\n                ans+=\\'!\\';\\n                index++;\\n            }else{\\n                if(target[index]!=\\'z\\'){\\n                    int target_row = row[target[index]-\\'a\\'];\\n                    int target_col = col[target[index]-\\'a\\'];\\n                    if(target_row-i>0){\\n                        helper(ans,\\'D\\',target_row-i);\\n                    }else if(target_row-i<0){\\n                        helper(ans,\\'U\\',i-target_row);\\n                    }\\n                    i=target_row;\\n                    if(target_col-j>0){\\n                        helper(ans,\\'R\\',target_col-j);\\n                    }else if(target_col-j<0){\\n                        helper(ans,\\'L\\',j-target_col);\\n                    }\\n                    j=target_col;\\n                }else{\\n                    int target_row = row[target[index]-\\'a\\'];\\n                    int target_col = col[target[index]-\\'a\\'];\\n                    if(target_col-j>0){\\n                        helper(ans,\\'R\\',target_col-j);\\n                    }else if(target_col-j<0){\\n                        helper(ans,\\'L\\',j-target_col);\\n                    }\\n                    j=target_col;\\n                    \\n                    if(target_row-i>0){\\n                        helper(ans,\\'D\\',target_row-i);\\n                    }else if(target_row-i<0){\\n                        helper(ans,\\'U\\',i-target_row);\\n                    }\\n                    i=target_row;\\n                }  \\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626558,
                "title": "beat-91-python-solution-o-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        alpha_list = string.ascii_lowercase\\n        alpha_d = {}\\n        for i,j in enumerate(alpha_list):\\n            alpha_d[j] = i\\n        def move(loc, target, alpha_d):\\n            if loc == target:\\n                return \\'!\\'\\n            temp =\\'\\'\\n            if target !=\\'z\\':\\n                for _ in range(abs(alpha_d[target]//5-alpha_d[loc]//5)):\\n                    if alpha_d[target]//5-alpha_d[loc]//5>0:\\n                        temp += \\'D\\'\\n                    else:\\n                        temp+= \\'U\\'\\n                for _ in range(abs(alpha_d[target]%5-alpha_d[loc]%5)):\\n                    if alpha_d[target]%5-alpha_d[loc]%5>0:\\n                        temp+=\\'R\\'\\n                    else:\\n                        temp+=\\'L\\'\\n                return temp+\\'!\\'\\n            else:\\n                temp+=\\'L\\'*(alpha_d[loc]%5)\\n                temp+=\\'D\\'*(5-alpha_d[loc]//5)\\n                return temp+\\'!\\'\\n        re = \\'\\'\\n        start =\\'a\\'\\n        for i in target:\\n            re+=move(start,i,alpha_d)\\n            start =i\\n        return re\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        alpha_list = string.ascii_lowercase\\n        alpha_d = {}\\n        for i,j in enumerate(alpha_list):\\n            alpha_d[j] = i\\n        def move(loc, target, alpha_d):\\n            if loc == target:\\n                return \\'!\\'\\n            temp =\\'\\'\\n            if target !=\\'z\\':\\n                for _ in range(abs(alpha_d[target]//5-alpha_d[loc]//5)):\\n                    if alpha_d[target]//5-alpha_d[loc]//5>0:\\n                        temp += \\'D\\'\\n                    else:\\n                        temp+= \\'U\\'\\n                for _ in range(abs(alpha_d[target]%5-alpha_d[loc]%5)):\\n                    if alpha_d[target]%5-alpha_d[loc]%5>0:\\n                        temp+=\\'R\\'\\n                    else:\\n                        temp+=\\'L\\'\\n                return temp+\\'!\\'\\n            else:\\n                temp+=\\'L\\'*(alpha_d[loc]%5)\\n                temp+=\\'D\\'*(5-alpha_d[loc]//5)\\n                return temp+\\'!\\'\\n        re = \\'\\'\\n        start =\\'a\\'\\n        for i in target:\\n            re+=move(start,i,alpha_d)\\n            start =i\\n        return re\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621260,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int x = 0, y = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < target.length(); i++){\\n            char ch = target.charAt(i);\\n            int x1 = (ch - \\'a\\') / 5;\\n            int y1 = (ch - \\'a\\') % 5;\\n            while(x1 < x)   {x--; sb.append(\\'U\\');}\\n            while(y1 > y)   {y++; sb.append(\\'R\\');}\\n            while(y1 < y)   {y--; sb.append(\\'L\\');}\\n            while(x1 > x)   {x++; sb.append(\\'D\\');}\\n            sb.append(\\'!\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483603,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `target`\\n */\\nclass Solution {\\n public:\\n  string alphabetBoardPath(const string &target) {\\n    constexpr char to_up = \\'U\\';\\n    constexpr char to_down = \\'D\\';\\n    constexpr char to_left = \\'L\\';\\n    constexpr char to_right = \\'R\\';\\n    constexpr char push_down = \\'!\\';\\n    constexpr int a = \\'a\\';\\n    \\n    string ret;\\n    int previous = 0;   // which means the initial position is (0, 0), that is `\\'a\\'`\\'s position\\n    for (const char ch : target) {\\n      const int current = ch - a;\\n      const auto [r, c] = position(current);\\n      const auto [pr, pc] = position(previous);\\n      /**\\n       * since moving down or moving right firstly,\\n       * and then moving up or moving left will possibly go out of the boundary,\\n       * the following moving order is safe to perform.\\n       */\\n      // move left if necessary\\n      if (c < pc) {\\n        ret.append(pc - c, to_left);\\n      }\\n      // move up if necessary\\n      if (r < pr) {\\n        ret.append(pr - r, to_up);\\n      }\\n      // move right if necessary\\n      if (c > pc) {\\n        ret.append(c - pc, to_right);\\n      }\\n      // move down if necessary\\n      if (r > pr) {\\n        ret.append(r - pr, to_down);\\n      }\\n      ret.push_back(push_down);\\n      previous = current;\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  pair<int, int> position(const int letter) {\\n    constexpr int cols = 5;\\n    return make_pair(letter / cols, letter % cols);\\n  };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the string `target`\\n */\\nclass Solution {\\n public:\\n  string alphabetBoardPath(const string &target) {\\n    constexpr char to_up = \\'U\\';\\n    constexpr char to_down = \\'D\\';\\n    constexpr char to_left = \\'L\\';\\n    constexpr char to_right = \\'R\\';\\n    constexpr char push_down = \\'!\\';\\n    constexpr int a = \\'a\\';\\n    \\n    string ret;\\n    int previous = 0;   // which means the initial position is (0, 0), that is `\\'a\\'`\\'s position\\n    for (const char ch : target) {\\n      const int current = ch - a;\\n      const auto [r, c] = position(current);\\n      const auto [pr, pc] = position(previous);\\n      /**\\n       * since moving down or moving right firstly,\\n       * and then moving up or moving left will possibly go out of the boundary,\\n       * the following moving order is safe to perform.\\n       */\\n      // move left if necessary\\n      if (c < pc) {\\n        ret.append(pc - c, to_left);\\n      }\\n      // move up if necessary\\n      if (r < pr) {\\n        ret.append(pr - r, to_up);\\n      }\\n      // move right if necessary\\n      if (c > pc) {\\n        ret.append(c - pc, to_right);\\n      }\\n      // move down if necessary\\n      if (r > pr) {\\n        ret.append(r - pr, to_down);\\n      }\\n      ret.push_back(push_down);\\n      previous = current;\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  pair<int, int> position(const int letter) {\\n    constexpr int cols = 5;\\n    return make_pair(letter / cols, letter % cols);\\n  };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434356,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n\\n    private static let board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"].map(Array.init)\\n    private static let letters = board\\n        .joined()\\n        .reduce(into: [Character: (Int, Int)]()) { acc, c in\\n            let row = board.firstIndex { $0.contains(c) }\\n            let col = board[row!].firstIndex(of: c)\\n            acc[c] = (row!, col!)\\n        }\\n\\n    func alphabetBoardPath(_ target: String) -> String {\\n\\n        func move(_ from: (Int, Int), _ to: (Int, Int)) -> String {\\n            var res = \"\"\\n            var f = from\\n            var t = to\\n\\n            while f.0 > t.0 {\\n                f.0 -= 1\\n                res += \"U\"\\n            }\\n\\n            while f.1 > t.1 {\\n                f.1 -= 1\\n                res += \"L\"\\n            }\\n\\n            while f.0 < t.0 {\\n                f.0 += 1\\n                res += \"D\"\\n            }\\n\\n            while f.1 < t.1 {\\n                f.1 += 1\\n                res += \"R\"\\n            }\\n\\n            return res + \"!\"\\n        }\\n\\n        let coords = target.map { Self.letters[$0]! }\\n        \\n        return zip([(0, 0)] + coords.dropLast(), coords)\\n            .map(move)\\n            .joined()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static let board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"].map(Array.init)\\n    private static let letters = board\\n        .joined()\\n        .reduce(into: [Character: (Int, Int)]()) { acc, c in\\n            let row = board.firstIndex { $0.contains(c) }\\n            let col = board[row!].firstIndex(of: c)\\n            acc[c] = (row!, col!)\\n        }\\n\\n    func alphabetBoardPath(_ target: String) -> String {\\n\\n        func move(_ from: (Int, Int), _ to: (Int, Int)) -> String {\\n            var res = \"\"\\n            var f = from\\n            var t = to\\n\\n            while f.0 > t.0 {\\n                f.0 -= 1\\n                res += \"U\"\\n            }\\n\\n            while f.1 > t.1 {\\n                f.1 -= 1\\n                res += \"L\"\\n            }\\n\\n            while f.0 < t.0 {\\n                f.0 += 1\\n                res += \"D\"\\n            }\\n\\n            while f.1 < t.1 {\\n                f.1 += 1\\n                res += \"R\"\\n            }\\n\\n            return res + \"!\"\\n        }\\n\\n        let coords = target.map { Self.letters[$0]! }\\n        \\n        return zip([(0, 0)] + coords.dropLast(), coords)\\n            .map(move)\\n            .joined()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378791,
                "title": "c-was-kinda-annoying-but-ok-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n    std::vector<string>board= {\"abcde\",\"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n    int row=0;\\n    int col=0;\\n    std::string res=\"\";\\n    int movevertical=0;\\n    int tcol=0;\\n    int curcol=0;\\n    char addlater=\\'\\\\0\\';\\n    for (int i=0; i<target.size(); i++)\\n    {\\n        addlater=\\'\\\\0\\';\\n        if (board[row][col]==target[i])\\n        {\\n            res+=\\'!\\';\\n            continue;\\n        }\\n        \\n        if (target[i] > board[row][col])\\n        {\\n            movevertical = (target[i]-97)/5 - (board[row][col]-97)/5;\\n            curcol=(board[row][col]-97)%5;\\n            tcol=(target[i]-97)%5;\\n            for (int k=0; k<movevertical; k++)\\n            {\\n                if (row == 4 && col > 0) \\n                {\\n                 addlater=\\'D\\';\\n                 break;\\n                }\\n                res+=\\'D\\';\\n                row++;\\n            \\n                \\n            }\\n            \\n        }\\n        else\\n        {\\n            movevertical= (board[row][col]-97)/5 - (target[i]-97)/5;\\n            curcol=(board[row][col]-97)%5;\\n            tcol=(target[i]-97)%5;\\n            for (int k=0; k<movevertical; k++)\\n            {\\n                res+=\\'U\\';\\n                row--;\\n            }\\n        }\\n        //calculate left / right\\n        //localize the difference.\\n        if (tcol > curcol)\\n        {\\n            for (int k=0; k<tcol-curcol; k++)\\n            {\\n                res+=\\'R\\';\\n                col++;\\n            }\\n        }\\n        else\\n        {\\n            for (int k=0; k<curcol-tcol; k++)\\n            {\\n                res+=\\'L\\';\\n                col--; \\n            }\\n        }\\n        if (addlater != \\'\\\\0\\')\\n        {\\n            res+=addlater;\\n            row++; \\n        }\\n        res+=\\'!\\';\\n\\n        \\n    }\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n    std::vector<string>board= {\"abcde\",\"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n    int row=0;\\n    int col=0;\\n    std::string res=\"\";\\n    int movevertical=0;\\n    int tcol=0;\\n    int curcol=0;\\n    char addlater=\\'\\\\0\\';\\n    for (int i=0; i<target.size(); i++)\\n    {\\n        addlater=\\'\\\\0\\';\\n        if (board[row][col]==target[i])\\n        {\\n            res+=\\'!\\';\\n            continue;\\n        }\\n        \\n        if (target[i] > board[row][col])\\n        {\\n            movevertical = (target[i]-97)/5 - (board[row][col]-97)/5;\\n            curcol=(board[row][col]-97)%5;\\n            tcol=(target[i]-97)%5;\\n            for (int k=0; k<movevertical; k++)\\n            {\\n                if (row == 4 && col > 0) \\n                {\\n                 addlater=\\'D\\';\\n                 break;\\n                }\\n                res+=\\'D\\';\\n                row++;\\n            \\n                \\n            }\\n            \\n        }\\n        else\\n        {\\n            movevertical= (board[row][col]-97)/5 - (target[i]-97)/5;\\n            curcol=(board[row][col]-97)%5;\\n            tcol=(target[i]-97)%5;\\n            for (int k=0; k<movevertical; k++)\\n            {\\n                res+=\\'U\\';\\n                row--;\\n            }\\n        }\\n        //calculate left / right\\n        //localize the difference.\\n        if (tcol > curcol)\\n        {\\n            for (int k=0; k<tcol-curcol; k++)\\n            {\\n                res+=\\'R\\';\\n                col++;\\n            }\\n        }\\n        else\\n        {\\n            for (int k=0; k<curcol-tcol; k++)\\n            {\\n                res+=\\'L\\';\\n                col--; \\n            }\\n        }\\n        if (addlater != \\'\\\\0\\')\\n        {\\n            res+=addlater;\\n            row++; \\n        }\\n        res+=\\'!\\';\\n\\n        \\n    }\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367754,
                "title": "easy-to-understand-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n         char [] carr=target.toCharArray();\\n        StringBuilder sb=new StringBuilder();\\n        int cr=0;\\n        int cc=0;\\n        for(int i=0;i<carr.length;i++){\\n            int a=carr[i]-97;\\n            int r=a/5;\\n            int c=a%5;\\n           \\n            while(cr!=r){\\n                if(cr>r){\\n                    cr--;\\n                    sb.append(\"U\");\\n                }else{\\n                    if(cc!=0 && cr==4) {\\n                \\t\\t\\n                \\t\\tbreak;\\n                \\t}\\n                    cr++;\\n                    sb.append(\"D\");\\n                }\\n            }\\n           \\n          //  System.out.println(r);\\n            while(cc!=c){\\n                if(cc>c){\\n                    cc--;\\n                    sb.append(\"L\");\\n                }else if(cc < c){\\n                    cc++;\\n                    sb.append(\"R\");\\n                }\\n            }\\n            if(cr>r || cr<r) {\\n            \\tSystem.out.println(cr);\\n            \\tsb.append(\"D\");\\n            }\\n            //System.out.println(c);\\n            cr=r;\\n            cc=c;\\n            sb.append(\"!\");\\n\\n        }\\n        return sb.toString();\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n         char [] carr=target.toCharArray();\\n        StringBuilder sb=new StringBuilder();\\n        int cr=0;\\n        int cc=0;\\n        for(int i=0;i<carr.length;i++){\\n            int a=carr[i]-97;\\n            int r=a/5;\\n            int c=a%5;\\n           \\n            while(cr!=r){\\n                if(cr>r){\\n                    cr--;\\n                    sb.append(\"U\");\\n                }else{\\n                    if(cc!=0 && cr==4) {\\n                \\t\\t\\n                \\t\\tbreak;\\n                \\t}\\n                    cr++;\\n                    sb.append(\"D\");\\n                }\\n            }\\n           \\n          //  System.out.println(r);\\n            while(cc!=c){\\n                if(cc>c){\\n                    cc--;\\n                    sb.append(\"L\");\\n                }else if(cc < c){\\n                    cc++;\\n                    sb.append(\"R\");\\n                }\\n            }\\n            if(cr>r || cr<r) {\\n            \\tSystem.out.println(cr);\\n            \\tsb.append(\"D\");\\n            }\\n            //System.out.println(c);\\n            cr=r;\\n            cc=c;\\n            sb.append(\"!\");\\n\\n        }\\n        return sb.toString();\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347853,
                "title": "string-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public class Pair{\\n        int row;\\n        int col;\\n        public Pair(int i,int j){\\n            this.row=i;\\n            this.col=j;\\n        }\\n    }\\n    public String alphabetBoardPath(String target) {\\n        String[] alphabets = {\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z\"};\\n        HashMap<Character,Pair> map = new HashMap<>();\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<alphabets[i].length();j++){\\n                map.put(alphabets[i].charAt(j),(new Pair(i,j)));\\n            }\\n        }\\n        map.put(\\'z\\',(new Pair(5,0)));\\n        int j=0;\\n        String str = \"\";\\n        int a=0,b=0;\\n        while(j<target.length()){\\n            if(map.get(target.charAt(j)).row<a){\\n                int x = a-map.get(target.charAt(j)).row;\\n                for(int i=1;i<=x;i++){\\n                    str += \"U\";\\n                }\\n            }\\n            if(map.get(target.charAt(j)).col<b){\\n                int x = b-map.get(target.charAt(j)).col;\\n                for(int i=1;i<=x;i++){\\n                    str += \"L\";\\n                }\\n            }\\n            if(map.get(target.charAt(j)).col>=b){\\n                int x = map.get(target.charAt(j)).col-b;\\n                for(int i=1;i<=x;i++){\\n                    str += \"R\";\\n                }\\n            }\\n            if(map.get(target.charAt(j)).row>=a){\\n                int x = map.get(target.charAt(j)).row-a;\\n                for(int i=1;i<=x;i++){\\n                    str += \"D\";\\n                }\\n            }\\n            str += \\'!\\';\\n            a=map.get(target.charAt(j)).row;\\n            b=map.get(target.charAt(j)).col;\\n            j++;\\n        }\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public class Pair{\\n        int row;\\n        int col;\\n        public Pair(int i,int j){\\n            this.row=i;\\n            this.col=j;\\n        }\\n    }\\n    public String alphabetBoardPath(String target) {\\n        String[] alphabets = {\"abcde\",\"fghij\",\"klmno\",\"pqrst\",\"uvwxy\",\"z\"};\\n        HashMap<Character,Pair> map = new HashMap<>();\\n        for(int i=0;i<5;i++){\\n            for(int j=0;j<alphabets[i].length();j++){\\n                map.put(alphabets[i].charAt(j),(new Pair(i,j)));\\n            }\\n        }\\n        map.put(\\'z\\',(new Pair(5,0)));\\n        int j=0;\\n        String str = \"\";\\n        int a=0,b=0;\\n        while(j<target.length()){\\n            if(map.get(target.charAt(j)).row<a){\\n                int x = a-map.get(target.charAt(j)).row;\\n                for(int i=1;i<=x;i++){\\n                    str += \"U\";\\n                }\\n            }\\n            if(map.get(target.charAt(j)).col<b){\\n                int x = b-map.get(target.charAt(j)).col;\\n                for(int i=1;i<=x;i++){\\n                    str += \"L\";\\n                }\\n            }\\n            if(map.get(target.charAt(j)).col>=b){\\n                int x = map.get(target.charAt(j)).col-b;\\n                for(int i=1;i<=x;i++){\\n                    str += \"R\";\\n                }\\n            }\\n            if(map.get(target.charAt(j)).row>=a){\\n                int x = map.get(target.charAt(j)).row-a;\\n                for(int i=1;i<=x;i++){\\n                    str += \"D\";\\n                }\\n            }\\n            str += \\'!\\';\\n            a=map.get(target.charAt(j)).row;\\n            b=map.get(target.charAt(j)).col;\\n            j++;\\n        }\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342468,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar alphabetBoardPath = function(target) {\\n    const BOARD = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\n    const currentPosition = { row: 0, col: 0 };\\n    const alphabetPathMap = BOARD.reduce((map, alphabets, row) => {\\n        for (let col = 0; col < alphabets.length; col++) {\\n            map.set(alphabets[col], { row, col });\\n        }\\n        return map;\\n    }, new Map());\\n    const move = (str, count) => str.repeat(Math.abs(count));\\n    \\n    return [...target].reduce((result, alphabet) => {\\n        const { row, col } = alphabetPathMap.get(alphabet);\\n        const moveRow = row - currentPosition.row;\\n        const moveCol = col - currentPosition.col;\\n        const codeRow = moveRow > 0 ? \\'D\\' : \\'U\\';\\n        const codeCol = moveCol > 0 ? \\'R\\' : \\'L\\';\\n\\n        result += alphabet === \\'z\\'\\n            ? move(codeCol, moveCol) + move(codeRow, moveRow)\\n            : move(codeRow, moveRow) + move(codeCol, moveCol);\\n        result += \\'!\\';\\n        currentPosition.row = row;\\n        currentPosition.col = col;\\n        return result;\\n    }, \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar alphabetBoardPath = function(target) {\\n    const BOARD = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"];\\n    const currentPosition = { row: 0, col: 0 };\\n    const alphabetPathMap = BOARD.reduce((map, alphabets, row) => {\\n        for (let col = 0; col < alphabets.length; col++) {\\n            map.set(alphabets[col], { row, col });\\n        }\\n        return map;\\n    }, new Map());\\n    const move = (str, count) => str.repeat(Math.abs(count));\\n    \\n    return [...target].reduce((result, alphabet) => {\\n        const { row, col } = alphabetPathMap.get(alphabet);\\n        const moveRow = row - currentPosition.row;\\n        const moveCol = col - currentPosition.col;\\n        const codeRow = moveRow > 0 ? \\'D\\' : \\'U\\';\\n        const codeCol = moveCol > 0 ? \\'R\\' : \\'L\\';\\n\\n        result += alphabet === \\'z\\'\\n            ? move(codeCol, moveCol) + move(codeRow, moveRow)\\n            : move(codeRow, moveRow) + move(codeCol, moveCol);\\n        result += \\'!\\';\\n        currentPosition.row = row;\\n        currentPosition.col = col;\\n        return result;\\n    }, \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285644,
                "title": "c-beats-92-using-tuple-coords",
                "content": "![12.png](https://assets.leetcode.com/users/images/951301fb-5389-4db7-9046-2ff32957fdf8_1678567893.6026382.png)\\n```\\npublic class Solution \\n{\\n    public string AlphabetBoardPath(string target) \\n    {\\n        var from = \\'a\\';\\n        var sbResult = new StringBuilder();\\n\\n        foreach (var letter in target)\\n        {\\n            var fromCoord = GetCoords(from);\\n            var toCoord = GetCoords(letter);\\n            var differenceX = toCoord.x - fromCoord.x;\\n            var differenceY = fromCoord.y - toCoord.y; // because Y is initially top-down\\n            \\n            if (differenceX < 0)\\n            {\\n                sbResult.Append(new string(\\'L\\', -differenceX));\\n            }\\n            if (differenceY < 0)\\n            {\\n                sbResult.Append(new string(\\'D\\', -differenceY));\\n            }\\n            if (differenceY > 0)\\n            {\\n                sbResult.Append(new string(\\'U\\', differenceY));\\n            }\\n            if (differenceX > 0)\\n            {\\n                sbResult.Append(new string(\\'R\\', differenceX));\\n            }\\n\\n            sbResult.Append(\"!\");\\n\\n            from = letter;\\n        }\\n\\n       return sbResult.ToString();\\n    }\\n\\n    public (int x, int y) GetCoords(char c)\\n    {\\n        return ((c - \\'a\\') % 5, (c - \\'a\\') / 5);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public string AlphabetBoardPath(string target) \\n    {\\n        var from = \\'a\\';\\n        var sbResult = new StringBuilder();\\n\\n        foreach (var letter in target)\\n        {\\n            var fromCoord = GetCoords(from);\\n            var toCoord = GetCoords(letter);\\n            var differenceX = toCoord.x - fromCoord.x;\\n            var differenceY = fromCoord.y - toCoord.y; // because Y is initially top-down\\n            \\n            if (differenceX < 0)\\n            {\\n                sbResult.Append(new string(\\'L\\', -differenceX));\\n            }\\n            if (differenceY < 0)\\n            {\\n                sbResult.Append(new string(\\'D\\', -differenceY));\\n            }\\n            if (differenceY > 0)\\n            {\\n                sbResult.Append(new string(\\'U\\', differenceY));\\n            }\\n            if (differenceX > 0)\\n            {\\n                sbResult.Append(new string(\\'R\\', differenceX));\\n            }\\n\\n            sbResult.Append(\"!\");\\n\\n            from = letter;\\n        }\\n\\n       return sbResult.ToString();\\n    }\\n\\n    public (int x, int y) GetCoords(char c)\\n    {\\n        return ((c - \\'a\\') % 5, (c - \\'a\\') / 5);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276941,
                "title": "greedy-using-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        s=string.ascii_lowercase\\n        x=0\\n        y=0\\n        d={}\\n        for i in s:\\n            d[i]=(x,y)\\n            y+=1\\n            if y==5:\\n                x+=1\\n                y=0\\n        x,y=0,0\\n        res=\"\"\\n        for i in target:\\n            x1,y1=d[i]\\n            a=x-x1\\n            b=y-y1\\n            if i==\"z\":\\n                res+=\"L\"*(y)\\n                res+=\"D\"*abs(x-x1)\\n                res+=\"!\"\\n                x,y=x1,y1\\n                continue\\n            if a>0:\\n                res+=\"U\"*(x-x1)\\n            elif a<0:\\n                res+=\"D\"*abs(x-x1)\\n            if b>0:\\n                res+=\"L\"*(abs(y-y1))\\n            elif b<0:\\n                res+=\"R\"*(abs(y-y1))\\n            res+=\"!\"\\n            x,y=x1,y1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        s=string.ascii_lowercase\\n        x=0\\n        y=0\\n        d={}\\n        for i in s:\\n            d[i]=(x,y)\\n            y+=1\\n            if y==5:\\n                x+=1\\n                y=0\\n        x,y=0,0\\n        res=\"\"\\n        for i in target:\\n            x1,y1=d[i]\\n            a=x-x1\\n            b=y-y1\\n            if i==\"z\":\\n                res+=\"L\"*(y)\\n                res+=\"D\"*abs(x-x1)\\n                res+=\"!\"\\n                x,y=x1,y1\\n                continue\\n            if a>0:\\n                res+=\"U\"*(x-x1)\\n            elif a<0:\\n                res+=\"D\"*abs(x-x1)\\n            if b>0:\\n                res+=\"L\"*(abs(y-y1))\\n            elif b<0:\\n                res+=\"R\"*(abs(y-y1))\\n            res+=\"!\"\\n            x,y=x1,y1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253572,
                "title": "be-attention-for-the-z",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {        \\n        auto coordForChar = [](char c) {            \\n            int idx = c - \\'a\\';            \\n            return make_pair(idx / 5, idx % 5);\\n        };\\n        \\n        auto lastPos = make_pair(0, 0);\\n        \\n        string ans = \"\";\\n        for (char c: target) {\\n            auto toPos = coordForChar(c);            \\n            \\n            int rowDiff = toPos.first - lastPos.first;\\n            int colDiff = toPos.second - lastPos.second;\\n            \\n            if (c == \\'z\\') {\\n                \\n                // since we need to move char from last to \\'z\\'\\n                // we have to move to the first column, and then move down to z\\n                if (colDiff != 0) {\\n                    // must be negative...\\n                    ans += string(-colDiff, \\'L\\');\\n                }\\n                if (rowDiff != 0) {\\n                   ans += string(rowDiff, \\'D\\');                    \\n                }\\n                \\n            } else {\\n                if (rowDiff != 0) {                    \\n                    ans += string(abs(rowDiff), rowDiff > 0 ? \\'D\\' : \\'U\\');                    \\n                }\\n                if (colDiff != 0) {\\n                    ans += string(abs(colDiff), colDiff > 0 ? \\'R\\' : \\'L\\');\\n                }   \\n            }\\n            \\n            ans += \"!\";\\n            lastPos = toPos;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {        \\n        auto coordForChar = [](char c) {            \\n            int idx = c - \\'a\\';            \\n            return make_pair(idx / 5, idx % 5);\\n        };\\n        \\n        auto lastPos = make_pair(0, 0);\\n        \\n        string ans = \"\";\\n        for (char c: target) {\\n            auto toPos = coordForChar(c);            \\n            \\n            int rowDiff = toPos.first - lastPos.first;\\n            int colDiff = toPos.second - lastPos.second;\\n            \\n            if (c == \\'z\\') {\\n                \\n                // since we need to move char from last to \\'z\\'\\n                // we have to move to the first column, and then move down to z\\n                if (colDiff != 0) {\\n                    // must be negative...\\n                    ans += string(-colDiff, \\'L\\');\\n                }\\n                if (rowDiff != 0) {\\n                   ans += string(rowDiff, \\'D\\');                    \\n                }\\n                \\n            } else {\\n                if (rowDiff != 0) {                    \\n                    ans += string(abs(rowDiff), rowDiff > 0 ? \\'D\\' : \\'U\\');                    \\n                }\\n                if (colDiff != 0) {\\n                    ans += string(abs(colDiff), colDiff > 0 ? \\'R\\' : \\'L\\');\\n                }   \\n            }\\n            \\n            ans += \"!\";\\n            lastPos = toPos;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246297,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string bfs(vector<pair<int,char>> adj[],int i,int target){\\n        vector<bool> vis(26,false);\\n        queue<pair<int,string>> q;\\n        q.push({i,\"\"});\\n        vis[i]=true;\\n        while(q.size()!=0){\\n            int node = q.front().first;\\n            string st = q.front().second;\\n            q.pop();\\n            \\n            if(node==target) return st;\\n            \\n            for(auto it:adj[node]){\\n                if(!vis[it.first]){\\n                    vis[it.first]=true;\\n                    st+=it.second;\\n                    q.push({it.first,st});\\n                    st.pop_back();\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n        \\n    }\\n    string alphabetBoardPath(string target) {\\n        vector<pair<int,char>> adj[26];\\n        vector<string> arr = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\"};\\n        int row = arr.size();\\n        int col = arr[0].size();\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                int delR[] = {-1,1,0,0};\\n                int delC[] = {0,0,-1,1};\\n                for(int k=0;k<4;k++){\\n                    int nr = i+delR[k];\\n                    int nc = j+delC[k];\\n                    char ch;\\n                    if(k==0) ch=\\'U\\';\\n                    if(k==1) ch=\\'D\\';\\n                    if(k==2) ch=\\'L\\';\\n                    if(k==3) ch=\\'R\\';\\n                    if(nr>=0&&nc>=0&&nr<row&&nc<col){\\n                        adj[arr[i][j]-\\'a\\'].push_back({arr[nr][nc]-\\'a\\',ch});\\n                    }\\n                }\\n            }\\n        }\\n        adj[\\'u\\'-\\'a\\'].push_back({\\'z\\'-\\'a\\',\\'D\\'});\\n        adj[\\'z\\'-\\'a\\'].push_back({\\'u\\'-\\'a\\',\\'U\\'});\\n        \\n        \\n        // for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n        //     for(auto it:adj[ch-\\'a\\']) cout<<(char)(it.first+\\'a\\')<<\"-\"<<it.second<<\" : \";\\n        //     cout<<endl;\\n        // }\\n        \\n        string ans = \"\";\\n        \\n        char ch = \\'a\\';\\n        for(int i=0;i<target.size();i++){\\n            ans+=bfs(adj,ch-\\'a\\',target[i]-\\'a\\');\\n            ans+=\\'!\\';\\n            ch=target[i];\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string bfs(vector<pair<int,char>> adj[],int i,int target){\\n        vector<bool> vis(26,false);\\n        queue<pair<int,string>> q;\\n        q.push({i,\"\"});\\n        vis[i]=true;\\n        while(q.size()!=0){\\n            int node = q.front().first;\\n            string st = q.front().second;\\n            q.pop();\\n            \\n            if(node==target) return st;\\n            \\n            for(auto it:adj[node]){\\n                if(!vis[it.first]){\\n                    vis[it.first]=true;\\n                    st+=it.second;\\n                    q.push({it.first,st});\\n                    st.pop_back();\\n                }\\n            }\\n        }\\n        \\n        return \"\";\\n        \\n    }\\n    string alphabetBoardPath(string target) {\\n        vector<pair<int,char>> adj[26];\\n        vector<string> arr = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\"};\\n        int row = arr.size();\\n        int col = arr[0].size();\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                int delR[] = {-1,1,0,0};\\n                int delC[] = {0,0,-1,1};\\n                for(int k=0;k<4;k++){\\n                    int nr = i+delR[k];\\n                    int nc = j+delC[k];\\n                    char ch;\\n                    if(k==0) ch=\\'U\\';\\n                    if(k==1) ch=\\'D\\';\\n                    if(k==2) ch=\\'L\\';\\n                    if(k==3) ch=\\'R\\';\\n                    if(nr>=0&&nc>=0&&nr<row&&nc<col){\\n                        adj[arr[i][j]-\\'a\\'].push_back({arr[nr][nc]-\\'a\\',ch});\\n                    }\\n                }\\n            }\\n        }\\n        adj[\\'u\\'-\\'a\\'].push_back({\\'z\\'-\\'a\\',\\'D\\'});\\n        adj[\\'z\\'-\\'a\\'].push_back({\\'u\\'-\\'a\\',\\'U\\'});\\n        \\n        \\n        // for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n        //     for(auto it:adj[ch-\\'a\\']) cout<<(char)(it.first+\\'a\\')<<\"-\"<<it.second<<\" : \";\\n        //     cout<<endl;\\n        // }\\n        \\n        string ans = \"\";\\n        \\n        char ch = \\'a\\';\\n        for(int i=0;i<target.size();i++){\\n            ans+=bfs(adj,ch-\\'a\\',target[i]-\\'a\\');\\n            ans+=\\'!\\';\\n            ch=target[i];\\n        }\\n        \\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3227327,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ret;\\n        int curR = 0, curC = 0;\\n        for (char a : target) {\\n            int nextR = (a - \\'a\\') / 5;\\n            int nextC = (a - \\'a\\') % 5;\\n            \\n            if(nextR >= curR){\\n                ret += string(max(0, nextC - curC), \\'R\\') + string(max(0, curC - nextC), \\'L\\') + string(nextR - curR, \\'D\\') + \"!\" ;   \\n            }\\n            else{\\n                ret += string(curR - nextR, \\'U\\') + string(max(0, nextC - curC), \\'R\\') + string(max(0, curC - nextC), \\'L\\') + \"!\" ;   \\n            }\\n\\n            curR = nextR;\\n            curC = nextC;\\n        }\\n        return ret;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ret;\\n        int curR = 0, curC = 0;\\n        for (char a : target) {\\n            int nextR = (a - \\'a\\') / 5;\\n            int nextC = (a - \\'a\\') % 5;\\n            \\n            if(nextR >= curR){\\n                ret += string(max(0, nextC - curC), \\'R\\') + string(max(0, curC - nextC), \\'L\\') + string(nextR - curR, \\'D\\') + \"!\" ;   \\n            }\\n            else{\\n                ret += string(curR - nextR, \\'U\\') + string(max(0, nextC - curC), \\'R\\') + string(max(0, curC - nextC), \\'L\\') + \"!\" ;   \\n            }\\n\\n            curR = nextR;\\n            curC = nextC;\\n        }\\n        return ret;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197503,
                "title": "c-table-of-moves-between-all-characters",
                "content": "```\\nclass Solution {\\n    const vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n    string dist(array<pair<int,int>, 26U> &locs, char c1, char c2) {\\n        \\n        if(c1 == c2)\\n            return \"\";\\n        \\n        const auto &l1 = locs[c1 - \\'a\\'];\\n        const auto &l2 = locs[c2 - \\'a\\'];\\n        \\n        string ret;\\n        if((c1 != \\'z\\' && c2 != \\'z\\') || c1 == \\'z\\') {\\n            for(int r = 0; r < abs(l2.first - l1.first); ++r) {\\n                ret += (l2.first > l1.first) ? \\'D\\' : \\'U\\';\\n            }\\n            for(int c = 0; c < abs(l2.second - l1.second); ++c) {\\n                ret += (l2.second > l1.second) ? \\'R\\' : \\'L\\';\\n            }\\n        } else {\\n            for(int c = 0; c < abs(l2.second - l1.second); ++c) {\\n                ret += (l2.second > l1.second) ? \\'R\\' : \\'L\\';\\n            }\\n            for(int r = 0; r < abs(l2.first - l1.first); ++r) {\\n                ret += (l2.first > l1.first) ? \\'D\\' : \\'U\\';\\n            }\\n        }\\n        return ret;\\n    }\\npublic:\\n    string alphabetBoardPath(string target) {\\n        array<pair<int,int>, 26U> locs;\\n        const int M = board.size();\\n        for(int r = 0; r < M; ++r) {\\n            const int N = board[r].size();\\n            for(int c = 0; c < N; ++c) {\\n                locs[board[r][c] - \\'a\\'] = {r, c};\\n            }\\n        }\\n        \\n        array<array<string, 26U>, 26U> distances;\\n        \\n        for(char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1) {\\n            distances[c1 - \\'a\\'][c1 - \\'a\\'] = \"\";\\n            for(char c2 = c1 + 1; c2 <= \\'z\\'; ++c2) {\\n                distances[c1 - \\'a\\'][c2 - \\'a\\'] = dist(locs, c1, c2);\\n                distances[c2 - \\'a\\'][c1 - \\'a\\'] = dist(locs, c2, c1);                \\n            }    \\n        }\\n        \\n        string ret;\\n        const int L = target.length();\\n        char start = board[0][0];\\n        for(const char c : target) {\\n            ret += (distances[start - \\'a\\'][c - \\'a\\'] + \\'!\\');\\n            start = c;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const vector<string> board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n    string dist(array<pair<int,int>, 26U> &locs, char c1, char c2) {\\n        \\n        if(c1 == c2)\\n            return \"\";\\n        \\n        const auto &l1 = locs[c1 - \\'a\\'];\\n        const auto &l2 = locs[c2 - \\'a\\'];\\n        \\n        string ret;\\n        if((c1 != \\'z\\' && c2 != \\'z\\') || c1 == \\'z\\') {\\n            for(int r = 0; r < abs(l2.first - l1.first); ++r) {\\n                ret += (l2.first > l1.first) ? \\'D\\' : \\'U\\';\\n            }\\n            for(int c = 0; c < abs(l2.second - l1.second); ++c) {\\n                ret += (l2.second > l1.second) ? \\'R\\' : \\'L\\';\\n            }\\n        } else {\\n            for(int c = 0; c < abs(l2.second - l1.second); ++c) {\\n                ret += (l2.second > l1.second) ? \\'R\\' : \\'L\\';\\n            }\\n            for(int r = 0; r < abs(l2.first - l1.first); ++r) {\\n                ret += (l2.first > l1.first) ? \\'D\\' : \\'U\\';\\n            }\\n        }\\n        return ret;\\n    }\\npublic:\\n    string alphabetBoardPath(string target) {\\n        array<pair<int,int>, 26U> locs;\\n        const int M = board.size();\\n        for(int r = 0; r < M; ++r) {\\n            const int N = board[r].size();\\n            for(int c = 0; c < N; ++c) {\\n                locs[board[r][c] - \\'a\\'] = {r, c};\\n            }\\n        }\\n        \\n        array<array<string, 26U>, 26U> distances;\\n        \\n        for(char c1 = \\'a\\'; c1 <= \\'z\\'; ++c1) {\\n            distances[c1 - \\'a\\'][c1 - \\'a\\'] = \"\";\\n            for(char c2 = c1 + 1; c2 <= \\'z\\'; ++c2) {\\n                distances[c1 - \\'a\\'][c2 - \\'a\\'] = dist(locs, c1, c2);\\n                distances[c2 - \\'a\\'][c1 - \\'a\\'] = dist(locs, c2, c1);                \\n            }    \\n        }\\n        \\n        string ret;\\n        const int L = target.length();\\n        char start = board[0][0];\\n        for(const char c : target) {\\n            ret += (distances[start - \\'a\\'][c - \\'a\\'] + \\'!\\');\\n            start = c;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173831,
                "title": "java-calculate-relative-position",
                "content": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder b = new StringBuilder();\\n        int[] current = new int[]{0, 0};\\n        for (int j = 0; j < target.length(); j++) {\\n            char c = target.charAt(j);\\n            int[] p = convert(c);\\n            if (Arrays.equals(p, current)) {\\n                b.append(\\'!\\');\\n                continue;\\n            }\\n            if (current[0] == 5 && current[1] == 0) {\\n                // handle z\\n                b.append(\\'U\\');\\n                current[0]--;\\n            }\\n            int x = p[0] - current[0];\\n            int y = p[1] - current[1];\\n            for (int i = 0; i < Math.abs(y); i++) {\\n                b.append(y > 0 ? \\'R\\' : \\'L\\');\\n            }   \\n            for (int i = 0; i < Math.abs(x); i++) {\\n                b.append(x > 0 ? \\'D\\' : \\'U\\');\\n            }            \\n            b.append(\\'!\\');\\n            current = p;\\n        }\\n        return b.toString();\\n    }\\n\\n    int[] convert(char c) {\\n        int num = c - \\'a\\';\\n        return new int[]{num / 5, num % 5};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        StringBuilder b = new StringBuilder();\\n        int[] current = new int[]{0, 0};\\n        for (int j = 0; j < target.length(); j++) {\\n            char c = target.charAt(j);\\n            int[] p = convert(c);\\n            if (Arrays.equals(p, current)) {\\n                b.append(\\'!\\');\\n                continue;\\n            }\\n            if (current[0] == 5 && current[1] == 0) {\\n                // handle z\\n                b.append(\\'U\\');\\n                current[0]--;\\n            }\\n            int x = p[0] - current[0];\\n            int y = p[1] - current[1];\\n            for (int i = 0; i < Math.abs(y); i++) {\\n                b.append(y > 0 ? \\'R\\' : \\'L\\');\\n            }   \\n            for (int i = 0; i < Math.abs(x); i++) {\\n                b.append(x > 0 ? \\'D\\' : \\'U\\');\\n            }            \\n            b.append(\\'!\\');\\n            current = p;\\n        }\\n        return b.toString();\\n    }\\n\\n    int[] convert(char c) {\\n        int num = c - \\'a\\';\\n        return new int[]{num / 5, num % 5};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173393,
                "title": "c-4ms-to-avoid-corner-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust be aware that \\'z\\' is a special corner case. To simplify our code, we could choose to move UP and LEFT before move DOWN and RIGHT, to avoid \\'z\\' cases.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate the board by a vector, simulate the board by a hash table.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn = target.length()\\nO(1) for creating hash table, O(n) for a linear search.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char, pair<int, int>> mp;\\n        string res = \"\";\\n        int cur_row = 0, cur_col = 0;\\n        vector<string> board{{\"abcde\"}, {\"fghij\"}, {\"klmno\"}, {\"pqrst\"}, {\"uvwxy\"}, {\"z\"}};\\n\\n        for(auto i = 0; i < board.size(); i++){\\n            for(auto j = 0; j < board[i].size(); j++){\\n                mp[board[i][j]] = {i, j};\\n            }\\n        }\\n\\n        for(auto ch : target){\\n            int row = mp[ch].first, col = mp[ch].second;\\n\\n            while(row < cur_row){\\n                res += \\'U\\';    // should move up\\n                cur_row--;\\n            }\\n\\n            while(col < cur_col){\\n                res += \\'L\\';    // should move left\\n                cur_col--;\\n            }\\n\\n            while(row > cur_row){\\n                res += \\'D\\';     // should move down\\n                cur_row++;\\n            }\\n\\n            while(col > cur_col){\\n                res += \\'R\\';   // should move right\\n                cur_col++;\\n            }\\n\\n            res += \\'!\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char, pair<int, int>> mp;\\n        string res = \"\";\\n        int cur_row = 0, cur_col = 0;\\n        vector<string> board{{\"abcde\"}, {\"fghij\"}, {\"klmno\"}, {\"pqrst\"}, {\"uvwxy\"}, {\"z\"}};\\n\\n        for(auto i = 0; i < board.size(); i++){\\n            for(auto j = 0; j < board[i].size(); j++){\\n                mp[board[i][j]] = {i, j};\\n            }\\n        }\\n\\n        for(auto ch : target){\\n            int row = mp[ch].first, col = mp[ch].second;\\n\\n            while(row < cur_row){\\n                res += \\'U\\';    // should move up\\n                cur_row--;\\n            }\\n\\n            while(col < cur_col){\\n                res += \\'L\\';    // should move left\\n                cur_col--;\\n            }\\n\\n            while(row > cur_row){\\n                res += \\'D\\';     // should move down\\n                cur_row++;\\n            }\\n\\n            while(col > cur_col){\\n                res += \\'R\\';   // should move right\\n                cur_col++;\\n            }\\n\\n            res += \\'!\\';\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169979,
                "title": "c-0ms-easy-to-understand-solution",
                "content": "\\n# Approach\\n1. Calculate the distance the next letter is from \\'a\\'. We do this since \\'a\\' is at the 0 position on the board. Then, since each row of the board is 5 letters long, the row of the next letter would be this value / 5 due to floor division. The remainder would then be the column. I store these in a pair to resemble coordinates on the board.\\n2. Match the current position that we\\'re at to the position of the next letter and add the moves required to the path. We first look left and right, since if we go up or down, we could end up going off the board if we try to get to z. Up and down subtract/add the row number, left and right the column number.\\n3. There is one special case with this approach, and that is if we\\'re at z and we need to get to a different letter. Since we move left and right first, this would result in us going off the board unless we\\'re going to a letter above z. So we first check if we\\'re at z and we don\\'t need to be there, then move up and continue.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - with n being the length of the target word\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string path;\\n        pair<int,int> currentPos, nextPos = pair(0,0);\\n        int alphabetPos;\\n        for(char c : target) {\\n            alphabetPos = int(c - \\'a\\');\\n            nextPos = pair(alphabetPos/5, alphabetPos % 5);\\n            if(alphabetPos != 25 && currentPos.first == 5) {\\n                path += \\'U\\';\\n                currentPos.first -= 1;\\n            }\\n            while(currentPos.first != nextPos.first || currentPos.second != nextPos.second) {\\n                if(currentPos.second > nextPos.second) {\\n                    path += \\'L\\';\\n                    currentPos.second -= 1;\\n                }\\n                else if (currentPos.second < nextPos.second) {\\n                    path += \\'R\\';\\n                    currentPos.second += 1;\\n                }\\n                else if(currentPos.first > nextPos.first) {\\n                    path += \\'U\\';\\n                    currentPos.first -= 1;\\n                }\\n                else {\\n                    path += \\'D\\';\\n                    currentPos.first += 1;\\n                }\\n            }\\n            path += \"!\";\\n        }\\n        return path;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string path;\\n        pair<int,int> currentPos, nextPos = pair(0,0);\\n        int alphabetPos;\\n        for(char c : target) {\\n            alphabetPos = int(c - \\'a\\');\\n            nextPos = pair(alphabetPos/5, alphabetPos % 5);\\n            if(alphabetPos != 25 && currentPos.first == 5) {\\n                path += \\'U\\';\\n                currentPos.first -= 1;\\n            }\\n            while(currentPos.first != nextPos.first || currentPos.second != nextPos.second) {\\n                if(currentPos.second > nextPos.second) {\\n                    path += \\'L\\';\\n                    currentPos.second -= 1;\\n                }\\n                else if (currentPos.second < nextPos.second) {\\n                    path += \\'R\\';\\n                    currentPos.second += 1;\\n                }\\n                else if(currentPos.first > nextPos.first) {\\n                    path += \\'U\\';\\n                    currentPos.first -= 1;\\n                }\\n                else {\\n                    path += \\'D\\';\\n                    currentPos.first += 1;\\n                }\\n            }\\n            path += \"!\";\\n        }\\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154558,
                "title": "time-o-len-target-space-o-len-target",
                "content": "\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        \\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\tr_prev = 0\\n        c_prev = 0\\n        prev = \\'a\\'\\n        res = []\\n        for c in target:\\n            if c == prev:\\n                res.append(\\'!\\')\\n                continue\\n            \\n            num = ord(c) - ord(\\'a\\')\\n            r_cur = num//5\\n            c_cur = num%5\\n            \\n            if r_prev == 5:\\n                res.append((r_prev - r_cur)*\\'U\\')\\n                if c_cur > 0:\\n                    res.append((c_cur)*\\'R\\')\\n            elif r_cur == 5:\\n                if c_prev > 0:\\n                    res.append(c_prev*\\'L\\')\\n                res.append((r_cur - r_prev)*\\'D\\')\\n            else:\\n                if r_prev > r_cur:\\n                    res.append((r_prev - r_cur)*\\'U\\')\\n                elif r_prev < r_cur:\\n                    res.append((r_cur - r_prev)*\\'D\\')\\n                    \\n                if c_prev > c_cur:\\n                    res.append((c_prev - c_cur)*\\'L\\')\\n                elif c_prev < c_cur:\\n                    res.append((c_cur - c_prev)*\\'R\\')\\n            \\n            res.append(\\'!\\')\\n            prev = c\\n            c_prev = c_cur\\n            r_prev = r_cur\\n            \\n        #print res\\n        return \"\".join(res)\\n            \\n",
                "solutionTags": [],
                "code": "\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        \"\"\"\\n        :type target: str\\n        :rtype: str\\n        \"\"\"\\n        \\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\tr_prev = 0\\n        c_prev = 0\\n        prev = \\'a\\'\\n        res = []\\n        for c in target:\\n            if c == prev:\\n                res.append(\\'!\\')\\n                continue\\n            \\n            num = ord(c) - ord(\\'a\\')\\n            r_cur = num//5\\n            c_cur = num%5\\n            \\n            if r_prev == 5:\\n                res.append((r_prev - r_cur)*\\'U\\')\\n                if c_cur > 0:\\n                    res.append((c_cur)*\\'R\\')\\n            elif r_cur == 5:\\n                if c_prev > 0:\\n                    res.append(c_prev*\\'L\\')\\n                res.append((r_cur - r_prev)*\\'D\\')\\n            else:\\n                if r_prev > r_cur:\\n                    res.append((r_prev - r_cur)*\\'U\\')\\n                elif r_prev < r_cur:\\n                    res.append((r_cur - r_prev)*\\'D\\')\\n                    \\n                if c_prev > c_cur:\\n                    res.append((c_prev - c_cur)*\\'L\\')\\n                elif c_prev < c_cur:\\n                    res.append((c_cur - c_prev)*\\'R\\')\\n            \\n            res.append(\\'!\\')\\n            prev = c\\n            c_prev = c_cur\\n            r_prev = r_cur\\n            \\n        #print res\\n        return \"\".join(res)\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 3152570,
                "title": "simple-java-solution-generalized-number-of-columns",
                "content": "# Code\\n```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int cols = 5;\\n        int rows = (int)Math.ceil(26.0/cols);\\n        char[][] arr = new char[rows][cols];\\n        int count = 0;\\n\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                arr[i][j] = (char)(count+\\'a\\');\\n                count++;\\n                if(count == 26) break;\\n            }\\n            if (count==26) break;\\n        }\\n        for(char[] row : arr) System.out.println(Arrays.toString(row));\\n        StringBuilder sb = new StringBuilder();\\n        int pos = 0;\\n        int r = 0;\\n        int c = 0;\\n        while(pos<target.length()){\\n\\n            char ch = target.charAt(pos);\\n            // System.out.println(arr[r][c]);\\n            if (ch == arr[r][c]){\\n                sb.append(\\'!\\');\\n                pos++;\\n                continue;\\n            }\\n\\n            boolean greater = ch > arr[r][c];\\n            boolean inRange = (arr[r][0]<=ch && ch<=arr[r][cols-1]);\\n\\n            if (inRange && greater) {\\n                c++;\\n                sb.append(\\'R\\');\\n            }\\n\\n            else if(!inRange && greater) {\\n                if (\\'a\\' <= arr[r+1][c] && arr[r+1][c]<= \\'z\\' ) {\\n                    r++;\\n                    sb.append(\\'D\\');\\n                }\\n                else {\\n                    c--;\\n                    sb.append(\\'L\\');\\n                }\\n            }\\n\\n            else if (inRange) {\\n                c--;\\n                sb.append(\\'L\\');\\n            }\\n\\n            else {\\n                r--;\\n                sb.append(\\'U\\');\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        int cols = 5;\\n        int rows = (int)Math.ceil(26.0/cols);\\n        char[][] arr = new char[rows][cols];\\n        int count = 0;\\n\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                arr[i][j] = (char)(count+\\'a\\');\\n                count++;\\n                if(count == 26) break;\\n            }\\n            if (count==26) break;\\n        }\\n        for(char[] row : arr) System.out.println(Arrays.toString(row));\\n        StringBuilder sb = new StringBuilder();\\n        int pos = 0;\\n        int r = 0;\\n        int c = 0;\\n        while(pos<target.length()){\\n\\n            char ch = target.charAt(pos);\\n            // System.out.println(arr[r][c]);\\n            if (ch == arr[r][c]){\\n                sb.append(\\'!\\');\\n                pos++;\\n                continue;\\n            }\\n\\n            boolean greater = ch > arr[r][c];\\n            boolean inRange = (arr[r][0]<=ch && ch<=arr[r][cols-1]);\\n\\n            if (inRange && greater) {\\n                c++;\\n                sb.append(\\'R\\');\\n            }\\n\\n            else if(!inRange && greater) {\\n                if (\\'a\\' <= arr[r+1][c] && arr[r+1][c]<= \\'z\\' ) {\\n                    r++;\\n                    sb.append(\\'D\\');\\n                }\\n                else {\\n                    c--;\\n                    sb.append(\\'L\\');\\n                }\\n            }\\n\\n            else if (inRange) {\\n                c--;\\n                sb.append(\\'L\\');\\n            }\\n\\n            else {\\n                r--;\\n                sb.append(\\'U\\');\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132956,
                "title": "unordered-map-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char,pair<int,int>>m;\\n        char ch=\\'a\\';\\n        for(int i=0;i<26;i++)\\n        {\\n            m[ch]=make_pair(i%5,i/5);\\n            ch++;\\n        }\\n        int ind=0;\\n        int p=0,q=0;\\n        string ans=\"\";\\n        while(ind<target.size())\\n        {\\n            int x=m[target[ind]].first;\\n            //cout<<x;\\n            int y=m[target[ind]].second;\\n            //cout<<y;\\n            while(q>y)\\n            {\\n                q--;\\n                ans.push_back(\\'U\\');\\n            }\\n            while(p>x)\\n            {\\n                p--;\\n                ans.push_back(\\'L\\');\\n            }while(q<y)\\n            {\\n                q++;\\n                ans.push_back(\\'D\\');\\n            }while(p<x)\\n            {\\n                p++;\\n                ans.push_back(\\'R\\');\\n            }\\n            ind++;\\n            ans.push_back(\\'!\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char,pair<int,int>>m;\\n        char ch=\\'a\\';\\n        for(int i=0;i<26;i++)\\n        {\\n            m[ch]=make_pair(i%5,i/5);\\n            ch++;\\n        }\\n        int ind=0;\\n        int p=0,q=0;\\n        string ans=\"\";\\n        while(ind<target.size())\\n        {\\n            int x=m[target[ind]].first;\\n            //cout<<x;\\n            int y=m[target[ind]].second;\\n            //cout<<y;\\n            while(q>y)\\n            {\\n                q--;\\n                ans.push_back(\\'U\\');\\n            }\\n            while(p>x)\\n            {\\n                p--;\\n                ans.push_back(\\'L\\');\\n            }while(q<y)\\n            {\\n                q++;\\n                ans.push_back(\\'D\\');\\n            }while(p<x)\\n            {\\n                p++;\\n                ans.push_back(\\'R\\');\\n            }\\n            ind++;\\n            ans.push_back(\\'!\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3122935,
                "title": "human-readable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst (\\n\\tUP    = \"U\"\\n\\tDOWN  = \"D\"\\n\\tLEFT  = \"L\"\\n\\tRIGHT = \"R\"\\n\\tFOUND = \"!\"\\n)\\n\\nvar (\\n\\tboard map[string][2]int = map[string][2]int{\\n\\t\\t\"a\": {0, 0},\\n\\t\\t\"b\": {0, 1},\\n\\t\\t\"c\": {0, 2},\\n\\t\\t\"d\": {0, 3},\\n\\t\\t\"e\": {0, 4},\\n\\n\\t\\t\"f\": {1, 0},\\n\\t\\t\"g\": {1, 1},\\n\\t\\t\"h\": {1, 2},\\n\\t\\t\"i\": {1, 3},\\n\\t\\t\"j\": {1, 4},\\n\\n\\t\\t\"k\": {2, 0},\\n\\t\\t\"l\": {2, 1},\\n\\t\\t\"m\": {2, 2},\\n\\t\\t\"n\": {2, 3},\\n\\t\\t\"o\": {2, 4},\\n\\n\\t\\t\"p\": {3, 0},\\n\\t\\t\"q\": {3, 1},\\n\\t\\t\"r\": {3, 2},\\n\\t\\t\"s\": {3, 3},\\n\\t\\t\"t\": {3, 4},\\n\\n\\t\\t\"u\": {4, 0},\\n\\t\\t\"v\": {4, 1},\\n\\t\\t\"w\": {4, 2},\\n\\t\\t\"x\": {4, 3},\\n\\t\\t\"y\": {4, 4},\\n\\n\\t\\t\"z\": {5, 0},\\n\\t}\\n)\\n\\nfunc alphabetBoardPath(target string) string {\\n\\tif target == \"\" {\\n\\t\\treturn \"\"\\n\\t}\\n\\n\\tbuilder := strings.Builder{}\\n\\tposition := [2]int{0, 0}\\n\\n\\tfor _, v := range target {\\n\\t\\tletter := string(v)\\n\\t\\tletterPosition := board[letter]\\n\\n\\t\\trowGap, columnGap := letterPosition[0]-position[0], letterPosition[1]-position[1]\\n\\n        if rowGap == 0 && columnGap == 0 {\\n            builder.WriteString(FOUND)\\n            continue\\n        }\\n\\n\\t\\tif letter == \"z\" {\\n\\t\\t\\trowGap -= 1\\n\\t\\t}\\n\\n\\t\\tswitch {\\n\\t\\tcase rowGap > 0:\\n\\t\\t\\tfor i := 0; i < rowGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(DOWN)\\n\\t\\t\\t}\\n\\t\\tcase rowGap < 0:\\n\\t\\t\\trowGap *= -1\\n\\t\\t\\tfor i := 0; i < rowGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(UP)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tswitch {\\n\\t\\tcase columnGap > 0:\\n\\t\\t\\tfor i := 0; i < columnGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(RIGHT)\\n\\t\\t\\t}\\n\\t\\tcase columnGap < 0:\\n\\t\\t\\tcolumnGap *= -1\\n\\t\\t\\tfor i := 0; i < columnGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(LEFT)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif string(v) == \"z\" {\\n\\t\\t\\tbuilder.WriteString(DOWN)\\n\\t\\t}\\n\\n\\t\\tbuilder.WriteString(FOUND)\\n\\n\\t\\tposition[0], position[1] = letterPosition[0], letterPosition[1]\\n\\t}\\n\\n\\treturn builder.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nconst (\\n\\tUP    = \"U\"\\n\\tDOWN  = \"D\"\\n\\tLEFT  = \"L\"\\n\\tRIGHT = \"R\"\\n\\tFOUND = \"!\"\\n)\\n\\nvar (\\n\\tboard map[string][2]int = map[string][2]int{\\n\\t\\t\"a\": {0, 0},\\n\\t\\t\"b\": {0, 1},\\n\\t\\t\"c\": {0, 2},\\n\\t\\t\"d\": {0, 3},\\n\\t\\t\"e\": {0, 4},\\n\\n\\t\\t\"f\": {1, 0},\\n\\t\\t\"g\": {1, 1},\\n\\t\\t\"h\": {1, 2},\\n\\t\\t\"i\": {1, 3},\\n\\t\\t\"j\": {1, 4},\\n\\n\\t\\t\"k\": {2, 0},\\n\\t\\t\"l\": {2, 1},\\n\\t\\t\"m\": {2, 2},\\n\\t\\t\"n\": {2, 3},\\n\\t\\t\"o\": {2, 4},\\n\\n\\t\\t\"p\": {3, 0},\\n\\t\\t\"q\": {3, 1},\\n\\t\\t\"r\": {3, 2},\\n\\t\\t\"s\": {3, 3},\\n\\t\\t\"t\": {3, 4},\\n\\n\\t\\t\"u\": {4, 0},\\n\\t\\t\"v\": {4, 1},\\n\\t\\t\"w\": {4, 2},\\n\\t\\t\"x\": {4, 3},\\n\\t\\t\"y\": {4, 4},\\n\\n\\t\\t\"z\": {5, 0},\\n\\t}\\n)\\n\\nfunc alphabetBoardPath(target string) string {\\n\\tif target == \"\" {\\n\\t\\treturn \"\"\\n\\t}\\n\\n\\tbuilder := strings.Builder{}\\n\\tposition := [2]int{0, 0}\\n\\n\\tfor _, v := range target {\\n\\t\\tletter := string(v)\\n\\t\\tletterPosition := board[letter]\\n\\n\\t\\trowGap, columnGap := letterPosition[0]-position[0], letterPosition[1]-position[1]\\n\\n        if rowGap == 0 && columnGap == 0 {\\n            builder.WriteString(FOUND)\\n            continue\\n        }\\n\\n\\t\\tif letter == \"z\" {\\n\\t\\t\\trowGap -= 1\\n\\t\\t}\\n\\n\\t\\tswitch {\\n\\t\\tcase rowGap > 0:\\n\\t\\t\\tfor i := 0; i < rowGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(DOWN)\\n\\t\\t\\t}\\n\\t\\tcase rowGap < 0:\\n\\t\\t\\trowGap *= -1\\n\\t\\t\\tfor i := 0; i < rowGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(UP)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tswitch {\\n\\t\\tcase columnGap > 0:\\n\\t\\t\\tfor i := 0; i < columnGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(RIGHT)\\n\\t\\t\\t}\\n\\t\\tcase columnGap < 0:\\n\\t\\t\\tcolumnGap *= -1\\n\\t\\t\\tfor i := 0; i < columnGap; i++ {\\n\\t\\t\\t\\tbuilder.WriteString(LEFT)\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif string(v) == \"z\" {\\n\\t\\t\\tbuilder.WriteString(DOWN)\\n\\t\\t}\\n\\n\\t\\tbuilder.WriteString(FOUND)\\n\\n\\t\\tposition[0], position[1] = letterPosition[0], letterPosition[1]\\n\\t}\\n\\n\\treturn builder.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3120257,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        \\n        HashMap<Character,int[]> hm = new HashMap<Character,int[]>();\\n        {\\n            int num = 97;\\n            for(int i=0; i<5; i++){\\n                for(int j=0; j<5; j++){\\n                    int n = num;\\n                    int[] arr = {i,j};\\n                    hm.put( (char)n, arr );\\n                    num++;\\n                }\\n            }\\n            \\n            int n = num;\\n            int[] arr = {5,0};\\n            hm.put( (char)n, arr);\\n            // hm.forEach((key, value) -> {\\n            //     System.out.print(key + \" = [\" + value[0] +\",\"+value[1]+\"]\");\\n            //     });\\n        }\\n        {\\n        \\tString output = \"\";\\n\\t        int currentpos[] = {0,0};\\n\\t        for(int i=0; i<target.length(); i++){\\n\\t            int[] targetpos = hm.get(target.charAt(i));\\n\\t            while( true ){\\n\\t                if(targetpos[0] < currentpos[0]){\\n\\t                    currentpos[0] = currentpos[0] - 1;\\n\\t                    output = output + \"U\";\\n\\t                }else if( (targetpos[0] > currentpos[0]) && (currentpos[0] != 4 || currentpos[1] == 0) ){\\n\\t                    currentpos[0] = currentpos[0] + 1;\\n\\t                    output = output + \"D\";\\n\\t                }else if( (targetpos[0] == currentpos[0]) || (currentpos[0] == 4) ){\\n\\t                    if(targetpos[1] < currentpos[1]){\\n\\t                        currentpos[1] = currentpos[1] - 1;\\n\\t                        output = output + \"L\";\\n\\t                    }else if( (targetpos[1] > currentpos[1]) && (currentpos[0] != 5)){\\n\\t                        currentpos[1] = currentpos[1] + 1;\\n\\t                        output = output + \"R\";\\n\\t                    }else if( (targetpos[1] == currentpos[1]) && (targetpos[0] == currentpos[0]) ){\\n\\t                        output = output + \"!\";\\n\\t                        break;\\n\\t                    }\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        return output;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public String alphabetBoardPath(String target) {\\n        \\n        HashMap<Character,int[]> hm = new HashMap<Character,int[]>();\\n        {\\n            int num = 97;\\n            for(int i=0; i<5; i++){\\n                for(int j=0; j<5; j++){\\n                    int n = num;\\n                    int[] arr = {i,j};\\n                    hm.put( (char)n, arr );\\n                    num++;\\n                }\\n            }\\n            \\n            int n = num;\\n            int[] arr = {5,0};\\n            hm.put( (char)n, arr);\\n            // hm.forEach((key, value) -> {\\n            //     System.out.print(key + \" = [\" + value[0] +\",\"+value[1]+\"]\");\\n            //     });\\n        }\\n        {\\n        \\tString output = \"\";\\n\\t        int currentpos[] = {0,0};\\n\\t        for(int i=0; i<target.length(); i++){\\n\\t            int[] targetpos = hm.get(target.charAt(i));\\n\\t            while( true ){\\n\\t                if(targetpos[0] < currentpos[0]){\\n\\t                    currentpos[0] = currentpos[0] - 1;\\n\\t                    output = output + \"U\";\\n\\t                }else if( (targetpos[0] > currentpos[0]) && (currentpos[0] != 4 || currentpos[1] == 0) ){\\n\\t                    currentpos[0] = currentpos[0] + 1;\\n\\t                    output = output + \"D\";\\n\\t                }else if( (targetpos[0] == currentpos[0]) || (currentpos[0] == 4) ){\\n\\t                    if(targetpos[1] < currentpos[1]){\\n\\t                        currentpos[1] = currentpos[1] - 1;\\n\\t                        output = output + \"L\";\\n\\t                    }else if( (targetpos[1] > currentpos[1]) && (currentpos[0] != 5)){\\n\\t                        currentpos[1] = currentpos[1] + 1;\\n\\t                        output = output + \"R\";\\n\\t                    }else if( (targetpos[1] == currentpos[1]) && (targetpos[0] == currentpos[0]) ){\\n\\t                        output = output + \"!\";\\n\\t                        break;\\n\\t                    }\\n\\t                }\\n\\t            }\\n\\t        }\\n\\t        return output;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119644,
                "title": "binary-search-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public static int[] bsearch(char[][] board, char ch) {\\n        int x = 0;\\n        int y = board[0].length-1;\\n        if(ch == \\'z\\') \\n            return new int[]{5, 0};\\n        while(true){\\n            if (board[x][y]==ch)\\n                return new int[]{x, y};\\n            if (board[x][y] < ch) \\n                x++;\\n            else \\n                y--;\\n        }\\n    }\\n    public static String alphabetBoardPath(String target) {\\n        char[][] board = {\\n\\t\\t\\t\\t{\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n                {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n                {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n\\t\\t\\t\\t{\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n                {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n                {\\'z\\'}\\n\\t\\t\\t\\t};\\n        StringBuilder res = new StringBuilder();\\n        int x = 0, y = 0;\\n        for (char c:target.toCharArray()) {\\n            int[] pos = bsearch(board, c);\\n            boolean isZ= false;\\n            while(pos[0] != x) {\\n                if (pos[0] > x) {\\n                    x++;\\n                    if (x == 5) {\\n                        isZ = true;\\n                        break;\\n                    }\\n                    res.append(\"D\");\\n                } else {\\n                    x--;\\n                    res.append(\"U\");\\n                }\\n                isZ = false;\\n            }\\n            while(pos[1] != y) {\\n                if (pos[1] > y) {\\n                    y++;\\n                    res.append(\"R\");\\n                } else {\\n                    y--;\\n                    res.append(\"L\");\\n                }\\n            }\\n            if(isZ) \\n                res.append(\"D\");\\n            res.append(\"!\");\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static int[] bsearch(char[][] board, char ch) {\\n        int x = 0;\\n        int y = board[0].length-1;\\n        if(ch == \\'z\\') \\n            return new int[]{5, 0};\\n        while(true){\\n            if (board[x][y]==ch)\\n                return new int[]{x, y};\\n            if (board[x][y] < ch) \\n                x++;\\n            else \\n                y--;\\n        }\\n    }\\n    public static String alphabetBoardPath(String target) {\\n        char[][] board = {\\n\\t\\t\\t\\t{\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n                {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n                {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n\\t\\t\\t\\t{\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n                {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n                {\\'z\\'}\\n\\t\\t\\t\\t};\\n        StringBuilder res = new StringBuilder();\\n        int x = 0, y = 0;\\n        for (char c:target.toCharArray()) {\\n            int[] pos = bsearch(board, c);\\n            boolean isZ= false;\\n            while(pos[0] != x) {\\n                if (pos[0] > x) {\\n                    x++;\\n                    if (x == 5) {\\n                        isZ = true;\\n                        break;\\n                    }\\n                    res.append(\"D\");\\n                } else {\\n                    x--;\\n                    res.append(\"U\");\\n                }\\n                isZ = false;\\n            }\\n            while(pos[1] != y) {\\n                if (pos[1] > y) {\\n                    y++;\\n                    res.append(\"R\");\\n                } else {\\n                    y--;\\n                    res.append(\"L\");\\n                }\\n            }\\n            if(isZ) \\n                res.append(\"D\");\\n            res.append(\"!\");\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119642,
                "title": "binary-search-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public static int[] bsearch(char[][] board, char ch) {\\n        int x = 0;\\n        int y = board[0].length-1;\\n        if(ch == \\'z\\') \\n            return new int[]{5, 0};\\n        while(true){\\n            if (board[x][y]==ch)\\n                return new int[]{x, y};\\n            if (board[x][y] < ch) \\n                x++;\\n            else \\n                y--;\\n        }\\n    }\\n    public static String alphabetBoardPath(String target) {\\n        char[][] board = {\\n\\t\\t\\t\\t{\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n                {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n                {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n\\t\\t\\t\\t{\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n                {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n                {\\'z\\'}\\n\\t\\t\\t\\t};\\n        StringBuilder res = new StringBuilder();\\n        int x = 0, y = 0;\\n        for (char c:target.toCharArray()) {\\n            int[] pos = bsearch(board, c);\\n            boolean isZ= false;\\n            while(pos[0] != x) {\\n                if (pos[0] > x) {\\n                    x++;\\n                    if (x == 5) {\\n                        isZ = true;\\n                        break;\\n                    }\\n                    res.append(\"D\");\\n                } else {\\n                    x--;\\n                    res.append(\"U\");\\n                }\\n                isZ = false;\\n            }\\n            while(pos[1] != y) {\\n                if (pos[1] > y) {\\n                    y++;\\n                    res.append(\"R\");\\n                } else {\\n                    y--;\\n                    res.append(\"L\");\\n                }\\n            }\\n            if(isZ) \\n                res.append(\"D\");\\n            res.append(\"!\");\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static int[] bsearch(char[][] board, char ch) {\\n        int x = 0;\\n        int y = board[0].length-1;\\n        if(ch == \\'z\\') \\n            return new int[]{5, 0};\\n        while(true){\\n            if (board[x][y]==ch)\\n                return new int[]{x, y};\\n            if (board[x][y] < ch) \\n                x++;\\n            else \\n                y--;\\n        }\\n    }\\n    public static String alphabetBoardPath(String target) {\\n        char[][] board = {\\n\\t\\t\\t\\t{\\'a\\', \\'b\\', \\'c\\', \\'d\\', \\'e\\'},\\n                {\\'f\\', \\'g\\', \\'h\\', \\'i\\', \\'j\\'},\\n                {\\'k\\', \\'l\\', \\'m\\', \\'n\\', \\'o\\'},\\n\\t\\t\\t\\t{\\'p\\', \\'q\\', \\'r\\', \\'s\\', \\'t\\'},\\n                {\\'u\\', \\'v\\', \\'w\\', \\'x\\', \\'y\\'},\\n                {\\'z\\'}\\n\\t\\t\\t\\t};\\n        StringBuilder res = new StringBuilder();\\n        int x = 0, y = 0;\\n        for (char c:target.toCharArray()) {\\n            int[] pos = bsearch(board, c);\\n            boolean isZ= false;\\n            while(pos[0] != x) {\\n                if (pos[0] > x) {\\n                    x++;\\n                    if (x == 5) {\\n                        isZ = true;\\n                        break;\\n                    }\\n                    res.append(\"D\");\\n                } else {\\n                    x--;\\n                    res.append(\"U\");\\n                }\\n                isZ = false;\\n            }\\n            while(pos[1] != y) {\\n                if (pos[1] > y) {\\n                    y++;\\n                    res.append(\"R\");\\n                } else {\\n                    y--;\\n                    res.append(\"L\");\\n                }\\n            }\\n            if(isZ) \\n                res.append(\"D\");\\n            res.append(\"!\");\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119485,
                "title": "easy-solution-user-freindly-hashtable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n 1> HASHMAP\\n 2> check every char from string and find the position of intialy char \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHASHMAP\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target)\\n    {\\n         map<char,pair<int,int>>mp;\\n         char ch=\\'a\\';\\n         for (int i=0;i<5;i++)\\n         {\\n             for (int j=0;j<5;j++)\\n             {\\n                 mp[ch]={i,j};\\n                 ch++;\\n             }\\n         }\\n         mp[ch]={5,0};\\n         int n=target.size();\\n         string ans=\"\";\\n         int x=0;\\n         int y=0;\\n         for (int i=0;i<n;i++)\\n         {\\n            int x1=mp[target[i]].first;\\n            int y1=mp[target[i]].second;\\n           \\n             while(y>y1)\\n            {\\n                y--;\\n                ans+=\"L\";\\n            }\\n\\n             while(x<x1)\\n            {\\n                x++;\\n                ans+=\"D\";\\n            }\\n            while(x>x1)\\n            {\\n                x--;\\n                ans+=\"U\";\\n            }\\n             while(y<y1)\\n            {\\n                y++;\\n                ans+=\"R\";\\n            }\\n            \\n            ans+=\"!\";\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target)\\n    {\\n         map<char,pair<int,int>>mp;\\n         char ch=\\'a\\';\\n         for (int i=0;i<5;i++)\\n         {\\n             for (int j=0;j<5;j++)\\n             {\\n                 mp[ch]={i,j};\\n                 ch++;\\n             }\\n         }\\n         mp[ch]={5,0};\\n         int n=target.size();\\n         string ans=\"\";\\n         int x=0;\\n         int y=0;\\n         for (int i=0;i<n;i++)\\n         {\\n            int x1=mp[target[i]].first;\\n            int y1=mp[target[i]].second;\\n           \\n             while(y>y1)\\n            {\\n                y--;\\n                ans+=\"L\";\\n            }\\n\\n             while(x<x1)\\n            {\\n                x++;\\n                ans+=\"D\";\\n            }\\n            while(x>x1)\\n            {\\n                x--;\\n                ans+=\"U\";\\n            }\\n             while(y<y1)\\n            {\\n                y++;\\n                ans+=\"R\";\\n            }\\n            \\n            ans+=\"!\";\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119429,
                "title": "python3-clean-code-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        res=\\'\\'\\n        a,b=0,0\\n\\n        for i in range(len(target)):\\n            m=(ord(target[i])-97)//5\\n            n=(ord(target[i])-97)%5\\n            \\n            if a>=m: res+=abs(a-m)*\\'U\\'\\n            if b>=n: res+=abs(b-n)*\\'L\\'\\n            if a<=m: res+=abs(a-m)*\\'D\\'\\n            if b<=n: res+=abs(b-n)*\\'R\\'\\n\\n            a,b=m,n\\n            res+=\\'!\\'\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def alphabetBoardPath(self, target):\\n        board = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\\n        res=\\'\\'\\n        a,b=0,0\\n\\n        for i in range(len(target)):\\n            m=(ord(target[i])-97)//5\\n            n=(ord(target[i])-97)%5\\n            \\n            if a>=m: res+=abs(a-m)*\\'U\\'\\n            if b>=n: res+=abs(b-n)*\\'L\\'\\n            if a<=m: res+=abs(a-m)*\\'D\\'\\n            if b<=n: res+=abs(b-n)*\\'R\\'\\n\\n            a,b=m,n\\n            res+=\\'!\\'\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119184,
                "title": "coordinate-geometry-approach",
                "content": "# Intuition\\nLooked similar to a coordinate geometry problem\\n\\n# Approach\\nFirst I wrote another function to calculate the direction vector (x, y) at which we would have to *\"travel\"* from letter to letter on our *\"graph\"* with left-right being +ve and bottom-up +ve.\\n\\nNext we have to account for the last row containing \\'Z\\' as our *\"graph\"* effectively isn\\'t a quadlilateral by altering the **calculate_length** function to return a list containing multiple movement directions;\\nIf traveling to *\\'Z\\'*, we add a final (0, -1) vector and subtract 1 from the first direction vector\\'s Y, and viec versa.\\n\\nNow we loop over the target and return our result.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n  board = [\\n    \"abcde\",\\n    \"fghij\",\\n    \"klmno\",\\n    \"pqrst\",\\n    \"uvwxy\",\\n    \"z\"\\n  ]\\n\\n  def calculate_length(self, letter_1: str, letter_2: str) -> list:\\n    coords = {\\n      \\'from\\': [], # (x,y)\\n      \\'to\\': []\\n    }\\n\\n    if letter_1 == letter_2: return [[0,0]]\\n\\n    for y, data in enumerate(self.board):\\n      try:\\n        x = data.index(letter_1)\\n        coords[\\'from\\'] = [x, y + 1]\\n      except: pass\\n      try:\\n        x = data.index(letter_2)\\n        coords[\\'to\\'] = [x, y + 1]\\n      except: pass\\n\\n    direction_vector = [[\\n      coords[\\'to\\'][0] - coords[\\'from\\'][0],\\n      coords[\\'from\\'][1] - coords[\\'to\\'][1]\\n    ]]\\n\\n    if letter_1 == \\'z\\':\\n      direction_vector.insert(0, [0, 1])\\n      direction_vector[1][1] -= 1\\n    elif letter_2 == \\'z\\':\\n      direction_vector.insert(1, [0, -1])\\n      direction_vector[0][1] += 1\\n\\n    return direction_vector\\n\\n  def alphabetBoardPath(self, target: str) -> str:\\n    result = \\'\\'\\n\\n    previous = \\'a\\'\\n    for letter in target:\\n      coords = self.calculate_length(previous, letter)\\n\\n      for coord in coords:\\n        #Handle Y-axis\\n        if coord[1] > 0: result += \\'U\\'*coord[1]\\n        elif coord[1] < 0: result += \\'D\\'*abs(coord[1])\\n\\n        #Handle X-axis\\n        if coord[0] > 0: result += \\'R\\'*coord[0]\\n        elif coord[0] < 0: result += \\'L\\'*abs(coord[0])\\n\\n      result += \\'!\\'\\n      previous = letter\\n\\n    return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n  board = [\\n    \"abcde\",\\n    \"fghij\",\\n    \"klmno\",\\n    \"pqrst\",\\n    \"uvwxy\",\\n    \"z\"\\n  ]\\n\\n  def calculate_length(self, letter_1: str, letter_2: str) -> list:\\n    coords = {\\n      \\'from\\': [], # (x,y)\\n      \\'to\\': []\\n    }\\n\\n    if letter_1 == letter_2: return [[0,0]]\\n\\n    for y, data in enumerate(self.board):\\n      try:\\n        x = data.index(letter_1)\\n        coords[\\'from\\'] = [x, y + 1]\\n      except: pass\\n      try:\\n        x = data.index(letter_2)\\n        coords[\\'to\\'] = [x, y + 1]\\n      except: pass\\n\\n    direction_vector = [[\\n      coords[\\'to\\'][0] - coords[\\'from\\'][0],\\n      coords[\\'from\\'][1] - coords[\\'to\\'][1]\\n    ]]\\n\\n    if letter_1 == \\'z\\':\\n      direction_vector.insert(0, [0, 1])\\n      direction_vector[1][1] -= 1\\n    elif letter_2 == \\'z\\':\\n      direction_vector.insert(1, [0, -1])\\n      direction_vector[0][1] += 1\\n\\n    return direction_vector\\n\\n  def alphabetBoardPath(self, target: str) -> str:\\n    result = \\'\\'\\n\\n    previous = \\'a\\'\\n    for letter in target:\\n      coords = self.calculate_length(previous, letter)\\n\\n      for coord in coords:\\n        #Handle Y-axis\\n        if coord[1] > 0: result += \\'U\\'*coord[1]\\n        elif coord[1] < 0: result += \\'D\\'*abs(coord[1])\\n\\n        #Handle X-axis\\n        if coord[0] > 0: result += \\'R\\'*coord[0]\\n        elif coord[0] < 0: result += \\'L\\'*abs(coord[0])\\n\\n      result += \\'!\\'\\n      previous = letter\\n\\n    return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118745,
                "title": "c-solution-easy-method-runtime-0ms",
                "content": "# Intuition\\nAs we see, a fixed table is given which will be used to solve all the strings. Therefore my first thought was to create a hash table for all characters from \"a\" (97) to \"z\" (123).\\n\\n# Approach\\nFirst we create a hash table for all the characters. Then using appropriate if else statements we construct an algo to traverse through the table. \\nKeeping in mind, when we reach \"z\" we should first go up, then continue traversing sideways, as traversing left or right would be invalid.\\n\\n# Complexity\\n- Time complexity:\\nO(5*6 + (length of string))\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        map<int, pair<int, int>> mapp;\\n        int ind = 0; bool check = false;\\n        pair<int, int> curr(0, 0); string ans;\\n\\n        for(int i=0; i<6; i++){\\n            for(int j=0; j<5; j++){\\n                ind = i*5 + j + \\'a\\';\\n                if(ind-\\'a\\' > 25){\\n                    check = true;\\n                    break;\\n                }\\n                mapp.insert({ind, {i, j}});\\n            }\\n            if(check)\\n            break;\\n        }\\n\\n        for(auto &it: target){\\n\\n            if((mapp[it].first == curr.first) && (mapp[it].second == curr.second)){\\n                ans.push_back(\\'!\\');\\n                continue;\\n            }\\n            if(curr.first == 5){\\n                ans.push_back(\\'U\\');\\n                curr.first--;\\n            }\\n\\n            int y = abs(mapp[it].first-curr.first); int x = abs(mapp[it].second-curr.second);\\n            if(mapp[it].second > curr.second){\\n                while(x--){\\n                curr.second++;\\n                ans.push_back(\\'R\\');}\\n            }else if(mapp[it].second < curr.second){\\n                while(x--){\\n                curr.second--;\\n                ans.push_back(\\'L\\');}\\n            }\\n\\n            if(mapp[it].first > curr.first){\\n                while(y--){\\n                curr.first++;\\n                ans.push_back(\\'D\\');}\\n            }else if(mapp[it].first < curr.first){\\n                while(y--){\\n                curr.first--;\\n                ans.push_back(\\'U\\');}\\n            }\\n\\n            ans.push_back(\\'!\\');\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        map<int, pair<int, int>> mapp;\\n        int ind = 0; bool check = false;\\n        pair<int, int> curr(0, 0); string ans;\\n\\n        for(int i=0; i<6; i++){\\n            for(int j=0; j<5; j++){\\n                ind = i*5 + j + \\'a\\';\\n                if(ind-\\'a\\' > 25){\\n                    check = true;\\n                    break;\\n                }\\n                mapp.insert({ind, {i, j}});\\n            }\\n            if(check)\\n            break;\\n        }\\n\\n        for(auto &it: target){\\n\\n            if((mapp[it].first == curr.first) && (mapp[it].second == curr.second)){\\n                ans.push_back(\\'!\\');\\n                continue;\\n            }\\n            if(curr.first == 5){\\n                ans.push_back(\\'U\\');\\n                curr.first--;\\n            }\\n\\n            int y = abs(mapp[it].first-curr.first); int x = abs(mapp[it].second-curr.second);\\n            if(mapp[it].second > curr.second){\\n                while(x--){\\n                curr.second++;\\n                ans.push_back(\\'R\\');}\\n            }else if(mapp[it].second < curr.second){\\n                while(x--){\\n                curr.second--;\\n                ans.push_back(\\'L\\');}\\n            }\\n\\n            if(mapp[it].first > curr.first){\\n                while(y--){\\n                curr.first++;\\n                ans.push_back(\\'D\\');}\\n            }else if(mapp[it].first < curr.first){\\n                while(y--){\\n                curr.first--;\\n                ans.push_back(\\'U\\');}\\n            }\\n\\n            ans.push_back(\\'!\\');\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118624,
                "title": "readable-c-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)     (size of string ans)\\n\\n- Space complexity:\\nO(n)    (for loop)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans ; \\n        pair <int,int> current {0,0}; \\n        pair <int,int>next ;\\n        for(int  i = 0 ; i < target.length() ; i++)\\n        {\\n            int m = target[i] - 97 ;\\n            next.first = (m/5) ; //row\\n            next.second = m % 5 ; //column \\n            if(target[i]==\\'z\\')\\n            {\\n                for(int i= 0 ; i < (-1*(current.first-next.first))-1; i++)\\n                ans.push_back(\\'D\\');\\n                \\n                for(int i= 0 ; i < (current.second-next.second); i++)\\n                    ans.push_back(\\'L\\');  \\n                \\n                if((-1*(current.first-next.first))-1 >=0)\\n                ans.push_back(\\'D\\');\\n\\n            }\\n            else \\n            {\\n                if((current.first - next.first) < 0 )\\n                for(int i= 0 ; i < -1*(current.first-next.first); i++)\\n                ans.push_back(\\'D\\');\\n                else\\n                    for(int i= 0 ; i < (current.first-next.first); i++)\\n                    ans.push_back(\\'U\\');\\n                if(current.second-next.second < 0 )\\n                    for(int i= 0 ; i < -1*(current.second-next.second); i++)\\n                    ans.push_back(\\'R\\');\\n                else\\n                    for(int i= 0 ; i < (current.second-next.second); i++)\\n                    ans.push_back(\\'L\\');\\n            }\\n            \\n            ans.push_back(\\'!\\');\\n            current.first = next.first ; \\n            current.second = next.second ;\\n        }\\n    return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans ; \\n        pair <int,int> current {0,0}; \\n        pair <int,int>next ;\\n        for(int  i = 0 ; i < target.length() ; i++)\\n        {\\n            int m = target[i] - 97 ;\\n            next.first = (m/5) ; //row\\n            next.second = m % 5 ; //column \\n            if(target[i]==\\'z\\')\\n            {\\n                for(int i= 0 ; i < (-1*(current.first-next.first))-1; i++)\\n                ans.push_back(\\'D\\');\\n                \\n                for(int i= 0 ; i < (current.second-next.second); i++)\\n                    ans.push_back(\\'L\\');  \\n                \\n                if((-1*(current.first-next.first))-1 >=0)\\n                ans.push_back(\\'D\\');\\n\\n            }\\n            else \\n            {\\n                if((current.first - next.first) < 0 )\\n                for(int i= 0 ; i < -1*(current.first-next.first); i++)\\n                ans.push_back(\\'D\\');\\n                else\\n                    for(int i= 0 ; i < (current.first-next.first); i++)\\n                    ans.push_back(\\'U\\');\\n                if(current.second-next.second < 0 )\\n                    for(int i= 0 ; i < -1*(current.second-next.second); i++)\\n                    ans.push_back(\\'R\\');\\n                else\\n                    for(int i= 0 ; i < (current.second-next.second); i++)\\n                    ans.push_back(\\'L\\');\\n            }\\n            \\n            ans.push_back(\\'!\\');\\n            current.first = next.first ; \\n            current.second = next.second ;\\n        }\\n    return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118412,
                "title": "c-runtime-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI am beginner,and use Brute force approach!\\n# Focal Point\\n<!-- Describe your approach to solving the problem. -->\\nSolve the \\'z\\' case ....\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string res=\"\";\\n        int col=0;\\n        int row=0;\\n        char pre=\\'a\\';\\n        for(int i=0;i<target.length();i++){\\n            int n_row=(target[i]-\\'a\\')/5;\\n            int n_col=(target[i]-\\'a\\')%5;\\n            if(pre==\\'z\\'){\\n                if(n_row>row){\\n                    res+=\\'U\\';\\n                    row++;\\n                }\\n            }\\n            if(target[i]==\\'z\\'){\\n                while(n_col<col){\\n                    col--;\\n                    res+=\\'L\\';\\n                }\\n            }\\n            while(n_row!=row){\\n                if(n_row>row){\\n                    row++;\\n                    res+=\\'D\\';\\n                }\\n                else if(n_row<row){\\n                    row--;\\n                    res+=\\'U\\';\\n                }\\n            }\\n            while(n_col!=col){\\n                if(n_col>col){\\n                    col++;\\n                    res+=\\'R\\';\\n                }\\n                else if(n_col<col){\\n                    col--;\\n                    res+=\\'L\\';\\n                }\\n            }\\n            res+=\\'!\\';\\n            pre=target[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string res=\"\";\\n        int col=0;\\n        int row=0;\\n        char pre=\\'a\\';\\n        for(int i=0;i<target.length();i++){\\n            int n_row=(target[i]-\\'a\\')/5;\\n            int n_col=(target[i]-\\'a\\')%5;\\n            if(pre==\\'z\\'){\\n                if(n_row>row){\\n                    res+=\\'U\\';\\n                    row++;\\n                }\\n            }\\n            if(target[i]==\\'z\\'){\\n                while(n_col<col){\\n                    col--;\\n                    res+=\\'L\\';\\n                }\\n            }\\n            while(n_row!=row){\\n                if(n_row>row){\\n                    row++;\\n                    res+=\\'D\\';\\n                }\\n                else if(n_row<row){\\n                    row--;\\n                    res+=\\'U\\';\\n                }\\n            }\\n            while(n_col!=col){\\n                if(n_col>col){\\n                    col++;\\n                    res+=\\'R\\';\\n                }\\n                else if(n_col<col){\\n                    col--;\\n                    res+=\\'L\\';\\n                }\\n            }\\n            res+=\\'!\\';\\n            pre=target[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118220,
                "title": "c-implementation-based-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<char>> grid = \\n    {\\n        {\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'},\\n        {\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'},\\n        {\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'},\\n        {\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'},\\n        {\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'},\\n        {\\'z\\',\\'1\\',\\'1\\',\\'1\\',\\'1\\'}\\n    };\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char,pair<int,int>> charPos;\\n        char tmp = \\'a\\';\\n        for(int i=0;i<=4;i++)\\n        {\\n            for(int j=0;j<=4;j++)\\n            {\\n                charPos[tmp] = {i,j};\\n                tmp++;\\n            }\\n        }\\n        charPos[\\'z\\'] = {5,0};\\n        string ans=\"\";\\n        int prevR = 0,prevC = 0;\\n        for(auto i:target)\\n        {\\n            int r = charPos[i].first;\\n            int c = charPos[i].second;\\n            if(i==\\'z\\')\\n            {\\n                if(prevC==c)\\n                {\\n                    for(int k=prevR;k<r;k++)\\n                    ans+=\\'D\\';\\n                    prevR = r;\\n                }\\n                if(prevC>c)\\n                {\\n                    for(int k=c;k<prevC;k++)\\n                    ans+=\\'L\\';\\n                    prevC=c;\\n                }\\n                \\n                for(int k=prevR;k<r;k++)\\n                {\\n                    ans+=\\'D\\';\\n                    prevR = r;\\n                }\\n                ans+=\\'!\\';\\n                continue;\\n            }\\n            else if(prevR==5)\\n            {\\n                if(r<prevR)\\n                {\\n                    for(int k=r;k<prevR;k++)\\n                    ans+=\\'U\\';\\n                    prevR = r;\\n                }\\n                if(c>prevC)\\n                {\\n                    for(int k=prevC;k<c;k++)\\n                    ans+=\\'R\\';\\n                    prevC = c;\\n                }\\n                ans+=\\'!\\';\\n                continue;\\n            }\\n            if(r>prevR)\\n            {\\n                for(int k=prevR;k<r;k++)\\n                ans+=\\'D\\';\\n                prevR = r;\\n            }\\n            if(r<prevR)\\n            {\\n                for(int k=r;k<prevR;k++)\\n                ans+=\\'U\\';\\n                prevR = r;\\n            }\\n            if(c>prevC)\\n            {\\n                for(int k=prevC;k<c;k++)\\n                ans+=\\'R\\';\\n                prevC = c;\\n            }\\n            if(c<prevC)\\n            {\\n                for(int k=c;k<prevC;k++)\\n                ans+=\\'L\\';\\n                prevC = c;\\n            }\\n            ans+=\\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<char>> grid = \\n    {\\n        {\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\'},\\n        {\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\'},\\n        {\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\'},\\n        {\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\'},\\n        {\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\'},\\n        {\\'z\\',\\'1\\',\\'1\\',\\'1\\',\\'1\\'}\\n    };\\n    string alphabetBoardPath(string target) {\\n        unordered_map<char,pair<int,int>> charPos;\\n        char tmp = \\'a\\';\\n        for(int i=0;i<=4;i++)\\n        {\\n            for(int j=0;j<=4;j++)\\n            {\\n                charPos[tmp] = {i,j};\\n                tmp++;\\n            }\\n        }\\n        charPos[\\'z\\'] = {5,0};\\n        string ans=\"\";\\n        int prevR = 0,prevC = 0;\\n        for(auto i:target)\\n        {\\n            int r = charPos[i].first;\\n            int c = charPos[i].second;\\n            if(i==\\'z\\')\\n            {\\n                if(prevC==c)\\n                {\\n                    for(int k=prevR;k<r;k++)\\n                    ans+=\\'D\\';\\n                    prevR = r;\\n                }\\n                if(prevC>c)\\n                {\\n                    for(int k=c;k<prevC;k++)\\n                    ans+=\\'L\\';\\n                    prevC=c;\\n                }\\n                \\n                for(int k=prevR;k<r;k++)\\n                {\\n                    ans+=\\'D\\';\\n                    prevR = r;\\n                }\\n                ans+=\\'!\\';\\n                continue;\\n            }\\n            else if(prevR==5)\\n            {\\n                if(r<prevR)\\n                {\\n                    for(int k=r;k<prevR;k++)\\n                    ans+=\\'U\\';\\n                    prevR = r;\\n                }\\n                if(c>prevC)\\n                {\\n                    for(int k=prevC;k<c;k++)\\n                    ans+=\\'R\\';\\n                    prevC = c;\\n                }\\n                ans+=\\'!\\';\\n                continue;\\n            }\\n            if(r>prevR)\\n            {\\n                for(int k=prevR;k<r;k++)\\n                ans+=\\'D\\';\\n                prevR = r;\\n            }\\n            if(r<prevR)\\n            {\\n                for(int k=r;k<prevR;k++)\\n                ans+=\\'U\\';\\n                prevR = r;\\n            }\\n            if(c>prevC)\\n            {\\n                for(int k=prevC;k<c;k++)\\n                ans+=\\'R\\';\\n                prevC = c;\\n            }\\n            if(c<prevC)\\n            {\\n                for(int k=c;k<prevC;k++)\\n                ans+=\\'L\\';\\n                prevC = c;\\n            }\\n            ans+=\\'!\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117898,
                "title": "100-fast-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\nMap each character with their respective row and col index. \\n\\n# Complexity\\n- Time complexity: O(board.size())+O(string.size());\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:O(n) for hashmap;\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        vector<string>board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char,int>row,col;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                row[board[i][j]]=i;\\n                col[board[i][j]]=j;\\n            }\\n        }\\n        int curRow=0,curCol=0;\\n        string ans=\"\";\\n        for(char t:target){\\n            int r=row[t],c=col[t];\\n            if(t==\\'z\\'){                 // edge case for \\'z\\'\\n                int cd=curCol-0;        // column diff & row diff\\n                int rd=5-curRow;\\n                while(cd--){\\n                    ans+=\"L\";\\n                }\\n                while(rd--){\\n                    ans+=\"D\";\\n                }\\n                ans+=\"!\";\\n                curRow=r,curCol=c;\\n                continue;\\n            }\\n            if(r>curRow){          // we need to move up from cur pos\\n                int d=r-curRow;\\n                while(d--){\\n                    ans+=\"D\";\\n                }\\n                curRow=r;\\n            }\\n            else if(r<curRow){     //we need to move down from cur pos\\n                int d=curRow-r;\\n                while(d--){\\n                    ans+=\"U\";\\n                }\\n                curRow=r;\\n            }\\n            if(c>curCol){          // move right\\n                int d=c-curCol;\\n                while(d--){\\n                    ans+=\"R\";\\n                }\\n                curCol=c;\\n            }\\n            else if(c<curCol){    // move left\\n                int d=curCol-c;\\n                while(d--){\\n                    ans+=\"L\";\\n                }\\n                curCol=c;\\n            }\\n\\n            ans+=\"!\";          // reached the req pos\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        vector<string>board = {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n        unordered_map<char,int>row,col;\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                row[board[i][j]]=i;\\n                col[board[i][j]]=j;\\n            }\\n        }\\n        int curRow=0,curCol=0;\\n        string ans=\"\";\\n        for(char t:target){\\n            int r=row[t],c=col[t];\\n            if(t==\\'z\\'){                 // edge case for \\'z\\'\\n                int cd=curCol-0;        // column diff & row diff\\n                int rd=5-curRow;\\n                while(cd--){\\n                    ans+=\"L\";\\n                }\\n                while(rd--){\\n                    ans+=\"D\";\\n                }\\n                ans+=\"!\";\\n                curRow=r,curCol=c;\\n                continue;\\n            }\\n            if(r>curRow){          // we need to move up from cur pos\\n                int d=r-curRow;\\n                while(d--){\\n                    ans+=\"D\";\\n                }\\n                curRow=r;\\n            }\\n            else if(r<curRow){     //we need to move down from cur pos\\n                int d=curRow-r;\\n                while(d--){\\n                    ans+=\"U\";\\n                }\\n                curRow=r;\\n            }\\n            if(c>curCol){          // move right\\n                int d=c-curCol;\\n                while(d--){\\n                    ans+=\"R\";\\n                }\\n                curCol=c;\\n            }\\n            else if(c<curCol){    // move left\\n                int d=curCol-c;\\n                while(d--){\\n                    ans+=\"L\";\\n                }\\n                curCol=c;\\n            }\\n\\n            ans+=\"!\";          // reached the req pos\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117232,
                "title": "c-solution-using-ascii-as-index",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse the Ascii value of characters to form the board and then do as required, no need to allocate any extra space to store that board.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        // map <char,pair<int,int>> m;\\n        // r = -95/2;\\n        // c = +3%5;\\n        int r = 0;\\n        int c = 0;\\n        string ans = \"\";\\n        for (char x : target) {\\n            int row = (int(x) - 97)/5;\\n            int col = (int(x) - 97)%5;\\n            int dr = abs(row - r);\\n            int dc = abs(col - c);\\n            if (dr == 0 && dc == 0) {\\n                ans += \\'!\\';\\n            } \\n            else if (dr == 0 && dc != 0) {\\n                if (col > c) {\\n                    for (int i=0;i<dc;i++) {\\n                        ans += \\'R\\';\\n                    }\\n                }\\n                else {\\n                    for (int i=0;i<dc;i++) {\\n                        ans += \\'L\\';\\n                    }\\n                }\\n                ans += \\'!\\';\\n            }\\n            else if (dc == 0 && dr != 0) {\\n                if (row > r) {\\n                    for (int i=0;i<dr;i++) {\\n                        ans += \\'D\\';\\n                    }\\n                }\\n                else {\\n                    for (int i=0;i<dr;i++) {\\n                        ans += \\'U\\';\\n                    }\\n                }\\n                ans += \\'!\\';\\n            }\\n            else {\\n                if (row == 5 && col == 0) {\\n                    if (col > c) {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'R\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'L\\';\\n                        }\\n                    }\\n                    if (row > r) {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'D\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'U\\';\\n                        }\\n                    }\\n                }\\n                else {\\n                    if (row > r) {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'D\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'U\\';\\n                        }\\n                    }\\n                    if (col > c) {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'R\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'L\\';\\n                        }\\n                    }\\n                }\\n                ans += \\'!\\';\\n            }\\n            r = row;\\n            c = col;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        // map <char,pair<int,int>> m;\\n        // r = -95/2;\\n        // c = +3%5;\\n        int r = 0;\\n        int c = 0;\\n        string ans = \"\";\\n        for (char x : target) {\\n            int row = (int(x) - 97)/5;\\n            int col = (int(x) - 97)%5;\\n            int dr = abs(row - r);\\n            int dc = abs(col - c);\\n            if (dr == 0 && dc == 0) {\\n                ans += \\'!\\';\\n            } \\n            else if (dr == 0 && dc != 0) {\\n                if (col > c) {\\n                    for (int i=0;i<dc;i++) {\\n                        ans += \\'R\\';\\n                    }\\n                }\\n                else {\\n                    for (int i=0;i<dc;i++) {\\n                        ans += \\'L\\';\\n                    }\\n                }\\n                ans += \\'!\\';\\n            }\\n            else if (dc == 0 && dr != 0) {\\n                if (row > r) {\\n                    for (int i=0;i<dr;i++) {\\n                        ans += \\'D\\';\\n                    }\\n                }\\n                else {\\n                    for (int i=0;i<dr;i++) {\\n                        ans += \\'U\\';\\n                    }\\n                }\\n                ans += \\'!\\';\\n            }\\n            else {\\n                if (row == 5 && col == 0) {\\n                    if (col > c) {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'R\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'L\\';\\n                        }\\n                    }\\n                    if (row > r) {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'D\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'U\\';\\n                        }\\n                    }\\n                }\\n                else {\\n                    if (row > r) {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'D\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dr;i++) {\\n                            ans += \\'U\\';\\n                        }\\n                    }\\n                    if (col > c) {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'R\\';\\n                        }\\n                    }\\n                    else {\\n                        for (int i=0;i<dc;i++) {\\n                            ans += \\'L\\';\\n                        }\\n                    }\\n                }\\n                ans += \\'!\\';\\n            }\\n            r = row;\\n            c = col;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116722,
                "title": "c-faster-than-100-o-n-simple-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans=\"\";\\n        char curr=\\'a\\';\\n        for(char c : target){\\n            while(c!=curr){\\n                if((c-\\'a\\')/5==5 && (curr-\\'a\\')/5==4){\\n                    if(curr==\\'u\\'){\\n                        ans+=\\'D\\';\\n                        curr+=5;\\n                    }else{\\n                        ans+=\\'L\\';\\n                        curr--;\\n                    }\\n                }\\n                else if((c-\\'a\\')/5>(curr-\\'a\\')/5){\\n                    ans+=\\'D\\';\\n                    curr+=5;\\n                }else if((c-\\'a\\')/5<(curr-\\'a\\')/5){\\n                    ans+=\\'U\\';\\n                    curr-=5;\\n                }else if(c>curr){\\n                    ans+=\\'R\\';\\n                    curr++;\\n                }else if(c<curr){\\n                    ans+=\\'L\\';\\n                    curr--;\\n                }\\n            }\\n            ans+=\\'!\\';\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n**UPVOTE IF HELPFUL!!!!!!!!!!!**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string target) {\\n        string ans=\"\";\\n        char curr=\\'a\\';\\n        for(char c : target){\\n            while(c!=curr){\\n                if((c-\\'a\\')/5==5 && (curr-\\'a\\')/5==4){\\n                    if(curr==\\'u\\'){\\n                        ans+=\\'D\\';\\n                        curr+=5;\\n                    }else{\\n                        ans+=\\'L\\';\\n                        curr--;\\n                    }\\n                }\\n                else if((c-\\'a\\')/5>(curr-\\'a\\')/5){\\n                    ans+=\\'D\\';\\n                    curr+=5;\\n                }else if((c-\\'a\\')/5<(curr-\\'a\\')/5){\\n                    ans+=\\'U\\';\\n                    curr-=5;\\n                }else if(c>curr){\\n                    ans+=\\'R\\';\\n                    curr++;\\n                }else if(c<curr){\\n                    ans+=\\'L\\';\\n                    curr--;\\n                }\\n            }\\n            ans+=\\'!\\';\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116529,
                "title": "simple-unordered-map-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intutuin is to use the index of the character in the board;\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    void godown(int n , string &s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'D\\');\\n    }\\n        void goleft(int n , string &s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'L\\');\\n    }\\n        void goright(int n , string& s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'R\\');\\n    }\\n        void goup(int n , string& s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'U\\');\\n    }\\n\\n    string alphabetBoardPath(string target) {\\n    vector<string> board {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n    string ans = \"\";\\n    int n = board.size();\\n\\n    cout<<n<<endl;\\n    unordered_map<char,pair<int,int>>m;\\n\\n    for(int  i = 0 ;i<n;i++)\\n    {\\n        for(int j = 0 ;j<board[i].size();j++)\\n        {\\n            m[board[i][j]] = {i,j};\\n            // cout<<board[i][j];\\n        }\\n    }\\n\\n    // for(auto x : m)\\n    // {\\n    //     cout<<x.first<<\" \"<<x.second.first<<\" \"<<x.second.second<<endl;\\n    // }\\n\\n    int sRow = 0;\\n    int sCol = 0;\\n\\n    for(auto ch : target)\\n    {\\n        pair<int,int> p = m[ch];\\n        int currRow = p.first;\\n        int currCol = p.second;\\n\\n        int i = currRow - sRow;\\n        int j = currCol - sCol;\\n\\n        // cout<<currRow<<\" \"<<sRow;\\n        //  cout<<currCol <<\" \"<<sCol;\\n        if(j<0)\\n        {\\n            goleft(j,ans);\\n        }\\n        if( i > 0)\\n        {\\n            godown(i,ans);\\n        }\\n        if(i<0)\\n        {\\n            goup(i,ans);\\n        }\\n\\n        if(j>0)\\n        {\\n            goright(j,ans);\\n        }\\n\\n        \\n        ans.push_back(\\'!\\');\\n\\n        sRow = currRow;\\n        sCol = currCol;\\n\\n    }\\n\\n\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    void godown(int n , string &s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'D\\');\\n    }\\n        void goleft(int n , string &s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'L\\');\\n    }\\n        void goright(int n , string& s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'R\\');\\n    }\\n        void goup(int n , string& s)\\n    {\\n        n = abs(n);\\n        for(int i = 0 ;i<n;i++) s.push_back(\\'U\\');\\n    }\\n\\n    string alphabetBoardPath(string target) {\\n    vector<string> board {\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"};\\n    string ans = \"\";\\n    int n = board.size();\\n\\n    cout<<n<<endl;\\n    unordered_map<char,pair<int,int>>m;\\n\\n    for(int  i = 0 ;i<n;i++)\\n    {\\n        for(int j = 0 ;j<board[i].size();j++)\\n        {\\n            m[board[i][j]] = {i,j};\\n            // cout<<board[i][j];\\n        }\\n    }\\n\\n    // for(auto x : m)\\n    // {\\n    //     cout<<x.first<<\" \"<<x.second.first<<\" \"<<x.second.second<<endl;\\n    // }\\n\\n    int sRow = 0;\\n    int sCol = 0;\\n\\n    for(auto ch : target)\\n    {\\n        pair<int,int> p = m[ch];\\n        int currRow = p.first;\\n        int currCol = p.second;\\n\\n        int i = currRow - sRow;\\n        int j = currCol - sCol;\\n\\n        // cout<<currRow<<\" \"<<sRow;\\n        //  cout<<currCol <<\" \"<<sCol;\\n        if(j<0)\\n        {\\n            goleft(j,ans);\\n        }\\n        if( i > 0)\\n        {\\n            godown(i,ans);\\n        }\\n        if(i<0)\\n        {\\n            goup(i,ans);\\n        }\\n\\n        if(j>0)\\n        {\\n            goright(j,ans);\\n        }\\n\\n        \\n        ans.push_back(\\'!\\');\\n\\n        sRow = currRow;\\n        sCol = currCol;\\n\\n    }\\n\\n\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3116521,
                "title": "python3-c-explained-step-by-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        letters_map = {}\\n\\n        # For evry char we store its row and col\\n\\n        for i in range(26):\\n            letter = chr(ord(\\'a\\') + i)\\n            letters_map[letter] = (i // 5, i % 5)\\n        \\n        moves = []\\n        i, j = 0, 0\\n\\n        for letter in target:\\n            next_i, next_j = letters_map[letter]\\n\\n            # First move horizontally and then vertically as for destination z moving\\n            # vertically first would make us go out of bounds\\n\\n            # If we are moving to a char from z then we take a vertical movement and then \\n            # continue as usual\\n\\n            if (i, j) == letters_map[\\'z\\'] and letter != \\'z\\':\\n                moves.append(\\'U\\')\\n                i-=1\\n\\n            while j != next_j:\\n                if j < next_j:\\n                    moves.append(\\'R\\')\\n                    j+=1\\n                else:\\n                    moves.append(\\'L\\')\\n                    j-=1\\n            \\n            while i != next_i:\\n                if i < next_i:\\n                    moves.append(\\'D\\')\\n                    i+=1\\n                else:\\n                    moves.append(\\'U\\')\\n                    i-=1\\n            \\n            moves.append(\\'!\\')\\n        \\n        return \\'\\'.join(moves)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def alphabetBoardPath(self, target: str) -> str:\\n        letters_map = {}\\n\\n        # For evry char we store its row and col\\n\\n        for i in range(26):\\n            letter = chr(ord(\\'a\\') + i)\\n            letters_map[letter] = (i // 5, i % 5)\\n        \\n        moves = []\\n        i, j = 0, 0\\n\\n        for letter in target:\\n            next_i, next_j = letters_map[letter]\\n\\n            # First move horizontally and then vertically as for destination z moving\\n            # vertically first would make us go out of bounds\\n\\n            # If we are moving to a char from z then we take a vertical movement and then \\n            # continue as usual\\n\\n            if (i, j) == letters_map[\\'z\\'] and letter != \\'z\\':\\n                moves.append(\\'U\\')\\n                i-=1\\n\\n            while j != next_j:\\n                if j < next_j:\\n                    moves.append(\\'R\\')\\n                    j+=1\\n                else:\\n                    moves.append(\\'L\\')\\n                    j-=1\\n            \\n            while i != next_i:\\n                if i < next_i:\\n                    moves.append(\\'D\\')\\n                    i+=1\\n                else:\\n                    moves.append(\\'U\\')\\n                    i-=1\\n            \\n            moves.append(\\'!\\')\\n        \\n        return \\'\\'.join(moves)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116427,
                "title": "c-0ms-faster-than-100-hashing-clean-concise-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    string alphabetBoardPath(string target) {\\n\\n       unordered_map<char,pair<int,int>>mpp;\\n\\n       char ch = \\'a\\';\\n       for(int i = 0;i<6;++i)\\n       { \\n           for(int j = 0;j<5;++j)\\n           {\\n              mpp[ch] = {i,j};\\n              ch++;\\n           }\\n       }\\n\\n       string ans = \"\";\\n       pair<int,int>pos = {0,0};\\n\\n       for(auto it : target)\\n       {\\n          if(it==\\'z\\')\\n          {\\n              string s(pos.second,\\'L\\');\\n              ans+=s;\\n              string s2(mpp[it].first-pos.first,\\'D\\');\\n              ans+=s2;\\n                 \\n          }\\n\\n          else\\n          {\\n\\n          int x = mpp[it].first- pos.first;\\n          int y = mpp[it].second - pos.second;\\n\\n          if(x > 0)\\n          {\\n             string s(x,\\'D\\');\\n             ans += s;\\n          }\\n\\n          else if(x<0)\\n          {\\n             string s(abs(x),\\'U\\');\\n             ans += s;\\n          }\\n          \\n          if(y>0)\\n          {\\n             string s(y,\\'R\\');\\n             ans += s;\\n          }\\n\\n          else if(y<0)\\n          {\\n              string s(abs(y),\\'L\\');\\n              ans += s;\\n          }\\n          }\\n           ans.push_back(\\'!\\');\\n\\n           pos = {mpp[it].first, mpp[it].second};\\n       }\\n\\n       return ans; \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    string alphabetBoardPath(string target) {\\n\\n       unordered_map<char,pair<int,int>>mpp;\\n\\n       char ch = \\'a\\';\\n       for(int i = 0;i<6;++i)\\n       { \\n           for(int j = 0;j<5;++j)\\n           {\\n              mpp[ch] = {i,j};\\n              ch++;\\n           }\\n       }\\n\\n       string ans = \"\";\\n       pair<int,int>pos = {0,0};\\n\\n       for(auto it : target)\\n       {\\n          if(it==\\'z\\')\\n          {\\n              string s(pos.second,\\'L\\');\\n              ans+=s;\\n              string s2(mpp[it].first-pos.first,\\'D\\');\\n              ans+=s2;\\n                 \\n          }\\n\\n          else\\n          {\\n\\n          int x = mpp[it].first- pos.first;\\n          int y = mpp[it].second - pos.second;\\n\\n          if(x > 0)\\n          {\\n             string s(x,\\'D\\');\\n             ans += s;\\n          }\\n\\n          else if(x<0)\\n          {\\n             string s(abs(x),\\'U\\');\\n             ans += s;\\n          }\\n          \\n          if(y>0)\\n          {\\n             string s(y,\\'R\\');\\n             ans += s;\\n          }\\n\\n          else if(y<0)\\n          {\\n              string s(abs(y),\\'L\\');\\n              ans += s;\\n          }\\n          }\\n           ans.push_back(\\'!\\');\\n\\n           pos = {mpp[it].first, mpp[it].second};\\n       }\\n\\n       return ans; \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116237,
                "title": "simple-c-solution-using-o-n-time-complexity",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string s) {\\n        string ans=\"\";\\n        int r=0,c=0;\\n        for(int i=0;i<s.size();++i){\\n            int ascii=s[i]-97;\\n            int nr=ascii/5;\\n            int nc=ascii%5;\\n            if(s[i]==\\'z\\'){\\n                nr=5;\\n                nc=0;\\n                if(nr>r)\\n                    for(int j=r;j<nr-1;++j)\\n                    ans+=\\'D\\';\\n                if(nc>c)\\n                    for(int j=c;j<nc;++j)\\n                    ans+=\\'R\\';\\n                else if(nc<c)\\n                    for(int j=nc;j<c;++j)\\n                    ans+=\\'L\\';\\n                if(nr>r){\\n                    ans+=\\'D\\';\\n                }    \\n            }\\n            else{\\n                if(nr>r)\\n                    for(int j=r;j<nr;++j)\\n                    ans+=\\'D\\';\\n                else if(nr<r)\\n                    for(int j=nr;j<r;++j)\\n                    ans+=\\'U\\';\\n                if(nc>c)\\n                    for(int j=c;j<nc;++j)\\n                    ans+=\\'R\\';\\n                else if(nc<c)\\n                    for(int j=nc;j<c;++j)\\n                    ans+=\\'L\\';\\n            }\\n            ans+=\\'!\\';\\n            r=nr;\\n            c=nc;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string alphabetBoardPath(string s) {\\n        string ans=\"\";\\n        int r=0,c=0;\\n        for(int i=0;i<s.size();++i){\\n            int ascii=s[i]-97;\\n            int nr=ascii/5;\\n            int nc=ascii%5;\\n            if(s[i]==\\'z\\'){\\n                nr=5;\\n                nc=0;\\n                if(nr>r)\\n                    for(int j=r;j<nr-1;++j)\\n                    ans+=\\'D\\';\\n                if(nc>c)\\n                    for(int j=c;j<nc;++j)\\n                    ans+=\\'R\\';\\n                else if(nc<c)\\n                    for(int j=nc;j<c;++j)\\n                    ans+=\\'L\\';\\n                if(nr>r){\\n                    ans+=\\'D\\';\\n                }    \\n            }\\n            else{\\n                if(nr>r)\\n                    for(int j=r;j<nr;++j)\\n                    ans+=\\'D\\';\\n                else if(nr<r)\\n                    for(int j=nr;j<r;++j)\\n                    ans+=\\'U\\';\\n                if(nc>c)\\n                    for(int j=c;j<nc;++j)\\n                    ans+=\\'R\\';\\n                else if(nc<c)\\n                    for(int j=nc;j<c;++j)\\n                    ans+=\\'L\\';\\n            }\\n            ans+=\\'!\\';\\n            r=nr;\\n            c=nc;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116224,
                "title": "simple-typescript-solution-using-a-pre-computed-reverse-map-of-the-character-positions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first though was to use the old school trick of doing the byte offset but I could not remember how to do it typescript/javascript so I opted to do a map approach.\\n\\n# Approach\\nPretty much this is a simple reverse mapping solution of the characters to a position.\\n\\nAnd also uses an array of strings to later concatenate into a single string in order to avoid the recreation of the string every time a character gets addded.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Pre-compute char position map\\nconst charPositions: Map<string, [number, number]> = new  Map<string, [number, number]>();\\nconst alphabet = [\\'abcde\\',\\'fghij\\',\\'klmno\\',\\'pqrst\\',\\'uvwxy\\' , \\'z\\'];\\nfor(let i = 0; i < alphabet.length; i++) {\\n    for(let j = 0; j < alphabet[i].length; j++) {\\n        charPositions.set(alphabet[i][j], [i, j]);\\n    }\\n}\\n\\nfunction alphabetBoardPath(target: string): string {\\n    let curx = 0;\\n    let cury = 0;\\n    let result: string[] = [];\\n    for(let i = 0; i < target.length; i++) {\\n        const [tx, ty] = charPositions.get(target[i]);\\n        let diffx = tx - curx;\\n        let diffy = ty - cury;\\n\\n        // The ordering of the fill operations is important.\\n        // This order handles when the position goes in and out of \\'z\\'.\\n        if(diffx < 0) result.push(...fill(diffx * - 1, \\'U\\'));\\n        if(diffy < 0) result.push(...fill(diffy * -1, \\'L\\'));\\n        \\n        result.push(...fill(diffx, \\'D\\'));\\n        result.push(...fill(diffy, \\'R\\'));\\n\\n        result.push(\\'!\\');\\n\\n        curx = tx;\\n        cury = ty;\\n    }\\n\\n    return result.join(\\'\\');\\n};\\n\\nfunction fill(repeats: number, str: string): string[] {\\n    let result: string[] = [];\\n    while(repeats > 0) {\\n        result.push(str);\\n        repeats--;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// Pre-compute char position map\\nconst charPositions: Map<string, [number, number]> = new  Map<string, [number, number]>();\\nconst alphabet = [\\'abcde\\',\\'fghij\\',\\'klmno\\',\\'pqrst\\',\\'uvwxy\\' , \\'z\\'];\\nfor(let i = 0; i < alphabet.length; i++) {\\n    for(let j = 0; j < alphabet[i].length; j++) {\\n        charPositions.set(alphabet[i][j], [i, j]);\\n    }\\n}\\n\\nfunction alphabetBoardPath(target: string): string {\\n    let curx = 0;\\n    let cury = 0;\\n    let result: string[] = [];\\n    for(let i = 0; i < target.length; i++) {\\n        const [tx, ty] = charPositions.get(target[i]);\\n        let diffx = tx - curx;\\n        let diffy = ty - cury;\\n\\n        // The ordering of the fill operations is important.\\n        // This order handles when the position goes in and out of \\'z\\'.\\n        if(diffx < 0) result.push(...fill(diffx * - 1, \\'U\\'));\\n        if(diffy < 0) result.push(...fill(diffy * -1, \\'L\\'));\\n        \\n        result.push(...fill(diffx, \\'D\\'));\\n        result.push(...fill(diffy, \\'R\\'));\\n\\n        result.push(\\'!\\');\\n\\n        curx = tx;\\n        cury = ty;\\n    }\\n\\n    return result.join(\\'\\');\\n};\\n\\nfunction fill(repeats: number, str: string): string[] {\\n    let result: string[] = [];\\n    while(repeats > 0) {\\n        result.push(str);\\n        repeats--;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3115067,
                "title": "good",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 0\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  string alphabetBoardPath(string target) {\\n    string answer;\\n    int j = 0;\\n    int k = 0;\\n\\n    for (char z : target) {\\n      int newj = (z - \\'a\\') % 5;\\n      int newk = (z - \\'a\\') / 5;\\n      answer += string(max(0, k - newk), \\'U\\') + string(max(0, newj - j), \\'R\\') +\\n             string(max(0, j - newj), \\'L\\') + string(max(0, newk - k), \\'D\\') +\\n             \\'!\\';\\n      j = newj;\\n      k = newk;\\n    }\\n\\n    return answer;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  string alphabetBoardPath(string target) {\\n    string answer;\\n    int j = 0;\\n    int k = 0;\\n\\n    for (char z : target) {\\n      int newj = (z - \\'a\\') % 5;\\n      int newk = (z - \\'a\\') / 5;\\n      answer += string(max(0, k - newk), \\'U\\') + string(max(0, newj - j), \\'R\\') +\\n             string(max(0, j - newj), \\'L\\') + string(max(0, newk - k), \\'D\\') +\\n             \\'!\\';\\n      j = newj;\\n      k = newk;\\n    }\\n\\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565455,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            },
            {
                "id": 1780812,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            },
            {
                "id": 1797301,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            },
            {
                "id": 1829434,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            },
            {
                "id": 1795406,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            },
            {
                "id": 1781077,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            },
            {
                "id": 1781037,
                "content": [
                    {
                        "username": "dragonpolice",
                        "content": "This is annoying, I spent too long on understanding this question! Tried to explain what I understood after such a long time in case any one like me stuck in understanding question.....\\nFor each target String, we start at the place (0, 0) of the board which is the place of \\'a\\'. \\nThen, for example 1, target is \"leet\". We can see from the img of board, char \\'L\\' is 2 positions down and 1 position right for place (0, 0), that\\'s why we use \\'DDR!\\' for moving down 2, moving right 1 and then add this char \\'L\\'. Continue, for char \\'e\\', we begin at current place of \\'L\\', we need to move up 2 positions and move right 3 positions to place of \\'e\\', that\\'s why we use \\'UURRR!\\', since there are 2 \\'e\\' next to each other, we have 2 \\'!\\' in \\'UURRR!!\\'; last, for char \\'t\\',  we begin at current place which is place of \\'e\\', in order to move to place of \\'t\\', we have to move down 3 positions which is \"DDD!\\'. Therefore, the final result for target \\'leet\\' is \"DDR!UURRR!!DDD!\".\\nHope this explain works! Correct me please if I am wrong!\\n"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "You are correct. You need to keep track of the current position. But keep in mind that \\'z\\' is kind of a especial case to watchout for because you can only come in and come out of \\'z\\' by going through \\'u\\'. In my solution sort of cheated by changing the ordering when I do the moves for example to come in I first do Left before doing the Down to come out I always do the Up before doing the Right in that way I don\\'t have to handle the especial case of \\'z\\'."
                    },
                    {
                        "username": "SacredDoggo",
                        "content": "it is specified that I have to provide any of the shortest path\\n\"Return a sequence of moves that makes our answer equal to target in the minimum number of moves.  You may return any path that does so.\"\\n\\nbut test case 42 is not following the pattern \\n\"zdz\"\\nOutput: \"DDDDD!RRRUUUUU!LLLDDDDD!\"\\nExpected: \"DDDDD!UUUUURRR!DDDDLLLD!\""
                    },
                    {
                        "username": "72engineers",
                        "content": "the board has boundary"
                    },
                    {
                        "username": "leenamahajan",
                        "content": "There is a special case for z, you can\\'t go R without going up first"
                    },
                    {
                        "username": "longluo",
                        "content": "Do u get mad by $z$ ?"
                    },
                    {
                        "username": "Msey",
                        "content": "**The question description should have difficulty level as well so I could filter them and never go on**"
                    },
                    {
                        "username": "madezhenshifan",
                        "content": "Don\\'t be misled by the hint. It\\'s just a brainteaser. Should be marked as \\'easy\\'."
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I did it with BFS and it is F.ing SLOW!!!!!!\n[My BFS Solution](https://leetcode.com/problems/alphabet-board-path/solutions/3119821/bfs-pretty-slow-c-common-template-used-to-travel-in-bfs/?orderBy=most_votes)"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "It is simple if you think from / and % angle."
                    },
                    {
                        "username": "Chetan_007",
                        "content": "Don\\'t think it is a DFS or BFS problem just by watching the figures.\\nIt is way easier than you think."
                    }
                ]
            }
        ]
    }
]