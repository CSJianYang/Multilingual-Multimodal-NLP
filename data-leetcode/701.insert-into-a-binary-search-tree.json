[
    {
        "title": "Search in a Binary Search Tree",
        "question_content": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\n&nbsp;\nExample 1:\n\nInput: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]\n\nExample 2:\n\nInput: root = [4,2,7,1,3], val = 5\nOutput: []\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 5000].\n\t1 <= Node.val <= 107\n\troot is a binary search tree.\n\t1 <= val <= 107",
        "solutions": [
            {
                "id": 149274,
                "title": "java-beats-100-concise-method-using-recursion-and-iteration",
                "content": "recursion:\\n```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null) return root;\\n        if(root.val == val){\\n            return root;\\n        }\\n        else{\\n            return val<root.val? searchBST(root.left,val):searchBST(root.right,val);\\n        }\\n    }\\n```\\niteration:\\n```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n        while(root != null && root.val != val){\\n            root = val<root.val? root.left:root.right;\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null) return root;\\n        if(root.val == val){\\n            return root;\\n        }\\n        else{\\n            return val<root.val? searchBST(root.left,val):searchBST(root.right,val);\\n        }\\n    }\\n```\n```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n        while(root != null && root.val != val){\\n            root = val<root.val? root.left:root.right;\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 139687,
                "title": "concise-iterative-solution-c",
                "content": "``` cpp\\nTreeNode* searchBST(TreeNode* root, int val) {\\n    while (root != nullptr && root->val != val) {\\n      root = (root->val > val) ? root->left : root->right;\\n    }\\n    return root;\\n}\\n```",
                "solutionTags": [],
                "code": "``` cpp\\nTreeNode* searchBST(TreeNode* root, int val) {\\n    while (root != nullptr && root->val != val) {\\n      root = (root->val > val) ? root->left : root->right;\\n    }\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 148890,
                "title": "python-3-lines-dfs-solution-w-a-very-simple-approach",
                "content": "One way or another, DFS will continue till found target value val or will stop and return None from a leaf node\\n```\\nclass Solution:\\n    def searchBST(self, root, val):\\n        if root and val < root.val: return self.searchBST(root.left, val)\\n        elif root and val > root.val: return self.searchBST(root.right, val)\\n        return root\\n```\\n1-liner for fun\\n```\\nclass Solution:\\n    def searchBST(self, root, val):\\n        return self.searchBST(root.left,val) if root and val<root.val else self.searchBST(root.right,val) if root and val>root.val else root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root, val):\\n        if root and val < root.val: return self.searchBST(root.left, val)\\n        elif root and val > root.val: return self.searchBST(root.right, val)\\n        return root\\n```\n```\\nclass Solution:\\n    def searchBST(self, root, val):\\n        return self.searchBST(root.left,val) if root and val<root.val else self.searchBST(root.right,val) if root and val>root.val else root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688670,
                "title": "c-easy-recursion-with-explanation-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        //if root is null return null\\n        if(!root) return root;\\n        //create node to return \\n        TreeNode *node=new TreeNode(); \\n        // if root->val != val,search in left and right\\n        //otherwise this would be required node and we would return it\\n        if(val<root->val){\\n            //search in left \\n            node=searchBST(root->left,val);\\n        } else if(val>root->val){\\n            //search in right\\n            node=searchBST(root->right,val);\\n        } else {\\n            //required node\\n            node=root;\\n        }\\n        return node;\\n    }\\n};\\n```\\nPlease Like.\\nThank you:)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        //if root is null return null\\n        if(!root) return root;\\n        //create node to return \\n        TreeNode *node=new TreeNode(); \\n        // if root->val != val,search in left and right\\n        //otherwise this would be required node and we would return it\\n        if(val<root->val){\\n            //search in left \\n            node=searchBST(root->left,val);\\n        } else if(val>root->val){\\n            //search in right\\n            node=searchBST(root->right,val);\\n        } else {\\n            //required node\\n            node=root;\\n        }\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944691,
                "title": "easy-to-understand-clean-java-code-in-2-ways",
                "content": "***BINARY SEARCH TREE (BST)*** is a node-based binary tree data structure which has the properties:\\n\\n* The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n* The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n* The left and right subtree each must also be a binary search tree.\\n\\n![image](https://assets.leetcode.com/users/images/49874e49-a0fa-40d0-a18e-3c5ff98d0aab_1649905553.0092869.gif)\\n\\n\\n\\n***APPROCH 1 : RECURSION METHOD***\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null || root.val == val) return root;// Base Cases: root is null or val is present at root\\n\\t\\tif(root.val > val) return searchBST(root.left, val); // Value is greater than root\\'s val then search in right side of the root\\n\\t\\treturn searchBST(root.right, val);//Value is smaller than root\\'s val then search in left side of the root\\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***Time Complexity : O(N)***\\n***Space Complexity :O(N)***\\nWhere `N` is height of the tree.\\n\\n<hr>\\n<hr>\\n\\n****APPROACH 2 : ITERATIVE METHOD**\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n   \\n        if(root == null)return null;//Base Condition(If tree is empty )\\n        while (root != null && root.val !=val){//Tree is not empty and root value is not equals to val\\n            root = val <root.val?root.left :root.right;//terminatory condition if val smaller than root value then search in left side else on right side\\n        }\\n        return root;  \\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***Time Complexity : O(N)***\\n***Space Complexity :O(1)***\\nWhere `N` is height of the tree.\\n\\n<hr>\\n<hr>",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null || root.val == val) return root;// Base Cases: root is null or val is present at root\\n\\t\\tif(root.val > val) return searchBST(root.left, val); // Value is greater than root\\'s val then search in right side of the root\\n\\t\\treturn searchBST(root.right, val);//Value is smaller than root\\'s val then search in left side of the root\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n   \\n        if(root == null)return null;//Base Condition(If tree is empty )\\n        while (root != null && root.val !=val){//Tree is not empty and root value is not equals to val\\n            root = val <root.val?root.left :root.right;//terminatory condition if val smaller than root value then search in left side else on right side\\n        }\\n        return root;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 544466,
                "title": "recursive-and-iterative-faster-than-96-easy-to-understand-python",
                "content": "### Recursive approach\\n```\\ndef recursive(self, root, val):\\n        def rec(root):\\n            if root:\\n                if root.val == val: return root\\n                elif root.val < val: return rec(root.right)\\n                return rec(root.left)\\n        \\n        return rec(root)\\n```\\n\\n### Iterative approach\\n```\\ndef iterative(self, root, val):\\n        temp = root\\n        while temp:\\n            if temp.val == val: return temp\\n            elif temp.val < val: temp = temp.right\\n            else: temp = temp.left\\n        return None\\n```\\n\\n**I hope that you\\'ve found them useful.**\\n*In that case, please do upvote. It motivates me to write more such posts*",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef recursive(self, root, val):\\n        def rec(root):\\n            if root:\\n                if root.val == val: return root\\n                elif root.val < val: return rec(root.right)\\n                return rec(root.left)\\n        \\n        return rec(root)\\n```\n```\\ndef iterative(self, root, val):\\n        temp = root\\n        while temp:\\n            if temp.val == val: return temp\\n            elif temp.val < val: temp = temp.right\\n            else: temp = temp.left\\n        return None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 147001,
                "title": "python-solution-iterative-o-1-space-o-n-log-n-average-case-time-o-n-worst-case-time",
                "content": "All pretty straightforward, if you\\'re having trouble with this I\\'d recommend going back and re-reading the definition of a binary search tree. The only nodes you should be touching at all are ones that are along the path to the node we\\'re searching for, or that would be if it existed.\\n\\nIt\\'s best to use iteration rather than recursion here, because iteration is O(1) space, whereas recursion is O(log-n) on average with a worst case of O(n) space due to Python not supporting tail calls (meaning that everything goes on the stack, and that could be a lot for a stringy tree).\\n\\nRegardless of whether we use iteration or recursion, the time taken has a best case of O(1), if the node we\\'re looking for was the root node, an average case of O(n-log-n) for a reasonably balanced tree, and a worst case of O(n) when the tree is long and stringy.\\n\\nDon\\'t forget to make sure the root node actually exists, and also be careful that your code handles the case of ONLY having a root node.\\n\\n```\\nclass Solution(object):\\n    def searchBST(self, root, val):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type val: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        current_node = root\\n        while current_node != None:\\n            if current_node.val == val:\\n                return current_node\\n            elif current_node.val < val:\\n                current_node = current_node.right\\n            else:\\n                current_node = current_node.left\\n        return None\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def searchBST(self, root, val):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type val: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        current_node = root\\n        while current_node != None:\\n            if current_node.val == val:\\n                return current_node\\n            elif current_node.val < val:\\n                current_node = current_node.right\\n            else:\\n                current_node = current_node.left\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794032,
                "title": "2-approach-with-great-explanation-beats-84-user-recursive-and-looping",
                "content": "![Screenshot 2023-07-20 234618.png](https://assets.leetcode.com/users/images/266f5967-de24-468f-a32a-2637fee990cb_1689878647.4068298.png)\\n\\n# \\u2705 \\u2B06\\uFE0F --- Soln -  1 ---  \\u2B06 \\u267B\\uFE0F\\n# \\uD83E\\uDD29 Intuition and Approach - Recursive \\uD83E\\uDD73\\n\\nthe searchBST function is a recursive function that searches for a specific target value in a binary search tree (BST). The function starts its search from the root of the BST and traverses down the tree based on the comparison of the target value with the values of nodes. If the target value is found in the tree, the function returns the corresponding TreeNode*, otherwise, it returns NULL to indicate that the target value is not present in the BST.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n\\n- Space complexity: O(log n)\\n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int target) {\\n\\n        if(root->val == target) return root;\\n\\n        //if the target is lesser than the root->val, then \\n        else if(root->val > target) return searchBST(root->left,target);\\n        else return searchBST(root->right, target);\\n\\n        // If the root is null (i.e., the tree is empty) or we have reached a leaf node,\\n        // we cannot find the target in the tree, so we return null.\\n        if (root == NULL) return NULL;\\n\\n        // If the current node\\'s value is equal to the target value,\\n        // then we have found the node containing the target value, so we return this node.\\n        if (root->val == target) return root;\\n\\n        // If the target value is lesser than the current node\\'s value,\\n        // we need to search in the left subtree of the current node.\\n        // So we recursively call the searchBST function with the left child of the current node.\\n        else if(root->val > target) return searchBST(root->left,target);\\n\\n        // If the target value is greater than the current node\\'s value,\\n        // we need to search in the right subtree of the current node.\\n        // So we recursively call the searchBST function with the right child of the current node.\\n        else return searchBST(root->right, target);\\n\\n        \\n    }\\n};\\n```\\n# \\u2B06\\uFE0F\\u2705---  Soln - 2  --- \\uD83E\\uDD73\\n\\n# \\uD83E\\uDD29 Intuition and Approach \\u267B\\uFE0F\\nwhile loop to traverse the binary search tree iteratively, moving to the left or right subtree based on the comparison of the target value with the values of nodes. If the target value is found in the tree, the function returns the corresponding TreeNode*, otherwise, it returns NULL to indicate that the target value is not present in the BST. \\n\\n```\\n    // The loop continues until either the root becomes NULL (end of the tree) or\\n    // the root\\'s value matches the target value.\\n    while (root != NULL && root->val != target) {\\n\\n        // If the current node\\'s value is greater than the target value,\\n        // move to the left subtree to continue the search.\\n        if (root->val > target)\\n            root = root->left;\\n\\n        // If the current node\\'s value is lesser than the target value,\\n        // move to the right subtree to continue the search.\\n        else\\n            root = root->right;\\n    }\\n\\n    // Return the current node (which contains the target value) if found,\\n    // or NULL if the target value is not present in the BST.\\n    return root;\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int target) {\\n\\n        if(root->val == target) return root;\\n\\n        //if the target is lesser than the root->val, then \\n        else if(root->val > target) return searchBST(root->left,target);\\n        else return searchBST(root->right, target);\\n\\n        // If the root is null (i.e., the tree is empty) or we have reached a leaf node,\\n        // we cannot find the target in the tree, so we return null.\\n        if (root == NULL) return NULL;\\n\\n        // If the current node\\'s value is equal to the target value,\\n        // then we have found the node containing the target value, so we return this node.\\n        if (root->val == target) return root;\\n\\n        // If the target value is lesser than the current node\\'s value,\\n        // we need to search in the left subtree of the current node.\\n        // So we recursively call the searchBST function with the left child of the current node.\\n        else if(root->val > target) return searchBST(root->left,target);\\n\\n        // If the target value is greater than the current node\\'s value,\\n        // we need to search in the right subtree of the current node.\\n        // So we recursively call the searchBST function with the right child of the current node.\\n        else return searchBST(root->right, target);\\n\\n        \\n    }\\n};\\n```\n```\\n    // The loop continues until either the root becomes NULL (end of the tree) or\\n    // the root\\'s value matches the target value.\\n    while (root != NULL && root->val != target) {\\n\\n        // If the current node\\'s value is greater than the target value,\\n        // move to the left subtree to continue the search.\\n        if (root->val > target)\\n            root = root->left;\\n\\n        // If the current node\\'s value is lesser than the target value,\\n        // move to the right subtree to continue the search.\\n        else\\n            root = root->right;\\n    }\\n\\n    // Return the current node (which contains the target value) if found,\\n    // or NULL if the target value is not present in the BST.\\n    return root;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651155,
                "title": "javascript-3-solutions",
                "content": "**Recursion with helper function:**\\n```\\nvar searchBST = function(root, val) {\\n    let res = null;\\n    const helper = (node) => {\\n        if(!node) return;\\n        if(node.val === val){\\n            res = node;\\n            return;\\n        }\\n        if(val < node.val) helper(node.left)\\n        if(val > node.val) helper(node.right)\\n    }\\n    \\n    helper(root);   \\n    return res;\\n};\\n```\\n\\n**Pure Recursion :**\\n```\\nvar searchBST = function(root, val) {\\n    if(!root) return null;\\n    if(root.val === val) return root;\\n    if(val < root.val) return searchBST(root.left, val);\\n    if(val > root.val) return searchBST(root.right, val);\\n}\\n```\\n\\n**Iterative:**\\n```\\n// no need to use stack since \"val\"  or \"null\" will be eventually found in the end \\n// and we do not need to traverse what we skipped\\n\\nvar searchBST = function(root, val) {\\n    while(root !== null && root.val !== val){\\n        root = val < root.val ? root.left : root.right;\\n    }\\n    return root;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar searchBST = function(root, val) {\\n    let res = null;\\n    const helper = (node) => {\\n        if(!node) return;\\n        if(node.val === val){\\n            res = node;\\n            return;\\n        }\\n        if(val < node.val) helper(node.left)\\n        if(val > node.val) helper(node.right)\\n    }\\n    \\n    helper(root);   \\n    return res;\\n};\\n```\n```\\nvar searchBST = function(root, val) {\\n    if(!root) return null;\\n    if(root.val === val) return root;\\n    if(val < root.val) return searchBST(root.left, val);\\n    if(val > root.val) return searchBST(root.right, val);\\n}\\n```\n```\\n// no need to use stack since \"val\"  or \"null\" will be eventually found in the end \\n// and we do not need to traverse what we skipped\\n\\nvar searchBST = function(root, val) {\\n    while(root !== null && root.val !== val){\\n        root = val < root.val ? root.left : root.right;\\n    }\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688273,
                "title": "python-intuitive-recursive-solution-o-h-explained",
                "content": "This is exercise to undertand what is Binary Search Tree and how it works. Remember, that **left** subtree is always lesser than root and **right** subtree is always bigger than root.\\nSo, what we need to do? We start from the root of our tree and compare value in its root. If value we are looking is **less** than value in root, we go left, if it is **more**, we go to the right. When we stop? Either if we found place, where these two values are equal, or we reached NULL leaf (it means we visited leaf and descended to its NULL children). In this cases we save found node to global variable, which we return in the end.\\n\\n**Complexity**, both time and space is `O(h)`, where `h` is heigth of our tree.\\n\\n**Remark**: I used `helper` function, which is not necessary here, but in this way the code is more universal for different trees traversal problems, where you need to return more difficult objects. \\n\\n```\\nclass Solution:\\n    def helper(self, root):\\n        if not root or root.val == self.val: \\n            self.Found = root\\n            return root\\n        \\n        if root.val < self.val:\\n            return self.helper(root.right)\\n        \\n        if root.val > self.val:\\n            return self.helper(root.left)\\n    \\n    def searchBST(self, root, val):\\n        self.val = val\\n        self.Found = None\\n        self.helper(root)\\n        return self.Found\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def helper(self, root):\\n        if not root or root.val == self.val: \\n            self.Found = root\\n            return root\\n        \\n        if root.val < self.val:\\n            return self.helper(root.right)\\n        \\n        if root.val > self.val:\\n            return self.helper(root.left)\\n    \\n    def searchBST(self, root, val):\\n        self.val = val\\n        self.Found = None\\n        self.helper(root)\\n        return self.Found\\n```",
                "codeTag": "Java"
            },
            {
                "id": 943397,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return\\n        if root.val==val:\\n            return root\\n        if root.val<val:\\n            return self.searchBST(root.right,val)\\n        else:\\n            return self.searchBST(root.left,val)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return\\n        if root.val==val:\\n            return root\\n        if root.val<val:\\n            return self.searchBST(root.right,val)\\n        else:\\n            return self.searchBST(root.left,val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946310,
                "title": "recursive-solution-with-time-complexity-of-o-longn",
                "content": "\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Recursion.***\\n- Here we have 4 possible cases:\\n    - `if(root== NULL)` means we didn\\u2019t find the element in the tree, so we\\u2019ll return null.\\n    - `if(root->val == val)` we find our root, simply return it.\\n    - `if(root->val > val)` as our current value is greater & in BST lift side we\\u2019ll have smaller values, so we\\u2019ll search for the left tree only.\\n    - `if(root->val < val)` here current value is less so we\\u2019ll simply search on the right tree.\\n- **Time complexity:** O(n), worst case it can have 1node in every stage!\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root== NULL) return NULL;\\n        if(root->val == val) return root;\\n        if(root->val > val) return searchBST(root->left, val);\\n        return searchBST(root->right, val);\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root== NULL) return NULL;\\n        if(root->val == val) return root;\\n        if(root->val > val) return searchBST(root->left, val);\\n        return searchBST(root->right, val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171663,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def searchBST(self, root, val):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type val: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        trav = root\\n        while trav:\\n            if trav.val == val:\\n                return trav\\n            elif trav.val < val:\\n                trav = trav.right\\n            else:\\n                trav = trav.left\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def searchBST(self, root, val):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type val: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        trav = root\\n        while trav:\\n            if trav.val == val:\\n                return trav\\n            elif trav.val < val:\\n                trav = trav.right\\n            else:\\n                trav = trav.left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164866,
                "title": "c-solution",
                "content": "\\nSince element to left are small than root and elements to right are greater than root in BST we use same property to traverse element and return requiered element.\\nIf root is null or we reached end and element is not found we return NULL\\n``` \\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL)\\n            return NULL;\\n        if(root->val==val)\\n            return root;\\n        if(root->val<val)\\n            return searchBST(root->right,val);\\n        else\\n            return searchBST(root->left,val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL)\\n            return NULL;\\n        if(root->val==val)\\n            return root;\\n        if(root->val<val)\\n            return searchBST(root->right,val);\\n        else\\n            return searchBST(root->left,val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336093,
                "title": "c-one-line-recursive-two-line-iterative",
                "content": "## Recursive:\\n```cpp\\nTreeNode* searchBST(TreeNode* root, int val) {\\n\\treturn (!root || root->val == val) ? root : root->val < val ? searchBST(root->right, val) : searchBST(root->left, val); \\n}\\n```\\n---\\n## Iterative:\\n```cpp\\nTreeNode* searchBST(TreeNode* root, int val) {\\n\\twhile(root && root->val != val) root = root->val < val ? root->right : root->left;\\n\\treturn root;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nTreeNode* searchBST(TreeNode* root, int val) {\\n\\treturn (!root || root->val == val) ? root : root->val < val ? searchBST(root->right, val) : searchBST(root->left, val); \\n}\\n```\n```cpp\\nTreeNode* searchBST(TreeNode* root, int val) {\\n\\twhile(root && root->val != val) root = root->val < val ? root->right : root->left;\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164355,
                "title": "easy-to-understand-recursive-traversal-java",
                "content": "Based on the BST idea, we traverse to the subtree of the original BST based on the property that root.left < root < root.right.\\n\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null)\\n            return root;\\n        if (root.val == val)\\n            return root;\\n        else if (root.val > val)\\n            return searchBST(root.left, val);\\n        else if (root.val < val)\\n            return searchBST(root.right, val);\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null)\\n            return root;\\n        if (root.val == val)\\n            return root;\\n        else if (root.val > val)\\n            return searchBST(root.left, val);\\n        else if (root.val < val)\\n            return searchBST(root.right, val);\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944884,
                "title": "simple-5-line-python-code",
                "content": "**Code:**\\n```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root is None or root.val == val: # If end is reached or a node with a value of target is found found.\\n            return root # Return that node.\\n\\t\\t# If target > current nodes value search in left side of node else search rightwards.\\n        return self.searchBST(root.left,val) if root.val > val else self.searchBST(root.right,val) \\n```\\n**One Liner Code:**\\n```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        return root if not root or root.val == val else self.searchBST(root.left if root.val > val else root.right, val)\\n```\\n**Results:**\\n![image](https://assets.leetcode.com/users/images/b8a93e86-9978-4023-ab6e-73759ea6ea30_1649906877.2815614.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root is None or root.val == val: # If end is reached or a node with a value of target is found found.\\n            return root # Return that node.\\n\\t\\t# If target > current nodes value search in left side of node else search rightwards.\\n        return self.searchBST(root.left,val) if root.val > val else self.searchBST(root.right,val) \\n```\n```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        return root if not root or root.val == val else self.searchBST(root.left if root.val > val else root.right, val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944508,
                "title": "c-3-lines-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nRecursively call the method with the node choosed using BST property (small nodes go to the left, grater - to the right).\\n\\nTime: **O(n)** - in worst case we have linked list\\nSpace: **O(n)** - recursive call stack\\n\\nRuntime: 41 ms, faster than **83.26%** of C++ online submissions for Search in a Binary Search Tree.\\nMemory Usage: 34.9 MB, less than **24.22%** of C++ online submissions for Search in a Binary Search Tree.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (!root) return NULL;\\n        if (root->val == val) return root;\\n        return searchBST(root->val > val ? root->left : root->right, val);\\n    }\\n};\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (!root) return NULL;\\n        if (root->val == val) return root;\\n        return searchBST(root->val > val ? root->left : root->right, val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772489,
                "title": "easiest-soltuion-c-plus-plus-bst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust by using the main property of binary search tree which is left node is less than its root and right is more than its root\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nby using its main property which is left node is less than its root and right is more than its root so if the val / targert value is less than the root then we search it in the left sub tree else in right sub tree and using the recursion for that \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// please upvaote if it is helpful for u ..............\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL) return NULL;\\n        if(root->val==val) return root;\\n        if(val<root->val) return searchBST(root->left,val);\\n        else return searchBST(root->right,val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// please upvaote if it is helpful for u ..............\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL) return NULL;\\n        if(root->val==val) return root;\\n        if(val<root->val) return searchBST(root->left,val);\\n        else return searchBST(root->right,val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046235,
                "title": "java-0-ms-faster-than-100-00-super-simlpe-clear-solution-iterative-5-lines",
                "content": "\\tclass Solution {\\n\\t\\tpublic TreeNode searchBST(TreeNode root, int val) {\\n\\t\\t\\twhile (root != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( val < root.val ) root = root.left;\\n\\t\\t\\t\\telse if ( val > root.val ) root = root.right;\\n\\t\\t\\t\\telse return root;\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic TreeNode searchBST(TreeNode root, int val) {\\n\\t\\t\\twhile (root != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( val < root.val ) root = root.left;\\n\\t\\t\\t\\telse if ( val > root.val ) root = root.right;\\n\\t\\t\\t\\telse return root;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 200291,
                "title": "c-beats-100-concise-method-using-recursion",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nstruct TreeNode* searchBST(struct TreeNode* root, int val) {\\n    if(root){\\n        if(root->val == val)\\n            return root;\\n        else if(root->val > val)\\n            return searchBST(root->left, val);\\n        else\\n            return searchBST(root->right, val);\\n    }\\n    return NULL;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nstruct TreeNode* searchBST(struct TreeNode* root, int val) {\\n    if(root){\\n        if(root->val == val)\\n            return root;\\n        else if(root->val > val)\\n            return searchBST(root->left, val);\\n        else\\n            return searchBST(root->right, val);\\n    }\\n    return NULL;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3016072,
                "title": "simple-python-iterative-solution-o-h-o-1",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(H), where H is the height of tree.\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        node=root\\n        while(node):\\n            if node.val==val:\\n                return node\\n            if node.val<val:\\n                node=node.right\\n            else:\\n                node=node.left\\n        return None\\n\\n```\\nUpvote if you like it!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        node=root\\n        while(node):\\n            if node.val==val:\\n                return node\\n            if node.val<val:\\n                node=node.right\\n            else:\\n                node=node.left\\n        return None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257083,
                "title": "100-concise-and-easy-c-solution-using-recursion-and-iteration",
                "content": "Plz upvote if you find it useful\\n\\nRecursive Approach..\\n```\\n**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL){\\n           return NULL;\\n       }\\n        if(root->val==val){\\n                return root;\\n            }\\n        if(val>root->val){\\n            return searchBST(root->right,val);\\n        }\\n         else{\\n            return searchBST(root->left,val);\\n            }\\n        // return NULL;\\n    }\\n};\\n```\\n\\nIterative Approach..\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       TreeNode* temp=root;\\n        while(temp!=NULL){\\n            if(temp->val==val){\\n                return temp;\\n            }\\n            if(val>temp->val){\\n                temp=temp->right;\\n            }\\n            else{\\n                temp=temp->left;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL){\\n           return NULL;\\n       }\\n        if(root->val==val){\\n                return root;\\n            }\\n        if(val>root->val){\\n            return searchBST(root->right,val);\\n        }\\n         else{\\n            return searchBST(root->left,val);\\n            }\\n        // return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       TreeNode* temp=root;\\n        while(temp!=NULL){\\n            if(temp->val==val){\\n                return temp;\\n            }\\n            if(val>temp->val){\\n                temp=temp->right;\\n            }\\n            else{\\n                temp=temp->left;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946167,
                "title": "99-faster-and-96-less-code-using-simple-recursion",
                "content": "![image](https://assets.leetcode.com/users/images/d6d4e7ec-e96c-4e21-b36d-0deceab8b19d_1649932752.0958385.png)\\n\\n```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root and val == root.val:\\n            return root\\n        if root and val > root.val:\\n            return self.searchBST(root.right, val)\\n        elif root and val < root.val:\\n            return self.searchBST(root.left, val)\\n        else:\\n            return None\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root and val == root.val:\\n            return root\\n        if root and val > root.val:\\n            return self.searchBST(root.right, val)\\n        elif root and val < root.val:\\n            return self.searchBST(root.left, val)\\n        else:\\n            return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944605,
                "title": "c-dfs-using-properties-of-a-bst",
                "content": "dfs.\\n\\nIf the target is smaller than current node->val, look left.\\nIf the target is larger than current node->val, look right.\\nIf it is equal set the ans\\n\\nSolved live on stream.  Everyday 6pm PT.  Check profile for link.\\n\\n```\\nclass Solution {\\n    void dfs(TreeNode* root, int val, TreeNode*& ans) {\\n        if(!root) return;\\n    \\n        if(root->val == val) {\\n            ans = root;\\n        } else if(root->val > val) {\\n            dfs(root->left, val, ans);\\n        } else if(root->val < val) {\\n            dfs(root->right, val, ans);\\n        }\\n        \\n    }\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        TreeNode* ans = nullptr;\\n        dfs(root, val, ans);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void dfs(TreeNode* root, int val, TreeNode*& ans) {\\n        if(!root) return;\\n    \\n        if(root->val == val) {\\n            ans = root;\\n        } else if(root->val > val) {\\n            dfs(root->left, val, ans);\\n        } else if(root->val < val) {\\n            dfs(root->right, val, ans);\\n        }\\n        \\n    }\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        TreeNode* ans = nullptr;\\n        dfs(root, val, ans);\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688364,
                "title": "python-3-bst-easy-to-read-and-understand",
                "content": "```\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return None\\n        if root.val == val:\\n            return root\\n        elif root.val > val:\\n            return self.searchBST(root.left, val)           \\n        else:\\n            return self.searchBST(root.right, val)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return None\\n        if root.val == val:\\n            return root\\n        elif root.val > val:\\n            return self.searchBST(root.left, val)           \\n        else:\\n            return self.searchBST(root.right, val)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 247948,
                "title": "python3-iterative-and-recursive-solutions",
                "content": "```\\n# iterative\\n\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        while root and root.val != val:\\n            if root.val > val:\\n                root = root.left\\n            elif root.val < val:\\n                root = root.right\\n        return root\\n\\n# recursive\\n\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root or root.val == val:\\n            return root\\n        if root.val > val:\\n            return self.searchBST(root.left, val)\\n        return self.searchBST(root.right, val)",
                "solutionTags": [],
                "code": "```\\n# iterative\\n\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        while root and root.val != val:\\n            if root.val > val:\\n                root = root.left\\n            elif root.val < val:\\n                root = root.right\\n        return root\\n\\n# recursive\\n\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root or root.val == val:\\n            return root\\n        if root.val > val:\\n            return self.searchBST(root.left, val)\\n        return self.searchBST(root.right, val)",
                "codeTag": "Java"
            },
            {
                "id": 1046240,
                "title": "js-super-simple-clear-solution-iterative-5-lines",
                "content": "\\tvar searchBST = function(root, val) {\\n\\t\\twhile (root != null)\\n\\t\\t{\\n\\t\\t\\tif ( val < root.val ) root = root.left;\\n\\t\\t\\telse if ( val > root.val ) root = root.right;\\n\\t\\t\\telse return root;\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar searchBST = function(root, val) {\\n\\t\\twhile (root != null)\\n\\t\\t{\\n\\t\\t\\tif ( val < root.val ) root = root.left;\\n\\t\\t\\telse if ( val > root.val ) root = root.right;\\n\\t\\t\\telse return root;\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3908499,
                "title": "easy-c-recursive-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(log(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root == NULL) return NULL;\\n        if(root->val == val) return root;\\n\\n        if(val < root->val) root = searchBST(root->left, val);\\n        else root = searchBST(root->right, val);\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root == NULL) return NULL;\\n        if(root->val == val) return root;\\n\\n        if(val < root->val) root = searchBST(root->left, val);\\n        else root = searchBST(root->right, val);\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248002,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? {\\n        guard let root = root else { return nil }\\n        return val == root.val ? root : searchBST(val < root.val ? root.left : root.right, val)\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.059 (0.061) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test1() {\\n        let tree = solution.searchBST(TreeNode([4,2,7,1,3]), 2)\\n        XCTAssertEqual(tree?.val, TreeNode([2,1,3])?.val)\\n    }\\n    \\n    func test2() {\\n        let tree = solution.searchBST(TreeNode([4,2,7,1,3]), 5)\\n        XCTAssertEqual(tree?.val, TreeNode([])?.val)\\n    }\\n}\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? {\\n        guard let root = root else { return nil }\\n        return val == root.val ? root : searchBST(val < root.val ? root.left : root.right, val)\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test1() {\\n        let tree = solution.searchBST(TreeNode([4,2,7,1,3]), 2)\\n        XCTAssertEqual(tree?.val, TreeNode([2,1,3])?.val)\\n    }\\n    \\n    func test2() {\\n        let tree = solution.searchBST(TreeNode([4,2,7,1,3]), 5)\\n        XCTAssertEqual(tree?.val, TreeNode([])?.val)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688260,
                "title": "java-simple-solution-recursive-100-00-runtime",
                "content": "***UPVOTE if you like my solution***\\n<hr>\\n\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null)\\n            return null;\\n        if(root.val==val)\\n            return root;\\n        \\n        TreeNode l = searchBST(root.left,val);\\n        TreeNode r = searchBST(root.right,val);\\n        \\n        if(l!=null)\\n            return l;\\n        if(r!=null)\\n            return r;\\n        \\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null)\\n            return null;\\n        if(root.val==val)\\n            return root;\\n        \\n        TreeNode l = searchBST(root.left,val);\\n        TreeNode r = searchBST(root.right,val);\\n        \\n        if(l!=null)\\n            return l;\\n        if(r!=null)\\n            return r;\\n        \\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688236,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null || root.val == val) return root;\\n        if(root.val > val) return searchBST(root.left, val);\\n        return searchBST(root.right, val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null || root.val == val) return root;\\n        if(root.val > val) return searchBST(root.left, val);\\n        return searchBST(root.right, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651000,
                "title": "c-easy-2-solutions-recursive-iterative",
                "content": "# Intuition\\nRecursively traversing the tree based on BST Property & comparing data of nodes & value we have to search. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach - *Recursive*\\n<!-- Describe your approach to solving the problem. -->\\n- **2 Base Cases**\\n    - *if root is NULL, we return NULL ;* \\n    - *if data of root matches to value to be searched, we return the node;*\\n- **Recursive Traversal Statements based on comparison of node\\'s data & the value to be searched and the BST Property**\\n    - *if data of node is greater than value, we search in the left subtree & OMIT right subtree*\\n    - *Else, we search in the right subtree & OMIT the left subtree.*\\n\\n# Complexity\\n- Time complexity:$$O(log N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        // base case \\n        // if element not found or if element found \\n        if (root == NULL)\\n        {\\n            return NULL ; \\n        }\\n\\n        if (root -> val == val)\\n        {\\n            return root ; \\n        }\\n\\n        // return statments mandatory in recursion because return type non NULL here\\n        // left part traverse\\n        if (root -> val > val)\\n        {\\n            return searchBST(root -> left, val) ;\\n        }\\n\\n        // right part traverse \\n        else    \\n        {\\n            return searchBST(root -> right, val) ; \\n        }\\n    }\\n};\\n```\\n---\\n# *OPTIMIZED SOLUTION* \\n# Intuition\\nWe know, whenever we reach NULL it means that the element is absent in the tree. Because in a BST, an element can not exist anywhere else.\\nTherefore, we don\\'t necessarily need to go back to the previous node & traverse to some other subtree.\\nSo, this can be solved ITERATIVELY without RECURSION\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach - *Iterative*\\n- Create a `temp` node & make it equal to root; \\n- Now, traverse **till temp is NOT EQUAL to NULL**\\n- While traversing \\n    - Compare *temp\\'s data & the val* which we have to find.\\n    - ***Move to left or right child of temp based on the comparison using the BST Property***\\n> **BST Property**\\n*Left Child Value < Node Value \\nRight Child Value > Node Value*>\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(log N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        // Solving Iteratively \\n        // with Constant O(1) Space Complexity \\n        // Optimised Solution \\n\\n        TreeNode *temp = root ; \\n\\n        while(temp != NULL)\\n        {\\n            if (temp -> val == val)\\n            {\\n                return temp ; \\n            }\\n\\n            if (temp -> val > val)\\n            {\\n                temp = temp -> left; \\n            }\\n\\n            else\\n            {\\n                temp = temp -> right ; \\n            }\\n        }\\n        return NULL ;  \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/587b327a-0c8a-4f25-8268-66087409fe88_1687065985.4967413.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        // base case \\n        // if element not found or if element found \\n        if (root == NULL)\\n        {\\n            return NULL ; \\n        }\\n\\n        if (root -> val == val)\\n        {\\n            return root ; \\n        }\\n\\n        // return statments mandatory in recursion because return type non NULL here\\n        // left part traverse\\n        if (root -> val > val)\\n        {\\n            return searchBST(root -> left, val) ;\\n        }\\n\\n        // right part traverse \\n        else    \\n        {\\n            return searchBST(root -> right, val) ; \\n        }\\n    }\\n};\\n```\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        // Solving Iteratively \\n        // with Constant O(1) Space Complexity \\n        // Optimised Solution \\n\\n        TreeNode *temp = root ; \\n\\n        while(temp != NULL)\\n        {\\n            if (temp -> val == val)\\n            {\\n                return temp ; \\n            }\\n\\n            if (temp -> val > val)\\n            {\\n                temp = temp -> left; \\n            }\\n\\n            else\\n            {\\n                temp = temp -> right ; \\n            }\\n        }\\n        return NULL ;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947173,
                "title": "cpp-3-lines-code-using-dfs",
                "content": "**Approach:**\\nSimply, just call the dfs function and in the dfs function, *if root node is not null and val of root is not equal to the given value(val) then call the dfs again and assign its value to root, if the root value is greater than the value to be searched then we call dfs for left half otherwise we call for right half* . \\nAfter this we just return the root node. \\n```\\nC++ Code:\\nTreeNode* dfs(TreeNode* root,int val)\\n    {\\n        if(root!=NULL && root->val!=val)\\n           root=(root->val>val)?dfs(root->left,val):dfs(root->right,val);\\n        return root;\\n    }\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        return dfs(root,val);\\n    }\\n\\t",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "**Approach:**\\nSimply, just call the dfs function and in the dfs function, *if root node is not null and val of root is not equal to the given value(val) then call the dfs again and assign its value to root, if the root value is greater than the value to be searched then we call dfs for left half otherwise we call for right half* . \\nAfter this we just return the root node. \\n```\\nC++ Code:\\nTreeNode* dfs(TreeNode* root,int val)\\n    {\\n        if(root!=NULL && root->val!=val)\\n           root=(root->val>val)?dfs(root->left,val):dfs(root->right,val);\\n        return root;\\n    }\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        return dfs(root,val);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1944618,
                "title": "python-3-methods-dfs-and-bfs-and-constant-space-method",
                "content": "\\n\\t\\t\\n\\t\\t\"\"\"\\n        #dfs\\n        def search(node):\\n            if node==None:\\n                return None\\n            if node.val==val:\\n                return node\\n            if node.val>val:\\n                return search(node.left)\\n            return search(node.right)\\n  \\n        return search(root)\\n\\n        \"\"\"\\n        #bfs\\n        q=deque([root])\\n        while q:\\n            node=q.popleft()\\n            if node.val==val:\\n                return node\\n            if node.val>val:\\n                if node.left:\\n                    q.append(node.left)\\n            else:\\n                if node.right:\\n                    q.append(node.right)\\n        return None\\n\\t\\t\\n\\t\\t\\n# \\t\\tconstant space solution\\n\\t\\twhile root:\\n            if root.val==val:\\n                return root\\n            if root.val>val:\\n                root=root.left\\n            else:\\n                root=root.right\\n        return None",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "\\n\\t\\t\\n\\t\\t\"\"\"\\n        #dfs\\n        def search(node):\\n            if node==None:\\n                return None\\n            if node.val==val:\\n                return node\\n            if node.val>val:\\n                return search(node.left)\\n            return search(node.right)\\n  \\n        return search(root)\\n\\n        \"\"\"\\n        #bfs\\n        q=deque([root])\\n        while q:\\n            node=q.popleft()\\n            if node.val==val:\\n                return node\\n            if node.val>val:\\n                if node.left:\\n                    q.append(node.left)\\n            else:\\n                if node.right:\\n                    q.append(node.right)\\n        return None\\n\\t\\t\\n\\t\\t\\n# \\t\\tconstant space solution\\n\\t\\twhile root:\\n            if root.val==val:\\n                return root\\n            if root.val>val:\\n                root=root.left\\n            else:\\n                root=root.right\\n        return None",
                "codeTag": "Python3"
            },
            {
                "id": 689624,
                "title": "java-2-liner",
                "content": "```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n\\tif (root == null || root.val == val) return root;\\n\\treturn val<root.val? searchBST(root.left,val): searchBST(root.right,val);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n\\tif (root == null || root.val == val) return root;\\n\\treturn val<root.val? searchBST(root.left,val): searchBST(root.right,val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 461483,
                "title": "simple-4-line-javascript-solution",
                "content": "```javascript\\nvar searchBST = function(root, val) {\\n    while(root) {\\n        if(root.val === val) return root;\\n        root = root.val > val ? root.left : root.right;\\n    }\\n    return null;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar searchBST = function(root, val) {\\n    while(root) {\\n        if(root.val === val) return root;\\n        root = root.val > val ? root.left : root.right;\\n    }\\n    return null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330540,
                "title": "rust-0ms-100",
                "content": "```rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn search_bst(root: Option<Rc<RefCell<TreeNode>>>, val: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        match &root {\\n            Some(node) if node.borrow().val == val => root,\\n            Some(node) if node.borrow().val > val => Solution::search_bst(node.borrow().left.clone(), val),\\n            Some(node) if node.borrow().val < val => Solution::search_bst(node.borrow().right.clone(), val),\\n            Some(_) => panic!(),\\n            None => None,\\n        }\\n    }\\n}\\n```\\n\\nIt\\'s not very pretty.",
                "solutionTags": [],
                "code": "```rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn search_bst(root: Option<Rc<RefCell<TreeNode>>>, val: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        match &root {\\n            Some(node) if node.borrow().val == val => root,\\n            Some(node) if node.borrow().val > val => Solution::search_bst(node.borrow().left.clone(), val),\\n            Some(node) if node.borrow().val < val => Solution::search_bst(node.borrow().right.clone(), val),\\n            Some(_) => panic!(),\\n            None => None,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3793585,
                "title": "recursive-approach-with-easy-steps",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nImagine you have a tree where each node has a value, and the nodes are arranged in a specific order, called a binary search tree (BST). The BST has a special property: for any node, all the nodes in its left subtree have values smaller than the node\\'s value, and all the nodes in its right subtree have values greater than the node\\'s value. We need to find a specific value (val) in this tree and return the subtree that contains the value.\\n\\n# Approach\\nTo find the value in the binary search tree, we use a recursive approach:\\n\\n1. We start at the root of the tree and check if it\\'s null or if its value is equal to the target value val. If so, we have found the node with the value we want, and we return it.\\n\\n1. If the target value val is smaller than the root\\'s value, we know the node we want must be in the left subtree. So, we repeat the search process on the left subtree by calling the method again with the left subtree as the new root.\\n\\n1. If the target value val is greater than the root\\'s value, we know the node we want must be in the right subtree. So, we repeat the search process on the right subtree by calling the method again with the right subtree as the new root.\\n\\n1. We continue this process recursively until we find the node with the target value or reach a dead-end (a leaf node) in the tree. If we reach a dead-end and still haven\\'t found the value, we return null to indicate that the value is not present in the tree.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time it takes to find the value in the binary search tree depends on the height of the tree. In the best case (a balanced tree), the height is relatively small, and the search is quick, taking logarithmic time (O(log n)), where n is the number of nodes in the tree. However, in the worst case (a skewed tree), the height can be equal to the number of nodes, resulting in a linear search that takes O(n) time.\\n\\n\\n- Space complexity:\\nThe space required by the recursive approach depends on the height of the tree as well. For each recursive call, some space is used to keep track of the current node and the next nodes to explore. In the best and average cases (balanced tree), the space complexity is O(log n). In the worst case (skewed tree), the space complexity is O(n).\\n\\n# Code\\n```java []\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        // If the root is null or its value is equal to the target value, return the root\\n        if (root == null || root.val == val) {\\n            return root;\\n        }\\n        \\n        // If the target value is less than the root\\'s value, search in the left subtree\\n        if (val < root.val) {\\n            return searchBST(root.left, val);\\n        } else {\\n            // If the target value is greater than the root\\'s value, search in the right subtree\\n            return searchBST(root.right, val);\\n        }\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution(object):\\n    def searchBST(self, root, val):\\n        # If the root is None or its value is equal to the target value, return the root\\n        if not root or root.val == val:\\n            return root\\n        \\n        # If the target value is less than the root\\'s value, search in the left subtree\\n        if val < root.val:\\n            return self.searchBST(root.left, val)\\n        else:\\n            # If the target value is greater than the root\\'s value, search in the right subtree\\n            return self.searchBST(root.right, val)\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        // If the root is NULL or its value is equal to the target value, return the root\\n        if (!root || root->val == val) {\\n            return root;\\n        }\\n\\n        // If the target value is less than the root\\'s value, search in the left subtree\\n        if (val < root->val) {\\n            return searchBST(root->left, val);\\n        } else {\\n            // If the target value is greater than the root\\'s value, search in the right subtree\\n            return searchBST(root->right, val);\\n        }\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/58e314db-5e8d-4d23-9d0f-4f6f35e25002_1689872832.2468483.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```java []\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        // If the root is null or its value is equal to the target value, return the root\\n        if (root == null || root.val == val) {\\n            return root;\\n        }\\n        \\n        // If the target value is less than the root\\'s value, search in the left subtree\\n        if (val < root.val) {\\n            return searchBST(root.left, val);\\n        } else {\\n            // If the target value is greater than the root\\'s value, search in the right subtree\\n            return searchBST(root.right, val);\\n        }\\n    }\\n}\\n\\n```\n```python []\\nclass Solution(object):\\n    def searchBST(self, root, val):\\n        # If the root is None or its value is equal to the target value, return the root\\n        if not root or root.val == val:\\n            return root\\n        \\n        # If the target value is less than the root\\'s value, search in the left subtree\\n        if val < root.val:\\n            return self.searchBST(root.left, val)\\n        else:\\n            # If the target value is greater than the root\\'s value, search in the right subtree\\n            return self.searchBST(root.right, val)\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        // If the root is NULL or its value is equal to the target value, return the root\\n        if (!root || root->val == val) {\\n            return root;\\n        }\\n\\n        // If the target value is less than the root\\'s value, search in the left subtree\\n        if (val < root->val) {\\n            return searchBST(root->left, val);\\n        } else {\\n            // If the target value is greater than the root\\'s value, search in the right subtree\\n            return searchBST(root->right, val);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614525,
                "title": "c-concise-and-simple-solution-100-easy-to-understand-recursion-and-iteration",
                "content": "# Approach 1 :\\n<!-- Describe your approach to solving the problem. -->\\nIterative Search by comparing values until you encounter a NULL node or Required Node.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(h)** --> h is height of the BST\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(1)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while (root != nullptr && root->val != val) {\\n            root = (root->val > val) ? root->left : root->right;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n---\\n\\n# Approach 2 :\\n<!-- Describe your approach to solving the problem. -->\\nRecursively Search by comparing values and return node when condition satisfied.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(h)** --> h is height of the BST\\n**O(n)** --> worst case it will have only 1 node in every level. (Linked List case)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(h)** --> h is height of the BST\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(!root) return NULL;\\n        if(root->val == val) return root;\\n        else if(root->val < val) return searchBST(root->right, val);\\n        else return searchBST(root->left, val);\\n    }\\n};\\n```\\n\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while (root != nullptr && root->val != val) {\\n            root = (root->val > val) ? root->left : root->right;\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(!root) return NULL;\\n        if(root->val == val) return root;\\n        else if(root->val < val) return searchBST(root->right, val);\\n        else return searchBST(root->left, val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2859373,
                "title": "search-in-a-bst-java-recursive-iterative-stack-clean-simple",
                "content": "**1. Recursive approach:**\\n\\n```\\n    // Time Complexity: O(log n), worst case O(h)\\n    // Space Complexity: O(h)\\n    // n -> number of nodes in the tree\\n    // h -> height of the tree\\n    public TreeNode recursiveUsingSearchBST(TreeNode root, int val) {\\n        if (root == null) return root;\\n        if (val < root.val) return recursiveUsingSearchBST(root.left, val);\\n        if (val > root.val) return recursiveUsingSearchBST(root.right, val);\\n        return root;\\n    }\\n```\\n\\n**2. Iterative approach:**\\n\\n```\\n    // Time Complexity: O(log n)\\n    // Space Complexity: O(1)\\n    public TreeNode iterativeUsingSearchBST(TreeNode root, int val) {\\n        while (root != null && root.val != val) {\\n            root = val < root.val ? root.left : root.right;\\n        }\\n\\n        return root;\\n    }\\n```\\n**3. Stack approach:**\\n\\n```\\n    // Time Complexity: O(log n) or O(h)\\n    // Space Complexity: O(h)\\n    // n -> number of nodes in the tree\\n    // h -> height of the tree\\n    public TreeNode stackUsingSearchBST(TreeNode root, int val) {\\n        if (root == null || root.val == val) {\\n            return root;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root.val > val) {\\n            stack.push(root.left);\\n        } else {\\n            stack.push(root.right);\\n        }\\n        while (!stack.isEmpty()) {\\n            TreeNode currentNode = stack.pop();\\n            if (currentNode != null) {\\n                if (currentNode.val == val) {\\n                    return currentNode;\\n                }\\n                if (currentNode.val > val) {\\n                    stack.push(currentNode.left);\\n                } else {\\n                    stack.push(currentNode.right);\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n    // Time Complexity: O(log n), worst case O(h)\\n    // Space Complexity: O(h)\\n    // n -> number of nodes in the tree\\n    // h -> height of the tree\\n    public TreeNode recursiveUsingSearchBST(TreeNode root, int val) {\\n        if (root == null) return root;\\n        if (val < root.val) return recursiveUsingSearchBST(root.left, val);\\n        if (val > root.val) return recursiveUsingSearchBST(root.right, val);\\n        return root;\\n    }\\n```\n```\\n    // Time Complexity: O(log n)\\n    // Space Complexity: O(1)\\n    public TreeNode iterativeUsingSearchBST(TreeNode root, int val) {\\n        while (root != null && root.val != val) {\\n            root = val < root.val ? root.left : root.right;\\n        }\\n\\n        return root;\\n    }\\n```\n```\\n    // Time Complexity: O(log n) or O(h)\\n    // Space Complexity: O(h)\\n    // n -> number of nodes in the tree\\n    // h -> height of the tree\\n    public TreeNode stackUsingSearchBST(TreeNode root, int val) {\\n        if (root == null || root.val == val) {\\n            return root;\\n        }\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root.val > val) {\\n            stack.push(root.left);\\n        } else {\\n            stack.push(root.right);\\n        }\\n        while (!stack.isEmpty()) {\\n            TreeNode currentNode = stack.pop();\\n            if (currentNode != null) {\\n                if (currentNode.val == val) {\\n                    return currentNode;\\n                }\\n                if (currentNode.val > val) {\\n                    stack.push(currentNode.left);\\n                } else {\\n                    stack.push(currentNode.right);\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1944840,
                "title": "c-iterative-o-logn-solution-with-explaination-sc-o-1",
                "content": "seaching in BST is similliar as binary search in sorted array. what we do is first we check if root has the target value than we return root \\nif root doesn\\'t have target value than \\n* we compare root value with target if value is greater than root than our ans root will lie in left subtree because in BST all left child is smaller than root and all right child is greater than root in terms of value stored so we simply asign root to root->left\\n* if root value is lesser than target than our answer root will lie in the right subtree because we want larger value than root\\'s value which we can get in only right subtree of that root so we simply assign root to root->right.\\n\\nwe repeat the above process until we get our ans or root is NULL. if answer exist than our loop will return that root otherwise at last we will return nullptr.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        \\n        while(root!=nullptr){\\n            if(root->val == val) return root;\\n            else if(root->val > val) root=root->left;\\n            else root=root->right;\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        \\n        while(root!=nullptr){\\n            if(root->val == val) return root;\\n            else if(root->val > val) root=root->left;\\n            else root=root->right;\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684440,
                "title": "small-c-code-3-lines-75-faster-iterative-solution",
                "content": "**Please Upvote if you like..:)**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root)\\n        {\\n            if(root->val == val) return root;\\n            if(root->val >= val) root=root->left;\\n            else root=root->right;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root)\\n        {\\n            if(root->val == val) return root;\\n            if(root->val >= val) root=root->left;\\n            else root=root->right;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563432,
                "title": "python-simple-recursive-solution-one-line",
                "content": "**Python :**\\n\\n```\\ndef searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n\\tif not root:\\n\\t\\treturn None\\n\\n\\tif root.val < val:\\n\\t\\treturn self.searchBST(root.right, val)\\n\\n\\telif root.val > val:\\n\\t\\treturn self.searchBST(root.left, val)\\n\\n\\telse:\\n\\t\\treturn root\\n```\\n\\n**and in one line :**\\n\\n```\\ndef searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n\\treturn self.searchBST(root.right, val) if root and root.val < val else self.searchBST(root.left, val) if root and  root.val > val else root\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n\\tif not root:\\n\\t\\treturn None\\n\\n\\tif root.val < val:\\n\\t\\treturn self.searchBST(root.right, val)\\n\\n\\telif root.val > val:\\n\\t\\treturn self.searchBST(root.left, val)\\n\\n\\telse:\\n\\t\\treturn root\\n```\n```\\ndef searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n\\treturn self.searchBST(root.right, val) if root and root.val < val else self.searchBST(root.left, val) if root and  root.val > val else root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1545192,
                "title": "4-line-solution-c",
                "content": "```\\nTreeNode* searchBST(TreeNode* root, int val) { \\n      if(!root) return NULL;\\n      if(root->val == val) return root;\\n      if(root->val < val) return searchBST(root->right, val);\\n      else return searchBST(root->left, val);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* searchBST(TreeNode* root, int val) { \\n      if(!root) return NULL;\\n      if(root->val == val) return root;\\n      if(root->val < val) return searchBST(root->right, val);\\n      else return searchBST(root->left, val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1329527,
                "title": "easy-2-liner-0ms-solution",
                "content": "```\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        \\n        if(root == null) return null;\\n        \\n        return root.val == val ? root : val > root.val ? searchBST(root.right, val) : searchBST(root.left, val);        \\n                \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        \\n        if(root == null) return null;\\n        \\n        return root.val == val ? root : val > root.val ? searchBST(root.right, val) : searchBST(root.left, val);        \\n                \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1046232,
                "title": "c-super-simle-clear-solution-iterative-5-lines",
                "content": "\\tpublic class Solution {\\n\\t\\tpublic TreeNode SearchBST(TreeNode root, int val) {\\n\\t\\t\\twhile (root != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( val < root.val ) root = root.left;\\n\\t\\t\\t\\telse if ( val > root.val ) root = root.right;\\n\\t\\t\\t\\telse return root;\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic TreeNode SearchBST(TreeNode root, int val) {\\n\\t\\t\\twhile (root != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( val < root.val ) root = root.left;\\n\\t\\t\\t\\telse if ( val > root.val ) root = root.right;\\n\\t\\t\\t\\telse return root;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1046218,
                "title": "python-super-simple-clear-solution-iterative-5-lines",
                "content": "\\tclass Solution:\\n\\t\\tdef searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n\\t\\t\\twhile root:\\n\\t\\t\\t\\tif val < root.val: root = root.left\\n\\t\\t\\t\\telif val > root.val: root = root.right\\n\\t\\t\\t\\telse: return root\\n\\t\\t\\treturn root",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n\\t\\t\\twhile root:\\n\\t\\t\\t\\tif val < root.val: root = root.left\\n\\t\\t\\t\\telif val > root.val: root = root.right\\n\\t\\t\\t\\telse: return root\\n\\t\\t\\treturn root",
                "codeTag": "Java"
            },
            {
                "id": 787675,
                "title": "c-simple-and-short-recursive-solution",
                "content": "```\\nstruct TreeNode* searchBST(struct TreeNode* root, int val){\\n    if (!root)\\n        return NULL;\\n    if (root->val == val)\\n        return root;\\n    if (val < root->val)\\n        return searchBST(root->left, val);\\n    else\\n        return searchBST(root->right, val);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct TreeNode* searchBST(struct TreeNode* root, int val){\\n    if (!root)\\n        return NULL;\\n    if (root->val == val)\\n        return root;\\n    if (val < root->val)\\n        return searchBST(root->left, val);\\n    else\\n        return searchBST(root->right, val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748538,
                "title": "java-most-simple-1-line-no-recursion-beats-100",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(log N)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null && root.val != val){\\n            root=root.val<val?root.right:root.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null && root.val != val){\\n            root=root.val<val?root.right:root.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460104,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL) return root;\\n        if(root->val==val) return root;\\n        if(root->val>val) return searchBST(root->left,val);\\n        else return searchBST(root->right,val);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n\\n        def bst(node):\\n            if not node:\\n                return None\\n\\n            if val > node.val:\\n                return bst(node.right)\\n            elif val < node.val:\\n                return bst(node.left)\\n            else:\\n                return node\\n            \\n            return None\\n\\n        return bst(root)\\n```\\n\\n```Java []\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while (root!=null) {\\n            if (root.val==val) {\\n                return root;\\n            }  \\n            else if (root.val<val) {\\n                root = root.right;\\n            }\\n            else {\\n                root = root.left;\\n            } \\n        }\\n        return null;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL) return root;\\n        if(root->val==val) return root;\\n        if(root->val>val) return searchBST(root->left,val);\\n        else return searchBST(root->right,val);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n\\n        def bst(node):\\n            if not node:\\n                return None\\n\\n            if val > node.val:\\n                return bst(node.right)\\n            elif val < node.val:\\n                return bst(node.left)\\n            else:\\n                return node\\n            \\n            return None\\n\\n        return bst(root)\\n```\n```Java []\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while (root!=null) {\\n            if (root.val==val) {\\n                return root;\\n            }  \\n            else if (root.val<val) {\\n                root = root.right;\\n            }\\n            else {\\n                root = root.left;\\n            } \\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445566,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL || root->val==val){\\n            return root;\\n        }\\n        if(root->val>val){\\n            return searchBST(root->left,val);\\n        }\\n        else{\\n            return searchBST(root->right,val);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL || root->val==val){\\n            return root;\\n        }\\n        if(root->val>val){\\n            return searchBST(root->left,val);\\n        }\\n        else{\\n            return searchBST(root->right,val);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419054,
                "title": "java-fastest-code-explained-deeply",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(H) H is height of tree\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/eca22e69-4359-4468-ab13-98584e3b6435_1681551356.0869029.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        \\n        // Check if the root node is null or if the root value matches the input value\\n        if(root == null || root.val == val) {\\n            // If so, return the root node (which may be null)\\n            return root;\\n        }\\n    \\n        // If the input value is less than the root value, search the left subtree recursively\\n        if(val < root.val) {\\n            return searchBST(root.left, val);\\n        }\\n        // Otherwise, search the right subtree recursively\\n        else {\\n            return searchBST(root.right, val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        \\n        // Check if the root node is null or if the root value matches the input value\\n        if(root == null || root.val == val) {\\n            // If so, return the root node (which may be null)\\n            return root;\\n        }\\n    \\n        // If the input value is less than the root value, search the left subtree recursively\\n        if(val < root.val) {\\n            return searchBST(root.left, val);\\n        }\\n        // Otherwise, search the right subtree recursively\\n        else {\\n            return searchBST(root.right, val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267934,
                "title": "best-o-h-solution",
                "content": "# Approach 1\\nRecursive Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root == NULL)\\n            return NULL;\\n        if (root->val == val)\\n            return root;\\n        if (root->val > val)\\n            return searchBST(root->left, val);\\n        else\\n            return searchBST(root->right, val);        \\n    }\\n};\\n```\\n\\n# Approach 2\\nIterative Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while (root != NULL && root->val != val) {\\n            if (root->val > val)\\n                root = root->left;\\n            else\\n                root = root->right;    \\n        }\\n        return root;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root == NULL)\\n            return NULL;\\n        if (root->val == val)\\n            return root;\\n        if (root->val > val)\\n            return searchBST(root->left, val);\\n        else\\n            return searchBST(root->right, val);        \\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while (root != NULL && root->val != val) {\\n            if (root->val > val)\\n                root = root->left;\\n            else\\n                root = root->right;    \\n        }\\n        return root;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219320,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while (root != null) {\\n            if (val < root.val) root = root.left;\\n            else if (val > root.val) root = root.right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while (root != null) {\\n            if (val < root.val) root = root.left;\\n            else if (val > root.val) root = root.right;\\n            else return root;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104341,
                "title": "beats-100-java-iterative-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null && root.val != val)\\n        {\\n            root = (val > root.val) ? root.right : root.left; \\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null && root.val != val)\\n        {\\n            root = (val > root.val) ? root.right : root.left; \\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802276,
                "title": "java",
                "content": "If you like it pls upvote\\n```\\n\\npublic TreeNode searchBST(TreeNode root, int val) {\\n    while (root != null && root.val != val) {\\n        root = root.val > val ? root.left : root.right;\\n    }\\n    return root;\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\npublic TreeNode searchBST(TreeNode root, int val) {\\n    while (root != null && root.val != val) {\\n        root = root.val > val ? root.left : root.right;\\n    }\\n    return root;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2752301,
                "title": "java-dfs-in-just-0-ms-2-solutions",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Solution 1: 1 ms | 10% faster\\n```\\nclass Solution {\\n    \\n    TreeNode result;\\n    \\n    public TreeNode searchBST(TreeNode root, int val) {\\n        result = null;\\n        searchInBST(root, val);\\n        return result;\\n    }\\n\\n    private void searchInBST(TreeNode node, int val) {\\n        if (node == null) return;\\n\\n        if (val == node.val) {\\n            result = node;\\n            return;\\n        }\\n\\n        searchInBST(node.left, val);\\n        searchInBST(node.right, val);\\n    }\\n}\\n```\\n\\n# Solution 2: 0 ms | 100% faster\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        if (root.left == null && root.right == null) return null;\\n        if (root.left != null && root.left.val == val) return root.left;\\n        if (root.right != null && root.right.val == val) return root.right;\\n\\n        TreeNode result = searchBST(root.left, val);\\n        if (result != null) {\\n            return result;\\n        } else {\\n            return searchBST(root.right, val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    TreeNode result;\\n    \\n    public TreeNode searchBST(TreeNode root, int val) {\\n        result = null;\\n        searchInBST(root, val);\\n        return result;\\n    }\\n\\n    private void searchInBST(TreeNode node, int val) {\\n        if (node == null) return;\\n\\n        if (val == node.val) {\\n            result = node;\\n            return;\\n        }\\n\\n        searchInBST(node.left, val);\\n        searchInBST(node.right, val);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        if (root.left == null && root.right == null) return null;\\n        if (root.left != null && root.left.val == val) return root.left;\\n        if (root.right != null && root.right.val == val) return root.right;\\n\\n        TreeNode result = searchBST(root.left, val);\\n        if (result != null) {\\n            return result;\\n        } else {\\n            return searchBST(root.right, val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749415,
                "title": "c-recursive-easy-code",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root && root->val!=val){\\n            root=root->val>val?root->left:root->right;\\n        }\\n        return root;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root && root->val!=val){\\n            root=root->val>val?root->left:root->right;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2690134,
                "title": "java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null){\\n            return null;\\n        }\\n        if(root.val == val){\\n            return root;\\n        }else if(root.val < val){\\n            return searchBST(root.right,val);\\n        }else{\\n            return searchBST(root.left,val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null){\\n            return null;\\n        }\\n        if(root.val == val){\\n            return root;\\n        }else if(root.val < val){\\n            return searchBST(root.right,val);\\n        }else{\\n            return searchBST(root.left,val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180667,
                "title": "python3-binary-search-faster-than-96",
                "content": "```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        \\n        def search(root):\\n            if root == None:\\n                return None\\n            if root.val == val:\\n                return root\\n            if val < root.val:\\n                return search(root.left)\\n            else:\\n                return search(root.right)\\n        \\n        return search(root)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        \\n        def search(root):\\n            if root == None:\\n                return None\\n            if root.val == val:\\n                return root\\n            if val < root.val:\\n                return search(root.left)\\n            else:\\n                return search(root.right)\\n        \\n        return search(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946472,
                "title": "js-simple-explained-optimal-solution",
                "content": "# 700. Search in a Binary Search Tree \\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n<!-- ### Index:\\n1. [Explaining the Question](#explaining-the-question)\\n2. [Recommended Knowledge](#what-do-we-know)\\n3. [What do we know](#recommended-knowledge)\\n4. [Solution Explanation](#how-were-going-to-do-it)\\n5. [Big *O* Notation](#big-o-notation)\\n6. [Leetcode Results](#leetcode-results)\\n7. [Solution](#the-solution) -->\\n\\n## Explaining The Question\\nSo we\\'re given a number and must locate it in the tree.\\nWe can now perform our standard DFS or BFS algos, but this is a binary search tree. That is, we can use a divide and conquer algorithm to find exactly what we are looking for by halving the size of the tree with each node we traverse. Super fast.\\n\\n\\nThink of it like using Binary search on a sorted array.\\n\\nA Binary Search Tree is a tree that has been sorted in such a way that we can move through it at breakneck speed. At each node, the value to the left is less than the current value, and the value to the right is greater than the current value. That\\'s it.\\n\\n***\\n\\n##  Recommended Knowledge\\n1. Binary Trees\\n2. Binary Search Trees\\n3. Recursive Searching in a tree\\n4. How to traverse a Binary Search Tree\\n\\n## What do we know?\\n1. We have a Binary Search Tree and we have to search for a value\\n2. We can do this in ***O(log n)***\\n\\n## How we\\'re going to do it:\\n1. We\\'re going to go to every node and ask if the given value is greater than or less than the value we need to find. \\n2. So firstly, we\\'re going to do this recursively. Meaning, we need to check every node for every possible outcome. \\n3. Firstly we ask, is this node a ***leaf node*** ? In this case, we reached the end of the list never finding what we looked for.\\n4. We then ask, \\'Is the current node the one we have been searching for?\\' we do this by comparing values. If they\\'re the same, we found it so we return the node.\\n5. Now we need to know where to go next if we never found it, do we go left or right? If the current value is greater than what we\\'re searching for, we go left as we know the left values are always lesser than the current value and thus our value will be on the left side. The same logic applies to the right node, where if the current value is lesser than the value we\\'re looking for, we go right as we know that\\'s where the larger number are.\\n6. We repeat this until we reach the end of the list or what we came looking for.\\n\\n## Big O Notation:\\n* Time Complexity:   *O(**log n**)* | Where ***n*** is the number of nodes the tree has and ***log*** because we\\'re half-ing the search tree on every move. It\\'s logarithmic. We\\'re using a ***divide and conquer*** algorithm\\n* Space Complexity: *O(**1**)* | As we never allocate any extra space or have the need to bubble up in the call stack.\\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 72 ms, faster than ***97.71%*** of JavaScript online submissions for Search in a Binary Search Tree\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/680109112/)\\n\\n\\n***\\n\\n# The Solution\\n```\\nvar searchBST = function (root, val) {\\n    \\n\\t// We have reached a leaf node\\n\\t// This mean\\'s we never found the\\n\\t// node we was looking for.\\n\\tif (!root) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// We found the node we\\'re looking for\\n\\t// Return it.\\n\\tif (root.val === val) {\\n\\t\\treturn root;\\n\\t}\\n\\n\\t// The 2 parts below only make sense if you understand\\n\\t// Binary Search Trees. It helps if you understand divide and conquer algorithms.\\n\\t// Like Binary search.\\n\\n\\t// So we know the value we\\'re looking for\\n\\t// if greater than the current node, thus\\n\\t// the node we\\'re looking for is somewhere on the right tree\\n\\tif (val > root.val) {\\n\\t\\treturn searchBST(root.right, val);\\n\\t}\\n\\n\\t// So the value we\\'re searching for is less than the current node\\n\\t// which means the node we\\'re looking for exists somewhere on\\n\\t// the left side.\\n\\tif (val < root.val) {\\n\\t\\treturn searchBST(root.left, val);\\n\\t}\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nvar searchBST = function (root, val) {\\n    \\n\\t// We have reached a leaf node\\n\\t// This mean\\'s we never found the\\n\\t// node we was looking for.\\n\\tif (!root) {\\n\\t\\treturn null;\\n\\t}\\n\\n\\t// We found the node we\\'re looking for\\n\\t// Return it.\\n\\tif (root.val === val) {\\n\\t\\treturn root;\\n\\t}\\n\\n\\t// The 2 parts below only make sense if you understand\\n\\t// Binary Search Trees. It helps if you understand divide and conquer algorithms.\\n\\t// Like Binary search.\\n\\n\\t// So we know the value we\\'re looking for\\n\\t// if greater than the current node, thus\\n\\t// the node we\\'re looking for is somewhere on the right tree\\n\\tif (val > root.val) {\\n\\t\\treturn searchBST(root.right, val);\\n\\t}\\n\\n\\t// So the value we\\'re searching for is less than the current node\\n\\t// which means the node we\\'re looking for exists somewhere on\\n\\t// the left side.\\n\\tif (val < root.val) {\\n\\t\\treturn searchBST(root.left, val);\\n\\t}\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945782,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        \\n        // Case where root is equal to null meaning we have reached the end of the tree traversal\\n        if(root == null){\\n            return null;\\n        }\\n        \\n        if(root.val == val){\\n\\t\\t\\t// Case where root value is equal to value searched, TreeNode found\\n            return root;\\n        }else if(root.val > val){\\n            // Case where the root value is greater than value searched, therefore we have to search on left side\\n            return searchBST(root.left, val);\\n        }else{\\n            // Case where the root value is smaller than value searched, therefore we have to search on right side\\n            return searchBST(root.right, val);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        \\n        // Case where root is equal to null meaning we have reached the end of the tree traversal\\n        if(root == null){\\n            return null;\\n        }\\n        \\n        if(root.val == val){\\n\\t\\t\\t// Case where root value is equal to value searched, TreeNode found\\n            return root;\\n        }else if(root.val > val){\\n            // Case where the root value is greater than value searched, therefore we have to search on left side\\n            return searchBST(root.left, val);\\n        }else{\\n            // Case where the root value is smaller than value searched, therefore we have to search on right side\\n            return searchBST(root.right, val);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945689,
                "title": "simple-binary-search-easy-to-understand-python",
                "content": "Since the given tree is Binary Search Tree, It follows the rule that :\\n1. value of right node is greater than the value  of current node .\\n2. value of left node is less than the value of current node.\\n\\nOn the basis of above information we can perform searching in following steps:\\n1. while with condition current node not equal to None.\\n\\ta. If required value is equal to value current node then return the node.\\n\\tb. if required value > value of current node then update current node to current node\\'s right node.\\n\\tc. if required value < value of current node then update current node to current node\\'s left node.\\n2. return Null outside while loop (if no such node found then we have to reutrn NULL (None in case of python))\\n\\n\\nPython Code:\\n\\n\\n    \\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        \\n        temp=root\\n        while(temp!=None):\\n            if temp.val==val: \\n                return temp\\n            elif val>temp.val:\\n                temp=temp.right\\n            else:\\n                temp=temp.left\\n        return None\\n\\n\\n",
                "solutionTags": [],
                "code": "Since the given tree is Binary Search Tree, It follows the rule that :\\n1. value of right node is greater than the value  of current node .\\n2. value of left node is less than the value of current node.\\n\\nOn the basis of above information we can perform searching in following steps:\\n1. while with condition current node not equal to None.\\n\\ta. If required value is equal to value current node then return the node.\\n\\tb. if required value > value of current node then update current node to current node\\'s right node.\\n\\tc. if required value < value of current node then update current node to current node\\'s left node.\\n2. return Null outside while loop (if no such node found then we have to reutrn NULL (None in case of python))\\n\\n\\nPython Code:\\n\\n\\n    \\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        \\n        temp=root\\n        while(temp!=None):\\n            if temp.val==val: \\n                return temp\\n            elif val>temp.val:\\n                temp=temp.right\\n            else:\\n                temp=temp.left\\n        return None\\n\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1944579,
                "title": "python3-simple-3-lines",
                "content": "Trees can be traversed using either one of the following approaches:\\n1. Inorder\\n2. Preorder\\n3. Postorder \\n4. BFS\\n5. DFS\\n\\nBut for the given problem, we are using **B**inary **S**earch **T**ree and BST has an important property which we can rely on to reduce the overall time for traversal:\\n**`Each node in the tree has a key which is greater than all the keys in the left subtree and smaller than those in the right subtree`**\\n\\n\\n**The recursive solution:** \\n```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root or root.val == val:\\n            return root        \\n        return self.searchBST(root.left, val) if val < root.val else self.searchBST(root.right, val)\\n```\\n**Time Complexity** : **O(h)** where **h** is height of the tree. The **h** can be either **logN**  if its balanced tree or **N** if its a skewed tree.\\n**Space Complexity**: **O(h)** where **h** is height of the tree. The **h** can be either **logN**  if its balanced tree or **N** if its a skewed tree.\\n\\nI usually don\\'t like to write a recursive solution in languages which doesn\\'t support tail recursion optimization. As I usually prefer Python for my solutions, I came up with an iterative solution:\\n\\n```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        while root and root.val != val:\\n            root = root.left if val < root.val else root.right\\n        return root\\n```\\n\\n**Time Complexity** : **O(h)** where **h** is height of the tree. The **h** can be either **logN**  if its balanced tree or **N** if its a skewed tree.\\n**Space Complexity**: **O(1)**\\n____________________________________________________________________________________________________________\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root or root.val == val:\\n            return root        \\n        return self.searchBST(root.left, val) if val < root.val else self.searchBST(root.right, val)\\n```\n```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        while root and root.val != val:\\n            root = root.left if val < root.val else root.right\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108914,
                "title": "c-iterative-and-recursive-solution",
                "content": "```\\n // Recursive Solution\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root == nullptr || val == root->val)\\n            return root;\\n        if (val < root->val)\\n            return searchBST(root->left, val);\\n        return searchBST(root->right, val);\\n    }\\n    \\n    // Iterative Solution\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while (root && root->val != val)\\n            root = (val < root->val)?root->left:root->right;\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n // Recursive Solution\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root == nullptr || val == root->val)\\n            return root;\\n        if (val < root->val)\\n            return searchBST(root->left, val);\\n        return searchBST(root->right, val);\\n    }\\n    \\n    // Iterative Solution\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while (root && root->val != val)\\n            root = (val < root->val)?root->left:root->right;\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002354,
                "title": "python-very-concise-iterative-solution",
                "content": "```\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        while root and val != root.val:\\n            root = root.left if val < root.val else root.right\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        while root and val != root.val:\\n            root = root.left if val < root.val else root.right\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 688346,
                "title": "easy-recursive-python-solution",
                "content": "**Time O(n) Space O(n)**\\n```\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return None\\n        \\n        elif root.val==val:\\n            return root\\n        \\n        elif root.val>val:\\n            return self.searchBST(root.left,val)\\n        \\n        elif root.val<val:\\n            return self.searchBST(root.right,val)\\n            \\n            \\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return None\\n        \\n        elif root.val==val:\\n            return root\\n        \\n        elif root.val>val:\\n            return self.searchBST(root.left,val)\\n        \\n        elif root.val<val:\\n            return self.searchBST(root.right,val)\\n            \\n            \\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 688317,
                "title": "java-simple-recursive-solution",
                "content": "By using the property of BST we can easily solve this problem.\\n\\n```\\n public TreeNode searchBST(TreeNode root, int val) {\\n        \\n        if (root == null) {\\n            return root;\\n        }\\n        \\n        if(root.val == val) {\\n            return root;\\n        }\\n        \\n        if(val > root.val) {\\n            return searchBST(root.right, val);\\n        }\\n        \\n        return searchBST(root.left, val);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public TreeNode searchBST(TreeNode root, int val) {\\n        \\n        if (root == null) {\\n            return root;\\n        }\\n        \\n        if(root.val == val) {\\n            return root;\\n        }\\n        \\n        if(val > root.val) {\\n            return searchBST(root.right, val);\\n        }\\n        \\n        return searchBST(root.left, val);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 385050,
                "title": "javascript-recursive-dfs-with-clearly-written-comments",
                "content": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} val\\n * @return {TreeNode}\\n */\\nvar searchBST = function(root, val) {\\n  return dfs(root);\\n\\n  function dfs(node) {\\n\\tif (node == null) { /* our base case which we will reach at leaf nodes */\\n      return null; /* the path just traversed doesn\\'t contain the target so we return null */\\n    } else {\\n      if (node.val === val) {\\n        return node; /* exact match to our target val, return the subtree rooted at the current node */\\n      }\\n      /* target not yet found, compare node.val to target and traverse the left/right subtrees accordingly */\\n      if (node.val > val) {\\n        return dfs(node.left);\\n      }\\n      if (node.val < val) {\\n        return dfs(node.right);\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```javascript\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} val\\n * @return {TreeNode}\\n */\\nvar searchBST = function(root, val) {\\n  return dfs(root);\\n\\n  function dfs(node) {\\n\\tif (node == null) { /* our base case which we will reach at leaf nodes */\\n      return null; /* the path just traversed doesn\\'t contain the target so we return null */\\n    } else {\\n      if (node.val === val) {\\n        return node; /* exact match to our target val, return the subtree rooted at the current node */\\n      }\\n      /* target not yet found, compare node.val to target and traverse the left/right subtrees accordingly */\\n      if (node.val > val) {\\n        return dfs(node.left);\\n      }\\n      if (node.val < val) {\\n        return dfs(node.right);\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 263927,
                "title": "100-golang-solution",
                "content": "```\\nfunc searchBST(root *TreeNode, val int) *TreeNode {\\n    if root==nil {\\n        return nil\\n    }\\n    if val==root.Val {\\n        return root\\n    } else if val > root.Val {\\n        return searchBST(root.Right,val)\\n    } \\n    return searchBST(root.Left,val)\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc searchBST(root *TreeNode, val int) *TreeNode {\\n    if root==nil {\\n        return nil\\n    }\\n    if val==root.Val {\\n        return root\\n    } else if val > root.Val {\\n        return searchBST(root.Right,val)\\n    } \\n    return searchBST(root.Left,val)\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 149553,
                "title": "python-3-lines-o-n-time-o-1-memory",
                "content": "```\\ndef searchBST(self, root, val):\\n        while root and root.val != val:\\n            root = root.left if val < root.val else root.right\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\ndef searchBST(self, root, val):\\n        while root and root.val != val:\\n            root = root.left if val < root.val else root.right\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3985721,
                "title": "java-easy-to-understand-100-faster",
                "content": "# Complexity\\n- Time complexity: O(n) where n = No. of Nodes\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null){\\n            if(root.val>val){\\n                root=root.left;\\n            }\\n            else if(root.val<val){\\n                root=root.right;\\n            }\\n            else{\\n                return root;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null){\\n            if(root.val>val){\\n                root=root.left;\\n            }\\n            else if(root.val<val){\\n                root=root.right;\\n            }\\n            else{\\n                return root;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876815,
                "title": "simple-bst-beats-100",
                "content": "\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root!=null) {\\n            if(root.val == val) {\\n                return root;\\n            }else if(root.val > val) {\\n                return searchBST(root.left,val);\\n            }else{\\n                return searchBST(root.right,val);\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n![upv.jpeg](https://assets.leetcode.com/users/images/b62c59fe-cb8f-4a4d-a659-8fe6f5175f26_1691412501.8096478.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root!=null) {\\n            if(root.val == val) {\\n                return root;\\n            }else if(root.val > val) {\\n                return searchBST(root.left,val);\\n            }else{\\n                return searchBST(root.right,val);\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597310,
                "title": "simplest-python-solution-using-recursion-in-7-lines-of-code",
                "content": "# Intuition\\nOn seeing this problem initially, I instantly thought of applying recursion by searching through the root node and recursively calling the function for left and right subtrees until we reach the leaf nodes.\\n\\n# Approach\\n* First, we check if the root is not None. This acts as the base case for the recursive algorithm.\\n* Then we have three cases:\\n  * Value of the root = target\\n  * Value of the root > target\\n  * Value of the root < target\\n* If the root value is greater than the target, then we recursively call the function for the left subtree, since it is guaranteed not to be present in the right subtree.\\n* Similarly, If the root value is less than the target, then we recursively call the function for the right subtree, since it is guaranteed not to be present in the left subtree.\\n* If the root value equals the target, then we return the root.\\n* As for unsuccessful cases, the while loop terminates when the root is None and then returns nothing, basically None.\\n\\n# Complexity\\n- Time complexity: \\n  - Average case: $$O(logn)$$\\n  - Best case: $$O(1)$$ (When the root itself is the target)\\n  - Worst case: $$O(n)$$ (When the BST is skewed and takes maximum \\'n\\' traversals)\\n  \\n\\n- Space complexity (call stack):\\n  - Average case: $$O(logn)$$\\n  - Best case: $$O(1)$$ (When the root itself is the target)\\n  - Worst case: $$O(n)$$ (When the BST is skewed and takes maximum \\'n\\' traversals, hence \\'n\\' function calls)\\n\\n# Code\\n```python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root:\\n            if root.val < val:\\n                return self.searchBST(root.right, val)\\n            elif root.val > val:\\n                return self.searchBST(root.left, val)\\n            else:\\n                return root\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root:\\n            if root.val < val:\\n                return self.searchBST(root.right, val)\\n            elif root.val > val:\\n                return self.searchBST(root.left, val)\\n            else:\\n                return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212679,
                "title": "java-easy-0ms-beats-100-simple-like-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while (root!=null) {\\n            if (root.val==val) {\\n                return root;\\n            }  \\n            else if (root.val<val) {\\n                root = root.right;\\n            }\\n            else {\\n                root = root.left;\\n            } \\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while (root!=null) {\\n            if (root.val==val) {\\n                return root;\\n            }  \\n            else if (root.val<val) {\\n                root = root.right;\\n            }\\n            else {\\n                root = root.left;\\n            } \\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114191,
                "title": "beginner-friendly-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root!=NULL && root->val!=val)\\n        {\\n          if(val>root->val)\\n          root=root->right;\\n          else\\n          root=root->left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root!=NULL && root->val!=val)\\n        {\\n          if(val>root->val)\\n          root=root->right;\\n          else\\n          root=root->left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793735,
                "title": "2-line-solution-share-my-code-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root!=NULL and root->val  != val) root = val < root->val ? root->left : root->right;\\n        return root;\\n    }\\n};\\n```\\n<br>\\nPlease do upvote this post.\\n\\n![image](https://assets.leetcode.com/users/images/5ce11bf6-0db9-4239-bbb9-dfe5d76443f3_1666346629.9681695.gif)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root!=NULL and root->val  != val) root = val < root->val ? root->left : root->right;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749253,
                "title": "java-solution-memory-usage-42-4-mb-runtime-0-ms",
                "content": "```\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n\\n        if (root.val > val) {\\n            return searchBST(root.left, val);\\n        } else if (root.val < val) {\\n            return searchBST(root.right, val);\\n        } else {\\n            return root;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n\\n        if (root.val > val) {\\n            return searchBST(root.left, val);\\n        } else if (root.val < val) {\\n            return searchBST(root.right, val);\\n        } else {\\n            return root;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2709212,
                "title": "go-recursion",
                "content": "the main thing is not to forget about the exit from the recursion\\n```\\nfunc searchBST(root *TreeNode, val int) *TreeNode {\\n    switch {\\n        case root==nil:\\n            return nil\\n        case root.Val==val:\\n            return root\\n        case root.Val<val:\\n            return searchBST(root.Right, val)\\n        case root.Val>val:\\n            return searchBST(root.Left, val)\\n    }\\n    return nil\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc searchBST(root *TreeNode, val int) *TreeNode {\\n    switch {\\n        case root==nil:\\n            return nil\\n        case root.Val==val:\\n            return root\\n        case root.Val<val:\\n            return searchBST(root.Right, val)\\n        case root.Val>val:\\n            return searchBST(root.Left, val)\\n    }\\n    return nil\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2663705,
                "title": "java-easy-2line-solution-0ms",
                "content": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null && root.val!=val){\\n            root=val<root.val?root.left:root.right;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null && root.val!=val){\\n            root=val<root.val?root.left:root.right;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642289,
                "title": "java-6-lines-straight-forward-code-for-beginners-recursion-search-in-a-binary-search-tree",
                "content": "**Upvote, if my solution is helpful**\\n\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        \\n        if(root==null) return null;\\n        if(root.val==val) return root;\\n        \\n        TreeNode left = searchBST(root.left,val);\\n        TreeNode right = searchBST(root.right,val);\\n        \\n        if(left!=null) return left;\\n        return right;\\n\\n      \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        \\n        if(root==null) return null;\\n        if(root.val==val) return root;\\n        \\n        TreeNode left = searchBST(root.left,val);\\n        TreeNode right = searchBST(root.right,val);\\n        \\n        if(left!=null) return left;\\n        return right;\\n\\n      \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508885,
                "title": "python-elegant-short-two-solutions-iterative-recursive-three-lines",
                "content": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n\\t\\t\\twhile root is not None and root.val != val:\\n\\t\\t\\t\\troot = root.left if val < root.val else root.right\\n\\t\\t\\treturn root\\n\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n\\t\\t\\tif root is None or root.val == val:\\n\\t\\t\\t\\treturn root\\n\\t\\t\\treturn self.searchBST(root.left if val < root.val else root.right, val)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(1)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n\\t\\t\\twhile root is not None and root.val != val:\\n\\t\\t\\t\\troot = root.left if val < root.val else root.right\\n\\t\\t\\treturn root\\n\\n\\n\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n)\\n\\t\\tMemory: O(n)\\n\\t\\t\"\"\"\\n\\n\\t\\tdef searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n\\t\\t\\tif root is None or root.val == val:\\n\\t\\t\\t\\treturn root\\n\\t\\t\\treturn self.searchBST(root.left if val < root.val else root.right, val)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2220002,
                "title": "0-ms-100-fast-solution-java-implementation-iterative-solution",
                "content": "```\\nclass Solution {\\n    \\n    public TreeNode searchBST(TreeNode root, int val) {\\n        \\n        while(root != null) {\\n            \\n            if(root.val == val) {\\n                return root;\\n            }\\n            \\n            else if(root.val > val) {\\n                root = root.left;\\n            }\\n            \\n            else {\\n                root = root.right;\\n            } \\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public TreeNode searchBST(TreeNode root, int val) {\\n        \\n        while(root != null) {\\n            \\n            if(root.val == val) {\\n                return root;\\n            }\\n            \\n            else if(root.val > val) {\\n                root = root.left;\\n            }\\n            \\n            else {\\n                root = root.right;\\n            } \\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189762,
                "title": "3-lines-c-code-easy-solution-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL) return NULL;\\n        if(root->val == val) return root;\\n        return (root->val > val) ? searchBST(root->left,val) : searchBST(root->right, val);}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL) return NULL;\\n        if(root->val == val) return root;\\n        return (root->val > val) ? searchBST(root->left,val) : searchBST(root->right, val);}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178537,
                "title": "python-simple-and-easy-solution-bst",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        curNode=root\\n        while(curNode):\\n            if curNode.val==val:\\n                return curNode\\n            elif curNode.val>val:\\n                curNode=curNode.left\\n            else:\\n                curNode=curNode.right\\n        return None\\n        \\n```\\n**Please UpVote if it was Helpful :)**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        curNode=root\\n        while(curNode):\\n            if curNode.val==val:\\n                return curNode\\n            elif curNode.val>val:\\n                curNode=curNode.left\\n            else:\\n                curNode=curNode.right\\n        return None\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065472,
                "title": "simple-easy-to-understand-o-logn-time-c",
                "content": "Implementation\\n\\n**Time Complexity : O(logN)\\nSpace Complexity : O(logN)**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root && root->val != val){\\n            root = root->val > val ? root->left : root->right;\\n        }\\n        return root;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root && root->val != val){\\n            root = root->val > val ? root->left : root->right;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017071,
                "title": "python-dfs-solution-easy-1-if-statement-with-explanation-58ms-beats-90",
                "content": "We use classic dfs to traverse through binary search tree. Binary search tree has special characterstic: left child is always less than right child. We use that to our advantage!\\n\\n![image](https://assets.leetcode.com/users/images/bd359471-5307-435f-b492-1d1528777b89_1651948897.9743044.png)\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def searchBST(self, root, val):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type val: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        if root and val < root.val: \\n            return self.searchBST(root.left, val)\\n        elif root and val > root.val: \\n            return self.searchBST(root.right, val)\\n        else:\\n            return root\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def searchBST(self, root, val):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type val: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        if root and val < root.val: \\n            return self.searchBST(root.left, val)\\n        elif root and val > root.val: \\n            return self.searchBST(root.right, val)\\n        else:\\n            return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947431,
                "title": "simple-4-line-recursive-solution-with-comments-in-cpp",
                "content": "```\\n  TreeNode* searchBST(TreeNode* root, int val) {\\n  \\n  //if we get val at root then we will return it , same concept like mid in binary search\\n        if(root==NULL or root->val==val) return root;\\n\\t\\t\\n        //if value of root is greater than value we want to search, we will recursively call the left part of the subtree as it stores small values.\\n        else if(root->val>val)\\n            return searchBST(root->left , val);\\n        //last else condition.\\n        return searchBST(root->right , val);\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n  TreeNode* searchBST(TreeNode* root, int val) {\\n  \\n  //if we get val at root then we will return it , same concept like mid in binary search\\n        if(root==NULL or root->val==val) return root;\\n\\t\\t\\n        //if value of root is greater than value we want to search, we will recursively call the left part of the subtree as it stores small values.\\n        else if(root->val>val)\\n            return searchBST(root->left , val);\\n        //last else condition.\\n        return searchBST(root->right , val);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1946738,
                "title": "0-ms-beginner-friendly-recursion",
                "content": "```\\nclass Solution {  \\n    public TreeNode searchBST(TreeNode root, int val)\\n    {\\n        if(root == null)\\n        {\\n            return null;\\n        }\\n        if(root.val == val)\\n        {\\n            return root;\\n        }\\n        \\n        if(val < root.val)\\n        {\\n            return searchBST(root.left, val);\\n        }\\n        else\\n        {\\n            return searchBST(root.right, val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {  \\n    public TreeNode searchBST(TreeNode root, int val)\\n    {\\n        if(root == null)\\n        {\\n            return null;\\n        }\\n        if(root.val == val)\\n        {\\n            return root;\\n        }\\n        \\n        if(val < root.val)\\n        {\\n            return searchBST(root.left, val);\\n        }\\n        else\\n        {\\n            return searchBST(root.right, val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945008,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root != null && root.val != val){\\n            // if the root value is less than val then move left else move right\\n            root = val < root.val ? root.left : root.right;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root != null && root.val != val){\\n            // if the root value is less than val then move left else move right\\n            root = val < root.val ? root.left : root.right;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944750,
                "title": "easy-c-80-faster-3-lines",
                "content": "```\\nTreeNode* searchBST(TreeNode* root, int val) {\\n    if(root==nullptr or root->val==val) return root;\\n    if(root->val > val) return searchBST(root->left,val);\\n    return searchBST(root->right,val);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* searchBST(TreeNode* root, int val) {\\n    if(root==nullptr or root->val==val) return root;\\n    if(root->val > val) return searchBST(root->left,val);\\n    return searchBST(root->right,val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1944606,
                "title": "100-faster-java-code",
                "content": "```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null)\\n        {\\n            if(root.val==val) return root;\\n            else if(root.val<val)root=root.right;\\n            else if(root.val>val)root=root.left;\\n        }\\n        return root;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null)\\n        {\\n            if(root.val==val) return root;\\n            else if(root.val<val)root=root.right;\\n            else if(root.val>val)root=root.left;\\n        }\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1944516,
                "title": "java-1-liner-2-methods",
                "content": "**Idea:** Searching in a BST is simple: If val > node.val, go right else go left\\n**Method 1:** Recursive\\n>**T/S:** O(n)/O(h), where n = number of nodes in the tree, h = height of the tree\\n```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n\\tif (root == null || root.val == val)\\n\\t\\treturn root;\\n\\tif (val < root.val) \\n\\t\\treturn searchBST(root.left, val);\\n\\treturn searchBST(root.right, val);\\n}\\n```\\n*1 liner variation for Method 1:*\\n```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n\\treturn root == null || root.val == val ? \\n\\troot : \\n\\tval < root.val ? \\n\\tsearchBST(root.left, val) : \\n\\tsearchBST(root.right, val);\\n}\\n```\\n**Method 2:** Iterative (2 liner)\\n>**T/S:** O(n)/O(1)\\n```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n\\twhile (root != null && root.val != val)\\n\\t\\troot = val < root.val ? root.left : root.right;\\n\\treturn root;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n\\tif (root == null || root.val == val)\\n\\t\\treturn root;\\n\\tif (val < root.val) \\n\\t\\treturn searchBST(root.left, val);\\n\\treturn searchBST(root.right, val);\\n}\\n```\n```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n\\treturn root == null || root.val == val ? \\n\\troot : \\n\\tval < root.val ? \\n\\tsearchBST(root.left, val) : \\n\\tsearchBST(root.right, val);\\n}\\n```\n```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n\\twhile (root != null && root.val != val)\\n\\t\\troot = val < root.val ? root.left : root.right;\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1834829,
                "title": "java-easy-solution-faster-than-100-online-submissions",
                "content": "```\\nThe problem statement is clearly variation of Insert Element in BST.\\nWhen given key is less than current node value we have to go to left subtree,\\nand if given key is greater than current node value we go to right subtree.\\n( As per property of BST ).\\nSo if we find any node value equal to key as per question we stop the search and\\nreturn node address. And if we reach end of tree that means key is not present in tree\\nso we return \\' null \\' in JAVA and \\' NULL \\' in C++.\\n```\\n```\\nclass Solution {\\n    TreeNode searchEle(TreeNode root, int val){\\n        if(root==null)\\n            return null;\\n        if(root.val == val)\\n            return root;\\n        else if(root.val <= val)         //current node value is less than key, so our search area would be right subtree\\n            return searchEle(root.right, val);   \\n\\t\\t\\t\\n        return searchEle(root.left, val);       // current node value is greater so our search area is left subtree\\n    }\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        return searchEle(root, val);\\n    }\\n}\\n```\\nIf you like, please upvote !!\\nHappy Coding :)",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nThe problem statement is clearly variation of Insert Element in BST.\\nWhen given key is less than current node value we have to go to left subtree,\\nand if given key is greater than current node value we go to right subtree.\\n( As per property of BST ).\\nSo if we find any node value equal to key as per question we stop the search and\\nreturn node address. And if we reach end of tree that means key is not present in tree\\nso we return \\' null \\' in JAVA and \\' NULL \\' in C++.\\n```\n```\\nclass Solution {\\n    TreeNode searchEle(TreeNode root, int val){\\n        if(root==null)\\n            return null;\\n        if(root.val == val)\\n            return root;\\n        else if(root.val <= val)         //current node value is less than key, so our search area would be right subtree\\n            return searchEle(root.right, val);   \\n\\t\\t\\t\\n        return searchEle(root.left, val);       // current node value is greater so our search area is left subtree\\n    }\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        return searchEle(root, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621596,
                "title": "c-3-lines-of-code-iterative-solution",
                "content": "\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root and root->val != val)\\n        root = (root->val>val?root->left:root->right);\\n        return root;\\n    }\\n\\t\\n\\t//  please upvote if you like the solution\\n",
                "solutionTags": [],
                "code": "\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root and root->val != val)\\n        root = (root->val>val?root->left:root->right);\\n        return root;\\n    }\\n\\t\\n\\t//  please upvote if you like the solution\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1555223,
                "title": "c-beats-100-easy-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* ans;\\n    void help(TreeNode* root, int val){\\n        if(!root)\\n            return;\\n        if(root->val == val){\\n            ans = root;\\n            return;\\n        }\\n        if(val < root->val)\\n        help(root->left, val);\\n        else\\n        help(root->right, val);\\n    }\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        help(root, val);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* ans;\\n    void help(TreeNode* root, int val){\\n        if(!root)\\n            return;\\n        if(root->val == val){\\n            ans = root;\\n            return;\\n        }\\n        if(val < root->val)\\n        help(root->left, val);\\n        else\\n        help(root->right, val);\\n    }\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        help(root, val);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518631,
                "title": "2-lines-java-solution-using-recursion",
                "content": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null || root.val == val) return root;\\n        return (val < root.val)? searchBST(root.left, val): searchBST(root.right, val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null || root.val == val) return root;\\n        return (val < root.val)? searchBST(root.left, val): searchBST(root.right, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504922,
                "title": "short-clean-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null) return null;\\n        if(root.val == val) return root;\\n        return root.val > val ? searchBST(root.left, val) : searchBST(root.right, val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null) return null;\\n        if(root.val == val) return root;\\n        return root.val > val ? searchBST(root.left, val) : searchBST(root.right, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348869,
                "title": "c-iterative-and-recursive-solutions",
                "content": "##### Iterative Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* searchBST(TreeNode* root, int val) {\\n\\t\\t\\tif(!root){\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\t}\\n\\t\\t\\twhile(root){\\n\\t\\t\\t\\tif(root -> val == val){\\n\\t\\t\\t\\t\\treturn root;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(root -> val > val){\\n\\t\\t\\t\\t\\troot = root -> left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\troot = root -> right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn root;       \\n\\t\\t}\\n\\t};\\n##### Recursive Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* searchBST(TreeNode* root, int val) {\\n\\t\\t\\tif(!root or root -> val == val){\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t\\telse if(root -> val > val){\\n\\t\\t\\t\\treturn searchBST(root -> left, val);            \\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\treturn searchBST(root -> right, val);            \\n\\t\\t\\t}\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* searchBST(TreeNode* root, int val) {\\n\\t\\t\\tif(!root){\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1231118,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "Recursive Approach:\\n\\n\\tpublic TreeNode searchBST(TreeNode root, int val) \\n    {\\n        if(root==null)\\n            return null;\\n        else if(root.val==val)\\n            return root;\\n        else if(root.val<val)\\n            return searchBST(root.right,val);\\n        else\\n            return searchBST(root.left,val);\\n    }\\n\\t\\nITERETIVE Approach:\\n\\n\\tpublic TreeNode searchBST(TreeNode root, int val) \\n    {\\n        while(root!=null)\\n        {\\n            if(root.val==val)\\n                return root;\\n            else if(root.val<val)\\n                root=root.right;\\n            else\\n                root=root.left;\\n        }\\n        return null;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "Recursive Approach:\\n\\n\\tpublic TreeNode searchBST(TreeNode root, int val) \\n    {\\n        if(root==null)\\n            return null;\\n        else if(root.val==val)\\n            return root;\\n        else if(root.val<val)\\n            return searchBST(root.right,val);\\n        else\\n            return searchBST(root.left,val);\\n    }\\n\\t\\nITERETIVE Approach:\\n\\n\\tpublic TreeNode searchBST(TreeNode root, int val) \\n    {\\n        while(root!=null)\\n        {\\n            if(root.val==val)\\n                return root;\\n            else if(root.val<val)\\n                root=root.right;\\n            else\\n                root=root.left;\\n        }\\n        return null;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1125320,
                "title": "java-straightforward",
                "content": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n      while(root!=null){\\n           if(root.val == val){\\n              return root;\\n          }\\n          else if(root.val > val){\\n              root = root.left;\\n          }else{\\n              root = root.right;\\n          }\\n      }  \\n        return null;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n      while(root!=null){\\n           if(root.val == val){\\n              return root;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1046228,
                "title": "c-super-simple-clear-solution-faster-than-99-46-iterative-5-line",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* searchBST(TreeNode* root, int val) {\\n\\t\\t\\twhile (root)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( val < root->val ) root = root->left;\\n\\t\\t\\t\\telse if ( val > root->val ) root = root->right;\\n\\t\\t\\t\\telse return root;\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* searchBST(TreeNode* root, int val) {\\n\\t\\t\\twhile (root)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ( val < root->val ) root = root->left;\\n\\t\\t\\t\\telse if ( val > root->val ) root = root->right;\\n\\t\\t\\t\\telse return root;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 688729,
                "title": "c-old-new-recursion-iteration-4-solution",
                "content": "```\\n//with BST property\\nclass Solution { // Recusion\\npublic: // Time/Space: O(h); O(h); h is height of BST\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(!root) return nullptr;\\n        if(root->val == val) return root;\\n        return root->val > val ? searchBST(root->left, val) : searchBST(root->right, val) ;        \\n    }\\n};\\n\\n```\\n\\n```\\n//with BST property\\nclass Solution {//BEST:  Iteration\\npublic: // Time/Space: O(h); O(1); h is height of BST\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root && root->val != val)\\n            root=root->val > val ? root->left : root->right;\\n        return root;\\n    }\\n};\\n```\\n\\n```\\n// without using BST property\\nclass Solution { // Recursion + classical C++\\npublic: // Time/Space: O(h); O(h); h is height of BST\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(!root) return nullptr;\\n        if(root->val == val) return root;\\n        TreeNode* left = searchBST(root->left, val);\\n        if(left) return left;\\n        TreeNode* right = searchBST(root->right, val);\\n        if(right) return right;\\n        return nullptr;\\n    }\\n};\\n\\n```\\n\\n\\n```\\n// without using BST property\\nclass Solution { // Recursion + Modern C++\\npublic: // Time/Space: O(N); O(N)\\n    TreeNode* searchBST(TreeNode* root, int val) {        \\n        if(root){\\n            if(root->val == val) return root;\\n            for(auto e: {root->left, root->right}){\\n                auto ret = searchBST(e, val);\\n                if(ret) return ret;\\n            }        \\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//with BST property\\nclass Solution { // Recusion\\npublic: // Time/Space: O(h); O(h); h is height of BST\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(!root) return nullptr;\\n        if(root->val == val) return root;\\n        return root->val > val ? searchBST(root->left, val) : searchBST(root->right, val) ;        \\n    }\\n};\\n\\n```\n```\\n//with BST property\\nclass Solution {//BEST:  Iteration\\npublic: // Time/Space: O(h); O(1); h is height of BST\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root && root->val != val)\\n            root=root->val > val ? root->left : root->right;\\n        return root;\\n    }\\n};\\n```\n```\\n// without using BST property\\nclass Solution { // Recursion + classical C++\\npublic: // Time/Space: O(h); O(h); h is height of BST\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(!root) return nullptr;\\n        if(root->val == val) return root;\\n        TreeNode* left = searchBST(root->left, val);\\n        if(left) return left;\\n        TreeNode* right = searchBST(root->right, val);\\n        if(right) return right;\\n        return nullptr;\\n    }\\n};\\n\\n```\n```\\n// without using BST property\\nclass Solution { // Recursion + Modern C++\\npublic: // Time/Space: O(N); O(N)\\n    TreeNode* searchBST(TreeNode* root, int val) {        \\n        if(root){\\n            if(root->val == val) return root;\\n            for(auto e: {root->left, root->right}){\\n                auto ret = searchBST(e, val);\\n                if(ret) return ret;\\n            }        \\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688384,
                "title": "3-lines-simple-recursive-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root == nullptr || root->val == val) return root;\\n        if(val < root->val) return searchBST(root->left, val);\\n        else return searchBST(root->right, val);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root == nullptr || root->val == val) return root;\\n        if(val < root->val) return searchBST(root->left, val);\\n        else return searchBST(root->right, val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688272,
                "title": "swift-o-h",
                "content": "Because it is a binary search tree, you don\\'t have to check both branches.\\n\\nSo the complexity would be O(h), where h is the height of the tree. In worste case it would be O(n).\\nIf the tree were a balanced tree, then the complexity would be O(log n).\\n\\n```\\nclass Solution {\\n    func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? {\\n        guard let root = root else {\\n            return nil\\n        }\\n        \\n        if root.val == val {\\n            return root\\n        } else if val > root.val {\\n            return searchBST(root.right, val)   \\n        } else {\\n            return searchBST(root.left, val)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func searchBST(_ root: TreeNode?, _ val: Int) -> TreeNode? {\\n        guard let root = root else {\\n            return nil\\n        }\\n        \\n        if root.val == val {\\n            return root\\n        } else if val > root.val {\\n            return searchBST(root.right, val)   \\n        } else {\\n            return searchBST(root.left, val)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520224,
                "title": "java-recursive-and-iterative",
                "content": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        TreeNode left = searchBST(root.left, val);\\n        if (left != null && left.val == val) return left;\\n        return searchBST(root.right, val);\\n    }\\n}\\n```\\n\\nanother version:\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        TreeNode left = searchBST(root.left, val);\\n        if (left != null) return left;\\n        TreeNode right = searchBST(root.right, val);\\n        if (right != null) return right;\\n        return null;\\n    }\\n}\\n```\\n\\nanother repharsing of recursive:\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        if (root.left == null && root.right == null) return null;\\n        TreeNode fromLeft = searchBST(root.left, val);\\n        TreeNode fromRight = searchBST(root.right, val);\\n        if (fromLeft != null)\\n            return fromLeft;\\n        if (fromRight != null)\\n            return fromRight;\\n        return null;\\n    }\\n}\\n```\\n\\none more recursive: \\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        TreeNode leftFound = searchBST(root.left, val);\\n        TreeNode rightFound = searchBST(root.right, val);\\n        if (null != leftFound && leftFound.val == val)\\n            return leftFound;\\n        else if (null != rightFound && rightFound.val == val)\\n            return rightFound;\\n        return null;\\n    }\\n}\\n```\\n\\nrecursive O(log N) taking advantage of how bst is organized\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        TreeNode leftFound = null;\\n        TreeNode rightFound = null;\\n        if (root.val < val) {\\n            leftFound = searchBST(root.left, val);\\n            rightFound = searchBST(root.right, val);\\n        } else {\\n            rightFound = searchBST(root.right, val);\\n            leftFound = searchBST(root.left, val);\\n        }\\n\\n        if (null != leftFound && leftFound.val == val)\\n            return leftFound;\\n        else if (null != rightFound && rightFound.val == val)\\n            return rightFound;\\n        return null;\\n    }\\n}\\n```\\n\\niterative:\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n        while ( ! stack.isEmpty() ) {\\n            TreeNode curr = stack.pop();\\n            if (curr.val == val) return curr;\\n            if (curr.left != null) stack.push(curr.left);\\n            if (curr.right != null) stack.push(curr.right);\\n        }\\n        return null;\\n    }\\n}\\n```\\n\\nO(log N) solution, taking advantage as it is a Binary **Search** Tree\\nso all values on the left are less then current value and on the right are more \\nthan current value\\n\\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n        while ( ! stack.isEmpty() ) {\\n            TreeNode curr = stack.pop();\\n            if (curr.val == val) return curr;\\n            if (curr.val < val) {\\n                if (null != curr.right) stack.push(curr.right);\\n                if (null != curr.left) stack.push(curr.left);\\n            } else { \\n                if (null != curr.left) stack.push(curr.left);\\n                if (null != curr.right) stack.push(curr.right);\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        TreeNode left = searchBST(root.left, val);\\n        if (left != null && left.val == val) return left;\\n        return searchBST(root.right, val);\\n    }\\n}\\n```\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        TreeNode left = searchBST(root.left, val);\\n        if (left != null) return left;\\n        TreeNode right = searchBST(root.right, val);\\n        if (right != null) return right;\\n        return null;\\n    }\\n}\\n```\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        if (root.left == null && root.right == null) return null;\\n        TreeNode fromLeft = searchBST(root.left, val);\\n        TreeNode fromRight = searchBST(root.right, val);\\n        if (fromLeft != null)\\n            return fromLeft;\\n        if (fromRight != null)\\n            return fromRight;\\n        return null;\\n    }\\n}\\n```\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        TreeNode leftFound = searchBST(root.left, val);\\n        TreeNode rightFound = searchBST(root.right, val);\\n        if (null != leftFound && leftFound.val == val)\\n            return leftFound;\\n        else if (null != rightFound && rightFound.val == val)\\n            return rightFound;\\n        return null;\\n    }\\n}\\n```\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        TreeNode leftFound = null;\\n        TreeNode rightFound = null;\\n        if (root.val < val) {\\n            leftFound = searchBST(root.left, val);\\n            rightFound = searchBST(root.right, val);\\n        } else {\\n            rightFound = searchBST(root.right, val);\\n            leftFound = searchBST(root.left, val);\\n        }\\n\\n        if (null != leftFound && leftFound.val == val)\\n            return leftFound;\\n        else if (null != rightFound && rightFound.val == val)\\n            return rightFound;\\n        return null;\\n    }\\n}\\n```\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n        while ( ! stack.isEmpty() ) {\\n            TreeNode curr = stack.pop();\\n            if (curr.val == val) return curr;\\n            if (curr.left != null) stack.push(curr.left);\\n            if (curr.right != null) stack.push(curr.right);\\n        }\\n        return null;\\n    }\\n}\\n```\n```java\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return null;\\n        if (root.val == val) return root;\\n        Deque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n        while ( ! stack.isEmpty() ) {\\n            TreeNode curr = stack.pop();\\n            if (curr.val == val) return curr;\\n            if (curr.val < val) {\\n                if (null != curr.right) stack.push(curr.right);\\n                if (null != curr.left) stack.push(curr.left);\\n            } else { \\n                if (null != curr.left) stack.push(curr.left);\\n                if (null != curr.right) stack.push(curr.right);\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489640,
                "title": "c-without-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root)\\n        {\\n            if(root->val==val)\\n                break;\\n            else if(root->val>val)\\n                root=root->left;\\n            else\\n                root=root->right;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root)\\n        {\\n            if(root->val==val)\\n                break;\\n            else if(root->val>val)\\n                root=root->left;\\n            else\\n                root=root->right;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405791,
                "title": "c-recursive",
                "content": "```\\nstruct TreeNode* searchBST(struct TreeNode* root, int val){\\n    if (!root || root->val == val)\\n\\t\\treturn root;\\n\\t\\n    if (root->val < val)\\n\\t\\treturn searchBST(root->right, val);\\n    else\\n\\t\\treturn searchBST(root->left, val);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nstruct TreeNode* searchBST(struct TreeNode* root, int val){\\n    if (!root || root->val == val)\\n\\t\\treturn root;\\n\\t\\n    if (root->val < val)\\n\\t\\treturn searchBST(root->right, val);\\n    else\\n\\t\\treturn searchBST(root->left, val);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 364530,
                "title": "python-easy-iterative-solution",
                "content": "```\\nclass Solution(object):\\n    def searchBST(self, root, val):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type val: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        while root:\\n            if root.val == val:\\n                return root\\n            if root.val < val:\\n                root = root.right\\n            else:\\n                root = root.left\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def searchBST(self, root, val):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type val: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        while root:\\n            if root.val == val:\\n                return root\\n            if root.val < val:\\n                root = root.right\\n            else:\\n                root = root.left\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359769,
                "title": "share-my-python3-solutions-easy-to-understand",
                "content": "**iteration**:\\n\\n```\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return None\\n\\n        node = root\\n        while node:\\n            if node.val == val:\\n                return node\\n            elif val > node.val:\\n                node = node.right\\n            else:\\n                node = node.left\\n\\n        return None\\n```\\n\\n**recursion**:\\n\\n```\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return None\\n\\n        def _helper(node):\\n            if not node:\\n                return None\\n\\n            if node.val == val:\\n                return node\\n\\n            if val > node.val:\\n                return _helper(node.right)\\n            return _helper(node.left)\\n\\n        return _helper(root)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return None\\n\\n        node = root\\n        while node:\\n            if node.val == val:\\n                return node\\n            elif val > node.val:\\n                node = node.right\\n            else:\\n                node = node.left\\n\\n        return None\\n```\n```\\nclass Solution:\\n    def searchBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return None\\n\\n        def _helper(node):\\n            if not node:\\n                return None\\n\\n            if node.val == val:\\n                return node\\n\\n            if val > node.val:\\n                return _helper(node.right)\\n            return _helper(node.left)\\n\\n        return _helper(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249083,
                "title": "java-3-lines-code",
                "content": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null) return null;\\n        if(root.val == val) return root;\\n        return root.val>val ? searchBST(root.left, val) : searchBST(root.right, val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null) return null;\\n        if(root.val == val) return root;\\n        return root.val>val ? searchBST(root.left, val) : searchBST(root.right, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213818,
                "title": "rust-solution",
                "content": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn search_bst(root: Option<Rc<RefCell<TreeNode>>>, val: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        if let Some(r) = &root {\\n            if r.borrow().val < val {\\n                return Self::search_bst(r.borrow().right.clone(), val);\\n            } else if r.borrow().val > val {\\n                return Self::search_bst(r.borrow().left.clone(), val);\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn search_bst(root: Option<Rc<RefCell<TreeNode>>>, val: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        if let Some(r) = &root {\\n            if r.borrow().val < val {\\n                return Self::search_bst(r.borrow().right.clone(), val);\\n            } else if r.borrow().val > val {\\n                return Self::search_bst(r.borrow().left.clone(), val);\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168564,
                "title": "beats-100-java-code",
                "content": "class Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        TreeNode current = root;\\n        while(current.val != val){\\n            if(val<current.val){\\n                current = current.left;\\n            }else{\\n                current = current.right;\\n            }\\n            if(current == null){\\n                return null;\\n            }\\n        }\\n        return current;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        TreeNode current = root;\\n        while(current.val != val){\\n            if(val<current.val){\\n                current = current.left;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4042949,
                "title": "search-in-a-binary-search-tree-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        TreeNode* temp=root;\\n        while(temp!=NULL){\\n            if(temp->val==val)return temp;\\n            else if(temp->val<val)temp=temp->right;\\n            else temp=temp->left;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        TreeNode* temp=root;\\n        while(temp!=NULL){\\n            if(temp->val==val)return temp;\\n            else if(temp->val<val)temp=temp->right;\\n            else temp=temp->left;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010431,
                "title": "2-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while (root!=NULL && root->val != val) root = (root->val < val) ? root->right : root->left;\\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while (root!=NULL && root->val != val) root = (root->val < val) ? root->right : root->left;\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970237,
                "title": "best-c-solutions-recursive-and-iterative-approach-beats-100",
                "content": "\\n\\n# Code\\n```\\n// Recusive solution\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root == NULL)\\n            return NULL;\\n        \\n        if(root->val == val)\\n            return root;\\n        else if(val < root->val)\\n            return searchBST(root->left, val);\\n        else\\n            return searchBST(root->right, val);\\n        \\n        return root;\\n    }\\n};\\n\\n// Iterative solution\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {   \\n        TreeNode *curr = root;\\n        while(true){\\n            if(curr == NULL || val == curr->val){\\n                break;\\n            }\\n            else if(val < curr->val)\\n                curr = curr->left;\\n            else\\n                curr = curr->right;\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Recusive solution\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root == NULL)\\n            return NULL;\\n        \\n        if(root->val == val)\\n            return root;\\n        else if(val < root->val)\\n            return searchBST(root->left, val);\\n        else\\n            return searchBST(root->right, val);\\n        \\n        return root;\\n    }\\n};\\n\\n// Iterative solution\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {   \\n        TreeNode *curr = root;\\n        while(true){\\n            if(curr == NULL || val == curr->val){\\n                break;\\n            }\\n            else if(val < curr->val)\\n                curr = curr->left;\\n            else\\n                curr = curr->right;\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794010,
                "title": "search-in-a-binary-search-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/b1df7e06-8bf4-4667-9704-2f5c32362687_1689878452.9824464.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        while root!=None and root.val!=val:\\n            if val<root.val:\\n                root=root.left\\n            else:\\n                root=root.right\\n        return root\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        while root!=None and root.val!=val:\\n            if val<root.val:\\n                root=root.left\\n            else:\\n                root=root.right\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792917,
                "title": "very-easy-java-solution-simple-binary-search-tree",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(root.val > val){\\n            return searchBST(root.left, val);\\n        }\\n        else if(root.val < val){\\n            return searchBST(root.right, val);\\n        }\\n        else{\\n            return root;\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(root.val > val){\\n            return searchBST(root.left, val);\\n        }\\n        else if(root.val < val){\\n            return searchBST(root.right, val);\\n        }\\n        else{\\n            return root;\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753659,
                "title": "c-recursion-3-line-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root == NULL || root->val == val) return root;\\n        if(val < root->val) return searchBST(root->left, val);\\n        else return searchBST(root->right, val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root == NULL || root->val == val) return root;\\n        if(val < root->val) return searchBST(root->left, val);\\n        else return searchBST(root->right, val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716422,
                "title": "cpp-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code searches for a node with a given value in a binary search tree (BST) and returns the node if found.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a function searchBST() that takes a pointer to the root of the BST root and an integer val as arguments. It performs the following steps to search for the node:\\n\\nSet a temporary pointer t to root. Start traversing the BST from the root.\\nWhile t is not NULL, compare the value of the current node t->val with the target value val.\\nIf they are equal, return t as the node with the desired value.\\nIf val is greater than the value of the current node t->val, move t to its right child.\\nOtherwise, move t to its left child.\\nIf the loop terminates without finding the node with the desired value, return NULL.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code traverses the BST until it finds the desired value or reaches a leaf node, which takes O(h) time in the worst case, where h is the height of the BST. In the average case, the time complexity is O(log n) for a balanced BST and O(n) for an unbalanced BST, where n is the number of nodes in the BST.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a constant amount of additional space, so the space complexity is O(1).\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        TreeNode* t=root;\\n        while(t){\\n            if(t->val==val){\\n                return t;\\n            }\\n            if(t->val<val){\\n                t=t->right;\\n            }\\n            else\\n            t=t->left;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        TreeNode* t=root;\\n        while(t){\\n            if(t->val==val){\\n                return t;\\n            }\\n            if(t->val<val){\\n                t=t->right;\\n            }\\n            else\\n            t=t->left;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705775,
                "title": "easy-c-solution-beat-100",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL)\\n            return NULL;\\n        if(root->val==val)\\n            return root;\\n        if(val<root->val)\\n            return searchBST(root->left,val);\\n        else\\n             return searchBST(root->right,val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL)\\n            return NULL;\\n        if(root->val==val)\\n            return root;\\n        if(val<root->val)\\n            return searchBST(root->left,val);\\n        else\\n             return searchBST(root->right,val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705225,
                "title": "search-in-a-binary-search-tree-leetcode",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root == NULL || root -> val == val){\\n            return root;\\n        }\\n        \\n        // checking the other cases:-\\n        if(root -> val > val){\\n            return searchBST(root -> left, val);\\n        }else{\\n            return searchBST(root -> right, val);\\n        }\\n    }\\n// By ~ Shubham Verma - Do considered Upvote if my code helped you...\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root == NULL || root -> val == val){\\n            return root;\\n        }\\n        \\n        // checking the other cases:-\\n        if(root -> val > val){\\n            return searchBST(root -> left, val);\\n        }else{\\n            return searchBST(root -> right, val);\\n        }\\n    }\\n// By ~ Shubham Verma - Do considered Upvote if my code helped you...\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662290,
                "title": "recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL) return NULL;\\n        if(root->val==val) return root;\\n        if(root->val>val) return searchBST(root->left , val);\\n        return searchBST(root->right , val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL) return NULL;\\n        if(root->val==val) return root;\\n        if(root->val>val) return searchBST(root->left , val);\\n        return searchBST(root->right , val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648378,
                "title": "c-easiest-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root!=NULL && root->val!=val){\\n            if(val<root->val) root=root->left;\\n            else root=root->right;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root!=NULL && root->val!=val){\\n            if(val<root->val) root=root->left;\\n            else root=root->right;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604704,
                "title": "java-0-ms-recursion-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust **Compare the target Value with Root Value**. \\n- **Target value > Root Value** then our possible Solution will be **present in right**.\\n- **Target Value < Root Value** , Traverse **Left** for possible solution.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n          if (root == null || root.val == val) {\\n            return root;\\n        }\\n        \\n        if (val > root.val) {\\n            return searchBST(root.right, val);\\n        } else {\\n            return searchBST(root.left, val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n          if (root == null || root.val == val) {\\n            return root;\\n        }\\n        \\n        if (val > root.val) {\\n            return searchBST(root.right, val);\\n        } else {\\n            return searchBST(root.left, val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540375,
                "title": "python-easy-iterative-solution",
                "content": "```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        while root!=None and root.val!=val:\\n            if root.val<val:\\n                root=root.right\\n            else:\\n                root=root.left\\n        return root\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        while root!=None and root.val!=val:\\n            if root.val<val:\\n                root=root.right\\n            else:\\n                root=root.left\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535261,
                "title": "super-simple-beginner-friendly-solution-in-c",
                "content": "\\nTime Complexity - O(log n)   where n is the no. of nodes.\\nSpace Complexity - stack space(due to recursion)\\n\\nLogic is super simple, since it is a Binary Search Tree we will use the property of the right node greater than the root and the left one being smaller.\\n\\n```\\n TreeNode* searchBST(TreeNode* root, int val) {\\n        \\n        if(root == nullptr)\\n            return root;\\n        \\n        if(root->val == val)\\n            return root;\\n        \\n        if(root->val > val)\\n            return searchBST(root->left, val);\\n        \\n        else \\n           return searchBST(root->right, val);\\n        \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "\\nTime Complexity - O(log n)   where n is the no. of nodes.\\nSpace Complexity - stack space(due to recursion)\\n\\nLogic is super simple, since it is a Binary Search Tree we will use the property of the right node greater than the root and the left one being smaller.\\n\\n```\\n TreeNode* searchBST(TreeNode* root, int val) {\\n        \\n        if(root == nullptr)\\n            return root;\\n        \\n        if(root->val == val)\\n            return root;\\n        \\n        if(root->val > val)\\n            return searchBST(root->left, val);\\n        \\n        else \\n           return searchBST(root->right, val);\\n        \\n    }\\n};\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3461360,
                "title": "very-simple-java-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe smaller values go on the left of the root and greater on the right of the root. Using this concept we will traverse recursively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a recursive approach. \\n- First we check whether the root is empty or not.\\n- Then, if the target value is lesser than the node value we recursively call the *searchBST* function passing the left node if the root, and the target value.\\n- For the target value greater than the node value, we call the function, passing the right node and the target value.\\n- If the node value and the target value matches, we just simply return the node.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null)\\n            return null;\\n        \\n        if(val<root.val)\\n            return searchBST(root.left, val);\\n        if(val>root.val)\\n            return searchBST(root.right, val);\\n        if(val == root.val)\\n            return root;\\n\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root == null)\\n            return null;\\n        \\n        if(val<root.val)\\n            return searchBST(root.left, val);\\n        if(val>root.val)\\n            return searchBST(root.right, val);\\n        if(val == root.val)\\n            return root;\\n\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369536,
                "title": "c-solution-recursive-iterative",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\\n## recursive\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root==NULL)return NULL;\\n        if (root->val== val)return root;\\n        if (root->val > val) return searchBST(root->left,val);\\n        return searchBST(root->right,val);\\n    }\\n};\\n```\\n\\n\\n## iterative\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root==NULL)return NULL;\\n        while (root){\\n            if (root->val == val)return root;\\n            if (root->val < val){\\n                root= root->right;\\n            }\\n            else root= root->left;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root==NULL)return NULL;\\n        if (root->val== val)return root;\\n        if (root->val > val) return searchBST(root->left,val);\\n        return searchBST(root->right,val);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root==NULL)return NULL;\\n        while (root){\\n            if (root->val == val)return root;\\n            if (root->val < val){\\n                root= root->right;\\n            }\\n            else root= root->left;\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308194,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root == NULL or root->val == val) return root;\\n        if(root->val < val) return searchBST(root->right, val);\\n        else return searchBST(root->left, val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root == NULL or root->val == val) return root;\\n        if(root->val < val) return searchBST(root->right, val);\\n        else return searchBST(root->left, val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197837,
                "title": "python-less-time-complexity-approach-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root and root.val > val: \\n            return self.searchBST(root.left, val)\\n        elif root and root.val < val: \\n            return self.searchBST(root.right, val)\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root and root.val > val: \\n            return self.searchBST(root.left, val)\\n        elif root and root.val < val: \\n            return self.searchBST(root.right, val)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131595,
                "title": "c-easy-binary-search-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust traverse with tmp root. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni)if tmp->val==val  then return tmp (we find our node with value val)\\nii) else if(tmp->val>val) then our node must we lie left side bez it is binary tree\\niii)else if (tmp->val<val> ) then our node must be lie in right side .\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nAt worst case we traverse all node so TC: O(Node) O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)  we did;nt use any data_structure  so space c is constant\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        \\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       TreeNode* tmp=root;\\n\\n       while(tmp!=NULL)\\n       {\\n           if(tmp->val>val)\\n           {\\n               tmp=tmp->left;\\n           }\\n           else if(tmp->val<val)\\n           {\\n               tmp=tmp->right;\\n           }\\n           else\\n           {\\n               return tmp;\\n           }\\n       }\\n       TreeNode* nULL=NULL;\\n       return nULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        \\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       TreeNode* tmp=root;\\n\\n       while(tmp!=NULL)\\n       {\\n           if(tmp->val>val)\\n           {\\n               tmp=tmp->left;\\n           }\\n           else if(tmp->val<val)\\n           {\\n               tmp=tmp->right;\\n           }\\n           else\\n           {\\n               return tmp;\\n           }\\n       }\\n       TreeNode* nULL=NULL;\\n       return nULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031677,
                "title": "c-very-easy-and-fast-recursion-tc-o-logn",
                "content": "TC: O(LogN)\\nSC: Auxiliary Stack Space O(N)\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        //base case\\n        if(root==NULL || root->val==val)return root;\\n        \\n        if(val<=root->val)\\n            return searchBST(root->left,val);\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        //base case\\n        if(root==NULL || root->val==val)return root;\\n        \\n        if(val<=root->val)\\n            return searchBST(root->left,val);\\n        return searchBST(root->right,val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018751,
                "title": "using-recursion-c",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL || root->val==val)\\n        {\\n            return root;\\n        }\\n        if(root->val > val)\\n            return searchBST(root->left,val);\\n        else\\n            return searchBST(root->right,val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL || root->val==val)\\n        {\\n            return root;\\n        }\\n        if(root->val > val)\\n            return searchBST(root->left,val);\\n        else\\n            return searchBST(root->right,val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018745,
                "title": "c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL)\\n            return NULL;\\n        if(root->val==val)\\n            return root;\\n        if(root->val<val)\\n            return searchBST(root->right,val);\\n        else\\n            return searchBST(root->left,val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if(root==NULL)\\n            return NULL;\\n        if(root->val==val)\\n            return root;\\n        if(root->val<val)\\n            return searchBST(root->right,val);\\n        else\\n            return searchBST(root->left,val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010619,
                "title": "beats-100-java-easy-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/** 700. Search in a Binary Search Tree **/\\n\\n/**\\n * Definition for a binary tree node. \\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root != null && root.val != val){\\n            if( val < root.val){\\n                root = root.left;\\n            }else{\\n                root = root.right;\\n            }   \\n        } \\n        return root;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/** 700. Search in a Binary Search Tree **/\\n\\n/**\\n * Definition for a binary tree node. \\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root != null && root.val != val){\\n            if( val < root.val){\\n                root = root.left;\\n            }else{\\n                root = root.right;\\n            }   \\n        } \\n        return root;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838194,
                "title": "c-recursion-easy-98-time-92-space",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n      if(root == nullptr or root->val == val) return root;\\n      else if(root->val > val)  return searchBST(root->left, val);\\n      return searchBST(root->right, val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n      if(root == nullptr or root->val == val) return root;\\n      else if(root->val > val)  return searchBST(root->left, val);\\n      return searchBST(root->right, val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787698,
                "title": "java-iterative-solution-single-iteration",
                "content": "```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null) {\\n            if(root.val==val) {\\n                break;\\n            } else if(root.val<val) {\\n                root=root.right;\\n            } else {\\n                root=root.left;\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null) {\\n            if(root.val==val) {\\n                break;\\n            } else if(root.val<val) {\\n                root=root.right;\\n            } else {\\n                root=root.left;\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2786546,
                "title": "c-solution-search-in-a-binary-search-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        TreeNode* temp = root;\\n        \\n        while(temp != NULL){\\n            if(temp->val == val)\\n                return temp;\\n            if(temp->val > val)\\n                temp = temp->left;\\n            else\\n                temp = temp->right;\\n        }\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        TreeNode* temp = root;\\n        \\n        while(temp != NULL){\\n            if(temp->val == val)\\n                return temp;\\n            if(temp->val > val)\\n                temp = temp->left;\\n            else\\n                temp = temp->right;\\n        }\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768158,
                "title": "short-and-precise-c-code",
                "content": "Here is the C++ Solution:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root==NULL || root->val == val)return root;\\n        while (root!= NULL && root->val != val){\\n            root= ((root->val)>val)?root->left:root->right;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root==NULL || root->val == val)return root;\\n        while (root!= NULL && root->val != val){\\n            root= ((root->val)>val)?root->left:root->right;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768149,
                "title": "easy-c-solution",
                "content": "Here is my C++ Solution:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root==NULL)return NULL;\\n        \\n        // if (root->val < val)searchBST(root->right,val);\\n        // else searchBST(root->left,val);\\n        while (root->val != val){\\n            if (val< root->val){if (root->left)root= root->left; else break;}\\n            else if (val > root->val){ if (root->right)root= root->right; else break; }\\n        }\\n        if (root->val == val)return root;\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root==NULL)return NULL;\\n        \\n        // if (root->val < val)searchBST(root->right,val);\\n        // else searchBST(root->left,val);\\n        while (root->val != val){\\n            if (val< root->val){if (root->left)root= root->left; else break;}\\n            else if (val > root->val){ if (root->right)root= root->right; else break; }\\n        }\\n        if (root->val == val)return root;\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756553,
                "title": "python-beats-90-simple-iterative-approach",
                "content": "```\\nstack, subtree = [], None\\nwhile True:\\n\\twhile root:\\n\\t\\tif root.val == val: subtree = root\\n\\t\\tstack.append(root)\\n\\t\\troot = root.left\\n\\n\\tif subtree: return subtree\\n\\t\\n\\tif not stack: return None\\n\\n\\troot = stack.pop().right\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nstack, subtree = [], None\\nwhile True:\\n\\twhile root:\\n\\t\\tif root.val == val: subtree = root\\n\\t\\tstack.append(root)\\n\\t\\troot = root.left\\n\\n\\tif subtree: return subtree\\n\\t\\n\\tif not stack: return None\\n\\n\\troot = stack.pop().right\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2754892,
                "title": "java-recursive-and-iterative-clean-and-simple",
                "content": "### **Please Upvote** :D\\n##### 1. Recursive approach: \\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return root;\\n        if (val < root.val) return searchBST(root.left, val);\\n        if (val > root.val) return searchBST(root.right, val);\\n        return root;\\n    }\\n}\\n\\n// TC: O(logn) or O(h), SC: O(h)\\n// n -> number of nodes in the tree\\n// h -> height of the tree\\n```\\n##### 2. Iterative approach:\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while (root != null && root.val != val) {\\n            root = val < root.val ? root.left : root.right;\\n        }\\n\\n        return root;\\n    }\\n}\\n\\n// TC: O(logn), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root == null) return root;\\n        if (val < root.val) return searchBST(root.left, val);\\n        if (val > root.val) return searchBST(root.right, val);\\n        return root;\\n    }\\n}\\n\\n// TC: O(logn) or O(h), SC: O(h)\\n// n -> number of nodes in the tree\\n// h -> height of the tree\\n```\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while (root != null && root.val != val) {\\n            root = val < root.val ? root.left : root.right;\\n        }\\n\\n        return root;\\n    }\\n}\\n\\n// TC: O(logn), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716462,
                "title": "4-liner-to-ace",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root==nullptr) {return nullptr;}\\n        if (root->val==val) return root;\\n        if(root->val>val)\\n            return searchBST(root->left,val);\\n        return searchBST(root->right,val);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        if (root==nullptr) {return nullptr;}\\n        if (root->val==val) return root;\\n        if(root->val>val)\\n            return searchBST(root->left,val);\\n        return searchBST(root->right,val);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714249,
                "title": "c-easy-to-understand-no-recursion-o-log-n-time-no-extra-space",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        TreeNode* temp = root;\\n        while(temp != NULL){\\n            if(temp->val == val){\\n                return temp;\\n            }\\n            else if(val < temp->val){\\n                temp = temp->left;\\n            }\\n            else{\\n                temp = temp->right;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        TreeNode* temp = root;\\n        while(temp != NULL){\\n            if(temp->val == val){\\n                return temp;\\n            }\\n            else if(val < temp->val){\\n                temp = temp->left;\\n            }\\n            else{\\n                temp = temp->right;\\n            }\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714141,
                "title": "python-java-easy-solution",
                "content": "**Python Solution:**\\n```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root is None:\\n            return None\\n        if root.val== val:\\n            return root\\n        return self.searchBST(root.left, val) if val< root.val else self.searchBST(root.right, val)\\n```\\n**Java Solution:**\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root== null)\\n            return null;\\n        if (root.val== val)\\n            return root;\\n        return val< root.val ? searchBST(root.left, val) : searchBST(root.right, val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root is None:\\n            return None\\n        if root.val== val:\\n            return root\\n        return self.searchBST(root.left, val) if val< root.val else self.searchBST(root.right, val)\\n```\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if (root== null)\\n            return null;\\n        if (root.val== val)\\n            return root;\\n        return val< root.val ? searchBST(root.left, val) : searchBST(root.right, val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707098,
                "title": "easy-solution-beginner-friendly-5-lines-code",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int x) {\\n         //base cases\\n        if(root == NULL)  //if root became NULL means value is not present in the BST\\n\\t\\t\\treturn NULL;  \\n        if(root->val == x) //if root\\'s value is equal to the given val, it\\'s mean val is prensent\\n\\t\\t\\treturn root;   // in the BST and it is equal to the root\\'s value so return the value\\n        //Now do recursive calls\\n        if(x > root->val)   // if the val is greater than the value of the root then search for the right BST\\n            return searchBST(root->right, x);\\n        return searchBST(root->left, x);  // if the val is lesser than the value of the root then search for the left BST\\n    }\\n};\\n```\\n**DO UPVOTE \\u2B06\\uFE0F !!! IF YOU HAVE UNDERSTOOD MY SOLUTION** \\uD83D\\uDE43\\n**THANK YOU \\uD83D\\uDE00.**",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int x) {\\n         //base cases\\n        if(root == NULL)  //if root became NULL means value is not present in the BST\\n\\t\\t\\treturn NULL;  \\n        if(root->val == x) //if root\\'s value is equal to the given val, it\\'s mean val is prensent\\n\\t\\t\\treturn root;   // in the BST and it is equal to the root\\'s value so return the value\\n        //Now do recursive calls\\n        if(x > root->val)   // if the val is greater than the value of the root then search for the right BST\\n            return searchBST(root->right, x);\\n        return searchBST(root->left, x);  // if the val is lesser than the value of the root then search for the left BST\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662899,
                "title": "java-easy-understanding-0ms",
                "content": "\\n# Code\\n\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null && root.val!=val)\\n        {\\n          if(root.val>val)root=root.left;\\n          else root=root.right;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        while(root!=null && root.val!=val)\\n        {\\n          if(root.val>val)root=root.left;\\n          else root=root.right;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2584711,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        \\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->val == val)\\n                return curr;\\n            else if(curr->val > val)\\n                curr = curr->left;\\n            else\\n                curr = curr->right;\\n        }\\n        return curr;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        \\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->val == val)\\n                return curr;\\n            else if(curr->val > val)\\n                curr = curr->left;\\n            else\\n                curr = curr->right;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1865114,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1923734,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1567317,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1568754,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1574491,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1955799,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1878352,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1572538,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1574786,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1810370,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1865114,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1923734,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1567317,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1568754,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1574491,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1955799,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1878352,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1572538,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1574786,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            },
            {
                "id": 1810370,
                "content": [
                    {
                        "username": "georgezakharov",
                        "content": "Please, don't share your answers here in discussions.\nPeople try to find tips here, not answers."
                    },
                    {
                        "username": "mochiball",
                        "content": "This question is binary search but for trees "
                    },
                    {
                        "username": "FFIB",
                        "content": "I just wrote  `return nil` \\uFF0Cbut hint compile errors\\u3002"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-in-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hammockryan8",
                        "content": "![image](https://assets.leetcode.com/users/images/02941615-5c42-44af-aa06-fb6ce1c1bb65_1602819193.5452113.png)\\n"
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "plsz dont share sol here"
                    },
                    {
                        "username": "yin78105",
                        "content": "For those who do not know the characteristic of Binary Search Tree, \"... is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node\\'s left subtree and less than the ones in its right subtree. ...\" from Wikipedia\\n\\nI am so confused at first when I reading the solutions. Any ideas about how to use recursion to run through all node?"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Use the characteristic of the Binary Search Tree. Every node in the subtree to the left of the current node has a value less than that of the current node. Every node in the subtree to the right of the current node has a greater value than the current node. So, starting from the root, compare the target value to the current node\\'s value to determine which subtree (left or right) to do recursion on."
                    },
                    {
                        "username": "Canaximui",
                        "content": "thank you so much, you reminded me of this really important point XD"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "FIrst check:\\nIf root val==val then return root\\nSecond check:\\nif root.val>val then traverse recursively left subtree \\notherwise traverse right subtree\\nI hope this will help you to get the clue."
                    },
                    {
                        "username": "dreamsclogs",
                        "content": "I return `nil`, but complier said it expects `[]`\\n\\n-_-"
                    },
                    {
                        "username": "vishal_1009",
                        "content": "![Uploading file...]()\\n"
                    },
                    {
                        "username": "khushimattu",
                        "content": "What is wrong in this?\\n```\\nclass Solution {\\n    public TreeNode searchBST(TreeNode root, int val) {\\n        if(root==null){\\n            return null;\\n        }\\n        if(val>root.val){\\n            searchBST(root.right,val);\\n        }\\n        else if(val<root.val){\\n            searchBST(root.left,val);\\n        }\\n        return root;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "QuarantinedSoul",
                        "content": "I think you missed returning the results of left and right calls, \n\n ```java\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root == null){\n            return null;\n        }\n        if(val > root.val){\n           //returning the result of right call\n            return searchBST(root.right, val);\n        }\n        else if(val < root.val){\n            return searchBST(root.left, val);\n        }\n        else{ \n            return root;\n        }\n    }\n}\n```\n\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Insert into a Binary Search Tree",
        "question_content": "<p>You are given the <code>root</code> node of a binary search tree (BST) and a <code>value</code> to insert into the tree. Return <em>the root node of the BST after the insertion</em>. It is <strong>guaranteed</strong> that the new value does not exist in the original BST.</p>\n\n<p><strong>Notice</strong>&nbsp;that there may exist&nbsp;multiple valid ways for the&nbsp;insertion, as long as the tree remains a BST after insertion. You can return <strong>any of them</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg\" style=\"width: 752px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3], val = 5\n<strong>Output:</strong> [4,2,7,1,3,5]\n<strong>Explanation:</strong> Another accepted tree is:\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/05/bst.jpg\" style=\"width: 352px; height: 301px;\" />\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [40,20,60,10,30,50,70], val = 25\n<strong>Output:</strong> [40,20,60,10,30,50,70,null,null,25]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [4,2,7,1,3,null,null,null,null,null,null], val = 5\n<strong>Output:</strong> [4,2,7,1,3,5]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in&nbsp;the tree will be in the range <code>[0,&nbsp;10<sup>4</sup>]</code>.</li>\n\t<li><code>-10<sup>8</sup> &lt;= Node.val &lt;= 10<sup>8</sup></code></li>\n\t<li>All the values <code>Node.val</code> are <strong>unique</strong>.</li>\n\t<li><code>-10<sup>8</sup> &lt;= val &lt;= 10<sup>8</sup></code></li>\n\t<li>It&#39;s <strong>guaranteed</strong> that <code>val</code> does not exist in the original BST.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1683942,
                "title": "well-detailed-explaination-java-c-python-easy-for-mind-to-accept-it",
                "content": "Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\n\\n**So Ladies n Gentlemen without any further due let\\'s start,**\\n`In this problem given a root node of binary search tree and the value & that value we need to add in Binary Search Tree & also saying all the nodes in BST have unique value & the value we need to add is not present in tree.`\\n\\n**Approach Explain :**\\n\\n**Summary :**\\nIf the **root** is empty, the new tree node can be returned as the root node.\\n\\nOtherwise compare **root. val** is related to the size of the target value:\\n\\n* If **root.val** is greater than the **target value**, indicating that the target value should be inserted into the **left subtree of the root**, and the problem becomes root. Insert the target value in the left and recursively call the current function;\\n* If **root.val** is less than the **target value**, indicating that the target value should be inserted into the **right subtree of the root**, and the problem becomes root. Insert the target value in right and recursively call the current function.\\n\\n**Explanation:**\\nIn Binary search tree follow the property, all the nodes on **right subtree**, value is **greater** then the **root value** & all the nodes on **left subtree**, value is **less** then the **root value**.\\n\\n![image](https://assets.leetcode.com/users/images/b040d674-f7eb-47f0-925e-abacfd7db072_1641950282.0731766.png)\\n\\nSo, now let\\'s say we need to **add 5**. We will first compare with the **root node**. If it is less then we go on to the left subtree, if it is greater then we go to the right subtree. So, in this **example** **right subtree exist** and we will compare with **7**. Then it will go to the left & left subtree doesn\\'t exist over here, then we will add the new node over here.\\nNow let\\'s say we need to add **8**, then we will go again the right step and here we will **add 8**\\n\\n\\n![image](https://assets.leetcode.com/users/images/d3743245-dd1c-42fd-8ff3-f434004a92d3_1641951764.907826.png)\\n\\n\\n*Hope you got the point*\\n\\n**Let\\'s Code it up:**\\n\\n **Method - 1: Recursive**\\n\\n*Recursive Code line explain\\'s :* `Similar for C++, Java, Python` **{Only Syntax Difference}** approach same\\n```\\n{\\n        if(root == null) return new TreeNode(val); // if root doesn\\'t exist, then return new TreeNode value\\n        if(root.val > val) root.left = insertIntoBST(root.left, val); // if root value is greater then value, it means our root value exist on left side\\n        else root.right = insertIntoBST(root.right, val); // otherwise root value is lesser then value, it means our root value exist on right side\\n        return root; // returning original root node\\n```\\n**Java**\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if(root.val > val) root.left = insertIntoBST(root.left, val);\\n        else root.right = insertIntoBST(root.right, val);\\n        return root;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root) return new TreeNode(val);\\n        if(root->val > val) root->left = insertIntoBST(root->left, val);\\n        else root->right = insertIntoBST(root->right, val);\\n        return root;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root is None: return TreeNode(val) \\n        if root.val > val:  root.left = self.insertIntoBST(root.left, val)\\n        else: root.right = self.insertIntoBST(root.right, val)\\n        return root\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(H) as considering recursion stack, takes place in internal memory, if not consider then  O(1)\\n\\n**Method - 2: Iterative**\\n\\n*Iterative Code line explain\\'s :* `Similar for C++, Java` **{Only Syntax Difference}** approach same\\n```\\nif(root == null) return new TreeNode(val);\\n        \\n        TreeNode curr = root;\\n        \\n        while(true){ // running an infinity loop, look for the place for new node to add\\n            if(curr.val < val){\\n                if(curr.right != null) curr = curr.right; // update current on right\\n                else {\\n                    curr.right = new TreeNode(val); // otherwise add current of right to new value TreeNode\\n                    break; // breaking this infinity loop\\n                }\\n            }\\n            else{\\n                if(curr.left != null) curr = curr.left; // update current on left\\n                else{\\n                    curr.left = new TreeNode(val); // otherwise add current of left to new value TreeNode\\n                    break; // breaking this infinity loop\\n                }\\n            }\\n        }\\n        return root;\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        \\n        TreeNode curr = root;\\n        \\n        while(true){\\n            if(curr.val < val){\\n                if(curr.right != null) curr = curr.right;\\n                else {\\n                    curr.right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(curr.left != null) curr = curr.left;\\n                else{\\n                    curr.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) { \\n        if(!root) return new TreeNode(val);\\n        \\n        auto curr = root;\\n        \\n        while(true){\\n            if(curr->val < val){\\n                if(curr->right) curr = curr->right;\\n                else {\\n                    curr->right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(curr->left) curr = curr->left;\\n                else{\\n                    curr->left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N), where N is height of binary search tree\\n\\n* **Space Complexity :-** BigO(1)\\n\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n{\\n        if(root == null) return new TreeNode(val); // if root doesn\\'t exist, then return new TreeNode value\\n        if(root.val > val) root.left = insertIntoBST(root.left, val); // if root value is greater then value, it means our root value exist on left side\\n        else root.right = insertIntoBST(root.right, val); // otherwise root value is lesser then value, it means our root value exist on right side\\n        return root; // returning original root node\\n```\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if(root.val > val) root.left = insertIntoBST(root.left, val);\\n        else root.right = insertIntoBST(root.right, val);\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root) return new TreeNode(val);\\n        if(root->val > val) root->left = insertIntoBST(root->left, val);\\n        else root->right = insertIntoBST(root->right, val);\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root is None: return TreeNode(val) \\n        if root.val > val:  root.left = self.insertIntoBST(root.left, val)\\n        else: root.right = self.insertIntoBST(root.right, val)\\n        return root\\n```\n```\\nif(root == null) return new TreeNode(val);\\n        \\n        TreeNode curr = root;\\n        \\n        while(true){ // running an infinity loop, look for the place for new node to add\\n            if(curr.val < val){\\n                if(curr.right != null) curr = curr.right; // update current on right\\n                else {\\n                    curr.right = new TreeNode(val); // otherwise add current of right to new value TreeNode\\n                    break; // breaking this infinity loop\\n                }\\n            }\\n            else{\\n                if(curr.left != null) curr = curr.left; // update current on left\\n                else{\\n                    curr.left = new TreeNode(val); // otherwise add current of left to new value TreeNode\\n                    break; // breaking this infinity loop\\n                }\\n            }\\n        }\\n        return root;\\n```\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        \\n        TreeNode curr = root;\\n        \\n        while(true){\\n            if(curr.val < val){\\n                if(curr.right != null) curr = curr.right;\\n                else {\\n                    curr.right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(curr.left != null) curr = curr.left;\\n                else{\\n                    curr.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) { \\n        if(!root) return new TreeNode(val);\\n        \\n        auto curr = root;\\n        \\n        while(true){\\n            if(curr->val < val){\\n                if(curr->right) curr = curr->right;\\n                else {\\n                    curr->right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(curr->left) curr = curr->left;\\n                else{\\n                    curr->left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 150757,
                "title": "java-iterative-100",
                "content": "```\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        TreeNode cur = root;\\n        while(true) {\\n            if(cur.val <= val) {\\n                if(cur.right != null) cur = cur.right;\\n                else {\\n                    cur.right = new TreeNode(val);\\n                    break;\\n                }\\n            } else {\\n                if(cur.left != null) cur = cur.left;\\n                else {\\n                    cur.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        TreeNode cur = root;\\n        while(true) {\\n            if(cur.val <= val) {\\n                if(cur.right != null) cur = cur.right;\\n                else {\\n                    cur.right = new TreeNode(val);\\n                    break;\\n                }\\n            } else {\\n                if(cur.left != null) cur = cur.left;\\n                else {\\n                    cur.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 180244,
                "title": "python-4-line-clean-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def insertIntoBST(self, root, val):\\n        if(root == None): return TreeNode(val);\\n        if(root.val < val): root.right = self.insertIntoBST(root.right, val);\\n        else: root.left = self.insertIntoBST(root.left, val);\\n        return(root)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def insertIntoBST(self, root, val):\\n        if(root == None): return TreeNode(val);\\n        if(root.val < val): root.right = self.insertIntoBST(root.right, val);\\n        else: root.left = self.insertIntoBST(root.left, val);\\n        return(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157064,
                "title": "c-very-simple",
                "content": "```\\n\\tTreeNode* insertIntoBST(TreeNode *node, int val) {\\n\\t\\tif (!node) {\\n\\t\\t\\tTreeNode *newNode = new TreeNode(val);\\n\\t\\t\\treturn newNode;\\n\\t\\t}\\n\\t\\tif (val < node->val) {\\n\\t\\t\\tnode->left = insertIntoBST(node->left, val);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tnode->right = insertIntoBST(node->right, val);\\n\\t\\t}\\n\\t\\treturn node;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tTreeNode* insertIntoBST(TreeNode *node, int val) {\\n\\t\\tif (!node) {\\n\\t\\t\\tTreeNode *newNode = new TreeNode(val);\\n\\t\\t\\treturn newNode;\\n\\t\\t}\\n\\t\\tif (val < node->val) {\\n\\t\\t\\tnode->left = insertIntoBST(node->left, val);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tnode->right = insertIntoBST(node->right, val);\\n\\t\\t}\\n\\t\\treturn node;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164137,
                "title": "java-easy-to-understand-solution",
                "content": "public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) {\\n            return new TreeNode(val);\\n        }\\n        if (root.val > val) {\\n            root.left = insertIntoBST(root.left, val);\\n        } else {\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n        return root;\\n    }",
                "solutionTags": [],
                "code": "public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) {\\n            return new TreeNode(val);\\n        }\\n        if (root.val > val) {\\n            root.left = insertIntoBST(root.left, val);\\n        } else {\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 222959,
                "title": "c-iterative-linus-style",
                "content": "[[TED] Linus Torvalds - The mind behind Linux](https://www.ted.com/talks/linus_torvalds_the_mind_behind_linux/transcript)\\n\"Good taste is about really seeing the big patterns and kind of instinctively knowing what\\'s the right way to do things.\"\\n```cpp\\n\\tTreeNode *insertIntoBST(TreeNode *root, int val)\\n\\t{\\n\\t\\tTreeNode **cur = &root;\\n\\t\\twhile( *cur )\\n\\t\\t\\tcur = (val > (*cur)->val) ? &(*cur)->right : &(*cur)->left;\\n\\t\\t*cur = new TreeNode(val);\\n\\t\\treturn root;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```cpp\\n\\tTreeNode *insertIntoBST(TreeNode *root, int val)\\n\\t{\\n\\t\\tTreeNode **cur = &root;\\n\\t\\twhile( *cur )\\n\\t\\t\\tcur = (val > (*cur)->val) ? &(*cur)->right : &(*cur)->left;\\n\\t\\t*cur = new TreeNode(val);\\n\\t\\treturn root;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 153792,
                "title": "c-iterative",
                "content": "Starting from `root`, each time move to the left or right child. Once we reach a leaf node, insert `val`.\\n```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode *cur = root, *node = new TreeNode(val);\\n        while (cur) {\\n            if (cur -> val > val) {\\n                if (cur -> left) {\\n                    cur = cur -> left;\\n                } else {\\n                    cur -> left = node;\\n                    break;\\n                }\\n            } else {\\n                if (cur -> right) {\\n                    cur = cur -> right;\\n                } else {\\n                    cur -> right = node;\\n                    break;\\n                }\\n            }\\n        }\\n        return root ? root : node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode *cur = root, *node = new TreeNode(val);\\n        while (cur) {\\n            if (cur -> val > val) {\\n                if (cur -> left) {\\n                    cur = cur -> left;\\n                } else {\\n                    cur -> left = node;\\n                    break;\\n                }\\n            } else {\\n                if (cur -> right) {\\n                    cur = cur -> right;\\n                } else {\\n                    cur -> right = node;\\n                    break;\\n                }\\n            }\\n        }\\n        return root ? root : node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881606,
                "title": "java-0ms-o-n-simple-recursion",
                "content": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)\\n            return new TreeNode(val);\\n        if(root.val>val)\\n            root.left = insertIntoBST(root.left,val);\\n        else\\n            root.right = insertIntoBST(root.right,val);\\n        return root;\\n    }\\n}\\n```\\n\\n**Do upvote if you like the solution.**\\n**Thank you**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)\\n            return new TreeNode(val);\\n        if(root.val>val)\\n            root.left = insertIntoBST(root.left,val);\\n        else\\n            root.right = insertIntoBST(root.right,val);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881677,
                "title": "python-o-h-recursive-solution-explained",
                "content": "What we need to do in this problem is just traverse our tree and find the correct place for our new value:\\n\\n1. If we have `val < root.val`, we need to go left: if it is possible, we go left; if left children is not existing, then we create it with `val` value.\\n2. If we have `val > root.val`, we need to go right: if it is possible, we go right; if right children is not existing, then we create it with `val` value.\\n\\nFinally, we run our `dfs` function from `root` and return `root`.\\n\\n**Complexity** time and space complexity is `O(h)`, where `h` is height of our tree.\\n\\n```\\nclass Solution:\\n    def insertIntoBST(self, root, val):\\n        def dfs(root):\\n            if val < root.val:\\n                if root.left:\\n                    dfs(root.left)\\n                else:\\n                    root.left = TreeNode(val)\\n            else:\\n                if root.right:\\n                    dfs(root.right)\\n                else:\\n                    root.right = TreeNode(val)\\n        \\n        if not root: return TreeNode(val)\\n        dfs(root)\\n        return root\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root, val):\\n        def dfs(root):\\n            if val < root.val:\\n                if root.left:\\n                    dfs(root.left)\\n                else:\\n                    root.left = TreeNode(val)\\n            else:\\n                if root.right:\\n                    dfs(root.right)\\n                else:\\n                    root.right = TreeNode(val)\\n        \\n        if not root: return TreeNode(val)\\n        dfs(root)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684062,
                "title": "c-java-python-2-solutions-4-lines-image-explanation-beginner-friendly",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* search from `root`\\n\\t* if `val > current_node.val`, go right, search in the right subtree\\n\\t* if `val < current_node.val`, go left, search in the left subtree\\n\\t* Any time when we go right or left, if the position is empty, put val there, that is the end.\\n\\n\\n![image](https://assets.leetcode.com/users/images/a98afa59-79ed-4337-80ba-c26d3d1a53ff_1641956952.2360563.png)\\n\\n**Recursive**\\n```\\nTime  Complexity: O(N) for the worst case that the BST is a single chain, for a Balanced Binary Tree it would be O(logN)\\nSpace Complexity: used by the function stack, the same as Time Complexity, from O(logN) to O(N)\\n```\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL) return new TreeNode(val);\\n        if (val > root->val) root->right = insertIntoBST(root->right, val); // Continue searching in the right subtree\\n        else root->left = insertIntoBST(root->left, val); // Continue searching in the left subtree\\n        return root;\\n    }\\n};\\n```\\n\\n**Python**\\n``` python\\nclass Solution(object):\\n    def insertIntoBST(self, root, val):\\n        if root is None: return TreeNode(val)\\n        if val > root.val: root.right = self.insertIntoBST(root.right, val)  # Continue searching in the right subtree\\n        else: root.left = self.insertIntoBST(root.left, val)  # Continue searching in the left subtree\\n        return root\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if (val > root.val) root.right = insertIntoBST(root.right, val); // Continue searching in the right subtree\\n        else root.left = insertIntoBST(root.left, val); // Continue searching in the left subtree\\n        return root;\\n    }\\n}\\n```\\n\\n**Non-Recursive**\\n```\\nTime  Complexity: O(N) for the worst case that the BST is a single chain, for a Balanced Binary Tree it would be O(logN)\\nSpace Complexity: O(1)\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL) return new TreeNode(val);\\n        TreeNode *node = root;\\n        while (true) {\\n            if (val > node->val) { // Continue searching in the right subtree\\n                if (node->right) { // the position is occupied, continue to search\\n                    node = node->right;\\n                } else { // position is empty, insert position found and break the loop\\n                    node->right = new TreeNode(val);\\n                    break;\\n                }\\n            } else { // Continue searching in the left subtree\\n                if (node->left) { // the position is occupied, continue to search\\n                    node = node->left;\\n                    } else { // position is empty, insert position found and break the loop\\n                    node->left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n\\n\\n\\n**Python**\\n``` python\\nclass Solution(object):\\n    def insertIntoBST(self, root, val):\\n        if root is None: return TreeNode(val)\\n        node = root\\n        while True:\\n            if val > node.val:  # Continue searching in the right subtree\\n                if node.right is not None:  # the position is occupied, continue to search\\n                    node = node.right\\n                else:  # position is empty, insert position found and break the loop\\n                    node.right = TreeNode(val)\\n                    break\\n            else:  # Continue searching in the left subtree\\n                if node.left is not None:  # the position is occupied, continue to search\\n                    node = node.left\\n                else:  # position is empty, insert position found and break the loop\\n                    node.left = TreeNode(val)\\n                    break\\n        return root\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        TreeNode node = root;\\n        while (true) {\\n            if (val > node.val) { // Continue searching in the right subtree\\n                if (node.right != null) { // the position is occupied, continue to search\\n                    node = node.right;\\n                } else { // position is empty, insert position found, put val here\\n                    node.right = new TreeNode(val);\\n                    break;\\n                }\\n            } else { // Continue searching in the left subtree\\n                if (node.left != null) { // the position is occupied, continue to search\\n                    node = node.left;\\n                    } else { // position is empty, insert position found, put val here\\n                    node.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nTime  Complexity: O(N) for the worst case that the BST is a single chain, for a Balanced Binary Tree it would be O(logN)\\nSpace Complexity: used by the function stack, the same as Time Complexity, from O(logN) to O(N)\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL) return new TreeNode(val);\\n        if (val > root->val) root->right = insertIntoBST(root->right, val); // Continue searching in the right subtree\\n        else root->left = insertIntoBST(root->left, val); // Continue searching in the left subtree\\n        return root;\\n    }\\n};\\n```\n``` python\\nclass Solution(object):\\n    def insertIntoBST(self, root, val):\\n        if root is None: return TreeNode(val)\\n        if val > root.val: root.right = self.insertIntoBST(root.right, val)  # Continue searching in the right subtree\\n        else: root.left = self.insertIntoBST(root.left, val)  # Continue searching in the left subtree\\n        return root\\n```\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if (val > root.val) root.right = insertIntoBST(root.right, val); // Continue searching in the right subtree\\n        else root.left = insertIntoBST(root.left, val); // Continue searching in the left subtree\\n        return root;\\n    }\\n}\\n```\n```\\nTime  Complexity: O(N) for the worst case that the BST is a single chain, for a Balanced Binary Tree it would be O(logN)\\nSpace Complexity: O(1)\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL) return new TreeNode(val);\\n        TreeNode *node = root;\\n        while (true) {\\n            if (val > node->val) { // Continue searching in the right subtree\\n                if (node->right) { // the position is occupied, continue to search\\n                    node = node->right;\\n                } else { // position is empty, insert position found and break the loop\\n                    node->right = new TreeNode(val);\\n                    break;\\n                }\\n            } else { // Continue searching in the left subtree\\n                if (node->left) { // the position is occupied, continue to search\\n                    node = node->left;\\n                    } else { // position is empty, insert position found and break the loop\\n                    node->left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\n``` python\\nclass Solution(object):\\n    def insertIntoBST(self, root, val):\\n        if root is None: return TreeNode(val)\\n        node = root\\n        while True:\\n            if val > node.val:  # Continue searching in the right subtree\\n                if node.right is not None:  # the position is occupied, continue to search\\n                    node = node.right\\n                else:  # position is empty, insert position found and break the loop\\n                    node.right = TreeNode(val)\\n                    break\\n            else:  # Continue searching in the left subtree\\n                if node.left is not None:  # the position is occupied, continue to search\\n                    node = node.left\\n                else:  # position is empty, insert position found and break the loop\\n                    node.left = TreeNode(val)\\n                    break\\n        return root\\n```\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        TreeNode node = root;\\n        while (true) {\\n            if (val > node.val) { // Continue searching in the right subtree\\n                if (node.right != null) { // the position is occupied, continue to search\\n                    node = node.right;\\n                } else { // position is empty, insert position found, put val here\\n                    node.right = new TreeNode(val);\\n                    break;\\n                }\\n            } else { // Continue searching in the left subtree\\n                if (node.left != null) { // the position is occupied, continue to search\\n                    node = node.left;\\n                    } else { // position is empty, insert position found, put val here\\n                    node.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683883,
                "title": "python3-iterative-explained",
                "content": "Traverse the tree using the main property of the Binary Search Tree (smaller values go to the left, greater values go to the right) until we reach a leaf node. Then again compare the given value with the value of the leaf node and insert a new node to the left or to the right accordingly.\\n\\nTime: **O(N)** - the height of the Binary Search Tree (in the worst case height is equal to the number of elements when the tree degrades into a singly linked list)\\nSpace: **O(1)** - nothing stored\\n\\nRuntime: 136 ms, faster than **69.22%** of Python3 online submissions for Insert into a Binary Search Tree.\\nMemory Usage: 16.9 MB, less than **26.36%** of Python3 online submissions for Insert into a Binary Search Tree.\\n\\n```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root: return TreeNode(val)\\n            \\n        cur, next = None, root\\n        while next:\\n            cur = next\\n            next = cur.left if val < cur.val else cur.right\\n        \\n        if val < cur.val: \\n            cur.left = TreeNode(val)\\n        else: \\n            cur.right = TreeNode(val)\\n            \\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root: return TreeNode(val)\\n            \\n        cur, next = None, root\\n        while next:\\n            cur = next\\n            next = cur.left if val < cur.val else cur.right\\n        \\n        if val < cur.val: \\n            cur.left = TreeNode(val)\\n        else: \\n            cur.right = TreeNode(val)\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801194,
                "title": "well-detailed-explanation-java-c-python-beats-around-100-users",
                "content": "![image.png](https://assets.leetcode.com/users/images/64ae1a92-cc6e-4766-9cc6-60d110e57010_1690034598.3542624.png)\\n\\n# \\u2705 \\u2B06\\uFE0F  Approach 1 - iterative method \\u2B06 \\u267B\\uFE0F\\n\\nIn **CPP** or **JAVA** or **PYTHON**, the main difference is nothing. Only have to change 1-2 **word** in **syntax**. Otherwise the whole code and concept will remain same.\\n \\n```\\nWell defined and describeed in code. Please upvote if it helped.\\n```\\n\\n# Complexity\\n- Time complexity : O(logn)\\n\\n- Space complexity : O(logn)\\n\\n# Code\\n```\\n     if (root == NULL)\\n        return new TreeNode(val);\\n    \\n    // Create a temporary pointer \\'temp\\' to store the original root node.\\n    TreeNode* temp = root;\\n    \\n    // Start a while loop to find the appropriate position to insert the new value.\\n    while (root) {\\n        // If the value to insert (val) is greater than or equal to the current node\\'s value, move to the right subtree.\\n        if (root->val <= val) {\\n            // If the right child exists, move \\'root\\' to the right child and continue the loop.\\n            if (root->right != NULL)\\n                root = root->right;\\n            // If the right child is NULL, it means we have found the appropriate place to insert the new value.\\n            // Create a new node with the given value and set it as the right child of the current node.\\n            else {\\n                root->right = new TreeNode(val);\\n                // Break out of the loop as the insertion is complete.\\n                break;\\n            }\\n        }\\n        // If the value to insert (val) is less than the current node\\'s value, move to the left subtree.\\n        else {\\n            // If the left child exists, move \\'root\\' to the left child and continue the loop.\\n            if (root->left != NULL)\\n                root = root->left;\\n            // If the left child is NULL, it means we have found the appropriate place to insert the new value.\\n            // Create a new node with the given value and set it as the left child of the current node.\\n            else {\\n                root->left = new TreeNode(val);\\n                // Break out of the loop as the insertion is complete.\\n                break;\\n            }\\n        }\\n    }\\n    \\n    // Return the original root (temp) of the modified tree after the insertion.\\n    return temp;\\n    }\\n};\\n\\n\\n```\\n\\n# \\u2705 \\u2B06\\uFE0F  Approach 1 - recursive method \\u2B06 \\u267B\\uFE0F \\n\\n```\\nWell defined and describeed in code. Please upvote if it helped.\\n```\\n\\n# Complexity\\n- Time complexity : O(logn)\\n\\n- Space complexity : O(logn)\\n\\n# Code\\n```\\n// If the tree is empty, create a new node with the given value and return it as the new root.\\n        if(root == NULL) return new TreeNode(val);\\n\\n        // Compare the value to insert (val) with the current node\\'s value.\\n        if (val > root->val)\\n            // If the value to insert is greater than the current node\\'s value, recursively insert it into the right subtree.\\n            root->right = insertIntoBST(root->right, val);\\n        else\\n            // If the value to insert is less than or equal to the current node\\'s value, recursively insert it into the left subtree.\\n            root->left = insertIntoBST(root->left, val);\\n\\n        // Return the root of the modified tree after the insertion.\\n        return root;\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nWell defined and describeed in code. Please upvote if it helped.\\n```\n```\\n     if (root == NULL)\\n        return new TreeNode(val);\\n    \\n    // Create a temporary pointer \\'temp\\' to store the original root node.\\n    TreeNode* temp = root;\\n    \\n    // Start a while loop to find the appropriate position to insert the new value.\\n    while (root) {\\n        // If the value to insert (val) is greater than or equal to the current node\\'s value, move to the right subtree.\\n        if (root->val <= val) {\\n            // If the right child exists, move \\'root\\' to the right child and continue the loop.\\n            if (root->right != NULL)\\n                root = root->right;\\n            // If the right child is NULL, it means we have found the appropriate place to insert the new value.\\n            // Create a new node with the given value and set it as the right child of the current node.\\n            else {\\n                root->right = new TreeNode(val);\\n                // Break out of the loop as the insertion is complete.\\n                break;\\n            }\\n        }\\n        // If the value to insert (val) is less than the current node\\'s value, move to the left subtree.\\n        else {\\n            // If the left child exists, move \\'root\\' to the left child and continue the loop.\\n            if (root->left != NULL)\\n                root = root->left;\\n            // If the left child is NULL, it means we have found the appropriate place to insert the new value.\\n            // Create a new node with the given value and set it as the left child of the current node.\\n            else {\\n                root->left = new TreeNode(val);\\n                // Break out of the loop as the insertion is complete.\\n                break;\\n            }\\n        }\\n    }\\n    \\n    // Return the original root (temp) of the modified tree after the insertion.\\n    return temp;\\n    }\\n};\\n\\n\\n```\n```\\nWell defined and describeed in code. Please upvote if it helped.\\n```\n```\\n// If the tree is empty, create a new node with the given value and return it as the new root.\\n        if(root == NULL) return new TreeNode(val);\\n\\n        // Compare the value to insert (val) with the current node\\'s value.\\n        if (val > root->val)\\n            // If the value to insert is greater than the current node\\'s value, recursively insert it into the right subtree.\\n            root->right = insertIntoBST(root->right, val);\\n        else\\n            // If the value to insert is less than or equal to the current node\\'s value, recursively insert it into the left subtree.\\n            root->left = insertIntoBST(root->left, val);\\n\\n        // Return the root of the modified tree after the insertion.\\n        return root;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 753339,
                "title": "python-self-balanced-tree-avl-tree",
                "content": "**Why use a Self-Balanced Tree (AVL)?**\\n\\nAlthough a self-balanced tree is not required to solve this problem, it is definitely a useful technique if you want to reduce the time-complexity of all operations (search, insert, delete) of a BST from `O(N)` to `O(logN)`. A self-balanced tree is a structure that always keeps the tree balanced (heights of left and right subtrees is <= 1 and height of the tree to be always `O(logN)`. Since the operations of the BST takes `O(height)` time at most, keeping the height of the tree `O(logN)` will guarantee an upper bound of `O(logN)` for these operations of BST.\\n\\n**Code**\\n```\\n# Definition for a binary tree node.\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.height = 1 # this won\\'t work for this question since it doesn\\'t let me modify the structure\\n        \\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        \\n        height_dict = collections.defaultdict(int)\\n        \\n        def insert(node, key):\\n            if not node:\\n                return TreeNode(key)\\n            if node.val < key:\\n                node.right = insert(node.right, key)\\n            elif node.val > key:\\n                node.left = insert(node.left, key)\\n            height_dict[node] = 1 + max(getHeight(node.left), getHeight(node.right))\\n            balance = getBalance(node)\\n            \\n            if balance > 1 and node.left.val > key:\\n                # LL imbalance -> Right Rotation\\n                return rightRotation(node)\\n            \\n            if balance > 1 and node.left.val < key:\\n                # LR imbalance -> Left Right Rotation\\n                node.left = leftRotation(node.left)\\n                return rightRotation(node)\\n            \\n            if balance < -1 and node.right.val < key:\\n                # RR imbalance -> Left Rotation\\n                return leftRotation(node)\\n            \\n            if balance < -1 and node.right.val > key:\\n\\t\\t\\t\\t# RL imbalance -> Right Left Rotation\\n                node.right = rightRotation(node.right)\\n                return leftRotation(node)\\n            \\n            return node\\n            \\n        def getHeight(node):\\n            if not node:\\n                return 0\\n            return height_dict[node]\\n        \\n        def getBalance(node):\\n            if not node:\\n                return 0\\n            return getHeight(node.left) - getHeight(node.right)\\n        \\n        def rightRotation(node):\\n            new_node = node.left\\n            subtree = new_node.right\\n            new_node.right = node\\n            node.left = subtree\\n            new_node.height = 1 + max(getHeight(new_node.left), getHeight(new_node.right))\\n            node.height = 1 + max(getHeight(node.left), getHeight(node.right))\\n            return new_node\\n        \\n        def leftRotation(node):\\n            new_node = node.right\\n            subtree = new_node.left\\n            new_node.left = node\\n            node.right = subtree\\n            new_node.height = 1 + max(getHeight(new_node.left), getHeight(new_node.right))\\n            node.height = 1 + max(getHeight(node.left), getHeight(node.right))\\n            return new_node\\n        \\n        return insert(root, val)\\n```\\n\\nSince this problem doesn\\'t let me modify the structure of the `TreeNode` class, I just created a `dict` to keep the height of each node. Generally, we would want to keep the height of the node as one of the attributes of the TreeNode structure.",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.height = 1 # this won\\'t work for this question since it doesn\\'t let me modify the structure\\n        \\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        \\n        height_dict = collections.defaultdict(int)\\n        \\n        def insert(node, key):\\n            if not node:\\n                return TreeNode(key)\\n            if node.val < key:\\n                node.right = insert(node.right, key)\\n            elif node.val > key:\\n                node.left = insert(node.left, key)\\n            height_dict[node] = 1 + max(getHeight(node.left), getHeight(node.right))\\n            balance = getBalance(node)\\n            \\n            if balance > 1 and node.left.val > key:\\n                # LL imbalance -> Right Rotation\\n                return rightRotation(node)\\n            \\n            if balance > 1 and node.left.val < key:\\n                # LR imbalance -> Left Right Rotation\\n                node.left = leftRotation(node.left)\\n                return rightRotation(node)\\n            \\n            if balance < -1 and node.right.val < key:\\n                # RR imbalance -> Left Rotation\\n                return leftRotation(node)\\n            \\n            if balance < -1 and node.right.val > key:\\n\\t\\t\\t\\t# RL imbalance -> Right Left Rotation\\n                node.right = rightRotation(node.right)\\n                return leftRotation(node)\\n            \\n            return node\\n            \\n        def getHeight(node):\\n            if not node:\\n                return 0\\n            return height_dict[node]\\n        \\n        def getBalance(node):\\n            if not node:\\n                return 0\\n            return getHeight(node.left) - getHeight(node.right)\\n        \\n        def rightRotation(node):\\n            new_node = node.left\\n            subtree = new_node.right\\n            new_node.right = node\\n            node.left = subtree\\n            new_node.height = 1 + max(getHeight(new_node.left), getHeight(new_node.right))\\n            node.height = 1 + max(getHeight(node.left), getHeight(node.right))\\n            return new_node\\n        \\n        def leftRotation(node):\\n            new_node = node.right\\n            subtree = new_node.left\\n            new_node.left = node\\n            node.right = subtree\\n            new_node.height = 1 + max(getHeight(new_node.left), getHeight(new_node.right))\\n            node.height = 1 + max(getHeight(node.left), getHeight(node.right))\\n            return new_node\\n        \\n        return insert(root, val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683964,
                "title": "python-simple-recursive-clean-o-n-time-o-1-space",
                "content": "I noticed some solutions with different odd things in them so I\\'m putting this here hopefully as a cleaner version. Please upvote if this helps \\uD83D\\uDC4D\\n\\n```\\nclass Solution:\\n    def insertIntoBST(self, root, val):\\n        if not root:\\n            return TreeNode(val)\\n      \\n        if val<root.val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        else:\\n            root.right = self.insertIntoBST(root.right, val)\\n  \\n        return root",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "I noticed some solutions with different odd things in them so I\\'m putting this here hopefully as a cleaner version. Please upvote if this helps \\uD83D\\uDC4D\\n\\n```\\nclass Solution:\\n    def insertIntoBST(self, root, val):\\n        if not root:\\n            return TreeNode(val)\\n      \\n        if val<root.val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        else:\\n            root.right = self.insertIntoBST(root.right, val)\\n  \\n        return root",
                "codeTag": "Java"
            },
            {
                "id": 881671,
                "title": "c-clean-clear-efficient-solution-o-logn-with-explanations-2-solutions",
                "content": "**This is a shorter more implicit solution:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val)\\n\\t{\\n        if (!root)\\n\\t\\t\\treturn new TreeNode(val);\\n\\t\\t\\t\\n        if (val > root->val)\\n\\t\\t\\troot->right = insertIntoBST(root->right, val);\\n        else \\n\\t\\t\\troot->left = insertIntoBST(root->left, val);\\n\\t\\t\\t\\n        return root;\\n    }\\n};\\n```\\n\\n\\n\\n**This is a more explicit solution:**\\n```\\nclass Solution {\\nprivate:\\n\\t// helper function to initialize a tree node\\n    void InitNode(TreeNode* newNode,int value)\\n    {\\n        newNode->val = value;\\n        newNode->left = NULL;\\n        newNode->right = NULL;\\n    }\\n\\t// helper function to create tree node\\n    TreeNode* CreateNode(int value)\\n    {\\n        TreeNode *newNode = new TreeNode;\\t\\n        InitNode(newNode, value);\\n\\n        return newNode;\\n    }\\n    // function to insert a tree node into a BST\\n    void InsertNode(TreeNode **root, TreeNode *newNode)\\n    {\\n        if (!*root)\\n        {\\n            // not a Special case at all: Tree is empty\\n            *root = newNode;\\n        }\\n        else\\n        {\\n            // otherwise, trivial case:\\n            if ((*root)->val > newNode->val)\\n            {\\n                // go left\\n                InsertNode(&(*root)->left, newNode);\\n            }\\n            else if ((*root)->val < newNode->val)\\n            {\\n                // go right\\n                InsertNode(&(*root)->right, newNode);\\n            }\\n            else\\n            {\\n                // delete duplicated node (prevent duplication!)\\n                delete newNode;\\n            }\\n        }\\n    }\\n    \\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) \\n    {\\n        TreeNode *newNode = CreateNode(val);\\n\\t    InsertNode(&root, newNode);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val)\\n\\t{\\n        if (!root)\\n\\t\\t\\treturn new TreeNode(val);\\n\\t\\t\\t\\n        if (val > root->val)\\n\\t\\t\\troot->right = insertIntoBST(root->right, val);\\n        else \\n\\t\\t\\troot->left = insertIntoBST(root->left, val);\\n\\t\\t\\t\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n\\t// helper function to initialize a tree node\\n    void InitNode(TreeNode* newNode,int value)\\n    {\\n        newNode->val = value;\\n        newNode->left = NULL;\\n        newNode->right = NULL;\\n    }\\n\\t// helper function to create tree node\\n    TreeNode* CreateNode(int value)\\n    {\\n        TreeNode *newNode = new TreeNode;\\t\\n        InitNode(newNode, value);\\n\\n        return newNode;\\n    }\\n    // function to insert a tree node into a BST\\n    void InsertNode(TreeNode **root, TreeNode *newNode)\\n    {\\n        if (!*root)\\n        {\\n            // not a Special case at all: Tree is empty\\n            *root = newNode;\\n        }\\n        else\\n        {\\n            // otherwise, trivial case:\\n            if ((*root)->val > newNode->val)\\n            {\\n                // go left\\n                InsertNode(&(*root)->left, newNode);\\n            }\\n            else if ((*root)->val < newNode->val)\\n            {\\n                // go right\\n                InsertNode(&(*root)->right, newNode);\\n            }\\n            else\\n            {\\n                // delete duplicated node (prevent duplication!)\\n                delete newNode;\\n            }\\n        }\\n    }\\n    \\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) \\n    {\\n        TreeNode *newNode = CreateNode(val);\\n\\t    InsertNode(&root, newNode);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365503,
                "title": "python-recursive-solution-beats-85-time-96-space",
                "content": "```\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            root=TreeNode(val)\\n            return root\\n        if root.val<val:\\n            root.right=self.insertIntoBST(root.right,val)\\n        else:\\n            root.left=self.insertIntoBST(root.left,val)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            root=TreeNode(val)\\n            return root\\n        if root.val<val:\\n            root.right=self.insertIntoBST(root.right,val)\\n        else:\\n            root.left=self.insertIntoBST(root.left,val)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650682,
                "title": "easy-to-understand-faster-than-92-2-solutions-recursive-iterative-python-sol",
                "content": "```\\n    def iterative(self, root, val):\\n        node = root\\n        while node:\\n            if node.val < val:\\n                if node.right:\\n                    node = node.right\\n                else:\\n                    node.right = TreeNode(val)\\n                    break\\n            else:\\n                if node.left:\\n                    node = node.left\\n                else:\\n                    node.left = TreeNode(val)\\n                    break\\n        return root if root else TreeNode(val)\\n                    \\n        \\n    def recursive(root, val):\\n        if not root: return TreeNode(val)\\n        def rec(node, val):\\n            if node:\\n                if val > node.val:\\n                    if node.right:\\n                        node.right = rec(node.right, val)\\n                    else:\\n                        node.right = TreeNode(val)\\n                        \\n                elif val < node.val:\\n                    if node.left:\\n                        node.left = rec(node.left, val)\\n                    else:\\n                        node.left = TreeNode(val)\\n                return node\\n        rec(root, val)\\n        return root\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def iterative(self, root, val):\\n        node = root\\n        while node:\\n            if node.val < val:\\n                if node.right:\\n                    node = node.right\\n                else:\\n                    node.right = TreeNode(val)\\n                    break\\n            else:\\n                if node.left:\\n                    node = node.left\\n                else:\\n                    node.left = TreeNode(val)\\n                    break\\n        return root if root else TreeNode(val)\\n                    \\n        \\n    def recursive(root, val):\\n        if not root: return TreeNode(val)\\n        def rec(node, val):\\n            if node:\\n                if val > node.val:\\n                    if node.right:\\n                        node.right = rec(node.right, val)\\n                    else:\\n                        node.right = TreeNode(val)\\n                        \\n                elif val < node.val:\\n                    if node.left:\\n                        node.left = rec(node.left, val)\\n                    else:\\n                        node.left = TreeNode(val)\\n                return node\\n        rec(root, val)\\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 405916,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} val\\n * @return {TreeNode}\\n */\\nvar insertIntoBST = function(root, val) {\\n    if (root == null) {\\n        return new TreeNode(val);\\n    }\\n    \\n    if(val < root.val) {\\n        root.left = insertIntoBST(root.left, val);\\n    } else {\\n        root.right = insertIntoBST(root.right, val);\\n    }\\n    \\n    return root;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} val\\n * @return {TreeNode}\\n */\\nvar insertIntoBST = function(root, val) {\\n    if (root == null) {\\n        return new TreeNode(val);\\n    }\\n    \\n    if(val < root.val) {\\n        root.left = insertIntoBST(root.left, val);\\n    } else {\\n        root.right = insertIntoBST(root.right, val);\\n    }\\n    \\n    return root;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 190447,
                "title": "javascript",
                "content": "```\nvar insertIntoBST = function(root, val) {\n    if(!root) {\n        return new TreeNode(val);\n    }\n    if(val > root.val){\n        root.right = insertIntoBST(root.right, val);\n    }\n    else {\n        root.left = insertIntoBST(root.left, val);\n    }\n    return root;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar insertIntoBST = function(root, val) {\n    if(!root) {\n        return new TreeNode(val);\n    }\n    if(val > root.val){\n        root.right = insertIntoBST(root.right, val);\n    }\n    else {\n        root.left = insertIntoBST(root.left, val);\n    }\n    return root;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 882155,
                "title": "c-simple-solution-easy-to-understand-recursion-and-iteration",
                "content": "Please find both recursive and iterative approach below and if you face any problem , let me know in comments.\\n\\nRecursive Approach :\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL)   \\n            return new TreeNode(val);\\n        if(root->val<val){\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        else{\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        return root;\\n    }\\n};\\n```\\nIterative Approach\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL)   \\n            return new TreeNode(val);\\n        TreeNode *curr=root;\\n        TreeNode *prev=NULL;\\n        while(curr){\\n            prev=curr;\\n            if(curr->val<val)\\n                curr=curr->right;\\n            else\\n                curr=curr->left;\\n        }\\n        if(prev->val < val){\\n            prev->right=new TreeNode(val);\\n        }\\n        else\\n            prev->left=new TreeNode(val);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL)   \\n            return new TreeNode(val);\\n        if(root->val<val){\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        else{\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL)   \\n            return new TreeNode(val);\\n        TreeNode *curr=root;\\n        TreeNode *prev=NULL;\\n        while(curr){\\n            prev=curr;\\n            if(curr->val<val)\\n                curr=curr->right;\\n            else\\n                curr=curr->left;\\n        }\\n        if(prev->val < val){\\n            prev->right=new TreeNode(val);\\n        }\\n        else\\n            prev->left=new TreeNode(val);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881814,
                "title": "python-7-line-soltuion",
                "content": "```\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return TreeNode(val)\\n        \\n        if val > root.val:\\n            root.right = self.insertIntoBST(root.right, val)\\n        else:\\n            root.left = self.insertIntoBST(root.left, val)\\n\\t\\t\\t\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return TreeNode(val)\\n        \\n        if val > root.val:\\n            root.right = self.insertIntoBST(root.right, val)\\n        else:\\n            root.left = self.insertIntoBST(root.left, val)\\n\\t\\t\\t\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422826,
                "title": "java-easy-to-understand-solution-with-both-100",
                "content": "Just use two variable denote the prevNode and currNode. \\n\\n```java\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n\\n        TreeNode currNode = root, prevNode = null;\\n        while (currNode != null) {\\n        \\tprevNode = currNode;\\n        \\tif (val > currNode.val) {\\n        \\t\\tcurrNode = currNode.right;\\n        \\t\\tcontinue;\\n        \\t}\\n\\n        \\tif (val <= currNode.val) {\\n        \\t\\tcurrNode = currNode.left;\\n        \\t\\tcontinue;\\n        \\t}\\n        }\\n\\n        if (val > prevNode.val) {\\n        \\tprevNode.right = new TreeNode(val);\\n        } else if (val <= prevNode.val) {\\n        \\tprevNode.left = new TreeNode(val);\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n\\n        TreeNode currNode = root, prevNode = null;\\n        while (currNode != null) {\\n        \\tprevNode = currNode;\\n        \\tif (val > currNode.val) {\\n        \\t\\tcurrNode = currNode.right;\\n        \\t\\tcontinue;\\n        \\t}\\n\\n        \\tif (val <= currNode.val) {\\n        \\t\\tcurrNode = currNode.left;\\n        \\t\\tcontinue;\\n        \\t}\\n        }\\n\\n        if (val > prevNode.val) {\\n        \\tprevNode.right = new TreeNode(val);\\n        } else if (val <= prevNode.val) {\\n        \\tprevNode.left = new TreeNode(val);\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290527,
                "title": "my-python-dfs-solution",
                "content": "1. If root is None, create the node and return the node\\n2. If root.val smaller than val, insert the val into root\\'s right subtree and make the modified right subtree\\'s root as root.right\\n3. If root.val greater than val, similar to the case 2\\n\\nBelow is my python implementation\\n\\n```python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return TreeNode(val)\\n        if root.val < val:\\n            right = self.insertIntoBST(root.right, val)\\n            root.right = right\\n        if root.val > val:\\n            left = self.insertIntoBST(root.left, val)\\n            root.left = left\\n        return root\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return TreeNode(val)\\n        if root.val < val:\\n            right = self.insertIntoBST(root.right, val)\\n            root.right = right\\n        if root.val > val:\\n            left = self.insertIntoBST(root.left, val)\\n            root.left = left\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932741,
                "title": "solution-with-proper-approach-and-intution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust find out the place where value can be placed by comapring and checking property of BST\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou have to just create a temp node initialised with root ,\\nnow i checked if value currently at temp node is less than or equal to value (to be inserted) ,\\nso now we will move to right to find out whether we can add node here or not if temp -> right already exist then we will move to it ,otherwise we will create a node there ,\\nSimilarly if value at node is greater than we will do the same thing but on left side.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == nullptr) return new TreeNode(val) ;\\n\\n        TreeNode *temp = root ;\\n\\n        while(true){\\n            if(temp->val <= val){\\n                if(temp->right != nullptr){\\n                    temp = temp->right ;\\n                }\\n                else{\\n                    temp->right = new TreeNode(val) ;\\n                    break ;\\n                }\\n            }\\n            else{\\n                if(temp->left != nullptr){\\n                    temp = temp->left ;\\n                }\\n                else{\\n                    temp->left = new TreeNode(val) ;\\n                    break ; \\n                }\\n            }\\n        }\\n        return root ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == nullptr) return new TreeNode(val) ;\\n\\n        TreeNode *temp = root ;\\n\\n        while(true){\\n            if(temp->val <= val){\\n                if(temp->right != nullptr){\\n                    temp = temp->right ;\\n                }\\n                else{\\n                    temp->right = new TreeNode(val) ;\\n                    break ;\\n                }\\n            }\\n            else{\\n                if(temp->left != nullptr){\\n                    temp = temp->left ;\\n                }\\n                else{\\n                    temp->left = new TreeNode(val) ;\\n                    break ; \\n                }\\n            }\\n        }\\n        return root ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519975,
                "title": "insert-at-leafnode",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n          \\n        if(root == NULL)\\n        {   TreeNode* root = new TreeNode(val);\\n            return root;\\n        \\n        if(root->val > val)\\n            root->left = insertIntoBST(root->left,val);\\n        else if(root->val < val)\\n            root->right = insertIntoBST(root->right,val);\\n        \\n        return root;\\n        return (root == NULL) ? \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n          \\n        if(root == NULL)\\n        {   TreeNode* root = new TreeNode(val);\\n            return root;\\n        \\n        if(root->val > val)\\n            root->left = insertIntoBST(root->left,val);\\n        else if(root->val < val)\\n            root->right = insertIntoBST(root->right,val);\\n        \\n        return root;\\n        return (root == NULL) ? \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420660,
                "title": "100-faster-java-sulution-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/bbb1aaa6-d65a-4ecf-9240-1092a228e8f6_1681579894.8068745.png)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        \\n        // if the root is null, create a new node with the given value\\n        if (root == null) {\\n            return new TreeNode(val);\\n        }\\n\\n        // initialize a current node to the root\\n        TreeNode cur = root;\\n\\n        // traverse the tree until an appropriate location for the new node is found\\n        while (true) {\\n            // if the value to be inserted is greater than or equal to the current node value\\n            if (cur.val <= val) {\\n                // if the right child is not null, move to the right subtree\\n                if (cur.right != null) {\\n                    cur = cur.right;\\n                }\\n                // if the right child is null, create a new node with the given value and attach it as the right child of the current node\\n                else {\\n                    cur.right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            // if the value to be inserted is less than the current node value\\n            else {\\n                // if the left child is not null, move to the left subtree\\n                if (cur.left != null) {\\n                    cur = cur.left;\\n                }\\n                // if the left child is null, create a new node with the given value and attach it as the left child of the current node\\n                else {\\n                    cur.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        // return the root of the BST\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        \\n        // if the root is null, create a new node with the given value\\n        if (root == null) {\\n            return new TreeNode(val);\\n        }\\n\\n        // initialize a current node to the root\\n        TreeNode cur = root;\\n\\n        // traverse the tree until an appropriate location for the new node is found\\n        while (true) {\\n            // if the value to be inserted is greater than or equal to the current node value\\n            if (cur.val <= val) {\\n                // if the right child is not null, move to the right subtree\\n                if (cur.right != null) {\\n                    cur = cur.right;\\n                }\\n                // if the right child is null, create a new node with the given value and attach it as the right child of the current node\\n                else {\\n                    cur.right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            // if the value to be inserted is less than the current node value\\n            else {\\n                // if the left child is not null, move to the left subtree\\n                if (cur.left != null) {\\n                    cur = cur.left;\\n                }\\n                // if the left child is null, create a new node with the given value and attach it as the left child of the current node\\n                else {\\n                    cur.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        // return the root of the BST\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407657,
                "title": "c-easy-beginner-friendly-two-pointer-approach",
                "content": "# Intuition\\nIn a BST, for each **node** : left **subtree** contains all smaller elements than the **node** and right **subtree** contains all the larger elements than the **node**.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMake two pointers one(**node**) on the root and other(**prev**) just before it(**initialized to NULL**).\\nNow simply move accordingly for finding the correct node onto which the new value node will get attached i.e.,\\nIf the node\\'s value if larger than the new value -> move **prev** to **node** and **node** to its **left**\\nelse -> move **prev** to **node** and **node** to its **right**.\\nAs soon as the **node** becomes **NULL** **stop**.\\nAt this time we have our **prev** pointer at the \"node\" onto which we have to attach the new node.\\nMake a new **new node** with **val=given value** and attach it to **correct side(left or right)**.\\nFinally **return** the **root**.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(longn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root){\\n            TreeNode* node = new TreeNode(val);\\n            return node;\\n        }\\n        TreeNode* node = root;\\n        TreeNode* prev=NULL;\\n        while(node){\\n            if(val<node->val){\\n                prev=node;\\n                node=node->left;\\n            }\\n            else{\\n                prev=node;\\n                node=node->right;\\n            }\\n        }\\n        if(val<prev->val){\\n            TreeNode* newNode = new TreeNode(val);\\n            prev->left=newNode;\\n        }\\n        else{\\n            TreeNode* newNode = new TreeNode(val);\\n            prev->right=newNode;\\n        }\\n        return root;\\n    }\\n};\\n```\\n# ***Please upvote if it helped!***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root){\\n            TreeNode* node = new TreeNode(val);\\n            return node;\\n        }\\n        TreeNode* node = root;\\n        TreeNode* prev=NULL;\\n        while(node){\\n            if(val<node->val){\\n                prev=node;\\n                node=node->left;\\n            }\\n            else{\\n                prev=node;\\n                node=node->right;\\n            }\\n        }\\n        if(val<prev->val){\\n            TreeNode* newNode = new TreeNode(val);\\n            prev->left=newNode;\\n        }\\n        else{\\n            TreeNode* newNode = new TreeNode(val);\\n            prev->right=newNode;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461264,
                "title": "python-dfs-clean-concise",
                "content": "```python\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if root == None: return TreeNode(val)\\n        if val < root.val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        else:\\n            root.right = self.insertIntoBST(root.right, val)\\n        return root\\n```\\nComplexity:\\n- Time: `O(H)`, where `H` is the height of the BST.\\n- Space: `O(H)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if root == None: return TreeNode(val)\\n        if val < root.val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        else:\\n            root.right = self.insertIntoBST(root.right, val)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882944,
                "title": "c-iterative-easy-approach-commented",
                "content": "```\\nTreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode *prev, *cur;      \\n        prev= cur = root;\\n        TreeNode *node = new TreeNode(val);\\n        if(root == NULL)\\n            return node;\\n        while(cur)\\n        {\\n            if(val < cur->val)      // if val is less than curr node, move left side\\n            {\\n                prev = cur;\\n                cur = cur->left;\\n            }\\n            else if(val > cur->val) //if val is greater than curr node, move right side\\n            {\\n                prev = cur;\\n                cur = cur->right;\\n            }\\n        }\\n        if(val < prev->val)         //simply attach value to last node\\n            prev->left = node;\\n        else\\n            prev->right = node;\\n        return root;\\n    }",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nTreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode *prev, *cur;      \\n        prev= cur = root;\\n        TreeNode *node = new TreeNode(val);\\n        if(root == NULL)\\n            return node;\\n        while(cur)\\n        {\\n            if(val < cur->val)      // if val is less than curr node, move left side\\n            {\\n                prev = cur;\\n                cur = cur->left;\\n            }\\n            else if(val > cur->val) //if val is greater than curr node, move right side\\n            {\\n                prev = cur;\\n                cur = cur->right;\\n            }\\n        }\\n        if(val < prev->val)         //simply attach value to last node\\n            prev->left = node;\\n        else\\n            prev->right = node;\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 881890,
                "title": "rust-solution",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn insert_into_bst(root: Option<Rc<RefCell<TreeNode>>>, val: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        Some(match root {\\n            None => Rc::new(RefCell::new(TreeNode::new(val))),\\n            Some(r) => {\\n                if r.borrow().val > val {\\n                    let node = Solution::insert_into_bst(r.borrow().left.clone(), val);\\n                    r.borrow_mut().left = node;\\n                } else {\\n                    let node = Solution::insert_into_bst(r.borrow().right.clone(), val);\\n                    r.borrow_mut().right = node\\n                }\\n                r\\n            }\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn insert_into_bst(root: Option<Rc<RefCell<TreeNode>>>, val: i32) -> Option<Rc<RefCell<TreeNode>>> {\\n        Some(match root {\\n            None => Rc::new(RefCell::new(TreeNode::new(val))),\\n            Some(r) => {\\n                if r.borrow().val > val {\\n                    let node = Solution::insert_into_bst(r.borrow().left.clone(), val);\\n                    r.borrow_mut().left = node;\\n                } else {\\n                    let node = Solution::insert_into_bst(r.borrow().right.clone(), val);\\n                    r.borrow_mut().right = node\\n                }\\n                r\\n            }\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 772734,
                "title": "4-line-solution-with-explanation-0ms-faster-than-100",
                "content": "```\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        \\n        if(root == null)  return new TreeNode(val);;\\n        \\n        if(val < root.val) root.left = insertIntoBST(root.left, val);\\n\\t\\t\\n        else  root.right = insertIntoBST(root.right, val);\\n        \\n        return root;\\n\\t\\t\\n }\\n ```\\n \\nSecond Line:  We have to first look whether the given val is smaller than root\\'s val or not as BST has a rule that left side to the parent will have smaller nodes while right side of parent will be bigger.\\n\\tSo make recursive call with root.left as we don\\'t know how many nodes would be smaller than the given \\'val\\' \\n\\nThird Line: Similarly we have to do as in second step. i.e. if the given val is greater than root\\'s val then make right recursive call.\\n\\nFourth line: It is pretty self explaning.\\n\\nFirstLine: Now when making recursive calls we reaches null that is where the game is about to end, so create a new node and put the given \\'val\\' into the node and return it.\\n\\nHere root.left = insertIntoBST() & root.right = insertIntoBST()\\nwill make sure that the link is being created well.\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        \\n        if(root == null)  return new TreeNode(val);;\\n        \\n        if(val < root.val) root.left = insertIntoBST(root.left, val);\\n\\t\\t\\n        else  root.right = insertIntoBST(root.right, val);\\n        \\n        return root;\\n\\t\\t\\n }\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 772366,
                "title": "faster-than-95-63",
                "content": "\\n    class Solution {\\n         public:\\n             TreeNode* insertIntoBST(TreeNode* root, int val) {\\n                 if(root==NULL) return new TreeNode(val);\\n                 if(root->left==NULL && root->right==NULL){\\n                     if(root->val>val)\\n                         root->left=new TreeNode(val);\\n                     else\\n                         root->right=new TreeNode(val);\\n                     return root;\\n                 }\\n                 if(root->val>val)\\n                    root->left=insertIntoBST(root->left,val);\\n                 else if(root->val<val)\\n                    root->right=insertIntoBST(root->right,val);\\n                 return root;\\n             }\\n         };\\n\\t\\nFeel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n         public:\\n             TreeNode* insertIntoBST(TreeNode* root, int val) {\\n                 if(root==NULL) return new TreeNode(val);\\n                 if(root->left==NULL && root->right==NULL){\\n                     if(root->val>val)\\n                         root->left=new TreeNode(val);\\n                     else\\n                         root->right=new TreeNode(val);\\n                     return root;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 724211,
                "title": "c-easy-recursive-3-line-with-explanation-and-iterative-solution",
                "content": "**RECURSIVE SOLUTION**:\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root==0)return new TreeNode(val);\\n        if (val<root->val)root->left=insertIntoBST(root->left,val);\\n        else root->right=insertIntoBST(root->right,val);\\n        return root;\\n    }\\n};\\n```\\n**ITERATIVE SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode* p=root,*q=0;\\n        if(root==0){\\n            TreeNode* newNode=new TreeNode;\\n            newNode->val=val;\\n            return newNode;\\n        }\\n        while(p!=0){\\n            q=p;\\n            if(p->val>val)p=p->left;\\n            else p=p->right;\\n        }\\n        TreeNode* newNode=new TreeNode;\\n        newNode->val=val;\\n        if(q->val>val)q->left=newNode;\\n        else q->right=newNode;\\n        return root;\\n    }\\n};\\n```\\nPlease upvote if you like my solution..... :)\\n\\n![image](https://assets.leetcode.com/users/images/4bfcfe6b-716b-4771-bde8-c2f1e98addcf_1594134752.3812985.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root==0)return new TreeNode(val);\\n        if (val<root->val)root->left=insertIntoBST(root->left,val);\\n        else root->right=insertIntoBST(root->right,val);\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode* p=root,*q=0;\\n        if(root==0){\\n            TreeNode* newNode=new TreeNode;\\n            newNode->val=val;\\n            return newNode;\\n        }\\n        while(p!=0){\\n            q=p;\\n            if(p->val>val)p=p->left;\\n            else p=p->right;\\n        }\\n        TreeNode* newNode=new TreeNode;\\n        newNode->val=val;\\n        if(q->val>val)q->left=newNode;\\n        else q->right=newNode;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585520,
                "title": "c-4-lines-recursive-solution",
                "content": "```\\n    public TreeNode InsertIntoBST(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n\\n        if (val < root.val) root.left = InsertIntoBST(root.left, val);\\n        if (val > root.val) root.right = InsertIntoBST(root.right, val);\\n\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    public TreeNode InsertIntoBST(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n\\n        if (val < root.val) root.left = InsertIntoBST(root.left, val);\\n        if (val > root.val) root.right = InsertIntoBST(root.right, val);\\n\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 390367,
                "title": "python3-iterative-and-recursive",
                "content": "```\\nclass Solution(object):\\n    def insertIntoBST(self, root, val):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type val: int\\n        :rtype: TreeNode\\n        \"\"\"\\n\\t\\t\"\"\"Iterative\"\"\"\\n        if not root: return TreeNode(val)\\n        cur = root\\n        while True:\\n            if cur.val < val:\\n                if cur.right: cur = cur.right\\n                else: \\n                    cur.right = TreeNode(val)\\n                    break\\n            else:\\n                if cur.left: cur = cur.left\\n                else:\\n                    cur.left = TreeNode(val)\\n                    break\\n        \\n        return root\\n        \\n        \"\"\"Recursive\"\"\"\\n        \"\"\"\\n        if not root:\\n             return TreeNode(val)\\n        if root.val < val:\\n            root.right =  self.insertIntoBST(root.right,val)\\n        else:\\n            root.left  =  self.insertIntoBST(root.left,val)\\n        return root \\n        \"\"\"\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def insertIntoBST(self, root, val):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type val: int\\n        :rtype: TreeNode\\n        \"\"\"\\n\\t\\t\"\"\"Iterative\"\"\"\\n        if not root: return TreeNode(val)\\n        cur = root\\n        while True:\\n            if cur.val < val:\\n                if cur.right: cur = cur.right\\n                else: \\n                    cur.right = TreeNode(val)\\n                    break\\n            else:\\n                if cur.left: cur = cur.left\\n                else:\\n                    cur.left = TreeNode(val)\\n                    break\\n        \\n        return root\\n        \\n        \"\"\"Recursive\"\"\"\\n        \"\"\"\\n        if not root:\\n             return TreeNode(val)\\n        if root.val < val:\\n            root.right =  self.insertIntoBST(root.right,val)\\n        else:\\n            root.left  =  self.insertIntoBST(root.left,val)\\n        return root \\n        \"\"\"\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 291978,
                "title": "simple-javascript-solution",
                "content": "```\\nconst insertIntoBST = (root, val) => {\\n\\tif (!root) {\\n  \\troot = new TreeNode(val);\\n  } else {\\n  \\tlet currentNode = root;\\n    while(currentNode) {\\n    \\tif (currentNode.val < val) {\\n      \\tif (currentNode.right === null) {\\n        \\tcurrentNode.right = new TreeNode(val);\\n          break;\\n        } else {\\n        \\tcurrentNode = currentNode.right;\\n        }      \\t\\n      } else {\\n      \\tif (currentNode.left === null) {\\n        \\tcurrentNode.left = new TreeNode(val);\\n          break;\\n        } else {\\n\\t        currentNode = currentNode.left\\n        }\\n      }\\n    }\\n  }\\n  \\n  return root;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst insertIntoBST = (root, val) => {\\n\\tif (!root) {\\n  \\troot = new TreeNode(val);\\n  } else {\\n  \\tlet currentNode = root;\\n    while(currentNode) {\\n    \\tif (currentNode.val < val) {\\n      \\tif (currentNode.right === null) {\\n        \\tcurrentNode.right = new TreeNode(val);\\n          break;\\n        } else {\\n        \\tcurrentNode = currentNode.right;\\n        }      \\t\\n      } else {\\n      \\tif (currentNode.left === null) {\\n        \\tcurrentNode.left = new TreeNode(val);\\n          break;\\n        } else {\\n\\t        currentNode = currentNode.left\\n        }\\n      }\\n    }\\n  }\\n  \\n  return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 151607,
                "title": "java-beats-100-simple-and-elegant-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)\\n            return new TreeNode(val);\\n        if(root.val < val)\\n            root.right=insertIntoBST(root.right, val);\\n        else\\n            root.left=insertIntoBST(root.left, val);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)\\n            return new TreeNode(val);\\n        if(root.val < val)\\n            root.right=insertIntoBST(root.right, val);\\n        else\\n            root.left=insertIntoBST(root.left, val);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405262,
                "title": "c-iterative-detail-explanation-with-image",
                "content": "![image](https://assets.leetcode.com/users/images/0e6eff33-07e8-4dda-bf16-710b5fdef2fb_1660110086.704796.jpeg)\\n\\n1. Search for key value, if it is already present then we should not insert it.\\n2. So where it should get inserted? where root gets terminate \\n3. If suppose 38 is key value , it should be at right child of 35\\n4. But we should have pointer on 35 \\n5. We can have tail pointer for it\\n6. Create new node & link it with tail pointer\\n7. if key is greater than tail then link with right->child\\n8. else with left->child\\n\\n\\n\\t\\tif(root==NULL){\\n            return new TreeNode(val);\\n        }  \\n    \\t\\n        TreeNode* tail = NULL;\\n        TreeNode* p;\\n\\t\\tTreeNode* rt=root; \\n        while(rt!=NULL){\\n            tail = rt;\\n            if(rt->val==val) return NULL;\\n            else if(rt->val<val){\\n                rt = rt->right;\\n            }\\n            else rt = rt->left;\\n        }\\n        p = new TreeNode;\\n        p->val = val;\\n        if(p->val>tail->val)tail->right = p;\\n        else tail->left = p;\\n        \\n        return root;",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/0e6eff33-07e8-4dda-bf16-710b5fdef2fb_1660110086.704796.jpeg)\\n\\n1. Search for key value, if it is already present then we should not insert it.\\n2. So where it should get inserted? where root gets terminate \\n3. If suppose 38 is key value , it should be at right child of 35\\n4. But we should have pointer on 35 \\n5. We can have tail pointer for it\\n6. Create new node & link it with tail pointer\\n7. if key is greater than tail then link with right->child\\n8. else with left->child\\n\\n\\n\\t\\tif(root==NULL){\\n            return new TreeNode(val);\\n        }  \\n    \\t\\n        TreeNode* tail = NULL;\\n        TreeNode* p;\\n\\t\\tTreeNode* rt=root; \\n        while(rt!=NULL){\\n            tail = rt;\\n            if(rt->val==val) return NULL;\\n            else if(rt->val<val){\\n                rt = rt->right;\\n            }\\n            else rt = rt->left;\\n        }\\n        p = new TreeNode;\\n        p->val = val;\\n        if(p->val>tail->val)tail->right = p;\\n        else tail->left = p;\\n        \\n        return root;",
                "codeTag": "Unknown"
            },
            {
                "id": 881734,
                "title": "c-super-short-easy-most-efficient-solution",
                "content": "```\\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val)\\n{\\n    if (!root)\\n    {\\n        struct TreeNode* new_node = malloc(sizeof(struct TreeNode));\\n        new_node->val = val;\\n        new_node->left = NULL;\\n        new_node->right = NULL;\\n        \\n\\t    return new_node;\\n    }\\n\\t\\t\\t\\n    if (val > root->val)\\n\\t\\troot->right = insertIntoBST(root->right, val);\\n    else \\n\\t\\troot->left = insertIntoBST(root->left, val);\\n\\t\\t\\t\\n    return root;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val)\\n{\\n    if (!root)\\n    {\\n        struct TreeNode* new_node = malloc(sizeof(struct TreeNode));\\n        new_node->val = val;\\n        new_node->left = NULL;\\n        new_node->right = NULL;\\n        \\n\\t    return new_node;\\n    }\\n\\t\\t\\t\\n    if (val > root->val)\\n\\t\\troot->right = insertIntoBST(root->right, val);\\n    else \\n\\t\\troot->left = insertIntoBST(root->left, val);\\n\\t\\t\\t\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688990,
                "title": "c-iterative-vs-recursive-approaches-100-time-100-space",
                "content": "Because recursion here would probably just drain some more memory for no plausible reason (although I admit navigating a tree is more natural with recursion), we can start with the most challenging approach - iteration.\\n\\nWe will just use 2 support variables, both of the `TreeNode*` type:\\n* `current`, initialised with `root`;\\n* `newNode`, created using `val`.\\n\\nAt this point we want to check if we are given the edge case of an empty tree, in which case we just return `newNode`; otherwise we will then proceed with an infinite `while` loop and at each step we will search if we need to move `left` (`current->val > val`) or `right` (`current->val < val`), followed by another check;\\n* if we can move `left`/`right`, we do so updating `current` and `continue`;\\n* if not, we \"move\" `left`/`right` by attaching `newNode` as a matchingn new branch of `newNode` and `break` out of the loop.\\n\\nFinally, we return `root` :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        // support variables\\n        TreeNode *current = root, *newNode = new TreeNode(val);\\n        // edge case - empty tree\\n        if (!root) return newNode;\\n        // iterative search\\n        while (true) {\\n            if (current->val > val) {\\n                if (current->left) {\\n                    current = current->left;\\n                    continue;\\n                }\\n                current->left = newNode;\\n                break;\\n            } else {\\n                if (current->right) {\\n                    current = current->right;\\n                    continue;\\n                }\\n                current->right = newNode;\\n                break;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nSame logic, moved to recursion (through a helper function):\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* dfs(TreeNode *root, int val) {\\n        if (!root) return new TreeNode(val);\\n        if (root->val > val) {\\n            root->left = dfs(root->left, val);\\n            return root;\\n        }\\n        if (root->val < val) {\\n            root->right = dfs(root->right, val);\\n            return root;\\n        };\\n        return NULL;\\n    }\\n    TreeNode* insertIntoBST(TreeNode *root, int val) {\\n        return dfs(root, val);\\n    }\\n};\\n```\\n\\nA bit more hacky with the comma operator:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* dfs(TreeNode *root, int val) {\\n        if (!root) return new TreeNode(val);\\n        if (root->val > val) return (root->left = dfs(root->left, val), root);\\n        if (root->val < val) return (root->right = dfs(root->right, val), root);\\n        return NULL;\\n    }\\n    TreeNode* insertIntoBST(TreeNode *root, int val) {\\n        return dfs(root, val);\\n    }\\n};\\n```\\n\\nThat at this point we can conveniently convert into a one-liner:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* dfs(TreeNode *root, int val) {\\n        return !root ? new TreeNode(val) : root->val > val ? (root->left = dfs(root->left, val), root) : (root->right = dfs(root->right, val), root);\\n    }\\n    TreeNode* insertIntoBST(TreeNode *root, int val) {\\n        return dfs(root, val);\\n    }\\n};\\n```\\n\\nBut, wait: who needs a helper function any longer, now?\\n\\nTime to cut some middlemen here:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode *root, int val) {\\n        return !root ? new TreeNode(val) : root->val > val ? (root->left = insertIntoBST(root->left, val), root) : (root->right = insertIntoBST(root->right, val), root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        // support variables\\n        TreeNode *current = root, *newNode = new TreeNode(val);\\n        // edge case - empty tree\\n        if (!root) return newNode;\\n        // iterative search\\n        while (true) {\\n            if (current->val > val) {\\n                if (current->left) {\\n                    current = current->left;\\n                    continue;\\n                }\\n                current->left = newNode;\\n                break;\\n            } else {\\n                if (current->right) {\\n                    current = current->right;\\n                    continue;\\n                }\\n                current->right = newNode;\\n                break;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* dfs(TreeNode *root, int val) {\\n        if (!root) return new TreeNode(val);\\n        if (root->val > val) {\\n            root->left = dfs(root->left, val);\\n            return root;\\n        }\\n        if (root->val < val) {\\n            root->right = dfs(root->right, val);\\n            return root;\\n        };\\n        return NULL;\\n    }\\n    TreeNode* insertIntoBST(TreeNode *root, int val) {\\n        return dfs(root, val);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* dfs(TreeNode *root, int val) {\\n        if (!root) return new TreeNode(val);\\n        if (root->val > val) return (root->left = dfs(root->left, val), root);\\n        if (root->val < val) return (root->right = dfs(root->right, val), root);\\n        return NULL;\\n    }\\n    TreeNode* insertIntoBST(TreeNode *root, int val) {\\n        return dfs(root, val);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* dfs(TreeNode *root, int val) {\\n        return !root ? new TreeNode(val) : root->val > val ? (root->left = dfs(root->left, val), root) : (root->right = dfs(root->right, val), root);\\n    }\\n    TreeNode* insertIntoBST(TreeNode *root, int val) {\\n        return dfs(root, val);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode *root, int val) {\\n        return !root ? new TreeNode(val) : root->val > val ? (root->left = insertIntoBST(root->left, val), root) : (root->right = insertIntoBST(root->right, val), root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526054,
                "title": "python-95-clean-and-short-with-a-detailed-explanation",
                "content": "The solution:\\n\\n```\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root: \\n            return TreeNode(val)\\n        if val < root.val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        else: \\n            root.right = self.insertIntoBST(root.right, val)\\n        return root\\n```\\n\\nHere is the explanation.\\n\\nFirst off, let\\'s think how many logical operations we need. On a high level, we make 2 decisions:\\n\\n1. Are we going to create a new node at this level or traverse down? \\n2. Are we going to traverse left or right? \\n\\nSo in theory, all we need is just 2 `if` statements. Okey, that sounds promising. \\n\\nNow we need to review our interfaces. Since we are given a function already, it comes with pre-defined parameters (root and val) and the return value (root). Are they sufficient to pass data between recursive calls? If not, we might need to either define a helper function with a more appropriate interface or use some global variables. In this case we are in luck, the predefined function interface is sufficient.\\n\\nOkey, now we just need to put it all together.\\n\\n1. The first `if` is to decide if we are ending recursing or going down. That\\'s simply:\\n\\n```\\n        if not root: \\n            return TreeNode(val)\\n```\\n\\n2. And the second if is to decide left or right.  The one `if` version is:\\n\\n```\\n        if val < root.val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        else: \\n            root.right = self.insertIntoBST(root.right, val)\\n\\t\\treturn root\\n```\\n\\nWhile this code is supershort, it might be possible to optimize. \\n\\nIn this model we chose left side when `val < root.val` and we choose right if `val >= root.val`. See the difference between `<` and `>=`? That means if val is equal to root.val we always prefer right over left side. Now just imagine if we start with an empty tree and keep adding value `1`. This funtion would keep adding 1s to to the right creating a very deep and unbalanced tree - exactly opposite of what BST is meant to be.\\n\\nSo we can try to optimize our code and add 3rd `if`, something like (root is replaced with r and val with v to keep it shorter):\\n\\n```\\nclass Solution:\\n    def insertIntoBST(self, r: TreeNode, v: int) -> TreeNode:\\n        if not r: \\n            return TreeNode(v)\\n        if v == r.val:\\n\\t        if not r.left:\\n\\t\\t        r.left = TreeNode(v)\\n\\t\\t        return r\\n\\t        elif not r.right:\\n\\t\\t        r.right = TreeNode(v)\\n\\t\\t        return r\\n        if v < r.val:\\n            r.left = self.insertIntoBST(r.left, v)\\n        else: \\n            r.right = self.insertIntoBST(r.right, v)\\n        return r\\n```\\n\\nBut optimizing a special case comes with a price.\\n\\nObvious pro: The BST is likely to be better balanced\\n\\nObvious con: The code is longer\\n\\nNot so obvious things:  Now we have a lottery. We are going to pay a small fixed price to check if val == root.val for every non empty node. This is like buying a ticket at every stop. But we only get a pay out if this condition happens to be true and if we have no left node. Is it going to be a net win or loss? That really depends on the use cases. For the test cases provided with the problem, there is no significant difference, both approaches top at about 95%. So I\\'d say based on the provided tests we should go with the first shorter version of the code.\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root: \\n            return TreeNode(val)\\n        if val < root.val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        else: \\n            root.right = self.insertIntoBST(root.right, val)\\n        return root\\n```\n```\\n        if not root: \\n            return TreeNode(val)\\n```\n```\\n        if val < root.val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        else: \\n            root.right = self.insertIntoBST(root.right, val)\\n\\t\\treturn root\\n```\n```\\nclass Solution:\\n    def insertIntoBST(self, r: TreeNode, v: int) -> TreeNode:\\n        if not r: \\n            return TreeNode(v)\\n        if v == r.val:\\n\\t        if not r.left:\\n\\t\\t        r.left = TreeNode(v)\\n\\t\\t        return r\\n\\t        elif not r.right:\\n\\t\\t        r.right = TreeNode(v)\\n\\t\\t        return r\\n        if v < r.val:\\n            r.left = self.insertIntoBST(r.left, v)\\n        else: \\n            r.right = self.insertIntoBST(r.right, v)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 177852,
                "title": "short-java-solution-beats-100",
                "content": "We need to assign the new node when we reach null. Once we reach null in that subtree, we return the new node to the parent. \\n\\n```class Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if(val < root.val)\\n            root.left = insertIntoBST(root.left, val);\\n        else \\n            root.right = insertIntoBST(root.right, val);\\n        \\n        return root;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if(val < root.val)\\n            root.left = insertIntoBST(root.left, val);\\n        else \\n            root.right = insertIntoBST(root.right, val);\\n        \\n        return root;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269096,
                "title": "best-o-logn-solution",
                "content": "# Approach\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root == NULL)\\n            return new TreeNode(val);\\n        TreeNode* curr = root;    \\n        while (true) {\\n            if (curr->val < val) {\\n                if (curr->right != NULL)\\n                    curr = curr->right;\\n                else {\\n                    curr->right = new TreeNode(val);\\n                    break;\\n                }    \\n            } else {\\n                if (curr->left != NULL)\\n                    curr = curr->left;\\n                else {\\n                    curr->left = new TreeNode(val);\\n                    break;\\n                }    \\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root == NULL)\\n            return new TreeNode(val);\\n        TreeNode* curr = root;    \\n        while (true) {\\n            if (curr->val < val) {\\n                if (curr->right != NULL)\\n                    curr = curr->right;\\n                else {\\n                    curr->right = new TreeNode(val);\\n                    break;\\n                }    \\n            } else {\\n                if (curr->left != NULL)\\n                    curr = curr->left;\\n                else {\\n                    curr->left = new TreeNode(val);\\n                    break;\\n                }    \\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2538085,
                "title": "easiest-approach-damn-easy-hell-easy",
                "content": "# Easiest Pseudocode :D\\n# Upvote \\uD83D\\uDD3C\\u2705\\n\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null){\\n            TreeNode insert = new TreeNode(val);\\n            return insert;\\n        }\\n        if(root.val > val){\\n            root.left = insertIntoBST(root.left , val);\\n        }\\n        else if(root.val < val){\\n            root.right = insertIntoBST(root.right , val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null){\\n            TreeNode insert = new TreeNode(val);\\n            return insert;\\n        }\\n        if(root.val > val){\\n            root.left = insertIntoBST(root.left , val);\\n        }\\n        else if(root.val < val){\\n            root.right = insertIntoBST(root.right , val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180670,
                "title": "python3-recursive-solution",
                "content": "```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root == None:\\n            return TreeNode(val)\\n        \\n        def insert(root):\\n            if root == None:\\n                return TreeNode(val)\\n            if val < root.val:\\n                if root.left:\\n                    insert(root.left)\\n                else:\\n                    root.left = insert(root.left)\\n            else:\\n                if root.right:\\n                    insert(root.right)\\n                else:\\n                    root.right = insert(root.right)\\n        \\n        insert(root)\\n        return root\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root == None:\\n            return TreeNode(val)\\n        \\n        def insert(root):\\n            if root == None:\\n                return TreeNode(val)\\n            if val < root.val:\\n                if root.left:\\n                    insert(root.left)\\n                else:\\n                    root.left = insert(root.left)\\n            else:\\n                if root.right:\\n                    insert(root.right)\\n                else:\\n                    root.right = insert(root.right)\\n        \\n        insert(root)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685450,
                "title": "easy-to-understand-c-solution",
                "content": "#### **Approach:**\\nIf the ***root*** is empty, the new tree node can be returned as the root node.\\n\\nOtherwise compare ***root. val*** is related to the size of the target value:\\n\\n* If ***root. val*** is greater than the target value, indicating that the target value should be inserted into the left subtree of the root.For thet we have to reach to the leftmost node of the left subtree.\\n*  If ***root. val*** is lesser than the target value, indicating that the target value should be inserted into the right subtree of the root.For thet we have to reach to the rightmost node of the right subtree.\\n\\n**C++ Code:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root) return new TreeNode(val);\\n        TreeNode* temp=root;\\n        while(true){\\n            if(val<=temp->val){\\n                if(temp->left!=NULL){\\n                    temp=temp->left;\\n                }\\n                else{\\n                    temp->left=new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(temp->right!=NULL){\\n                    temp=temp->right;\\n                }\\n                else{\\n                    temp->right=new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n\\n```\\n\\n***Time Complexity* :**  BigO(N), where N is height of binary search tree.\\n***Space Complexity* :** BigO(1)\\n\\nIf you understood than don\\'t forget to upvote \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root) return new TreeNode(val);\\n        TreeNode* temp=root;\\n        while(true){\\n            if(val<=temp->val){\\n                if(temp->left!=NULL){\\n                    temp=temp->left;\\n                }\\n                else{\\n                    temp->left=new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(temp->right!=NULL){\\n                    temp=temp->right;\\n                }\\n                else{\\n                    temp->right=new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684012,
                "title": "c-simple-intuitive-solution-w-explanation",
                "content": "We need to insert the given value in the Binary Search Tree.\\n\\n**APPROACH :**\\n\\n* Insertion in a BST is always done at a leaf node.\\n* But which leaf node is to be chosen is decided using the BST properties :\\n            1. If the root is ```NULL```, create a new node, make it the root & return it.\\n            2. If ```val``` is less than the ```root->val```, then the given value should be inserted into the ```left subtree``` of the root.\\n            3. If the val is greater than ```root->val```, the given value should be inserted into the ```right subtree``` of the root.\\n\\n**ALGORITHM : Recursive**\\n* If ```root==NULL```, create a new node with value equal to ```val``` & return the node.\\n* If ```val``` is less than ```root->val```, then recursively call the function on the left subtree of the root & insert the node at a leaf node.\\n* If ```val``` is greater than ```root->val```, then recursively call the function on the right subtree & insert the node at the leaf node.\\n* Finally return the ```root```.\\n\\n**Code : Recursive**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (!root) {\\n            TreeNode *newNode = new TreeNode(val);\\n            return newNode;\\n\\t\\t}\\n        if(val < root->val) root->left = insertIntoBST(root->left, val);\\n        \\n        else root->right = insertIntoBST(root->right, val);\\n        \\n        return root;\\n    }\\n};\\n```\\n\\n**ALGORITHM : Iterative**\\n\\n* If ```root==NULL```, create a new node whose value is equal to ```val```, make it the root & return it.\\n* If root is present, traverse the tree using a pointer ```currr``` initially pointing to the root.\\n* If ```val``` is less than ```curr->val```, then move ```curr``` to point to the left child :\\n              1. If the left child is present again compare ```val``` with it\\'s children nodes\\' values & move the ```curr``` pointer.\\n              2. If not, create a new node with value as ```val``` & make it it\\'s left child.\\n* If ```val``` is greater than ```curr->val```, then move ```curr``` to point to the right child.\\n             1. If the right child is present keep moving the ```curr``` pointer.\\n             2. If not, create a new node with value as ```val``` & make it it\\'s right child.\\n\\n**Code : Iterative**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root) return new TreeNode(val);\\n        TreeNode *curr = root;\\n        while(true){\\n            if(val < curr->val){\\n                if(curr->left) cur = curr->left;\\n                else curr->left = new TreeNode(val); break;\\n            }else{\\n                if(curr->right) curr = curr->right;\\n                else curr->right = new TreeNode(val); break;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**Time Complexity :** O(h) - h = height of the BST (In the worst case, the tree might be skewed & the time complexity degrades to O(n) - n = no. of nodes in the BST\\n\\n**Space Complexity :** O(1)\\n\\n**If you like my solution & explanation, please upvote my post :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```NULL```\n```val```\n```root->val```\n```left subtree```\n```root->val```\n```right subtree```\n```root==NULL```\n```val```\n```val```\n```root->val```\n```val```\n```root->val```\n```root```\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (!root) {\\n            TreeNode *newNode = new TreeNode(val);\\n            return newNode;\\n\\t\\t}\\n        if(val < root->val) root->left = insertIntoBST(root->left, val);\\n        \\n        else root->right = insertIntoBST(root->right, val);\\n        \\n        return root;\\n    }\\n};\\n```\n```root==NULL```\n```val```\n```currr```\n```val```\n```curr->val```\n```curr```\n```val```\n```curr```\n```val```\n```val```\n```curr->val```\n```curr```\n```curr```\n```val```\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root) return new TreeNode(val);\\n        TreeNode *curr = root;\\n        while(true){\\n            if(val < curr->val){\\n                if(curr->left) cur = curr->left;\\n                else curr->left = new TreeNode(val); break;\\n            }else{\\n                if(curr->right) curr = curr->right;\\n                else curr->right = new TreeNode(val); break;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681958,
                "title": "this-should-not-be-a-medium-q-it-is-really-easy-my-java-solution-o-logn-simple-and-easy",
                "content": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null){\\n            return new TreeNode(val,null,null);\\n        }\\n        if(val<root.val){\\n            root.left=insertIntoBST(root.left,val);\\n        }else if(val>root.val){\\n            root.right=insertIntoBST(root.right,val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null){\\n            return new TreeNode(val,null,null);\\n        }\\n        if(val<root.val){\\n            root.left=insertIntoBST(root.left,val);\\n        }else if(val>root.val){\\n            root.right=insertIntoBST(root.right,val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518838,
                "title": "python-simplest-iterative-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root:\\n            return TreeNode(val)\\n        tempRoot = root\\n        while root:\\n            if root.val < val:\\n                if not root.right:\\n                    root.right = TreeNode(val)\\n                    break\\n                root = root.right\\n            else:\\n                if not root.left:\\n                    root.left = TreeNode(val)\\n                    break\\n                root = root.left\\n        return tempRoot\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root:\\n            return TreeNode(val)\\n        tempRoot = root\\n        while root:\\n            if root.val < val:\\n                if not root.right:\\n                    root.right = TreeNode(val)\\n                    break\\n                root = root.right\\n            else:\\n                if not root.left:\\n                    root.left = TreeNode(val)\\n                    break\\n                root = root.left\\n        return tempRoot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1495527,
                "title": "c-4-line-code",
                "content": "```\\nTreeNode* insertIntoBST(TreeNode* root, int val) {\\n     \\n        if(root == NULL) return new TreeNode(val);\\n        \\n        if(root->val >= val) root->left = insertIntoBST(root->left, val);\\n        else if(root->val < val) root->right = insertIntoBST(root->right, val);\\n        \\n        return root;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* insertIntoBST(TreeNode* root, int val) {\\n     \\n        if(root == NULL) return new TreeNode(val);\\n        \\n        if(root->val >= val) root->left = insertIntoBST(root->left, val);\\n        else if(root->val < val) root->right = insertIntoBST(root->right, val);\\n        \\n        return root;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 990356,
                "title": "simple-c-program",
                "content": "TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode *n=new TreeNode(val);\\n        if(root==NULL){\\n            return n;\\n        }\\n        if(root->val>val && root->left==NULL){\\n            root->left=n;\\n        }\\n        else if(root->val<val && root->right==NULL){\\n            root->right=n;\\n        }\\n        else if(root->val>val && root->left!=NULL){\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        else if(root->val<val && root->right!=NULL){\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        return root;\\n    }",
                "solutionTags": [],
                "code": "TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode *n=new TreeNode(val);\\n        if(root==NULL){\\n            return n;\\n        }\\n        if(root->val>val && root->left==NULL){\\n            root->left=n;\\n        }\\n        else if(root->val<val && root->right==NULL){\\n            root->right=n;\\n        }\\n        else if(root->val>val && root->left!=NULL){\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        else if(root->val<val && root->right!=NULL){\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 881625,
                "title": "c-simple-and-clean-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void InitNode(TreeNode* node, int val)\\n    {\\n        node->val = val;\\n        node->left = NULL;\\n        node->right = NULL;\\n    }\\n    \\n    \\n    void InsertNode(TreeNode** root, TreeNode* newNode)\\n    {\\n        if (!*root)\\n            *root = newNode;\\n        \\n        else\\n        {\\n            if (newNode->val < (*root)->val)\\n                InsertNode(&(*root)->left, newNode);\\n            \\n            else if(newNode->val > (*root)->val)\\n                InsertNode(&(*root)->right, newNode);\\n            \\n            else\\n                delete newNode;\\n            \\n        }\\n    }\\n\\n\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode* new_node = new TreeNode;\\n        InitNode(new_node, val);\\n        InsertNode(&root, new_node);\\n        return root;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void InitNode(TreeNode* node, int val)\\n    {\\n        node->val = val;\\n        node->left = NULL;\\n        node->right = NULL;\\n    }\\n    \\n    \\n    void InsertNode(TreeNode** root, TreeNode* newNode)\\n    {\\n        if (!*root)\\n            *root = newNode;\\n        \\n        else\\n        {\\n            if (newNode->val < (*root)->val)\\n                InsertNode(&(*root)->left, newNode);\\n            \\n            else if(newNode->val > (*root)->val)\\n                InsertNode(&(*root)->right, newNode);\\n            \\n            else\\n                delete newNode;\\n            \\n        }\\n    }\\n\\n\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode* new_node = new TreeNode;\\n        InitNode(new_node, val);\\n        InsertNode(&root, new_node);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481609,
                "title": "c-solution",
                "content": "```\\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val){\\n    struct TreeNode *p = root, *parent=NULL;\\n    struct TreeNode* node = malloc(sizeof(struct TreeNode));\\n    node->left = NULL;\\n    node->right = NULL;\\n    node->val = val;\\n    if(!root){\\n        return node;\\n    }\\n    while (p) {\\n        parent = p;\\n        p = (val>p->val)?p->right:p->left;\\n    }\\n    if(val>parent->val){\\n        parent->right = node;\\n    }else{\\n        parent->left = node;\\n    }\\n    return root;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val){\\n    struct TreeNode *p = root, *parent=NULL;\\n    struct TreeNode* node = malloc(sizeof(struct TreeNode));\\n    node->left = NULL;\\n    node->right = NULL;\\n    node->val = val;\\n    if(!root){\\n        return node;\\n    }\\n    while (p) {\\n        parent = p;\\n        p = (val>p->val)?p->right:p->left;\\n    }\\n    if(val>parent->val){\\n        parent->right = node;\\n    }else{\\n        parent->left = node;\\n    }\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 339444,
                "title": "iterative-soluton-in-c",
                "content": "```\\npublic class Solution {\\n    public TreeNode InsertIntoBST(TreeNode root, int val) {\\n     TreeNode curr=root, parent=null;\\n        if(root==null)return new TreeNode(val);\\n        while(curr!=null){\\n            parent = curr;\\n            if(curr.val < val)\\n                curr=curr.right;\\n            else \\n                curr=curr.left;\\n            \\n            \\n        }\\n        if(parent.val < val)  parent.right=new TreeNode(val);\\n        else parent.left=new TreeNode(val);\\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode InsertIntoBST(TreeNode root, int val) {\\n     TreeNode curr=root, parent=null;\\n        if(root==null)return new TreeNode(val);\\n        while(curr!=null){\\n            parent = curr;\\n            if(curr.val < val)\\n                curr=curr.right;\\n            else \\n                curr=curr.left;\\n            \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 294323,
                "title": "a-recursive-golang-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc insertIntoBST(root *TreeNode, val int) *TreeNode {\\n    if root == nil{\\n        return &TreeNode{Val: val}\\n    }\\n    \\n    \\n    if root.Val > val{\\n        root.Left = insertIntoBST(root.Left, val)\\n    }else{\\n        root.Right = insertIntoBST(root.Right, val)\\n    }\\n    \\n    return root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc insertIntoBST(root *TreeNode, val int) *TreeNode {\\n    if root == nil{\\n        return &TreeNode{Val: val}\\n    }\\n    \\n    \\n    if root.Val > val{\\n        root.Left = insertIntoBST(root.Left, val)\\n    }else{\\n        root.Right = insertIntoBST(root.Right, val)\\n    }\\n    \\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172060,
                "title": "super-short-java-solution",
                "content": "```\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if(root.val > val) root.left = insertIntoBST(root.left, val);\\n        else root.right = insertIntoBST(root.right, val);\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if(root.val > val) root.left = insertIntoBST(root.left, val);\\n        else root.right = insertIntoBST(root.right, val);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3728090,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        node = TreeNode(val)\\n        if not root:\\n            root = node\\n            return root\\n        if not root.left and val < root.val:\\n            root.left = node\\n        elif not root.right and val > root.val:\\n            root.right = node\\n        \\n        elif val < root.val:\\n            self.insertIntoBST(root.left, val)\\n        else:\\n            self.insertIntoBST(root.right, val)\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        node = TreeNode(val)\\n        if not root:\\n            root = node\\n            return root\\n        if not root.left and val < root.val:\\n            root.left = node\\n        elif not root.right and val > root.val:\\n            root.right = node\\n        \\n        elif val < root.val:\\n            self.insertIntoBST(root.left, val)\\n        else:\\n            self.insertIntoBST(root.right, val)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463283,
                "title": "very-simple-java-solution",
                "content": "# Complexity\\n- Time complexity: Avg. Case: O(H), Worst Case: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) {\\n            return new TreeNode(val);\\n        }\\n        \\n        TreeNode curr = root;\\n        \\n        while (true) {\\n            if (val < curr.val) {\\n                if (curr.left == null) {\\n                    curr.left = new TreeNode(val);\\n                    break;\\n                } else {\\n                    curr = curr.left;\\n                }\\n            } else if (val > curr.val) {\\n                if (curr.right == null) {\\n                    curr.right = new TreeNode(val);\\n                    break;\\n                } else {\\n                    curr = curr.right;\\n                }\\n            } else {\\n                // val is already in the tree, do nothing\\n                break;\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) {\\n            return new TreeNode(val);\\n        }\\n        \\n        TreeNode curr = root;\\n        \\n        while (true) {\\n            if (val < curr.val) {\\n                if (curr.left == null) {\\n                    curr.left = new TreeNode(val);\\n                    break;\\n                } else {\\n                    curr = curr.left;\\n                }\\n            } else if (val > curr.val) {\\n                if (curr.right == null) {\\n                    curr.right = new TreeNode(val);\\n                    break;\\n                } else {\\n                    curr = curr.right;\\n                }\\n            } else {\\n                // val is already in the tree, do nothing\\n                break;\\n            }\\n        }\\n        \\n        return root;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396521,
                "title": "insert-into-a-bst-java-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null) return new TreeNode(val);\\n        TreeNode curr = root;\\n        while(true){\\n            if(curr.val>val){\\n                if(curr.left!=null) curr=curr.left;\\n                else{\\n                    curr.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(curr.right!=null) curr=curr.right;\\n                else{\\n                    curr.right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null) return new TreeNode(val);\\n        TreeNode curr = root;\\n        while(true){\\n            if(curr.val>val){\\n                if(curr.left!=null) curr=curr.left;\\n                else{\\n                    curr.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(curr.right!=null) curr=curr.right;\\n                else{\\n                    curr.right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271241,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(h), h is the height of the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), n is the number of nodes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)\\n        {\\n            root=new TreeNode(val);\\n            root.left=null;\\n            root.right=null;\\n        }\\n        else if(val<root.val)root.left=insertIntoBST(root.left,val);\\n        else root.right=insertIntoBST(root.right,val);\\n        return root;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)\\n        {\\n            root=new TreeNode(val);\\n            root.left=null;\\n            root.right=null;\\n        }\\n        else if(val<root.val)root.left=insertIntoBST(root.left,val);\\n        else root.right=insertIntoBST(root.right,val);\\n        return root;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958893,
                "title": "easy-c-solution",
                "content": "# Approach\\nWe follow the BST logic. Given a root of a subtree, all nodes with keys less than the root key are in the left subtree and all nodes with keys greater than the root key are in the right subtree. \\nAll nodes are inserted as leaves. Starting from the root we compare the value that we want to insert with the root key and decide to continue searching either in the left subtree or in the right subrtee. \\nIf the root becomes nullptr, we have found our value\\'s place => we add it.\\n\\n# Complexity\\n- Time complexity:\\nO(h) h = max depth of the tree \\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void insert(TreeNode*& root, int val)\\n    {\\n        if(root == nullptr){\\n            root = new TreeNode(val);\\n            return;\\n        }\\n        if(root->val <= val)\\n            insert(root->right, val);\\n        else\\n            insert(root->left, val);\\n           \\n    }\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        insert(root, val);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void insert(TreeNode*& root, int val)\\n    {\\n        if(root == nullptr){\\n            root = new TreeNode(val);\\n            return;\\n        }\\n        if(root->val <= val)\\n            insert(root->right, val);\\n        else\\n            insert(root->left, val);\\n           \\n    }\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        insert(root, val);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877555,
                "title": "striver-method-o-h-fastest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst find the suitable position of key node which insert.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStriver Method\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(h)$$\\nwhere h is height of BST\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int key) {\\n        if(!root){\\n            // TreeNode * node = new TreeNode(key);\\n            \\n            return  new TreeNode(key) ;\\n        }\\n        if(root->val > key){\\n            root->left = insertIntoBST(root->left,key);\\n\\n        }\\n        else{\\n            root->right = insertIntoBST(root->right, key);\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int key) {\\n        if(!root){\\n            // TreeNode * node = new TreeNode(key);\\n            \\n            return  new TreeNode(key) ;\\n        }\\n        if(root->val > key){\\n            root->left = insertIntoBST(root->left,key);\\n\\n        }\\n        else{\\n            root->right = insertIntoBST(root->right, key);\\n        }\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787031,
                "title": "c-solution-insert-into-a-binary-search-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL)\\n            return new TreeNode(val);\\n        \\n        if(root->val > val){\\n            root->left = insertIntoBST(root->left , val);\\n        }\\n        \\n        else\\n            root->right = insertIntoBST(root->right , val);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL)\\n            return new TreeNode(val);\\n        \\n        if(root->val > val){\\n            root->left = insertIntoBST(root->left , val);\\n        }\\n        \\n        else\\n            root->right = insertIntoBST(root->right , val);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768042,
                "title": "huh-100-faster-simple-java-solution-i-bet-for-the-best-easy-to-understand",
                "content": "Upvote if you liked the solution\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n         if(root==null)\\n            return new TreeNode(val);\\n        if(root.val>val)\\n            root.left = insertIntoBST(root.left,val);\\n        else\\n            root.right = insertIntoBST(root.right,val);\\n        return root;\\n    }\\n}\\n/*\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        \\n        TreeNode curr = root;\\n        \\n        while(true){\\n            if(curr.val < val){\\n                if(curr.right != null) curr = curr.right;\\n                else {\\n                    curr.right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(curr.left != null) curr = curr.left;\\n                else{\\n                    curr.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n*/",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n         if(root==null)\\n            return new TreeNode(val);\\n        if(root.val>val)\\n            root.left = insertIntoBST(root.left,val);\\n        else\\n            root.right = insertIntoBST(root.right,val);\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2707046,
                "title": "701-insert-into-a-binary-search-tree-0-ms-solution",
                "content": "Pls upvote if you find the sol helpfull :)\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) \\n    {\\n        \\n        if(root==null)\\n            return new TreeNode(val);\\n            if(root.val<val){\\n            root.right =insertIntoBST(root.right, val);\\n            }\\n        else{\\n      root.left  =insertIntoBST(root.left, val);\\n        }\\n        return root;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) \\n    {\\n        \\n        if(root==null)\\n            return new TreeNode(val);\\n            if(root.val<val){\\n            root.right =insertIntoBST(root.right, val);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2689161,
                "title": "0ms-faster-than-100-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int key) {\\n         if(root==null) return root=new TreeNode(key);\\n        \\n        if(root.val<key){\\n            root.right=insertIntoBST(root.right,key);\\n        }\\n        else if(root.val>key){\\n            root.left=insertIntoBST(root.left,key);\\n        }\\n        // your code here\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int key) {\\n         if(root==null) return root=new TreeNode(key);\\n        \\n        if(root.val<key){\\n            root.right=insertIntoBST(root.right,key);\\n        }\\n        else if(root.val>key){\\n            root.left=insertIntoBST(root.left,key);\\n        }\\n        // your code here\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395784,
                "title": "c-4-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root) return new TreeNode(val) ;\\n        if(val < root->val) root->left = insertIntoBST(root->left,val) ;\\n        else root->right = insertIntoBST(root->right,val) ;\\n        return root ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root) return new TreeNode(val) ;\\n        if(val < root->val) root->left = insertIntoBST(root->left,val) ;\\n        else root->right = insertIntoBST(root->right,val) ;\\n        return root ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391743,
                "title": "java-recursive-solution-0ms-100-faster",
                "content": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n      \\n     if(root.val > val) root.left = insertIntoBST(root.left, val);\\n      \\n      else root.right = insertIntoBST(root.right, val);\\n      \\n      return root;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n      \\n     if(root.val > val) root.left = insertIntoBST(root.left, val);\\n      \\n      else root.right = insertIntoBST(root.right, val);\\n      \\n      return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1903792,
                "title": "well-explaination-java-and-c-code-with-notes",
                "content": "\\n**Java**\\n\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        // create copy of root because at the end u need to return root itself\\n        TreeNode cur = root;\\n        while(true){\\n            //  right side\\n            if(cur.val <= val){\\n                if(cur.right != null) cur = cur.right;\\n                else {\\n                    // if its null\\n                    cur.right = new TreeNode(val);\\n                    break;\\n                }\\n            } // left side\\n            else {\\n                if(cur.left != null) cur = cur.left;\\n                else {\\n                    // if its null\\n                    cur.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n    \\n}\\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL) return new TreeNode(val);\\n        TreeNode *cur = root;\\n        while(true) {\\n            if(cur->val <= val) {\\n                if(cur->right != NULL) cur = cur->right;\\n                else {\\n                    cur->right = new TreeNode(val);\\n                    break;\\n                }\\n            } else {\\n                if(cur->left != NULL) cur = cur->left;\\n                else {\\n                    cur->left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**Notes Link** : https://github.com/rizonkumar/LeetCode-Notes/blob/main/701.pdf",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        // create copy of root because at the end u need to return root itself\\n        TreeNode cur = root;\\n        while(true){\\n            //  right side\\n            if(cur.val <= val){\\n                if(cur.right != null) cur = cur.right;\\n                else {\\n                    // if its null\\n                    cur.right = new TreeNode(val);\\n                    break;\\n                }\\n            } // left side\\n            else {\\n                if(cur.left != null) cur = cur.left;\\n                else {\\n                    // if its null\\n                    cur.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL) return new TreeNode(val);\\n        TreeNode *cur = root;\\n        while(true) {\\n            if(cur->val <= val) {\\n                if(cur->right != NULL) cur = cur->right;\\n                else {\\n                    cur->right = new TreeNode(val);\\n                    break;\\n                }\\n            } else {\\n                if(cur->left != NULL) cur = cur->left;\\n                else {\\n                    cur->left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767632,
                "title": "easy-java-iterative-solution",
                "content": "``` \\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null) return new TreeNode(val);\\n        TreeNode curr = root;\\n        TreeNode prev = root;\\n        while(curr!=null){\\n            prev = curr;\\n            if(val < curr.val) curr = curr.left;\\n            else if(val > curr.val) curr = curr.right;\\n        }\\n        if(val<prev.val) prev.left = new TreeNode(val);\\n        if(val>prev.val) prev.right = new TreeNode(val);\\n        return root;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null) return new TreeNode(val);\\n        TreeNode curr = root;\\n        TreeNode prev = root;\\n        while(curr!=null){\\n            prev = curr;\\n            if(val < curr.val) curr = curr.left;\\n            else if(val > curr.val) curr = curr.right;\\n        }\\n        if(val<prev.val) prev.left = new TreeNode(val);\\n        if(val>prev.val) prev.right = new TreeNode(val);\\n        return root;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684780,
                "title": "c-c-simple-and-clean-recursive-solutions",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (!root) \\n            return new TreeNode(val);\\n        \\n        if (root->val < val) \\n            root->right = insertIntoBST(root->right, val);\\n        else \\n            root->left = insertIntoBST(root->left, val);\\n        \\n        return root;\\n    }\\n};\\n```\\n****\\n**C:**\\n```\\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val) {\\n    if (!root) {\\n        struct TreeNode* new_node = malloc(sizeof(struct TreeNode));\\n        new_node->val = val;\\n        new_node->left = NULL;\\n        new_node->right = NULL;\\n        return new_node;\\n    }\\n    \\n    if (root->val < val) \\n        root->right = insertIntoBST(root->right, val);\\n    else\\n        root->left = insertIntoBST(root->left, val);\\n        \\n    return root;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (!root) \\n            return new TreeNode(val);\\n        \\n        if (root->val < val) \\n            root->right = insertIntoBST(root->right, val);\\n        else \\n            root->left = insertIntoBST(root->left, val);\\n        \\n        return root;\\n    }\\n};\\n```\n```\\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val) {\\n    if (!root) {\\n        struct TreeNode* new_node = malloc(sizeof(struct TreeNode));\\n        new_node->val = val;\\n        new_node->left = NULL;\\n        new_node->right = NULL;\\n        return new_node;\\n    }\\n    \\n    if (root->val < val) \\n        root->right = insertIntoBST(root->right, val);\\n    else\\n        root->left = insertIntoBST(root->left, val);\\n        \\n    return root;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684225,
                "title": "c-4-lines-recursive-solution",
                "content": "```\\nTreeNode* insertIntoBST(TreeNode* root, int val) {\\n    if(!root) return new TreeNode(val);\\n    if(root->val > val) root->left = insertIntoBST(root->left,val);\\n    else root->right = insertIntoBST(root->right,val);\\n    return root;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\nTreeNode* insertIntoBST(TreeNode* root, int val) {\\n    if(!root) return new TreeNode(val);\\n    if(root->val > val) root->left = insertIntoBST(root->left,val);\\n    else root->right = insertIntoBST(root->right,val);\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1637459,
                "title": "java-easy-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n        TreeNode node = root;\\n        TreeNode prev = root;\\n        while(node!=null){\\n            prev = node;\\n            if(node.val > val) node = node.left;\\n            else if(node.val < val) node = node.right;\\n        } \\n        if(prev.val > val) prev.left = new TreeNode(val);\\n        else prev.right = new TreeNode(val);\\n        return root;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n        TreeNode node = root;\\n        TreeNode prev = root;\\n        while(node!=null){\\n            prev = node;\\n            if(node.val > val) node = node.left;\\n            else if(node.val < val) node = node.right;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1429301,
                "title": "c-4-line-recursive-code-clean-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == nullptr) return (new TreeNode(val));\\n        \\n        if(root->val > val) root->left = insertIntoBST(root->left, val);\\n        else root->right = insertIntoBST(root->right, val);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == nullptr) return (new TreeNode(val));\\n        \\n        if(root->val > val) root->left = insertIntoBST(root->left, val);\\n        else root->right = insertIntoBST(root->right, val);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881774,
                "title": "javascript-clean-5-liner-solution",
                "content": "```javascript\\nvar insertIntoBST = function(root, val) {\\n    \\n    function recurse(node) {\\n        if(!node) return new TreeNode(val);\\n        if(val > node.val) node.right = recurse(node.right);\\n        else node.left = recurse(node.left);\\n        return node;\\n    }\\n    return recurse(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nvar insertIntoBST = function(root, val) {\\n    \\n    function recurse(node) {\\n        if(!node) return new TreeNode(val);\\n        if(val > node.val) node.right = recurse(node.right);\\n        else node.left = recurse(node.left);\\n        return node;\\n    }\\n    return recurse(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 881618,
                "title": "c-clear-easy-and-simple-solution",
                "content": "```\\nvoid InitNode(struct TreeNode* node, int val)\\n{\\n    node->val = val;\\n    node->left = NULL;\\n    node->right = NULL;\\n}\\n    \\n    \\nvoid InsertNode(struct TreeNode** root, struct TreeNode* newNode)\\n{\\n    if (!*root)\\n        *root = newNode;\\n    \\n    else\\n    {\\n        if (newNode->val < (*root)->val)\\n            InsertNode(&(*root)->left, newNode);\\n        \\n        else if(newNode->val > (*root)->val)\\n            InsertNode(&(*root)->right, newNode);\\n        \\n        else\\n            free(newNode) ;\\n    }\\n}\\n\\n\\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val){\\n    struct TreeNode* new_node = malloc(sizeof(struct TreeNode));\\n    InitNode(new_node, val);\\n    InsertNode(&root, new_node);\\n    return root;\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid InitNode(struct TreeNode* node, int val)\\n{\\n    node->val = val;\\n    node->left = NULL;\\n    node->right = NULL;\\n}\\n    \\n    \\nvoid InsertNode(struct TreeNode** root, struct TreeNode* newNode)\\n{\\n    if (!*root)\\n        *root = newNode;\\n    \\n    else\\n    {\\n        if (newNode->val < (*root)->val)\\n            InsertNode(&(*root)->left, newNode);\\n        \\n        else if(newNode->val > (*root)->val)\\n            InsertNode(&(*root)->right, newNode);\\n        \\n        else\\n            free(newNode) ;\\n    }\\n}\\n\\n\\nstruct TreeNode* insertIntoBST(struct TreeNode* root, int val){\\n    struct TreeNode* new_node = malloc(sizeof(struct TreeNode));\\n    InitNode(new_node, val);\\n    InsertNode(&root, new_node);\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 373442,
                "title": "python-recursive-solution-bottom-up-approach-96ms",
                "content": "```\\ndef insertIntoBST(self, root, val):\\n        if not root:\\n            return TreeNode(val)\\n        if(val<root.val):\\n            root.left=self.insertIntoBST(root.left,val)          #Telling the parent node that this node will be the parent of the inserted node\\n        elif(val>root.val):\\n            root.right=self.insertIntoBST(root.right,val)    \\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\ndef insertIntoBST(self, root, val):\\n        if not root:\\n            return TreeNode(val)\\n        if(val<root.val):\\n            root.left=self.insertIntoBST(root.left,val)          #Telling the parent node that this node will be the parent of the inserted node\\n        elif(val>root.val):\\n            root.right=self.insertIntoBST(root.right,val)    \\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 351814,
                "title": "c-iterative-and-recursive-solutions",
                "content": "ITERATIVE -\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) \\n    {\\n        TreeNode * cur = root, * node = new TreeNode(val);\\n        while (cur) \\n        {\\n            if (val < cur -> val) \\n            {\\n                if (cur -> left) \\n                    cur = cur -> left;\\n                else \\n                {\\n                    cur -> left = node;\\n                    break;\\n                }\\n            } \\n            else \\n            {\\n                if (cur -> right) \\n                    cur = cur -> right;\\n                else \\n                {\\n                    cur -> right = node;\\n                    break;\\n                }\\n            }\\n        }\\n        return root ? root : node;\\n    }\\n};\\n```\\nRECURSIVE - \\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) \\n    {\\n        if(!root)\\n            return new TreeNode(val);\\n        if(val < root -> val)\\n            root -> left = insertIntoBST(root -> left, val);\\n        else root -> right = insertIntoBST(root -> right, val);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) \\n    {\\n        TreeNode * cur = root, * node = new TreeNode(val);\\n        while (cur) \\n        {\\n            if (val < cur -> val) \\n            {\\n                if (cur -> left) \\n                    cur = cur -> left;\\n                else \\n                {\\n                    cur -> left = node;\\n                    break;\\n                }\\n            } \\n            else \\n            {\\n                if (cur -> right) \\n                    cur = cur -> right;\\n                else \\n                {\\n                    cur -> right = node;\\n                    break;\\n                }\\n            }\\n        }\\n        return root ? root : node;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) \\n    {\\n        if(!root)\\n            return new TreeNode(val);\\n        if(val < root -> val)\\n            root -> left = insertIntoBST(root -> left, val);\\n        else root -> right = insertIntoBST(root -> right, val);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234412,
                "title": "swift-232ms",
                "content": "```swift\\nfunc insertIntoBST(_ root: TreeNode?, _ val: Int) -> TreeNode? {\\n\\tguard let node = root else { return TreeNode(val) }\\n\\tif val < node.val {\\n\\t\\tnode.left = insertIntoBST(node.left, val)\\n\\t} else {\\n\\t\\t node.right  = insertIntoBST(node.right, val)\\n\\t}\\n\\treturn node\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nfunc insertIntoBST(_ root: TreeNode?, _ val: Int) -> TreeNode? {\\n\\tguard let node = root else { return TreeNode(val) }\\n\\tif val < node.val {\\n\\t\\tnode.left = insertIntoBST(node.left, val)\\n\\t} else {\\n\\t\\t node.right  = insertIntoBST(node.right, val)\\n\\t}\\n\\treturn node\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 220119,
                "title": "python-iterative",
                "content": "```\\nclass Solution:\\n    def insertIntoBST(self, root, val):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type val: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        if root == None:\\n            return TreeNode(val)\\n        p = root\\n        while p:\\n            if val < p.val:\\n                if p.left:\\n                    p = p.left\\n                else:\\n                    p.left = TreeNode(val)\\n                    break\\n            else:\\n                if p.right:\\n                    p = p.right\\n                else:\\n                    p.right = TreeNode(val)\\n                    break\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root, val):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type val: int\\n        :rtype: TreeNode\\n        \"\"\"\\n        if root == None:\\n            return TreeNode(val)\\n        p = root\\n        while p:\\n            if val < p.val:\\n                if p.left:\\n                    p = p.left\\n                else:\\n                    p.left = TreeNode(val)\\n                    break\\n            else:\\n                if p.right:\\n                    p = p.right\\n                else:\\n                    p.right = TreeNode(val)\\n                    break\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175218,
                "title": "java-iterative-and-recursive-solution",
                "content": "The first thought come into my mind is iterative solution, but I prefer recursive solution cause it\\'s more concise and clean. I need more pratice on recursive thinking \\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        TreeNode p = root;\\n        while (p != null) {\\n            if (p.val > val) {\\n                if (p.left == null) {\\n                    p.left = new TreeNode(val);\\n                    break;\\n                }\\n                p = p.left;\\n            } else {\\n                if (p.right == null) {\\n                    p.right = new TreeNode(val);\\n                    break;\\n                }\\n                p = p.right;\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n##### recursive:\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null)   return new TreeNode(val);\\n        \\n        if (root.val > val) {\\n            root.left = insertIntoBST(root.left, val);\\n        } else {\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        TreeNode p = root;\\n        while (p != null) {\\n            if (p.val > val) {\\n                if (p.left == null) {\\n                    p.left = new TreeNode(val);\\n                    break;\\n                }\\n                p = p.left;\\n            } else {\\n                if (p.right == null) {\\n                    p.right = new TreeNode(val);\\n                    break;\\n                }\\n                p = p.right;\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null)   return new TreeNode(val);\\n        \\n        if (root.val > val) {\\n            root.left = insertIntoBST(root.left, val);\\n        } else {\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148962,
                "title": "python-3-lines-dfs-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def insertIntoBST(self, root, val):\\n        if root and root.val > val and not self.insertIntoBST(root.left, val): root.left = TreeNode(val)\\n        elif root and root.val < val and not self.insertIntoBST(root.right, val): root.right = TreeNode(val)\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root, val):\\n        if root and root.val > val and not self.insertIntoBST(root.left, val): root.left = TreeNode(val)\\n        elif root and root.val < val and not self.insertIntoBST(root.right, val): root.right = TreeNode(val)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970026,
                "title": "best-recursive-and-iterative-solutions-image-and-video-explanation-beats-100",
                "content": "# [Video link](https://youtu.be/UeRUKRJvPa4?feature=shared)\\n\\n#### Image credits to @hi-malik\\n![image.png](https://assets.leetcode.com/users/images/7ec5e1d9-61da-4d64-b7e5-d830dd435d10_1693198478.4838505.png)\\n\\n\\n# Code\\n```\\n// Recursive solution\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        // If root does not exist, insert val in new node and return\\n        if(root == NULL){\\n            TreeNode *node = new TreeNode(val);\\n            return node;\\n        }\\n        \\n        // If val is more than root->val then go to right of root\\n        if(val > root->val)\\n            root->right = insertIntoBST(root->right, val);\\n        \\n        // If val is less than root->val then go to left of root\\n        if(val < root->val)\\n            root->left = insertIntoBST(root->left, val);\\n        \\n        return root;\\n    }\\n};\\n\\n// Iterative solution\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL)\\n            return new TreeNode(val);\\n        \\n        TreeNode *curr = root;\\n        while(true){\\n            if(val < curr->val){\\n                if(curr->left != NULL)\\n                    curr = curr->left;\\n                else{\\n                    curr->left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(curr->right != NULL)\\n                    curr = curr->right;\\n                else{\\n                    curr->right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive solution\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        // If root does not exist, insert val in new node and return\\n        if(root == NULL){\\n            TreeNode *node = new TreeNode(val);\\n            return node;\\n        }\\n        \\n        // If val is more than root->val then go to right of root\\n        if(val > root->val)\\n            root->right = insertIntoBST(root->right, val);\\n        \\n        // If val is less than root->val then go to left of root\\n        if(val < root->val)\\n            root->left = insertIntoBST(root->left, val);\\n        \\n        return root;\\n    }\\n};\\n\\n// Iterative solution\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL)\\n            return new TreeNode(val);\\n        \\n        TreeNode *curr = root;\\n        while(true){\\n            if(val < curr->val){\\n                if(curr->left != NULL)\\n                    curr = curr->left;\\n                else{\\n                    curr->left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(curr->right != NULL)\\n                    curr = curr->right;\\n                else{\\n                    curr->right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716414,
                "title": "cpp-solution-completely-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code inserts a new node with a given value into a binary search tree (BST) while maintaining the BST property.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a function insertIntoBST() that takes a pointer to the root of the BST root and an integer val as arguments. It performs the following steps to insert the new node:\\n\\nCreate a temporary pointer r and set it to NULL. This pointer will keep track of the parent node while traversing the BST to find the appropriate position for insertion.\\nCheck if root is NULL. If so, create a new TreeNode with the value val and return it as the new root.\\nSet a temporary pointer t to root. Start traversing the BST from the root.\\nWhile t is not NULL, update r to t and move t to its left or right child based on the value of val. If val is greater than the value of the current node t->val, move t to its right child; otherwise, move t to its left child.\\nCreate a new TreeNode with the value val.\\nCheck if r->val > val. If true, set p as the left child of r; otherwise, set p as the right child of r.\\nReturn the root of the BST.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code traverses the BST to find the appropriate position for insertion, which takes O(h) time in the worst case, where h is the height of the BST. In the average case, the time complexity is O(log n) for a balanced BST and O(n) for an unbalanced BST, where n is the number of nodes in the BST.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a constant amount of additional space, so the space complexity is O(1).\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode*r=NULL;\\n        if(root==NULL)\\n        {\\n            TreeNode* p= new TreeNode(val);\\n            return p;\\n        }\\n        TreeNode*t=root;\\n        while(t){\\n            r=t;\\n            if(t->val<val){\\n                t=t->right;\\n            }\\n            else\\n            t=t->left;\\n        }\\n        TreeNode* p= new TreeNode(val);\\n        if(r->val>val){\\n            r->left=p;\\n        }\\n        else\\n        r->right=p;\\n\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode*r=NULL;\\n        if(root==NULL)\\n        {\\n            TreeNode* p= new TreeNode(val);\\n            return p;\\n        }\\n        TreeNode*t=root;\\n        while(t){\\n            r=t;\\n            if(t->val<val){\\n                t=t->right;\\n            }\\n            else\\n            t=t->left;\\n        }\\n        TreeNode* p= new TreeNode(val);\\n        if(r->val>val){\\n            r->left=p;\\n        }\\n        else\\n        r->right=p;\\n\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678409,
                "title": "full-algo-explanation-c-easy-to-understand-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we can output any tree that is a BST we can just insert the new node to the correct leaf node where it belongs to.\\n# Algo\\n- Make a new node with given val\\n- Check if root node is null if yes then return the new node\\n- Traverse the tree till you find the approapriate root node using property of BST that all nodes in left subtree are < root and all nodes in right subtree are > root.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode* temp = new TreeNode(val);\\n        if(root==NULL) return temp;\\n        TreeNode* head = root;\\n        while(true)\\n        {\\n            if(val > root->val)\\n            {\\n                if(root->right) root = root->right;\\n                else\\n                {\\n                    root->right = temp;\\n                    break;\\n                } \\n            }\\n            else\\n            {\\n                if(root->left) root= root->left;\\n                else \\n                {\\n                    root->left = temp;\\n                    break;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n**If you find it to be Helpful please Upvote, it really helps me out. \\nAlso if you have any doubts just post them in comments down below, I\\'ll be happy to help.**",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode* temp = new TreeNode(val);\\n        if(root==NULL) return temp;\\n        TreeNode* head = root;\\n        while(true)\\n        {\\n            if(val > root->val)\\n            {\\n                if(root->right) root = root->right;\\n                else\\n                {\\n                    root->right = temp;\\n                    break;\\n                } \\n            }\\n            else\\n            {\\n                if(root->left) root= root->left;\\n                else \\n                {\\n                    root->left = temp;\\n                    break;\\n                }\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672360,
                "title": "c-easiest-and-self-explanatory-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        // try to insert the node on the leaf wherever it should be so we will check for it \\n        if(root==NULL) return new TreeNode(val);\\n        TreeNode* cur=root;\\n        while(true){\\n            if(cur->val<val){\\n                if(cur->right) cur=cur->right;\\n                else {\\n                    cur->right=new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(cur->left) cur=cur->left;\\n                else{\\n                    cur->left=new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        // try to insert the node on the leaf wherever it should be so we will check for it \\n        if(root==NULL) return new TreeNode(val);\\n        TreeNode* cur=root;\\n        while(true){\\n            if(cur->val<val){\\n                if(cur->right) cur=cur->right;\\n                else {\\n                    cur->right=new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{\\n                if(cur->left) cur=cur->left;\\n                else{\\n                    cur->left=new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650949,
                "title": "c-recursive-easy-explained",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- **Base Case :** if root is NULL \\nMeaning root hasn\\'t been created yet, so create a node using constructor by passing the val. \\n```\\n    if (root == NULL)\\n    {\\n        root = new TreeNode(val) ; \\n        // need to return root or else stack overflow occurs (FUNCTION CALL STACK OVERFLOW -> Segmentation Fault) \\n        return root ; \\n    }\\n```\\n- ***BST\\'s don\\'t have duplicate nodes***, so check if at any instant root\\'s data is equal to val means we don\\'t have to make any change \\n```\\n    // BST\\'s dont have duplicate values \\n    if (root -> val == val)\\n    {\\n        return root ; \\n    }\\n```\\n\\n- Now, **recursive traversal statements** based on the comparison of data & the **BST property**.\\n- *If data of root is lesser than the val passed, the node will be created in the right subtree.*\\n```\\n    if (root -> val < val)\\n    {\\n        root -> right = insertIntoBST(root -> right, val) ; \\n    }\\n```\\n- *Else, node will be created in the left subtree*\\n```\\n    else\\n    {\\n        root -> left = insertIntoBST(root -> left, val) ; \\n    }\\n```\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n\\n        // if root is NULL meaning first node hasnt been formed yet \\n        // so we create the root node \\n        if (root == NULL)\\n        {\\n            root = new TreeNode(val) ; \\n            // need to return root or else stack overflow occurs (FUNCTION CALL STACK OVERFLOW -> Segmentation Fault) \\n            return root ; \\n        }\\n\\n        // BST\\'s dont have duplicate values \\n        if (root -> val == val)\\n        {\\n            return root ; \\n        }\\n\\n        // else if root is NOT null \\n        // so we have to compare the root value with the given data to be inserted to decide whether it goes left or right \\n        if (root -> val < val)\\n        {\\n            root -> right = insertIntoBST(root -> right, val) ; \\n        }\\n\\n        else\\n        {\\n            root -> left = insertIntoBST(root -> left, val) ; \\n        }\\n\\n        return root ; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/57ad5169-f0cb-41b4-9667-40a88b9ecd12_1687064833.363184.png)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n    if (root == NULL)\\n    {\\n        root = new TreeNode(val) ; \\n        // need to return root or else stack overflow occurs (FUNCTION CALL STACK OVERFLOW -> Segmentation Fault) \\n        return root ; \\n    }\\n```\n```\\n    // BST\\'s dont have duplicate values \\n    if (root -> val == val)\\n    {\\n        return root ; \\n    }\\n```\n```\\n    if (root -> val < val)\\n    {\\n        root -> right = insertIntoBST(root -> right, val) ; \\n    }\\n```\n```\\n    else\\n    {\\n        root -> left = insertIntoBST(root -> left, val) ; \\n    }\\n```\n```C++ []\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n\\n        // if root is NULL meaning first node hasnt been formed yet \\n        // so we create the root node \\n        if (root == NULL)\\n        {\\n            root = new TreeNode(val) ; \\n            // need to return root or else stack overflow occurs (FUNCTION CALL STACK OVERFLOW -> Segmentation Fault) \\n            return root ; \\n        }\\n\\n        // BST\\'s dont have duplicate values \\n        if (root -> val == val)\\n        {\\n            return root ; \\n        }\\n\\n        // else if root is NOT null \\n        // so we have to compare the root value with the given data to be inserted to decide whether it goes left or right \\n        if (root -> val < val)\\n        {\\n            root -> right = insertIntoBST(root -> right, val) ; \\n        }\\n\\n        else\\n        {\\n            root -> left = insertIntoBST(root -> left, val) ; \\n        }\\n\\n        return root ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606867,
                "title": "java-easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)return new TreeNode(val);\\n        if(val<root.val)\\n        {\\n            if(root.left!=null)\\n            {\\n                insertIntoBST(root.left,val);\\n            }\\n            else\\n            root.left=new TreeNode(val);\\n        }   \\n        else if(val>root.val)\\n        {\\n            if(root.right!=null)\\n            {\\n                insertIntoBST(root.right,val);\\n            }\\n            else\\n            {\\n                root.right=new TreeNode(val);\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)return new TreeNode(val);\\n        if(val<root.val)\\n        {\\n            if(root.left!=null)\\n            {\\n                insertIntoBST(root.left,val);\\n            }\\n            else\\n            root.left=new TreeNode(val);\\n        }   \\n        else if(val>root.val)\\n        {\\n            if(root.right!=null)\\n            {\\n                insertIntoBST(root.right,val);\\n            }\\n            else\\n            {\\n                root.right=new TreeNode(val);\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601564,
                "title": "100-for-beginners",
                "content": "# Code\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) {\\n            root = new TreeNode(val);\\n            return root;\\n        }\\n        if(val < root.val) {\\n            root.left = insertIntoBST(root.left, val);\\n        } else {\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) {\\n            root = new TreeNode(val);\\n            return root;\\n        }\\n        if(val < root.val) {\\n            root.left = insertIntoBST(root.left, val);\\n        } else {\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505070,
                "title": "easy-c-solution-using-recursion",
                "content": "\\n# Approach\\nif root==null then create a newnode tagret and insert it\\nif (target>root->val) then traverse right\\nelse left \\nreturn root atlast \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n\\n- Space complexity:just a node is created \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root,  int target) {\\n        if(root==NULL)\\n        {\\n            return new TreeNode(target);\\n        }\\n        else if (target>root->val)\\n        {\\n            root->right=insertIntoBST(root->right,target);\\n        }\\n        else \\n        {\\n            root->left=insertIntoBST(root->left,target);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root,  int target) {\\n        if(root==NULL)\\n        {\\n            return new TreeNode(target);\\n        }\\n        else if (target>root->val)\\n        {\\n            root->right=insertIntoBST(root->right,target);\\n        }\\n        else \\n        {\\n            root->left=insertIntoBST(root->left,target);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462876,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL){\\n           return new TreeNode(val);\\n        }\\n        if(val < root->val){\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        else{\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def insert(self, root, val):\\n        if not root:\\n            return TreeNode(val)\\n        if val <= root.val:\\n            root.left = self.insert(root.left, val)\\n        else:\\n            root.right = self.insert(root.right, val)\\n        return root\\n\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        return self.insert(root, val)\\n```\\n\\n```Java []\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if(root.val > val) root.left = insertIntoBST(root.left, val);\\n        else root.right = insertIntoBST(root.right, val);\\n        return root;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL){\\n           return new TreeNode(val);\\n        }\\n        if(val < root->val){\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        else{\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        return root;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def insert(self, root, val):\\n        if not root:\\n            return TreeNode(val)\\n        if val <= root.val:\\n            root.left = self.insert(root.left, val)\\n        else:\\n            root.right = self.insert(root.right, val)\\n        return root\\n\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        return self.insert(root, val)\\n```\n```Java []\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if(root.val > val) root.left = insertIntoBST(root.left, val);\\n        else root.right = insertIntoBST(root.right, val);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445568,
                "title": "simple-c-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root){\\n            return new TreeNode(val);\\n        }\\n        if(root->val>val){\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        else if(root->val<val){\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root){\\n            return new TreeNode(val);\\n        }\\n        if(root->val>val){\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        else if(root->val<val){\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328536,
                "title": "701-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Check if the root is null (i.e., the tree is empty). If the root is null, create a new node with the given value and return it as the new root of the BST.\\n2. If the root is not null, compare the value of the root with the given value to determine where to insert the new value.\\n3. If the value of the root is greater than the given value, insert the new value in the left subtree. Call the insertIntoBST function recursively on the left child node of the root and the given value as arguments.\\n4. If the value of the root is less than the given value, insert the new value in the right subtree. Call the insertIntoBST function recursively on the right child node of the root and the given value as arguments.\\n5. After the insertion is complete, return the root node of the BST.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n    # if the root is null, create a new node with the given val and return it as the new root of the BST\\n    if root is None:\\n        return TreeNode(val)\\n    \\n    # if the value of the root is greater than the given val, insert the new value in the left subtree\\n    if root.val > val:\\n        root.left = self.insertIntoBST(root.left, val)\\n        \\n    # if the value of the root is less than the given val, insert the new value in the right subtree\\n    else:\\n        root.right = self.insertIntoBST(root.right, val)\\n    \\n    # return the root of the BST after the insertion\\n    return root\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n  def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n    # if the root is null, create a new node with the given val and return it as the new root of the BST\\n    if root is None:\\n        return TreeNode(val)\\n    \\n    # if the value of the root is greater than the given val, insert the new value in the left subtree\\n    if root.val > val:\\n        root.left = self.insertIntoBST(root.left, val)\\n        \\n    # if the value of the root is less than the given val, insert the new value in the right subtree\\n    else:\\n        root.right = self.insertIntoBST(root.right, val)\\n    \\n    # return the root of the BST after the insertion\\n    return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308666,
                "title": "easiest-efficient-solution-in-5-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity \\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlssssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null){\\n            root = new TreeNode(val);\\n            return root;  }\\n        if(root.val>val) root.left = insertIntoBST(root.left, val);\\n        else root.right = insertIntoBST(root.right, val);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null){\\n            root = new TreeNode(val);\\n            return root;  }\\n        if(root.val>val) root.left = insertIntoBST(root.left, val);\\n        else root.right = insertIntoBST(root.right, val);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308188,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL) return new TreeNode(val);\\n        if(val < root->val) root->left = insertIntoBST(root->left, val);\\n        else root->right = insertIntoBST(root->right, val);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL) return new TreeNode(val);\\n        if(val < root->val) root->left = insertIntoBST(root->left, val);\\n        else root->right = insertIntoBST(root->right, val);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301723,
                "title": "best-and-efficient-recursive-solution-in-python",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root == None:\\n            return TreeNode(val)\\n        if root.val < val:\\n            root.right = self.insertIntoBST(root.right,val)\\n        else:\\n            root.left = self.insertIntoBST(root.left,val)\\n        return root\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root == None:\\n            return TreeNode(val)\\n        if root.val < val:\\n            root.right = self.insertIntoBST(root.right,val)\\n        else:\\n            root.left = self.insertIntoBST(root.left,val)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270983,
                "title": "c-recursion",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n- Space complexity: $$O(log(n))$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public TreeNode InsertIntoBST(TreeNode? root, int val)\\n    {\\n        if (root == null)\\n        {\\n            return new TreeNode(val);\\n        }\\n\\n        if (root.val > val)\\n        {\\n            root.left = InsertIntoBST(root.left, val);\\n        }\\n        else\\n        {\\n            root.right = InsertIntoBST(root.right, val);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public TreeNode InsertIntoBST(TreeNode? root, int val)\\n    {\\n        if (root == null)\\n        {\\n            return new TreeNode(val);\\n        }\\n\\n        if (root.val > val)\\n        {\\n            root.left = InsertIntoBST(root.left, val);\\n        }\\n        else\\n        {\\n            root.right = InsertIntoBST(root.right, val);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219329,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) {\\n            return new TreeNode(val);\\n        }\\n        TreeNode curr = root;\\n        while (true) {\\n            if (curr.val <= val) {\\n                if (curr.right != null) {\\n                    curr = curr.right;\\n                } else {\\n                    curr.right = new TreeNode(val);\\n                    break;\\n                }\\n            } else {\\n                if (curr.left != null) {\\n                    curr = curr.left;\\n                } else {\\n                    curr.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) {\\n            return new TreeNode(val);\\n        }\\n        TreeNode curr = root;\\n        while (true) {\\n            if (curr.val <= val) {\\n                if (curr.right != null) {\\n                    curr = curr.right;\\n                } else {\\n                    curr.right = new TreeNode(val);\\n                    break;\\n                }\\n            } else {\\n                if (curr.left != null) {\\n                    curr = curr.left;\\n                } else {\\n                    curr.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210864,
                "title": "java-easy-to-understand-0-ms-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   private void Helper(TreeNode root,int val)\\n   {\\n       if(val<root.val && root.left==null)\\n       {\\n           root.left=new TreeNode(val);\\n           return ;\\n       }\\n        else if(val>root.val && root.right==null)\\n       {\\n           root.right=new TreeNode(val);\\n           return ;\\n       }\\n       else if(val<root.val)\\n       {\\n           Helper(root.left,val);\\n       }\\n       else if(val>root.val)\\n       {\\n           Helper(root.right,val);\\n       }\\n       return;\\n\\n   }\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)\\n        {\\n            root=new TreeNode(val);\\n            return root;\\n        }\\n           \\n        Helper(root,val);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   private void Helper(TreeNode root,int val)\\n   {\\n       if(val<root.val && root.left==null)\\n       {\\n           root.left=new TreeNode(val);\\n           return ;\\n       }\\n        else if(val>root.val && root.right==null)\\n       {\\n           root.right=new TreeNode(val);\\n           return ;\\n       }\\n       else if(val<root.val)\\n       {\\n           Helper(root.left,val);\\n       }\\n       else if(val>root.val)\\n       {\\n           Helper(root.right,val);\\n       }\\n       return;\\n\\n   }\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)\\n        {\\n            root=new TreeNode(val);\\n            return root;\\n        }\\n           \\n        Helper(root,val);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131678,
                "title": "c-insert-in-binary-s-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe create a ins node and traverse whole tree when we find node is NULL we insert with ins node\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni)infine while loop\\nii) check  tmp->val >val then we have to insert our node in left side .If left side is NULL then we directly link our node with tmp otherwise go left\\n\\niii)similary for tmp->val <val then we have to insert node in right side and if right side is NULL then it means we reaches end point .just link tmp->right with ins node otherwise go right side \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)  n=node\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)  we did\\'nt use any data_structure \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\nTreeNode * ins=new TreeNode(val);\\nif(root==NULL)\\n{\\n    return ins;\\n}\\n\\nTreeNode* tmp=root;\\n\\n\\nwhile(1)\\n{\\n     if(tmp->val >val)\\n     {\\n         if(tmp->left)\\n         {tmp=tmp->left;}\\n         else\\n         {\\n             tmp->left=ins;\\n             return root;\\n         }\\n     }\\n     else if(tmp->val <val)\\n     {\\n\\n         if(tmp->right)\\n        { tmp=tmp->right;}\\n         else\\n         {\\n             tmp->right=ins;\\n             return root;\\n         }\\n\\n     }\\n\\n     \\n}\\nreturn root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\nTreeNode * ins=new TreeNode(val);\\nif(root==NULL)\\n{\\n    return ins;\\n}\\n\\nTreeNode* tmp=root;\\n\\n\\nwhile(1)\\n{\\n     if(tmp->val >val)\\n     {\\n         if(tmp->left)\\n         {tmp=tmp->left;}\\n         else\\n         {\\n             tmp->left=ins;\\n             return root;\\n         }\\n     }\\n     else if(tmp->val <val)\\n     {\\n\\n         if(tmp->right)\\n        { tmp=tmp->right;}\\n         else\\n         {\\n             tmp->right=ins;\\n             return root;\\n         }\\n\\n     }\\n\\n     \\n}\\nreturn root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053528,
                "title": "java-simple-easy-and-fast-solution",
                "content": "// Although there are various options available for a node for simplicity inserting it at leaf position and using the property of BST to reduce the time complexity \\nPlease upvote if understood \\n\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null){\\n            return new TreeNode(val);\\n        }\\n        if(val > root.val){\\n            root.right = insertIntoBST(root.right ,val);\\n        }else{\\n            root.left = insertIntoBST(root.left ,val);\\n        }\\n        return root ;\\n    }\\n",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "// Although there are various options available for a node for simplicity inserting it at leaf position and using the property of BST to reduce the time complexity \\nPlease upvote if understood \\n\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null){\\n            return new TreeNode(val);\\n        }\\n        if(val > root.val){\\n            root.right = insertIntoBST(root.right ,val);\\n        }else{\\n            root.left = insertIntoBST(root.left ,val);\\n        }\\n        return root ;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3012715,
                "title": "simple-loop-solution",
                "content": "\\n# Approach\\nCompare the value to insert  with node val and iterate to either left or right of the root node ..and shift the root to that nod\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode *ans=root;\\n        if(root == nullptr){\\n            return new TreeNode(val);\\n        }\\n        while(root){\\n            if(root->val < val){\\n                if(root->right){\\n                    root=root->right;\\n                }\\n                else{\\n                    TreeNode *ins =new TreeNode(val);\\n                    root->right=ins;\\n                    break;\\n                }\\n            }\\n            else{\\n                if(root->left){\\n                    root=root->left;\\n                }\\n                else{\\n                    TreeNode *ins =new TreeNode(val);\\n                    root->left=ins;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode *ans=root;\\n        if(root == nullptr){\\n            return new TreeNode(val);\\n        }\\n        while(root){\\n            if(root->val < val){\\n                if(root->right){\\n                    root=root->right;\\n                }\\n                else{\\n                    TreeNode *ins =new TreeNode(val);\\n                    root->right=ins;\\n                    break;\\n                }\\n            }\\n            else{\\n                if(root->left){\\n                    root=root->left;\\n                }\\n                else{\\n                    TreeNode *ins =new TreeNode(val);\\n                    root->left=ins;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972725,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the concepts of BST\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimply find the suitable last NULL node using recursion and place the node there.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(height of BST)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL)\\n        {\\n             root=new TreeNode(val);\\n            return root;\\n        }    \\n        else if(val>root->val)\\n        {\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        else\\n        {\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL)\\n        {\\n             root=new TreeNode(val);\\n            return root;\\n        }    \\n        else if(val>root->val)\\n        {\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        else\\n        {\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953761,
                "title": "c-binary-search-easy-simple-logic-clean",
                "content": "![image](https://assets.leetcode.com/users/images/67434741-6664-4d70-b414-3a7ec80efefa_1672062107.5927925.png)\\n\\n**T->O(logn) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* insertIntoBST(TreeNode* root,int val) {\\n\\t\\t\\tif(!root) return new TreeNode(val);\\n\\t\\t\\tTreeNode* curr=root;\\n\\t\\t\\twhile(curr){\\n\\t\\t\\t\\tif(curr->val>val){\\n\\t\\t\\t\\t\\tif(!curr->left){\\n\\t\\t\\t\\t\\t\\tcurr->left=new TreeNode(val);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr=curr->left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tif(!curr->right){\\n\\t\\t\\t\\t\\t\\tcurr->right=new TreeNode(val);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurr=curr->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* insertIntoBST(TreeNode* root,int val) {\\n\\t\\t\\tif(!root) return new TreeNode(val);\\n\\t\\t\\tTreeNode* curr=root;\\n\\t\\t\\twhile(curr){\\n\\t\\t\\t\\tif(curr->val>val){\\n\\t\\t\\t\\t\\tif(!curr->left){\\n\\t\\t\\t\\t\\t\\tcurr->left=new TreeNode(val);\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2919166,
                "title": "recursive-solution-100-beats-java",
                "content": "- 35/35 cases passed (0 ms)\\n- Your runtime beats 100 % of java submissions\\n- Your memory usage beats 87.77 % of java submissions (43 MB)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)root=new TreeNode(val);\\n        else if(root.val>val)root.left=insertIntoBST(root.left, val);\\n        else if(root.val<val)root.right=insertIntoBST(root.right, val);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)root=new TreeNode(val);\\n        else if(root.val>val)root.left=insertIntoBST(root.left, val);\\n        else if(root.val<val)root.right=insertIntoBST(root.right, val);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887831,
                "title": "golang-solution",
                "content": "# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc insertIntoBST(root *TreeNode, val int) *TreeNode {\\n\\treturn add(root, val)\\n}\\n\\nfunc add(leaf *TreeNode, val int) *TreeNode{\\n       if leaf == nil {\\n\\t\\treturn &TreeNode{\\n\\t\\t\\tLeft:  nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t\\tVal:   val,\\n\\t\\t}\\n\\t}\\n\\tswitch {\\n\\tcase leaf.Val > val:\\n\\t\\tleaf.Left = add(leaf.Left, val)\\n\\tcase leaf.Val < val:\\n\\t\\tleaf.Right = add(leaf.Right, val)\\n\\tcase leaf.Val == val:\\n\\t\\treturn leaf\\n\\t}\\n\\treturn leaf \\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc insertIntoBST(root *TreeNode, val int) *TreeNode {\\n\\treturn add(root, val)\\n}\\n\\nfunc add(leaf *TreeNode, val int) *TreeNode{\\n       if leaf == nil {\\n\\t\\treturn &TreeNode{\\n\\t\\t\\tLeft:  nil,\\n\\t\\t\\tRight: nil,\\n\\t\\t\\tVal:   val,\\n\\t\\t}\\n\\t}\\n\\tswitch {\\n\\tcase leaf.Val > val:\\n\\t\\tleaf.Left = add(leaf.Left, val)\\n\\tcase leaf.Val < val:\\n\\t\\tleaf.Right = add(leaf.Right, val)\\n\\tcase leaf.Val == val:\\n\\t\\treturn leaf\\n\\t}\\n\\treturn leaf \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2792685,
                "title": "2-easy-c-solution-iterative-recursive-bfs-dfs-both-ways",
                "content": "**Here is the Iterative Code :**\\nBFS\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root==NULL)return new TreeNode(val);\\n        TreeNode* curr= root;\\n        while (true){\\n            if (curr->val > val){\\n                if(curr->left)curr= curr->left;\\n                else{\\n                    curr->left= new TreeNode(val);\\n                    break;\\n                }\\n                \\n            }\\n            else{\\n                if(curr->right)curr= curr->right;\\n                else{\\n                    curr->right= new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```\\n\\n**Here is the Recursive Code :**\\nDFS\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root==NULL)return new TreeNode(val);\\n        if (root->val > val)root->left= insertIntoBST(root->left,val);\\n        else root->right= insertIntoBST(root->right,val);\\n        return root;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root==NULL)return new TreeNode(val);\\n        TreeNode* curr= root;\\n        while (true){\\n            if (curr->val > val){\\n                if(curr->left)curr= curr->left;\\n                else{\\n                    curr->left= new TreeNode(val);\\n                    break;\\n                }\\n                \\n            }\\n            else{\\n                if(curr->right)curr= curr->right;\\n                else{\\n                    curr->right= new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root==NULL)return new TreeNode(val);\\n        if (root->val > val)root->left= insertIntoBST(root->left,val);\\n        else root->right= insertIntoBST(root->right,val);\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785977,
                "title": "c-solution-iterative",
                "content": "Here is my C++ Solution:\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root==NULL)return new TreeNode(val);\\n        TreeNode* curr= root;\\n        while (true){\\n            if (curr->val > val){\\n                if(curr->left)curr= curr->left;\\n                else{\\n                    curr->left= new TreeNode(val);\\n                    break;\\n                }\\n                \\n            }\\n            else{\\n                if(curr->right)curr= curr->right;\\n                else{\\n                    curr->right= new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root==NULL)return new TreeNode(val);\\n        TreeNode* curr= root;\\n        while (true){\\n            if (curr->val > val){\\n                if(curr->left)curr= curr->left;\\n                else{\\n                    curr->left= new TreeNode(val);\\n                    break;\\n                }\\n                \\n            }\\n            else{\\n                if(curr->right)curr= curr->right;\\n                else{\\n                    curr->right= new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779941,
                "title": "c-beats-81-easy-and-simple-recursive-sol",
                "content": "# Intuition\\nIt\\'s pretty simple to think of a recursive solution.What i did, is to simply find the appropriate position where the new node should be placed.\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL)\\n        {\\n            TreeNode *newNode=new TreeNode(val);\\n            return newNode;\\n        }\\n        if(val>root->val)\\n        {\\n        // insert in left part (Here we also have to check value of nodes in left part, Therefore we use recursion)\\n        root->right=insertIntoBST(root->right,val);\\n        }\\n        else{\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL)\\n        {\\n            TreeNode *newNode=new TreeNode(val);\\n            return newNode;\\n        }\\n        if(val>root->val)\\n        {\\n        // insert in left part (Here we also have to check value of nodes in left part, Therefore we use recursion)\\n        root->right=insertIntoBST(root->right,val);\\n        }\\n        else{\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755692,
                "title": "java-iterative-and-recursive-clean-and-simple",
                "content": "### **Please Upvote** :D\\n##### 1. Iterative aproach:\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n\\n        TreeNode n = root;\\n\\n        while (true) {\\n            if (val < n.val) {\\n                if (n.left != null) n = n.left;\\n                else {\\n                    n.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else {\\n                if (n.right != null) n = n.right;\\n                else {\\n                    n.right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return root;\\n    }\\n}\\n\\n// TC: O(logn), SC: O(1)\\n```\\n\\n\\n##### 2. Recursive approach:\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n\\n        if (val < root.val) {\\n            root.left = insertIntoBST(root.left, val);\\n        }\\n        else {\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n\\n        return root;\\n    }\\n}\\n\\n// TC: O(h), SC: O(h)\\n// h -> height of the tree\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n\\n        TreeNode n = root;\\n\\n        while (true) {\\n            if (val < n.val) {\\n                if (n.left != null) n = n.left;\\n                else {\\n                    n.left = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else {\\n                if (n.right != null) n = n.right;\\n                else {\\n                    n.right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return root;\\n    }\\n}\\n\\n// TC: O(logn), SC: O(1)\\n```\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) return new TreeNode(val);\\n\\n        if (val < root.val) {\\n            root.left = insertIntoBST(root.left, val);\\n        }\\n        else {\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n\\n        return root;\\n    }\\n}\\n\\n// TC: O(h), SC: O(h)\\n// h -> height of the tree\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749781,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL){return new TreeNode(val);}\\n        TreeNode* r=root;\\n        while(true){\\n            if(r->val>=val){\\n                if(r->left){r=r->left;}\\n                else{r->left=new TreeNode(val); break;}\\n            }\\n            else{\\n                if(r->right){r=r->right;}\\n                else{r->right=new TreeNode(val); break;}\\n            }\\n        }\\n        return root;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL){return new TreeNode(val);}",
                "codeTag": "Java"
            },
            {
                "id": 2714923,
                "title": "2-solutions-in-javascript",
                "content": "TC of both solutions will be O(logn) for balanced BST and O(n) for unbalanced BST\\nRECURSIVE SOLUTION\\n```\\nvar insertIntoBST = function(root, val) {\\n    if(!root) {\\n        return new TreeNode(val);\\n    }\\n    if(root.val > val) {\\n        root.left = insertIntoBST(root.left,val);\\n    } else if(root.val < val) {\\n        root.right = insertIntoBST(root.right,val);\\n    } \\n    return root;\\n};\\n```\\n\\nITERATIVE SOLUTION\\n```\\nvar insertIntoBST = function(root, val) {\\n    if(!root) {\\n        return new TreeNode(val);\\n    }\\n    let temp = root, continueLoop = true;\\n    do {\\n        if(val < temp.val) {\\n            if(temp.left) {\\n                temp = temp.left;\\n            } else {\\n                temp.left = new TreeNode(val);\\n                continueLoop = false;\\n            }\\n            \\n        } else if(val > temp.val) {\\n            if(temp.right) {\\n                temp = temp.right;\\n            } else {\\n                temp.right = new TreeNode(val);\\n                continueLoop = false;\\n            }\\n        }\\n    } while(continueLoop);\\n    return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar insertIntoBST = function(root, val) {\\n    if(!root) {\\n        return new TreeNode(val);\\n    }\\n    if(root.val > val) {\\n        root.left = insertIntoBST(root.left,val);\\n    } else if(root.val < val) {\\n        root.right = insertIntoBST(root.right,val);\\n    } \\n    return root;\\n};\\n```\n```\\nvar insertIntoBST = function(root, val) {\\n    if(!root) {\\n        return new TreeNode(val);\\n    }\\n    let temp = root, continueLoop = true;\\n    do {\\n        if(val < temp.val) {\\n            if(temp.left) {\\n                temp = temp.left;\\n            } else {\\n                temp.left = new TreeNode(val);\\n                continueLoop = false;\\n            }\\n            \\n        } else if(val > temp.val) {\\n            if(temp.right) {\\n                temp = temp.right;\\n            } else {\\n                temp.right = new TreeNode(val);\\n                continueLoop = false;\\n            }\\n        }\\n    } while(continueLoop);\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2714774,
                "title": "python-java-recursive-solution",
                "content": "**Python Solution:**\\n```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root is None:\\n            return TreeNode(val)\\n        if root.val> val:\\n            root.left= self.insertIntoBST(root.left, val) \\n        else:\\n            root.right= self.insertIntoBST(root.right, val)\\n        return root\\n```\\n**Java Solution:**\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root== null)\\n            return new TreeNode(val);\\n        if (root.val > val)\\n            root.left= insertIntoBST(root.left, val);\\n        else\\n            root.right= insertIntoBST(root.right, val);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root is None:\\n            return TreeNode(val)\\n        if root.val> val:\\n            root.left= self.insertIntoBST(root.left, val) \\n        else:\\n            root.right= self.insertIntoBST(root.right, val)\\n        return root\\n```\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root== null)\\n            return new TreeNode(val);\\n        if (root.val > val)\\n            root.left= insertIntoBST(root.left, val);\\n        else\\n            root.right= insertIntoBST(root.right, val);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688465,
                "title": "python-easy-solution",
                "content": "```\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root:\\n            return TreeNode(val = val)\\n        \\n        if root.val > val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        \\n        if root.val < val:\\n            root.right = self.insertIntoBST(root.right, val)\\n        \\n        return root\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root:\\n            return TreeNode(val = val)\\n        \\n        if root.val > val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        \\n        if root.val < val:\\n            root.right = self.insertIntoBST(root.right, val)\\n        \\n        return root\\n\\t\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2510657,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root is None:\\n            return TreeNode(val)\\n        curr=root\\n        while True:\\n            if curr.val<=val:\\n                if curr.right:\\n                    curr=curr.right\\n                else:\\n                    curr.right=TreeNode(val)\\n                    break\\n            else:\\n                if curr.left:\\n                    curr=curr.left\\n                    \\n                else:\\n                    curr.left=TreeNode(val)\\n                    break\\n        return root\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if root is None:\\n            return TreeNode(val)\\n        curr=root\\n        while True:\\n            if curr.val<=val:\\n                if curr.right:\\n                    curr=curr.right\\n                else:\\n                    curr.right=TreeNode(val)\\n                    break\\n            else:\\n                if curr.left:\\n                    curr=curr.left\\n                    \\n                else:\\n                    curr.left=TreeNode(val)\\n                    break\\n        return root\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370046,
                "title": "c-iterative-approach-with-explanation-easily-understable-solution",
                "content": "TreeNode* insertIntoBST(TreeNode* root, int val) {\\n       \\n       if(root == NULL){\\n           return new TreeNode(val);\\n           \\n       } \\n        TreeNode* node = root;\\n        while(true){\\n            if(val > node->val){  // serching in the right tree\\n                if(node->right){  // the position is occupied continue to search\\n                    node = node->right;  \\n                }\\n                else{\\n                    // position is  empty insert position is found and break the loop\\n                    node->right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{  // continue serching in left  subtree\\n                if(node->left){\\n                    node = node->left;\\n                }\\n                else{\\n                    node->left= new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "TreeNode* insertIntoBST(TreeNode* root, int val) {\\n       \\n       if(root == NULL){\\n           return new TreeNode(val);\\n           \\n       } \\n        TreeNode* node = root;\\n        while(true){\\n            if(val > node->val){  // serching in the right tree\\n                if(node->right){  // the position is occupied continue to search\\n                    node = node->right;  \\n                }\\n                else{\\n                    // position is  empty insert position is found and break the loop\\n                    node->right = new TreeNode(val);\\n                    break;\\n                }\\n            }\\n            else{  // continue serching in left  subtree\\n                if(node->left){\\n                    node = node->left;\\n                }\\n                else{\\n                    node->left= new TreeNode(val);\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2341341,
                "title": "easy-c-solution-iterative-tc-o-height",
                "content": "**Solution -->**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL){\\n            root=new TreeNode(val);\\n            return root;\\n        }\\n        \\n        TreeNode* prev=NULL;\\n        TreeNode* temp=root;\\n        \\n        while(temp!=NULL){\\n            prev=temp;\\n            if(temp->val>val){\\n                temp=temp->left;\\n            }\\n            else if(temp->val<val){\\n                temp=temp->right;\\n            }\\n        }\\n        temp=prev;\\n        TreeNode* newNode=new  TreeNode(val);\\n        if(temp->val>val){\\n            temp->left=newNode;\\n        }\\n        else{\\n             temp->right=newNode;\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL){\\n            root=new TreeNode(val);\\n            return root;\\n        }\\n        \\n        TreeNode* prev=NULL;\\n        TreeNode* temp=root;\\n        \\n        while(temp!=NULL){\\n            prev=temp;\\n            if(temp->val>val){\\n                temp=temp->left;\\n            }\\n            else if(temp->val<val){\\n                temp=temp->right;\\n            }\\n        }\\n        temp=prev;\\n        TreeNode* newNode=new  TreeNode(val);\\n        if(temp->val>val){\\n            temp->left=newNode;\\n        }\\n        else{\\n             temp->right=newNode;\\n        }\\n        return root;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215156,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root == NULL) {\\n            return new TreeNode(val);\\n        }\\n        if (val > root -> val) {\\n            root -> right = insertIntoBST(root -> right, val);\\n        }\\n        if (val < root -> val) {\\n            root -> left = insertIntoBST(root -> left, val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root == NULL) {\\n            return new TreeNode(val);\\n        }\\n        if (val > root -> val) {\\n            root -> right = insertIntoBST(root -> right, val);\\n        }\\n        if (val < root -> val) {\\n            root -> left = insertIntoBST(root -> left, val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884096,
                "title": "insert-into-binary-search-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) \\n    {\\n        if(root == NULL) \\n        {\\n            root = new TreeNode(val);\\n        }\\n        \\n        else if(val >= (root-> val))\\n        {\\n            root->right = insertIntoBST(root->right, val);\\n        }\\n        \\n        else \\n        {\\n            root->left = insertIntoBST(root->left, val);\\n        }\\n        \\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) \\n    {\\n        if(root == NULL) \\n        {\\n            root = new TreeNode(val);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1752022,
                "title": "c-efficient-recursive-easy-3-steps-solution-with-approach-explanation",
                "content": "##### If you understand the approach please please upvote!!!\\n***Thanks :)***\\n\\n**Approach/steps :-**\\n*s1.  if root doesn\\'t exist, then return new TreeNode value\\ns2.  if root value is greater then value, it means our root value exist on left side\\ns3.  otherwise root value is lesser then value, it means our root value exist on right side\\ns4.  returning original root node*\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL){ //s1\\n            TreeNode *node=new TreeNode(val);\\n            return node;\\n        }\\n        if(val< root->val)\\n            root->left=insertIntoBST(root->left,val);//s2\\n        else\\n            root->right=insertIntoBST(root->right,val);//s3\\n        \\n        return root;//s4\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL){ //s1\\n            TreeNode *node=new TreeNode(val);\\n            return node;\\n        }\\n        if(val< root->val)\\n            root->left=insertIntoBST(root->left,val);//s2\\n        else\\n            root->right=insertIntoBST(root->right,val);//s3\\n        \\n        return root;//s4\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685621,
                "title": "python3-bfs-solution-o-n-time-iterative-approach-easy-to-understand",
                "content": "Perform BFS and look at each level to search for insertion point.\\nOnce we find it, insert the Node with value val and break the loop.\\n**Upvote** if you like the solution :)\\n\\n```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root:\\n            return TreeNode(val)\\n        \\n        # bfs\\n        d = deque()\\n        d.append(root)\\n        \\n        while d:\\n            node = d.popleft()\\n            \\n            if node.val > val:\\n                if node.left:\\n                    d.append(node.left)\\n                else:\\n                    node.left = TreeNode(val)\\n                    break\\n            else:\\n                if node.right:\\n                    d.append(node.right)\\n                else:\\n                    node.right = TreeNode(val)\\n                    break\\n        return root\\n```\\n\\n**Time Complexity** : O(N)\\n**Space Complexity**: O(height of the tree) = O(log N)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root:\\n            return TreeNode(val)\\n        \\n        # bfs\\n        d = deque()\\n        d.append(root)\\n        \\n        while d:\\n            node = d.popleft()\\n            \\n            if node.val > val:\\n                if node.left:\\n                    d.append(node.left)\\n                else:\\n                    node.left = TreeNode(val)\\n                    break\\n            else:\\n                if node.right:\\n                    d.append(node.right)\\n                else:\\n                    node.right = TreeNode(val)\\n                    break\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684490,
                "title": "99-fast-easy-to-understand-c-iterative-solution",
                "content": "**Please Upvote if you like it... :)**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL)\\n        {\\n            return new TreeNode(val);\\n        }\\n        TreeNode* curr = root;\\n        while(true)\\n        {\\n            if(curr -> val < val)\\n            {\\n                if(curr -> right != NULL)\\n                {\\n                    curr = curr->right;\\n                }\\n                else\\n                {\\n                    curr -> right = new TreeNode(val);\\n                    return root;\\n                }\\n            }\\n            else\\n            {\\n                if(curr -> left != NULL)\\n                {\\n                    curr = curr -> left;\\n                }\\n                else\\n                {\\n                    curr -> left = new TreeNode(val);\\n                    return root;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == NULL)\\n        {\\n            return new TreeNode(val);\\n        }\\n        TreeNode* curr = root;\\n        while(true)\\n        {\\n            if(curr -> val < val)\\n            {\\n                if(curr -> right != NULL)\\n                {\\n                    curr = curr->right;\\n                }\\n                else\\n                {\\n                    curr -> right = new TreeNode(val);\\n                    return root;\\n                }\\n            }\\n            else\\n            {\\n                if(curr -> left != NULL)\\n                {\\n                    curr = curr -> left;\\n                }\\n                else\\n                {\\n                    curr -> left = new TreeNode(val);\\n                    return root;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684284,
                "title": "c-4-lines-code",
                "content": "class Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL)\\n            return new TreeNode(val);\\n        root->val>val?root->left=insertIntoBST(root->left,val):root->right=insertIntoBST(root->right,val);\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL)\\n            return new TreeNode(val);\\n        root->val>val?root->left=insertIntoBST(root->left,val):root->right=insertIntoBST(root->right,val);\\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1684254,
                "title": "iterative-c",
                "content": "Find the value in the BST that have to be inserted until you encounter a **NULL** Node and add the new Node in the NULL place. Hence it will be a BST.\\nDry run the test cases for more clear understanding.\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root)\\n            return new TreeNode(val);\\n        TreeNode* head = root; \\n        while(root!=NULL){\\n            if(root->val>val){\\n                if(root->left)\\n                    root = root->left;\\n                else{\\n                    root->left = new TreeNode(val);\\n                    break;\\n                }\\n                \\n            }\\n            else if(root->val<val)\\n            {\\n                if(root->right)\\n                    root = root->right;\\n                else{\\n                     root->right = new TreeNode(val);\\n                     break;\\n                }\\n            }\\n        \\n        }\\n        return head;\\n    }\\n};\\n```\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(!root)\\n            return new TreeNode(val);\\n        TreeNode* head = root; \\n        while(root!=NULL){\\n            if(root->val>val){\\n                if(root->left)\\n                    root = root->left;\\n                else{\\n                    root->left = new TreeNode(val);\\n                    break;\\n                }\\n                \\n            }\\n            else if(root->val<val)\\n            {\\n                if(root->right)\\n                    root = root->right;\\n                else{\\n                     root->right = new TreeNode(val);\\n                     break;\\n                }\\n            }\\n        \\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684235,
                "title": "java-fully-explained-with-picture-recursive-solution",
                "content": "### What is Binary Search Tree(BST)?\\n\\t\\n- The left subtree of a node contains only nodes with keys lesser than the node\\u2019s key.\\n- The right subtree of a node contains only nodes with keys greater than the node\\u2019s key.\\n- The left and right subtree each must also be a binary search tree.\\n\\n### Insert into BST :\\n\\t\\n-  We are going to iterative through the tree.\\n-  If the current value is greater then the inserted value, then we move to the left sub tree(2).\\n-  If the current value is lesser then the inserted value, then we move to the right sub tree(3).\\n-  If the current node is null , we are going to insert the value in that place.(1)\\n\\n![BST](https://assets.leetcode.com/users/images/ff146ae6-3313-4731-b52d-dc1786fd7aaa_1641962899.3465295.png)\\n\\n\\n```java\\nclass Solution {\\n    TreeNode dfs(TreeNode r,int val){\\n        if(r == null)return new TreeNode(val); // --> (1)\\n        if(r.val > val) // --> (2)\\n            r.left = dfs(r.left,val);\\n        else // -->(3)\\n            r.right = dfs(r.right,val);\\n        return r;\\n    }\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        return dfs(root,val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    TreeNode dfs(TreeNode r,int val){\\n        if(r == null)return new TreeNode(val); // --> (1)\\n        if(r.val > val) // --> (2)\\n            r.left = dfs(r.left,val);\\n        else // -->(3)\\n            r.right = dfs(r.right,val);\\n        return r;\\n    }\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        return dfs(root,val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683859,
                "title": "701-insert-into-a-binary-search-tree-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL) return new TreeNode(val); //if empty return the value to be inserted as it is the only esisting node \\n        else if(root->val>val){ //check if root value is greater than value to be inserted \\n            root->left=insertIntoBST(root->left, val); //call the function insertIntoBST with root->left as root\\n        }else {\\n            root->right=insertIntoBST(root->right, val);//call the function insertIntoBST with root->right as root\\n        }  //when it reaches leaf it appends the value to either left or right \\n        return root; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL) return new TreeNode(val); //if empty return the value to be inserted as it is the only esisting node \\n        else if(root->val>val){ //check if root value is greater than value to be inserted \\n            root->left=insertIntoBST(root->left, val); //call the function insertIntoBST with root->left as root\\n        }else {\\n            root->right=insertIntoBST(root->right, val);//call the function insertIntoBST with root->right as root\\n        }  //when it reaches leaf it appends the value to either left or right \\n        return root; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640133,
                "title": "c-very-easy-bst",
                "content": "* **_`Upvote if you found solution helpful`_**\\n* **_`Happy Coding`_** \\n\\n```C++\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL){\\n            return (new TreeNode(val));\\n        }\\n        if(root->val > val){\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        else{\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root==NULL){\\n            return (new TreeNode(val));\\n        }\\n        if(root->val > val){\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        else{\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603089,
                "title": "c-easy-solution-90-faster-o-logn",
                "content": "\\t//In this solution duplicacy is not taken under consideration for BST\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* insertIntoBST(TreeNode* root, int val) {\\n\\t\\t //if root is null make a new root and return (Simple)\\n\\t\\t\\tif(root==nullptr){\\n\\t\\t\\t\\tTreeNode *t=new TreeNode(val);\\n\\t\\t\\t\\treturn t;\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode *head=root;\\n\\t\\t\\t\\n\\t\\t\\t//iterate if we have some nodes in BST\\n\\t\\t\\twhile(head){\\n\\t\\t\\t  //if value to be inserted is greater than current node value then go right\\n\\t\\t\\t\\t if(val>head->val){\\n\\t\\t\\t\\t\\t if(head->right==nullptr){\\n\\t\\t\\t\\t\\t\\t  head->right=new TreeNode(val);\\n\\t\\t\\t\\t\\t\\t return root;\\n\\t\\t\\t\\t\\t }\\n\\t\\t\\t\\t\\t else\\n\\t\\t\\t\\t\\t\\t head=head->right;\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t //if value to be inserted is lesser than current node value then go left\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t   if(head->left==nullptr){\\n\\t\\t\\t\\t\\t\\t  head->left=new TreeNode(val);\\n\\t\\t\\t\\t\\t\\t return root;\\n\\t\\t\\t\\t\\t }\\n\\t\\t\\t\\t\\t else\\n\\t\\t\\t\\t\\t\\t head=head->left; \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t//  do upvote ? if you like it : give suggestion in comment section !",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* insertIntoBST(TreeNode* root, int val) {\\n\\t\\t //if root is null make a new root and return (Simple)\\n\\t\\t\\tif(root==nullptr){\\n\\t\\t\\t\\tTreeNode *t=new TreeNode(val);\\n\\t\\t\\t\\treturn t;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1518665,
                "title": "both-java-recursive-iterative-solutions",
                "content": "# 1. ***Iterative*** solution\\n# \\n\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        TreeNode temp = root;\\n        while(true){\\n            if(temp.val > val){\\n                if(temp.left != null) temp = temp.left;\\n                else {temp.left = new TreeNode(val); break;}\\n            }\\n            else{\\n                if(temp.right != null) temp = temp.right;\\n                else {temp.right = new TreeNode(val); break;}\\n            }\\n        }      \\n        return root; \\n    }\\n}\\n```\\n\\n# 2. ***Recursive*** solution\\n# \\n\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if(val < root.val) root.left = insertIntoBST(root.left, val);\\n        else root.right = insertIntoBST(root.right, val);\\n        return root; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        TreeNode temp = root;\\n        while(true){\\n            if(temp.val > val){\\n                if(temp.left != null) temp = temp.left;\\n                else {temp.left = new TreeNode(val); break;}\\n            }\\n            else{\\n                if(temp.right != null) temp = temp.right;\\n                else {temp.right = new TreeNode(val); break;}\\n            }\\n        }      \\n        return root; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        if(val < root.val) root.left = insertIntoBST(root.left, val);\\n        else root.right = insertIntoBST(root.right, val);\\n        return root; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515550,
                "title": "super-short-and-intuitive-recursive-0ms-solution",
                "content": "Super short and intuitive recursive solution.\\n```\\npublic TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) {\\n            return new TreeNode(val);\\n        }\\n        if (root.val > val) {\\n            root.left = insertIntoBST(root.left, val);\\n        }\\n        else {\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n        return root;\\n    }",
                "solutionTags": [],
                "code": "Super short and intuitive recursive solution.\\n```\\npublic TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null) {\\n            return new TreeNode(val);\\n        }\\n        if (root.val > val) {\\n            root.left = insertIntoBST(root.left, val);\\n        }\\n        else {\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1467261,
                "title": "simple-recursive-python-solution",
                "content": "```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root:\\n            return TreeNode(val)\\n        if root.val < val:\\n            root.right = self.insertIntoBST(root.right, val)\\n\\n        if root.val > val:\\n            root.left = self.insertIntoBST(root.left, val)\\n            \\n        return root",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\\n        if not root:\\n            return TreeNode(val)\\n        if root.val < val:\\n            root.right = self.insertIntoBST(root.right, val)\\n\\n        if root.val > val:\\n            root.left = self.insertIntoBST(root.left, val)\\n            \\n        return root",
                "codeTag": "Java"
            },
            {
                "id": 1459460,
                "title": "c-recursive-and-iterative-solution",
                "content": "#### Recursive Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* insertIntoBST(TreeNode* root, int val) {\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\tTreeNode* newNode = new TreeNode(val);\\n\\t\\t\\t\\treturn newNode;            \\n\\t\\t\\t}\\n\\t\\t\\tif(root -> val < val){\\n\\t\\t\\t\\troot -> right = insertIntoBST(root -> right, val);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot -> left = insertIntoBST(root -> left, val);\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};\\n\\t\\n#### Iterative Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* insertIntoBST(TreeNode* root, int val) {\\n\\t\\t\\tTreeNode* prev = NULL;\\n\\t\\t\\tTreeNode* curr = root;\\n\\t\\t\\tTreeNode* newNode = new TreeNode(val);\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn newNode;\\n\\t\\t\\t}\\n\\t\\t\\twhile(curr != NULL){\\n\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t\\tif(curr -> val < val){\\n\\t\\t\\t\\t\\tcurr = curr -> right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tcurr = curr -> left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(prev -> val < val){\\n\\t\\t\\t\\tprev -> right = newNode;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tprev -> left = newNode;\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* insertIntoBST(TreeNode* root, int val) {\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\tTreeNode* newNode = new TreeNode(val);\\n\\t\\t\\t\\treturn newNode;            \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1312163,
                "title": "c-simple-solution-self-explained-100",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode *t=new TreeNode(val);\\n        TreeNode *p=root;\\n        if(p==NULL)\\n        {\\n            return t;\\n        }\\n        while(p){\\n            if(p->val>val)\\n            {\\n                if(p->left)\\n                   p=p->left;\\n                else\\n                {    \\n                    p->left=t;\\n                    break;\\n                }  \\n            }\\n            else{\\n                if(p->right)\\n                    p=p->right;\\n                else{\\n                    p->right=t;\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode *t=new TreeNode(val);\\n        TreeNode *p=root;\\n        if(p==NULL)\\n        {\\n            return t;\\n        }\\n        while(p){\\n            if(p->val>val)\\n            {\\n                if(p->left)\\n                   p=p->left;\\n                else\\n                {    \\n                    p->left=t;\\n                    break;\\n                }  \\n            }\\n            else{\\n                if(p->right)\\n                    p=p->right;\\n                else{\\n                    p->right=t;\\n                    break;\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232224,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)\\n        {\\n            root=new TreeNode(val);\\n            return root;\\n        }\\n        //if value is lesser than root val,then it occupies left side of the tree else right side of the tree\\n        if(val<root.val)\\n        {\\n            root.left=insertIntoBST(root.left,val);\\n        }\\n        else\\n        {\\n            root.right=insertIntoBST(root.right,val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)\\n        {\\n            root=new TreeNode(val);\\n            return root;\\n        }\\n        //if value is lesser than root val,then it occupies left side of the tree else right side of the tree\\n        if(val<root.val)\\n        {\\n            root.left=insertIntoBST(root.left,val);\\n        }\\n        else\\n        {\\n            root.right=insertIntoBST(root.right,val);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091367,
                "title": "c-iterative-sol-using-queue",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) \\n    {\\n        TreeNode* node= new TreeNode(val);\\n        if(root==nullptr)\\n        {\\n            return node;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode* res=q.front();\\n            q.pop();\\n            \\n            if(val>=res->val)\\n            {\\n                if(res->right)\\n                {\\n                    q.push(res->right);\\n                }\\n                else\\n                {\\n                    res->right=node;\\n                    return root;\\n                }\\n            }\\n            else if(val<=res->val)\\n            {\\n                if(res->left)\\n                {\\n                    q.push(res->left);\\n                }\\n                else\\n                {\\n                    res->left=node;\\n                    return root;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n};\\n\\'\\'\\'\\n\\nDo upvote, if it helps you :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) \\n    {\\n        TreeNode* node= new TreeNode(val);\\n        if(root==nullptr)\\n        {\\n            return node;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1086668,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public TreeNode InsertIntoBST(TreeNode root, int val) {\\n        if (root == null)\\n            return new TreeNode(val);\\n        \\n        DFS(root, val);\\n        \\n        return root;\\n    }\\n    \\n    private void DFS(TreeNode node, int val)\\n    {\\n        if (node.val > val)\\n        {\\n            if (node.left == null)\\n                node.left = new TreeNode(val);\\n            else\\n                DFS(node.left, val);\\n        }\\n        else\\n        {\\n            if (node.right == null)\\n                node.right = new TreeNode(val);\\n            else\\n                DFS(node.right, val);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode InsertIntoBST(TreeNode root, int val) {\\n        if (root == null)\\n            return new TreeNode(val);\\n        \\n        DFS(root, val);\\n        \\n        return root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1049436,
                "title": "c-resursive",
                "content": "```\\nTreeNode* insertIntoBST(TreeNode* root, int val) {\\n\\tif (!root)\\n\\t\\troot = new TreeNode(val);\\n\\telse if (root->val < val) {\\n\\t\\tif (root->right)\\n\\t\\t\\troot->right = insertIntoBST(root->right, val);\\n\\t\\telse\\n\\t\\t\\troot->right = new TreeNode(val);\\n\\t}\\n\\telse if (root->val > val) {\\n\\t\\tif (root->left)\\n\\t\\t\\troot->left = insertIntoBST(root->left, val);\\n\\t\\telse\\n\\t\\t\\troot->left = new TreeNode(val);\\n\\t}\\n\\treturn root;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nTreeNode* insertIntoBST(TreeNode* root, int val) {\\n\\tif (!root)\\n\\t\\troot = new TreeNode(val);\\n\\telse if (root->val < val) {\\n\\t\\tif (root->right)\\n\\t\\t\\troot->right = insertIntoBST(root->right, val);\\n\\t\\telse\\n\\t\\t\\troot->right = new TreeNode(val);\\n\\t}\\n\\telse if (root->val > val) {\\n\\t\\tif (root->left)\\n\\t\\t\\troot->left = insertIntoBST(root->left, val);\\n\\t\\telse\\n\\t\\t\\troot->left = new TreeNode(val);\\n\\t}\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1045190,
                "title": "golang-stack-solution-with-explanation",
                "content": "The main idea of this solution is that we are inserting into a **binary search tree**. \\n\\n*Note: A binary search tree is a tree that has a left value smaller than the root and a right value greater than the root, while a Binary Tree has no such order.*\\n\\nThis solution is simple because the description says that the value which they give, `val`, is unique and is not in the BST so we can just traverse the tree and put the value at the bottom of the tree as a leaf.\\n\\nAnother way of saying this is if `val` is smaller than the root then go left, and if it is greater go right. But if there is no left value when we want to go left we insert the value into that position, the same go for the right side if we want to go right.\\n\\n```\\nfunc insertIntoBST(root *TreeNode, val int) *TreeNode {\\n\\th := []*TreeNode{}\\n\\tif root == nil {\\n\\t\\troot = &TreeNode{\\n\\t\\t\\tVal:   val,\\n\\t\\t}\\n\\t\\treturn root\\n\\t}\\n\\th = append(h, root)\\n\\n\\tfor len(h) != 0 {\\n\\t\\tpop := &TreeNode{}\\n\\t\\tpop, h = h[len(h)-1], h[:len(h)-1]\\n\\n\\t\\tif pop != nil {\\n\\t\\t\\tif val < pop.Val {\\n\\t\\t\\t\\tif pop.Left == nil {\\n\\t\\t\\t\\t\\tpop.Left = &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: val,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn root\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\th = append(h, pop.Left)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif pop.Right == nil {\\n\\t\\t\\t\\t\\tpop.Right = &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: val,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn root\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\th = append(h, pop.Right)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc insertIntoBST(root *TreeNode, val int) *TreeNode {\\n\\th := []*TreeNode{}\\n\\tif root == nil {\\n\\t\\troot = &TreeNode{\\n\\t\\t\\tVal:   val,\\n\\t\\t}\\n\\t\\treturn root\\n\\t}\\n\\th = append(h, root)\\n\\n\\tfor len(h) != 0 {\\n\\t\\tpop := &TreeNode{}\\n\\t\\tpop, h = h[len(h)-1], h[:len(h)-1]\\n\\n\\t\\tif pop != nil {\\n\\t\\t\\tif val < pop.Val {\\n\\t\\t\\t\\tif pop.Left == nil {\\n\\t\\t\\t\\t\\tpop.Left = &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: val,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn root\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\th = append(h, pop.Left)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif pop.Right == nil {\\n\\t\\t\\t\\t\\tpop.Right = &TreeNode{\\n\\t\\t\\t\\t\\t\\tVal: val,\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn root\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\th = append(h, pop.Right)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 951751,
                "title": "easy-solution-recommendation-welcome",
                "content": "```\\n  TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root==NULL) return new TreeNode (val);\\n        \\n        \\n        else if(val<=root->val)\\n        {\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        else\\n        {\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root==NULL) return new TreeNode (val);\\n        \\n        \\n        else if(val<=root->val)\\n        {\\n            root->left=insertIntoBST(root->left,val);\\n        }\\n        else\\n        {\\n            root->right=insertIntoBST(root->right,val);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950301,
                "title": "python-o-log-n-recursive-and-o-1-iterative",
                "content": "```\\n\\n# v1 - recursive\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return TreeNode(val)\\n            \\n        if val < root.val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        elif val > root.val:\\n            root.right = self.insertIntoBST(root.right, val)\\n            \\n        return root\\n\\n# v2 - iterative\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return TreeNode(val)\\n        \\n        head = root\\n        \\n        while True:\\n            if val == head.val:\\n                break\\n                \\n            if val < head.val:\\n                if head.left:\\n                    head = head.left\\n                else:\\n                    head.left = TreeNode(val)\\n                    break\\n            elif val > head.val:\\n                if head.right:\\n                    head = head.right\\n                else:\\n                    head.right = TreeNode(val)\\n                    break\\n            \\n        return root \\n```",
                "solutionTags": [],
                "code": "```\\n\\n# v1 - recursive\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return TreeNode(val)\\n            \\n        if val < root.val:\\n            root.left = self.insertIntoBST(root.left, val)\\n        elif val > root.val:\\n            root.right = self.insertIntoBST(root.right, val)\\n            \\n        return root\\n\\n# v2 - iterative\\nclass Solution:\\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\\n        if not root:\\n            return TreeNode(val)\\n        \\n        head = root\\n        \\n        while True:\\n            if val == head.val:\\n                break\\n                \\n            if val < head.val:\\n                if head.left:\\n                    head = head.left\\n                else:\\n                    head.left = TreeNode(val)\\n                    break\\n            elif val > head.val:\\n                if head.right:\\n                    head = head.right\\n                else:\\n                    head.right = TreeNode(val)\\n                    break\\n            \\n        return root \\n```",
                "codeTag": "Java"
            },
            {
                "id": 881991,
                "title": "java-o-logn-solution-eazy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        return insert(root,val);\\n    \\n        \\n    }\\n     public TreeNode insert(TreeNode root,int value){\\n\\n        if(root == null){\\n            return new TreeNode(value);\\n\\n        }\\n        else if(root.val>value){\\n           root.left=insert(root.left,value);\\n\\n        }\\n        else{\\n           root.right=insert(root.right,value);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        return insert(root,val);\\n    \\n        \\n    }\\n     public TreeNode insert(TreeNode root,int value){\\n\\n        if(root == null){\\n            return new TreeNode(value);\\n\\n        }\\n        else if(root.val>value){\\n           root.left=insert(root.left,value);\\n\\n        }\\n        else{\\n           root.right=insert(root.right,value);\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881830,
                "title": "insert-into-a-binary-search-tree-simple-recursive-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == nullptr)\\n            return new TreeNode(val);\\n        \\n        if(root->val < val) \\n            root->right = insertIntoBST(root->right, val);\\n        else\\n            root->left = insertIntoBST(root->left, val);\\n        return root;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if(root == nullptr)\\n            return new TreeNode(val);\\n        \\n        if(root->val < val) \\n            root->right = insertIntoBST(root->right, val);\\n        else\\n            root->left = insertIntoBST(root->left, val);\\n        return root;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881703,
                "title": "insert-into-a-binary-search-tree-swift",
                "content": "Swift solution:\\n\\n    func insertIntoBST(_ root: TreeNode?, _ val: Int) -> TreeNode? {\\n        guard let newRoot = root else { return TreeNode(val) }\\n        if val < newRoot.val {\\n            newRoot.left = insertIntoBST(root?.left, val)\\n        } else {\\n            newRoot.right = insertIntoBST(root?.right, val)\\n        }\\n        return newRoot\\n    }",
                "solutionTags": [
                    "Swift"
                ],
                "code": "Swift solution:\\n\\n    func insertIntoBST(_ root: TreeNode?, _ val: Int) -> TreeNode? {\\n        guard let newRoot = root else { return TreeNode(val) }\\n        if val < newRoot.val {\\n            newRoot.left = insertIntoBST(root?.left, val)\\n        } else {\\n            newRoot.right = insertIntoBST(root?.right, val)\\n        }\\n        return newRoot\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 881601,
                "title": "insert-into-a-binary-search-tree-java-c-recursive-iterative",
                "content": "Recursive method.  Time O(h), Space O(h)\\n\\nJava\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null)\\n        {\\n            return new TreeNode(val);\\n        }\\n        if (val < root.val)\\n        {\\n            root.left = insertIntoBST(root.left, val);\\n        }\\n        else\\n        {\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root == nullptr)\\n        {\\n            return new TreeNode(val);\\n        }\\n        if (root->val < val)\\n        {\\n            root->right = insertIntoBST(root->right, val);\\n        }\\n        else\\n        {\\n            root->left = insertIntoBST(root->left, val);\\n        }\\n        return root;\\n    }\\n    \\n};\\n```\\nIterative method:\\n\\nTime: O(h), Space O(1)\\n\\nJava\\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        TreeNode newNode = new TreeNode(val);\\n        if (root == null)\\n        {\\n            return newNode;\\n        }\\n        TreeNode cur = root;\\n        while (true)\\n        {\\n            if (cur.val < val)\\n            {\\n                if (cur.right == null)\\n                {\\n                    cur.right = newNode;\\n                    break;\\n                }\\n                cur = cur.right;\\n            }\\n            else\\n            {\\n                if (cur.left == null)\\n                {\\n                    cur.left = newNode;\\n                    break;\\n                }\\n                cur = cur.left;\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode* newNode = new TreeNode(val);\\n        if (root == nullptr)\\n        {\\n            return newNode;\\n        }\\n        TreeNode* cur = root;\\n        while (true)\\n        {\\n            if (cur->val < val)\\n            {\\n                if (cur->right == nullptr)\\n                {\\n                    cur->right = newNode;\\n                    break;\\n                }\\n                cur = cur->right;\\n            }\\n            else\\n            {\\n                if (cur->left == nullptr)\\n                {\\n                    cur->left = newNode;\\n                    break;\\n                }\\n                cur = cur->left;\\n            }\\n        }        return root;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if (root == null)\\n        {\\n            return new TreeNode(val);\\n        }\\n        if (val < root.val)\\n        {\\n            root.left = insertIntoBST(root.left, val);\\n        }\\n        else\\n        {\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        if (root == nullptr)\\n        {\\n            return new TreeNode(val);\\n        }\\n        if (root->val < val)\\n        {\\n            root->right = insertIntoBST(root->right, val);\\n        }\\n        else\\n        {\\n            root->left = insertIntoBST(root->left, val);\\n        }\\n        return root;\\n    }\\n    \\n};\\n```\n```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        TreeNode newNode = new TreeNode(val);\\n        if (root == null)\\n        {\\n            return newNode;\\n        }\\n        TreeNode cur = root;\\n        while (true)\\n        {\\n            if (cur.val < val)\\n            {\\n                if (cur.right == null)\\n                {\\n                    cur.right = newNode;\\n                    break;\\n                }\\n                cur = cur.right;\\n            }\\n            else\\n            {\\n                if (cur.left == null)\\n                {\\n                    cur.left = newNode;\\n                    break;\\n                }\\n                cur = cur.left;\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        TreeNode* newNode = new TreeNode(val);\\n        if (root == nullptr)\\n        {\\n            return newNode;\\n        }\\n        TreeNode* cur = root;\\n        while (true)\\n        {\\n            if (cur->val < val)\\n            {\\n                if (cur->right == nullptr)\\n                {\\n                    cur->right = newNode;\\n                    break;\\n                }\\n                cur = cur->right;\\n            }\\n            else\\n            {\\n                if (cur->left == nullptr)\\n                {\\n                    cur->left = newNode;\\n                    break;\\n                }\\n                cur = cur->left;\\n            }\\n        }        return root;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741013,
                "title": "javascript-o-1-memory-and-iterative-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} val\\n * @return {TreeNode}\\n */\\nvar insertIntoBST = function(root, val) {\\n    if(!root) {\\n        root = new TreeNode(val)\\n        return root\\n    }\\n    let top = root\\n    while(top) {\\n        if(top.val >= val && top.left != null) top = top.left\\n        else if(top.val >= val && top.left == null) {\\n            top.left = new TreeNode(val)\\n            break\\n        }\\n        else if(top.val < val && top.right != null) top = top.right\\n        else {\\n            top.right = new TreeNode(val)\\n            break;\\n        }\\n    }\\n    return root\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} val\\n * @return {TreeNode}\\n */\\nvar insertIntoBST = function(root, val) {\\n    if(!root) {\\n        root = new TreeNode(val)\\n        return root\\n    }\\n    let top = root\\n    while(top) {\\n        if(top.val >= val && top.left != null) top = top.left\\n        else if(top.val >= val && top.left == null) {\\n            top.left = new TreeNode(val)\\n            break\\n        }\\n        else if(top.val < val && top.right != null) top = top.right\\n        else {\\n            top.right = new TreeNode(val)\\n            break;\\n        }\\n    }\\n    return root\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 670847,
                "title": "java-iterative-dfs-using-stack",
                "content": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode current = stack.pop();\\n            if(current.val > val){\\n                if(current.left == null){\\n                    current.left = new TreeNode(val);\\n                    return root;\\n                }\\n                stack.push(current.left);\\n            }else{\\n                if(current.right==null){\\n                    current.right = new TreeNode(val);\\n                    return root;\\n                }\\n                stack.push(current.right);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root == null) return new TreeNode(val);\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode current = stack.pop();\\n            if(current.val > val){\\n                if(current.left == null){\\n                    current.left = new TreeNode(val);\\n                    return root;\\n                }\\n                stack.push(current.left);\\n            }else{\\n                if(current.right==null){\\n                    current.right = new TreeNode(val);\\n                    return root;\\n                }\\n                stack.push(current.right);\\n            }\\n        }\\n        return root;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 496353,
                "title": "simple-java-recursive-solution",
                "content": "```\\npublic TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(null == root) return new TreeNode(val);\\n        if(val < root.val){\\n            root.left = insertIntoBST(root.left, val);\\n        }else{\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(null == root) return new TreeNode(val);\\n        if(val < root.val){\\n            root.left = insertIntoBST(root.left, val);\\n        }else{\\n            root.right = insertIntoBST(root.right, val);\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 475611,
                "title": "non-recursive-javascript-solution-faster-than-97",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} val\\n * @return {TreeNode}\\n */\\nvar insertIntoBST = function(root, val) {\\n    if (root === null) {\\n        return new TreeNode(val);\\n    }\\n    \\n    let current = root;\\n    let parent = null;\\n    while (current !== null) {\\n        parent = current;\\n        if (val > current.val) {\\n            current = current.right;\\n        } else {\\n            current = current.left;\\n        }\\n    }\\n    \\n    if (val > parent.val) {\\n        parent.right = new TreeNode(val);\\n    } else {\\n        parent.left = new TreeNode(val);\\n    }\\n\\n    return root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} val\\n * @return {TreeNode}\\n */\\nvar insertIntoBST = function(root, val) {\\n    if (root === null) {\\n        return new TreeNode(val);\\n    }\\n    \\n    let current = root;\\n    let parent = null;\\n    while (current !== null) {\\n        parent = current;\\n        if (val > current.val) {\\n            current = current.right;\\n        } else {\\n            current = current.left;\\n        }\\n    }\\n    \\n    if (val > parent.val) {\\n        parent.right = new TreeNode(val);\\n    } else {\\n        parent.left = new TreeNode(val);\\n    }\\n\\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 473399,
                "title": "c-recursive-easy-to-understand",
                "content": "```\\nRuntime: 88 ms, faster than 69.67% of C++ online submissions for Insert into a Binary Search Tree.\\nMemory Usage: 32.9 MB, less than 75.00% of C++ online submissions for Insert into a Binary Search Tree.\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        \\n        if(!root){\\n            return new TreeNode(val);\\n        }\\n        \\n        if(val < root->val){\\n            root->left = insertIntoBST(root->left, val);\\n        }\\n        \\n        if(val > root->val){\\n            root->right = insertIntoBST(root->right, val);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nRuntime: 88 ms, faster than 69.67% of C++ online submissions for Insert into a Binary Search Tree.\\nMemory Usage: 32.9 MB, less than 75.00% of C++ online submissions for Insert into a Binary Search Tree.\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\\n        \\n        if(!root){\\n            return new TreeNode(val);\\n        }\\n        \\n        if(val < root->val){\\n            root->left = insertIntoBST(root->left, val);\\n        }\\n        \\n        if(val > root->val){\\n            root->right = insertIntoBST(root->right, val);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376779,
                "title": "solution-java-0-ms-100-38-5-mb-100",
                "content": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)\\n            return new TreeNode(val);\\n        if(root.val<val)\\n            root.right = insertIntoBST(root.right, val);\\n        else\\n            root.left = insertIntoBST(root.left, val);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public TreeNode insertIntoBST(TreeNode root, int val) {\\n        if(root==null)\\n            return new TreeNode(val);\\n        if(root.val<val)\\n            root.right = insertIntoBST(root.right, val);\\n        else\\n            root.left = insertIntoBST(root.left, val);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569868,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1572488,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1565723,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1568134,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1573019,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1569425,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1844199,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1576213,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1573571,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1574449,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1569868,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1572488,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1565723,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1568134,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1573019,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1569425,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1844199,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1576213,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1573571,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 1574449,
                "content": [
                    {
                        "username": "nutigattu",
                        "content": "Given the simple requirement. I guess it should be Easy not Medium."
                    },
                    {
                        "username": "cfauchere",
                        "content": "I am disapointed with this question. I do not think in an interview it would be ok to just insert the node and leave the tree unbalanced."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/insert-into-a-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iteration\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "thevirtuoso1973",
                        "content": "This should really be an easy considering it\\'s basically a search algo for BST with like an extra 2 or 3 lines."
                    },
                    {
                        "username": "sharmaillusion",
                        "content": "I feel that this should be an easy question.\\nConsidering that the element does not exist in the tree, all we need to do is traverse down the tree such that the value satisfy BST criteria, until we hit reach the end, and append the new node over there. Does not even require recursion, can be done using simple while loop."
                    },
                    {
                        "username": "MahsaAbadian",
                        "content": "In a real interview question like this, isn\\'t it important to come up with a solution that keeps the tree almost balanced? (Something like Red Black Tree Rotations :D)"
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Love BST problems"
                    },
                    {
                        "username": "letyrodri",
                        "content": "It\\'s not log(n) besides doing recursion and going to left or right.\\nThe thing is that the tree could be arranged all nodes over the left or right and could be a valid tree. In example, 1->2->3->4->5 all over the right.\\n\\n![image](https://assets.leetcode.com/users/images/3a72bce0-f906-485b-91e1-8687b409a83d_1641956612.3812113.jpeg)\\n\\nSo the time complexity is O(n) in the worst case for most of the recursive algorithm that are around this discussion.\\nbest!"
                    },
                    {
                        "username": "DeadlyTRex",
                        "content": "That\\'s actually applicable to all the tree problems. The thing is we calculate worst case complexity only to arrive at average case complexity in general (based on the probability of the occurrence of different cases). "
                    },
                    {
                        "username": "piyushshah12327",
                        "content": "The title says it all."
                    },
                    {
                        "username": "saketthavanani",
                        "content": "![image](https://assets.leetcode.com/users/images/e07d214d-defe-48a1-a4d6-7da42b7193b1_1601986602.29456.png)\\n"
                    }
                ]
            },
            {
                "id": 2070216,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "- It\\'s *guaranteed* that `val` does not exist in the original BST.\\n##### This constraint should be removed to add some fun."
                    },
                    {
                        "username": "user1748GJ",
                        "content": "This question should have a follow up section where it asks you to rebalance the tree. I think it would be more interesting that way"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Is it fine to return an unbalanced tree?"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "As you can see in the example 2 it is accepted.\\nYou can give yourself a follow-up challenge to try rebalance the tree yourself"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "The code for inserting the element as leaf node in the tree is easy. But what about inserting the element at the root of the tree like given in the 2nd possible answer for 1st example?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\nC++ iterative approach. Easy T.C=O(h) in worst case height(h) can be n for skewed tree. S.C=O(1) \n\n# Approach\n\n1. Create a new TreeNode with the given value and assign it to the variable newNode.\n2. Check if the root is null. If it is, then the new node becomes the root, so return newNode.\n3. Assign the root node to the variable temp.\n4. Enter a loop that continues until temp becomes null.\n5. Inside the loop, compare the value of temp with the given value.\n   - If the value of temp is less than or equal to the given value, move to the right subtree.\n     - If the right child of temp is null, assign newNode to the right child of temp and break the loop.\n     - Otherwise, update temp to be its right child and continue the loop.\n   - If the value of temp is greater than the given value, move to the left subtree.\n     - If the left child of temp is null, assign newNode to the left child of temp and break the loop.\n     - Otherwise, update temp to be its left child and continue the loop.\n6. Return the root node.\n\n--------------------------------------------------\n# Complexity\n- Time complexity:\nT.C=O(h) in worst case height(h) can be n for skewed tree.\n\n- Space complexity:\nS.C=O(1) no extra space.\n--------------------------------------------------\nPlease Upvote. If understand the concept.\nSolution link:\nhttps://leetcode.com/problems/insert-into-a-binary-search-tree/solutions/3714129/c-iterative-approach-easy-t-c-o-h-in-worst-case-height-h-can-be-n-for-skewed-tree-s-c-o-1/\n"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Why do we even have to return root node which is already known to outside code?"
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get weird error like this \\n[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "ks20soni",
                        "content": "Trying to insert the new node to the right of its floor value but not working. Any idea why?"
                    },
                    {
                        "username": "devesht709",
                        "content": "cur, next = None, root\\n        while next:\\n            cur = next\\n            next = cur.left if val < cur.val else cur.right\\n         if the value gone upto exert it must follow the upper casees ...\\n"
                    },
                    {
                        "username": "kirsty",
                        "content": "The constraints say `-10^8 <= Node.val <= 10^8`, but there is an invalid test case error if you include negative values."
                    }
                ]
            },
            {
                "id": 2069401,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "- It\\'s *guaranteed* that `val` does not exist in the original BST.\\n##### This constraint should be removed to add some fun."
                    },
                    {
                        "username": "user1748GJ",
                        "content": "This question should have a follow up section where it asks you to rebalance the tree. I think it would be more interesting that way"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Is it fine to return an unbalanced tree?"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "As you can see in the example 2 it is accepted.\\nYou can give yourself a follow-up challenge to try rebalance the tree yourself"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "The code for inserting the element as leaf node in the tree is easy. But what about inserting the element at the root of the tree like given in the 2nd possible answer for 1st example?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\nC++ iterative approach. Easy T.C=O(h) in worst case height(h) can be n for skewed tree. S.C=O(1) \n\n# Approach\n\n1. Create a new TreeNode with the given value and assign it to the variable newNode.\n2. Check if the root is null. If it is, then the new node becomes the root, so return newNode.\n3. Assign the root node to the variable temp.\n4. Enter a loop that continues until temp becomes null.\n5. Inside the loop, compare the value of temp with the given value.\n   - If the value of temp is less than or equal to the given value, move to the right subtree.\n     - If the right child of temp is null, assign newNode to the right child of temp and break the loop.\n     - Otherwise, update temp to be its right child and continue the loop.\n   - If the value of temp is greater than the given value, move to the left subtree.\n     - If the left child of temp is null, assign newNode to the left child of temp and break the loop.\n     - Otherwise, update temp to be its left child and continue the loop.\n6. Return the root node.\n\n--------------------------------------------------\n# Complexity\n- Time complexity:\nT.C=O(h) in worst case height(h) can be n for skewed tree.\n\n- Space complexity:\nS.C=O(1) no extra space.\n--------------------------------------------------\nPlease Upvote. If understand the concept.\nSolution link:\nhttps://leetcode.com/problems/insert-into-a-binary-search-tree/solutions/3714129/c-iterative-approach-easy-t-c-o-h-in-worst-case-height-h-can-be-n-for-skewed-tree-s-c-o-1/\n"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Why do we even have to return root node which is already known to outside code?"
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get weird error like this \\n[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "ks20soni",
                        "content": "Trying to insert the new node to the right of its floor value but not working. Any idea why?"
                    },
                    {
                        "username": "devesht709",
                        "content": "cur, next = None, root\\n        while next:\\n            cur = next\\n            next = cur.left if val < cur.val else cur.right\\n         if the value gone upto exert it must follow the upper casees ...\\n"
                    },
                    {
                        "username": "kirsty",
                        "content": "The constraints say `-10^8 <= Node.val <= 10^8`, but there is an invalid test case error if you include negative values."
                    }
                ]
            },
            {
                "id": 2027833,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "- It\\'s *guaranteed* that `val` does not exist in the original BST.\\n##### This constraint should be removed to add some fun."
                    },
                    {
                        "username": "user1748GJ",
                        "content": "This question should have a follow up section where it asks you to rebalance the tree. I think it would be more interesting that way"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Is it fine to return an unbalanced tree?"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "As you can see in the example 2 it is accepted.\\nYou can give yourself a follow-up challenge to try rebalance the tree yourself"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "The code for inserting the element as leaf node in the tree is easy. But what about inserting the element at the root of the tree like given in the 2nd possible answer for 1st example?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\nC++ iterative approach. Easy T.C=O(h) in worst case height(h) can be n for skewed tree. S.C=O(1) \n\n# Approach\n\n1. Create a new TreeNode with the given value and assign it to the variable newNode.\n2. Check if the root is null. If it is, then the new node becomes the root, so return newNode.\n3. Assign the root node to the variable temp.\n4. Enter a loop that continues until temp becomes null.\n5. Inside the loop, compare the value of temp with the given value.\n   - If the value of temp is less than or equal to the given value, move to the right subtree.\n     - If the right child of temp is null, assign newNode to the right child of temp and break the loop.\n     - Otherwise, update temp to be its right child and continue the loop.\n   - If the value of temp is greater than the given value, move to the left subtree.\n     - If the left child of temp is null, assign newNode to the left child of temp and break the loop.\n     - Otherwise, update temp to be its left child and continue the loop.\n6. Return the root node.\n\n--------------------------------------------------\n# Complexity\n- Time complexity:\nT.C=O(h) in worst case height(h) can be n for skewed tree.\n\n- Space complexity:\nS.C=O(1) no extra space.\n--------------------------------------------------\nPlease Upvote. If understand the concept.\nSolution link:\nhttps://leetcode.com/problems/insert-into-a-binary-search-tree/solutions/3714129/c-iterative-approach-easy-t-c-o-h-in-worst-case-height-h-can-be-n-for-skewed-tree-s-c-o-1/\n"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Why do we even have to return root node which is already known to outside code?"
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get weird error like this \\n[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "ks20soni",
                        "content": "Trying to insert the new node to the right of its floor value but not working. Any idea why?"
                    },
                    {
                        "username": "devesht709",
                        "content": "cur, next = None, root\\n        while next:\\n            cur = next\\n            next = cur.left if val < cur.val else cur.right\\n         if the value gone upto exert it must follow the upper casees ...\\n"
                    },
                    {
                        "username": "kirsty",
                        "content": "The constraints say `-10^8 <= Node.val <= 10^8`, but there is an invalid test case error if you include negative values."
                    }
                ]
            },
            {
                "id": 1989779,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "- It\\'s *guaranteed* that `val` does not exist in the original BST.\\n##### This constraint should be removed to add some fun."
                    },
                    {
                        "username": "user1748GJ",
                        "content": "This question should have a follow up section where it asks you to rebalance the tree. I think it would be more interesting that way"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Is it fine to return an unbalanced tree?"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "As you can see in the example 2 it is accepted.\\nYou can give yourself a follow-up challenge to try rebalance the tree yourself"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "The code for inserting the element as leaf node in the tree is easy. But what about inserting the element at the root of the tree like given in the 2nd possible answer for 1st example?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\nC++ iterative approach. Easy T.C=O(h) in worst case height(h) can be n for skewed tree. S.C=O(1) \n\n# Approach\n\n1. Create a new TreeNode with the given value and assign it to the variable newNode.\n2. Check if the root is null. If it is, then the new node becomes the root, so return newNode.\n3. Assign the root node to the variable temp.\n4. Enter a loop that continues until temp becomes null.\n5. Inside the loop, compare the value of temp with the given value.\n   - If the value of temp is less than or equal to the given value, move to the right subtree.\n     - If the right child of temp is null, assign newNode to the right child of temp and break the loop.\n     - Otherwise, update temp to be its right child and continue the loop.\n   - If the value of temp is greater than the given value, move to the left subtree.\n     - If the left child of temp is null, assign newNode to the left child of temp and break the loop.\n     - Otherwise, update temp to be its left child and continue the loop.\n6. Return the root node.\n\n--------------------------------------------------\n# Complexity\n- Time complexity:\nT.C=O(h) in worst case height(h) can be n for skewed tree.\n\n- Space complexity:\nS.C=O(1) no extra space.\n--------------------------------------------------\nPlease Upvote. If understand the concept.\nSolution link:\nhttps://leetcode.com/problems/insert-into-a-binary-search-tree/solutions/3714129/c-iterative-approach-easy-t-c-o-h-in-worst-case-height-h-can-be-n-for-skewed-tree-s-c-o-1/\n"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Why do we even have to return root node which is already known to outside code?"
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get weird error like this \\n[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "ks20soni",
                        "content": "Trying to insert the new node to the right of its floor value but not working. Any idea why?"
                    },
                    {
                        "username": "devesht709",
                        "content": "cur, next = None, root\\n        while next:\\n            cur = next\\n            next = cur.left if val < cur.val else cur.right\\n         if the value gone upto exert it must follow the upper casees ...\\n"
                    },
                    {
                        "username": "kirsty",
                        "content": "The constraints say `-10^8 <= Node.val <= 10^8`, but there is an invalid test case error if you include negative values."
                    }
                ]
            },
            {
                "id": 1955050,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "- It\\'s *guaranteed* that `val` does not exist in the original BST.\\n##### This constraint should be removed to add some fun."
                    },
                    {
                        "username": "user1748GJ",
                        "content": "This question should have a follow up section where it asks you to rebalance the tree. I think it would be more interesting that way"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Is it fine to return an unbalanced tree?"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "As you can see in the example 2 it is accepted.\\nYou can give yourself a follow-up challenge to try rebalance the tree yourself"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "The code for inserting the element as leaf node in the tree is easy. But what about inserting the element at the root of the tree like given in the 2nd possible answer for 1st example?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\nC++ iterative approach. Easy T.C=O(h) in worst case height(h) can be n for skewed tree. S.C=O(1) \n\n# Approach\n\n1. Create a new TreeNode with the given value and assign it to the variable newNode.\n2. Check if the root is null. If it is, then the new node becomes the root, so return newNode.\n3. Assign the root node to the variable temp.\n4. Enter a loop that continues until temp becomes null.\n5. Inside the loop, compare the value of temp with the given value.\n   - If the value of temp is less than or equal to the given value, move to the right subtree.\n     - If the right child of temp is null, assign newNode to the right child of temp and break the loop.\n     - Otherwise, update temp to be its right child and continue the loop.\n   - If the value of temp is greater than the given value, move to the left subtree.\n     - If the left child of temp is null, assign newNode to the left child of temp and break the loop.\n     - Otherwise, update temp to be its left child and continue the loop.\n6. Return the root node.\n\n--------------------------------------------------\n# Complexity\n- Time complexity:\nT.C=O(h) in worst case height(h) can be n for skewed tree.\n\n- Space complexity:\nS.C=O(1) no extra space.\n--------------------------------------------------\nPlease Upvote. If understand the concept.\nSolution link:\nhttps://leetcode.com/problems/insert-into-a-binary-search-tree/solutions/3714129/c-iterative-approach-easy-t-c-o-h-in-worst-case-height-h-can-be-n-for-skewed-tree-s-c-o-1/\n"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Why do we even have to return root node which is already known to outside code?"
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get weird error like this \\n[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "ks20soni",
                        "content": "Trying to insert the new node to the right of its floor value but not working. Any idea why?"
                    },
                    {
                        "username": "devesht709",
                        "content": "cur, next = None, root\\n        while next:\\n            cur = next\\n            next = cur.left if val < cur.val else cur.right\\n         if the value gone upto exert it must follow the upper casees ...\\n"
                    },
                    {
                        "username": "kirsty",
                        "content": "The constraints say `-10^8 <= Node.val <= 10^8`, but there is an invalid test case error if you include negative values."
                    }
                ]
            },
            {
                "id": 1936484,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "- It\\'s *guaranteed* that `val` does not exist in the original BST.\\n##### This constraint should be removed to add some fun."
                    },
                    {
                        "username": "user1748GJ",
                        "content": "This question should have a follow up section where it asks you to rebalance the tree. I think it would be more interesting that way"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Is it fine to return an unbalanced tree?"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "As you can see in the example 2 it is accepted.\\nYou can give yourself a follow-up challenge to try rebalance the tree yourself"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "The code for inserting the element as leaf node in the tree is easy. But what about inserting the element at the root of the tree like given in the 2nd possible answer for 1st example?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\nC++ iterative approach. Easy T.C=O(h) in worst case height(h) can be n for skewed tree. S.C=O(1) \n\n# Approach\n\n1. Create a new TreeNode with the given value and assign it to the variable newNode.\n2. Check if the root is null. If it is, then the new node becomes the root, so return newNode.\n3. Assign the root node to the variable temp.\n4. Enter a loop that continues until temp becomes null.\n5. Inside the loop, compare the value of temp with the given value.\n   - If the value of temp is less than or equal to the given value, move to the right subtree.\n     - If the right child of temp is null, assign newNode to the right child of temp and break the loop.\n     - Otherwise, update temp to be its right child and continue the loop.\n   - If the value of temp is greater than the given value, move to the left subtree.\n     - If the left child of temp is null, assign newNode to the left child of temp and break the loop.\n     - Otherwise, update temp to be its left child and continue the loop.\n6. Return the root node.\n\n--------------------------------------------------\n# Complexity\n- Time complexity:\nT.C=O(h) in worst case height(h) can be n for skewed tree.\n\n- Space complexity:\nS.C=O(1) no extra space.\n--------------------------------------------------\nPlease Upvote. If understand the concept.\nSolution link:\nhttps://leetcode.com/problems/insert-into-a-binary-search-tree/solutions/3714129/c-iterative-approach-easy-t-c-o-h-in-worst-case-height-h-can-be-n-for-skewed-tree-s-c-o-1/\n"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Why do we even have to return root node which is already known to outside code?"
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get weird error like this \\n[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "ks20soni",
                        "content": "Trying to insert the new node to the right of its floor value but not working. Any idea why?"
                    },
                    {
                        "username": "devesht709",
                        "content": "cur, next = None, root\\n        while next:\\n            cur = next\\n            next = cur.left if val < cur.val else cur.right\\n         if the value gone upto exert it must follow the upper casees ...\\n"
                    },
                    {
                        "username": "kirsty",
                        "content": "The constraints say `-10^8 <= Node.val <= 10^8`, but there is an invalid test case error if you include negative values."
                    }
                ]
            },
            {
                "id": 1932430,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "- It\\'s *guaranteed* that `val` does not exist in the original BST.\\n##### This constraint should be removed to add some fun."
                    },
                    {
                        "username": "user1748GJ",
                        "content": "This question should have a follow up section where it asks you to rebalance the tree. I think it would be more interesting that way"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Is it fine to return an unbalanced tree?"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "As you can see in the example 2 it is accepted.\\nYou can give yourself a follow-up challenge to try rebalance the tree yourself"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "The code for inserting the element as leaf node in the tree is easy. But what about inserting the element at the root of the tree like given in the 2nd possible answer for 1st example?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\nC++ iterative approach. Easy T.C=O(h) in worst case height(h) can be n for skewed tree. S.C=O(1) \n\n# Approach\n\n1. Create a new TreeNode with the given value and assign it to the variable newNode.\n2. Check if the root is null. If it is, then the new node becomes the root, so return newNode.\n3. Assign the root node to the variable temp.\n4. Enter a loop that continues until temp becomes null.\n5. Inside the loop, compare the value of temp with the given value.\n   - If the value of temp is less than or equal to the given value, move to the right subtree.\n     - If the right child of temp is null, assign newNode to the right child of temp and break the loop.\n     - Otherwise, update temp to be its right child and continue the loop.\n   - If the value of temp is greater than the given value, move to the left subtree.\n     - If the left child of temp is null, assign newNode to the left child of temp and break the loop.\n     - Otherwise, update temp to be its left child and continue the loop.\n6. Return the root node.\n\n--------------------------------------------------\n# Complexity\n- Time complexity:\nT.C=O(h) in worst case height(h) can be n for skewed tree.\n\n- Space complexity:\nS.C=O(1) no extra space.\n--------------------------------------------------\nPlease Upvote. If understand the concept.\nSolution link:\nhttps://leetcode.com/problems/insert-into-a-binary-search-tree/solutions/3714129/c-iterative-approach-easy-t-c-o-h-in-worst-case-height-h-can-be-n-for-skewed-tree-s-c-o-1/\n"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Why do we even have to return root node which is already known to outside code?"
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get weird error like this \\n[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "ks20soni",
                        "content": "Trying to insert the new node to the right of its floor value but not working. Any idea why?"
                    },
                    {
                        "username": "devesht709",
                        "content": "cur, next = None, root\\n        while next:\\n            cur = next\\n            next = cur.left if val < cur.val else cur.right\\n         if the value gone upto exert it must follow the upper casees ...\\n"
                    },
                    {
                        "username": "kirsty",
                        "content": "The constraints say `-10^8 <= Node.val <= 10^8`, but there is an invalid test case error if you include negative values."
                    }
                ]
            },
            {
                "id": 1846988,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "- It\\'s *guaranteed* that `val` does not exist in the original BST.\\n##### This constraint should be removed to add some fun."
                    },
                    {
                        "username": "user1748GJ",
                        "content": "This question should have a follow up section where it asks you to rebalance the tree. I think it would be more interesting that way"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Is it fine to return an unbalanced tree?"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "As you can see in the example 2 it is accepted.\\nYou can give yourself a follow-up challenge to try rebalance the tree yourself"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "The code for inserting the element as leaf node in the tree is easy. But what about inserting the element at the root of the tree like given in the 2nd possible answer for 1st example?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\nC++ iterative approach. Easy T.C=O(h) in worst case height(h) can be n for skewed tree. S.C=O(1) \n\n# Approach\n\n1. Create a new TreeNode with the given value and assign it to the variable newNode.\n2. Check if the root is null. If it is, then the new node becomes the root, so return newNode.\n3. Assign the root node to the variable temp.\n4. Enter a loop that continues until temp becomes null.\n5. Inside the loop, compare the value of temp with the given value.\n   - If the value of temp is less than or equal to the given value, move to the right subtree.\n     - If the right child of temp is null, assign newNode to the right child of temp and break the loop.\n     - Otherwise, update temp to be its right child and continue the loop.\n   - If the value of temp is greater than the given value, move to the left subtree.\n     - If the left child of temp is null, assign newNode to the left child of temp and break the loop.\n     - Otherwise, update temp to be its left child and continue the loop.\n6. Return the root node.\n\n--------------------------------------------------\n# Complexity\n- Time complexity:\nT.C=O(h) in worst case height(h) can be n for skewed tree.\n\n- Space complexity:\nS.C=O(1) no extra space.\n--------------------------------------------------\nPlease Upvote. If understand the concept.\nSolution link:\nhttps://leetcode.com/problems/insert-into-a-binary-search-tree/solutions/3714129/c-iterative-approach-easy-t-c-o-h-in-worst-case-height-h-can-be-n-for-skewed-tree-s-c-o-1/\n"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Why do we even have to return root node which is already known to outside code?"
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get weird error like this \\n[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "ks20soni",
                        "content": "Trying to insert the new node to the right of its floor value but not working. Any idea why?"
                    },
                    {
                        "username": "devesht709",
                        "content": "cur, next = None, root\\n        while next:\\n            cur = next\\n            next = cur.left if val < cur.val else cur.right\\n         if the value gone upto exert it must follow the upper casees ...\\n"
                    },
                    {
                        "username": "kirsty",
                        "content": "The constraints say `-10^8 <= Node.val <= 10^8`, but there is an invalid test case error if you include negative values."
                    }
                ]
            },
            {
                "id": 1782208,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "- It\\'s *guaranteed* that `val` does not exist in the original BST.\\n##### This constraint should be removed to add some fun."
                    },
                    {
                        "username": "user1748GJ",
                        "content": "This question should have a follow up section where it asks you to rebalance the tree. I think it would be more interesting that way"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Is it fine to return an unbalanced tree?"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "As you can see in the example 2 it is accepted.\\nYou can give yourself a follow-up challenge to try rebalance the tree yourself"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "The code for inserting the element as leaf node in the tree is easy. But what about inserting the element at the root of the tree like given in the 2nd possible answer for 1st example?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\nC++ iterative approach. Easy T.C=O(h) in worst case height(h) can be n for skewed tree. S.C=O(1) \n\n# Approach\n\n1. Create a new TreeNode with the given value and assign it to the variable newNode.\n2. Check if the root is null. If it is, then the new node becomes the root, so return newNode.\n3. Assign the root node to the variable temp.\n4. Enter a loop that continues until temp becomes null.\n5. Inside the loop, compare the value of temp with the given value.\n   - If the value of temp is less than or equal to the given value, move to the right subtree.\n     - If the right child of temp is null, assign newNode to the right child of temp and break the loop.\n     - Otherwise, update temp to be its right child and continue the loop.\n   - If the value of temp is greater than the given value, move to the left subtree.\n     - If the left child of temp is null, assign newNode to the left child of temp and break the loop.\n     - Otherwise, update temp to be its left child and continue the loop.\n6. Return the root node.\n\n--------------------------------------------------\n# Complexity\n- Time complexity:\nT.C=O(h) in worst case height(h) can be n for skewed tree.\n\n- Space complexity:\nS.C=O(1) no extra space.\n--------------------------------------------------\nPlease Upvote. If understand the concept.\nSolution link:\nhttps://leetcode.com/problems/insert-into-a-binary-search-tree/solutions/3714129/c-iterative-approach-easy-t-c-o-h-in-worst-case-height-h-can-be-n-for-skewed-tree-s-c-o-1/\n"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Why do we even have to return root node which is already known to outside code?"
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get weird error like this \\n[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "ks20soni",
                        "content": "Trying to insert the new node to the right of its floor value but not working. Any idea why?"
                    },
                    {
                        "username": "devesht709",
                        "content": "cur, next = None, root\\n        while next:\\n            cur = next\\n            next = cur.left if val < cur.val else cur.right\\n         if the value gone upto exert it must follow the upper casees ...\\n"
                    },
                    {
                        "username": "kirsty",
                        "content": "The constraints say `-10^8 <= Node.val <= 10^8`, but there is an invalid test case error if you include negative values."
                    }
                ]
            },
            {
                "id": 1757939,
                "content": [
                    {
                        "username": "Ebad1001",
                        "content": "- It\\'s *guaranteed* that `val` does not exist in the original BST.\\n##### This constraint should be removed to add some fun."
                    },
                    {
                        "username": "user1748GJ",
                        "content": "This question should have a follow up section where it asks you to rebalance the tree. I think it would be more interesting that way"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "Is it fine to return an unbalanced tree?"
                    },
                    {
                        "username": "user1748GJ",
                        "content": "As you can see in the example 2 it is accepted.\\nYou can give yourself a follow-up challenge to try rebalance the tree yourself"
                    },
                    {
                        "username": "prerna-rn",
                        "content": "The code for inserting the element as leaf node in the tree is easy. But what about inserting the element at the root of the tree like given in the 2nd possible answer for 1st example?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\nC++ iterative approach. Easy T.C=O(h) in worst case height(h) can be n for skewed tree. S.C=O(1) \n\n# Approach\n\n1. Create a new TreeNode with the given value and assign it to the variable newNode.\n2. Check if the root is null. If it is, then the new node becomes the root, so return newNode.\n3. Assign the root node to the variable temp.\n4. Enter a loop that continues until temp becomes null.\n5. Inside the loop, compare the value of temp with the given value.\n   - If the value of temp is less than or equal to the given value, move to the right subtree.\n     - If the right child of temp is null, assign newNode to the right child of temp and break the loop.\n     - Otherwise, update temp to be its right child and continue the loop.\n   - If the value of temp is greater than the given value, move to the left subtree.\n     - If the left child of temp is null, assign newNode to the left child of temp and break the loop.\n     - Otherwise, update temp to be its left child and continue the loop.\n6. Return the root node.\n\n--------------------------------------------------\n# Complexity\n- Time complexity:\nT.C=O(h) in worst case height(h) can be n for skewed tree.\n\n- Space complexity:\nS.C=O(1) no extra space.\n--------------------------------------------------\nPlease Upvote. If understand the concept.\nSolution link:\nhttps://leetcode.com/problems/insert-into-a-binary-search-tree/solutions/3714129/c-iterative-approach-easy-t-c-o-h-in-worst-case-height-h-can-be-n-for-skewed-tree-s-c-o-1/\n"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "Why do we even have to return root node which is already known to outside code?"
                    },
                    {
                        "username": "SG-C",
                        "content": "does anyone get weird error like this \\n[0.014s][warning][os,thread] Failed to start thread \"Unknown thread\" - pthread_create failed (EAGAIN) for attributes: stacksize: 195316k, guardsize: 0k, detached.\\nError occurred during initialization of VM\\njava.lang.OutOfMemoryError: unable to create native thread: possibly out of memory or process/resource limits reached"
                    },
                    {
                        "username": "ks20soni",
                        "content": "Trying to insert the new node to the right of its floor value but not working. Any idea why?"
                    },
                    {
                        "username": "devesht709",
                        "content": "cur, next = None, root\\n        while next:\\n            cur = next\\n            next = cur.left if val < cur.val else cur.right\\n         if the value gone upto exert it must follow the upper casees ...\\n"
                    },
                    {
                        "username": "kirsty",
                        "content": "The constraints say `-10^8 <= Node.val <= 10^8`, but there is an invalid test case error if you include negative values."
                    }
                ]
            }
        ]
    }
]