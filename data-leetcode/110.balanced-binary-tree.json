[
    {
        "title": "Regular Expression Matching",
        "question_content": "Given an input string s&nbsp;and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n\t'.' Matches any single character.​​​​\n\t'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n&nbsp;\nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\nExample 2:\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\nExample 3:\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length&nbsp;<= 20\n\t1 <= p.length&nbsp;<= 20\n\ts contains only lowercase English letters.\n\tp contains only lowercase English letters, '.', and&nbsp;'*'.\n\tIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
        "solutions": [
            {
                "id": 5651,
                "title": "easy-dp-java-solution-with-detailed-explanation",
                "content": "This Solution use 2D DP. beat 90% solutions, very simple.\\n\\nHere are some conditions to figure out, then the logic can be very straightforward.\\n\\n    1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];\\n    2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];\\n    3, If p.charAt(j) == '*': \\n       here are two sub conditions:\\n                   1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty\\n                   2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':\\n                                  dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a \\n                               or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a\\n                               or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty\\n\\nHere is the solution\\n\\n    public boolean isMatch(String s, String p) {\\n\\n        if (s == null || p == null) {\\n            return false;\\n        }\\n        boolean[][] dp = new boolean[s.length()+1][p.length()+1];\\n        dp[0][0] = true;\\n        for (int i = 0; i < p.length(); i++) {\\n            if (p.charAt(i) == '*' && dp[0][i-1]) {\\n                dp[0][i+1] = true;\\n            }\\n        }\\n        for (int i = 0 ; i < s.length(); i++) {\\n            for (int j = 0; j < p.length(); j++) {\\n                if (p.charAt(j) == '.') {\\n                    dp[i+1][j+1] = dp[i][j];\\n                }\\n                if (p.charAt(j) == s.charAt(i)) {\\n                    dp[i+1][j+1] = dp[i][j];\\n                }\\n                if (p.charAt(j) == '*') {\\n                    if (p.charAt(j-1) != s.charAt(i) && p.charAt(j-1) != '.') {\\n                        dp[i+1][j+1] = dp[i+1][j-1];\\n                    } else {\\n                        dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "This Solution use 2D DP. beat 90% solutions, very simple.\\n\\nHere are some conditions to figure out, then the logic can be very straightforward.\\n\\n    1, If p.charAt(j) == s.charAt(i) :  dp[i][j] = dp[i-1][j-1];\\n    2, If p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];\\n    3, If p.charAt(j) == '*': \\n       here are two sub conditions:\\n                   1   if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty\\n                   2   if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':\\n                                  dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a \\n                               or dp[i][j] = dp[i][j-1]   // in this case, a* counts as single a\\n                               or dp[i][j] = dp[i][j-2]   // in this case, a* counts as empty\\n\\nHere is the solution\\n\\n    public boolean isMatch(String s, String p) {\\n\\n        if (s == null || p == null) {\\n            return false;\\n        }\\n        boolean[][] dp = new boolean[s.length()+1][p.length()+1];\\n        dp[0][0] = true;\\n        for (int i = 0; i < p.length(); i++) {\\n            if (p.charAt(i) == '*' && dp[0][i-1]) {\\n                dp[0][i+1] = true;\\n            }\\n        }\\n        for (int i = 0 ; i < s.length(); i++) {\\n            for (int j = 0; j < p.length(); j++) {\\n                if (p.charAt(j) == '.') {\\n                    dp[i+1][j+1] = dp[i][j];\\n                }\\n                if (p.charAt(j) == s.charAt(i)) {\\n                    dp[i+1][j+1] = dp[i][j];\\n                }\\n                if (p.charAt(j) == '*') {\\n                    if (p.charAt(j-1) != s.charAt(i) && p.charAt(j-1) != '.') {\\n                        dp[i+1][j+1] = dp[i+1][j-1];\\n                    } else {\\n                        dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 191830,
                "title": "java-dp-solution-beats-100-with-explanation",
                "content": "Consider following example\\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y\\na 1\\na 2\\nb 3\\n```\\n\\n`dp[i][j]` denotes if `s.substring(0,i)` is valid for pattern `p.substring(0,j)`. For example `dp[0][0] == true` (denoted by y in the matrix) because when s and p are both empty they match. So if we somehow base `dp[i+1][j+1]` on previos `dp[i][j]`\\'s then the result will be `dp[s.length()][p.length()]`  \\n\\nSo what about the first column? for and empty pattern `p=\"\"` only thing that is valid is an empty string `s=\"\"` and that is already our `dp[0][0]` which is true. That means rest of `dp[i][0]\\' is false.\\n\\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y\\na 1 n\\na 2 n\\nb 3 n\\n```\\n\\nWhat about the first row? In other words which pattern p matches empty string `s=\"\"`? The answer is either an empty pattern `p=\"\"` or a pattern that can represent an empty string such as `p=\"a*\"`, `p=\"z*\"` or more interestingly a combiation of them as in `p=\"a*b*c*\"`. Below for loop is used to populate `dp[0][j]`. Note how it uses previous states by checking `dp[0][j-2]`\\n\\n```java\\n        for (int j=2; j<=p.length(); j++) {\\n            dp[0][j] = p.charAt(j-1) == \\'*\\' && dp[0][j-2]; \\n        }\\n```\\n\\nAt this stage our matrix has become as follows: Notice `dp[0][2]` and `dp[0][4]` are both true because `p=\"c*\"` and `p=\"c*a*\"` can both match an empty string.\\n\\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y n y n y n\\na 1 n\\na 2 n\\nb 3 n\\n```\\n\\nSo now we can start our main iteration. It is basically the same, we will iterate all possible s lengths (i) for all possible p lengths (j) and we will try to find a relation based on previous results. Turns out there are two cases.\\n1) `(p.charAt(j-1) == s.charAt(i-1) || p.charAt(j-1) == \\'.\\')` if the current characters match or pattern has `.` then the result is determined by the previous state `dp[i][j] = dp[i-1][j-1]`. *Don\\'t be confused by the `charAt(j-1)` `charAt(i-1)` indexes using a `-1` offset that is because our dp array is actually one index bigger than our string and pattern lenghts to hold the initial state `dp[0][0]`*\\n\\n2) if `p.charAt(j-1) == \\'*\\'` then either it acts as an empty set and the result is `dp[i][j] = dp[i][j-2]` or `(s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == \\'.\\')` current char of string equals the char preceding `*` in pattern so the result is  `dp[i-1][j]`\\n\\nSo here is the final state of matrix after we evaluate all elements:\\n\\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y n y n y n\\na 1 n n n y y n\\na 2 n n n n y n\\nb 3 n n n n n y\\n```\\n\\nAnd here is the code: \\n\\n```java\\npublic boolean isMatch(String s, String p) {\\n        if (p == null || p.length() == 0) return (s == null || s.length() == 0);\\n        \\n        boolean dp[][] = new boolean[s.length()+1][p.length()+1];\\n        dp[0][0] = true;\\n        for (int j=2; j<=p.length(); j++) {\\n            dp[0][j] = p.charAt(j-1) == \\'*\\' && dp[0][j-2]; \\n        }\\n        \\n        for (int j=1; j<=p.length(); j++) {\\n            for (int i=1; i<=s.length(); i++) {\\n                if (p.charAt(j-1) == s.charAt(i-1) || p.charAt(j-1) == \\'.\\') \\n\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n                else if(p.charAt(j-1) == \\'*\\')\\n                    dp[i][j] = dp[i][j-2] || ((s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == \\'.\\') && dp[i-1][j]); \\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }\\n```\\n\\nTime and space complexity are `O(p.length() * s.length())`. \\nTry to evaluate the matrix by yourself if it is still confusing, hope this helps!",
                "solutionTags": [],
                "code": "```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y\\na 1\\na 2\\nb 3\\n```\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y\\na 1 n\\na 2 n\\nb 3 n\\n```\n```java\\n        for (int j=2; j<=p.length(); j++) {\\n            dp[0][j] = p.charAt(j-1) == \\'*\\' && dp[0][j-2]; \\n        }\\n```\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y n y n y n\\na 1 n\\na 2 n\\nb 3 n\\n```\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y n y n y n\\na 1 n n n y y n\\na 2 n n n n y n\\nb 3 n n n n n y\\n```\n```java\\npublic boolean isMatch(String s, String p) {\\n        if (p == null || p.length() == 0) return (s == null || s.length() == 0);\\n        \\n        boolean dp[][] = new boolean[s.length()+1][p.length()+1];\\n        dp[0][0] = true;\\n        for (int j=2; j<=p.length(); j++) {\\n            dp[0][j] = p.charAt(j-1) == \\'*\\' && dp[0][j-2]; \\n        }\\n        \\n        for (int j=1; j<=p.length(); j++) {\\n            for (int i=1; i<=s.length(); i++) {\\n                if (p.charAt(j-1) == s.charAt(i-1) || p.charAt(j-1) == \\'.\\') \\n\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n                else if(p.charAt(j-1) == \\'*\\')\\n                    dp[i][j] = dp[i][j-2] || ((s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == \\'.\\') && dp[i-1][j]); \\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2976919,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.length(), m = p.length();\\n        bool dp[n+1][m+1];\\n        memset(dp, false, sizeof(dp));\\n        dp[0][0] = true;\\n        \\n        for(int i=0; i<=n; i++){\\n            for(int j=1; j<=m; j++){\\n                if(p[j-1] == \\'*\\'){\\n                    dp[i][j] = dp[i][j-2] || (i > 0 && (s[i-1] == p[j-2] || p[j-2] == \\'.\\') && dp[i-1][j]);\\n                }\\n                else{\\n                    dp[i][j] = i > 0 && dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == \\'.\\');\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        i, j = len(s) - 1, len(p) - 1\\n        return self.backtrack({}, s, p, i, j)\\n\\n    def backtrack(self, cache, s, p, i, j):\\n        key = (i, j)\\n        if key in cache:\\n            return cache[key]\\n\\n        if i == -1 and j == -1:\\n            cache[key] = True\\n            return True\\n\\n        if i != -1 and j == -1:\\n            cache[key] = False\\n            return cache[key]\\n\\n        if i == -1 and p[j] == \\'*\\':\\n            k = j\\n            while k != -1 and p[k] == \\'*\\':\\n                k -= 2\\n            \\n            if k == -1:\\n                cache[key] = True\\n                return cache[key]\\n            \\n            cache[key] = False\\n            return cache[key]\\n        \\n        if i == -1 and p[j] != \\'*\\':\\n            cache[key] = False\\n            return cache[key]\\n\\n        if p[j] == \\'*\\':\\n            if self.backtrack(cache, s, p, i, j - 2):\\n                cache[key] = True\\n                return cache[key]\\n            \\n            if p[j - 1] == s[i] or p[j - 1] == \\'.\\':\\n                if self.backtrack(cache, s, p, i - 1, j):\\n                    cache[key] = True\\n                    return cache[key]\\n        \\n        if p[j] == \\'.\\' or s[i] == p[j]:\\n            if self.backtrack(cache, s, p, i - 1, j - 1):\\n                cache[key] = True\\n                return cache[key]\\n\\n        cache[key] = False\\n        return cache[key]\\n```\\n\\n```Java []\\nenum Result {\\n    TRUE, FALSE\\n}\\n\\nclass Solution {\\n    Result[][] memo;\\n\\n    public boolean isMatch(String text, String pattern) {\\n        memo = new Result[text.length() + 1][pattern.length() + 1];\\n        return dp(0, 0, text, pattern);\\n    }\\n\\n    public boolean dp(int i, int j, String text, String pattern) {\\n        if (memo[i][j] != null) {\\n            return memo[i][j] == Result.TRUE;\\n        }\\n        boolean ans;\\n        if (j == pattern.length()){\\n            ans = i == text.length();\\n        } else{\\n            boolean first_match = (i < text.length() &&\\n                                   (pattern.charAt(j) == text.charAt(i) ||\\n                                    pattern.charAt(j) == \\'.\\'));\\n\\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == \\'*\\'){\\n                ans = (dp(i, j+2, text, pattern) ||\\n                       first_match && dp(i+1, j, text, pattern));\\n            } else {\\n                ans = first_match && dp(i+1, j+1, text, pattern);\\n            }\\n        }\\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.length(), m = p.length();\\n        bool dp[n+1][m+1];\\n        memset(dp, false, sizeof(dp));\\n        dp[0][0] = true;\\n        \\n        for(int i=0; i<=n; i++){\\n            for(int j=1; j<=m; j++){\\n                if(p[j-1] == \\'*\\'){\\n                    dp[i][j] = dp[i][j-2] || (i > 0 && (s[i-1] == p[j-2] || p[j-2] == \\'.\\') && dp[i-1][j]);\\n                }\\n                else{\\n                    dp[i][j] = i > 0 && dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == \\'.\\');\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        i, j = len(s) - 1, len(p) - 1\\n        return self.backtrack({}, s, p, i, j)\\n\\n    def backtrack(self, cache, s, p, i, j):\\n        key = (i, j)\\n        if key in cache:\\n            return cache[key]\\n\\n        if i == -1 and j == -1:\\n            cache[key] = True\\n            return True\\n\\n        if i != -1 and j == -1:\\n            cache[key] = False\\n            return cache[key]\\n\\n        if i == -1 and p[j] == \\'*\\':\\n            k = j\\n            while k != -1 and p[k] == \\'*\\':\\n                k -= 2\\n            \\n            if k == -1:\\n                cache[key] = True\\n                return cache[key]\\n            \\n            cache[key] = False\\n            return cache[key]\\n        \\n        if i == -1 and p[j] != \\'*\\':\\n            cache[key] = False\\n            return cache[key]\\n\\n        if p[j] == \\'*\\':\\n            if self.backtrack(cache, s, p, i, j - 2):\\n                cache[key] = True\\n                return cache[key]\\n            \\n            if p[j - 1] == s[i] or p[j - 1] == \\'.\\':\\n                if self.backtrack(cache, s, p, i - 1, j):\\n                    cache[key] = True\\n                    return cache[key]\\n        \\n        if p[j] == \\'.\\' or s[i] == p[j]:\\n            if self.backtrack(cache, s, p, i - 1, j - 1):\\n                cache[key] = True\\n                return cache[key]\\n\\n        cache[key] = False\\n        return cache[key]\\n```\n```Java []\\nenum Result {\\n    TRUE, FALSE\\n}\\n\\nclass Solution {\\n    Result[][] memo;\\n\\n    public boolean isMatch(String text, String pattern) {\\n        memo = new Result[text.length() + 1][pattern.length() + 1];\\n        return dp(0, 0, text, pattern);\\n    }\\n\\n    public boolean dp(int i, int j, String text, String pattern) {\\n        if (memo[i][j] != null) {\\n            return memo[i][j] == Result.TRUE;\\n        }\\n        boolean ans;\\n        if (j == pattern.length()){\\n            ans = i == text.length();\\n        } else{\\n            boolean first_match = (i < text.length() &&\\n                                   (pattern.charAt(j) == text.charAt(i) ||\\n                                    pattern.charAt(j) == \\'.\\'));\\n\\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == \\'*\\'){\\n                ans = (dp(i, j+2, text, pattern) ||\\n                       first_match && dp(i+1, j, text, pattern));\\n            } else {\\n                ans = first_match && dp(i+1, j+1, text, pattern);\\n            }\\n        }\\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5665,
                "title": "my-concise-recursive-and-dp-solutions-with-full-explanation-in-c",
                "content": "Please refer to [my blog post][1] if you have any comment. Wildcard matching problem can be solved similarly.\\n\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            if (p.empty())    return s.empty();\\n            \\n            if ('*' == p[1])\\n                // x* matches empty string or at least one character: x* -> xx*\\n                // *s is to ensure s is non-empty\\n                return (isMatch(s, p.substr(2)) || !s.empty() && (s[0] == p[0] || '.' == p[0]) && isMatch(s.substr(1), p));\\n            else\\n                return !s.empty() && (s[0] == p[0] || '.' == p[0]) && isMatch(s.substr(1), p.substr(1));\\n        }\\n    };\\n    \\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            /**\\n             * f[i][j]: if s[0..i-1] matches p[0..j-1]\\n             * if p[j - 1] != '*'\\n             *      f[i][j] = f[i - 1][j - 1] && s[i - 1] == p[j - 1]\\n             * if p[j - 1] == '*', denote p[j - 2] with x\\n             *      f[i][j] is true iff any of the following is true\\n             *      1) \"x*\" repeats 0 time and matches empty: f[i][j - 2]\\n             *      2) \"x*\" repeats >= 1 times and matches \"x*x\": s[i - 1] == x && f[i - 1][j]\\n             * '.' matches any single character\\n             */\\n            int m = s.size(), n = p.size();\\n            vector<vector<bool>> f(m + 1, vector<bool>(n + 1, false));\\n            \\n            f[0][0] = true;\\n            for (int i = 1; i <= m; i++)\\n                f[i][0] = false;\\n            // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] is '*' and p[0..j - 3] matches empty\\n            for (int j = 1; j <= n; j++)\\n                f[0][j] = j > 1 && '*' == p[j - 1] && f[0][j - 2];\\n            \\n            for (int i = 1; i <= m; i++)\\n                for (int j = 1; j <= n; j++)\\n                    if (p[j - 1] != '*')\\n                        f[i][j] = f[i - 1][j - 1] && (s[i - 1] == p[j - 1] || '.' == p[j - 1]);\\n                    else\\n                        // p[0] cannot be '*' so no need to check \"j > 1\" here\\n                        f[i][j] = f[i][j - 2] || (s[i - 1] == p[j - 2] || '.' == p[j - 2]) && f[i - 1][j];\\n            \\n            return f[m][n];\\n        }\\n    };\\n\\n  [1]: http://xiaohuiliucuriosity.blogspot.com/2014/12/regular-expression-matching.html",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            if (p.empty())    return s.empty();\\n            \\n            if ('*' == p[1])\\n                // x* matches empty string or at least one character: x* -> xx*\\n                // *s is to ensure s is non-empty\\n                return (isMatch(s, p.substr(2)) || !s.empty() && (s[0] == p[0] || '.' == p[0]) && isMatch(s.substr(1), p));\\n            else\\n                return !s.empty() && (s[0] == p[0] || '.' == p[0]) && isMatch(s.substr(1), p.substr(1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 5684,
                "title": "c-o-n-space-dp",
                "content": "We define `dp[i][j]` to be `true` if `s[0..i)` matches `p[0..j)` and `false` otherwise. The state equations will be:\\n\\n 1. `dp[i][j] = dp[i - 1][j - 1]`, if `p[j - 1] != \\'*\\' && (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\')`;\\n 2. `dp[i][j] = dp[i][j - 2]`, if `p[j - 1] == \\'*\\'` and the pattern repeats for 0 time;\\n 3. `dp[i][j] = dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\')`, if `p[j - 1] == \\'*\\'` and the pattern repeats for at least 1 time.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size(), n = p.size();\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        dp[0][0] = true;\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i][j - 2] || (i && dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\'));\\n                } else {\\n                    dp[i][j] = i && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\');\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\nAnd you may further reduce the memory usage down to two vectors (`O(n)`).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size(), n = p.size();\\n        vector<bool> pre(n + 1, false), cur(n + 1, false);\\n        cur[0] = true;\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (p[j - 1] == \\'*\\') {\\n                    cur[j] = cur[j - 2] || (i && pre[j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\'));\\n                } else {\\n                    cur[j] = i && pre[j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\');\\n                }\\n            }\\n            fill(pre.begin(), pre.end(), false);\\n\\t\\t\\tswap(pre, cur);\\n        }\\n        return pre[n];\\n    }\\n};\\n```\\n\\nOr even just one vector.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size(), n = p.size();\\n        vector<bool> cur(n + 1, false);\\n        for (int i = 0; i <= m; i++) {\\n            bool pre = cur[0];\\n            cur[0] = !i;\\n            for (int j = 1; j <= n; j++) {\\n                bool temp = cur[j];\\n                if (p[j - 1] == \\'*\\') {\\n                    cur[j] = cur[j - 2] || (i && cur[j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\'));\\n                } else {\\n                    cur[j] = i && pre && (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\');\\n                }\\n                pre = temp;\\n            }\\n        }\\n        return cur[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size(), n = p.size();\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        dp[0][0] = true;\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i][j - 2] || (i && dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\'));\\n                } else {\\n                    dp[i][j] = i && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\');\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size(), n = p.size();\\n        vector<bool> pre(n + 1, false), cur(n + 1, false);\\n        cur[0] = true;\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (p[j - 1] == \\'*\\') {\\n                    cur[j] = cur[j - 2] || (i && pre[j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\'));\\n                } else {\\n                    cur[j] = i && pre[j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\');\\n                }\\n            }\\n            fill(pre.begin(), pre.end(), false);\\n\\t\\t\\tswap(pre, cur);\\n        }\\n        return pre[n];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size(), n = p.size();\\n        vector<bool> cur(n + 1, false);\\n        for (int i = 0; i <= m; i++) {\\n            bool pre = cur[0];\\n            cur[0] = !i;\\n            for (int j = 1; j <= n; j++) {\\n                bool temp = cur[j];\\n                if (p[j - 1] == \\'*\\') {\\n                    cur[j] = cur[j - 2] || (i && cur[j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\'));\\n                } else {\\n                    cur[j] = i && pre && (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\');\\n                }\\n                pre = temp;\\n            }\\n        }\\n        return cur[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5847,
                "title": "evolve-from-brute-force-to-dp",
                "content": "The point I want to show is once you figure out the naive approach (#1 or #2), it is effortless to transform to dp. Mostly copy and replace.\\n1. Recursion. This is the most straight forward idea. We match the current char in s and p, then solve the problem recursively. Following are the keys\\n\\t1\\\\) Termination condition. Since p can match empty string, s is empty (i=sn) cannot terminate the matching. Only p is empty(j==pn) terminates the recursion.\\n\\t2\\\\) If a char is followed by *, then we only need to honor the *. No need to do 1 to 1 match. 1 to 1 match is only needed if a char is not followed by *.\\n\\t3\\\\) When matching *, we check if the next char is *. If we process * as the current char, it means 1 to 1 match is already done for the previous char. The logic is not clean.\\n* c++\\n```\\n    bool isMatch(string s, string p) {\\n        return isMatch(0,s,0,p);    \\n    }\\n    bool isMatch(int i, string& s, int j, string &p) {\\n        int pn=p.size(), sn = s.size();\\n        if(j==pn) return i==sn;\\n        if(p[j+1]==\\'*\\') {\\n            if(isMatch(i,s,j+2,p)) return 1;\\n            while(i<sn && (p[j]==s[i]||p[j]==\\'.\\')) \\n\\t\\t\\t\\tif(isMatch(++i,s,j+2,p)) return 1;\\n        } else if (i<sn && (p[j]==\\'.\\'|| s[i]==p[j]) && isMatch(i+1,s,j+1,p)) \\n\\t\\t\\treturn 1;\\n        return 0;\\n    }\\n```\\n* java\\n```\\n\\tpublic boolean isMatch(String s, String p) {\\n        return isMatch(0,s,0,p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) { \\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) { // since * in p can match 0 of previous char, so empty string(i==sn) may match p\\n            return i==sn;    \\n        }\\n        char pj = p.charAt(j);\\n        if(j+1<pn && p.charAt(j+1)==\\'*\\') { //match *, needs to look at the next char to repeate current char\\n            if(isMatch(i,s,j+2,p)) {\\n                return true;\\n            }\\n            while(i<sn && (pj == \\'.\\'||pj==s.charAt(i))) {\\n                if(isMatch(++i,s,j+2,p)) {\\n                    return true;\\n                }\\n            }\\n        } else if(i<sn && (s.charAt(i) == pj ||    //match char\\n                   pj==\\'.\\')) {              //match dot\\n            return isMatch(i+1, s, j+1, p);\\n        }\\n        return false;\\n    }\\n```\\nTime complexity is roughly O(m+n choose n).\\nSay n is length of s, m is length of p. In the worst case,\\nT(n,m) = T(n,m-2)+T(n-1,m-2)+T(n-2,m-2)+...+T(1, m-2)\\nT(n-1,m) = T(n-1,m-2)+T(n-2,m-2)+...+T(1,m-2)\\n=> ****T(n,m) = T(n-1,m) + T(n,m-2)****\\nInitial conditions are T(0,m) = m, T(n,0) = 1\\nTo solve the 2 variable recursion, see [here](http://math.stackexchange.com/questions/206158/solving-recurrence-relation-in-2-variables)\\n\\n2. Recursion The highlighted recursive equation indicates a more concise way to handle the case when * matches 1 or more characters. It does not change the time complexity of the recursion but it transforms to a better run time dp solution compared with the original equation.\\n* c++\\n```\\n    bool isMatch(string s, string p) {\\n        return isMatch(0,s,0,p);    \\n    }\\n    bool isMatch(int i, string& s, int j, string &p) {\\n        int pn=p.size(), sn = s.size();\\n        if(j==pn) return i==sn;\\n        if(p[j+1]==\\'*\\') {\\n            if(isMatch(i,s,j+2,p) || \\n               i<sn && (p[j] == \\'.\\' || s[i] == p[j]) && isMatch(i+1,s,j,p)) \\n\\t\\t\\t   return 1;\\n        } else if (i<sn && (p[j]==\\'.\\'|| s[i]==p[j]) && isMatch(i+1,s,j+1,p)) \\n\\t\\t\\treturn 1;\\n        return 0;\\n    }\\n```\\n* java\\n```\\n\\tpublic boolean isMatch(String s, String p) {\\n        return isMatch(0,s,0,p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) { \\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) { // since * in p can match 0 of previous char, so empty string(i==sn) may match p\\n            return i==sn;    \\n        }\\n        char pj = p.charAt(j);\\n        if(j+1<pn && p.charAt(j+1)==\\'*\\') { //match *, needs to look at the next char to repeate current char\\n            if(isMatch(i,s,j+2,p)) {\\n                return true;\\n            }\\n            if(i<sn && (pj == \\'.\\'||pj==s.charAt(i))) {\\n                if(isMatch(i+1,s,j,p)) {\\n                    return true;\\n                }\\n            }\\n        } else if(i<sn && (s.charAt(i) == pj ||    //match char\\n                   pj==\\'.\\')) {              //match dot\\n            return isMatch(i+1, s, j+1, p);\\n        }\\n        return false;\\n    }\\n```\\n3. Recursion with memoization O(mn), add a vector, the rest is the same as #2.    \\n* c++\\n```\\n    bool isMatch(string s, string p) {\\n        vector<vector<char>> dp(s.size()+1,vector<char>(p.size()+1,-1));\\n        return isMatch(0,s,0,p,dp);    \\n    }\\n    bool isMatch(int i, string& s, int j, string &p, vector<vector<char>> &dp) {\\n        if(dp[i][j] > -1) return dp[i][j];\\n        int pn=p.size(), sn = s.size();\\n        if(j==pn) return dp[i][j] = i==sn;\\n        if(p[j+1]==\\'*\\') {\\n            if(isMatch(i,s,j+2,p,dp) || \\n               i<sn && (p[j] == \\'.\\' || s[i] == p[j]) && isMatch(i+1,s,j,p,dp)) \\n\\t\\t\\t   return dp[i][j] = 1;\\n        } else if (i<sn && (p[j]==\\'.\\'|| s[i]==p[j]) && isMatch(i+1,s,j+1,p,dp)) \\n\\t\\t\\treturn dp[i][j] = 1;\\n        return dp[i][j] = 0;\\n    }\\n```\\n* java\\n```\\n\\tBoolean[][] mem;\\n    public boolean isMatch(String s, String p) {\\n        mem = new Boolean[s.length()+1][p.length()];\\n        return isMatch(0,s,0,p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) { \\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) { // since * in p can match 0 of previous char, so empty string(i==sn) may match p\\n            return i==sn;    \\n        }\\n        if(mem[i][j]!=null) {\\n            return mem[i][j];\\n        }\\n        char pj = p.charAt(j);\\n        if(j+1<pn && p.charAt(j+1)==\\'*\\') { //match *, needs to look at the next char to repeate current char\\n            if(isMatch(i,s,j+2,p)) {\\n                return mem[i][j]=true;\\n            }\\n            if(i<sn && (pj == \\'.\\'||pj==s.charAt(i))) {\\n                if(isMatch(i+1,s,j,p)) {\\n                    return mem[i][j]=true;\\n                }\\n            }\\n        } else if(i<sn && (s.charAt(i) == pj ||    //match char\\n                   pj==\\'.\\')) {              //match dot\\n            return mem[i][j]=isMatch(i+1, s, j+1, p);\\n        }\\n        return mem[i][j]=false;\\n    }\\n```\\n4. Bottom up dp to be consistent with #3, O(mn), use for loop instead of recursion, the rest is the same as #2 and #3.\\nIdea is the same as top down dp.\\n* c++\\n```\\n     bool isMatch(string s, string p) {\\n        int pn=p.size(), sn = s.size();\\n        vector<vector<bool>> dp(sn+1,vector<bool>(pn+1));\\n        dp[sn][pn] = 1;\\n        for(int i = sn;i>=0;i--) \\n            for(int j=pn-1;j>=0;j--) \\n                if(p[j+1]==\\'*\\') \\n\\t\\t\\t\\t\\tdp[i][j] = dp[i][j+2] || i<sn && (p[j] == \\'.\\' || s[i] == p[j]) && dp[i+1][j];\\n                else dp[i][j] = i<sn && (p[j]==\\'.\\'|| s[i]==p[j]) && dp[i+1][j+1];\\n        return dp[0][0];    \\n    }\\n```\\n* java\\n```\\n\\tpublic boolean isMatch(String s, String p) {\\n        int sn=s.length(),pn=p.length();\\n        boolean[][] dp=new boolean[sn+1][pn+1];\\n        dp[sn][pn]=true;\\n        for(int i=sn;i>=0;i--)\\n            for(int j=pn-1;j>=0;j--)\\n                if(j+1<pn&&p.charAt(j+1)==\\'*\\') {\\n                    dp[i][j]=dp[i][j+2];\\n                    if(i<sn&&(p.charAt(j)==\\'.\\'||s.charAt(i)==p.charAt(j))) \\n                        dp[i][j]|=dp[i+1][j];\\n                } else if(i<sn&&(p.charAt(j)==\\'.\\'||s.charAt(i)==p.charAt(j))) \\n                    dp[i][j]=dp[i+1][j+1];\\n        return dp[0][0];    \\n    }\\n}\\n```\\n5. Java 1 liner. In real work, none of the above is accpetable due to readability and maintenane overehead.\\n```\\n\\tpublic boolean isMatch(String s, String p) {\\n        return s.matches(p); \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n    bool isMatch(string s, string p) {\\n        return isMatch(0,s,0,p);    \\n    }\\n    bool isMatch(int i, string& s, int j, string &p) {\\n        int pn=p.size(), sn = s.size();\\n        if(j==pn) return i==sn;\\n        if(p[j+1]==\\'*\\') {\\n            if(isMatch(i,s,j+2,p)) return 1;\\n            while(i<sn && (p[j]==s[i]||p[j]==\\'.\\')) \\n\\t\\t\\t\\tif(isMatch(++i,s,j+2,p)) return 1;\\n        } else if (i<sn && (p[j]==\\'.\\'|| s[i]==p[j]) && isMatch(i+1,s,j+1,p)) \\n\\t\\t\\treturn 1;\\n        return 0;\\n    }\\n```\n```\\n\\tpublic boolean isMatch(String s, String p) {\\n        return isMatch(0,s,0,p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) { \\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) { // since * in p can match 0 of previous char, so empty string(i==sn) may match p\\n            return i==sn;    \\n        }\\n        char pj = p.charAt(j);\\n        if(j+1<pn && p.charAt(j+1)==\\'*\\') { //match *, needs to look at the next char to repeate current char\\n            if(isMatch(i,s,j+2,p)) {\\n                return true;\\n            }\\n            while(i<sn && (pj == \\'.\\'||pj==s.charAt(i))) {\\n                if(isMatch(++i,s,j+2,p)) {\\n                    return true;\\n                }\\n            }\\n        } else if(i<sn && (s.charAt(i) == pj ||    //match char\\n                   pj==\\'.\\')) {              //match dot\\n            return isMatch(i+1, s, j+1, p);\\n        }\\n        return false;\\n    }\\n```\n```\\n    bool isMatch(string s, string p) {\\n        return isMatch(0,s,0,p);    \\n    }\\n    bool isMatch(int i, string& s, int j, string &p) {\\n        int pn=p.size(), sn = s.size();\\n        if(j==pn) return i==sn;\\n        if(p[j+1]==\\'*\\') {\\n            if(isMatch(i,s,j+2,p) || \\n               i<sn && (p[j] == \\'.\\' || s[i] == p[j]) && isMatch(i+1,s,j,p)) \\n\\t\\t\\t   return 1;\\n        } else if (i<sn && (p[j]==\\'.\\'|| s[i]==p[j]) && isMatch(i+1,s,j+1,p)) \\n\\t\\t\\treturn 1;\\n        return 0;\\n    }\\n```\n```\\n\\tpublic boolean isMatch(String s, String p) {\\n        return isMatch(0,s,0,p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) { \\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) { // since * in p can match 0 of previous char, so empty string(i==sn) may match p\\n            return i==sn;    \\n        }\\n        char pj = p.charAt(j);\\n        if(j+1<pn && p.charAt(j+1)==\\'*\\') { //match *, needs to look at the next char to repeate current char\\n            if(isMatch(i,s,j+2,p)) {\\n                return true;\\n            }\\n            if(i<sn && (pj == \\'.\\'||pj==s.charAt(i))) {\\n                if(isMatch(i+1,s,j,p)) {\\n                    return true;\\n                }\\n            }\\n        } else if(i<sn && (s.charAt(i) == pj ||    //match char\\n                   pj==\\'.\\')) {              //match dot\\n            return isMatch(i+1, s, j+1, p);\\n        }\\n        return false;\\n    }\\n```\n```\\n    bool isMatch(string s, string p) {\\n        vector<vector<char>> dp(s.size()+1,vector<char>(p.size()+1,-1));\\n        return isMatch(0,s,0,p,dp);    \\n    }\\n    bool isMatch(int i, string& s, int j, string &p, vector<vector<char>> &dp) {\\n        if(dp[i][j] > -1) return dp[i][j];\\n        int pn=p.size(), sn = s.size();\\n        if(j==pn) return dp[i][j] = i==sn;\\n        if(p[j+1]==\\'*\\') {\\n            if(isMatch(i,s,j+2,p,dp) || \\n               i<sn && (p[j] == \\'.\\' || s[i] == p[j]) && isMatch(i+1,s,j,p,dp)) \\n\\t\\t\\t   return dp[i][j] = 1;\\n        } else if (i<sn && (p[j]==\\'.\\'|| s[i]==p[j]) && isMatch(i+1,s,j+1,p,dp)) \\n\\t\\t\\treturn dp[i][j] = 1;\\n        return dp[i][j] = 0;\\n    }\\n```\n```\\n\\tBoolean[][] mem;\\n    public boolean isMatch(String s, String p) {\\n        mem = new Boolean[s.length()+1][p.length()];\\n        return isMatch(0,s,0,p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) { \\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) { // since * in p can match 0 of previous char, so empty string(i==sn) may match p\\n            return i==sn;    \\n        }\\n        if(mem[i][j]!=null) {\\n            return mem[i][j];\\n        }\\n        char pj = p.charAt(j);\\n        if(j+1<pn && p.charAt(j+1)==\\'*\\') { //match *, needs to look at the next char to repeate current char\\n            if(isMatch(i,s,j+2,p)) {\\n                return mem[i][j]=true;\\n            }\\n            if(i<sn && (pj == \\'.\\'||pj==s.charAt(i))) {\\n                if(isMatch(i+1,s,j,p)) {\\n                    return mem[i][j]=true;\\n                }\\n            }\\n        } else if(i<sn && (s.charAt(i) == pj ||    //match char\\n                   pj==\\'.\\')) {              //match dot\\n            return mem[i][j]=isMatch(i+1, s, j+1, p);\\n        }\\n        return mem[i][j]=false;\\n    }\\n```\n```\\n     bool isMatch(string s, string p) {\\n        int pn=p.size(), sn = s.size();\\n        vector<vector<bool>> dp(sn+1,vector<bool>(pn+1));\\n        dp[sn][pn] = 1;\\n        for(int i = sn;i>=0;i--) \\n            for(int j=pn-1;j>=0;j--) \\n                if(p[j+1]==\\'*\\') \\n\\t\\t\\t\\t\\tdp[i][j] = dp[i][j+2] || i<sn && (p[j] == \\'.\\' || s[i] == p[j]) && dp[i+1][j];\\n                else dp[i][j] = i<sn && (p[j]==\\'.\\'|| s[i]==p[j]) && dp[i+1][j+1];\\n        return dp[0][0];    \\n    }\\n```\n```\\n\\tpublic boolean isMatch(String s, String p) {\\n        int sn=s.length(),pn=p.length();\\n        boolean[][] dp=new boolean[sn+1][pn+1];\\n        dp[sn][pn]=true;\\n        for(int i=sn;i>=0;i--)\\n            for(int j=pn-1;j>=0;j--)\\n                if(j+1<pn&&p.charAt(j+1)==\\'*\\') {\\n                    dp[i][j]=dp[i][j+2];\\n                    if(i<sn&&(p.charAt(j)==\\'.\\'||s.charAt(i)==p.charAt(j))) \\n                        dp[i][j]|=dp[i+1][j];\\n                } else if(i<sn&&(p.charAt(j)==\\'.\\'||s.charAt(i)==p.charAt(j))) \\n                    dp[i][j]=dp[i+1][j+1];\\n        return dp[0][0];    \\n    }\\n}\\n```\n```\\n\\tpublic boolean isMatch(String s, String p) {\\n        return s.matches(p); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5723,
                "title": "my-dp-approach-in-python-with-comments-and-unittest",
                "content": "I shared my DP approach with comments and provided some unit tests for it. Some statements in the approach directly affect some corner cases, for example, comment out line 22-23, then the unittest `test_symbol_0` will fail. Hope this script helps us better understand the problem.\\n\\n    import unittest\\n    \\n    \\n    class Solution(object):\\n        def isMatch(self, s, p):\\n            # The DP table and the string s and p use the same indexes i and j, but\\n            # table[i][j] means the match status between p[:i] and s[:j], i.e.\\n            # table[0][0] means the match status of two empty strings, and\\n            # table[1][1] means the match status of p[0] and s[0]. Therefore, when\\n            # refering to the i-th and the j-th characters of p and s for updating\\n            # table[i][j], we use p[i - 1] and s[j - 1].\\n    \\n            # Initialize the table with False. The first row is satisfied.\\n            table = [[False] * (len(s) + 1) for _ in range(len(p) + 1)]\\n    \\n            # Update the corner case of matching two empty strings.\\n            table[0][0] = True\\n    \\n            # Update the corner case of when s is an empty string but p is not.\\n            # Since each '*' can eliminate the charter before it, the table is\\n            # vertically updated by the one before previous. [test_symbol_0]\\n            for i in range(2, len(p) + 1):\\n                table[i][0] = table[i - 2][0] and p[i - 1] == '*'\\n    \\n            for i in range(1, len(p) + 1):\\n                for j in range(1, len(s) + 1):\\n                    if p[i - 1] != \"*\":\\n                        # Update the table by referring the diagonal element.\\n                        table[i][j] = table[i - 1][j - 1] and \\\\\\n                                      (p[i - 1] == s[j - 1] or p[i - 1] == '.')\\n                    else:\\n                        # Eliminations (referring to the vertical element)\\n                        # Either refer to the one before previous or the previous.\\n                        # I.e. * eliminate the previous or count the previous.\\n                        # [test_symbol_1]\\n                        table[i][j] = table[i - 2][j] or table[i - 1][j]\\n    \\n                        # Propagations (referring to the horizontal element)\\n                        # If p's previous one is equal to the current s, with\\n                        # helps of *, the status can be propagated from the left.\\n                        # [test_symbol_2]\\n                        if p[i - 2] == s[j - 1] or p[i - 2] == '.':\\n                            table[i][j] |= table[i][j - 1]\\n    \\n            return table[-1][-1]\\n    \\n    \\n    class TestSolution(unittest.TestCase):\\n        def test_none_0(self):\\n            s = \"\"\\n            p = \"\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n        def test_none_1(self):\\n            s = \"\"\\n            p = \"a\"\\n            self.assertFalse(Solution().isMatch(s, p))\\n    \\n        def test_no_symbol_equal(self):\\n            s = \"abcd\"\\n            p = \"abcd\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n        def test_no_symbol_not_equal_0(self):\\n            s = \"abcd\"\\n            p = \"efgh\"\\n            self.assertFalse(Solution().isMatch(s, p))\\n    \\n        def test_no_symbol_not_equal_1(self):\\n            s = \"ab\"\\n            p = \"abb\"\\n            self.assertFalse(Solution().isMatch(s, p))\\n    \\n        def test_symbol_0(self):\\n            s = \"\"\\n            p = \"a*\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n        def test_symbol_1(self):\\n            s = \"a\"\\n            p = \"ab*\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n        def test_symbol_2(self):\\n            # E.g.\\n            #   s a b b\\n            # p 1 0 0 0\\n            # a 0 1 0 0\\n            # b 0 0 1 0\\n            # * 0 1 1 1\\n            s = \"abb\"\\n            p = \"ab*\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n    \\n    if __name__ == \"__main__\":\\n        unittest.main()",
                "solutionTags": [],
                "code": "I shared my DP approach with comments and provided some unit tests for it. Some statements in the approach directly affect some corner cases, for example, comment out line 22-23, then the unittest `test_symbol_0` will fail. Hope this script helps us better understand the problem.\\n\\n    import unittest\\n    \\n    \\n    class Solution(object):\\n        def isMatch(self, s, p):\\n            # The DP table and the string s and p use the same indexes i and j, but\\n            # table[i][j] means the match status between p[:i] and s[:j], i.e.\\n            # table[0][0] means the match status of two empty strings, and\\n            # table[1][1] means the match status of p[0] and s[0]. Therefore, when\\n            # refering to the i-th and the j-th characters of p and s for updating\\n            # table[i][j], we use p[i - 1] and s[j - 1].\\n    \\n            # Initialize the table with False. The first row is satisfied.\\n            table = [[False] * (len(s) + 1) for _ in range(len(p) + 1)]\\n    \\n            # Update the corner case of matching two empty strings.\\n            table[0][0] = True\\n    \\n            # Update the corner case of when s is an empty string but p is not.\\n            # Since each '*' can eliminate the charter before it, the table is\\n            # vertically updated by the one before previous. [test_symbol_0]\\n            for i in range(2, len(p) + 1):\\n                table[i][0] = table[i - 2][0] and p[i - 1] == '*'\\n    \\n            for i in range(1, len(p) + 1):\\n                for j in range(1, len(s) + 1):\\n                    if p[i - 1] != \"*\":\\n                        # Update the table by referring the diagonal element.\\n                        table[i][j] = table[i - 1][j - 1] and \\\\\\n                                      (p[i - 1] == s[j - 1] or p[i - 1] == '.')\\n                    else:\\n                        # Eliminations (referring to the vertical element)\\n                        # Either refer to the one before previous or the previous.\\n                        # I.e. * eliminate the previous or count the previous.\\n                        # [test_symbol_1]\\n                        table[i][j] = table[i - 2][j] or table[i - 1][j]\\n    \\n                        # Propagations (referring to the horizontal element)\\n                        # If p's previous one is equal to the current s, with\\n                        # helps of *, the status can be propagated from the left.\\n                        # [test_symbol_2]\\n                        if p[i - 2] == s[j - 1] or p[i - 2] == '.':\\n                            table[i][j] |= table[i][j - 1]\\n    \\n            return table[-1][-1]\\n    \\n    \\n    class TestSolution(unittest.TestCase):\\n        def test_none_0(self):\\n            s = \"\"\\n            p = \"\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n        def test_none_1(self):\\n            s = \"\"\\n            p = \"a\"\\n            self.assertFalse(Solution().isMatch(s, p))\\n    \\n        def test_no_symbol_equal(self):\\n            s = \"abcd\"\\n            p = \"abcd\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n        def test_no_symbol_not_equal_0(self):\\n            s = \"abcd\"\\n            p = \"efgh\"\\n            self.assertFalse(Solution().isMatch(s, p))\\n    \\n        def test_no_symbol_not_equal_1(self):\\n            s = \"ab\"\\n            p = \"abb\"\\n            self.assertFalse(Solution().isMatch(s, p))\\n    \\n        def test_symbol_0(self):\\n            s = \"\"\\n            p = \"a*\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n        def test_symbol_1(self):\\n            s = \"a\"\\n            p = \"ab*\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n        def test_symbol_2(self):\\n            # E.g.\\n            #   s a b b\\n            # p 1 0 0 0\\n            # a 0 1 0 0\\n            # b 0 0 1 0\\n            # * 0 1 1 1\\n            s = \"abb\"\\n            p = \"ab*\"\\n            self.assertTrue(Solution().isMatch(s, p))\\n    \\n    \\n    if __name__ == \"__main__\":\\n        unittest.main()",
                "codeTag": "Java"
            },
            {
                "id": 3401751,
                "title": "detailed-explaination-with-pictures-in-c-java-python-dp-bottom-up-tabulation",
                "content": "# Approach\\n- Here the approach is very simple we basically must create a DP to store the states. For any DP problem all follow the same rule that we should memoize the truth value of $$(n,m)$$ then we need the values of $$(n-1 , m)$$ or $$(n ,m-1)$$ or $$(n-1 , m-1)$$ this would be the whole point of DP.\\n\\n\\n---\\n\\n\\n\\n![pic0.png](https://assets.leetcode.com/users/images/267087b4-5347-4ce1-832b-55364e51e470_1681152399.32624.png)\\n\\n>The example of mississippi is taken and the DP table is depicted below and the explaination is provided down.\\n\\n![pic1.png](https://assets.leetcode.com/users/images/691610d4-9872-4118-a2e1-98088037f172_1681152410.7458284.png)\\n\\n>Here we basically broke the entire one into three cases as shown in the below picture.Now we procced based on the below three cases and construct our DP table and thus we finally obtain our answer.\\n\\n![pic 2.png](https://assets.leetcode.com/users/images/7957e76b-6f3b-4922-8c7a-b399ceb2ce2c_1681152426.4691515.png)\\n\\n\\n---\\n\\n\\n\\n# Complexity\\n> - Time complexity: Here the complexity would be $$O(n^2)$$ as we need a 2D loop for keeping the track of length of both the strings.\\n\\n>- Space complexity: Here the space would also be $$O(n^2)$$ which can later be optimised to $$O(n)$$ by making space optimisation into two 1D arrays but we must do this to store the truth values of the lengths.\\n\\n\\n---\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.length(), m = p.length();\\n        bool dp[n+1][m+1];\\n        memset(dp, false, sizeof(dp));\\n        dp[0][0] = true;\\n        \\n        for(int i=0; i<=n; i++){\\n            for(int j=1; j<=m; j++){\\n                if(p[j-1] == \\'*\\'){\\n                    dp[i][j] = dp[i][j-2] || (i > 0 && (s[i-1] == p[j-2] || p[j-2] == \\'.\\') && dp[i-1][j]);\\n                }\\n                else{\\n                    dp[i][j] = i > 0 && dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == \\'.\\');\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n```\\n```java []\\nenum Result {\\n    TRUE, FALSE\\n}\\n\\nclass Solution {\\n    Result[][] memo;\\n\\n    public boolean isMatch(String text, String pattern) {\\n        memo = new Result[text.length() + 1][pattern.length() + 1];\\n        return dp(0, 0, text, pattern);\\n    }\\n\\n    public boolean dp(int i, int j, String text, String pattern) {\\n        if (memo[i][j] != null) {\\n            return memo[i][j] == Result.TRUE;\\n        }\\n        boolean ans;\\n        if (j == pattern.length()){\\n            ans = i == text.length();\\n        } else{\\n            boolean first_match = (i < text.length() &&\\n                                   (pattern.charAt(j) == text.charAt(i) ||\\n                                    pattern.charAt(j) == \\'.\\'));\\n\\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == \\'*\\'){\\n                ans = (dp(i, j+2, text, pattern) ||\\n                       first_match && dp(i+1, j, text, pattern));\\n            } else {\\n                ans = first_match && dp(i+1, j+1, text, pattern);\\n            }\\n        }\\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\\n        return ans;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        i, j = len(s) - 1, len(p) - 1\\n        return self.backtrack({}, s, p, i, j)\\n\\n    def backtrack(self, cache, s, p, i, j):\\n        key = (i, j)\\n        if key in cache:\\n            return cache[key]\\n\\n        if i == -1 and j == -1:\\n            cache[key] = True\\n            return True\\n\\n        if i != -1 and j == -1:\\n            cache[key] = False\\n            return cache[key]\\n\\n        if i == -1 and p[j] == \\'*\\':\\n            k = j\\n            while k != -1 and p[k] == \\'*\\':\\n                k -= 2\\n            \\n            if k == -1:\\n                cache[key] = True\\n                return cache[key]\\n            \\n            cache[key] = False\\n            return cache[key]\\n        \\n        if i == -1 and p[j] != \\'*\\':\\n            cache[key] = False\\n            return cache[key]\\n\\n        if p[j] == \\'*\\':\\n            if self.backtrack(cache, s, p, i, j - 2):\\n                cache[key] = True\\n                return cache[key]\\n            \\n            if p[j - 1] == s[i] or p[j - 1] == \\'.\\':\\n                if self.backtrack(cache, s, p, i - 1, j):\\n                    cache[key] = True\\n                    return cache[key]\\n        \\n        if p[j] == \\'.\\' or s[i] == p[j]:\\n            if self.backtrack(cache, s, p, i - 1, j - 1):\\n                cache[key] = True\\n                return cache[key]\\n\\n        cache[key] = False\\n        return cache[key]\\n```\\n\\n\\n---\\n\\n\\n\\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/9092568d-0cd5-46ad-9797-cac9d3b749f4_1681152758.70305.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.length(), m = p.length();\\n        bool dp[n+1][m+1];\\n        memset(dp, false, sizeof(dp));\\n        dp[0][0] = true;\\n        \\n        for(int i=0; i<=n; i++){\\n            for(int j=1; j<=m; j++){\\n                if(p[j-1] == \\'*\\'){\\n                    dp[i][j] = dp[i][j-2] || (i > 0 && (s[i-1] == p[j-2] || p[j-2] == \\'.\\') && dp[i-1][j]);\\n                }\\n                else{\\n                    dp[i][j] = i > 0 && dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == \\'.\\');\\n                }\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n```\n```java []\\nenum Result {\\n    TRUE, FALSE\\n}\\n\\nclass Solution {\\n    Result[][] memo;\\n\\n    public boolean isMatch(String text, String pattern) {\\n        memo = new Result[text.length() + 1][pattern.length() + 1];\\n        return dp(0, 0, text, pattern);\\n    }\\n\\n    public boolean dp(int i, int j, String text, String pattern) {\\n        if (memo[i][j] != null) {\\n            return memo[i][j] == Result.TRUE;\\n        }\\n        boolean ans;\\n        if (j == pattern.length()){\\n            ans = i == text.length();\\n        } else{\\n            boolean first_match = (i < text.length() &&\\n                                   (pattern.charAt(j) == text.charAt(i) ||\\n                                    pattern.charAt(j) == \\'.\\'));\\n\\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == \\'*\\'){\\n                ans = (dp(i, j+2, text, pattern) ||\\n                       first_match && dp(i+1, j, text, pattern));\\n            } else {\\n                ans = first_match && dp(i+1, j+1, text, pattern);\\n            }\\n        }\\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\\n        return ans;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        i, j = len(s) - 1, len(p) - 1\\n        return self.backtrack({}, s, p, i, j)\\n\\n    def backtrack(self, cache, s, p, i, j):\\n        key = (i, j)\\n        if key in cache:\\n            return cache[key]\\n\\n        if i == -1 and j == -1:\\n            cache[key] = True\\n            return True\\n\\n        if i != -1 and j == -1:\\n            cache[key] = False\\n            return cache[key]\\n\\n        if i == -1 and p[j] == \\'*\\':\\n            k = j\\n            while k != -1 and p[k] == \\'*\\':\\n                k -= 2\\n            \\n            if k == -1:\\n                cache[key] = True\\n                return cache[key]\\n            \\n            cache[key] = False\\n            return cache[key]\\n        \\n        if i == -1 and p[j] != \\'*\\':\\n            cache[key] = False\\n            return cache[key]\\n\\n        if p[j] == \\'*\\':\\n            if self.backtrack(cache, s, p, i, j - 2):\\n                cache[key] = True\\n                return cache[key]\\n            \\n            if p[j - 1] == s[i] or p[j - 1] == \\'.\\':\\n                if self.backtrack(cache, s, p, i - 1, j):\\n                    cache[key] = True\\n                    return cache[key]\\n        \\n        if p[j] == \\'.\\' or s[i] == p[j]:\\n            if self.backtrack(cache, s, p, i - 1, j - 1):\\n                cache[key] = True\\n                return cache[key]\\n\\n        cache[key] = False\\n        return cache[key]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5802,
                "title": "simple-java-recursive-solution-with-two-cases",
                "content": "There are two cases to consider:\\n\\nFirst, the second character of p is `*`, now p string can match any number of character before `*`.  `if(isMatch(s, p.substring(2))` means we can match the remaining s string, otherwise, we check if the first character matches or not.\\n\\nSecond, if the second character is not `*`, we need match character one by one.\\n\\n\\n\\n\\n    public boolean isMatch(String s, String p) {\\n        if (p.length() == 0) {\\n            return s.length() == 0;\\n        }\\n        if (p.length() > 1 && p.charAt(1) == '*') {  // second char is '*'\\n            if (isMatch(s, p.substring(2))) {\\n                return true;\\n            }\\n            if(s.length() > 0 && (p.charAt(0) == '.' || s.charAt(0) == p.charAt(0))) {\\n                return isMatch(s.substring(1), p);\\n            }\\n            return false;\\n        } else {                                     // second char is not '*'\\n            if(s.length() > 0 && (p.charAt(0) == '.' || s.charAt(0) == p.charAt(0))) {\\n                return isMatch(s.substring(1), p.substring(1));\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "There are two cases to consider:\\n\\nFirst, the second character of p is `*`, now p string can match any number of character before `*`.  `if(isMatch(s, p.substring(2))` means we can match the remaining s string, otherwise, we check if the first character matches or not.\\n\\nSecond, if the second character is not `*`, we need match character one by one.\\n\\n\\n\\n\\n    public boolean isMatch(String s, String p) {\\n        if (p.length() == 0) {\\n            return s.length() == 0;\\n        }\\n        if (p.length() > 1 && p.charAt(1) == '*') {  // second char is '*'\\n            if (isMatch(s, p.substring(2))) {\\n                return true;\\n            }\\n            if(s.length() > 0 && (p.charAt(0) == '.' || s.charAt(0) == p.charAt(0))) {\\n                return isMatch(s.substring(1), p);\\n            }\\n            return false;\\n        } else {                                     // second char is not '*'\\n            if(s.length() > 0 && (p.charAt(0) == '.' || s.charAt(0) == p.charAt(0))) {\\n                return isMatch(s.substring(1), p.substring(1));\\n            }\\n            return false;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 5659,
                "title": "the-shortest-ac-code",
                "content": "  1.'.' is easy to handle. if p has a '.', it can pass any single character in s except '\\\\0'.\\n\\n2.'*' is a totally different problem. if p has a '*' character, it can pass any length of first-match characters in s including '\\\\0'.\\n\\n\\n\\n      class Solution {\\n        public:\\n        bool matchFirst(const char *s, const char *p){\\n            return (*p == *s || (*p == '.' && *s != '\\\\0'));\\n        }\\n    \\n    bool isMatch(const char *s, const char *p) {\\n    \\tif (*p == '\\\\0') return *s == '\\\\0';\\t//empty\\n    \\n    \\tif (*(p + 1) != '*') {//without *\\n    \\t\\tif(!matchFirst(s,p)) return false;\\n    \\t\\treturn isMatch(s + 1, p + 1);\\n    \\t} else { //next: with a *\\n        \\tif(isMatch(s, p + 2)) return true;    //try the length of 0\\n    \\t\\twhile ( matchFirst(s,p) )       //try all possible lengths \\n    \\t\\t\\tif (isMatch(++s, p + 2))return true;\\n    \\t}\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        bool matchFirst(const char *s, const char *p){\\n            return (*p == *s || (*p == '.' && *s != '\\\\0'));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 280588,
                "title": "dp-solution-with-the-most-general-natural-explanation",
                "content": "**Data structure**\\n\\nCliche: DP 2D array, `boolean[][] M = new boolean[m + 1][n + 1];` where `M[i][j]` represents if the first `i` characters in `s` match the first `j` characters in `p`.\\n\\n---\\n**Strategy**\\n\\nInitialization: \\n1. `M[0][0] = true`, since empty string matches empty pattern\\t\\t\\n2. `M[i][0] = false`(which is default value of the boolean array) since empty pattern cannot match non-empty string\\n3. `M[0][j]`: what pattern matches empty string \"\"? It should be `#*#*#*#*...` \\nAs we can see, **the length of pattern should be even && the char at the odd position(1, 3, ...) should be \\\\*.**, we will do this check seperately.\\n\\n---\\nInduction rule(very similar to **edit distance**, which we also consider from the end position), 3 cases for the last character in the pattern: `[letter . *]`\\n1. If it is a letter, and it can match the last character in `s`, then the result depends on if the 1st `j - 1` characters in `p` can match 1st `i - 1` in `s`, i.e. `M[i][j] = M[i - 1][j - 1]` \\n\\tIf it is a letter, and it cannot match the last character in `s`, then `M[i][j] = false`; since it is the default value, we don\\'t need to do anything here\\n2. If it is a dot `.`, then it can definitely match the last character in `s`, so the result depends on if the 1st `j - 1` characters in `p` can match 1st `i - 1` in `s`, i.e. `M[i][j] = M[i - 1][j - 1]` \\n3. If it is a star `*` , then it can means **`0 time, or at least 1 time(>= 1)`**:\\n    3.1. If it means `0` time, then it does not match anything, then we are using the 1st `j - 2` characters in pattern `p` to match 1st `i` charcaters in `s`, so `M[i][j] = M[i][j - 2]`\\n\\t3.2. If it means at least `1` time, then `a*` can be treated like `a*a` where the last `a` is just a virtual/dummy character who will be responsible for matching the last character in `s`, so `M[i][j]` can be divided into 2 parts: \\n\\t1. The dummy character(the 2nd last character in `p`) matches last character in `s`, i.e. `p[j - 2] = s[i]` or `p[j - 2] = \\'.\\'`. For example:\\n\\t\\t\\\\###### a\\n\\t\\t###a* a\\n\\t2. The first `j` characters in `p` match the previous `i - 1` characters in `s`, i.e. `M[i - 1][j]`.\\n\\nFrom above, we can see that: `M[i][j]` depends on `M[i - 1][j - 1]`, `M[i][j - 2]`, `M[i - 1][j]`, i.e. get `M[i][j]`, we need to know previous elements in `M` which determines in our for loops, `i` goes from `1` to `m - 1`, `j` goes from `1` to `n + 1`\\n\\n---\\n**Final code**\\n\\n```java\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        // corner case\\n        if(s == null || p == null) return false;\\n\\n        int m = s.length();\\n        int n = p.length();\\n        \\n        // M[i][j] represents if the 1st i characters in s can match the 1st j characters in p\\n        boolean[][] M = new boolean[m + 1][n + 1];\\n\\n        // initialization: \\n\\t\\t// 1. M[0][0] = true, since empty string matches empty pattern\\n\\t\\tM[0][0] = true;\\n\\t\\t\\n\\t\\t// 2. M[i][0] = false(which is default value of the boolean array) since empty pattern cannot match non-empty string\\n\\t\\t// 3. M[0][j]: what pattern matches empty string \"\"? It should be #*#*#*#*..., or (#*)* if allow me to represent regex using regex :P, \\n\\t\\t// and for this case we need to check manually: \\n        // as we can see, the length of pattern should be even && the character at the even position should be *, \\n\\t\\t// thus for odd length, M[0][j] = false which is default. So we can just skip the odd position, i.e. j starts from 2, the interval of j is also 2. \\n\\t\\t// and notice that the length of repeat sub-pattern #* is only 2, we can just make use of M[0][j - 2] rather than scanning j length each time \\n\\t\\t// for checking if it matches #*#*#*#*.\\n        for(int j = 2; j < n + 1; j +=2){\\n            if(p.charAt(j - 1) == \\'*\\' && M[0][j - 2]){\\n                M[0][j] = true;\\n            }\\n        }\\n        \\n\\t\\t// Induction rule is very similar to edit distance, where we also consider from the end. And it is based on what character in the pattern we meet.\\n        // 1. if p.charAt(j) == s.charAt(i), M[i][j] = M[i - 1][j - 1]\\n\\t\\t//    ######a(i)\\n\\t\\t//    ####a(j)\\n        // 2. if p.charAt(j) == \\'.\\', M[i][j] = M[i - 1][j - 1]\\n        // \\t  #######a(i)\\n        //    ####.(j)\\n        // 3. if p.charAt(j) == \\'*\\':\\n        //    1. if p.charAt(j - 1) != \\'.\\' && p.charAt(j - 1) != s.charAt(i), then b* is counted as empty. M[i][j] = M[i][j - 2]\\n        //       #####a(i)\\n        //       ####b*(j)\\n        //    2.if p.charAt(j - 1) == \\'.\\' || p.charAt(j - 1) == s.charAt(i):\\n        //       ######a(i)\\n        //       ####.*(j)\\n\\t\\t//\\n\\t\\t// \\t  \\t #####a(i)\\n        //    \\t ###a*(j)\\n        //      2.1 if p.charAt(j - 1) is counted as empty, then M[i][j] = M[i][j - 2]\\n        //      2.2 if counted as one or multiple, then the pattern can be expanded with one more a*: \"####xa*a*\", then M[i][j] = M[i - 1][j]\\n\\t\\t// \\t  \\t #####a(i)\\n        //    \\t ###a*a*(j)\\n                \\n\\t\\t// recap:\\n\\t\\t// M[i][j] = M[i - 1][j - 1]\\n\\t\\t// M[i][j] = M[i - 1][j - 1]\\n\\t\\t// M[i][j] = M[i][j - 2]\\n\\t\\t// M[i][j] = M[i][j - 2]\\n        // M[i][j] = M[i - 1][j - 2]\\n        // M[i][j] = M[i - 1][j]\\n\\t\\t// Observation: from above, we can see to get M[i][j], we need to know previous elements in M, i.e. we need to compute them first. \\n\\t\\t// which determines i goes from 1 to m - 1, j goes from 1 to n + 1\\n\\t\\t\\n        for(int i = 1; i < m + 1; i++){\\n            for(int j = 1; j < n + 1; j++){\\n                char curS = s.charAt(i - 1);\\n                char curP = p.charAt(j - 1);\\n                if(curS == curP || curP == \\'.\\'){\\n                    M[i][j] = M[i - 1][j - 1];\\n                }else if(curP == \\'*\\'){\\n                    char preCurP = p.charAt(j - 2);\\n                    if(preCurP != \\'.\\' && preCurP != curS){\\n                        M[i][j] = M[i][j - 2];\\n                    }else{\\n                        M[i][j] = M[i][j - 2] || M[i - 1][j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return M[m][n];\\n    }\\n}\\n```\\n\\n---\\nTime complexity: `O(m*n)`\\nSpace complexity: `O(m*n)`\\n\\n---\\n**One more thing**\\n\\nIf you have any confusion or any opinion on the description, please comment, I will insist on updating it for **at least 100 years**.",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        // corner case\\n        if(s == null || p == null) return false;\\n\\n        int m = s.length();\\n        int n = p.length();\\n        \\n        // M[i][j] represents if the 1st i characters in s can match the 1st j characters in p\\n        boolean[][] M = new boolean[m + 1][n + 1];\\n\\n        // initialization: \\n\\t\\t// 1. M[0][0] = true, since empty string matches empty pattern\\n\\t\\tM[0][0] = true;\\n\\t\\t\\n\\t\\t// 2. M[i][0] = false(which is default value of the boolean array) since empty pattern cannot match non-empty string\\n\\t\\t// 3. M[0][j]: what pattern matches empty string \"\"? It should be #*#*#*#*..., or (#*)* if allow me to represent regex using regex :P, \\n\\t\\t// and for this case we need to check manually: \\n        // as we can see, the length of pattern should be even && the character at the even position should be *, \\n\\t\\t// thus for odd length, M[0][j] = false which is default. So we can just skip the odd position, i.e. j starts from 2, the interval of j is also 2. \\n\\t\\t// and notice that the length of repeat sub-pattern #* is only 2, we can just make use of M[0][j - 2] rather than scanning j length each time \\n\\t\\t// for checking if it matches #*#*#*#*.\\n        for(int j = 2; j < n + 1; j +=2){\\n            if(p.charAt(j - 1) == \\'*\\' && M[0][j - 2]){\\n                M[0][j] = true;\\n            }\\n        }\\n        \\n\\t\\t// Induction rule is very similar to edit distance, where we also consider from the end. And it is based on what character in the pattern we meet.\\n        // 1. if p.charAt(j) == s.charAt(i), M[i][j] = M[i - 1][j - 1]\\n\\t\\t//    ######a(i)\\n\\t\\t//    ####a(j)\\n        // 2. if p.charAt(j) == \\'.\\', M[i][j] = M[i - 1][j - 1]\\n        // \\t  #######a(i)\\n        //    ####.(j)\\n        // 3. if p.charAt(j) == \\'*\\':\\n        //    1. if p.charAt(j - 1) != \\'.\\' && p.charAt(j - 1) != s.charAt(i), then b* is counted as empty. M[i][j] = M[i][j - 2]\\n        //       #####a(i)\\n        //       ####b*(j)\\n        //    2.if p.charAt(j - 1) == \\'.\\' || p.charAt(j - 1) == s.charAt(i):\\n        //       ######a(i)\\n        //       ####.*(j)\\n\\t\\t//\\n\\t\\t// \\t  \\t #####a(i)\\n        //    \\t ###a*(j)\\n        //      2.1 if p.charAt(j - 1) is counted as empty, then M[i][j] = M[i][j - 2]\\n        //      2.2 if counted as one or multiple, then the pattern can be expanded with one more a*: \"####xa*a*\", then M[i][j] = M[i - 1][j]\\n\\t\\t// \\t  \\t #####a(i)\\n        //    \\t ###a*a*(j)\\n                \\n\\t\\t// recap:\\n\\t\\t// M[i][j] = M[i - 1][j - 1]\\n\\t\\t// M[i][j] = M[i - 1][j - 1]\\n\\t\\t// M[i][j] = M[i][j - 2]\\n\\t\\t// M[i][j] = M[i][j - 2]\\n        // M[i][j] = M[i - 1][j - 2]\\n        // M[i][j] = M[i - 1][j]\\n\\t\\t// Observation: from above, we can see to get M[i][j], we need to know previous elements in M, i.e. we need to compute them first. \\n\\t\\t// which determines i goes from 1 to m - 1, j goes from 1 to n + 1\\n\\t\\t\\n        for(int i = 1; i < m + 1; i++){\\n            for(int j = 1; j < n + 1; j++){\\n                char curS = s.charAt(i - 1);\\n                char curP = p.charAt(j - 1);\\n                if(curS == curP || curP == \\'.\\'){\\n                    M[i][j] = M[i - 1][j - 1];\\n                }else if(curP == \\'*\\'){\\n                    char preCurP = p.charAt(j - 2);\\n                    if(preCurP != \\'.\\' && preCurP != curS){\\n                        M[i][j] = M[i][j - 2];\\n                    }else{\\n                        M[i][j] = M[i][j - 2] || M[i - 1][j];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return M[m][n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883719,
                "title": "python-top-down-dp-clean-concise-o-m-n",
                "content": "**Idea**\\n- Firstly, we brute force by trying all possile options.\\n- Then we cache the result to prevent to re-compute sub-problems again.\\n```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if j == len(p):  # If `j` reach end of pattern `p`\\n                return i == len(s)  # Then it fully matches if and only if `i` reach end of string `s`\\n\\t\\t\\t\\t\\n            if j+1 < len(p) and p[j+1] == \\'*\\':\\n                ans = dp(i, j+2) # match zero chars\\n                if i < len(s) and (s[i] == p[j] or p[j] == \\'.\\'):\\n                    ans = ans or dp(i+1, j) # match 1 char, skip 1 char in s, don\\'t skip in p since it can march one or match more characters\\n                return ans\\n            if p[j] == \\'.\\' or i < len(s) and s[i] == p[j]:\\n                return dp(i+1, j+1) # match 1 char, skip 1 char in both s and p\\n            return False\\n        \\n        return dp(0, 0)\\n```\\n**Complexity**\\n- Time: `O(M*N)`, where `M <= 20` is length of string `s`, `N <= 30` is length of string `p`.\\n- Space: `O(M*N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        @lru_cache(None)\\n        def dp(i, j):\\n            if j == len(p):  # If `j` reach end of pattern `p`\\n                return i == len(s)  # Then it fully matches if and only if `i` reach end of string `s`\\n\\t\\t\\t\\t\\n            if j+1 < len(p) and p[j+1] == \\'*\\':\\n                ans = dp(i, j+2) # match zero chars\\n                if i < len(s) and (s[i] == p[j] or p[j] == \\'.\\'):\\n                    ans = ans or dp(i+1, j) # match 1 char, skip 1 char in s, don\\'t skip in p since it can march one or match more characters\\n                return ans\\n            if p[j] == \\'.\\' or i < len(s) and s[i] == p[j]:\\n                return dp(i+1, j+1) # match 1 char, skip 1 char in both s and p\\n            return False\\n        \\n        return dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5678,
                "title": "fast-python-solution-with-backtracking-and-caching-dp-solution",
                "content": "Takes about 174ms:\\n\\n     \\n    cache = {}\\n    def isMatch(self, s, p):\\n        if (s, p) in self.cache:\\n            return self.cache[(s, p)]\\n        if not p:\\n            return not s\\n        if p[-1] == '*':\\n            if self.isMatch(s, p[:-2]):\\n                self.cache[(s, p)] = True\\n                return True\\n            if s and (s[-1] == p[-2] or p[-2] == '.') and self.isMatch(s[:-1], p):\\n                self.cache[(s, p)] = True\\n                return True\\n        if s and (p[-1] == s[-1] or p[-1] == '.') and self.isMatch(s[:-1], p[:-1]):\\n            self.cache[(s, p)] = True\\n            return True\\n        self.cache[(s, p)] = False\\n        return False\\n\\n\\nDP version:\\n    \\n    def isMatch(self, s, p):\\n        dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)]\\n        dp[0][0] = True\\n        for i in range(1, len(p)):\\n            dp[i + 1][0] = dp[i - 1][0] and p[i] == '*'\\n        for i in range(len(p)):\\n            for j in range(len(s)):\\n                if p[i] == '*':\\n                    dp[i + 1][j + 1] = dp[i - 1][j + 1] or dp[i][j + 1]\\n                    if p[i - 1] == s[j] or p[i - 1] == '.':\\n                        dp[i + 1][j + 1] |= dp[i + 1][j]\\n                else:\\n                    dp[i + 1][j + 1] = dp[i][j] and (p[i] == s[j] or p[i] == '.')\\n        return dp[-1][-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "Takes about 174ms:\\n\\n     \\n    cache = {}\\n    def isMatch(self, s, p):\\n        if (s, p) in self.cache:\\n            return self.cache[(s, p)]\\n        if not p:\\n            return not s\\n        if p[-1] == '*':\\n            if self.isMatch(s, p[:-2]):\\n                self.cache[(s, p)] = True\\n                return True\\n            if s and (s[-1] == p[-2] or p[-2] == '.') and self.isMatch(s[:-1], p):\\n                self.cache[(s, p)] = True\\n                return True\\n        if s and (p[-1] == s[-1] or p[-1] == '.') and self.isMatch(s[:-1], p[:-1]):\\n            self.cache[(s, p)] = True\\n            return True\\n        self.cache[(s, p)] = False\\n        return False\\n\\n\\nDP version:\\n    \\n    def isMatch(self, s, p):\\n        dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)]\\n        dp[0][0] = True\\n        for i in range(1, len(p)):\\n            dp[i + 1][0] = dp[i - 1][0] and p[i] == '*'\\n        for i in range(len(p)):\\n            for j in range(len(s)):\\n                if p[i] == '*':\\n                    dp[i + 1][j + 1] = dp[i - 1][j + 1] or dp[i][j + 1]\\n                    if p[i - 1] == s[j] or p[i - 1] == '.':\\n                        dp[i + 1][j + 1] |= dp[i + 1][j]\\n                else:\\n                    dp[i + 1][j + 1] = dp[i][j] and (p[i] == s[j] or p[i] == '.')\\n        return dp[-1][-1]",
                "codeTag": "Python3"
            },
            {
                "id": 413571,
                "title": "python-60ms-human-readable-dp-solution",
                "content": "```\\n    def isMatch(self, s: str, p: str) -> bool:\\n        s, p = \\' \\'+ s, \\' \\'+ p\\n        lenS, lenP = len(s), len(p)\\n        dp = [[0]*(lenP) for i in range(lenS)]\\n        dp[0][0] = 1\\n\\n        for j in range(1, lenP):\\n            if p[j] == \\'*\\':\\n                dp[0][j] = dp[0][j-2]\\n\\n        for i in range(1, lenS):\\n            for j in range(1, lenP):\\n                if p[j] in {s[i], \\'.\\'}:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j] == \"*\":\\n                    dp[i][j] = dp[i][j-2] or int(dp[i-1][j] and p[j-1] in {s[i], \\'.\\'})\\n\\n        return bool(dp[-1][-1])\\n```\\nRuntime: 56 ms, faster than 70.79% of Python3 online submissions for Regular Expression Matching.\\nMemory Usage: 13.9 MB, less than 5.55% of Python3 online submissions for Regular Expression Matching.\\n\\nSee the [explanation of the idea](https://www.youtube.com/watch?v=l3hda49XcDE)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def isMatch(self, s: str, p: str) -> bool:\\n        s, p = \\' \\'+ s, \\' \\'+ p\\n        lenS, lenP = len(s), len(p)\\n        dp = [[0]*(lenP) for i in range(lenS)]\\n        dp[0][0] = 1\\n\\n        for j in range(1, lenP):\\n            if p[j] == \\'*\\':\\n                dp[0][j] = dp[0][j-2]\\n\\n        for i in range(1, lenS):\\n            for j in range(1, lenP):\\n                if p[j] in {s[i], \\'.\\'}:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j] == \"*\":\\n                    dp[i][j] = dp[i][j-2] or int(dp[i-1][j] and p[j-1] in {s[i], \\'.\\'})\\n\\n        return bool(dp[-1][-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 161365,
                "title": "java-solution-with-more-detailed-explanation",
                "content": "I will use this post as a more detailed explanation of my solution.\\n\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        /*\\n            dp[i][j] = whether the first i-character sequence in s matches the first j-character sequence in p\\n            we set dp[0][0] = true, because the first 0 character in s always matches the first 0 character in p\\n            \\n            For better readability, I will make this notation:\\n            s[i] means the i-th character in string s.\\n            For example, s = \"abc\", s[1] = \\'a\\', s[2] = \\'b\\', s[3] = \\'c\\'\\n            \\n            The above notation will give us a consistent view of the relationship between dp[i][j], s[i] and p[j].\\n            For example, if we have s = \"ab\", p = \"ac\", we will get:\\n            dp[0][0] = true (default base case); \\n            dp[1][0] = false (because s[1...1] = \"a\" and p[0] does not exist based on our notation);\\n            dp[1][1] = true (because s[1...1] = \"a\" and p[1...1] = \"a\", they match);\\n            dp[2][0] = false (because s[1...2] = \"ab\" and p[0] does not exist);\\n            dp[2][1] = false (because s[1...2] = \"ab\" and p[1...1] = \"a\", they don\\'t match);\\n            dp[2][2] = false (because s[1...2] = \"ab\" and p[1...2] = \"ac\", they don\\'t match);\\n            As a result, dp[s.length()][p.length()] = dp[2][2] = false.\\n            We will return false, meaning that s does not match p.\\n            \\n            With the above notation, we have:\\n            If we are currently at s[i] and p[j]:\\n            1. if (p[j] == s[i])\\n                    - The i-th character in s matches the j-th character in p, so dp[i][j] now depends on dp[i-1][j-1]\\n                    - Therefore we have dp[i][j] = dp[i-1][j-1]\\n            2. if (p[j] == \\'.\\')\\n                    - The j-th character in p is \\'.\\', meaning that it can represent any single character, it is the same as 1\\n                    - Therefore we have dp[i][j] = dp[i-1][j-1]\\n            3. if (p[j] == \\'*\\')\\n                    - The j-th character in p is \\'*\\', meaning that the character of p[j-1] can be repeated multiple times or can be not exising\\n                    - Now we will need to check p[j-1]:\\n                            3.1 -  if (p[j-1] != s[i] AND p[j-1] != \\'.\\')\\n                                    - In this case, the only possible scenario that s[1...i] matches p[1...j] is that s[1...i] matches p[1...j-2]\\n                                    - For example, when i = 2 and j = 4, p[1...4] = \"abc*\", s[1...2] = \"ab\":\\n                                            - p[4] = \\'*\\', p[4-1] = p[3] = \\'c\\' while s[2] = \\'b\\', so p[3] != s[2] and p[3] != \\'.\\'\\n                                            - But since s[1...2] matches p[1...2], s[1...2] still matches p[1...4] in this case\\n                                    - Therefore we have dp[i][j] = dp[i][j-2]\\n                            3.2 - if (p[j-1] == s[i] OR p[j-1] == \\'.\\')\\n                                    3.2.1 - if (s[1...i] does not match p[1...j-2])\\n                                    - In this case, we know that the character s[i] needs to match the character p[j-1]. Thus as long as s[1...i-1] matches p[1...j], we will have s[1....i] matches p[1...j]\\n                                    - For example, when i = 3 and j = 4, p[1...4] = \"abc*\", s[1...3] = \"abc\":\\n                                            - s[1...2] matches p[1...4] because of 3.1: since we have \"c*\", we can treat p = \"abc*\" as equivalent to p = \"ab\" when matching \"ab\", because c* means c can be repeating or not existing\\n                                            - since s[3] = \\'c\\' which is the same as p[3], it matches at s[3]\\n                                    - Another example, when i = 4 and j = 4, p[1...4] = \"abc*\", s[1...4] = \"abcc\"\\n                                            - From previous example, we know that dp[3][4] is true. So since we have \"c*\", c can repeat multiple times. Therefore as long as s[4] = \\'c\\' = p[4-1], we know that dp[4][4] = dp[3][4] = true\\n                                    - Therefore we have dp[i][j] = dp[i-1][j]\\n                                    - I noticed that some other solutions also include dp[i][j-1] as a condition where s[i] only appears once, but I think it is redundant here because dp[i-1][j] can be applied to both one appearance and multiple appearances. But if we have another quantifier like \"?\" which only allows one appearance, we should include dp[i][j-1].\\n                                    3.2.2 - if (s[1...i] does match p[1...j-2])\\n                                    - In this case, we actually don\\'t really need to care about p[j-1...j] because the previous sequence matches, and we can now treat p[j-1...j] as matching nothing.\\n                                    - Therefore we have dp[i][j] = dp[i][j-2]\\n        \\n        \\n        To construct the boolean[][] dp array, we also need an initialization on \"nothing in s\" (s[0]) matching p[1...j]:\\n        1. dp[0][0] = true\\n        2. dp[0][i] = true if p[i+1] == \\'*\\' AND dp[0][i-2] == true, otherwise false\\n            For example: \\n            p = \"a*b*\"\\n            dp[0][0] = true;\\n            dp[0][1] = false (because s[0] does not exist while p[1...1] = \"a\");\\n            dp[0][2] = true (because s[0] does not exist, but p[1...2] = \"a*\" meaning that a can be repeating or not existing);\\n            dp[0][3] = false (because s[0] does not exist while p[1...3] = \"a*b\");\\n            dp[0][4] = true (because s[0] does not exist while p[1...4] = \"a*b*\", b can be not existing, and dp[0][2] is true meaning that we already have a match for anything before p[3...4]);\\n        */\\n        \\n        if (s == null || p == null) {\\n            return false;\\n        }\\n        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; // by default every element is false\\n        dp[0][0] = true;\\n        char[] string = new char[s.length() + 1];\\n        char[] pattern = new char[p.length() + 1];\\n        // we don\\'t care about what character is on index 0. It is a way to make our view of index in dp[][] and string[] and pattern[] consistent. Our process starts at index==1 for string and pattern.\\n        string[0] = (char) 0;\\n        pattern[0] = (char) 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            string[i+1] = s.charAt(i);\\n        }\\n        for (int i = 0; i < p.length(); ++i) {\\n            pattern[i+1] = p.charAt(i);\\n        }\\n\\n        dp[0][0] = true;\\n        // initialization of dp, for base cases\\n        for (int i = 1; i < pattern.length; ++i) {\\n            // here we assume that pattern[1] (i.e. p.charAt(0)) will never be \\'*\\' based on the description of the problem which states that \\'*\\' matches zero or more of the preceding element, so it must have a preceding element otherwise it is not a valid input.\\n            if (pattern[i] == \\'*\\' && dp[0][i-2]) {\\n                dp[0][i] = true;\\n            }\\n        }\\n        \\n        for (int i = 1; i < string.length; ++i) {\\n            for (int j = 1; j < pattern.length; ++j) {\\n                if (pattern[j] == string[i] || pattern[j] == \\'.\\') {\\n                    // scenario 1 and 2: current character matches, we just need to know if previous sequence matches or not\\n                    dp[i][j] = dp[i-1][j-1]; \\n                } else if (pattern[j] == \\'*\\') {\\n                    if (pattern[j-1] != string[i] && pattern[j-1] != \\'.\\') {\\n                        // scenario 3.1: we should treat pattern[j-1...j] as matching nothing in string, it is valid because pattern[j] == \\'*\\', therefore we want to know if string[1...i] matches pattern[1...j-2]\\n                        dp[i][j] = dp[i][j-2];\\n                    } else {\\n                        // scenario 3.2.1 and 3.2.2: since pattern won\\'t change, we just need to make sure one of 3.2.1 and 3.2.2 is true for dp is true: either pattern[j-1...j] matches string[i], or pattern[j-1...j] matches nothing in string\\n                        // if pattern[j-1] matches string[i], we just need to know if string[i-1] matches pattern[j]: abc* matches abc and abcc, if we want to know if abc matches abc*, we just need to know if ab matches abc*; if we want to know if abcc matches abc*, we just need to know if abc matches abc*\\n                        // if pattern[j-1] matches nothing in string, it is scenario 3.1\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-2];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        /*\\n            dp[i][j] = whether the first i-character sequence in s matches the first j-character sequence in p\\n            we set dp[0][0] = true, because the first 0 character in s always matches the first 0 character in p\\n            \\n            For better readability, I will make this notation:\\n            s[i] means the i-th character in string s.\\n            For example, s = \"abc\", s[1] = \\'a\\', s[2] = \\'b\\', s[3] = \\'c\\'\\n            \\n            The above notation will give us a consistent view of the relationship between dp[i][j], s[i] and p[j].\\n            For example, if we have s = \"ab\", p = \"ac\", we will get:\\n            dp[0][0] = true (default base case); \\n            dp[1][0] = false (because s[1...1] = \"a\" and p[0] does not exist based on our notation);\\n            dp[1][1] = true (because s[1...1] = \"a\" and p[1...1] = \"a\", they match);\\n            dp[2][0] = false (because s[1...2] = \"ab\" and p[0] does not exist);\\n            dp[2][1] = false (because s[1...2] = \"ab\" and p[1...1] = \"a\", they don\\'t match);\\n            dp[2][2] = false (because s[1...2] = \"ab\" and p[1...2] = \"ac\", they don\\'t match);\\n            As a result, dp[s.length()][p.length()] = dp[2][2] = false.\\n            We will return false, meaning that s does not match p.\\n            \\n            With the above notation, we have:\\n            If we are currently at s[i] and p[j]:\\n            1. if (p[j] == s[i])\\n                    - The i-th character in s matches the j-th character in p, so dp[i][j] now depends on dp[i-1][j-1]\\n                    - Therefore we have dp[i][j] = dp[i-1][j-1]\\n            2. if (p[j] == \\'.\\')\\n                    - The j-th character in p is \\'.\\', meaning that it can represent any single character, it is the same as 1\\n                    - Therefore we have dp[i][j] = dp[i-1][j-1]\\n            3. if (p[j] == \\'*\\')\\n                    - The j-th character in p is \\'*\\', meaning that the character of p[j-1] can be repeated multiple times or can be not exising\\n                    - Now we will need to check p[j-1]:\\n                            3.1 -  if (p[j-1] != s[i] AND p[j-1] != \\'.\\')\\n                                    - In this case, the only possible scenario that s[1...i] matches p[1...j] is that s[1...i] matches p[1...j-2]\\n                                    - For example, when i = 2 and j = 4, p[1...4] = \"abc*\", s[1...2] = \"ab\":\\n                                            - p[4] = \\'*\\', p[4-1] = p[3] = \\'c\\' while s[2] = \\'b\\', so p[3] != s[2] and p[3] != \\'.\\'\\n                                            - But since s[1...2] matches p[1...2], s[1...2] still matches p[1...4] in this case\\n                                    - Therefore we have dp[i][j] = dp[i][j-2]\\n                            3.2 - if (p[j-1] == s[i] OR p[j-1] == \\'.\\')\\n                                    3.2.1 - if (s[1...i] does not match p[1...j-2])\\n                                    - In this case, we know that the character s[i] needs to match the character p[j-1]. Thus as long as s[1...i-1] matches p[1...j], we will have s[1....i] matches p[1...j]\\n                                    - For example, when i = 3 and j = 4, p[1...4] = \"abc*\", s[1...3] = \"abc\":\\n                                            - s[1...2] matches p[1...4] because of 3.1: since we have \"c*\", we can treat p = \"abc*\" as equivalent to p = \"ab\" when matching \"ab\", because c* means c can be repeating or not existing\\n                                            - since s[3] = \\'c\\' which is the same as p[3], it matches at s[3]\\n                                    - Another example, when i = 4 and j = 4, p[1...4] = \"abc*\", s[1...4] = \"abcc\"\\n                                            - From previous example, we know that dp[3][4] is true. So since we have \"c*\", c can repeat multiple times. Therefore as long as s[4] = \\'c\\' = p[4-1], we know that dp[4][4] = dp[3][4] = true\\n                                    - Therefore we have dp[i][j] = dp[i-1][j]\\n                                    - I noticed that some other solutions also include dp[i][j-1] as a condition where s[i] only appears once, but I think it is redundant here because dp[i-1][j] can be applied to both one appearance and multiple appearances. But if we have another quantifier like \"?\" which only allows one appearance, we should include dp[i][j-1].\\n                                    3.2.2 - if (s[1...i] does match p[1...j-2])\\n                                    - In this case, we actually don\\'t really need to care about p[j-1...j] because the previous sequence matches, and we can now treat p[j-1...j] as matching nothing.\\n                                    - Therefore we have dp[i][j] = dp[i][j-2]\\n        \\n        \\n        To construct the boolean[][] dp array, we also need an initialization on \"nothing in s\" (s[0]) matching p[1...j]:\\n        1. dp[0][0] = true\\n        2. dp[0][i] = true if p[i+1] == \\'*\\' AND dp[0][i-2] == true, otherwise false\\n            For example: \\n            p = \"a*b*\"\\n            dp[0][0] = true;\\n            dp[0][1] = false (because s[0] does not exist while p[1...1] = \"a\");\\n            dp[0][2] = true (because s[0] does not exist, but p[1...2] = \"a*\" meaning that a can be repeating or not existing);\\n            dp[0][3] = false (because s[0] does not exist while p[1...3] = \"a*b\");\\n            dp[0][4] = true (because s[0] does not exist while p[1...4] = \"a*b*\", b can be not existing, and dp[0][2] is true meaning that we already have a match for anything before p[3...4]);\\n        */\\n        \\n        if (s == null || p == null) {\\n            return false;\\n        }\\n        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; // by default every element is false\\n        dp[0][0] = true;\\n        char[] string = new char[s.length() + 1];\\n        char[] pattern = new char[p.length() + 1];\\n        // we don\\'t care about what character is on index 0. It is a way to make our view of index in dp[][] and string[] and pattern[] consistent. Our process starts at index==1 for string and pattern.\\n        string[0] = (char) 0;\\n        pattern[0] = (char) 0;\\n        for (int i = 0; i < s.length(); ++i) {\\n            string[i+1] = s.charAt(i);\\n        }\\n        for (int i = 0; i < p.length(); ++i) {\\n            pattern[i+1] = p.charAt(i);\\n        }\\n\\n        dp[0][0] = true;\\n        // initialization of dp, for base cases\\n        for (int i = 1; i < pattern.length; ++i) {\\n            // here we assume that pattern[1] (i.e. p.charAt(0)) will never be \\'*\\' based on the description of the problem which states that \\'*\\' matches zero or more of the preceding element, so it must have a preceding element otherwise it is not a valid input.\\n            if (pattern[i] == \\'*\\' && dp[0][i-2]) {\\n                dp[0][i] = true;\\n            }\\n        }\\n        \\n        for (int i = 1; i < string.length; ++i) {\\n            for (int j = 1; j < pattern.length; ++j) {\\n                if (pattern[j] == string[i] || pattern[j] == \\'.\\') {\\n                    // scenario 1 and 2: current character matches, we just need to know if previous sequence matches or not\\n                    dp[i][j] = dp[i-1][j-1]; \\n                } else if (pattern[j] == \\'*\\') {\\n                    if (pattern[j-1] != string[i] && pattern[j-1] != \\'.\\') {\\n                        // scenario 3.1: we should treat pattern[j-1...j] as matching nothing in string, it is valid because pattern[j] == \\'*\\', therefore we want to know if string[1...i] matches pattern[1...j-2]\\n                        dp[i][j] = dp[i][j-2];\\n                    } else {\\n                        // scenario 3.2.1 and 3.2.2: since pattern won\\'t change, we just need to make sure one of 3.2.1 and 3.2.2 is true for dp is true: either pattern[j-1...j] matches string[i], or pattern[j-1...j] matches nothing in string\\n                        // if pattern[j-1] matches string[i], we just need to know if string[i-1] matches pattern[j]: abc* matches abc and abcc, if we want to know if abc matches abc*, we just need to know if ab matches abc*; if we want to know if abcc matches abc*, we just need to know if abc matches abc*\\n                        // if pattern[j-1] matches nothing in string, it is scenario 3.1\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-2];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192023,
                "title": "6-lines-in-python",
                "content": "Shortest version of Python solution:\\n```\\ndef isMatch(self, s, p):\\n    if not p: return not s\\n    if not s: return len(p) > 1 and p[1] == \\'*\\' and self.isMatch(s, p[2:])\\n    Matched = (p[0] == \\'.\\' or p[0] == s[0])\\n    if len(p) > 1 and p[1] == \\'*\\':\\n        return (Matched and self.isMatch(s[1:], p)) or self.isMatch(s, p[2:])\\n    return Matched and self.isMatch(s[1:], p[1:])\\n```\\n\\nThe above solutions get AC but slow to run, mainly because repetitive computing and string copy, here\\'s the fast version that beats 96%\\n```\\ndef isMatch(self, s, p):\\n    memo = {}\\n    def dp(si, pi):\\n        if pi >= len(p): return si == len(s)\\n        if si >= len(s): return pi + 1 < len(p) and p[pi + 1] == \\'*\\' and dp(si, pi + 2)\\n        if (si, pi) not in memo:\\n            matched = p[pi] == \\'.\\' or p[pi] == s[si]\\n            if pi + 1 < len(p) and p[pi + 1] == \\'*\\':\\n                memo[(si, pi)] = dp(si, pi + 2) or (matched and dp(si + 1, pi))\\n            else:\\n                memo[(si, pi)] = matched and dp(si + 1, pi + 1)\\n        return memo[(si, pi)]\\n    return dp(0, 0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef isMatch(self, s, p):\\n    if not p: return not s\\n    if not s: return len(p) > 1 and p[1] == \\'*\\' and self.isMatch(s, p[2:])\\n    Matched = (p[0] == \\'.\\' or p[0] == s[0])\\n    if len(p) > 1 and p[1] == \\'*\\':\\n        return (Matched and self.isMatch(s[1:], p)) or self.isMatch(s, p[2:])\\n    return Matched and self.isMatch(s[1:], p[1:])\\n```\n```\\ndef isMatch(self, s, p):\\n    memo = {}\\n    def dp(si, pi):\\n        if pi >= len(p): return si == len(s)\\n        if si >= len(s): return pi + 1 < len(p) and p[pi + 1] == \\'*\\' and dp(si, pi + 2)\\n        if (si, pi) not in memo:\\n            matched = p[pi] == \\'.\\' or p[pi] == s[si]\\n            if pi + 1 < len(p) and p[pi + 1] == \\'*\\':\\n                memo[(si, pi)] = dp(si, pi + 2) or (matched and dp(si + 1, pi))\\n            else:\\n                memo[(si, pi)] = matched and dp(si + 1, pi + 1)\\n        return memo[(si, pi)]\\n    return dp(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 751381,
                "title": "brute-force-to-top-down-dp-and-bottom-up-dp-with-explanation",
                "content": "We can solve the problem using recursion. We need the helper function to keep track of the current indices of the pattern and the string. The basic condition would be when pattern index reaches the end, then we will check if the string index has also reached the end or not. \\n\\nNow we will check if the pattern current index matches the string current index character, this would be true either when the characters are equal i.e. s[i]==p[j] or if the p[j]==\\'.\\' since \\'.\\' can be replaced by any character. \\n\\nIf the next pattern character is \\'\\' that means the current pattern character p[j] could occur 0 or infinite times. So, then there would be two possibility either we can take match the current pattern character with the string and move i by 1 or we can just take zero occurence of the current pattern character and move the pattern character by 2. We will apply the OR condition between these two conditions since if either of them matches then it solves our problem and if next pattern character is not \\'\\' , then we need to check if the current character matches or not and also move both string and pattern character by 1.\\n \\nThe time complexity of this brute force approach is O(3^(max(m,n)) and space complexity is O(max(m,n)) where m and n are the length of pattern and string respectively.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return helper(s,p,0,0);\\n    }\\n    \\n    bool helper(string s, string p, int i, int j)\\n    {\\n        if(j==p.length())\\n            return i==s.length();\\n        bool first_match=(i<s.length() && (s[i]==p[j] || p[j]==\\'.\\' ));\\n        \\n        if(j+1<p.length() && p[j+1]==\\'*\\')\\n        {\\n            return (helper(s,p,i,j+2)|| (first_match && helper(s,p,i+1,j) ));\\n        }\\n        else\\n        {\\n            return (first_match && helper(s,p,i+1,j+1));\\n        }\\n    }\\n};\\n\\n```\\n\\n\\n\\nWe are actually recomputing the solution for the same subproblems many times. So to avoid that we can initialize dp matrix with all values with being -1. Now if dp[i][j]>=0 then that means this has been already computed so we can return the results here only, thus, it saves time and we don\\'t need to recompute that again. Notice that we are saving the results in dp[i][j] in the second last line and this result would always be positive either 0 or 1.  \\n\\nThe time complexity is now O(mn) and space complexity is O(mn) where m and n are the length of pattern and string respectively.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length(),-1));\\n        return helper(s,p,0,0,dp);\\n    }\\n    \\n    bool helper(string s, string p, int i, int j,vector<vector<int>> &dp)\\n    {\\n        if(j==p.length())\\n            return i==s.length();\\n        if(dp[i][j]>=0)\\n            return dp[i][j];\\n        bool first_match=(i<s.length() && (s[i]==p[j] || p[j]==\\'.\\' ));\\n        bool ans=0;\\n        if(j+1<p.length() && p[j+1]==\\'*\\')\\n        {\\n            ans= (helper(s,p,i,j+2,dp)|| (first_match && helper(s,p,i+1,j,dp) ));\\n        }\\n        else\\n        {\\n            ans= (first_match && helper(s,p,i+1,j+1,dp));\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n};\\n```\\n\\nBottom up solution \\n\\nWe can derive the bottom up solution from top down approach only. We will make the matrix of length (s.length()+1)* (p.length()+1)  . dp[s.length()][p.length()]=1 since both have ended at that point. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n    vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,0));\\n        dp[s.length()][p.length()]=1;\\n        \\n        for(int i=s.length();i>=0;i--)\\n        {\\n            for(int j=p.length()-1;j>=0;j--)\\n            {\\n                bool first_match=(i<s.length() && (p[j]==s[i]|| p[j]==\\'.\\'));\\n                    if(j+1<p.length() && p[j+1]==\\'*\\')\\n                    {\\n                        dp[i][j]=dp[i][j+2] || (first_match && dp[i+1][j]);\\n                    }\\n                else\\n                {\\n                    dp[i][j]=first_match && dp[i+1][j+1];\\n                }\\n            }\\n        }\\n        \\n    return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return helper(s,p,0,0);\\n    }\\n    \\n    bool helper(string s, string p, int i, int j)\\n    {\\n        if(j==p.length())\\n            return i==s.length();\\n        bool first_match=(i<s.length() && (s[i]==p[j] || p[j]==\\'.\\' ));\\n        \\n        if(j+1<p.length() && p[j+1]==\\'*\\')\\n        {\\n            return (helper(s,p,i,j+2)|| (first_match && helper(s,p,i+1,j) ));\\n        }\\n        else\\n        {\\n            return (first_match && helper(s,p,i+1,j+1));\\n        }\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length(),-1));\\n        return helper(s,p,0,0,dp);\\n    }\\n    \\n    bool helper(string s, string p, int i, int j,vector<vector<int>> &dp)\\n    {\\n        if(j==p.length())\\n            return i==s.length();\\n        if(dp[i][j]>=0)\\n            return dp[i][j];\\n        bool first_match=(i<s.length() && (s[i]==p[j] || p[j]==\\'.\\' ));\\n        bool ans=0;\\n        if(j+1<p.length() && p[j+1]==\\'*\\')\\n        {\\n            ans= (helper(s,p,i,j+2,dp)|| (first_match && helper(s,p,i+1,j,dp) ));\\n        }\\n        else\\n        {\\n            ans= (first_match && helper(s,p,i+1,j+1,dp));\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n    vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,0));\\n        dp[s.length()][p.length()]=1;\\n        \\n        for(int i=s.length();i>=0;i--)\\n        {\\n            for(int j=p.length()-1;j>=0;j--)\\n            {\\n                bool first_match=(i<s.length() && (p[j]==s[i]|| p[j]==\\'.\\'));\\n                    if(j+1<p.length() && p[j+1]==\\'*\\')\\n                    {\\n                        dp[i][j]=dp[i][j+2] || (first_match && dp[i+1][j]);\\n                    }\\n                else\\n                {\\n                    dp[i][j]=first_match && dp[i+1][j+1];\\n                }\\n            }\\n        }\\n        \\n    return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644123,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        \\n        var visit = [[Bool]]()\\n        let sLength = s.count, pCount = p.count\\n        \\n        for _ in 0...sLength + 1 {\\n            visit.append([Bool](repeating: false, count: pCount + 1))\\n        }\\n        \\n        visit[sLength][pCount] = true\\n        \\n        for i in stride(from: sLength, through: 0, by: -1) {\\n            for j in stride(from: pCount - 1, through: 0, by: -1) {\\n                \\n                let arrS = Array(s), arrP = Array(p)\\n                \\n                let first = i < sLength && (arrS[i] == arrP[j] || arrP[j] == \".\")\\n                \\n                if j + 1 < pCount && arrP[j + 1] == \"*\" {\\n                    visit[i][j] = visit[i][j + 2] || first && visit[i + 1][j]\\n                } else {\\n                    visit[i][j] = first && visit[i + 1][j + 1]\\n                }\\n            }\\n        }\\n        return visit[0][0]\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p>\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<br>\\n\\n<pre>\\nResult: Executed 5 tests, with 0 failures (0 unexpected) in 0.080 (0.082) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        XCTAssertFalse(solution.isMatch(\"aa\", \"a\"))\\n    }\\n    func test1() {\\n        XCTAssertTrue(solution.isMatch(\"aa\", \"a*\"))\\n    }\\n    func test2() {\\n        XCTAssertTrue(solution.isMatch(\"ab\", \".*\"))\\n    }\\n    func test3() {\\n        XCTAssertTrue(solution.isMatch(\"aab\", \"c*a*b\"))\\n    }\\n    func test4() {\\n        XCTAssertFalse(solution.isMatch(\"mississippi\", \"mis*is*p*.\"))\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        \\n        var visit = [[Bool]]()\\n        let sLength = s.count, pCount = p.count\\n        \\n        for _ in 0...sLength + 1 {\\n            visit.append([Bool](repeating: false, count: pCount + 1))\\n        }\\n        \\n        visit[sLength][pCount] = true\\n        \\n        for i in stride(from: sLength, through: 0, by: -1) {\\n            for j in stride(from: pCount - 1, through: 0, by: -1) {\\n                \\n                let arrS = Array(s), arrP = Array(p)\\n                \\n                let first = i < sLength && (arrS[i] == arrP[j] || arrP[j] == \".\")\\n                \\n                if j + 1 < pCount && arrP[j + 1] == \"*\" {\\n                    visit[i][j] = visit[i][j + 2] || first && visit[i + 1][j]\\n                } else {\\n                    visit[i][j] = first && visit[i + 1][j + 1]\\n                }\\n            }\\n        }\\n        return visit[0][0]\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        XCTAssertFalse(solution.isMatch(\"aa\", \"a\"))\\n    }\\n    func test1() {\\n        XCTAssertTrue(solution.isMatch(\"aa\", \"a*\"))\\n    }\\n    func test2() {\\n        XCTAssertTrue(solution.isMatch(\"ab\", \".*\"))\\n    }\\n    func test3() {\\n        XCTAssertTrue(solution.isMatch(\"aab\", \"c*a*b\"))\\n    }\\n    func test4() {\\n        XCTAssertFalse(solution.isMatch(\"mississippi\", \"mis*is*p*.\"))\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491812,
                "title": "javascript-recursive-approach-w-explanation",
                "content": "```\\nconst isMatch = (string, pattern) => {\\n    // early return when pattern is empty\\n    if (!pattern) {\\n\\t\\t// returns true when string and pattern are empty\\n\\t\\t// returns false when string contains chars with empty pattern\\n        return !string;\\n    }\\n    \\n\\t// check if the current char of the string and pattern match when the string has chars\\n    const hasFirstCharMatch = Boolean(string) && (pattern[0] === \\'.\\' || pattern[0] === string[0]);\\n\\n    // track when the next character * is next in line in the pattern\\n    if (pattern[1] === \\'*\\') {\\n        // if next pattern match (after *) is fine with current string, then proceed with it (s, p+2).  That\\'s because the current pattern may be skipped.\\n        // otherwise check hasFirstCharMatch. That\\'s because if we want to proceed with the current pattern, we must be sure that the current pattern char matches the char\\n\\t\\t// If hasFirstCharMatch is true, then do the recursion with next char and current pattern (s+1, p).  That\\'s because current char matches the pattern char. \\n        return (\\n            isMatch(string, pattern.slice(2)) || \\n            (hasFirstCharMatch && isMatch(string.slice(1), pattern))\\n        );\\n    }\\n    \\n    // now we know for sure that we need to do 2 simple actions\\n\\t// check the current pattern and string chars\\n\\t// if so, then can proceed with next string and pattern chars (s+1, p+1)\\n    return hasFirstCharMatch ? isMatch(string.slice(1), pattern.slice(1)) : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nconst isMatch = (string, pattern) => {\\n    // early return when pattern is empty\\n    if (!pattern) {\\n\\t\\t// returns true when string and pattern are empty\\n\\t\\t// returns false when string contains chars with empty pattern\\n        return !string;\\n    }\\n    \\n\\t// check if the current char of the string and pattern match when the string has chars\\n    const hasFirstCharMatch = Boolean(string) && (pattern[0] === \\'.\\' || pattern[0] === string[0]);\\n\\n    // track when the next character * is next in line in the pattern\\n    if (pattern[1] === \\'*\\') {\\n        // if next pattern match (after *) is fine with current string, then proceed with it (s, p+2).  That\\'s because the current pattern may be skipped.\\n        // otherwise check hasFirstCharMatch. That\\'s because if we want to proceed with the current pattern, we must be sure that the current pattern char matches the char\\n\\t\\t// If hasFirstCharMatch is true, then do the recursion with next char and current pattern (s+1, p).  That\\'s because current char matches the pattern char. \\n        return (\\n            isMatch(string, pattern.slice(2)) || \\n            (hasFirstCharMatch && isMatch(string.slice(1), pattern))\\n        );\\n    }\\n    \\n    // now we know for sure that we need to do 2 simple actions\\n\\t// check the current pattern and string chars\\n\\t// if so, then can proceed with next string and pattern chars (s+1, p+1)\\n    return hasFirstCharMatch ? isMatch(string.slice(1), pattern.slice(1)) : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2551251,
                "title": "python-explained-steps-clean-code-best-method",
                "content": "Hello!\\n\\nTo solve this problem we have to go through all possible states. State is defined by **s_index** and **p_index** where they define current char from **s** and **p** strings.\\n\\nWe return **True** if both **s_index** and **p_index** are out of bounds (it means that we were able to construct **s** string from **p** pattern and there are no chars left in **p**).\\n\\nIf **s_index** is out of bounds, but **p_index** is not out of bounds it means that we were able to construct **s** string from **p**, but there are some chars left in **p**. We can delete them only, if there are only letter + star pairs left. If there is at least one letter (or dot) without star after it, then we have to return **False**.\\n\\n\\nFor example if we have s = **abc** and p = **abcz(star)b(star)** then we are able to remove **z** and **b** occurencies, because there is **star** after **z** and after **b**, so we return **True**.\\n\\n\\nIf **p_index** is out of bounds while **s_index** is still not out of bounds it means that we are not able to construct **s** from **p**, because there are no letters left, so we return **False**.\\n\\nThen there are 4 options:\\n\\n1) If next char in **p** is a **star** and char in **s** match char in **p** (if char in **p** is dot, then we assume that we change dot to the char that is in **s**) then we have two options: we can use current char in **p** to match char in **s** or go to next char in **p** (because next char is a **star**, so we can use previous char 0 or more times).\\n\\n2) If next char in **p** is a **star** and char in **s** **DOES NOT** match char in **p**, then we can only explore going to the next char in **p** option (so we increase **p_index** by 2, because we have to skip the **star**).\\n\\n3) If next char in **p** **IS NOT** a **star** and char in **s** match char in **p**, then we can only explore current char option to match char in **s** (so we increase both **p_index** and **s_index** by 1)\\n\\n4)  If next char in **p** **IS NOT** a **star** and char in **s** **DOES NOT** match char in **p**, then there is no option left, so we have to return **False**.\\n\\nWe will use **memory** to store previous state and at the start of the function we check if current state was already explored. If **yes** then we just return value stored in **memory**.\\n\\nCode:\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        memory = {}\\n        \\n        def explore_state(s_index, p_index):\\n            if (s_index, p_index) in memory:\\n                return memory[(s_index, p_index)]\\n            \\n            s_index_out_of_border = s_index >= len(s)\\n            p_index_out_of_border = p_index >= len(p)\\n            next_char_is_a_star = p_index+1 < len(p) and p[p_index+1] == \"*\"\\n            \\n            if s_index_out_of_border is True:\\n                if p_index_out_of_border is True:\\n                    return True\\n                elif next_char_is_a_star is True:\\n                    memory[(s_index, p_index)] = explore_state(s_index, p_index+2)\\n                    return memory[(s_index, p_index)]\\n                else:\\n                    memory[(s_index, p_index)] = False\\n                    return memory[(s_index, p_index)]\\n                \\n            if p_index_out_of_border:\\n                return False\\n            \\n            match = s[s_index] == p[p_index] or p[p_index] == \".\"\\n            \\n            if next_char_is_a_star is True and match is True:\\n                memory[(s_index, p_index)] = explore_state(s_index, p_index+2) or explore_state(s_index+1, p_index)\\n            elif next_char_is_a_star is True and match is False:\\n                memory[(s_index, p_index)] = explore_state(s_index, p_index+2)\\n            elif next_char_is_a_star is False and match is True:\\n                memory[(s_index, p_index)] = explore_state(s_index+1, p_index+1)\\n            elif next_char_is_a_star is False and match is False:\\n                memory[(s_index, p_index)] = False\\n\\t\\t\\t\\t\\n            return memory[(s_index, p_index)]\\n        \\n        return explore_state(0, 0)\\n```\\n\\nPlease upvote if it was helpful :))",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        memory = {}\\n        \\n        def explore_state(s_index, p_index):\\n            if (s_index, p_index) in memory:\\n                return memory[(s_index, p_index)]\\n            \\n            s_index_out_of_border = s_index >= len(s)\\n            p_index_out_of_border = p_index >= len(p)\\n            next_char_is_a_star = p_index+1 < len(p) and p[p_index+1] == \"*\"\\n            \\n            if s_index_out_of_border is True:\\n                if p_index_out_of_border is True:\\n                    return True\\n                elif next_char_is_a_star is True:\\n                    memory[(s_index, p_index)] = explore_state(s_index, p_index+2)\\n                    return memory[(s_index, p_index)]\\n                else:\\n                    memory[(s_index, p_index)] = False\\n                    return memory[(s_index, p_index)]\\n                \\n            if p_index_out_of_border:\\n                return False\\n            \\n            match = s[s_index] == p[p_index] or p[p_index] == \".\"\\n            \\n            if next_char_is_a_star is True and match is True:\\n                memory[(s_index, p_index)] = explore_state(s_index, p_index+2) or explore_state(s_index+1, p_index)\\n            elif next_char_is_a_star is True and match is False:\\n                memory[(s_index, p_index)] = explore_state(s_index, p_index+2)\\n            elif next_char_is_a_star is False and match is True:\\n                memory[(s_index, p_index)] = explore_state(s_index+1, p_index+1)\\n            elif next_char_is_a_star is False and match is False:\\n                memory[(s_index, p_index)] = False\\n\\t\\t\\t\\t\\n            return memory[(s_index, p_index)]\\n        \\n        return explore_state(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991342,
                "title": "c-bottom-up-dp-solution-with-detailed-comments-from-o-mn-space-to-o-n-space",
                "content": "#### algorithm\\nWe start with building base cases:\\n- If both the string and the pattern are empty, there is a match. \\n- If the pattern is empty but the string is not, there is no match.\\n- If the string is empty, it\\'s still possible that there\\'s a match even if the pattern is not empty, as `*` can match zero of the preceding character.\\n\\nThe most difficult part is that we have two special characters that we need take care of. `.` is fairly straightforward: there will be a match between `.` and any string character. However, `*` is a bit difficult to deal with, since it can either match 0 of the preceding character, or match 1 or even more of the preceding character.\\n\\nIn this solution, we have two pointers pointing to the current characters at the string and pattern respectively. The logic of how to build our dp array depends on the current character in the pattern string that we\\'re currently at. \\n- If the current character we\\'re at is not `*`, then we check if it matches the current string charater. If so, then we check whether the remaining part still matches. \\n- If the current character we\\'re at is `*`, then we need to handle two different cases.\\n\\t- The first case is that this `*` might match 0 of the preceding character, therefore we need to check if the remaining part of the pattern matches the string.\\n\\t- The second case is that this `*` might match 1 or more of the preceding character. If so, we first need to ensure that the preceding character of `*` matches the current character in the string. We then need to see if the remaining part of the string matches with the pattern.\\n\\n#### O(mn) space\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<bool>> dp(s.size() + 1, vector<bool>(p.size() + 1, false));\\n        \\n\\t\\tdp[0][0] = true;\\n        for (int j = 2; j <= p.size(); ++j) {\\n            if (p[j - 1] == \\'*\\') {\\n                dp[0][j] = dp[0][j - 2];\\n            }\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = 1; j <= p.size(); ++j) {\\n                if (p[j - 1] != \\'*\\') {\\n                    dp[i][j] = (p[j - 1] == \\'.\\' || p[j - 1] == s[i - 1]) && dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = dp[i][j - 2] || (((p[j - 2] == \\'.\\') || (p[j - 2] == s[i - 1])) && dp[i - 1][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()][p.size()];\\n    }\\n};\\n```\\n\\n#### O(n) space\\nTo calculate `dp[i][j]`, we only need `dp[i][j - 2]`, `dp[i - 1][j - 1]`, and `dp[i - 1][j]`. Therefore, we can compress the original 2d array into 1d.\\nHowever, since we only have one array, we might override the necessary information for later calculation when we\\'re updating the dp array. Therefore, we need 2 extra variables to store the information from last iteration.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<bool> dp(p.size() + 1, false);\\n        \\n        dp[0] = true;\\n        for (int j = 2; j <= p.size(); ++j) {\\n            if (p[j - 1] == \\'*\\') {\\n                dp[j] = dp[j - 2];\\n            }\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            bool neighborLastRow = dp[0];\\n            dp[0] = false;\\n            for (int j = 1; j <= p.size(); ++j) {\\n                bool currLastRow = dp[j];\\n                if (p[j - 1] != \\'*\\') {\\n                    dp[j] = (p[j - 1] == \\'.\\' || p[j - 1] == s[i - 1]) && neighborLastRow;\\n                } else {\\n                    dp[j] = dp[j - 2] || (((p[j - 2] == \\'.\\') || (p[j - 2] == s[i - 1])) && currLastRow);\\n                }\\n                neighborLastRow = currLastRow;\\n            }\\n        }\\n        \\n        return dp[p.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<bool>> dp(s.size() + 1, vector<bool>(p.size() + 1, false));\\n        \\n\\t\\tdp[0][0] = true;\\n        for (int j = 2; j <= p.size(); ++j) {\\n            if (p[j - 1] == \\'*\\') {\\n                dp[0][j] = dp[0][j - 2];\\n            }\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = 1; j <= p.size(); ++j) {\\n                if (p[j - 1] != \\'*\\') {\\n                    dp[i][j] = (p[j - 1] == \\'.\\' || p[j - 1] == s[i - 1]) && dp[i - 1][j - 1];\\n                } else {\\n                    dp[i][j] = dp[i][j - 2] || (((p[j - 2] == \\'.\\') || (p[j - 2] == s[i - 1])) && dp[i - 1][j]);\\n                }\\n            }\\n        }\\n        \\n        return dp[s.size()][p.size()];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<bool> dp(p.size() + 1, false);\\n        \\n        dp[0] = true;\\n        for (int j = 2; j <= p.size(); ++j) {\\n            if (p[j - 1] == \\'*\\') {\\n                dp[j] = dp[j - 2];\\n            }\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            bool neighborLastRow = dp[0];\\n            dp[0] = false;\\n            for (int j = 1; j <= p.size(); ++j) {\\n                bool currLastRow = dp[j];\\n                if (p[j - 1] != \\'*\\') {\\n                    dp[j] = (p[j - 1] == \\'.\\' || p[j - 1] == s[i - 1]) && neighborLastRow;\\n                } else {\\n                    dp[j] = dp[j - 2] || (((p[j - 2] == \\'.\\') || (p[j - 2] == s[i - 1])) && currLastRow);\\n                }\\n                neighborLastRow = currLastRow;\\n            }\\n        }\\n        \\n        return dp[p.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5937,
                "title": "my-4ms-c-dp-solution-another-recursive-version-also-given-72ms",
                "content": "Just to build a DP table  checked, where checked[i][j] indicates whether s[0..i-1] matches with p[0..j-1]. The recursive relationship is as below:\\nTo match with the empty string s[0..0] (i.e. to make checked[0][j]), P[0..j-1] has to meet: p[j-1]=='*' (to cancel p[j-2]) and checked[0][j-2] == true;\\nTo match with the string s[0..i-1] (i.e. to make checked[i][j]), P[0..j-1] has to meet: \\n\\n 1. if p[j-1] =='*', then j must be larger than 1 (j>1) and\\n \\n - checked[i][j-2] (i.e. p[j-2] cancelled by '*')\\n - checked[i-1][j]    && (s[i-1] ==p[j-2] || p[j-2] =='.')  (s[i-1] matches with p[j-2] or '.', )\\n\\n 2. if p[j-1] !='*',  checked[i-1][j-1] && (s[i-1] ==p[j-1] || p[j-1] =='.')(i.e. s[i-1]  matches with p[j-1] or '.')\\n\\n\\n\\n \\n\\n   class Solution {\\n    \\n        public:\\n            bool isMatch(string s, string p) {\\n                int sSize = s.size(), pSize = p.size(), i, j;\\n                bool checked[sSize+1][pSize+1];\\n        //        fill_n(&matched[0][0], (sSize+1)*(pSize+1), false);\\n                \\n                for(j=2, checked[0][0]=true, checked[0][1]= false; j<=pSize; ++j) // match s[0..0]\\n                    checked[0][j] = p[j-1] == '*'? checked[0][j-2]  : false;\\n                for(i=1; i<=sSize; ++i)\\n                for(j=1, checked[i][0]=false; j<=pSize; ++j)\\n                {\\n                    if(p[j-1]=='*') // case (1)\\n                        checked[i][j] = (j>1) && ( checked[i][j-2]  || ( ( checked[i-1][j]) && (s[i-1]== p[j-2] || p[j-2] == '.')) );\\n                    else // case (2)\\n                        checked[i][j] = checked[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.');        \\n                }\\n                return checked[sSize][pSize];\\n            }\\n        };\\n\\nA recursive version, divide cases into two groups (if the next p char is '*' or not)\\n\\n    class Solution {\\n    private:\\n        bool helper(const string &s, const string &p, int sS, int pS)\\n        {\\n            int sSize = s.size(), pSize = p.size(), i, j; \\n            if(pS==pSize) return sS ==sSize; // if p goes to its end, then only if s also goes to its end to return true;\\n            \\n            if(p[pS+1]!='*')\\n            {\\n               if( sS<sSize && (p[pS]==s[sS] || p[pS] == '.')) return helper(s, p, sS+1, pS+1);\\n            }\\n            else\\n            {\\n                if(helper(s, p, sS,pS+2)) return true;\\n                while(sS<sSize && (p[pS]==s[sS] || p[pS] == '.')) if(helper(s,p, ++sS, pS+2)) return true;\\n            }\\n            return false;\\n        }\\n    \\n    public:\\n        bool isMatch(string s, string p) {\\n           helper(s, p, 0, 0); \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n        public:\\n            bool isMatch(string s, string p) {\\n                int sSize = s.size(), pSize = p.size(), i, j;\\n                bool checked[sSize+1][pSize+1];\\n        //        fill_n(&matched[0][0], (sSize+1)*(pSize+1), false);\\n                \\n                for(j=2, checked[0][0]=true, checked[0][1]= false; j<=pSize; ++j) // match s[0..0]\\n                    checked[0][j] = p[j-1] == '*'? checked[0][j-2]  : false;\\n                for(i=1; i<=sSize; ++i)\\n                for(j=1, checked[i][0]=false; j<=pSize; ++j)\\n                {\\n                    if(p[j-1]=='*') // case (1)\\n                        checked[i][j] = (j>1) && ( checked[i][j-2]  || ( ( checked[i-1][j]) && (s[i-1]== p[j-2] || p[j-2] == '.')) );\\n                    else // case (2)\\n                        checked[i][j] = checked[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == '.');        \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 529694,
                "title": "this-is-not-a-fast-algorithm-but-a-very-detailed-explanation-for-dumb-people-like-myself",
                "content": "**This is NOT a fast algorithm, it is intended to explain the naive algorithm to those who struggled like I did.**\\n\\nThe solution provided by Leedcode Solution, or tutorials on YouTube all fail to explain the question clearly enough before jumping into DP and other speedy algorithm.\\n\\n# Intuition and Analysis\\n\\n* Let s[i] and p[j] be the elements we are comparing.\\n* Without \\'\\\\*\\', compare element one by one,\\n```\\nif mismatch:\\n\\treturn False\\nelse:\\n\\ti++\\n\\tj++\\n```\\n* With \\'\\\\*\\'\\n\\t* case 1 we skip s[i] due to mismatch\\n\\t* case 2 we delete/ignore/skip s[i] one or more times.\\n\\n**THE CATCH** lies in \\'one or more times\\', most tutorial will tell you to delete s[i] until you fiind a mismatch e.g.\\n```\\n        s = \\'aaaab\\', p = \\'a*b\\'\\n        delete/ignore/skip \\'a\\' 4 times\\n        s = \\'b\\', p = \\'b\\' BINGO!\\n```\\nBut this algorithm can be easily defeated by\\n\\n\\ts = \\'aaa\\', p = \\'a*a\\'\\n\\t\\t\\nThis will result in s = \\'\\', p = \\'a\\'.\\n\\n**THE KEY** is try all the possibilities of the number of times s[i] can be deleted/ignored/skipped, if any possibility results in True, then this part of string matching is True because \\'\\\\*\\' gives this kind of flexibility. In the example above, the correct number of times is 2, you want be left with s = \\'a\\', p =\\'a\\'.\\n\\n**For implementation, please see in code, I rewrote readable version of simplied code.**\\n\\nI have struggled with this question for hours, I really hope this kind of \\'dumb\\' explaination can help you, because most answers I have looked at are trying too hard to be smart for newbies like myself.\\n\\n\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # Edge case\\n        if p is \\'\\':\\n            if s is \\'\\':\\n                return True\\n            else:\\n                return False\\n        # Simplified version:\\n        # if not p:\\n        #     return not s\\n\\n        if s:\\n            first_char_match = p[0] in (s[0], \\'.\\')\\n        else:\\n            first_char_match = False\\n        # Simplified version:\\n        # first_char_match = bool(s) and p[0] in (s[0], \\'.\\')\\n\\n        # len(p) < 2, p[1] will raise error\\n        if len(p) > 1 and p[1] == \\'*\\':\\n            \"\"\"\\n            Try all possibilities:\\n            1) 0 occurrence, zero_ocr\\n            2) repeat is for one or more occurrence.\\n               This is bit subtle. The correct number of times of \\n               deleting/ignoring/skipping will result in either case\\n               being True.\\n               e.g. s = \\'aaa\\', p = \\'a*a\\'\\n                    skips twice\\n                    s = \\'a\\', p[2:] = \\'a\\' -> True\\n               e.g. s = \\'aab\\', p = \\'a*b\\'\\n                    ...\\n                    s = \\'b\\', p = \\'a*b\\'\\n                    zero_ocr = isMatch(\\'b\\', \\'b\\') -> True\\n                    first_char_match = False\\n                    return zero_ocr, thus return True in the end\\n            \"\"\"\\n            zero_ocr = self.isMatch(s, p[2:])\\n            if first_char_match:\\n                repeat = self.isMatch(s[1:], p)\\n                return zero_ocr or repeat\\n            return zero_ocr\\n            # Simplified version\\n            # return self.isMatch(s, p[2:]) \\\\\\n            #        or (first_char_match and self.isMatch(s[1:], p))\\n        else:\\n            if first_char_match:\\n                return self.isMatch(s[1:], p[1:])\\n            else:\\n                return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nif mismatch:\\n\\treturn False\\nelse:\\n\\ti++\\n\\tj++\\n```\n```\\n        s = \\'aaaab\\', p = \\'a*b\\'\\n        delete/ignore/skip \\'a\\' 4 times\\n        s = \\'b\\', p = \\'b\\' BINGO!\\n```\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # Edge case\\n        if p is \\'\\':\\n            if s is \\'\\':\\n                return True\\n            else:\\n                return False\\n        # Simplified version:\\n        # if not p:\\n        #     return not s\\n\\n        if s:\\n            first_char_match = p[0] in (s[0], \\'.\\')\\n        else:\\n            first_char_match = False\\n        # Simplified version:\\n        # first_char_match = bool(s) and p[0] in (s[0], \\'.\\')\\n\\n        # len(p) < 2, p[1] will raise error\\n        if len(p) > 1 and p[1] == \\'*\\':\\n            \"\"\"\\n            Try all possibilities:\\n            1) 0 occurrence, zero_ocr\\n            2) repeat is for one or more occurrence.\\n               This is bit subtle. The correct number of times of \\n               deleting/ignoring/skipping will result in either case\\n               being True.\\n               e.g. s = \\'aaa\\', p = \\'a*a\\'\\n                    skips twice\\n                    s = \\'a\\', p[2:] = \\'a\\' -> True\\n               e.g. s = \\'aab\\', p = \\'a*b\\'\\n                    ...\\n                    s = \\'b\\', p = \\'a*b\\'\\n                    zero_ocr = isMatch(\\'b\\', \\'b\\') -> True\\n                    first_char_match = False\\n                    return zero_ocr, thus return True in the end\\n            \"\"\"\\n            zero_ocr = self.isMatch(s, p[2:])\\n            if first_char_match:\\n                repeat = self.isMatch(s[1:], p)\\n                return zero_ocr or repeat\\n            return zero_ocr\\n            # Simplified version\\n            # return self.isMatch(s, p[2:]) \\\\\\n            #        or (first_char_match and self.isMatch(s[1:], p))\\n        else:\\n            if first_char_match:\\n                return self.isMatch(s[1:], p[1:])\\n            else:\\n                return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294275,
                "title": "python-dp-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        # Initialize DP table\\n        # Row indices represent the lengths of subpatterns\\n        # Col indices represent the lengths of substrings\\n        T = [\\n            [False for _ in range(len(s)+1)]\\n            for _ in range(len(p)+1)\\n        ]\\n\\n        # Mark the origin as True, since p[:0] == \"\" and s[:0] == \"\"\\n        T[0][0] = True\\n\\n        # Consider all subpatterns p[:i], i > 0 against empty string s[:0]\\n        for i in range(1, len(p)+1):\\n            # Subpattern matches \"\" only if it consists of \"{a-z}*\" pairs\\n            T[i][0] = i > 1 and T[i-2][0] and p[i-1] == \\'*\\'\\n\\n        # Consider the empty pattern p[:0] against all substrings s[:j], j > 0\\n        # Since an empty pattern cannot match non-empty strings, cells remain False\\n\\n        # Match the remaining subpatterns (p[:i], i > 0) with the remaining\\n        # substrings (s[:j], j > 0)\\n        for i in range(1, len(p)+1):\\n            for j in range(1, len(s)+1):\\n\\n                # Case 1: Last char of subpattern p[i-1] is an alphabet or \\'.\\'\\n                if p[i-1] == s[j-1] or p[i-1] == \\'.\\':\\n                    T[i][j] |= T[i-1][j-1]\\n\\n                # Case 2: Last char of subpattern p[i-1] is \\'*\\'\\n                elif p[i-1] == \\'*\\':\\n\\n                    # Case 2a: Subpattern doesn\\'t need \\'*\\' to match the substring\\n\\n                    # If the subpattern without \\'*\\' matches the substring,\\n                    # the subpattern with \\'*\\' must still match\\n                    T[i][j] |= T[i-1][j]\\n\\n                    # If the subpattern without \\'*\\' and its preceding alphabet\\n                    # matches the substring, then the subpattern with them\\n                    # must still match\\n                    T[i][j] |= i > 1 and T[i-2][j]\\n\\n                    # Case 2b: Subpattern needs \\'*\\' to match the substring\\n\\n                    # If the alphabet preceding \\'*\\' matches the last char of\\n                    # the substring, then \\'*\\' is used to extend the match for\\n                    # the substring without its last char\\n                    if i > 1 and p[i-2] == s[j-1] or p[i-2] == \\'.\\':\\n                        T[i][j] |= T[i][j-1]\\n\\n        return T[-1][-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        # Initialize DP table\\n        # Row indices represent the lengths of subpatterns\\n        # Col indices represent the lengths of substrings\\n        T = [\\n            [False for _ in range(len(s)+1)]\\n            for _ in range(len(p)+1)\\n        ]\\n\\n        # Mark the origin as True, since p[:0] == \"\" and s[:0] == \"\"\\n        T[0][0] = True\\n\\n        # Consider all subpatterns p[:i], i > 0 against empty string s[:0]\\n        for i in range(1, len(p)+1):\\n            # Subpattern matches \"\" only if it consists of \"{a-z}*\" pairs\\n            T[i][0] = i > 1 and T[i-2][0] and p[i-1] == \\'*\\'\\n\\n        # Consider the empty pattern p[:0] against all substrings s[:j], j > 0\\n        # Since an empty pattern cannot match non-empty strings, cells remain False\\n\\n        # Match the remaining subpatterns (p[:i], i > 0) with the remaining\\n        # substrings (s[:j], j > 0)\\n        for i in range(1, len(p)+1):\\n            for j in range(1, len(s)+1):\\n\\n                # Case 1: Last char of subpattern p[i-1] is an alphabet or \\'.\\'\\n                if p[i-1] == s[j-1] or p[i-1] == \\'.\\':\\n                    T[i][j] |= T[i-1][j-1]\\n\\n                # Case 2: Last char of subpattern p[i-1] is \\'*\\'\\n                elif p[i-1] == \\'*\\':\\n\\n                    # Case 2a: Subpattern doesn\\'t need \\'*\\' to match the substring\\n\\n                    # If the subpattern without \\'*\\' matches the substring,\\n                    # the subpattern with \\'*\\' must still match\\n                    T[i][j] |= T[i-1][j]\\n\\n                    # If the subpattern without \\'*\\' and its preceding alphabet\\n                    # matches the substring, then the subpattern with them\\n                    # must still match\\n                    T[i][j] |= i > 1 and T[i-2][j]\\n\\n                    # Case 2b: Subpattern needs \\'*\\' to match the substring\\n\\n                    # If the alphabet preceding \\'*\\' matches the last char of\\n                    # the substring, then \\'*\\' is used to extend the match for\\n                    # the substring without its last char\\n                    if i > 1 and p[i-2] == s[j-1] or p[i-2] == \\'.\\':\\n                        T[i][j] |= T[i][j-1]\\n\\n        return T[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913909,
                "title": "c-recursion-memoisation-bottom-up-dp-o-n-m-commented-code",
                "content": "recursion code :\\ntc : O(2^n)\\n```\\nbool util(string s, string p, int n, int m){\\n\\t// if both the string have reached their end, then p must be in s\\n    if(n <= -1 && m <= -1)\\n        return true;\\n\\n\\t/* if the second last element is \\'*\\' then also we can call it a match, as given in the question, \\n\\t\\twe can have 0 occurences of the previous element */\\n    if(n == -1 && p[m] == \\'*\\')\\n        return util(s, p, n, m-2);\\n\\t\\n\\t// even now if element\\'s are left in s or p, then return false\\n    if(n == -1 || m == -1)\\n        return false;\\n\\t\\n\\t// if elements are same the skip it, cause it exists in both of them\\n    if(s[n] == p[m]){\\n        return util(s, p, n-1, m-1);\\n    }\\n    else{\\n\\t\\t// as it is given , when we encounter \\'*\\', we can choose 0 or n number of previous element\\n        if(p[m] == \\'*\\'){\\n            if(s[n] == p[m-1] || p[m-1] == \\'.\\'){\\n                return (util(s, p, n-1, m) || util(s, p, n, m-2));\\n            }\\n            else{\\n                return util(s, p, n, m-2);\\n            }\\n        }\\n\\t\\t// when encountering \\'.\\' we can skip 1 element\\n        else if(p[m] == \\'.\\'){\\n           return util(s, p, n-1, m-1);\\n        }\\n        else\\n            return false;\\n    }\\n}\\n\\nbool isMatchMemo(string s, string p) {\\n    return util(s, p, s.length()-1, p.length()-1);\\n}\\n```\\n\\nMemoisation : just avoiding ovelapping sub-problems, by storing the already processed states\\ntc : O(n*m)\\n```\\nunordered_map<string, int> dp;\\nbool util(string s, string p, int n, int m){\\n    string key = to_string(n) + to_string(m);\\n\\n    if(n <= -1 && m <= -1)\\n        return true;\\n\\n    if(n == -1 && p[m] == \\'*\\')\\n        return util(s, p, n, m-2);\\n\\n    if(n == -1 || m == -1)\\n        return false;\\n\\n    if(dp.count(key))\\n        return dp[key];\\n\\n    if(s[n] == p[m]){\\n        dp[key] = util(s, p, n-1, m-1);\\n    }\\n    else{\\n        if(p[m] == \\'*\\'){\\n            if(s[n] == p[m-1] || p[m-1] == \\'.\\'){\\n                dp[key] = (util(s, p, n-1, m) || util(s, p, n, m-2));\\n            }\\n            else{\\n                dp[key] = util(s, p, n, m-2);\\n            }\\n        }\\n        else if(p[m] == \\'.\\'){\\n            dp[key] = util(s, p, n-1, m-1);\\n        }\\n        else\\n            dp[key] = false;\\n    }\\n\\n    return dp[key];\\n}\\n\\nbool isMatchMemo(string s, string p) {\\n    return util(s, p, s.length()-1, p.length()-1);\\n}\\n```\\n\\nTop-Down : \\nhere just convert the condition we have applied in the recursion to if/else\\n\\ntc : O(n*m)\\nsc : O(n*m)\\n```\\nbool isMatch(string s, string p) {\\n    int n = s.length();\\n    int m = p.length();\\n\\n    bool dp[n+1][m+1];\\n    memset(dp, false, sizeof(dp));\\n\\n    for(int i = 0; i <= n; i++){\\n        for(int j = 0; j <= m; j++){\\n            if(!i && !j)    dp[i][j] = true;\\n            else if(!i && p[j-1] == \\'*\\')\\n                dp[i][j] = dp[i][j-2];\\n            else if(!i || !j) dp[i][j] = false;\\n\\n            else{\\n                if(s[i-1] == p[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n\\n                else if(p[j-1] == \\'*\\'){\\n                    if(s[i-1] == p[j-2] || p[j-2] == \\'.\\')\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-2];\\n                    else\\n                        dp[i][j] = dp[i][j-2];\\n                }\\n                else if(p[j-1] == \\'.\\')\\n                    dp[i][j] = dp[i-1][j-1];\\n            }\\n        }\\n    }\\n\\n    return dp[n][m];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nbool util(string s, string p, int n, int m){\\n\\t// if both the string have reached their end, then p must be in s\\n    if(n <= -1 && m <= -1)\\n        return true;\\n\\n\\t/* if the second last element is \\'*\\' then also we can call it a match, as given in the question, \\n\\t\\twe can have 0 occurences of the previous element */\\n    if(n == -1 && p[m] == \\'*\\')\\n        return util(s, p, n, m-2);\\n\\t\\n\\t// even now if element\\'s are left in s or p, then return false\\n    if(n == -1 || m == -1)\\n        return false;\\n\\t\\n\\t// if elements are same the skip it, cause it exists in both of them\\n    if(s[n] == p[m]){\\n        return util(s, p, n-1, m-1);\\n    }\\n    else{\\n\\t\\t// as it is given , when we encounter \\'*\\', we can choose 0 or n number of previous element\\n        if(p[m] == \\'*\\'){\\n            if(s[n] == p[m-1] || p[m-1] == \\'.\\'){\\n                return (util(s, p, n-1, m) || util(s, p, n, m-2));\\n            }\\n            else{\\n                return util(s, p, n, m-2);\\n            }\\n        }\\n\\t\\t// when encountering \\'.\\' we can skip 1 element\\n        else if(p[m] == \\'.\\'){\\n           return util(s, p, n-1, m-1);\\n        }\\n        else\\n            return false;\\n    }\\n}\\n\\nbool isMatchMemo(string s, string p) {\\n    return util(s, p, s.length()-1, p.length()-1);\\n}\\n```\n```\\nunordered_map<string, int> dp;\\nbool util(string s, string p, int n, int m){\\n    string key = to_string(n) + to_string(m);\\n\\n    if(n <= -1 && m <= -1)\\n        return true;\\n\\n    if(n == -1 && p[m] == \\'*\\')\\n        return util(s, p, n, m-2);\\n\\n    if(n == -1 || m == -1)\\n        return false;\\n\\n    if(dp.count(key))\\n        return dp[key];\\n\\n    if(s[n] == p[m]){\\n        dp[key] = util(s, p, n-1, m-1);\\n    }\\n    else{\\n        if(p[m] == \\'*\\'){\\n            if(s[n] == p[m-1] || p[m-1] == \\'.\\'){\\n                dp[key] = (util(s, p, n-1, m) || util(s, p, n, m-2));\\n            }\\n            else{\\n                dp[key] = util(s, p, n, m-2);\\n            }\\n        }\\n        else if(p[m] == \\'.\\'){\\n            dp[key] = util(s, p, n-1, m-1);\\n        }\\n        else\\n            dp[key] = false;\\n    }\\n\\n    return dp[key];\\n}\\n\\nbool isMatchMemo(string s, string p) {\\n    return util(s, p, s.length()-1, p.length()-1);\\n}\\n```\n```\\nbool isMatch(string s, string p) {\\n    int n = s.length();\\n    int m = p.length();\\n\\n    bool dp[n+1][m+1];\\n    memset(dp, false, sizeof(dp));\\n\\n    for(int i = 0; i <= n; i++){\\n        for(int j = 0; j <= m; j++){\\n            if(!i && !j)    dp[i][j] = true;\\n            else if(!i && p[j-1] == \\'*\\')\\n                dp[i][j] = dp[i][j-2];\\n            else if(!i || !j) dp[i][j] = false;\\n\\n            else{\\n                if(s[i-1] == p[j-1])\\n                    dp[i][j] = dp[i-1][j-1];\\n\\n                else if(p[j-1] == \\'*\\'){\\n                    if(s[i-1] == p[j-2] || p[j-2] == \\'.\\')\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-2];\\n                    else\\n                        dp[i][j] = dp[i][j-2];\\n                }\\n                else if(p[j-1] == \\'.\\')\\n                    dp[i][j] = dp[i-1][j-1];\\n            }\\n        }\\n    }\\n\\n    return dp[n][m];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5929,
                "title": "javascript-solution",
                "content": "    function isMatch(s, p) {\\n      var lenS = s.length;\\n      var lenP = p.length;\\n      var map = {};\\n    \\n      return check(0, 0);\\n    \\n      function check(idxS, idxP) {\\n        if (map[idxS + ':' + idxP] !== undefined) return map[idxS + ':' + idxP];\\n        if (idxS > lenS) return false;\\n        if (idxS === lenS && idxP === lenP) return true;\\n    \\n        if (p[idxP] === '.' || p[idxP] === s[idxS]) {\\n          map[idxS + ':' + idxP] = p[idxP + 1] === '*' ?\\n            check(idxS + 1, idxP) || check(idxS, idxP + 2) :\\n            check(idxS + 1, idxP + 1);\\n        } else {\\n          map[idxS + ':' + idxP] = p[idxP + 1] === '*' ?\\n            check(idxS, idxP + 2) : false;\\n        }\\n        return map[idxS + ':' + idxP];\\n      }\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function isMatch(s, p) {\\n      var lenS = s.length;\\n      var lenP = p.length;\\n      var map = {};\\n    \\n      return check(0, 0);\\n    \\n      function check(idxS, idxP) {\\n        if (map[idxS + ':' + idxP] !== undefined) return map[idxS + ':' + idxP];\\n        if (idxS > lenS) return false;\\n        if (idxS === lenS && idxP === lenP) return true;\\n    \\n        if (p[idxP] === '.' || p[idxP] === s[idxS]) {\\n          map[idxS + ':' + idxP] = p[idxP + 1] === '*' ?\\n            check(idxS + 1, idxP) || check(idxS, idxP + 2) :\\n            check(idxS + 1, idxP + 1);\\n        } else {\\n          map[idxS + ':' + idxP] = p[idxP + 1] === '*' ?\\n            check(idxS, idxP + 2) : false;\\n        }\\n        return map[idxS + ':' + idxP];\\n      }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 5941,
                "title": "my-ac-dp-solution-for-this-problem-asking-for-improvements",
                "content": "    public boolean isMatch(String s, String p) {\\n        int m = s.length();\\n        int n = p.length();\\n        \\n        if (s == null || p == null) {\\n            return false;\\n        }\\n        \\n        boolean[][] OPT = new boolean[m+1][n+1];\\n        OPT[0][0] = true;\\n        \\n        for (int i = 1; i <= m; i++) {\\n            OPT[i][0] = false;\\n        }\\n        for (int j = 1; j <= n; j++) {\\n            OPT[0][j] = (p.charAt(j-1) == '*') && (j-2 >= 0) && OPT[0][j-2];\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                OPT[i][j] = ((OPT[i-1][j-1]) && equals(s, p, i-1, j-1))\\n                        ||  ((OPT[i-1][j] || OPT[i][j-1]) \\n                            && (p.charAt(j-1) == '*') \\n                            && equals(s, p, i-1, j-2))\\n                        ||  ((p.charAt(j-1) == '*') && (j-2 >= 0) && OPT[i][j-2]);\\n            }\\n        }\\n        \\n        return OPT[m][n];\\n    }\\n    \\n    private boolean equals(String s, String p, int si, int pi) {\\n        return (s.charAt(si) == p.charAt(pi) || p.charAt(pi) == '.');\\n    }\\n\\nBasically, the OPT[i][j] means preceding substring of length i of s and length j of p. For any two substrings, the value of OPT[i][j] can be from one of following four cases:\\n\\n - case 1: OPT[i-1][j-1] is true, and ith character of s is equal to j th character of p. Or j th character of p is '.'\\n - case 2: OPT[i-1][j] is true, then my pattern now is '*' and preceding character is equal to incoming character of s\\n - case 3: OPT[i][j-1] is true, then my pattern now is '*' which can match an empty string\\n - case 4: OPT[i][j-2] is true, and the pattern like (a*) matches an empty string\\n\\nbase case is the OPT[0][0], OPT[i][0], OPT[0][j].",
                "solutionTags": [],
                "code": "    public boolean isMatch(String s, String p) {\\n        int m = s.length();\\n        int n = p.length();\\n        \\n        if (s == null || p == null) {\\n            return false;\\n        }\\n        \\n        boolean[][] OPT = new boolean[m+1][n+1];\\n        OPT[0][0] = true;\\n        \\n        for (int i = 1; i <= m; i++) {\\n            OPT[i][0] = false;\\n        }\\n        for (int j = 1; j <= n; j++) {\\n            OPT[0][j] = (p.charAt(j-1) == '*') && (j-2 >= 0) && OPT[0][j-2];\\n        }\\n        \\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                OPT[i][j] = ((OPT[i-1][j-1]) && equals(s, p, i-1, j-1))\\n                        ||  ((OPT[i-1][j] || OPT[i][j-1]) \\n                            && (p.charAt(j-1) == '*') \\n                            && equals(s, p, i-1, j-2))\\n                        ||  ((p.charAt(j-1) == '*') && (j-2 >= 0) && OPT[i][j-2]);\\n            }\\n        }\\n        \\n        return OPT[m][n];\\n    }\\n    \\n    private boolean equals(String s, String p, int si, int pi) {\\n        return (s.charAt(si) == p.charAt(pi) || p.charAt(pi) == '.');\\n    }\\n\\nBasically, the OPT[i][j] means preceding substring of length i of s and length j of p. For any two substrings, the value of OPT[i][j] can be from one of following four cases:\\n\\n - case 1: OPT[i-1][j-1] is true, and ith character of s is equal to j th character of p. Or j th character of p is '.'\\n - case 2: OPT[i-1][j] is true, then my pattern now is '*' and preceding character is equal to incoming character of s\\n - case 3: OPT[i][j-1] is true, then my pattern now is '*' which can match an empty string\\n - case 4: OPT[i][j-2] is true, and the pattern like (a*) matches an empty string\\n\\nbase case is the OPT[0][0], OPT[i][0], OPT[0][j].",
                "codeTag": "Unknown"
            },
            {
                "id": 2056415,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Python ***\\n\\n```\\n\\n    def isMatch(self, s: str, p: str) -> bool:\\n        s, p = \\' \\'+ s, \\' \\'+ p\\n        lenS, lenP = len(s), len(p)\\n        dp = [[0]*(lenP) for i in range(lenS)]\\n        dp[0][0] = 1\\n\\n        for j in range(1, lenP):\\n            if p[j] == \\'*\\':\\n                dp[0][j] = dp[0][j-2]\\n\\n        for i in range(1, lenS):\\n            for j in range(1, lenP):\\n                if p[j] in {s[i], \\'.\\'}:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j] == \"*\":\\n                    dp[i][j] = dp[i][j-2] or int(dp[i-1][j] and p[j-1] in {s[i], \\'.\\'})\\n\\n        return bool(dp[-1][-1])\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n***\"We are Anonymous. We are legion. We do not forgive. We do not forget. Expect us. Open your eyes..\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\n    def isMatch(self, s: str, p: str) -> bool:\\n        s, p = \\' \\'+ s, \\' \\'+ p\\n        lenS, lenP = len(s), len(p)\\n        dp = [[0]*(lenP) for i in range(lenS)]\\n        dp[0][0] = 1\\n\\n        for j in range(1, lenP):\\n            if p[j] == \\'*\\':\\n                dp[0][j] = dp[0][j-2]\\n\\n        for i in range(1, lenS):\\n            for j in range(1, lenP):\\n                if p[j] in {s[i], \\'.\\'}:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j] == \"*\":\\n                    dp[i][j] = dp[i][j-2] or int(dp[i-1][j] and p[j-1] in {s[i], \\'.\\'})\\n\\n        return bool(dp[-1][-1])\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 691060,
                "title": "c-dp-solution-with-detailed-explanation-and-helpful-pictures",
                "content": "I used to complain that the official article is not explicit and detailed enough. But when I attempt to write a good one, I find it really tough to explain a question very explicitly. I hope this post can help you understand how to use DP to solve this problem. And I am not a native speaker, if my terrible english make you more confused, I would like to to say sorry.\\n\\n**First I want to say the * can\\'t be the first character and two * can\\'t show up continuously in a test case. (This isn\\'t mentioned in the description)**\\n\\nThere is a very intuitive sentence to me in the comment section. One brother said that if we can\\'t come out a DP solution at the interveiw, we can begin at the recursion method. Then we import the memoization in to avoid repeated caculations. Then if we look back what we did, we find we implemented the essence of the top-down DP. Howeve, as for this problem. Especailly under the circumstance that I have already completed \"72 Edit Distance\" and \"161 One Edit Distance\". I am very sure that use the DP table is the best way to solve this problem. But as for this problem, the regulation is a little  difficult to find out. I spent a few time to write down the DP table and succedded to find the key ultimatlely. And I will share my DP table and exhibit some typical example to summarize the three conditions that we can judge the two strings match.\\n\\nFirst of all, we need to declare a doubel demension vector as the DP table. DP[i][j] represents s.substr(0,i-1) matched p.substr(0,j-1) Please pay attention to the index. And some basic skills to implement DP are used in the code. I thought I needn\\'t explain it. \\nLet\\'s throw the light on three key parts in the code.\\n1.s[i-1]==p[j-1],then we check DP[i-1][j-1]\\n\\n2.if DP[i][j-2]==1 and p[j-1]==\"star\" we can assign 1 to DP[i][j]\\nwe can use the character at p[j-2] totally times \\nexample:s=\"aa star\"   p=\"aac star\"\\n\\n3.Then we will go through the most complicated condition\\nwe must use the prosperity of \"star\" and copy the element before \"star\" some times to match string s\\nso we need to check DP[i-1][j]==1\\nand p[j-2]==s[i-1]|| p[j-2]==\".\"**\\n![image](https://assets.leetcode.com/users/tianhao_wang/image_1592354545.png)\\n![image](https://assets.leetcode.com/users/tianhao_wang/image_1592354555.png)\\n![image](https://assets.leetcode.com/users/tianhao_wang/image_1592354561.png)\\n![image](https://assets.leetcode.com/users/tianhao_wang/image_1592354568.png)\\n![image](https://assets.leetcode.com/users/tianhao_wang/image_1592354573.png)\\n![image](https://assets.leetcode.com/users/tianhao_wang/image_1592354578.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int s_size=s.size();\\n        int p_size=p.size();\\n        vector<vector<int>> DP(s_size+1,vector<int>(p_size+1,0));\\n        DP[0][0]=1;\\n        for(int j(2);j<=DP[0].size()-1;j++)\\n        {\\n            if(DP[0][j-2]&&p[j-1]==\\'*\\')\\n            {\\n                DP[0][j]=1;\\n            }\\n        }\\n        for(int i(1);i<=DP.size()-1;i++)\\n        {\\n            for(int j(1);j<=DP[0].size()-1;j++)\\n            {\\n                if(p[j-1] == \\'*\\')\\n                {\\n                    DP[i][j] = DP[i][j-2];//*we use totally 0 character before it\\n                    //so if DP[i][j-2]=1, we can directly assign 1 to DP[i][j] Think about s=\"a\",p=\"ac*\"\\n                    if(p[j-2] == \\'.\\' || p[j-2] == s[i-1])\\n                    {\\n                        if(DP[i-1][j])\\n                        {\\n                            DP[i][j]=1;// we need to use * to copy the element before it\\n                        }\\n                    }\\n                }\\n                else if(p[j-1]==s[i-1]||p[j-1]==\\'.\\')\\n                {\\n                    DP[i][j]=DP[i-1][j-1];\\n                }\\n            }\\n        }\\n        return DP[s_size][p_size]==1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int s_size=s.size();\\n        int p_size=p.size();\\n        vector<vector<int>> DP(s_size+1,vector<int>(p_size+1,0));\\n        DP[0][0]=1;\\n        for(int j(2);j<=DP[0].size()-1;j++)\\n        {\\n            if(DP[0][j-2]&&p[j-1]==\\'*\\')\\n            {\\n                DP[0][j]=1;\\n            }\\n        }\\n        for(int i(1);i<=DP.size()-1;i++)\\n        {\\n            for(int j(1);j<=DP[0].size()-1;j++)\\n            {\\n                if(p[j-1] == \\'*\\')\\n                {\\n                    DP[i][j] = DP[i][j-2];//*we use totally 0 character before it\\n                    //so if DP[i][j-2]=1, we can directly assign 1 to DP[i][j] Think about s=\"a\",p=\"ac*\"\\n                    if(p[j-2] == \\'.\\' || p[j-2] == s[i-1])\\n                    {\\n                        if(DP[i-1][j])\\n                        {\\n                            DP[i][j]=1;// we need to use * to copy the element before it\\n                        }\\n                    }\\n                }\\n                else if(p[j-1]==s[i-1]||p[j-1]==\\'.\\')\\n                {\\n                    DP[i][j]=DP[i-1][j-1];\\n                }\\n            }\\n        }\\n        return DP[s_size][p_size]==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400586,
                "title": "java-recursion-memo-dp-1ms-100",
                "content": "# Recursion (DFS) with Memo (1ms, 100%)\\nTC/SC: O(m*n), where m, n is the length of string and pattern.\\n[1ms submission](https://leetcode.com/submissions/detail/768902786/)\\n```java\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int m = s.length(), n = p.length();\\n        Boolean[][] M = new Boolean[m+1][n]; // Why Boolean: null indicates the sub-problem not processed yet\\n        return dfs(s, p, 0, 0, m, n, M);  // The problem: to match s[i, m), p[j, n)\\n    }\\n\\n    // the sub-problem: to match[i, m\\n    private boolean dfs(String s, String p, int i, int j, int m, int n, Boolean[][] M) {\\n        if (j == n) return i == m;\\n        if (M[i][j] != null) return M[i][j];\\n\\n        char c2 = p.charAt(j);\\n        if (j < n - 1 && p.charAt(j + 1) == \\'*\\')\\n            return M[i][j] = dfs(s, p, i, j+2, m, n, M) || // do not match \\'x*\\' , x means any char or . (use\\'*\\' as 0 char)\\n                    i < m && match(s.charAt(i), c2) && dfs(s, p, i+1, j, m, n, M); // match 1 char in string for \\'*\\'\\n\\n        return M[i][j] = i < m && match(s.charAt(i), c2) && dfs(s, p, i+1, j+1, m, n, M); // match 1 char from both sides\\n    }\\n\\n    private boolean match(char c1, char c2) {\\n        if (c2 == \\'.\\') return true;\\n        return c1 == c2;\\n    }\\n}\\n```\\n\\n# DP, right to left, same as above recursion + memo\\nTC/SC: O(m*n), where m, n is the length of string and pattern.\\n```java\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int m = s.length(), n = p.length();\\n        boolean[][] M = new boolean[m + 1][n + 1];\\n\\n        for (int i = m; i >= 0; i--) for (int j = n; j >= 0; j--)\\n            if(j == n) M[i][j] = i == m;\\n            else if (j + 1 < n && p.charAt(j + 1) == \\'*\\')\\n                M[i][j] = M[i][j + 2] || i < m && match(s.charAt(i), p.charAt(j)) && M[i+1][j];\\n            else // j == cols - 1 || j < cols - 1 && p.charAt(j + 1) != \\'*\\'\\n                M[i][j] = i < m && match(s.charAt(i), p.charAt(j)) && M[i+1][j+1];\\n\\n        return M[0][0];\\n    }\\n\\n    private boolean match(char c1, char c2) {\\n        return c2 == \\'.\\' || c1 == c2;\\n    }\\n}\\n```\\n\\n# dp, left to right, 1ms, 100%\\nTC/SC: O(m*n), where m, n is the length of string and pattern.\\n```java\\nclass Solution {\\n    public boolean isMatch(String str, String ptn) {\\n        if (ptn.equals(\".*\")) return true;\\n        char[] s = str.toCharArray(), p = ptn.toCharArray();\\n        int m = s.length, n = p.length;\\n        \\n         // left to right, add \\'\\' at the beginning, so dp[i+1][j+1] means match s[0, j] vs p[0, j]\\n        boolean[][] dp = new boolean[m+1][n+1];\\n        dp[0][0] = true;\\n        \\n        for (int j = 0; j < n; j++) // fill i = 0\\n            dp[0][j+1] = p[j] == \\'*\\' && dp[0][j-1]; // \"ab\" vs \"a*b*c*\"\\n        \\n        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\\n            if (p[j] == \\'*\\') \\n                dp[i+1][j+1] = dp[i+1][j-1] || // use \\'*\\' as 0 char, check back j-1(j-2 in p)\\n                match(s[i], p[j-1]) && dp[i][j+1]; // use \\'*\\' to match 1 more char, i must match j-1, s[0,i-1] must match p[0,j-1]\\n            else dp[i+1][j+1] = match(s[i], p[j]) && dp[i][j]; // normal match\\n\\n        return dp[m][n];\\n    }\\n    \\n    private boolean match(char a, char b) {\\n        return b == \\'.\\' || b == a;\\n    }\\n}\\n\\n/*\\n      \\'\\'      a      *      b      *      c      *      .\\n\\'\\'[ true, false,  true, false,  true, false,  true, false]\\n a[false,  true,  true, false,  true, false,  true,  true]\\n b[false, false, false,  true,  true, false,  true,  true]\\n x[false, false, false, false, false, false, false,  true]\\n\\n      \\'\\'     m      i      s      *      i      s      *      i      p      *      .\\n\\'\\'[ true, false, false, false, false, false, false, false, false, false, false, false]\\n m[false,  true, false, false, false, false, false, false, false, false, false, false]\\n i[false, false,  true, false,  true, false, false, false, false, false, false, false]\\n s[false, false, false,  true,  true, false, false, false, false, false, false, false]\\n s[false, false, false, false,  true, false, false, false, false, false, false, false]\\n i[false, false, false, false, false,  true, false,  true, false, false, false, false]\\n s[false, false, false, false, false, false,  true,  true, false, false, false, false]\\n s[false, false, false, false, false, false, false,  true, false, false, false, false]\\n i[false, false, false, false, false, false, false, false,  true, false,  true, false]\\n p[false, false, false, false, false, false, false, false, false,  true,  true,  true]\\n p[false, false, false, false, false, false, false, false, false, false,  true,  true]\\n i[false, false, false, false, false, false, false, false, false, false, false,  true]\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int m = s.length(), n = p.length();\\n        Boolean[][] M = new Boolean[m+1][n]; // Why Boolean: null indicates the sub-problem not processed yet\\n        return dfs(s, p, 0, 0, m, n, M);  // The problem: to match s[i, m), p[j, n)\\n    }\\n\\n    // the sub-problem: to match[i, m\\n    private boolean dfs(String s, String p, int i, int j, int m, int n, Boolean[][] M) {\\n        if (j == n) return i == m;\\n        if (M[i][j] != null) return M[i][j];\\n\\n        char c2 = p.charAt(j);\\n        if (j < n - 1 && p.charAt(j + 1) == \\'*\\')\\n            return M[i][j] = dfs(s, p, i, j+2, m, n, M) || // do not match \\'x*\\' , x means any char or . (use\\'*\\' as 0 char)\\n                    i < m && match(s.charAt(i), c2) && dfs(s, p, i+1, j, m, n, M); // match 1 char in string for \\'*\\'\\n\\n        return M[i][j] = i < m && match(s.charAt(i), c2) && dfs(s, p, i+1, j+1, m, n, M); // match 1 char from both sides\\n    }\\n\\n    private boolean match(char c1, char c2) {\\n        if (c2 == \\'.\\') return true;\\n        return c1 == c2;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int m = s.length(), n = p.length();\\n        boolean[][] M = new boolean[m + 1][n + 1];\\n\\n        for (int i = m; i >= 0; i--) for (int j = n; j >= 0; j--)\\n            if(j == n) M[i][j] = i == m;\\n            else if (j + 1 < n && p.charAt(j + 1) == \\'*\\')\\n                M[i][j] = M[i][j + 2] || i < m && match(s.charAt(i), p.charAt(j)) && M[i+1][j];\\n            else // j == cols - 1 || j < cols - 1 && p.charAt(j + 1) != \\'*\\'\\n                M[i][j] = i < m && match(s.charAt(i), p.charAt(j)) && M[i+1][j+1];\\n\\n        return M[0][0];\\n    }\\n\\n    private boolean match(char c1, char c2) {\\n        return c2 == \\'.\\' || c1 == c2;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public boolean isMatch(String str, String ptn) {\\n        if (ptn.equals(\".*\")) return true;\\n        char[] s = str.toCharArray(), p = ptn.toCharArray();\\n        int m = s.length, n = p.length;\\n        \\n         // left to right, add \\'\\' at the beginning, so dp[i+1][j+1] means match s[0, j] vs p[0, j]\\n        boolean[][] dp = new boolean[m+1][n+1];\\n        dp[0][0] = true;\\n        \\n        for (int j = 0; j < n; j++) // fill i = 0\\n            dp[0][j+1] = p[j] == \\'*\\' && dp[0][j-1]; // \"ab\" vs \"a*b*c*\"\\n        \\n        for (int i = 0; i < m; i++) for (int j = 0; j < n; j++)\\n            if (p[j] == \\'*\\') \\n                dp[i+1][j+1] = dp[i+1][j-1] || // use \\'*\\' as 0 char, check back j-1(j-2 in p)\\n                match(s[i], p[j-1]) && dp[i][j+1]; // use \\'*\\' to match 1 more char, i must match j-1, s[0,i-1] must match p[0,j-1]\\n            else dp[i+1][j+1] = match(s[i], p[j]) && dp[i][j]; // normal match\\n\\n        return dp[m][n];\\n    }\\n    \\n    private boolean match(char a, char b) {\\n        return b == \\'.\\' || b == a;\\n    }\\n}\\n\\n/*\\n      \\'\\'      a      *      b      *      c      *      .\\n\\'\\'[ true, false,  true, false,  true, false,  true, false]\\n a[false,  true,  true, false,  true, false,  true,  true]\\n b[false, false, false,  true,  true, false,  true,  true]\\n x[false, false, false, false, false, false, false,  true]\\n\\n      \\'\\'     m      i      s      *      i      s      *      i      p      *      .\\n\\'\\'[ true, false, false, false, false, false, false, false, false, false, false, false]\\n m[false,  true, false, false, false, false, false, false, false, false, false, false]\\n i[false, false,  true, false,  true, false, false, false, false, false, false, false]\\n s[false, false, false,  true,  true, false, false, false, false, false, false, false]\\n s[false, false, false, false,  true, false, false, false, false, false, false, false]\\n i[false, false, false, false, false,  true, false,  true, false, false, false, false]\\n s[false, false, false, false, false, false,  true,  true, false, false, false, false]\\n s[false, false, false, false, false, false, false,  true, false, false, false, false]\\n i[false, false, false, false, false, false, false, false,  true, false,  true, false]\\n p[false, false, false, false, false, false, false, false, false,  true,  true,  true]\\n p[false, false, false, false, false, false, false, false, false, false,  true,  true]\\n i[false, false, false, false, false, false, false, false, false, false, false,  true]\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391997,
                "title": "c-only-one-line",
                "content": "C++ has supported regex since C++11.\\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return regex_match(s,regex(p));\\n    }\\n};\\n```\\nHaHa :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return regex_match(s,regex(p));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5976,
                "title": "share-a-short-java-solution",
                "content": "Since there are just too many C++ and Python solutions here, I shared this solution in case someone need reference for Java.\\n\\n    \\tpublic boolean isMatch(String s, String p) {\\n    \\t\\tif (p.contains(\".\") || p.contains(\"*\")) {\\n    \\t\\t\\tif (p.length() == 1 || p.charAt(1) != '*')\\n    \\t\\t\\t\\treturn comp(s, p, s.length(), 0) && isMatch(s.substring(1), p.substring(1));\\n    \\t\\t\\tfor (int i = 0; i == 0 || comp(s, p, s.length(), i - 1); i++) {\\n    \\t\\t\\t\\tif (isMatch(s.substring(i), p.substring(2)))\\n    \\t\\t\\t\\t\\treturn true;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn s.equals(p);\\n    \\t}\\n    \\n    \\tprivate boolean comp(String s, String p, int sLen, int i) {\\n    \\t\\treturn sLen > i && (p.charAt(0) == s.charAt(i) || p.charAt(0) == '.');\\n    \\t}",
                "solutionTags": [],
                "code": "Since there are just too many C++ and Python solutions here, I shared this solution in case someone need reference for Java.\\n\\n    \\tpublic boolean isMatch(String s, String p) {\\n    \\t\\tif (p.contains(\".\") || p.contains(\"*\")) {\\n    \\t\\t\\tif (p.length() == 1 || p.charAt(1) != '*')\\n    \\t\\t\\t\\treturn comp(s, p, s.length(), 0) && isMatch(s.substring(1), p.substring(1));\\n    \\t\\t\\tfor (int i = 0; i == 0 || comp(s, p, s.length(), i - 1); i++) {\\n    \\t\\t\\t\\tif (isMatch(s.substring(i), p.substring(2)))\\n    \\t\\t\\t\\t\\treturn true;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn s.equals(p);\\n    \\t}\\n    \\n    \\tprivate boolean comp(String s, String p, int sLen, int i) {\\n    \\t\\treturn sLen > i && (p.charAt(0) == s.charAt(i) || p.charAt(0) == '.');\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 292797,
                "title": "rust-with-pattern",
                "content": "This is ridiculously easy with a small parser:\\n\\n```rust\\nimpl Solution {\\n    pub fn is_match(s: String, p: String) -> bool {\\n        is_match(s.as_bytes(), p.as_bytes())\\n    }\\n}\\n\\nfn is_match(s: &[u8], p: &[u8]) -> bool {\\n    match parse(p) {\\n        (Pattern::Empty, _) => s.is_empty(),\\n        (Pattern::Single(c), subp) => is_match_single(s, c, subp),\\n        (Pattern::Repeatable(c), subp) => is_match_single(s, c, p) || is_match(s, subp),\\n    }\\n}\\n\\nfn is_match_single(s: &[u8], to_match: u8, p: &[u8]) -> bool {\\n    match s.split_first() {\\n        Some((c, s)) if to_match == b\\'.\\' || to_match == *c => is_match(s, p),\\n        _ => false,\\n    }\\n}\\n\\n// Parser part:\\n\\nenum Pattern {\\n    Empty,\\n    Single(u8),\\n    Repeatable(u8),\\n}\\n\\n/// Returns the parsed pattern and the next pattern to parse.\\nfn parse(p: &[u8]) -> (Pattern, &[u8]) {\\n    match p.split_first() {\\n        None => (Pattern::Empty, p),\\n        Some((c, p)) => match p.split_first() {\\n            Some((b\\'*\\', p)) => (Pattern::Repeatable(*c), p),\\n            _ => (Pattern::Single(*c), p),\\n        },\\n    }\\n}\\n```\\n\\nThe most concise way top write that would be with the nightly `slice_patterns` feature:\\n\\n```rust\\n#![feature(slice_patterns)]\\n\\nfn is_match(s: &[u8], p: &[u8]) -> bool {\\n    match (p, s) {\\n        ([x, b\\'*\\', subp..], [y, subs..]) if *x == b\\'.\\' || x == y => is_match(subs, p),\\n        ([_, b\\'*\\', subp..], _) => is_match(s, subp),\\n        ([x, subp..], [y, subs..]) if *x == b\\'.\\' || x == y => is_match(subs, subp),\\n        ([], s) => s.is_empty(),\\n        _ => false,\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_match(s: String, p: String) -> bool {\\n        is_match(s.as_bytes(), p.as_bytes())\\n    }\\n}\\n\\nfn is_match(s: &[u8], p: &[u8]) -> bool {\\n    match parse(p) {\\n        (Pattern::Empty, _) => s.is_empty(),\\n        (Pattern::Single(c), subp) => is_match_single(s, c, subp),\\n        (Pattern::Repeatable(c), subp) => is_match_single(s, c, p) || is_match(s, subp),\\n    }\\n}\\n\\nfn is_match_single(s: &[u8], to_match: u8, p: &[u8]) -> bool {\\n    match s.split_first() {\\n        Some((c, s)) if to_match == b\\'.\\' || to_match == *c => is_match(s, p),\\n        _ => false,\\n    }\\n}\\n\\n// Parser part:\\n\\nenum Pattern {\\n    Empty,\\n    Single(u8),\\n    Repeatable(u8),\\n}\\n\\n/// Returns the parsed pattern and the next pattern to parse.\\nfn parse(p: &[u8]) -> (Pattern, &[u8]) {\\n    match p.split_first() {\\n        None => (Pattern::Empty, p),\\n        Some((c, p)) => match p.split_first() {\\n            Some((b\\'*\\', p)) => (Pattern::Repeatable(*c), p),\\n            _ => (Pattern::Single(*c), p),\\n        },\\n    }\\n}\\n```\n```rust\\n#![feature(slice_patterns)]\\n\\nfn is_match(s: &[u8], p: &[u8]) -> bool {\\n    match (p, s) {\\n        ([x, b\\'*\\', subp..], [y, subs..]) if *x == b\\'.\\' || x == y => is_match(subs, p),\\n        ([_, b\\'*\\', subp..], _) => is_match(s, subp),\\n        ([x, subp..], [y, subs..]) if *x == b\\'.\\' || x == y => is_match(subs, subp),\\n        ([], s) => s.is_empty(),\\n        _ => false,\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5810,
                "title": "8ms-backtracking-solution-c",
                "content": "    //regular expression matching\\n    //first solution: using recursive version\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int m = s.length(), n = p.length();\\n            return backtracking(s, m, p, n);\\n        }\\n        \\n        bool backtracking(string& s, int i, string& p, int j) {\\n            if (i == 0 && j == 0) return true;\\n            if (i != 0 && j == 0) return false;\\n            if (i == 0 && j != 0) {\\n                //in this case only p == \"c*c*c*\" this pattern can match null string\\n                if (p[j-1] == '*') {\\n                    return backtracking(s, i, p, j-2);\\n                }\\n                return false;\\n            }\\n            //now both i and j are not null\\n            if (s[i-1] == p[j-1] || p[j-1] == '.') {\\n                return backtracking(s, i - 1, p, j - 1);\\n            } else if (p[j-1] == '*') {\\n                //two cases: determines on whether p[j-2] == s[i-1]\\n                //first p[j-2]* matches zero characters of p\\n                if (backtracking(s, i, p, j - 2)) return true;\\n                //second consider whether p[j-2] == s[i-1], if true, then s[i-1] is matched, move to backtracking(i - 1, j)\\n                if (p[j-2] == s[i-1] || p[j-2] == '.') {\\n                    return backtracking(s, i - 1, p, j);\\n                }\\n                return false;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int m = s.length(), n = p.length();\\n            return backtracking(s, m, p, n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3489574,
                "title": "c-java-python-javascript-easy-dp-solution-with-detailed-explanation-dynamic-programming",
                "content": "\\n# Intuition:\\nThe problem requires to match a given string s with a pattern p. The pattern p can contain two special characters, \\'\\' and \\'.\\'. The \\'\\' matches zero or more of the preceding character and \\'.\\' matches any single character.\\n\\n# Approach:\\nWe can use dynamic programming to solve this problem. Let dp[i][j] be a boolean value representing whether the first i characters of s match the first j characters of p.\\n\\nFirst, we initialize dp[0][0] to true since an empty pattern matches an empty string.\\n\\nNext, we need to consider the first row of the dp matrix. If the pattern p starts with a \\'*\\' then it can match zero occurrences, so we set dp[0][j] to dp[0][j-2] for all j where p[j-1] == \\'*\\'.\\n\\nNow we fill in the remaining cells of the dp matrix using the following rules:\\n\\n1. If the i-1th character of s matches the j-1th character of p or the j-1th character of p is \\'.\\', then dp[i][j] is equal to dp[i-1][j-1].\\n2. If the j-1th character of p is \\'*\\', then we have two cases:\\na) Zero occurrences: dp[i][j] is equal to dp[i][j-2]\\nb) One or more occurrences: dp[i][j] is equal to dp[i-1][j] if the i-1th character of s matches the j-2th character of p or the j-2th character of p is \\'.\\'.\\n\\nFinally, we return dp[m][n], which represents whether the entire string s matches the entire pattern p.\\n# Complexity:\\n- Time Complexity:\\nThe time complexity of the algorithm is O(m * n), where m and n are the lengths of s and p, respectively. This is because we need to fill in the entire dp matrix.\\n\\n- Space Complexity:\\nThe space complexity of the algorithm is also O(m * n) because we need to create a dp matrix of size (m+1) x (n+1).\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size(), n = p.size();\\n        std::vector<std::vector<bool>> dp(m+1, std::vector<bool>(n+1, false));\\n        dp[0][0] = true; // empty pattern matches empty string\\n\\n        // initialize first row (empty string)\\n        for (int j = 1; j <= n; j++) {\\n            if (p[j-1] == \\'*\\')\\n                dp[0][j] = dp[0][j-2];\\n        }\\n\\n        // fill in remaining cells\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s[i-1] == p[j-1] || p[j-1] == \\'.\\') {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else if (p[j-1] == \\'*\\') {\\n                    dp[i][j] = dp[i][j-2]; // zero occurrences\\n                    if (s[i-1] == p[j-2] || p[j-2] == \\'.\\') {\\n                        dp[i][j] = dp[i][j] || dp[i-1][j]; // one or more occurrences\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int m = s.length(), n = p.length();\\n        boolean[][] dp = new boolean[m+1][n+1];\\n        dp[0][0] = true; // empty pattern matches empty string\\n\\n        // initialize first row (empty string)\\n        for (int j = 1; j <= n; j++) {\\n            if (p.charAt(j-1) == \\'*\\')\\n                dp[0][j] = dp[0][j-2];\\n        }\\n\\n        // fill in remaining cells\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == \\'.\\') {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else if (p.charAt(j-1) == \\'*\\') {\\n                    dp[i][j] = dp[i][j-2]; // zero occurrences\\n                    if (s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == \\'.\\') {\\n                        dp[i][j] = dp[i][j] || dp[i-1][j]; // one or more occurrences\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n+1) for _ in range(m+1)]\\n        dp[0][0] = True # empty pattern matches empty string\\n\\n        # initialize first row (empty string)\\n        for j in range(1, n+1):\\n            if p[j-1] == \\'*\\':\\n                dp[0][j] = dp[0][j-2]\\n\\n        # fill in remaining cells\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if s[i-1] == p[j-1] or p[j-1] == \\'.\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i][j-2]\\n                    if s[i-1] == p[j-2] or p[j-2] == \\'.\\':\\n                        dp[i][j] |= dp[i-1][j]\\n\\n        return dp[m][n]\\n\\n```\\n---\\n# JavaScript\\n```\\nvar isMatch = function(s, p) {\\n    const m = s.length, n = p.length;\\n    const dp = new Array(m+1).fill().map(() => new Array(n+1).fill(false));\\n    dp[0][0] = true; // empty pattern matches empty string\\n\\n    // initialize first row (empty string)\\n    for (let j = 1; j <= n; j++) {\\n        if (p[j-1] === \\'*\\')\\n        dp[0][j] = dp[0][j-2];\\n    }\\n\\n    // fill in remaining cells\\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n        if (s[i-1] === p[j-1] || p[j-1] === \\'.\\') {\\n            dp[i][j] = dp[i-1][j-1];\\n        } else if (p[j-1] === \\'*\\') {\\n            dp[i][j] = dp[i][j-2]; // zero occurrences\\n            if (s[i-1] === p[j-2] || p[j-2] === \\'.\\') {\\n            dp[i][j] = dp[i][j] || dp[i-1][j]; // one or more occurrences\\n            }\\n        }\\n        }\\n    }\\n    return dp[m][n];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size(), n = p.size();\\n        std::vector<std::vector<bool>> dp(m+1, std::vector<bool>(n+1, false));\\n        dp[0][0] = true; // empty pattern matches empty string\\n\\n        // initialize first row (empty string)\\n        for (int j = 1; j <= n; j++) {\\n            if (p[j-1] == \\'*\\')\\n                dp[0][j] = dp[0][j-2];\\n        }\\n\\n        // fill in remaining cells\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s[i-1] == p[j-1] || p[j-1] == \\'.\\') {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else if (p[j-1] == \\'*\\') {\\n                    dp[i][j] = dp[i][j-2]; // zero occurrences\\n                    if (s[i-1] == p[j-2] || p[j-2] == \\'.\\') {\\n                        dp[i][j] = dp[i][j] || dp[i-1][j]; // one or more occurrences\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int m = s.length(), n = p.length();\\n        boolean[][] dp = new boolean[m+1][n+1];\\n        dp[0][0] = true; // empty pattern matches empty string\\n\\n        // initialize first row (empty string)\\n        for (int j = 1; j <= n; j++) {\\n            if (p.charAt(j-1) == \\'*\\')\\n                dp[0][j] = dp[0][j-2];\\n        }\\n\\n        // fill in remaining cells\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == \\'.\\') {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else if (p.charAt(j-1) == \\'*\\') {\\n                    dp[i][j] = dp[i][j-2]; // zero occurrences\\n                    if (s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == \\'.\\') {\\n                        dp[i][j] = dp[i][j] || dp[i-1][j]; // one or more occurrences\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n+1) for _ in range(m+1)]\\n        dp[0][0] = True # empty pattern matches empty string\\n\\n        # initialize first row (empty string)\\n        for j in range(1, n+1):\\n            if p[j-1] == \\'*\\':\\n                dp[0][j] = dp[0][j-2]\\n\\n        # fill in remaining cells\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if s[i-1] == p[j-1] or p[j-1] == \\'.\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i][j-2]\\n                    if s[i-1] == p[j-2] or p[j-2] == \\'.\\':\\n                        dp[i][j] |= dp[i-1][j]\\n\\n        return dp[m][n]\\n\\n```\n```\\nvar isMatch = function(s, p) {\\n    const m = s.length, n = p.length;\\n    const dp = new Array(m+1).fill().map(() => new Array(n+1).fill(false));\\n    dp[0][0] = true; // empty pattern matches empty string\\n\\n    // initialize first row (empty string)\\n    for (let j = 1; j <= n; j++) {\\n        if (p[j-1] === \\'*\\')\\n        dp[0][j] = dp[0][j-2];\\n    }\\n\\n    // fill in remaining cells\\n    for (let i = 1; i <= m; i++) {\\n        for (let j = 1; j <= n; j++) {\\n        if (s[i-1] === p[j-1] || p[j-1] === \\'.\\') {\\n            dp[i][j] = dp[i-1][j-1];\\n        } else if (p[j-1] === \\'*\\') {\\n            dp[i][j] = dp[i][j-2]; // zero occurrences\\n            if (s[i-1] === p[j-2] || p[j-2] === \\'.\\') {\\n            dp[i][j] = dp[i][j] || dp[i-1][j]; // one or more occurrences\\n            }\\n        }\\n        }\\n    }\\n    return dp[m][n];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5829,
                "title": "java-4ms-dp-solution-with-o-n-2-time-and-o-n-space-beats-95",
                "content": "The dp algorithm is known by many other solutions. An optimization is to reduce the storage to O(n) with only one row of data. \\n\\n    public boolean isMatch(String s, String p) {\\n\\t\\t\\t/**\\n\\t\\t\\t * This solution is assuming s has no regular expressions.\\n\\t\\t\\t * \\n\\t\\t\\t * dp: res[i][j]=is s[0,...,i-1] matched with p[0,...,j-1];\\n\\t\\t\\t * \\n\\t\\t\\t * If p[j-1]!='*', res[i][j] = res[i-1][j-1] &&\\n\\t\\t\\t * (s[i-1]==p[j-1]||p[j-1]=='.'). Otherwise, res[i][j] is true if\\n\\t\\t\\t * res[i][j-1] or res[i][j-2] or\\n\\t\\t\\t * res[i-1][j]&&(s[i-1]==p[j-2]||p[j-2]=='.'), and notice the third\\n\\t\\t\\t * 'or' case includes the first 'or'.\\n\\t\\t\\t * \\n\\t\\t\\t * \\n\\t\\t\\t * Boundaries: res[0][0]=true;//s=p=\"\". res[i][0]=false, i>0.\\n\\t\\t\\t * res[0][j]=is p[0,...,j-1] empty, j>0, and so res[0][1]=false,\\n\\t\\t\\t * res[0][j]=p[j-1]=='*'&&res[0][j-2].\\n\\t\\t\\t * \\n\\t\\t\\t * O(n) space is enough to store a row of res.\\n\\t\\t\\t */\\n\\n\\t\\t\\tint m = s.length(), n = p.length();\\n\\t\\t\\tboolean[] res = new boolean[n + 1];\\n\\t\\t\\tres[0] = true;\\n\\n\\t\\t\\tint i, j;\\n\\t\\t\\tfor (j = 2; j <= n; j++)\\n\\t\\t\\t\\tres[j] = res[j - 2] && p.charAt(j - 1) == '*';\\n\\n\\t\\t\\tchar pc, sc, tc;\\n\\t\\t\\tboolean pre, cur; // pre=res[i - 1][j - 1], cur=res[i-1][j]\\n\\n\\t\\t\\tfor (i = 1; i <= m; i++) {\\n\\t\\t\\t\\tpre = res[0];\\n\\t\\t\\t\\tres[0] = false;\\n\\t\\t\\t\\tsc = s.charAt(i - 1);\\n\\n\\t\\t\\t\\tfor (j = 1; j <= n; j++) {\\n\\t\\t\\t\\t\\tcur = res[j];\\n\\t\\t\\t\\t\\tpc = p.charAt(j - 1);\\n\\t\\t\\t\\t\\tif (pc != '*')\\n\\t\\t\\t\\t\\t\\tres[j] = pre && (sc == pc || pc == '.');\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t// pc == '*' then it has a preceding char, i.e. j>1\\n\\t\\t\\t\\t\\t\\ttc = p.charAt(j - 2);\\n\\t\\t\\t\\t\\t\\tres[j] = res[j - 2] || (res[j] && (sc == tc || tc == '.'));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tpre = cur;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res[n];\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "The dp algorithm is known by many other solutions. An optimization is to reduce the storage to O(n) with only one row of data. \\n\\n    public boolean isMatch(String s, String p) {\\n\\t\\t\\t/**\\n\\t\\t\\t * This solution is assuming s has no regular expressions.\\n\\t\\t\\t * \\n\\t\\t\\t * dp: res[i][j]=is s[0,...,i-1] matched with p[0,...,j-1];\\n\\t\\t\\t * \\n\\t\\t\\t * If p[j-1]!='*', res[i][j] = res[i-1][j-1] &&\\n\\t\\t\\t * (s[i-1]==p[j-1]||p[j-1]=='.'). Otherwise, res[i][j] is true if\\n\\t\\t\\t * res[i][j-1] or res[i][j-2] or\\n\\t\\t\\t * res[i-1][j]&&(s[i-1]==p[j-2]||p[j-2]=='.'), and notice the third\\n\\t\\t\\t * 'or' case includes the first 'or'.\\n\\t\\t\\t * \\n\\t\\t\\t * \\n\\t\\t\\t * Boundaries: res[0][0]=true;//s=p=\"\". res[i][0]=false, i>0.\\n\\t\\t\\t * res[0][j]=is p[0,...,j-1] empty, j>0, and so res[0][1]=false,\\n\\t\\t\\t * res[0][j]=p[j-1]=='*'&&res[0][j-2].\\n\\t\\t\\t * \\n\\t\\t\\t * O(n) space is enough to store a row of res.\\n\\t\\t\\t */\\n\\n\\t\\t\\tint m = s.length(), n = p.length();\\n\\t\\t\\tboolean[] res = new boolean[n + 1];\\n\\t\\t\\tres[0] = true;\\n\\n\\t\\t\\tint i, j;\\n\\t\\t\\tfor (j = 2; j <= n; j++)\\n\\t\\t\\t\\tres[j] = res[j - 2] && p.charAt(j - 1) == '*';\\n\\n\\t\\t\\tchar pc, sc, tc;\\n\\t\\t\\tboolean pre, cur; // pre=res[i - 1][j - 1], cur=res[i-1][j]\\n\\n\\t\\t\\tfor (i = 1; i <= m; i++) {\\n\\t\\t\\t\\tpre = res[0];\\n\\t\\t\\t\\tres[0] = false;\\n\\t\\t\\t\\tsc = s.charAt(i - 1);\\n\\n\\t\\t\\t\\tfor (j = 1; j <= n; j++) {\\n\\t\\t\\t\\t\\tcur = res[j];\\n\\t\\t\\t\\t\\tpc = p.charAt(j - 1);\\n\\t\\t\\t\\t\\tif (pc != '*')\\n\\t\\t\\t\\t\\t\\tres[j] = pre && (sc == pc || pc == '.');\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t// pc == '*' then it has a preceding char, i.e. j>1\\n\\t\\t\\t\\t\\t\\ttc = p.charAt(j - 2);\\n\\t\\t\\t\\t\\t\\tres[j] = res[j - 2] || (res[j] && (sc == tc || tc == '.'));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tpre = cur;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res[n];\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 5962,
                "title": "c-easy-understanding-implementation",
                "content": "      bool isMatch(string s, string p) {\\n        if (p.empty()) return s.empty();\\n        if (p[1] != '*') {\\n            if(s[0] == p[0] || (p[0] == '.' && s[0] != '\\\\0')) return isMatch(s.substr(1), p.substr(1));\\n            else return false;\\n        } else {\\n            if (isMatch(s, p.substr(2))) return true;\\n            int index = 0;\\n            while (index < s.size() && (s[index] == p[0] || p[0] == '.')) {\\n                if (isMatch(s.substr(++index), p.substr(2))) return true;\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "      bool isMatch(string s, string p) {\\n        if (p.empty()) return s.empty();\\n        if (p[1] != '*') {\\n            if(s[0] == p[0] || (p[0] == '.' && s[0] != '\\\\0')) return isMatch(s.substr(1), p.substr(1));\\n            else return false;\\n        } else {\\n            if (isMatch(s, p.substr(2))) return true;\\n            int index = 0;\\n            while (index < s.size() && (s[index] == p[0] || p[0] == '.')) {\\n                if (isMatch(s.substr(++index), p.substr(2))) return true;\\n            }\\n            return false;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2227054,
                "title": "c-top-down-and-bottom-up-approach",
                "content": "Easy recursive + memoized and bottom up approach.\\n\\n**Recursive + Memoized**\\n```\\nclass Solution {\\npublic:\\n    bool solve(string &s, string &p, int n, int m, vector<vector<int>>&dp){\\n        if(n == 0 && m == 0) return true;\\n        if(m==0 && n!=0) return false;\\n        if(n==0 && m!=0 && p[m-1] == \\'*\\'){\\n            for(int i = m-1; i>=0; i-=2){\\n                if(p[i] != \\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        if(n==0 && m!=0) return false;\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(s[n-1] == p[m-1] || p[m-1] == \\'.\\'){\\n            return dp[n][m] = solve(s,p,n-1,m-1,dp);\\n        }\\n        else if(p[m-1] == \\'*\\'){\\n            if(p[m-2] == s[n-1] || p[m-2] == \\'.\\'){\\n                return dp[n][m] = solve(s,p,n-1,m,dp) || solve(s,p,n,m-2,dp);\\n            }\\n            else{\\n                return dp[n][m] = solve(s,p,n,m-2,dp);\\n            }\\n        }\\n        return dp[n][m] = false;\\n    }\\n    bool isMatch(string s, string p) {\\n        int n = s.length();\\n        int m = p.length();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        return solve(s,p,n,m,dp);\\n    }\\n};\\n```\\n\\n**Tabulation**\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.length();\\n        int m = p.length();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1));\\n        dp[0][0] = 1;\\n        for(int j=1; j<m+1; j++){\\n            if(p[j-1] == \\'*\\'){\\n                dp[0][j] = dp[0][j-2];\\n            }\\n        }\\n        for(int i=1; i<n+1; i++){\\n            dp[i][0] = 0;\\n        }\\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1] == p[j-1] || p[j-1] == \\'.\\'){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }\\n                else if(p[j-1] == \\'*\\'){\\n                    if(p[j-2] == s[i-1] || p[j-2] == \\'.\\'){\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-2];\\n                    }\\n                    else{\\n                        dp[i][j] = dp[i][j-2];\\n                    }\\n                }\\n                else{\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(string &s, string &p, int n, int m, vector<vector<int>>&dp){\\n        if(n == 0 && m == 0) return true;\\n        if(m==0 && n!=0) return false;\\n        if(n==0 && m!=0 && p[m-1] == \\'*\\'){\\n            for(int i = m-1; i>=0; i-=2){\\n                if(p[i] != \\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        if(n==0 && m!=0) return false;\\n        if(dp[n][m] != -1) return dp[n][m];\\n        if(s[n-1] == p[m-1] || p[m-1] == \\'.\\'){\\n            return dp[n][m] = solve(s,p,n-1,m-1,dp);\\n        }\\n        else if(p[m-1] == \\'*\\'){\\n            if(p[m-2] == s[n-1] || p[m-2] == \\'.\\'){\\n                return dp[n][m] = solve(s,p,n-1,m,dp) || solve(s,p,n,m-2,dp);\\n            }\\n            else{\\n                return dp[n][m] = solve(s,p,n,m-2,dp);\\n            }\\n        }\\n        return dp[n][m] = false;\\n    }\\n    bool isMatch(string s, string p) {\\n        int n = s.length();\\n        int m = p.length();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        return solve(s,p,n,m,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.length();\\n        int m = p.length();\\n        vector<vector<int>>dp(n+1,vector<int>(m+1));\\n        dp[0][0] = 1;\\n        for(int j=1; j<m+1; j++){\\n            if(p[j-1] == \\'*\\'){\\n                dp[0][j] = dp[0][j-2];\\n            }\\n        }\\n        for(int i=1; i<n+1; i++){\\n            dp[i][0] = 0;\\n        }\\n        for(int i=1; i<n+1; i++){\\n            for(int j=1; j<m+1; j++){\\n                if(s[i-1] == p[j-1] || p[j-1] == \\'.\\'){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }\\n                else if(p[j-1] == \\'*\\'){\\n                    if(p[j-2] == s[i-1] || p[j-2] == \\'.\\'){\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-2];\\n                    }\\n                    else{\\n                        dp[i][j] = dp[i][j-2];\\n                    }\\n                }\\n                else{\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6018,
                "title": "dp-java-solution-detail-explanation-from-2d-space-to-1d-space",
                "content": "A 2D space DP solution with core comment for you to understand.\\n\\n    public class Solution {\\n        public boolean isMatch(String s, String p) {\\n            // DP\\n            boolean opt[][] = new boolean[s.length()+1][p.length()+1];\\n            // base case\\n            opt[0][0] = true;\\n            boolean valid = false;\\n            for(int j = 2;j <= p.length();j+=2){\\n                if(p.charAt(j-1)=='*'){ valid = true; opt[0][j] = true;}\\n                else{ valid = false;}\\n                if(!valid) break;\\n            }\\n            // iteration\\n            for(int i = 1;i <= s.length();i++){\\n                for(int j = 1;j <= p.length();j++){\\n                    opt[i][j] = false;\\n                    if(s.charAt(i-1)==p.charAt(j-1) || p.charAt(j-1)=='.') opt[i][j] = opt[i-1][j-1];\\n                    else if(p.charAt(j-1)=='*'){\\n                        if(s.charAt(i-1)==p.charAt(j-2) || p.charAt(j-2)=='.')\\n                            opt[i][j] = opt[i-1][j] || opt[i][j-2];\\n                            // opt[i-1][j] do take s[i] to match p[j-1],p[j]\\n                            // opt[i][j-2] don't take s[i] to match p[j-1],p[j]\\n                        else\\n                            opt[i][j] = opt[i][j-2];\\n                            // opt[i][j-2] cannot take s[i] to match p[j-1],p[j]\\n                    }\\n                }\\n            }\\n            return opt[s.length()][p.length()];\\n        }\\n    }\\n\\nAs we can seen, current column will only be affected by previous column or current column itself. Just need a pre[] array to store the previous array.\\n\\n    public class Solution {\\n        public boolean isMatch(String s, String p) {\\n            // DP\\n            boolean opt[] = new boolean[p.length()+1];\\n            boolean pre[] = new boolean[p.length()+1];\\n            // base case\\n            pre[0] = true;\\n            boolean valid = false;\\n            for(int j = 2;j <= p.length();j+=2){\\n                if(p.charAt(j-1)=='*'){ valid = true; pre[j] = true;}\\n                else{ valid = false;}\\n                if(!valid) break;\\n            }\\n            // iteration\\n            for(int i = 1;i <= s.length();i++){\\n                for(int j = 1;j <= p.length();j++){\\n                    opt[j] = false;\\n                    if(s.charAt(i-1)==p.charAt(j-1) || p.charAt(j-1)=='.') opt[j] = pre[j-1];\\n                    else if(p.charAt(j-1)=='*'){\\n                        if(s.charAt(i-1)==p.charAt(j-2) || p.charAt(j-2)=='.')\\n                            opt[j] = pre[j] || opt[j-2];\\n                        else\\n                            opt[j] = opt[j-2];\\n                    }\\n                }\\n                for(int j = 0;j <= p.length();j++)\\n                    pre[j] = opt[j];\\n            }\\n            return pre[p.length()];\\n        }\\n    }\\n\\nAnd the pre[] array can be further eliminated, and only 1D array is used. But using two arrays is more clear.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isMatch(String s, String p) {\\n            // DP\\n            boolean opt[][] = new boolean[s.length()+1][p.length()+1];\\n            // base case\\n            opt[0][0] = true;\\n            boolean valid = false;\\n            for(int j = 2;j <= p.length();j+=2){\\n                if(p.charAt(j-1)=='*'){ valid = true; opt[0][j] = true;}",
                "codeTag": "Java"
            },
            {
                "id": 3243200,
                "title": "beats-98-regular-expression-matching-using-dynamic-programming-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved by using dynamic programming. We can define dp(i, j) as the boolean value indicating whether the substring s[i:] matches the pattern p[j:].\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve the problem by defining a recursive function that tries to match s[i:] with p[j:] for all possible i and j indices. The function should return true if and only if it matches the entire string.\\n\\nTo avoid redundant computation, we can use memoization to store the previously computed results of dp(i, j) in a memo dictionary. The recursive function first checks if the result is already computed in the memo dictionary and returns it if so.\\n\\nIf j reaches the end of p, the function returns true if and only if i also reaches the end of s.\\n\\nIf the next character in p is followed by a \\'\\', the function can match zero or more occurrences of the preceding character. The function recursively tries two cases: either skip the preceding character and the \\'\\', or match the preceding character and recursively try to match the remaining part of s and p. The function returns true if either case succeeds.\\n\\nOtherwise, the function simply checks if the next character in p matches the next character in s or is a dot character (\\'.\\') that matches any character. If so, the function recursively tries to match the remaining part of s and p. The function returns true if both cases succeed.\\n# Complexity\\n- Time complexity: O(SP), where S is the length of the string s and P is the length of the pattern p. The function tries to match each character in s with each character in p at most once and uses memoization to avoid redundant computation.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(SP), where S is the length of the string s and P is the length of the pattern p. The function uses memoization to store the previously computed results of dp(i, j).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        memo = {}\\n    \\n        def dp(i: int, j: int) -> bool:\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n        \\n            if j == len(p):\\n                return i == len(s)\\n        \\n            first_match = i < len(s) and (p[j] == s[i] or p[j] == \\'.\\')\\n        \\n            if j + 1 < len(p) and p[j+1] == \\'*\\':\\n                ans = dp(i, j+2) or (first_match and dp(i+1, j))\\n            else:\\n                ans = first_match and dp(i+1, j+1)\\n        \\n            memo[(i, j)] = ans\\n            return ans\\n    \\n        return dp(0, 0)\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        memo = {}\\n    \\n        def dp(i: int, j: int) -> bool:\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n        \\n            if j == len(p):\\n                return i == len(s)\\n        \\n            first_match = i < len(s) and (p[j] == s[i] or p[j] == \\'.\\')\\n        \\n            if j + 1 < len(p) and p[j+1] == \\'*\\':\\n                ans = dp(i, j+2) or (first_match and dp(i+1, j))\\n            else:\\n                ans = first_match and dp(i+1, j+1)\\n        \\n            memo[(i, j)] = ans\\n            return ans\\n    \\n        return dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5964,
                "title": "java-shortest-dp-solution",
                "content": "    public boolean isMatch(String s, String p) {\\n        boolean[] match = new boolean[s.length()+1];\\n        Arrays.fill(match, false);\\n        match[s.length()] = true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)=='*'){\\n                for(int j=s.length()-1;j>=0;j--)    match[j] = match[j]||match[j+1]&&(p.charAt(i-1)=='.'||s.charAt(j)==p.charAt(i-1));\\n                i--;\\n            }\\n            else{\\n                for(int j=0;j<s.length();j++)   match[j] = match[j+1]&&(p.charAt(i)=='.'||p.charAt(i)==s.charAt(j));\\n                match[s.length()] = false;\\n            }\\n        }\\n        return match[0];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isMatch(String s, String p) {\\n        boolean[] match = new boolean[s.length()+1];\\n        Arrays.fill(match, false);\\n        match[s.length()] = true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)=='*'){\\n                for(int j=s.length()-1;j>=0;j--)    match[j] = match[j]||match[j+1]&&(p.charAt(i-1)=='.'||s.charAt(j)==p.charAt(i-1));\\n                i--;\\n            }\\n            else{\\n                for(int j=0;j<s.length();j++)   match[j] = match[j+1]&&(p.charAt(i)=='.'||p.charAt(i)==s.charAt(j));\\n                match[s.length()] = false;\\n            }\\n        }\\n        return match[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 6006,
                "title": "c-recursive-solution-and-dp-solution",
                "content": "recursive solution:\\n\\n    bool isMatch(const char *s, const char *p) {\\n        if(!*p) return !*s;\\n        if(!*s) return *(p+1)=='*' && isMatch(s, p+2);\\n        if(*(p+1)=='*')\\n            return isMatch(s, p+2) || (*s==*p || *p=='.') && isMatch(s+1, p);\\n        else\\n            return (*s==*p || *p=='.') && isMatch(s+1, p+1);\\n    }\\n\\nDP solution:\\n\\n    bool isMatch(const char *s, const char *p) {\\n        const int m=strlen(s), n=strlen(p);\\n        bool arr[m+1][n+1];\\n        fill_n(*arr, (m+1)*(n+1), false);\\n        arr[0][0]=true;\\n        for(int j=2; j<=n; j+=2)\\n            if(arr[0][j-2] && p[j-1]=='*')\\n                arr[0][j]=true;\\n            else\\n                break;\\n        for(int i=1; i<=m; ++i)\\n            for(int j=1; j<=n; ++j)\\n                if(p[j-1]=='*')\\n                    arr[i][j]=arr[i][j-2] || arr[i-1][j] && (s[i-1]==p[j-2] || p[j-2]=='.');\\n                else\\n                    arr[i][j]=arr[i-1][j-1] && (s[i-1]==p[j-1] || p[j-1]=='.');\\n        return arr[m][n];\\n    }",
                "solutionTags": [],
                "code": "recursive solution:\\n\\n    bool isMatch(const char *s, const char *p) {\\n        if(!*p) return !*s;\\n        if(!*s) return *(p+1)=='*' && isMatch(s, p+2);\\n        if(*(p+1)=='*')\\n            return isMatch(s, p+2) || (*s==*p || *p=='.') && isMatch(s+1, p);\\n        else\\n            return (*s==*p || *p=='.') && isMatch(s+1, p+1);\\n    }\\n\\nDP solution:\\n\\n    bool isMatch(const char *s, const char *p) {\\n        const int m=strlen(s), n=strlen(p);\\n        bool arr[m+1][n+1];\\n        fill_n(*arr, (m+1)*(n+1), false);\\n        arr[0][0]=true;\\n        for(int j=2; j<=n; j+=2)\\n            if(arr[0][j-2] && p[j-1]=='*')\\n                arr[0][j]=true;\\n            else\\n                break;\\n        for(int i=1; i<=m; ++i)\\n            for(int j=1; j<=n; ++j)\\n                if(p[j-1]=='*')\\n                    arr[i][j]=arr[i][j-2] || arr[i-1][j] && (s[i-1]==p[j-2] || p[j-2]=='.');\\n                else\\n                    arr[i][j]=arr[i-1][j-1] && (s[i-1]==p[j-1] || p[j-1]=='.');\\n        return arr[m][n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1366181,
                "title": "c-c-simple-and-short-recursive-solutions-very-few-lines",
                "content": "**C:**\\n```\\nbool match(char* s, char* p) {\\n    return (s[0] == p[0]) || (p[0] == \\'.\\' && s[0]);\\n}\\n\\nbool isMatch(char * s, char * p){\\n    if (!p[0]) return !s[0];\\n    if (p[1] == \\'*\\') return isMatch(s, p+2) || match(s, p) && isMatch(s+1, p);\\n    if (p[0] == \\'.\\') return s[0] && isMatch(s+1, p+1);\\n    return match(s, p) && isMatch(s+1, p+1);\\n}\\n```\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    bool match(int s_idx, int p_idx) {\\n        return (ss[s_idx] == pp[p_idx]) || (pp[p_idx] == \\'.\\' && ss[s_idx]);\\n    }\\n    \\n    bool rec(int s_idx, int p_idx) {\\n        if (!pp[p_idx]) return !ss[s_idx];\\n        if (pp[p_idx+1] == \\'*\\') return rec(s_idx, p_idx+2) || match(s_idx, p_idx) && rec(s_idx+1, p_idx);\\n        if (pp[p_idx] == \\'.\\') return ss[s_idx] && rec(s_idx+1, p_idx+1);\\n        return match(s_idx, p_idx) && rec(s_idx+1, p_idx+1);\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        ss = s, pp = p;\\n        return rec(0, 0);\\n        \\n    }\\n    \\nprivate:\\n    string ss, pp;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool match(char* s, char* p) {\\n    return (s[0] == p[0]) || (p[0] == \\'.\\' && s[0]);\\n}\\n\\nbool isMatch(char * s, char * p){\\n    if (!p[0]) return !s[0];\\n    if (p[1] == \\'*\\') return isMatch(s, p+2) || match(s, p) && isMatch(s+1, p);\\n    if (p[0] == \\'.\\') return s[0] && isMatch(s+1, p+1);\\n    return match(s, p) && isMatch(s+1, p+1);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool match(int s_idx, int p_idx) {\\n        return (ss[s_idx] == pp[p_idx]) || (pp[p_idx] == \\'.\\' && ss[s_idx]);\\n    }\\n    \\n    bool rec(int s_idx, int p_idx) {\\n        if (!pp[p_idx]) return !ss[s_idx];\\n        if (pp[p_idx+1] == \\'*\\') return rec(s_idx, p_idx+2) || match(s_idx, p_idx) && rec(s_idx+1, p_idx);\\n        if (pp[p_idx] == \\'.\\') return ss[s_idx] && rec(s_idx+1, p_idx+1);\\n        return match(s_idx, p_idx) && rec(s_idx+1, p_idx+1);\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        ss = s, pp = p;\\n        return rec(0, 0);\\n        \\n    }\\n    \\nprivate:\\n    string ss, pp;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983676,
                "title": "java-recursive-and-non-dp-solution-1ms-beats-100-explained",
                "content": "My intution - \\n1. Parsing from backwards would make it easy to find `*` and then read the repeating character\\n2. Recursive function would need to know the index which it needs to parse onwards from (from backwards).\\n\\n\\t```\\n\\tboolean isMatch(String s, int i1, String p, int i2)\\n\\t```\\n\\nTermination conditions:\\n1. If both indices points to -1, that means we have found a match\\n2. If we have reached to end of pattern but string is still remaining that means current case is not a match\\n\\nWe can have 3 possible cases\\n\\n1. If both characters match at i1 of s and i2 of p\\n2. Pattern character is `.`\\n\\t* For both 1 and 2 call recusively by decrementing both indices by 1 to try matching remaining strings.\\n3. Pattern character is `*`\\n\\t* For this case read the next character which is the repeating character. It can be a dot or an alphabet. Call recursively for all the cases till the repeating character can be found in the string (in backward direction).\\n\\t* One extra case would be to ignore the applicable character and call recursively to match the remaing pattern.\\n\\nPlease pardon me if there is ambiguity in the above explanation. I am still learning to provide easy to understand explanations.\\n\\n```\\n    public boolean isMatch(String s, String p) {\\n        return isMatch(s, s.length()-1 ,p, p.length()-1);\\n    }\\n    \\n    private boolean isMatch(String s, int i1, String p, int i2)\\n    {\\n        if (i1 == -1 && i2 == -1) return true;\\n        else if (i2 == -1) return false;\\n        \\n        if (i1 >= 0 && (p.charAt(i2) == \\'.\\' || p.charAt(i2) == s.charAt(i1)))\\n        {\\n            return isMatch(s, i1-1, p, i2-1);\\n        }\\n\\t\\telse if (p.charAt(i2) == \\'*\\')\\n        {\\n            char ch = p.charAt(i2-1);\\n            boolean isDot = ch == \\'.\\';\\n\\n\\t\\t\\t// If matching character or dot character try to match remaing string for all possibilities\\n            for (int j = i1; j>=0 && (isDot || s.charAt(j) == ch); j--) \\n            {\\n                if (isMatch(s, j-1, p, i2-2))\\n                    return true;\\n            }\\n\\n            return isMatch(s, i1, p, i2-2); // Extra case where we want to not check the repeating character in s\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tboolean isMatch(String s, int i1, String p, int i2)\\n\\t```\n```\\n    public boolean isMatch(String s, String p) {\\n        return isMatch(s, s.length()-1 ,p, p.length()-1);\\n    }\\n    \\n    private boolean isMatch(String s, int i1, String p, int i2)\\n    {\\n        if (i1 == -1 && i2 == -1) return true;\\n        else if (i2 == -1) return false;\\n        \\n        if (i1 >= 0 && (p.charAt(i2) == \\'.\\' || p.charAt(i2) == s.charAt(i1)))\\n        {\\n            return isMatch(s, i1-1, p, i2-1);\\n        }\\n\\t\\telse if (p.charAt(i2) == \\'*\\')\\n        {\\n            char ch = p.charAt(i2-1);\\n            boolean isDot = ch == \\'.\\';\\n\\n\\t\\t\\t// If matching character or dot character try to match remaing string for all possibilities\\n            for (int j = i1; j>=0 && (isDot || s.charAt(j) == ch); j--) \\n            {\\n                if (isMatch(s, j-1, p, i2-2))\\n                    return true;\\n            }\\n\\n            return isMatch(s, i1, p, i2-2); // Extra case where we want to not check the repeating character in s\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5915,
                "title": "java-solution-o-n-2-dp-with-some-explanations",
                "content": "    public boolean isMatch(String s, String p) {\\n        int sL=s.length(), pL=p.length();\\n        \\n        boolean[][] dp = new boolean[sL+1][pL+1];\\n        dp[0][0] = true; // If s and p are \"\", isMathch() returns true;\\n        \\n        for(int i=0; i<=sL; i++) {\\n            \\n            // j starts from 1, since dp[i][0] is false when i!=0;\\n            for(int j=1; j<=pL; j++) {\\n                char c = p.charAt(j-1);\\n                \\n                if(c != '*') {\\n                    // The last character of s and p should match;\\n                    // And, dp[i-1][j-1] is true;\\n                    dp[i][j] = i>0 && dp[i-1][j-1] && (c=='.' || c==s.charAt(i-1));\\n                }\\n                else {\\n                    // Two situations:\\n                    // (1) dp[i][j-2] is true, and there is 0 preceding element of '*';\\n                    // (2) The last character of s should match the preceding element of '*';\\n                    //     And, dp[i-1][j] should be true;\\n                    dp[i][j] = (j>1 && dp[i][j-2]) ||\\n                               (i>0 && dp[i-1][j] && (p.charAt(j-2)=='.' || p.charAt(j-2)==s.charAt(i-1)));\\n                }\\n            }\\n        }\\n        \\n        return dp[sL][pL];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public boolean isMatch(String s, String p) {\\n        int sL=s.length(), pL=p.length();\\n        \\n        boolean[][] dp = new boolean[sL+1][pL+1];\\n        dp[0][0] = true; // If s and p are \"\", isMathch() returns true;\\n        \\n        for(int i=0; i<=sL; i++) {\\n            \\n            // j starts from 1, since dp[i][0] is false when i!=0;\\n            for(int j=1; j<=pL; j++) {\\n                char c = p.charAt(j-1);\\n                \\n                if(c != '*') {\\n                    // The last character of s and p should match;\\n                    // And, dp[i-1][j-1] is true;\\n                    dp[i][j] = i>0 && dp[i-1][j-1] && (c=='.' || c==s.charAt(i-1));\\n                }\\n                else {\\n                    // Two situations:\\n                    // (1) dp[i][j-2] is true, and there is 0 preceding element of '*';\\n                    // (2) The last character of s should match the preceding element of '*';\\n                    //     And, dp[i-1][j] should be true;\\n                    dp[i][j] = (j>1 && dp[i][j-2]) ||\\n                               (i>0 && dp[i-1][j] && (p.charAt(j-2)=='.' || p.charAt(j-2)==s.charAt(i-1)));\\n                }\\n            }\\n        }\\n        \\n        return dp[sL][pL];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2383634,
                "title": "fastest-solution-explained-0ms-100-o-n-time-complexity-o-n-space-complexity",
                "content": "\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 3.27MB*** (beats 99.04% / 90.42%).\\n* *** Java ***\\n\\n```\\n\\npublic boolean isMatch(String s, String p) {\\n\\t\\t/**\\n\\t\\t * This solution is assuming s has no regular expressions.\\n\\t\\t * \\n\\t\\t * dp: res[i][j]=is s[0,...,i-1] matched with p[0,...,j-1];\\n\\t\\t * \\n\\t\\t * If p[j-1]!=\\'*\\', res[i][j] = res[i-1][j-1] &&\\n\\t\\t * (s[i-1]==p[j-1]||p[j-1]==\\'.\\'). Otherwise, res[i][j] is true if\\n\\t\\t * res[i][j-1] or res[i][j-2] or\\n\\t\\t * res[i-1][j]&&(s[i-1]==p[j-2]||p[j-2]==\\'.\\'), and notice the third\\n\\t\\t * \\'or\\' case includes the first \\'or\\'.\\n\\t\\t * \\n\\t\\t * \\n\\t\\t * Boundaries: res[0][0]=true;//s=p=\"\". res[i][0]=false, i>0.\\n\\t\\t * res[0][j]=is p[0,...,j-1] empty, j>0, and so res[0][1]=false,\\n\\t\\t * res[0][j]=p[j-1]==\\'*\\'&&res[0][j-2].\\n\\t\\t * \\n\\t\\t * O(n) space is enough to store a row of res.\\n\\t\\t */\\n\\n\\t\\tint m = s.length(), n = p.length();\\n\\t\\tboolean[] res = new boolean[n + 1];\\n\\t\\tres[0] = true;\\n\\n\\t\\tint i, j;\\n\\t\\tfor (j = 2; j <= n; j++)\\n\\t\\t\\tres[j] = res[j - 2] && p.charAt(j - 1) == \\'*\\';\\n\\n\\t\\tchar pc, sc, tc;\\n\\t\\tboolean pre, cur; // pre=res[i - 1][j - 1], cur=res[i-1][j]\\n\\n\\t\\tfor (i = 1; i <= m; i++) {\\n\\t\\t\\tpre = res[0];\\n\\t\\t\\tres[0] = false;\\n\\t\\t\\tsc = s.charAt(i - 1);\\n\\n\\t\\t\\tfor (j = 1; j <= n; j++) {\\n\\t\\t\\t\\tcur = res[j];\\n\\t\\t\\t\\tpc = p.charAt(j - 1);\\n\\t\\t\\t\\tif (pc != \\'*\\')\\n\\t\\t\\t\\t\\tres[j] = pre && (sc == pc || pc == \\'.\\');\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t// pc == \\'*\\' then it has a preceding char, i.e. j>1\\n\\t\\t\\t\\t\\ttc = p.charAt(j - 2);\\n\\t\\t\\t\\t\\tres[j] = res[j - 2] || (res[j] && (sc == tc || tc == \\'.\\'));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpre = cur;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res[n];\\n\\t}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 10MB*** (beats 100.00% / 95.49%).\\n* *** Python ***\\n\\n```\\n\\ncache = {}\\ndef isMatch(self, s, p):\\n    if (s, p) in self.cache:\\n        return self.cache[(s, p)]\\n    if not p:\\n        return not s\\n    if p[-1] == \\'*\\':\\n        if self.isMatch(s, p[:-2]):\\n            self.cache[(s, p)] = True\\n            return True\\n        if s and (s[-1] == p[-2] or p[-2] == \\'.\\') and self.isMatch(s[:-1], p):\\n            self.cache[(s, p)] = True\\n            return True\\n    if s and (p[-1] == s[-1] or p[-1] == \\'.\\') and self.isMatch(s[:-1], p[:-1]):\\n        self.cache[(s, p)] = True\\n        return True\\n    self.cache[(s, p)] = False\\n    return False\\n\\n```\\n\\n```\\ndef isMatch(self, s, p):\\n    dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)]\\n    dp[0][0] = True\\n    for i in range(1, len(p)):\\n        dp[i + 1][0] = dp[i - 1][0] and p[i] == \\'*\\'\\n    for i in range(len(p)):\\n        for j in range(len(s)):\\n            if p[i] == \\'*\\':\\n                dp[i + 1][j + 1] = dp[i - 1][j + 1] or dp[i][j + 1]\\n                if p[i - 1] == s[j] or p[i - 1] == \\'.\\':\\n                    dp[i + 1][j + 1] |= dp[i + 1][j]\\n            else:\\n                dp[i + 1][j + 1] = dp[i][j] and (p[i] == s[j] or p[i] == \\'.\\')\\n    return dp[-1][-1]\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 23.7MB*** (beats 59.24% / 60.42%).\\n* *** C++ ***\\n\\n\\nWe can solve the problem using recursion. We need the helper function to keep track of the current indices of the pattern and the string. The basic condition would be when pattern index reaches the end, then we will check if the string index has also reached the end or not.\\n\\nNow we will check if the pattern current index matches the string current index character, this would be true either when the characters are equal i.e. s[i]==p[j] or if the p[j]==\\'.\\' since \\'.\\' can be replaced by any character.\\n\\nIf the next pattern character is \\'\\' that means the current pattern character p[j] could occur 0 or infinite times. So, then there would be two possibility either we can take match the current pattern character with the string and move i by 1 or we can just take zero occurence of the current pattern character and move the pattern character by 2. We will apply the OR condition between these two conditions since if either of them matches then it solves our problem and if next pattern character is not \\'\\' , then we need to check if the current character matches or not and also move both string and pattern character by 1.\\n\\nThe time complexity of this brute force approach is O(3^(max(m,n)) and space complexity is O(max(m,n)) where m and n are the length of pattern and string respectively.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return helper(s,p,0,0);\\n    }\\n    \\n    bool helper(string s, string p, int i, int j)\\n    {\\n        if(j==p.length())\\n            return i==s.length();\\n        bool first_match=(i<s.length() && (s[i]==p[j] || p[j]==\\'.\\' ));\\n        \\n        if(j+1<p.length() && p[j+1]==\\'*\\')\\n        {\\n            return (helper(s,p,i,j+2)|| (first_match && helper(s,p,i+1,j) ));\\n        }\\n        else\\n        {\\n            return (first_match && helper(s,p,i+1,j+1));\\n        }\\n    }\\n};\\n```\\n\\nWe are actually recomputing the solution for the same subproblems many times. So to avoid that we can initialize dp matrix with all values with being -1. Now if dp[i][j]>=0 then that means this has been already computed so we can return the results here only, thus, it saves time and we don\\'t need to recompute that again. Notice that we are saving the results in dp[i][j] in the second last line and this result would always be positive either 0 or 1.\\n\\nThe time complexity is now O(mn) and space complexity is O(mn) where m and n are the length of pattern and string respectively.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length(),-1));\\n        return helper(s,p,0,0,dp);\\n    }\\n    \\n    bool helper(string s, string p, int i, int j,vector<vector<int>> &dp)\\n    {\\n        if(j==p.length())\\n            return i==s.length();\\n        if(dp[i][j]>=0)\\n            return dp[i][j];\\n        bool first_match=(i<s.length() && (s[i]==p[j] || p[j]==\\'.\\' ));\\n        bool ans=0;\\n        if(j+1<p.length() && p[j+1]==\\'*\\')\\n        {\\n            ans= (helper(s,p,i,j+2,dp)|| (first_match && helper(s,p,i+1,j,dp) ));\\n        }\\n        else\\n        {\\n            ans= (first_match && helper(s,p,i+1,j+1,dp));\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n};\\n```\\n\\nBottom up solution\\n\\nWe can derive the bottom up solution from top down approach only. We will make the matrix of length (s.length()+1)* (p.length()+1) . dp[s.length()][p.length()]=1 since both have ended at that point.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n    vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,0));\\n        dp[s.length()][p.length()]=1;\\n        \\n        for(int i=s.length();i>=0;i--)\\n        {\\n            for(int j=p.length()-1;j>=0;j--)\\n            {\\n                bool first_match=(i<s.length() && (p[j]==s[i]|| p[j]==\\'.\\'));\\n                    if(j+1<p.length() && p[j+1]==\\'*\\')\\n                    {\\n                        dp[i][j]=dp[i][j+2] || (first_match && dp[i+1][j]);\\n                    }\\n                else\\n                {\\n                    dp[i][j]=first_match && dp[i+1][j+1];\\n                }\\n            }\\n        }\\n        \\n    return dp[0][0];\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 78MB*** (beats 100.00% / 100.00%).\\n* *** JavaScript ***\\n\\n\\n```\\n\\nfunction isMatch(s, p) {\\n  var lenS = s.length;\\n  var lenP = p.length;\\n  var map = {};\\n\\n  return check(0, 0);\\n\\n  function check(idxS, idxP) {\\n    if (map[idxS + \\':\\' + idxP] !== undefined) return map[idxS + \\':\\' + idxP];\\n    if (idxS > lenS) return false;\\n    if (idxS === lenS && idxP === lenP) return true;\\n\\n    if (p[idxP] === \\'.\\' || p[idxP] === s[idxS]) {\\n      map[idxS + \\':\\' + idxP] = p[idxP + 1] === \\'*\\' ?\\n        check(idxS + 1, idxP) || check(idxS, idxP + 2) :\\n        check(idxS + 1, idxP + 1);\\n    } else {\\n      map[idxS + \\':\\' + idxP] = p[idxP + 1] === \\'*\\' ?\\n        check(idxS, idxP + 2) : false;\\n    }\\n    return map[idxS + \\':\\' + idxP];\\n  }\\n}\\n\\n```\\n\\n```\\nconst isMatch = (string, pattern) => {\\n    // early return when pattern is empty\\n    if (!pattern) {\\n\\t\\t// returns true when string and pattern are empty\\n\\t\\t// returns false when string contains chars with empty pattern\\n        return !string;\\n    }\\n    \\n\\t// check if the current char of the string and pattern match when the string has chars\\n    const hasFirstCharMatch = Boolean(string) && (pattern[0] === \\'.\\' || pattern[0] === string[0]);\\n\\n    // track when the next character * is next in line in the pattern\\n    if (pattern[1] === \\'*\\') {\\n        // if next pattern match (after *) is fine with current string, then proceed with it (s, p+2).  That\\'s because the current pattern may be skipped.\\n        // otherwise check hasFirstCharMatch. That\\'s because if we want to proceed with the current pattern, we must be sure that the current pattern char matches the char\\n\\t\\t// If hasFirstCharMatch is true, then do the recursion with next char and current pattern (s+1, p).  That\\'s because current char matches the pattern char. \\n        return (\\n            isMatch(string, pattern.slice(2)) || \\n            (hasFirstCharMatch && isMatch(string.slice(1), pattern))\\n        );\\n    }\\n    \\n    // now we know for sure that we need to do 2 simple actions\\n\\t// check the current pattern and string chars\\n\\t// if so, then can proceed with next string and pattern chars (s+1, p+1)\\n    return hasFirstCharMatch ? isMatch(string.slice(1), pattern.slice(1)) : false;\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 15.23MB*** (beats 89.94% / 90.99%).\\n* *** Python3 ***\\n\\n\\nIf dp[i][j] == False, it means s[:i] doesn\\'t match p[:j]\\u2028If dp[i][j] == True, it means s[:i] matches p[:j]\\u2028\\'.\\' Matches any single character.\\u2028\\'\\' Matches zero or more of the preceding element.\\u2028s = \"aa\"\\u2028p = \"a\"\\u2028Output: true\\u2028Explanation: \\'*\\' means zero or more of the preceding element, \\'a\\'. Therefore, by repeating \\'a\\' once, it becomes \"aa\".\\n\\n```\\ns = \"aab\"\\np = \"c*a*b\"\\n                 c      *       a      *     b\\ndp = [ \\n         [True, False, True, False, True, False], \\n\\t a  [False, False, False, True, True, False], \\n\\t a  [False, False, False, False, True, False], \\n\\t b\\t[False, False, False, False, False, True]] \\n\\t\\n#  Case 1 p[:j] ==  alphabet or \\'.\\'\\n#  Case 2: p[:j] is \\'*\\'\\n\\t# Case 2a: p[:j-1] doesn\\'t need a \\'*\\' to match the substring s[:i]\\n\\t    #1  p[:j-1] ==s[:i]   dp[i][j] =d[i-1][j]\\n\\t\\t    0  a  *                0   a  a \\n        0                      0\\n        a        T        ---> a\\n        a        T             a         T\\n\\t\\t#2  p[:j-1] == \\'.\\'      dp[i][j]=dp[i][j-2]\\n\\t\\t    0  a  b  *\\n        0  \\n        a     T     T          \\n        \\n\\t# Case 2b: p[:j] needs \\'*\\' to match the substring s[:i]\\n```\\n```\\n # about *:\\n case 1: 0 preceding element\\n case 2: 1 or more preceding element\\n\\t\\t\\t   the preceding element could be a \\'.\\' or an alpharbet.\\n\\t\\t\\t   more proceding element is easy to handle once you use dynamic programming. \\n ```\\n ```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        n = len(s)\\n        m = len(p)\\n        dp = [[False for _ in range (m+1)] for _ in range (n+1)]\\n        dp[0][0] = True\\n        for c in range(1,m+1):\\n            if p[c-1] == \\'*\\' and c > 1:\\n                dp[0][c] = dp[0][c-2]\\n        for r in range(1,n+1):\\n            for c in range(1,m+1):\\n                if p[c-1] == s[r-1] or p[c-1] == \\'.\\':\\n                    dp[r][c] = dp[r-1][c-1]\\n                elif c > 1 and p[c-1] == \\'*\\':\\n                    if  p[c-2] ==\\'.\\' or s[r-1]==p[c-2]:\\n                        dp[r][c] =dp[r][c-2] or dp[r-1][c]\\n                    else:\\n                        dp[r][c] = dp[r][c-2]\\n        return dp[n][m]\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 33.33MB*** (beats 99.00% / 60.12%).\\n* *** Kotlin ***\\n\\n\\n```\\n\\nclass Solution {\\n    fun isMatch(s: String, p: String): Boolean {\\n        return isMatchRecursive(s, p)\\n    }\\n    \\n    fun isMatchRecursive(s: String, p: String): Boolean {\\n        if (p == \"\") return s == \"\"\\n        \\n        if (p.length >= 2 && p[1] == \\'*\\' && s.length > 0 && (s[0] == p[0] || p[0] == \\'.\\')) {\\n            return isMatchRecursive(s.substring(1), p) || isMatchRecursive(s, p.substring(2))\\n        } else if (p.length >= 2 && p[1] == \\'*\\') {\\n            return isMatchRecursive(s, p.substring(2))\\n        }\\n        \\n        return if (s.length > 0) {\\n            if (s[0] == p[0] || p[0] == \\'.\\') {\\n                isMatchRecursive(s.substring(1), p.substring(1))\\n            } else {\\n                false\\n            }\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\n```\\n\\n```\\nclass Solution {\\n    fun isMatch(s: String, p: String): Boolean {\\n        return p.toRegex().matches(s)\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 13.17MB*** (beats 79.34% / 99.92%).\\n* *** Swift ***\\n\\n\\n```\\n\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        \\n        var visit = [[Bool]]()\\n        let sLength = s.count, pCount = p.count\\n        \\n        for _ in 0...sLength + 1 {\\n            visit.append([Bool](repeating: false, count: pCount + 1))\\n        }\\n        \\n        visit[sLength][pCount] = true\\n        \\n        for i in stride(from: sLength, through: 0, by: -1) {\\n            for j in stride(from: pCount - 1, through: 0, by: -1) {\\n                \\n                let arrS = Array(s), arrP = Array(p)\\n                \\n                let first = i < sLength && (arrS[i] == arrP[j] || arrP[j] == \".\")\\n                \\n                if j + 1 < pCount && arrP[j + 1] == \"*\" {\\n                    visit[i][j] = visit[i][j + 2] || first && visit[i + 1][j]\\n                } else {\\n                    visit[i][j] = first && visit[i + 1][j + 1]\\n                }\\n            }\\n        }\\n        return visit[0][0]\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 62.07MB*** (beats 99.99% / 99.99%).\\n* *** PHP ***\\n\\n\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param String $p\\n     * @return Boolean\\n     */\\n    function isMatch($s, $p) {\\n        return preg_match(\"/^{$p}$/\", $s);\\n    }\\n}\\n```\\n\\nHowever, that kinda defeats the point of the exercise, which is to show you can write a regex matcher. So here is my solution.\\n```\\nclass Solution {\\n    \\n    const WILDCARD = \"*\";\\n    const ANY_CHAR = \".\";\\n    \\n    /**\\n     * @param String $string\\n     * @param String $pattern\\n     * @return Boolean\\n     */\\n    function isMatch($string, $pattern) \\n    {\\n        if (!$pattern) {\\n            return !$string;\\n        }\\n        \\n        $matchResult = $string && ($string[0] === $pattern[0] || self::ANY_CHAR === $pattern[0]);\\n        $greedyMatch = !empty($pattern[1]) && $pattern[1] == self::WILDCARD;\\n\\n        if (!$matchResult && !$greedyMatch) {\\n            return false;\\n        }\\n\\n        if ($greedyMatch) {\\n            return ($matchResult && $this->isMatch(substr($string, 1), $pattern)) || $this->isMatch($string, substr($pattern, 2));\\n        }\\n        \\n        return $matchResult && $this->isMatch(substr($string, 1), substr($pattern, 1));\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 1.17MB*** (beats 99.64% / 99.92%).\\n* *** C ***\\n\\n\\n```\\n\\nbool match(char* s, char* p) {\\n    return (s[0] == p[0]) || (p[0] == \\'.\\' && s[0]);\\n}\\n\\nbool isMatch(char * s, char * p){\\n    if (!p[0]) return !s[0];\\n    if (p[1] == \\'*\\') return isMatch(s, p+2) || match(s, p) && isMatch(s+1, p);\\n    if (p[0] == \\'.\\') return s[0] && isMatch(s+1, p+1);\\n    return match(s, p) && isMatch(s+1, p+1);\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\npublic boolean isMatch(String s, String p) {\\n\\t\\t/**\\n\\t\\t * This solution is assuming s has no regular expressions.\\n\\t\\t * \\n\\t\\t * dp: res[i][j]=is s[0,...,i-1] matched with p[0,...,j-1];\\n\\t\\t * \\n\\t\\t * If p[j-1]!=\\'*\\', res[i][j] = res[i-1][j-1] &&\\n\\t\\t * (s[i-1]==p[j-1]||p[j-1]==\\'.\\'). Otherwise, res[i][j] is true if\\n\\t\\t * res[i][j-1] or res[i][j-2] or\\n\\t\\t * res[i-1][j]&&(s[i-1]==p[j-2]||p[j-2]==\\'.\\'), and notice the third\\n\\t\\t * \\'or\\' case includes the first \\'or\\'.\\n\\t\\t * \\n\\t\\t * \\n\\t\\t * Boundaries: res[0][0]=true;//s=p=\"\". res[i][0]=false, i>0.\\n\\t\\t * res[0][j]=is p[0,...,j-1] empty, j>0, and so res[0][1]=false,\\n\\t\\t * res[0][j]=p[j-1]==\\'*\\'&&res[0][j-2].\\n\\t\\t * \\n\\t\\t * O(n) space is enough to store a row of res.\\n\\t\\t */\\n\\n\\t\\tint m = s.length(), n = p.length();\\n\\t\\tboolean[] res = new boolean[n + 1];\\n\\t\\tres[0] = true;\\n\\n\\t\\tint i, j;\\n\\t\\tfor (j = 2; j <= n; j++)\\n\\t\\t\\tres[j] = res[j - 2] && p.charAt(j - 1) == \\'*\\';\\n\\n\\t\\tchar pc, sc, tc;\\n\\t\\tboolean pre, cur; // pre=res[i - 1][j - 1], cur=res[i-1][j]\\n\\n\\t\\tfor (i = 1; i <= m; i++) {\\n\\t\\t\\tpre = res[0];\\n\\t\\t\\tres[0] = false;\\n\\t\\t\\tsc = s.charAt(i - 1);\\n\\n\\t\\t\\tfor (j = 1; j <= n; j++) {\\n\\t\\t\\t\\tcur = res[j];\\n\\t\\t\\t\\tpc = p.charAt(j - 1);\\n\\t\\t\\t\\tif (pc != \\'*\\')\\n\\t\\t\\t\\t\\tres[j] = pre && (sc == pc || pc == \\'.\\');\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t// pc == \\'*\\' then it has a preceding char, i.e. j>1\\n\\t\\t\\t\\t\\ttc = p.charAt(j - 2);\\n\\t\\t\\t\\t\\tres[j] = res[j - 2] || (res[j] && (sc == tc || tc == \\'.\\'));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpre = cur;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res[n];\\n\\t}\\n\\n```\n```\\n```\n```\\n```\n```\\n\\ncache = {}\\ndef isMatch(self, s, p):\\n    if (s, p) in self.cache:\\n        return self.cache[(s, p)]\\n    if not p:\\n        return not s\\n    if p[-1] == \\'*\\':\\n        if self.isMatch(s, p[:-2]):\\n            self.cache[(s, p)] = True\\n            return True\\n        if s and (s[-1] == p[-2] or p[-2] == \\'.\\') and self.isMatch(s[:-1], p):\\n            self.cache[(s, p)] = True\\n            return True\\n    if s and (p[-1] == s[-1] or p[-1] == \\'.\\') and self.isMatch(s[:-1], p[:-1]):\\n        self.cache[(s, p)] = True\\n        return True\\n    self.cache[(s, p)] = False\\n    return False\\n\\n```\n```\\ndef isMatch(self, s, p):\\n    dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)]\\n    dp[0][0] = True\\n    for i in range(1, len(p)):\\n        dp[i + 1][0] = dp[i - 1][0] and p[i] == \\'*\\'\\n    for i in range(len(p)):\\n        for j in range(len(s)):\\n            if p[i] == \\'*\\':\\n                dp[i + 1][j + 1] = dp[i - 1][j + 1] or dp[i][j + 1]\\n                if p[i - 1] == s[j] or p[i - 1] == \\'.\\':\\n                    dp[i + 1][j + 1] |= dp[i + 1][j]\\n            else:\\n                dp[i + 1][j + 1] = dp[i][j] and (p[i] == s[j] or p[i] == \\'.\\')\\n    return dp[-1][-1]\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return helper(s,p,0,0);\\n    }\\n    \\n    bool helper(string s, string p, int i, int j)\\n    {\\n        if(j==p.length())\\n            return i==s.length();\\n        bool first_match=(i<s.length() && (s[i]==p[j] || p[j]==\\'.\\' ));\\n        \\n        if(j+1<p.length() && p[j+1]==\\'*\\')\\n        {\\n            return (helper(s,p,i,j+2)|| (first_match && helper(s,p,i+1,j) ));\\n        }\\n        else\\n        {\\n            return (first_match && helper(s,p,i+1,j+1));\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length(),-1));\\n        return helper(s,p,0,0,dp);\\n    }\\n    \\n    bool helper(string s, string p, int i, int j,vector<vector<int>> &dp)\\n    {\\n        if(j==p.length())\\n            return i==s.length();\\n        if(dp[i][j]>=0)\\n            return dp[i][j];\\n        bool first_match=(i<s.length() && (s[i]==p[j] || p[j]==\\'.\\' ));\\n        bool ans=0;\\n        if(j+1<p.length() && p[j+1]==\\'*\\')\\n        {\\n            ans= (helper(s,p,i,j+2,dp)|| (first_match && helper(s,p,i+1,j,dp) ));\\n        }\\n        else\\n        {\\n            ans= (first_match && helper(s,p,i+1,j+1,dp));\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n    vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,0));\\n        dp[s.length()][p.length()]=1;\\n        \\n        for(int i=s.length();i>=0;i--)\\n        {\\n            for(int j=p.length()-1;j>=0;j--)\\n            {\\n                bool first_match=(i<s.length() && (p[j]==s[i]|| p[j]==\\'.\\'));\\n                    if(j+1<p.length() && p[j+1]==\\'*\\')\\n                    {\\n                        dp[i][j]=dp[i][j+2] || (first_match && dp[i+1][j]);\\n                    }\\n                else\\n                {\\n                    dp[i][j]=first_match && dp[i+1][j+1];\\n                }\\n            }\\n        }\\n        \\n    return dp[0][0];\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\n\\nfunction isMatch(s, p) {\\n  var lenS = s.length;\\n  var lenP = p.length;\\n  var map = {};\\n\\n  return check(0, 0);\\n\\n  function check(idxS, idxP) {\\n    if (map[idxS + \\':\\' + idxP] !== undefined) return map[idxS + \\':\\' + idxP];\\n    if (idxS > lenS) return false;\\n    if (idxS === lenS && idxP === lenP) return true;\\n\\n    if (p[idxP] === \\'.\\' || p[idxP] === s[idxS]) {\\n      map[idxS + \\':\\' + idxP] = p[idxP + 1] === \\'*\\' ?\\n        check(idxS + 1, idxP) || check(idxS, idxP + 2) :\\n        check(idxS + 1, idxP + 1);\\n    } else {\\n      map[idxS + \\':\\' + idxP] = p[idxP + 1] === \\'*\\' ?\\n        check(idxS, idxP + 2) : false;\\n    }\\n    return map[idxS + \\':\\' + idxP];\\n  }\\n}\\n\\n```\n```\\nconst isMatch = (string, pattern) => {\\n    // early return when pattern is empty\\n    if (!pattern) {\\n\\t\\t// returns true when string and pattern are empty\\n\\t\\t// returns false when string contains chars with empty pattern\\n        return !string;\\n    }\\n    \\n\\t// check if the current char of the string and pattern match when the string has chars\\n    const hasFirstCharMatch = Boolean(string) && (pattern[0] === \\'.\\' || pattern[0] === string[0]);\\n\\n    // track when the next character * is next in line in the pattern\\n    if (pattern[1] === \\'*\\') {\\n        // if next pattern match (after *) is fine with current string, then proceed with it (s, p+2).  That\\'s because the current pattern may be skipped.\\n        // otherwise check hasFirstCharMatch. That\\'s because if we want to proceed with the current pattern, we must be sure that the current pattern char matches the char\\n\\t\\t// If hasFirstCharMatch is true, then do the recursion with next char and current pattern (s+1, p).  That\\'s because current char matches the pattern char. \\n        return (\\n            isMatch(string, pattern.slice(2)) || \\n            (hasFirstCharMatch && isMatch(string.slice(1), pattern))\\n        );\\n    }\\n    \\n    // now we know for sure that we need to do 2 simple actions\\n\\t// check the current pattern and string chars\\n\\t// if so, then can proceed with next string and pattern chars (s+1, p+1)\\n    return hasFirstCharMatch ? isMatch(string.slice(1), pattern.slice(1)) : false;\\n};\\n```\n```\\n```\n```\\n```\n```\\ns = \"aab\"\\np = \"c*a*b\"\\n                 c      *       a      *     b\\ndp = [ \\n         [True, False, True, False, True, False], \\n\\t a  [False, False, False, True, True, False], \\n\\t a  [False, False, False, False, True, False], \\n\\t b\\t[False, False, False, False, False, True]] \\n\\t\\n#  Case 1 p[:j] ==  alphabet or \\'.\\'\\n#  Case 2: p[:j] is \\'*\\'\\n\\t# Case 2a: p[:j-1] doesn\\'t need a \\'*\\' to match the substring s[:i]\\n\\t    #1  p[:j-1] ==s[:i]   dp[i][j] =d[i-1][j]\\n\\t\\t    0  a  *                0   a  a \\n        0                      0\\n        a        T        ---> a\\n        a        T             a         T\\n\\t\\t#2  p[:j-1] == \\'.\\'      dp[i][j]=dp[i][j-2]\\n\\t\\t    0  a  b  *\\n        0  \\n        a     T     T          \\n        \\n\\t# Case 2b: p[:j] needs \\'*\\' to match the substring s[:i]\\n```\n```\\n # about *:\\n case 1: 0 preceding element\\n case 2: 1 or more preceding element\\n\\t\\t\\t   the preceding element could be a \\'.\\' or an alpharbet.\\n\\t\\t\\t   more proceding element is easy to handle once you use dynamic programming. \\n ```\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        n = len(s)\\n        m = len(p)\\n        dp = [[False for _ in range (m+1)] for _ in range (n+1)]\\n        dp[0][0] = True\\n        for c in range(1,m+1):\\n            if p[c-1] == \\'*\\' and c > 1:\\n                dp[0][c] = dp[0][c-2]\\n        for r in range(1,n+1):\\n            for c in range(1,m+1):\\n                if p[c-1] == s[r-1] or p[c-1] == \\'.\\':\\n                    dp[r][c] = dp[r-1][c-1]\\n                elif c > 1 and p[c-1] == \\'*\\':\\n                    if  p[c-2] ==\\'.\\' or s[r-1]==p[c-2]:\\n                        dp[r][c] =dp[r][c-2] or dp[r-1][c]\\n                    else:\\n                        dp[r][c] = dp[r][c-2]\\n        return dp[n][m]\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\n    fun isMatch(s: String, p: String): Boolean {\\n        return isMatchRecursive(s, p)\\n    }\\n    \\n    fun isMatchRecursive(s: String, p: String): Boolean {\\n        if (p == \"\") return s == \"\"\\n        \\n        if (p.length >= 2 && p[1] == \\'*\\' && s.length > 0 && (s[0] == p[0] || p[0] == \\'.\\')) {\\n            return isMatchRecursive(s.substring(1), p) || isMatchRecursive(s, p.substring(2))\\n        } else if (p.length >= 2 && p[1] == \\'*\\') {\\n            return isMatchRecursive(s, p.substring(2))\\n        }\\n        \\n        return if (s.length > 0) {\\n            if (s[0] == p[0] || p[0] == \\'.\\') {\\n                isMatchRecursive(s.substring(1), p.substring(1))\\n            } else {\\n                false\\n            }\\n        } else {\\n            false\\n        }\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    fun isMatch(s: String, p: String): Boolean {\\n        return p.toRegex().matches(s)\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        \\n        var visit = [[Bool]]()\\n        let sLength = s.count, pCount = p.count\\n        \\n        for _ in 0...sLength + 1 {\\n            visit.append([Bool](repeating: false, count: pCount + 1))\\n        }\\n        \\n        visit[sLength][pCount] = true\\n        \\n        for i in stride(from: sLength, through: 0, by: -1) {\\n            for j in stride(from: pCount - 1, through: 0, by: -1) {\\n                \\n                let arrS = Array(s), arrP = Array(p)\\n                \\n                let first = i < sLength && (arrS[i] == arrP[j] || arrP[j] == \".\")\\n                \\n                if j + 1 < pCount && arrP[j + 1] == \"*\" {\\n                    visit[i][j] = visit[i][j + 2] || first && visit[i + 1][j]\\n                } else {\\n                    visit[i][j] = first && visit[i + 1][j + 1]\\n                }\\n            }\\n        }\\n        return visit[0][0]\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param String $p\\n     * @return Boolean\\n     */\\n    function isMatch($s, $p) {\\n        return preg_match(\"/^{$p}$/\", $s);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    const WILDCARD = \"*\";\\n    const ANY_CHAR = \".\";\\n    \\n    /**\\n     * @param String $string\\n     * @param String $pattern\\n     * @return Boolean\\n     */\\n    function isMatch($string, $pattern) \\n    {\\n        if (!$pattern) {\\n            return !$string;\\n        }\\n        \\n        $matchResult = $string && ($string[0] === $pattern[0] || self::ANY_CHAR === $pattern[0]);\\n        $greedyMatch = !empty($pattern[1]) && $pattern[1] == self::WILDCARD;\\n\\n        if (!$matchResult && !$greedyMatch) {\\n            return false;\\n        }\\n\\n        if ($greedyMatch) {\\n            return ($matchResult && $this->isMatch(substr($string, 1), $pattern)) || $this->isMatch($string, substr($pattern, 2));\\n        }\\n        \\n        return $matchResult && $this->isMatch(substr($string, 1), substr($pattern, 1));\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\n\\nbool match(char* s, char* p) {\\n    return (s[0] == p[0]) || (p[0] == \\'.\\' && s[0]);\\n}\\n\\nbool isMatch(char * s, char * p){\\n    if (!p[0]) return !s[0];\\n    if (p[1] == \\'*\\') return isMatch(s, p+2) || match(s, p) && isMatch(s+1, p);\\n    if (p[0] == \\'.\\') return s[0] && isMatch(s+1, p+1);\\n    return match(s, p) && isMatch(s+1, p+1);\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242255,
                "title": "c-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f(int i,int j,string &s,string &p)\\n    { \\n        if(i<0 && j<0) return true;   //Both Strings Exhausted\\n        if(j<0 && i>=0) return false;  //p exhausted but s is remaining\\n        if(i<0 && j>=0)  //if s is exhausted by p remains , it will only be true if all charcter in p have *;\\n        {\\n            while(j>=0)\\n            {\\n                if(p[j]==\\'*\\') j-=2;\\n                else return false;\\n            }\\n            return true;\\n        }\\n        \\n        if(p[j]==s[i] || p[j]==\\'.\\') return f(i-1,j-1,s,p);\\n        \\n        if(p[j]==\\'*\\')\\n        {\\n            if(p[j-1]!=s[i] && p[j-1]!=\\'.\\')\\n                return f(i,j-2,s,p);  //Consider * to be empty\\n            else\\n            {\\n                return f(i,j-2,s,p) || f(i-1,j,s,p); \\n                //These three case are as follows\\n                //consider * empty\\n                //consider * length>=1\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        return f(n-1,m-1,s,p);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int i,int j,string &s,string &p)\\n    { \\n        if(i<0 && j<0) return true;   //Both Strings Exhausted\\n        if(j<0 && i>=0) return false;  //p exhausted but s is remaining\\n        if(i<0 && j>=0)  //if s is exhausted by p remains , it will only be true if all charcter in p have *;\\n        {\\n            while(j>=0)\\n            {\\n                if(p[j]==\\'*\\') j-=2;\\n                else return false;\\n            }\\n            return true;\\n        }\\n        \\n        if(p[j]==s[i] || p[j]==\\'.\\') return f(i-1,j-1,s,p);\\n        \\n        if(p[j]==\\'*\\')\\n        {\\n            if(p[j-1]!=s[i] && p[j-1]!=\\'.\\')\\n                return f(i,j-2,s,p);  //Consider * to be empty\\n            else\\n            {\\n                return f(i,j-2,s,p) || f(i-1,j,s,p); \\n                //These three case are as follows\\n                //consider * empty\\n                //consider * length>=1\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        return f(n-1,m-1,s,p);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575404,
                "title": "recursive-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool fun(string s,string p,int i,int j){\\n        if(i==-1 && j==-1) return true;\\n        if(i!=-1 && j==-1) return false;\\n        if(i==-1 && j!=-1){\\n            if(p[j]==\\'*\\') return fun(s,p,i,j-2);\\n            else{\\n                return false;\\n            }\\n        }\\n        else{\\n            if(s[i]==p[j] || p[j]==\\'.\\') return fun(s,p,i-1,j-1);\\n            else if(p[j]==\\'*\\'){\\n                if(s[i]==p[j-1] || p[j-1]==\\'.\\') return fun(s,p,i-1,j) || fun(s,p,i,j-2);\\n                else{\\n                    return fun(s,p,i,j-2);\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        return fun(s,p,s.size()-1,p.size()-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool fun(string s,string p,int i,int j){\\n        if(i==-1 && j==-1) return true;\\n        if(i!=-1 && j==-1) return false;\\n        if(i==-1 && j!=-1){\\n            if(p[j]==\\'*\\') return fun(s,p,i,j-2);\\n            else{\\n                return false;\\n            }\\n        }\\n        else{\\n            if(s[i]==p[j] || p[j]==\\'.\\') return fun(s,p,i-1,j-1);\\n            else if(p[j]==\\'*\\'){\\n                if(s[i]==p[j-1] || p[j-1]==\\'.\\') return fun(s,p,i-1,j) || fun(s,p,i,j-2);\\n                else{\\n                    return fun(s,p,i,j-2);\\n                }\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        return fun(s,p,s.size()-1,p.size()-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295184,
                "title": "20-line-state-machine-solution-no-dp-beats-99-7",
                "content": "inspired by this solution for wildcard matching: https://leetcode.com/problems/wildcard-matching/discuss/138878/Finite-state-machine-with-Python-and-dictionary.-13-lines-O(p%2Bs)-time\\n\\n```\\nfrom collections import defaultdict\\ndef isMatch(self, s, p):\\n\\ttransfer = defaultdict(set)\\n\\tcurr_states = [0]\\n\\tfor i,c in enumerate(p):\\n\\t\\tif c==\\'*\\': continue\\n\\t\\tnew_state = curr_states[-1] + 1\\n\\t\\tfor state in curr_states:\\n\\t\\t\\ttransfer[state, c].add(new_state)\\n\\t\\tif i < len(p) - 1 and p[i + 1] == \\'*\\':  # if next c is *\\n\\t\\t\\ttransfer[new_state, c] = {new_state}\\n\\t\\t\\tcurr_states.append(new_state)\\n\\t\\telse:\\n\\t\\t\\tcurr_states = [new_state]\\n\\n\\tsuccess = curr_states  # final states\\n\\tcurr_states = {0}\\n\\tfor c in s:\\n\\t\\tnext_states = set()\\n\\t\\tfor state in curr_states:\\n\\t\\t\\tnext_states.update(transfer[state, c] | transfer[state, \\'.\\'])\\n\\t\\tcurr_states = next_states\\n\\t\\t\\n\\treturn any(state in curr_states for state in success)  # check any curr_states is success\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\ndef isMatch(self, s, p):\\n\\ttransfer = defaultdict(set)\\n\\tcurr_states = [0]\\n\\tfor i,c in enumerate(p):\\n\\t\\tif c==\\'*\\': continue\\n\\t\\tnew_state = curr_states[-1] + 1\\n\\t\\tfor state in curr_states:\\n\\t\\t\\ttransfer[state, c].add(new_state)\\n\\t\\tif i < len(p) - 1 and p[i + 1] == \\'*\\':  # if next c is *\\n\\t\\t\\ttransfer[new_state, c] = {new_state}\\n\\t\\t\\tcurr_states.append(new_state)\\n\\t\\telse:\\n\\t\\t\\tcurr_states = [new_state]\\n\\n\\tsuccess = curr_states  # final states\\n\\tcurr_states = {0}\\n\\tfor c in s:\\n\\t\\tnext_states = set()\\n\\t\\tfor state in curr_states:\\n\\t\\t\\tnext_states.update(transfer[state, c] | transfer[state, \\'.\\'])\\n\\t\\tcurr_states = next_states\\n\\t\\t\\n\\treturn any(state in curr_states for state in success)  # check any curr_states is success\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 5879,
                "title": "python-dp-solution-with-detailed-comments",
                "content": "    class Solution(object):\\n        def isMatch(self, s, p):\\n            \"\"\"\\n            :type s: str\\n            :type p: str\\n            :rtype: bool\\n            \"\"\"\\n            #O(NM) time, O(NM) space\\n            n, m = len(s), len(p)\\n            match = [[False for j in xrange(m + 1)] for i in xrange(n + 1)]\\n            \\n            #Base cases - empty string matches w/ empty pattern\\n            match[0][0] = True\\n            \\n            #empty string to nonempty pattern\\n            for i in xrange(1, m + 1):\\n                if i > 1 and p[i - 1] == '*':\\n                    match[0][i] = match[0][i - 2]\\n                        \\n            #DP cases\\n            for i in xrange(1, n + 1):\\n                for j in xrange(1, m + 1):\\n                    #If the string char equals the pattern char or the pattern is a dot,  \\n                    #there is a match if everything before matches\\n                    if p[j - 1] == '.' or p[j - 1] == s[i - 1]:\\n                        match[i][j] = match[i - 1][j - 1]\\n                    #Star can only match if there is something before the star to match\\n                    elif j > 1 and p[j - 1] == '*':\\n                        #If the character before the star matches char in the string,\\n                        #the star can match 0 of the char before it, or at least 1.\\n                        #match[i][j-2] is for matching 0, cause we need to skip the last 2\\n                        #characters in the pattern. match[i - 1][j] is for matching 1, cause\\n                        #we need to skip 1 character in the string, but keep the entire pattern\\n                        if p[j - 2] == s[i - 1] or p[j - 2] == '.':\\n                            match[i][j] = match[i][j - 2] or match[i - 1][j]\\n                        #If the character before the star does not match the char in the string,\\n                        #then the only way to get a match is if the star matches 0 characters\\n                        else:\\n                            match[i][j] = match[i][j - 2]\\n                            \\n            return match[n][m]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    class Solution(object):\\n        def isMatch(self, s, p):\\n            \"\"\"\\n            :type s: str\\n            :type p: str\\n            :rtype: bool\\n            \"\"\"\\n            #O(NM) time, O(NM) space\\n            n, m = len(s), len(p)\\n            match = [[False for j in xrange(m + 1)] for i in xrange(n + 1)]\\n            \\n            #Base cases - empty string matches w/ empty pattern\\n            match[0][0] = True\\n            \\n            #empty string to nonempty pattern\\n            for i in xrange(1, m + 1):\\n                if i > 1 and p[i - 1] == '*':\\n                    match[0][i] = match[0][i - 2]\\n                        \\n            #DP cases\\n            for i in xrange(1, n + 1):\\n                for j in xrange(1, m + 1):\\n                    #If the string char equals the pattern char or the pattern is a dot,  \\n                    #there is a match if everything before matches\\n                    if p[j - 1] == '.' or p[j - 1] == s[i - 1]:\\n                        match[i][j] = match[i - 1][j - 1]\\n                    #Star can only match if there is something before the star to match\\n                    elif j > 1 and p[j - 1] == '*':\\n                        #If the character before the star matches char in the string,\\n                        #the star can match 0 of the char before it, or at least 1.\\n                        #match[i][j-2] is for matching 0, cause we need to skip the last 2\\n                        #characters in the pattern. match[i - 1][j] is for matching 1, cause\\n                        #we need to skip 1 character in the string, but keep the entire pattern\\n                        if p[j - 2] == s[i - 1] or p[j - 2] == '.':\\n                            match[i][j] = match[i][j - 2] or match[i - 1][j]\\n                        #If the character before the star does not match the char in the string,\\n                        #then the only way to get a match is if the star matches 0 characters\\n                        else:\\n                            match[i][j] = match[i][j - 2]\\n                            \\n            return match[n][m]",
                "codeTag": "Java"
            },
            {
                "id": 5778,
                "title": "my-dfa-deterministic-finite-automata-java-codes",
                "content": "regular expression is the expression of regregular language, and regregular language can be expressed by  a DFA. I notice that nothing about DFA is talked about in the discuss,so I think I should post my codes to raise this topic.\\n\\nDuring building the DFA, there's a small trick to make the code clean.\\n![enter image description here][1]\\n\\n    import java.util.List;\\n    import java.util.ArrayList;\\n    \\n    public class Solution {\\n        String input;\\n        public boolean isMatch(String s, String p) {\\n            input=s;\\n            \\n            //----------building DFA------------\\n            Node start=new Node();\\n            Node pre=start;\\n            \\n            int i=0;\\n            while(i<p.length()){\\n                if(i+1<p.length() && p.charAt(i+1)=='*'){\\n                    Node n1=new Node();\\n                    Node n2=new Node();\\n                    pre.addEdge(new Edge(null,n1));\\n                    pre.addEdge(new Edge(null,n2));\\n                    n1.addEdge(new Edge(p.charAt(i),n1));\\n                    n1.addEdge(new Edge(p.charAt(i),n2));\\n                    pre=n2;\\n                    i+=2;\\n                }\\n                else{\\n                    Node n=new Node();\\n                    pre.addEdge(new Edge(p.charAt(i),n));\\n                    pre=n;\\n                    i++;\\n                }\\n            }\\n            pre.isEnd=true;\\n            \\n            //----------walking DFA-------------\\n            \\n            return walk(start,0);\\n        }\\n        \\n        private boolean walk(Node n,int begin){\\n            if(begin==input.length()){\\n                if(n.isEnd) return true;\\n                else if(n.edges.size()==0) return false;\\n            } \\n                \\n            for(Edge e:n.edges){\\n                if(e.take==null) {if(walk(e.to,begin)) return true;}\\n                else if(begin<input.length() && e.take=='.') {if(walk(e.to,begin+1)) return true;}\\n                else{\\n                    if(begin<input.length() && e.take==input.charAt(begin)) {if(walk(e.to,begin+1)) return true;}\\n                    else continue;\\n                }\\n            }\\n            return false;\\n        }\\n        \\n        //-------------below are just some datastruct to implement DFA-------------\\n        \\n        private class Node{\\n            List<Edge> edges;\\n            boolean isEnd;\\n            \\n            Node(){\\n                edges=new ArrayList<Edge>();\\n            }\\n            \\n            void addEdge(Edge e){\\n                this.edges.add(e);\\n            }\\n        }\\n        \\n        private class Edge{\\n            Character take;\\n            Node to;\\n            \\n            Edge(Character c,Node n){\\n                this.take=c;\\n                this.to=n;\\n            }\\n        }\\n    }\\n\\n\\n  [1]:http://ww1.sinaimg.cn/mw690/993e995cgw1er6mbyuvmjj20u20fdjs3.jpg",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        String input;\\n        public boolean isMatch(String s, String p) {\\n            input=s;\\n            \\n            //----------building DFA------------\\n            Node start=new Node();\\n            Node pre=start;\\n            \\n            int i=0;\\n            while(i<p.length()){\\n                if(i+1<p.length() && p.charAt(i+1)=='*'){\\n                    Node n1=new Node();\\n                    Node n2=new Node();\\n                    pre.addEdge(new Edge(null,n1));\\n                    pre.addEdge(new Edge(null,n2));\\n                    n1.addEdge(new Edge(p.charAt(i),n1));\\n                    n1.addEdge(new Edge(p.charAt(i),n2));\\n                    pre=n2;\\n                    i+=2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 414658,
                "title": "nfa-simulation-in-python",
                "content": "# Viewing the expression as an NFA\\n\\nThe regular expression `a*b.*c.` is equivalent to the non-deterministic finite automaton (NFA) depicted here:\\n\\n![image](https://assets.leetcode.com/users/lxnn/image_1572191696.png)\\n\\nFor those that don\\'t know how to interpret this:\\n* Start at the beginning of the string, and at node `0`, then follow the arrows.\\n* Each time you follow an arrow consume a character of the string (if the chracter matches the arrow label). If the label is an epsilon (`\\u03B5`) then you may follow that arrow without consuming a character.\\n* The string is a match if you can reach the final node (`5`) with no characters left to consume.\\n\\nThe phrase \\'non-deterministic\\' in this context just means that you may have more than one arrow to choose from at each step. For example, if you are at node `0` and the next character is an `a`, you have the choice to consume the `a` and stay at node `0`, or to move to node `1` without consuming any chars. In a deterministic finite automaton (DFA) there would be only one choice of arrow at each step.\\n\\nWe can turn the provided regular expression into an NFA like the one above:\\n* `\\'a*\\'` becomes:\\n![image](https://assets.leetcode.com/users/lxnn/image_1572200709.png)\\n\\n* `\\'a\\'` becomes:\\n![image](https://assets.leetcode.com/users/lxnn/image_1572200700.png)\\n\\n\\n<hr \\\\>\\n\\n# The Algorithm\\n\\nWith a DFA it\\'s easy to evaluate a match: you consume the string one character at a time keeping track of the current node. With an NFA, this evaluation procedure doesn\\'t work as you might end up at any one of a number of different nodes.\\n\\nWhile you can convert an NFA to a DFA, which can be evaluated efficiently, this isn\\'t helpful if you only plan to use the automaton once. The alternative is to evaluate the NFA as you would a DFA, but keep track of all the nodes you could be at at each step.\\n\\nThis is effectively a search problem, where the search state is `(Number of Chars Consumed, Current Node)`. If we encounter the same search state twice, there\\'s no point searching from it again, so we keep a hash table of the nodes we\\'ve seen.\\n\\n```python\\nfrom typing import NamedTuple\\n\\ndef match(pattern, string):\\n\\n    class Node(NamedTuple):\\n        star:   bool\\n        char:   str\\n\\n    class SearchState(NamedTuple):\\n        chars_consumed: int\\n        node_number:    int\\n\\n    # Get the node list\\n    nodes = []\\n    for (i, char) in enumerate(pattern):\\n        if char == \\'*\\':\\n            continue\\n        if i+1 < len(pattern) and pattern[i+1] == \\'*\\':\\n            nodes.append(Node(star=True, char=char))\\n        else:\\n            nodes.append(Node(star=False, char=char))\\n\\n    def expand(state):\\n        \"Yield all the successors to the state.\"\\n        if state.node_number == len(nodes):\\n            return\\n        node = nodes[state.node_number]\\n        if node.star:\\n\\t\\t    yield SearchState(\\n                state.chars_consumed,\\n                state.node_number + 1\\n            )\\n        if state.chars_consumed < len(string):\\n            current_char = string[state.chars_consumed]\\n            if node.char == \\'.\\' or current_char == node.char:\\n                yield SearchState(\\n                    state.chars_consumed + 1,\\n                    state.node_number + (0 if node.star else 1)\\n                )\\n\\n    # Perform the search\\n    seen = set()\\n    final_state = SearchState(\\n        chars_consumed  = len(string), \\n        node_number     = len(nodes)\\n    )\\n    initial_state = SearchState(0, 0)\\n    stack = [initial_state]\\n    while stack:\\n        state = stack.pop()\\n        if state == final_state:\\n            return True\\n        for next_state in expand(state):\\n            if next_state not in seen:\\n                stack.append(next_state)\\n                seen.add(next_state)\\n    return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom typing import NamedTuple\\n\\ndef match(pattern, string):\\n\\n    class Node(NamedTuple):\\n        star:   bool\\n        char:   str\\n\\n    class SearchState(NamedTuple):\\n        chars_consumed: int\\n        node_number:    int\\n\\n    # Get the node list\\n    nodes = []\\n    for (i, char) in enumerate(pattern):\\n        if char == \\'*\\':\\n            continue\\n        if i+1 < len(pattern) and pattern[i+1] == \\'*\\':\\n            nodes.append(Node(star=True, char=char))\\n        else:\\n            nodes.append(Node(star=False, char=char))\\n\\n    def expand(state):\\n        \"Yield all the successors to the state.\"\\n        if state.node_number == len(nodes):\\n            return\\n        node = nodes[state.node_number]\\n        if node.star:\\n\\t\\t    yield SearchState(\\n                state.chars_consumed,\\n                state.node_number + 1\\n            )\\n        if state.chars_consumed < len(string):\\n            current_char = string[state.chars_consumed]\\n            if node.char == \\'.\\' or current_char == node.char:\\n                yield SearchState(\\n                    state.chars_consumed + 1,\\n                    state.node_number + (0 if node.star else 1)\\n                )\\n\\n    # Perform the search\\n    seen = set()\\n    final_state = SearchState(\\n        chars_consumed  = len(string), \\n        node_number     = len(nodes)\\n    )\\n    initial_state = SearchState(0, 0)\\n    stack = [initial_state]\\n    while stack:\\n        state = stack.pop()\\n        if state == final_state:\\n            return True\\n        for next_state in expand(state):\\n            if next_state not in seen:\\n                stack.append(next_state)\\n                seen.add(next_state)\\n    return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366219,
                "title": "python3-dynamic-programming",
                "content": "If dp[i][j] == False, it means s[:i] doesn\\'t match p[:j]\\nIf dp[i][j] == True, it means s[:i] matches p[:j]\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\ns = \"aa\"\\np = \"a*\"\\nOutput: true\\nExplanation: \\'*\\' means zero or more of the preceding element, \\'a\\'. Therefore, by repeating \\'a\\' once, it becomes \"aa\".\\n```\\ns = \"aab\"\\np = \"c*a*b\"\\n                 c      *       a      *     b\\ndp = [ \\n         [True, False, True, False, True, False], \\n\\t a  [False, False, False, True, True, False], \\n\\t a  [False, False, False, False, True, False], \\n\\t b\\t[False, False, False, False, False, True]] \\n\\t\\n#  Case 1 p[:j] ==  alphabet or \\'.\\'\\n#  Case 2: p[:j] is \\'*\\'\\n\\t# Case 2a: p[:j-1] doesn\\'t need a \\'*\\' to match the substring s[:i]\\n\\t    #1  p[:j-1] ==s[:i]   dp[i][j] =d[i-1][j]\\n\\t\\t    0  a  *                0   a  a \\n        0                      0\\n        a        T        ---> a\\n        a        T             a         T\\n\\t\\t#2  p[:j-1] == \\'.\\'      dp[i][j]=dp[i][j-2]\\n\\t\\t    0  a  b  *\\n        0  \\n        a     T     T          \\n        \\n\\t# Case 2b: p[:j] needs \\'*\\' to match the substring s[:i]\\n```\\n```\\n # about *:\\n case 1: 0 preceding element\\n case 2: 1 or more preceding element\\n\\t\\t\\t   the preceding element could be a \\'.\\' or an alpharbet.\\n\\t\\t\\t   more proceding element is easy to handle once you use dynamic programming. \\n \\n \\n```\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        n = len(s)\\n        m = len(p)\\n        dp = [[False for _ in range (m+1)] for _ in range (n+1)]\\n        dp[0][0] = True\\n        for c in range(1,m+1):\\n            if p[c-1] == \\'*\\' and c > 1:\\n                dp[0][c] = dp[0][c-2]\\n        for r in range(1,n+1):\\n            for c in range(1,m+1):\\n                if p[c-1] == s[r-1] or p[c-1] == \\'.\\':\\n                    dp[r][c] = dp[r-1][c-1]\\n                elif c > 1 and p[c-1] == \\'*\\':\\n                    if  p[c-2] ==\\'.\\' or s[r-1]==p[c-2]:\\n                        dp[r][c] =dp[r][c-2] or dp[r-1][c]\\n                    else:\\n                        dp[r][c] = dp[r][c-2]\\n        return dp[n][m]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ns = \"aab\"\\np = \"c*a*b\"\\n                 c      *       a      *     b\\ndp = [ \\n         [True, False, True, False, True, False], \\n\\t a  [False, False, False, True, True, False], \\n\\t a  [False, False, False, False, True, False], \\n\\t b\\t[False, False, False, False, False, True]] \\n\\t\\n#  Case 1 p[:j] ==  alphabet or \\'.\\'\\n#  Case 2: p[:j] is \\'*\\'\\n\\t# Case 2a: p[:j-1] doesn\\'t need a \\'*\\' to match the substring s[:i]\\n\\t    #1  p[:j-1] ==s[:i]   dp[i][j] =d[i-1][j]\\n\\t\\t    0  a  *                0   a  a \\n        0                      0\\n        a        T        ---> a\\n        a        T             a         T\\n\\t\\t#2  p[:j-1] == \\'.\\'      dp[i][j]=dp[i][j-2]\\n\\t\\t    0  a  b  *\\n        0  \\n        a     T     T          \\n        \\n\\t# Case 2b: p[:j] needs \\'*\\' to match the substring s[:i]\\n```\n```\\n # about *:\\n case 1: 0 preceding element\\n case 2: 1 or more preceding element\\n\\t\\t\\t   the preceding element could be a \\'.\\' or an alpharbet.\\n\\t\\t\\t   more proceding element is easy to handle once you use dynamic programming. \\n \\n \\n```\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        n = len(s)\\n        m = len(p)\\n        dp = [[False for _ in range (m+1)] for _ in range (n+1)]\\n        dp[0][0] = True\\n        for c in range(1,m+1):\\n            if p[c-1] == \\'*\\' and c > 1:\\n                dp[0][c] = dp[0][c-2]\\n        for r in range(1,n+1):\\n            for c in range(1,m+1):\\n                if p[c-1] == s[r-1] or p[c-1] == \\'.\\':\\n                    dp[r][c] = dp[r-1][c-1]\\n                elif c > 1 and p[c-1] == \\'*\\':\\n                    if  p[c-2] ==\\'.\\' or s[r-1]==p[c-2]:\\n                        dp[r][c] =dp[r][c-2] or dp[r-1][c]\\n                    else:\\n                        dp[r][c] = dp[r][c-2]\\n        return dp[n][m]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5968,
                "title": "my-accepted-solution-based-on-nondeterministic-finite-automata-nfa",
                "content": "First of all, my algorithm is not even among the fastest one written in c++. It is more of a demo to show how general regexp matching is implemented. Somehow I fee the knowledge behind regular expression matching is more important than just writing a special DP or backtracking algorithm that solves this particular case. \\n\\nThe algorithm I provided is based on NFA. For everyone who is interested in how regular expression is developed, please find out the concepts of nondeterministic state machines. I personally was really fascinated about regular language and Kleene theory. \\n\\nOnce you got the idea, you can use the sample code I provided below to match more complicated rules, if you know how to generate the proper epsilon transition rule for each type of special char ('*', '.', '+' and brackets (you may need to use stack to tract left and right bracket pairs, or other data structures)). \\n\\n\\n\\n    class DirectedGraph {\\n    public:\\n      explicit DirectedGraph(size_t n)\\n          : adj_sets_(n, std::unordered_set<size_t>()) {}\\n      void AddEdge(size_t w, size_t v) { adj_sets_[w].insert(v); }\\n      const std::unordered_set<size_t> &Adjacent(size_t w) const {\\n        return adj_sets_[w];\\n      }\\n      size_t size() const { return adj_sets_.size(); }\\n    \\n    private:\\n      // n vertices\\n      std::vector<std::unordered_set<size_t>> adj_sets_;\\n    };\\n    \\n    class DirectedGraphDFS {\\n    public:\\n      DirectedGraphDFS(const DirectedGraph &graph, size_t s)\\n          : marked_(graph.size(), false) {\\n        DFS(graph, s);\\n      }\\n    \\n      DirectedGraphDFS(const DirectedGraph &graph, std::vector<size_t> sources)\\n          : marked_(graph.size(), false) {\\n        for (auto s : sources) {\\n          DFS(graph, s);\\n        }\\n      }\\n    \\n      DirectedGraphDFS(const DirectedGraph &graph,\\n                       std::unordered_set<size_t> sources)\\n          : marked_(graph.size(), false) {\\n        for (auto s : sources) {\\n          DFS(graph, s);\\n        }\\n      }\\n    \\n      bool Reachable(size_t v) const { return marked_[v]; }\\n    \\n    private:\\n      void DFS(const DirectedGraph &graph, size_t s) {\\n        marked_[s] = true;\\n        const auto &adj = graph.Adjacent(s);\\n        for (auto v : adj) {\\n          if (!marked_[v]) {\\n            DFS(graph, v);\\n          }\\n        }\\n      }\\n      std::vector<bool> marked_;\\n    };\\n    \\n    class NFA {\\n    public:\\n      explicit NFA(std::string regexp)\\n          : regexp_(regexp), epsilon_closure_(regexp.size() + 1) {\\n        // suppose we only allow . and kleene star *\\n\\n        size_t len = regexp.size();\\n        for (size_t i = 0; i < len; ++i) {\\n          // let us build the transition rules, if the regepx[i] = * then we have a\\n          // epsilon\\n          // transition\\n          if (regexp[i] == '*') {\\n            // the star cannot appear at the first letter\\n            assert(i > 0);\\n            size_t lp = i - 1;\\n            while (regexp[lp] == '*') {\\n              --lp;\\n              // now epsilon transition between lp -> i and i -> lp\\n            }\\n            epsilon_closure_.AddEdge(lp, i);\\n            epsilon_closure_.AddEdge(i, lp);\\n            // we also have an epsilon transition between i and i + 1\\n            epsilon_closure_.AddEdge(i, i + 1);\\n          }\\n          // all other chars are implicit transition\\n        }\\n      }\\n    \\n      bool Match(std::string input) {\\n        reached_state_.clear();\\n        // feed the initial state in\\n        reached_state_.insert(0);\\n        DoEpsilonTransition();\\n    \\n        for (auto c : input) {\\n          DoCharMatching(c);\\n          DoEpsilonTransition();\\n        }\\n    \\n        if (reached_state_.find(epsilon_closure_.size() - 1) !=\\n            reached_state_.end()) {\\n          return true;\\n        }\\n        return false;\\n      }\\n    \\n    private:\\n      void DoEpsilonTransition() {\\n        DirectedGraphDFS dfs(epsilon_closure_, reached_state_);\\n        for (size_t i = 0; i < epsilon_closure_.size(); ++i) {\\n          if (dfs.Reachable(i)) {\\n            reached_state_.insert(i);\\n          }\\n        }\\n      }\\n    \\n      void DoCharMatching(char c) {\\n        auto original_state = reached_state_;\\n        reached_state_.clear();\\n        for (auto i : original_state) {\\n          if (regexp_[i] == c || regexp_[i] == '.') {\\n            // implicit transition\\n            reached_state_.insert(i + 1);\\n          }\\n        }\\n      }\\n    \\n      std::string regexp_;\\n      // The epsilon_closure transition graph\\n      DirectedGraph epsilon_closure_;\\n      std::unordered_set<size_t> reached_state_;\\n    };\\n    \\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            NFA nfa(p);\\n            return nfa.Match(s);\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            NFA nfa(p);\\n            return nfa.Match(s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2504762,
                "title": "100-recursion",
                "content": "**Please upvote if it was helpful!**\\n```\\nclass Solution {\\n  bool isMatch(String s, String p) {\\n    if (p.isEmpty) {\\n      return s.isEmpty;\\n    }\\n    bool firstMatch = s.isNotEmpty && (p[0] == s[0] || p[0] == \\'.\\');\\n\\n    if (p.length >= 2 && p[1] == \\'*\\') {\\n      return (isMatch(s, p.substring(2)) || (firstMatch && isMatch(s.substring(1), p)));\\n    } else {\\n      return firstMatch && isMatch(s.substring(1), p.substring(1));\\n    }\\n  }\\n}\\n```\\n[Submission Detail](https://leetcode.com/submissions/detail/787111559/)",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool isMatch(String s, String p) {\\n    if (p.isEmpty) {\\n      return s.isEmpty;\\n    }\\n    bool firstMatch = s.isNotEmpty && (p[0] == s[0] || p[0] == \\'.\\');\\n\\n    if (p.length >= 2 && p[1] == \\'*\\') {\\n      return (isMatch(s, p.substring(2)) || (firstMatch && isMatch(s.substring(1), p)));\\n    } else {\\n      return firstMatch && isMatch(s.substring(1), p.substring(1));\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439995,
                "title": "why-output-is-true-for-s-aab-and-p-c-a-b",
                "content": "Can someone let me know why output is true for s=\"aab\" and p=\"c*a*b\" as pattern is not present in input string, so it should output false. It seems I am missing some point about the question.",
                "solutionTags": [],
                "code": "Can someone let me know why output is true for s=\"aab\" and p=\"c*a*b\" as pattern is not present in input string, so it should output false. It seems I am missing some point about the question.",
                "codeTag": "Unknown"
            },
            {
                "id": 380342,
                "title": "a-few-lines-of-c",
                "content": "Same recursive logic with no memoization but in a few lines of C ...\\n\\nThe third line checks if the pattern string length > 1 and if so, whether it contains the quantifier expression, <char | \\'\\\\.\\'>\\'\\\\*\\'. In that case, we have to handle two things:\\n\\n   * We check if the expression is of any relevance owing to the fact that \\'\\\\*\\' can mean 0 recurrence of char. To do that we advance p by 2 past the expression and see if the string matches with the rest of the regex string.\\n   \\n   * If that is not the case, we recur without advancing p (adv = 0) in the 4th line. This is assuming that if the expression is indeed valid for the string, it would return 1 (3rd line, above bulletpoint) at a future level of recursion.\\n\\nThe fourth line is for the case of \\'\\\\.\\' or a character in the regex. In this case, we advance both s and p and recur.\\n\\n```\\nbool isMatch(char * s, char * p) {\\n    int adv/*ance p*/ = 1; \\n    if (*p == 0) return *s == 0;\\n    if (*p && *(p+1) && *(p+1) == \\'*\\') { if (isMatch(s, p + 2)) return 1; adv = 0; }\\n    if (*s && *p == \\'.\\' || *s == *p) return isMatch(s + 1, p + adv);\\n    return 0;\\n}\\n```\\n\\n... and ported over to C++ \\n\\n```\\nclass Solution {\\npublic:\\n    bool im(char *s, char *p) {        \\n        int adv = 1; \\n        if (*p == 0) return *s == 0;\\n        if (*p && *(p+1) && *(p+1) == \\'*\\') { if (im(s, p + 2)) return 1; adv = 0; }\\n        if (*s && *p == \\'.\\' || *s == *p) return im(s + 1, p + adv);\\n        return 0;\\n    }\\n    bool isMatch(string s, string p) {\\n        return im((char *)s.c_str(), (char *)p.c_str());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool isMatch(char * s, char * p) {\\n    int adv/*ance p*/ = 1; \\n    if (*p == 0) return *s == 0;\\n    if (*p && *(p+1) && *(p+1) == \\'*\\') { if (isMatch(s, p + 2)) return 1; adv = 0; }\\n    if (*s && *p == \\'.\\' || *s == *p) return isMatch(s + 1, p + adv);\\n    return 0;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool im(char *s, char *p) {        \\n        int adv = 1; \\n        if (*p == 0) return *s == 0;\\n        if (*p && *(p+1) && *(p+1) == \\'*\\') { if (im(s, p + 2)) return 1; adv = 0; }\\n        if (*s && *p == \\'.\\' || *s == *p) return im(s + 1, p + adv);\\n        return 0;\\n    }\\n    bool isMatch(string s, string p) {\\n        return im((char *)s.c_str(), (char *)p.c_str());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333806,
                "title": "",
                "content": "\\u4E3A\\u4EC0\\u4E48\\u8981\\u7528\\u52A8\\u6001\\u89C4\\u5212\\uFF1F\\u5982\\u679C\\u95EE\\u9898\\u89C4\\u6A21\\u7F29\\u5C0F\\uFF0C\\u90A3\\u4E48\\u89E3\\u51B3\\u95EE\\u9898\\u7684\\u601D\\u8DEF\\u662F\\u4E00\\u6837\\u7684\\n\\u52A8\\u6001\\u89C4\\u5212\\u7684\\u5173\\u952E\\u95EE\\u9898\\u662F\\u8981\\u627E\\u5230\\u5B50\\u95EE\\u9898\\u548C\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\n\\u5F53\\u76EE\\u6807\\u4E32\\u7684\\u5927\\u5C0F\\u4E3Ai\\uFF0C\\u6A21\\u5F0F\\u4E32\\u7684\\u5927\\u5C0F\\u4E3Aj\\u65F6\\uFF0C\\u4E00\\u822C\\u6765\\u8BF4ismatch[i][j]\\u8981\\u4F9D\\u8D56\\u4E8Eismatch[i-1][j-1]\\uFF0Cismatch[i][j-1]\\uFF0Cismatch[i-1][j]\\n\\u4E0B\\u9762\\u5C31\\u5177\\u4F53\\u60C5\\u51B5\\u8FDB\\u884C\\u5206\\u6790\\uFF1A\\n\\u5F53s[i]==p[j]\\u6216\\u8005p[j]==\\'.\\'\\u65F6\\uFF0C\\u76EE\\u6807\\u4E32\\u548C\\u6A21\\u5F0F\\u4E32\\u7684\\u6700\\u540E\\u4E24\\u4E2A\\u5B57\\u7B26\\u5339\\u914D\\uFF0C\\u90A3\\u4E48\\u539F\\u95EE\\u9898\\u8F6C\\u79FB\\u4E3Ai-1\\uFF0Cj-1\\u5927\\u5C0F\\u7684\\u5B50\\u95EE\\u9898,ismatch[i][j]=ismatch[i-1][j-1]\\n\\u5F53p[j]==\\'\\\\*\\'\\u65F6\\uFF0C\\'\\\\*\\'\\u53EF\\u4EE5\\u5339\\u914D\\u524D\\u9762\\u4E00\\u4E2A\\u5B57\\u7B26\\u4EFB\\u610F\\u591A\\u6B21\\uFF0C\\u53EF\\u4EE5\\u5206\\u6210\\u4E24\\u7C7B\\uFF1A\\u5339\\u914D0\\u6B21\\u6216\\u5927\\u4E8E0\\u6B21\\uFF0C\\u6700\\u540E\\u7684\\u7ED3\\u679C\\u662F\\u8FD9\\u4E24\\u79CD\\u60C5\\u51B5\\u53EA\\u8981\\u6709\\u4E00\\u4E2A\\u4E3Atrue\\u5219\\u4E3Atrue\\n\\u5F53\\u5339\\u914D0\\u6B21\\u65F6\\uFF0Cismatch[i][j]=ismatch[i][j-2]\\n\\u5F53\\u5339\\u914D\\u5927\\u4E8E0\\u6B21\\u65F6\\uFF0C\\u6709\\u4E00\\u79CD\\u9012\\u5F52\\u7684\\u601D\\u60F3\\u5728\\u91CC\\u9762\\uFF0C\\u5148\\u5339\\u914D1\\u6B21\\uFF0C\\u7136\\u540E\\u518D\\u9012\\u5F52\\u5730\\u5339\\u914D0\\u6B21\\u6216\\u8005\\u5927\\u4E8E0\\u6B21\\n\\u6211\\u4E3E\\u4F8B\\u5B50\\u8BF4\\u660E\\ns=baa\\np=ba*\\n\\u5F53\\u6BD4\\u8F83\\u5230\\u7B2C3\\u4E2A\\u5B57\\u7B26\\u65F6\\uFF0C\\u5339\\u914D\\u5927\\u4E8E0\\u6B21\\uFF0C\\u90A3\\u4E48\\u5148\\u5339\\u914D1\\u6B21\\uFF0C\\u540E\\u9762\\u8FD8\\u80FD\\u518D\\u5339\\u914D0\\u6B21\\u6216\\u5927\\u4E8E0\\u6B21\\uFF0Cp\\u53D8\\u6210baa*\\n\\u56E0\\u4E3As\\u7684\\u7B2C3\\u4E2A\\u5B57\\u7B26\\u548Cp\\u7684\\u7B2C3\\u4E2A\\u5B57\\u7B26\\u662F\\u76F8\\u7B49\\u7684\\uFF0C\\u90A3\\u4E48\\u53EF\\u4EE5\\u540C\\u65F6\\u53BB\\u6389\\u8FD9\\u4E24\\u4E2A\\u5B57\\u7B26\\uFF0Cs=ba\\uFF0Cp=ba*\\u518D\\u6BD4\\u8F83\\u8FD9\\u4E24\\u4E2A\\u5B57\\u7B26\\u4E32\\u3002\\u8FD9\\u79CD\\u60C5\\u51B5\\u539F\\u95EE\\u9898ismatch[i][j]\\u8F6C\\u79FB\\u6210\\u4E86ismatch[i-1][j]\\u7684\\u5B50\\u95EE\\u9898\\uFF0C\\u6761\\u4EF6\\u662Fs[i]==p[j-1]||p[j-1]==\\'.\\'\\n\\u6700\\u540E\\uFF0C\\u521D\\u59CB\\u60C5\\u51B5\\u662Fs\\u7684\\u5927\\u5C0F\\u4E3A\\u7A7A\\uFF0C\\u6A21\\u5F0F\\u4E32\\u7684\\u5927\\u5C0F\\u53D8\\u5316\\uFF0C\\u5C31\\u53EA\\u6709p[j]==\\'\\\\*\\'\\u4E14\\u5339\\u914D0\\u6B21\\u7684\\u60C5\\u51B5\\u3002\\n\\n\\n\\n```\\npublic boolean isMatch(String s, String p) {\\n\\n        int len1=s.length();\\n        int len2 = p.length();\\n\\t\\t\\n        boolean[][] ismatch=new boolean[len1+1][len2+1];\\n        ismatch[0][0]=true;\\n\\t\\t\\n        for(int j=2;j<=len2;j++) {\\n        \\tif(p.charAt(j-1)==\\'*\\') {\\n        \\t\\tismatch[0][j]=ismatch[0][j-2];\\n        \\t}\\t\\n        }\\n        \\n        for(int i=1;i<=len1;i++) {\\n        \\tfor(int j=1;j<=len2;j++) {\\n        \\t\\tif(p.charAt(j-1)==\\'.\\'||p.charAt(j-1)==s.charAt(i-1))\\n        \\t\\t\\tismatch[i][j]=ismatch[i-1][j-1];\\n        \\t\\telse if(p.charAt(j-1)==\\'*\\') {\\n        \\t\\t\\tismatch[i][j]=ismatch[i][j-2];//\\u5339\\u914D0\\u6B21\\n        \\t\\t\\tif(p.charAt(j-2)==\\'.\\'||p.charAt(j-2)==s.charAt(i-1))\\n        \\t\\t\\t\\tismatch[i][j]=ismatch[i][j]|ismatch[i-1][j];\\n        \\t\\t}\\n        \\t}\\n        }\\n        \\n        return ismatch[len1][len2];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isMatch(String s, String p) {\\n\\n        int len1=s.length();\\n        int len2 = p.length();\\n\\t\\t\\n        boolean[][] ismatch=new boolean[len1+1][len2+1];\\n        ismatch[0][0]=true;\\n\\t\\t\\n        for(int j=2;j<=len2;j++) {\\n        \\tif(p.charAt(j-1)==\\'*\\') {\\n        \\t\\tismatch[0][j]=ismatch[0][j-2];\\n        \\t}\\t\\n        }\\n        \\n        for(int i=1;i<=len1;i++) {\\n        \\tfor(int j=1;j<=len2;j++) {\\n        \\t\\tif(p.charAt(j-1)==\\'.\\'||p.charAt(j-1)==s.charAt(i-1))\\n        \\t\\t\\tismatch[i][j]=ismatch[i-1][j-1];\\n        \\t\\telse if(p.charAt(j-1)==\\'*\\') {\\n        \\t\\t\\tismatch[i][j]=ismatch[i][j-2];//\\u5339\\u914D0\\u6B21\\n        \\t\\t\\tif(p.charAt(j-2)==\\'.\\'||p.charAt(j-2)==s.charAt(i-1))\\n        \\t\\t\\t\\tismatch[i][j]=ismatch[i][j]|ismatch[i-1][j];\\n        \\t\\t}\\n        \\t}\\n        }\\n        \\n        return ismatch[len1][len2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 304089,
                "title": "dp-solution-using-c-with-some-explanation",
                "content": "![image](https://assets.leetcode.com/users/ckc721/image_1559480744.png)\\n\\nconsider these situations above.\\n\\n```\\n//\\'.\\' Matches any single character.\\n//\\'*\\' Matches zero or more of the preceding element.\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if(p.empty())\\n            return s.empty();\\n        \\n        //use a array to save all the status\\n        bool Result[s.length()+1][p.length()+1];\\n      \\n        //the first one is both empty sub-string\\n        Result[0][0] = true;\\n\\n        //in case of a*b*c* or a*b* etc.\\n        for(int j = 1; j < p.length()+1; j++)\\n        {\\n            if(p[j-1] == \\'*\\')\\n                Result[0][j] = Result[0][j-2];\\n            else\\n                Result[0][j] = false;\\n        }\\n        \\n        //sub-string s compare to empty string\\n        for(int i = 1; i < s.length()+1; i++)\\n            Result[i][0] = false;\\n        \\n        //calculate all the value in the table\\n        for(int i = 1; i < s.length()+1; i++)\\n        {\\n            for(int j = 1; j < p.length()+1; j++)\\n            {\\n                if(s[i-1] == p[j-1] || p[j-1] == \\'.\\')\\n                    Result[i][j] = Result[i-1][j-1];\\n                else if(p[j-1] == \\'*\\')\\n                {\\n                    Result[i][j] = Result[i][j-2];\\n                    if(s[i-1] == p[j-2] || p[j-2] == \\'.\\')\\n                        Result[i][j] = Result[i][j] | Result[i-1][j];\\n                }\\n                else\\n                    Result[i][j] = false;\\n            }\\n        }\\n        return Result[s.length()][p.length()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n//\\'.\\' Matches any single character.\\n//\\'*\\' Matches zero or more of the preceding element.\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if(p.empty())\\n            return s.empty();\\n        \\n        //use a array to save all the status\\n        bool Result[s.length()+1][p.length()+1];\\n      \\n        //the first one is both empty sub-string\\n        Result[0][0] = true;\\n\\n        //in case of a*b*c* or a*b* etc.\\n        for(int j = 1; j < p.length()+1; j++)\\n        {\\n            if(p[j-1] == \\'*\\')\\n                Result[0][j] = Result[0][j-2];\\n            else\\n                Result[0][j] = false;\\n        }\\n        \\n        //sub-string s compare to empty string\\n        for(int i = 1; i < s.length()+1; i++)\\n            Result[i][0] = false;\\n        \\n        //calculate all the value in the table\\n        for(int i = 1; i < s.length()+1; i++)\\n        {\\n            for(int j = 1; j < p.length()+1; j++)\\n            {\\n                if(s[i-1] == p[j-1] || p[j-1] == \\'.\\')\\n                    Result[i][j] = Result[i-1][j-1];\\n                else if(p[j-1] == \\'*\\')\\n                {\\n                    Result[i][j] = Result[i][j-2];\\n                    if(s[i-1] == p[j-2] || p[j-2] == \\'.\\')\\n                        Result[i][j] = Result[i][j] | Result[i-1][j];\\n                }\\n                else\\n                    Result[i][j] = false;\\n            }\\n        }\\n        return Result[s.length()][p.length()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239822,
                "title": "java-solutions-using-recursive-and-dp-with-both-top-down-and-bottom-up-traversal-order",
                "content": "1. recursive & forward (59ms)\\n```\\n    public boolean isMatch(String s, String p) {\\n        if (p.isEmpty())\\n            return s.isEmpty();\\n        boolean firstMatch = !s.isEmpty() && (s.charAt(0) == p.charAt(0) || p.charAt(0) == \\'.\\');\\n        if (p.length() >= 2 && p.charAt(1) == \\'*\\') { // next p is \\'*\\'\\n            return firstMatch && isMatch(s.substring(1), p) // * matches one or more\\n                || isMatch(s, p.substring(2)); // * matches zero character\\n        } else {\\n            return firstMatch && isMatch(s.substring(1), p.substring(1));\\n        }\\n    }\\n```\\n2. DP & bottom-up (14ms)\\n```\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] dp = new boolean[s.length()+1][p.length()+1];\\n        dp[s.length()][p.length()] = true;\\n        for (int i=s.length();i>=0;i--) { // i == s.length() to fill up i=s.length() column. in order to handle s=\"\", p=\"x*\"\\n            for (int j=p.length()-1;j>=0;j--) {\\n                boolean firstMatch = i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'.\\');\\n                if (j+1 < p.length() && p.charAt(j+1) == \\'*\\') {\\n                    dp[i][j] = firstMatch && dp[i+1][j] || dp[i][j+2];\\n                } else {\\n                    dp[i][j] = firstMatch && dp[i+1][j+1];\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```\\n3. recursive & reverse (21ms)\\n```\\n    public boolean isMatch(String s, String p) {\\n        if (p.isEmpty())\\n            return s.isEmpty();\\n        if (p.length() > 1 && p.charAt(p.length()-1) == \\'*\\') {\\n            boolean firstMatch = (!s.isEmpty() && (p.charAt(p.length()-2) == s.charAt(s.length()-1) || p.charAt(p.length()-2) == \\'.\\'));\\n            return firstMatch && isMatch(s.substring(0, s.length()-1), p.substring(0, p.length())) \\n                || isMatch(s.substring(0, s.length()), p.substring(0, p.length()-2));\\n        } else {\\n            boolean firstMatch = (!s.isEmpty() && (p.charAt(p.length()-1) == s.charAt(s.length()-1) || p.charAt(p.length()-1) == \\'.\\'));\\n            return firstMatch && isMatch(s.substring(0, s.length()-1), p.substring(0, p.length()-1));\\n        }\\n    }\\n```\\n4. DP & top-down (14ms)\\n```\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] dp = new boolean[s.length()+1][p.length()+1];\\n        dp[0][0] = true;\\n        for (int i=0;i<=s.length();i++) { // i == 0 to fill up i=0 column. in order to handle s=\"\", p=\"x*\"\\n            for (int j=1;j<=p.length();j++) {\\n                if (j-1 >= 0 && p.charAt(j-1) == \\'*\\') {\\n                    boolean firstMatch = i > 0 && (s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == \\'.\\');\\n                    dp[i][j] = firstMatch && dp[i-1][j] || dp[i][j-2];\\n                } else {\\n                    boolean firstMatch = i > 0 && (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == \\'.\\');\\n                    dp[i][j] = firstMatch && dp[i-1][j-1];\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n    public boolean isMatch(String s, String p) {\\n        if (p.isEmpty())\\n            return s.isEmpty();\\n        boolean firstMatch = !s.isEmpty() && (s.charAt(0) == p.charAt(0) || p.charAt(0) == \\'.\\');\\n        if (p.length() >= 2 && p.charAt(1) == \\'*\\') { // next p is \\'*\\'\\n            return firstMatch && isMatch(s.substring(1), p) // * matches one or more\\n                || isMatch(s, p.substring(2)); // * matches zero character\\n        } else {\\n            return firstMatch && isMatch(s.substring(1), p.substring(1));\\n        }\\n    }\\n```\n```\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] dp = new boolean[s.length()+1][p.length()+1];\\n        dp[s.length()][p.length()] = true;\\n        for (int i=s.length();i>=0;i--) { // i == s.length() to fill up i=s.length() column. in order to handle s=\"\", p=\"x*\"\\n            for (int j=p.length()-1;j>=0;j--) {\\n                boolean firstMatch = i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'.\\');\\n                if (j+1 < p.length() && p.charAt(j+1) == \\'*\\') {\\n                    dp[i][j] = firstMatch && dp[i+1][j] || dp[i][j+2];\\n                } else {\\n                    dp[i][j] = firstMatch && dp[i+1][j+1];\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```\n```\\n    public boolean isMatch(String s, String p) {\\n        if (p.isEmpty())\\n            return s.isEmpty();\\n        if (p.length() > 1 && p.charAt(p.length()-1) == \\'*\\') {\\n            boolean firstMatch = (!s.isEmpty() && (p.charAt(p.length()-2) == s.charAt(s.length()-1) || p.charAt(p.length()-2) == \\'.\\'));\\n            return firstMatch && isMatch(s.substring(0, s.length()-1), p.substring(0, p.length())) \\n                || isMatch(s.substring(0, s.length()), p.substring(0, p.length()-2));\\n        } else {\\n            boolean firstMatch = (!s.isEmpty() && (p.charAt(p.length()-1) == s.charAt(s.length()-1) || p.charAt(p.length()-1) == \\'.\\'));\\n            return firstMatch && isMatch(s.substring(0, s.length()-1), p.substring(0, p.length()-1));\\n        }\\n    }\\n```\n```\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] dp = new boolean[s.length()+1][p.length()+1];\\n        dp[0][0] = true;\\n        for (int i=0;i<=s.length();i++) { // i == 0 to fill up i=0 column. in order to handle s=\"\", p=\"x*\"\\n            for (int j=1;j<=p.length();j++) {\\n                if (j-1 >= 0 && p.charAt(j-1) == \\'*\\') {\\n                    boolean firstMatch = i > 0 && (s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == \\'.\\');\\n                    dp[i][j] = firstMatch && dp[i-1][j] || dp[i][j-2];\\n                } else {\\n                    boolean firstMatch = i > 0 && (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == \\'.\\');\\n                    dp[i][j] = firstMatch && dp[i-1][j-1];\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6010,
                "title": "c-sharing-my-7-line-recursive-solution-100ms-and-20-line-dp-solution-30ms",
                "content": "I'm sharing my recursive and DP solutions in C++. I'm a big recursion person so I first thought about the recursive solution first. Depending on the condition, you either advance one char in s or freeze s and advance two pointers in t. The only tricky part is in the base case. I basically loop and delete possible sequences of \"X*\" occurrences in t. \\n\\nCould somebody share some insights to make the code more elegant and efficient? One thing that comes to my mind is to somehow get rid of the strlen() function call.\\n\\nFor the recursive formulation, it takes about 100ms.\\n\\n    class Solution {\\n    public:\\n        bool isMatch(const char *s, const char *t) {\\n            if (*s=='\\\\0') {\\n                while (strlen(t)>=2 && t[1]=='*') {t += 2;}\\n                return *t=='\\\\0';\\n            }\\n    \\n            // if next char in t is not a star,\\n            if (t[1]!='*'){\\n                return s[0]==t[0]||t[0]=='.' ? isMatch(s+1,t+1) : false;\\n            // if next char in t is *, either skip this X* in t, or match X* to one char in s.\\n            } else {\\n                return strlen(t)>2&&isMatch(s,t+2) ? true : (s[0]==t[0]||t[0]=='.' ? isMatch(s+1,t) : false);\\n            }\\n        }\\n    };\\n\\nAs for DP, it's straightforward if you understand the recursive relations. It takes 32ms.\\n\\n    class Solution {\\n    public:\\n        bool isMatch(const char *s, const char *t) {\\n    \\n            vector<vector<bool>> V(strlen(s)+1, vector<bool>(strlen(t)+1,false));\\n            V[strlen(s)][strlen(t)] = true;\\n            \\n            // init bottom\\n            for (int i=0; i<(int)strlen(s)-1; i++) V[i][strlen(t)]=false;\\n            \\n            // init right\\n            for (int j=(int)strlen(t)-1; j>=0;j--){\\n                if (t[j]=='\\\\0') V[strlen(s)][j]=true;\\n                \\n                if (t[j+1]=='*') V[strlen(s)][j]=V[strlen(s)][j+2];\\n            }\\n            \\n            // fill in dp from bottom right\\n            for (int j=(int)strlen(t)-1; j>=0; j--){\\n                if (t[j]=='*') continue;\\n                for (int i=(int)strlen(s)-1; i>=0; i--){\\n                    if (t[j+1]!='*')\\n                        V[i][j] = (s[i]==t[j]||t[j]=='.') ? V[i+1][j+1] : false;\\n                    else if (V[i][j+2]){\\n                        V[i][j] = true;\\n                    } else {\\n                        V[i][j] = (s[i]==t[j]||t[j]=='.') ? V[i+1][j] : false;\\n                    }\\n                }\\n            }\\n            return V[0][0];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isMatch(const char *s, const char *t) {\\n            if (*s=='\\\\0') {\\n                while (strlen(t)>=2 && t[1]=='*') {t += 2;}",
                "codeTag": "Java"
            },
            {
                "id": 3109203,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size(), n = p.size();\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        dp[0][0] = true;\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i][j - 2] || (i && dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\'));\\n                } else {\\n                    dp[i][j] = i && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\');\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size(), n = p.size();\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        dp[0][0] = true;\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i][j - 2] || (i && dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\'));\\n                } else {\\n                    dp[i][j] = i && dp[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\');\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950153,
                "title": "easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity : O(N * M)***\\n* ***Space Complexity : O(N * M)***\\n\\n```\\nclass Solution {\\n    public:\\n    \\n    bool helper(string str, string pat, int i, int j, vector<vector<int>> &dp){\\n        \\n        if(i >= str.size() && j >= pat.size()){\\n            return true;\\n        }\\n       \\n        if(j >= pat.size()){\\n            return false;\\n        } \\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        if(i >= str.size()){\\n            \\n            if(pat[j + 1] == \\'*\\'){\\n                \\n                return dp[i][j] = helper(str, pat, i, j + 2, dp);\\n            }\\n            \\n            return false;\\n        }\\n        \\n        if(j + 1 < pat.size() && pat[j + 1] == \\'*\\'){\\n            \\n              if(pat[j] == \\'.\\' || pat[j] == str[i])\\n              {\\n                  return dp[i][j] = (helper(str, pat, i + 1, j, dp) || helper(str, pat, i, j + 2, dp));\\n              }\\n            \\n              else{\\n                  \\n                  return dp[i][j] = helper(str, pat, i, j + 2, dp);\\n              }   \\n        }\\n        \\n        else if (pat[j] == \\'.\\' || pat[j] == str[i])\\n        {\\n            return dp[i][j] = helper(str, pat, i + 1, j + 1, dp);\\n        }\\n        \\n        return dp[i][j] = false;   \\n    }\\n    \\n    bool isMatch(string str, string pat) {\\n        \\n        int n = str.size();\\n        \\n        int m = pat.size();\\n        \\n        vector<vector<int> > dp(n + 1, vector<int> (m + 1, -1));\\n        \\n        return helper(str, pat, 0, 0, dp) ? true : false;\\n    }\\n};\\n```\\n\\n\\n* ***Bottom Up Approach***\\n\\n* ***Time Complexity : O(M * N)***\\n* ***Space Complexity : O(M * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string str, string pat) {\\n        \\n        int n = str.size();\\n        \\n        int m = pat.size();\\n        \\n        vector<vector<bool>> dp(m + 1, vector<bool> (n + 1, false));\\n        \\n        for(int i = 0; i <= m; i++)\\n        {\\n            for(int j = 0; j <= n; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                {\\n                    dp[i][j] = true;\\n                }\\n                \\n                else if(i == 0)\\n                {\\n                    dp[i][j] = false;\\n                }\\n                \\n                else if(j == 0)\\n                {\\n                    if(pat[i - 1] == \\'*\\')\\n                    {\\n                        dp[i][j] = dp[i - 2][j];\\n                    }\\n                    \\n                    else\\n                    {\\n                        dp[i][j] = false;\\n                    }\\n                }\\n                \\n                else\\n                {\\n                    if(pat[i - 1] == \\'*\\')\\n                    {\\n                        dp[i][j] = dp[i - 2][j];\\n                        \\n                        if(pat[i - 2] == \\'.\\' || pat[i - 2] == str[j - 1])\\n                        {\\n                            dp[i][j] = dp[i][j] || dp[i][j - 1];\\n                        }\\n                    }\\n                    \\n                    else if(pat[i - 1] == \\'.\\')\\n                    {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    \\n                    else if(pat[i - 1] == str[j - 1])\\n                    {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    \\n                    else\\n                    {\\n                        dp[i][j] = false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    \\n    bool helper(string str, string pat, int i, int j, vector<vector<int>> &dp){\\n        \\n        if(i >= str.size() && j >= pat.size()){\\n            return true;\\n        }\\n       \\n        if(j >= pat.size()){\\n            return false;\\n        } \\n        \\n        if(dp[i][j] != -1){\\n            return dp[i][j];\\n        }\\n        \\n        if(i >= str.size()){\\n            \\n            if(pat[j + 1] == \\'*\\'){\\n                \\n                return dp[i][j] = helper(str, pat, i, j + 2, dp);\\n            }\\n            \\n            return false;\\n        }\\n        \\n        if(j + 1 < pat.size() && pat[j + 1] == \\'*\\'){\\n            \\n              if(pat[j] == \\'.\\' || pat[j] == str[i])\\n              {\\n                  return dp[i][j] = (helper(str, pat, i + 1, j, dp) || helper(str, pat, i, j + 2, dp));\\n              }\\n            \\n              else{\\n                  \\n                  return dp[i][j] = helper(str, pat, i, j + 2, dp);\\n              }   \\n        }\\n        \\n        else if (pat[j] == \\'.\\' || pat[j] == str[i])\\n        {\\n            return dp[i][j] = helper(str, pat, i + 1, j + 1, dp);\\n        }\\n        \\n        return dp[i][j] = false;   \\n    }\\n    \\n    bool isMatch(string str, string pat) {\\n        \\n        int n = str.size();\\n        \\n        int m = pat.size();\\n        \\n        vector<vector<int> > dp(n + 1, vector<int> (m + 1, -1));\\n        \\n        return helper(str, pat, 0, 0, dp) ? true : false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string str, string pat) {\\n        \\n        int n = str.size();\\n        \\n        int m = pat.size();\\n        \\n        vector<vector<bool>> dp(m + 1, vector<bool> (n + 1, false));\\n        \\n        for(int i = 0; i <= m; i++)\\n        {\\n            for(int j = 0; j <= n; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                {\\n                    dp[i][j] = true;\\n                }\\n                \\n                else if(i == 0)\\n                {\\n                    dp[i][j] = false;\\n                }\\n                \\n                else if(j == 0)\\n                {\\n                    if(pat[i - 1] == \\'*\\')\\n                    {\\n                        dp[i][j] = dp[i - 2][j];\\n                    }\\n                    \\n                    else\\n                    {\\n                        dp[i][j] = false;\\n                    }\\n                }\\n                \\n                else\\n                {\\n                    if(pat[i - 1] == \\'*\\')\\n                    {\\n                        dp[i][j] = dp[i - 2][j];\\n                        \\n                        if(pat[i - 2] == \\'.\\' || pat[i - 2] == str[j - 1])\\n                        {\\n                            dp[i][j] = dp[i][j] || dp[i][j - 1];\\n                        }\\n                    }\\n                    \\n                    else if(pat[i - 1] == \\'.\\')\\n                    {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    \\n                    else if(pat[i - 1] == str[j - 1])\\n                    {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    \\n                    else\\n                    {\\n                        dp[i][j] = false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5660,
                "title": "9-line-python-solution-dp-88ms",
                "content": "`dp[i][j] == True` means first j letters of `p` can match first i letters of `s`. For initialization, need to consider the case when `s` is empty and when `p` is empty.\\n\\n    def isMatch(self, s, p):\\n        lenS, lenP = len(s), len(p)\\n        dp = [[False] * (lenP + 1) for i in range(lenS + 1)]\\n        \\n        # initialization, when p is empty, always Flase, when s is empty:\\n        dp[0][0] = True\\n        for j in range(2, lenP + 1): dp[0][j] = dp[0][j - 2] and p[j - 1] == '*'\\n        \\n        # dp\\n        for i in range(1, lenS + 1):\\n            for j in range(1, lenP + 1):\\n                dp[i][j] = dp[i][j - 2] or (p[j - 2] in (s[i - 1], '.') and dp[i - 1][j]) if p[j - 1] == '*' \\\\\\n                    else dp[i - 1][j - 1] and p[j - 1] in ('.', s[i - 1])\\n        return dp[lenS][lenP]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "`dp[i][j] == True` means first j letters of `p` can match first i letters of `s`. For initialization, need to consider the case when `s` is empty and when `p` is empty.\\n\\n    def isMatch(self, s, p):\\n        lenS, lenP = len(s), len(p)\\n        dp = [[False] * (lenP + 1) for i in range(lenS + 1)]\\n        \\n        # initialization, when p is empty, always Flase, when s is empty:\\n        dp[0][0] = True\\n        for j in range(2, lenP + 1): dp[0][j] = dp[0][j - 2] and p[j - 1] == '*'\\n        \\n        # dp\\n        for i in range(1, lenS + 1):\\n            for j in range(1, lenP + 1):\\n                dp[i][j] = dp[i][j - 2] or (p[j - 2] in (s[i - 1], '.') and dp[i - 1][j]) if p[j - 1] == '*' \\\\\\n                    else dp[i - 1][j - 1] and p[j - 1] in ('.', s[i - 1])\\n        return dp[lenS][lenP]",
                "codeTag": "Python3"
            },
            {
                "id": 5748,
                "title": "python-dp-solution-in-36-ms",
                "content": "draw a table and use different test cases.\\nAfter try and error, finally get AC.\\n\\n\\n    def isMatch(self, s, p):\\n        m = len(s)\\n        n = len(p)\\n        dp = [[True] + [False] * m]\\n        for i in xrange(n):\\n            dp.append([False]*(m+1))\\n        \\n        for i in xrange(1, n + 1):\\n            x = p[i-1]\\n            if x == '*' and i > 1:\\n                dp[i][0] = dp[i-2][0]\\n            for j in xrange(1, m+1):\\n                if x == '*':\\n                    dp[i][j] = dp[i-2][j] or dp[i-1][j] or (dp[i-1][j-1] and p[i-2] == s[j-1]) or (dp[i][j-1] and p[i-2]=='.')\\n                elif x == '.' or x == s[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n        \\n        return dp[n][m]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "draw a table and use different test cases.\\nAfter try and error, finally get AC.\\n\\n\\n    def isMatch(self, s, p):\\n        m = len(s)\\n        n = len(p)\\n        dp = [[True] + [False] * m]\\n        for i in xrange(n):\\n            dp.append([False]*(m+1))\\n        \\n        for i in xrange(1, n + 1):\\n            x = p[i-1]\\n            if x == '*' and i > 1:\\n                dp[i][0] = dp[i-2][0]\\n            for j in xrange(1, m+1):\\n                if x == '*':\\n                    dp[i][j] = dp[i-2][j] or dp[i-1][j] or (dp[i-1][j-1] and p[i-2] == s[j-1]) or (dp[i][j-1] and p[i-2]=='.')\\n                elif x == '.' or x == s[j-1]:\\n                    dp[i][j] = dp[i-1][j-1]\\n        \\n        return dp[n][m]",
                "codeTag": "Python3"
            },
            {
                "id": 2948148,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size(), n = p.size();\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        dp[0][0] = true;\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i][j - 2] || (i && dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\'));\\n                }\\n                 else if(i>0 && (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\')) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n];   \\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size(), n = p.size();\\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n        dp[0][0] = true;\\n        for (int i = 0; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i][j - 2] || (i && dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\'));\\n                }\\n                 else if(i>0 && (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\')) {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n];   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151627,
                "title": "rust-0ms-using-thompson-nfa",
                "content": "A solution in Rust. Implements Thompson\\'s algorithm for regular expression matching. The regular expression is converted to its postfix representation, which is then used to construct a Thompson  NFA (Nondeterministic Finite Automata). The NFA is then used to step from state to state as characters of `s` are iterated over.\\n\\nThe artlcle *[Regular Expression Matching Can Be Simple And Fast](https://swtch.com/~rsc/regexp/regexp1.html)* was leveraged to implement the algorithm. It has a good explanation of how this works with diagrams.\\n\\nThe time-complexity of this algorithm is linear, `O(n)`, for all inputs, and could easily handle complex expressions and strings much longer than the problem\\'s constraints very quickly.  The state machine marches foward at each step with no backtracking. Interestingly, the state machine can be in multiple states at once.\\n\\nI wanted this to be quick, so I avoided  the use of smart pointers, and implemented handles instead. A state handle internally is simply an index into a contiguous array of State objects. This approach avoids the heavy overhead of the Rust smart pointer operations, while taking advantage of data locality and caching using an array as the memory store  for state objects.\\n\\n```rust\\nuse std::mem::swap;\\n\\nimpl Solution {\\n    pub fn is_match(s: String, p: String) -> bool {\\n\\n        MatcherNfa::new(p).full_match(s)\\n    }\\n}\\n\\n/// Represents Nondeterministic Finite Automata (state machines) constructed\\n/// using a regular expression, and used to determine if strings match it.\\n/// \\nstruct MatcherNfa {\\n    start   : HState,\\n    states  : States,\\n    set_id  : usize,\\n}\\n\\nimpl MatcherNfa {\\n    /// Creates a NFA state machine from a regular expression. Internally, the\\n    /// expression is converted to its postfix representation before building\\n    /// the NFA. Internally, \\'\\\\0\\' is treated as the postfix concatenation \\n    /// operator.\\n    /// \\n    fn new(p: String) -> Self {\\n        use Transition::*;\\n        let mut states  = States::new();\\n        let mut stack   = Vec::<Frag>::new();\\n        let     postfix = re2postfix(p);\\n\\n        for ch in postfix {\\n            match ch {\\n                \\'\\\\0\\' => {\\n                    // Handle postfix concatenation operator.\\n                    let e2 = stack.pop().unwrap();\\n                    let e1 = stack.pop().unwrap();\\n                    e1.out.patch(e2.start, &mut states);\\n                    stack.push(Frag::new(e1.start, e2.out));\\n                }\\n                \\'*\\' => {\\n                    // Handle \\'*\\' regular expression operator.\\n                    let e = stack.pop().unwrap();\\n                    let s = states.new_state(Split, Some(e.start), None);\\n                    e.out.patch(s, &mut states);\\n                    stack.push(Frag::new(s, s.out_n_handle(2).into()));\\n                }\\n                _ => {\\n                    // Treat all other characters as transition match chars. \\n                    let s = states.new_state(Char(ch), None, None);\\n                    stack.push(Frag::new(s, s.out_n_handle(1).into()));\\n                }\\n            }\\n        }\\n        let e = stack.pop().unwrap();\\n        let m = states.new_state(Match, None, None);\\n\\n        e.out.patch(m, &mut states);\\n\\n        MatcherNfa { start: e.start, states, set_id: 0 }\\n    }\\n    /// Run NFA to determine whether it matches `s`. Not a partial match.\\n    /// \\n    fn full_match(&mut self, s: String) -> bool {\\n        let mut curr_set = FollowSet::new();\\n        let mut next_set = FollowSet::new();\\n\\n        curr_set.start(self.start, &mut self.states, self.set_id);\\n\\n        for ch in s.chars() {\\n            curr_set.step(ch, \\n                          &mut next_set, \\n                          &mut self.states, \\n                          &mut self.set_id);\\n            \\n            swap(&mut curr_set, &mut next_set);\\n\\n            if curr_set.count() == 0 {\\n                break;\\n            }\\n        }\\n        curr_set.is_match(&self.states)\\n    }\\n}\\n\\n/// NFA state node.\\n/// \\n#[derive(Debug)]\\nstruct State {\\n    c         : Transition,\\n    out_1     : Option<HState>,\\n    out_2     : Option<HState>,\\n    last_set  : usize,\\n}\\n\\n/// Handle for State objects.\\n/// \\n#[derive(Copy, Clone, Debug)]\\nstruct HState { \\n    idx: usize \\n}\\nimpl HState {\\n    /// Create a new handle to a specific field of a State object.\\n    /// \\n    fn out_n_handle(&self, hout_n: u8) -> HStateField {\\n        HStateField { state: *self, which: hout_n }\\n    }\\n}\\n\\n/// A handle to the field of a State object. The associated fields are\\n/// `state.out_1` or `state.out_2`.\\n/// \\n#[derive(Copy, Clone, Debug)]\\nstruct HStateField {\\n    state: HState,\\n    which: u8,\\n}\\n\\n/// Contiguous memory storage for State objects.\\n/// \\nstruct States { \\n    mem: Vec<State>,\\n}\\nimpl States {\\n    /// Create a new States object to hold State objects.\\n    /// \\n    fn new() -> Self { \\n        States { mem: vec![] } \\n    }\\n    /// Creates a new State object and returns its handle.\\n    /// \\n    fn new_state(&mut self, \\n                 c      : Transition, \\n                 out_1  : Option<HState>, \\n                 out_2  : Option<HState>  ) -> HState \\n    {\\n        self.mem.push(State { c, out_1, out_2, last_set: usize::MAX });\\n        HState { idx: self.mem.len() - 1 }\\n    }\\n    /// Takes the handle of a State object and returns a reference to the \\n    /// object.\\n    /// \\n    fn h2state(&self, hstate: HState) -> &State {\\n        &self.mem[hstate.idx]\\n    }\\n    /// Takes the handle of a State object and returns a mutable reference to\\n    /// the object.\\n    /// \\n    fn h2state_mut(&mut self, hstate: HState) -> &mut State {\\n        &mut self.mem[hstate.idx]\\n    }\\n    /// Takes a handle to the field of a state object and returns a mutable\\n    /// reference to that field.\\n    /// \\n    fn h2out_mut(&mut self, hout_n: HStateField) -> &mut Option<HState> {\\n        match hout_n.which {\\n            1 => { &mut self.h2state_mut(hout_n.state).out_1 },\\n            2 => { &mut self.h2state_mut(hout_n.state).out_2 },\\n            _ => { panic!(\"Invalid field id.\") }\\n        }\\n    }\\n}\\n\\n/// NFA fragment. These are used to assemble the State graph.\\n/// \\nstruct Frag {\\n    start : HState,\\n    out   : StateList,\\n}\\nimpl Frag {\\n    fn new(start: HState, out: StateList) -> Self {\\n        Frag { start, out }\\n    }\\n}\\n\\n/// Represents transitions between states.\\n/// \\n#[derive(PartialEq, Debug)]\\nenum Transition {\\n    Char(char),\\n    Split,\\n    Match\\n}\\n\\n/// A list of State field handles. StateList\\'s are used together with `Frag`s\\n/// (fragments) when assembling the state graph. The name of this object may \\n/// seem like a slight misnomer; in the original implementation in C, this list\\n/// exists as a list of pointers to state pointers which enables updating the \\n/// out_1 and out_2 fields of the states. \\n/// \\nstruct StateList {\\n    list: Vec<HStateField>,\\n}\\nimpl StateList {\\n    /// Create a new StateList. Not used for this problem.\\n    /// \\n    fn new() -> Self {\\n        Self { list: vec![] }\\n    }\\n    /// Creates new state list with a single state.out_n field handle.\\n    /// \\n    fn from_hout_n(hout_n: HStateField) -> Self {\\n        Self { list: vec![hout_n] }\\n    }\\n    /// Appends another StateList to this one. Not used for problem.\\n    /// \\n    fn append(&mut self, mut other: StateList) {\\n        self.list.append(&mut other.list);\\n    }\\n    /// Sets each State in the list to the one provided.\\n    /// \\n    fn patch(&self, s: HState, states: &mut States) {\\n        for &h in &self.list {\\n            *states.h2out_mut(h) = Some(s);\\n        }\\n    }\\n}\\nimpl From<HStateField> for StateList {\\n    /// Convert a HStateField into a StateList with a single item.\\n    /// \\n    fn from(hout_n: HStateField) -> Self {\\n        Self::from_hout_n(hout_n)\\n    }\\n}\\n\\n/// A set of states used during matching operations. Implemented as a vector\\n/// internally. The methods that take `set_id` use that variable to check\\n/// for set membership. This value increments each step operation.\\n/// \\nstruct FollowSet {\\n    set: Vec<HState>,\\n}\\nimpl FollowSet {\\n    fn new() -> Self { \\n        FollowSet { set: vec![] } \\n    }\\n    /// Compute initial state set.\\n    /// \\n    fn start(&mut self, \\n             start  : HState, \\n             states : &mut States, \\n             set_id : usize) \\n    { \\n        self.add(Some(start), states, set_id);\\n    }\\n    /// Returns the number of states.\\n    /// \\n    fn count(&self) -> usize {\\n        self.set.len()\\n    }\\n    \\n    fn clear(&mut self) {\\n        self.set.clear();\\n    }\\n    /// Add `state` to set, following \"unlabeled arrows\" (transitions).\\n    /// \\n    fn add(&mut self, \\n           state    : Option<HState>, \\n           states   : &mut States, \\n           set_id   : usize) \\n    {\\n        use Transition::*;\\n        macro_rules! state { ($h:expr) => { states.h2state($h) }; }\\n\\n        if let Some(h) = state {\\n            if state!(h).last_set != set_id {\\n                states.h2state_mut(h).last_set = set_id;\\n                if state!(h).c == Split {\\n                    // Follow unlabeled transitions.\\n                    self.add(state!(h).out_1, states, set_id);\\n                    self.add(state!(h).out_2, states, set_id);\\n                }\\n                else {\\n                    self.set.push(h);\\n                }\\n            }\\n        }\\n    }\\n    /// Step the NFA from the states in this set past the character `c` to\\n    /// create next NFA state set `next_set`.\\n    /// \\n    fn step(&mut self, \\n            c        : char, \\n            next_set : &mut FollowSet, \\n            states   : &mut States, \\n            set_id   : &mut usize) \\n    {\\n        use Transition::*;\\n        *set_id += 1;\\n        next_set.clear();\\n        for &h in &self.set {\\n            let s = states.h2state(h);\\n            if s.c == Char(c) || s.c == Char(\\'.\\') {\\n                next_set.add(s.out_1, states, *set_id);\\n            }\\n        }\\n    }\\n    /// Determine if set contains a match.\\n    /// \\n    fn is_match(&self, states: &States) -> bool {\\n        self.set.iter().any(|&h| states.h2state(h).c == Transition::Match)\\n    }\\n}\\n\\n/// Convert regular expression to its postfix representation.\\n///\\nfn re2postfix(re: String) -> Vec<char> {\\n    let mut outputq = vec![];\\n    let mut opstack = vec![];\\n    let mut buf     = Vec::with_capacity(2);\\n    let mut chars   = re.chars();\\n\\n    if let Some(ch) = chars.next() {\\n        outputq.push(ch);\\n    }\\n    for ch in chars {\\n        if ch != \\'*\\' { buf.push(\\'\\\\0\\'); }\\n\\n        buf.push(ch);\\n\\n        for ch in buf.drain(..) {\\n            match ch {\\n                \\'*\\' => {\\n                    while opstack.last() == Some(&\\'*\\') {\\n                        outputq.push(opstack.pop().unwrap());\\n                    }\\n                    opstack.push(ch);\\n                }\\n                \\'\\\\0\\' => {\\n                    while let Some(op) = opstack.pop() {\\n                        outputq.push(op);\\n                    }\\n                    opstack.push(ch);\\n                }\\n                _ => {\\n                    outputq.push(ch);\\n                }\\n            }\\n        }\\n    }\\n    while let Some(op) = opstack.pop() {\\n        outputq.push(op);\\n    }\\n    outputq\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::mem::swap;\\n\\nimpl Solution {\\n    pub fn is_match(s: String, p: String) -> bool {\\n\\n        MatcherNfa::new(p).full_match(s)\\n    }\\n}\\n\\n/// Represents Nondeterministic Finite Automata (state machines) constructed\\n/// using a regular expression, and used to determine if strings match it.\\n/// \\nstruct MatcherNfa {\\n    start   : HState,\\n    states  : States,\\n    set_id  : usize,\\n}\\n\\nimpl MatcherNfa {\\n    /// Creates a NFA state machine from a regular expression. Internally, the\\n    /// expression is converted to its postfix representation before building\\n    /// the NFA. Internally, \\'\\\\0\\' is treated as the postfix concatenation \\n    /// operator.\\n    /// \\n    fn new(p: String) -> Self {\\n        use Transition::*;\\n        let mut states  = States::new();\\n        let mut stack   = Vec::<Frag>::new();\\n        let     postfix = re2postfix(p);\\n\\n        for ch in postfix {\\n            match ch {\\n                \\'\\\\0\\' => {\\n                    // Handle postfix concatenation operator.\\n                    let e2 = stack.pop().unwrap();\\n                    let e1 = stack.pop().unwrap();\\n                    e1.out.patch(e2.start, &mut states);\\n                    stack.push(Frag::new(e1.start, e2.out));\\n                }\\n                \\'*\\' => {\\n                    // Handle \\'*\\' regular expression operator.\\n                    let e = stack.pop().unwrap();\\n                    let s = states.new_state(Split, Some(e.start), None);\\n                    e.out.patch(s, &mut states);\\n                    stack.push(Frag::new(s, s.out_n_handle(2).into()));\\n                }\\n                _ => {\\n                    // Treat all other characters as transition match chars. \\n                    let s = states.new_state(Char(ch), None, None);\\n                    stack.push(Frag::new(s, s.out_n_handle(1).into()));\\n                }\\n            }\\n        }\\n        let e = stack.pop().unwrap();\\n        let m = states.new_state(Match, None, None);\\n\\n        e.out.patch(m, &mut states);\\n\\n        MatcherNfa { start: e.start, states, set_id: 0 }\\n    }\\n    /// Run NFA to determine whether it matches `s`. Not a partial match.\\n    /// \\n    fn full_match(&mut self, s: String) -> bool {\\n        let mut curr_set = FollowSet::new();\\n        let mut next_set = FollowSet::new();\\n\\n        curr_set.start(self.start, &mut self.states, self.set_id);\\n\\n        for ch in s.chars() {\\n            curr_set.step(ch, \\n                          &mut next_set, \\n                          &mut self.states, \\n                          &mut self.set_id);\\n            \\n            swap(&mut curr_set, &mut next_set);\\n\\n            if curr_set.count() == 0 {\\n                break;\\n            }\\n        }\\n        curr_set.is_match(&self.states)\\n    }\\n}\\n\\n/// NFA state node.\\n/// \\n#[derive(Debug)]\\nstruct State {\\n    c         : Transition,\\n    out_1     : Option<HState>,\\n    out_2     : Option<HState>,\\n    last_set  : usize,\\n}\\n\\n/// Handle for State objects.\\n/// \\n#[derive(Copy, Clone, Debug)]\\nstruct HState { \\n    idx: usize \\n}\\nimpl HState {\\n    /// Create a new handle to a specific field of a State object.\\n    /// \\n    fn out_n_handle(&self, hout_n: u8) -> HStateField {\\n        HStateField { state: *self, which: hout_n }\\n    }\\n}\\n\\n/// A handle to the field of a State object. The associated fields are\\n/// `state.out_1` or `state.out_2`.\\n/// \\n#[derive(Copy, Clone, Debug)]\\nstruct HStateField {\\n    state: HState,\\n    which: u8,\\n}\\n\\n/// Contiguous memory storage for State objects.\\n/// \\nstruct States { \\n    mem: Vec<State>,\\n}\\nimpl States {\\n    /// Create a new States object to hold State objects.\\n    /// \\n    fn new() -> Self { \\n        States { mem: vec![] } \\n    }\\n    /// Creates a new State object and returns its handle.\\n    /// \\n    fn new_state(&mut self, \\n                 c      : Transition, \\n                 out_1  : Option<HState>, \\n                 out_2  : Option<HState>  ) -> HState \\n    {\\n        self.mem.push(State { c, out_1, out_2, last_set: usize::MAX });\\n        HState { idx: self.mem.len() - 1 }\\n    }\\n    /// Takes the handle of a State object and returns a reference to the \\n    /// object.\\n    /// \\n    fn h2state(&self, hstate: HState) -> &State {\\n        &self.mem[hstate.idx]\\n    }\\n    /// Takes the handle of a State object and returns a mutable reference to\\n    /// the object.\\n    /// \\n    fn h2state_mut(&mut self, hstate: HState) -> &mut State {\\n        &mut self.mem[hstate.idx]\\n    }\\n    /// Takes a handle to the field of a state object and returns a mutable\\n    /// reference to that field.\\n    /// \\n    fn h2out_mut(&mut self, hout_n: HStateField) -> &mut Option<HState> {\\n        match hout_n.which {\\n            1 => { &mut self.h2state_mut(hout_n.state).out_1 },\\n            2 => { &mut self.h2state_mut(hout_n.state).out_2 },\\n            _ => { panic!(\"Invalid field id.\") }\\n        }\\n    }\\n}\\n\\n/// NFA fragment. These are used to assemble the State graph.\\n/// \\nstruct Frag {\\n    start : HState,\\n    out   : StateList,\\n}\\nimpl Frag {\\n    fn new(start: HState, out: StateList) -> Self {\\n        Frag { start, out }\\n    }\\n}\\n\\n/// Represents transitions between states.\\n/// \\n#[derive(PartialEq, Debug)]\\nenum Transition {\\n    Char(char),\\n    Split,\\n    Match\\n}\\n\\n/// A list of State field handles. StateList\\'s are used together with `Frag`s\\n/// (fragments) when assembling the state graph. The name of this object may \\n/// seem like a slight misnomer; in the original implementation in C, this list\\n/// exists as a list of pointers to state pointers which enables updating the \\n/// out_1 and out_2 fields of the states. \\n/// \\nstruct StateList {\\n    list: Vec<HStateField>,\\n}\\nimpl StateList {\\n    /// Create a new StateList. Not used for this problem.\\n    /// \\n    fn new() -> Self {\\n        Self { list: vec![] }\\n    }\\n    /// Creates new state list with a single state.out_n field handle.\\n    /// \\n    fn from_hout_n(hout_n: HStateField) -> Self {\\n        Self { list: vec![hout_n] }\\n    }\\n    /// Appends another StateList to this one. Not used for problem.\\n    /// \\n    fn append(&mut self, mut other: StateList) {\\n        self.list.append(&mut other.list);\\n    }\\n    /// Sets each State in the list to the one provided.\\n    /// \\n    fn patch(&self, s: HState, states: &mut States) {\\n        for &h in &self.list {\\n            *states.h2out_mut(h) = Some(s);\\n        }\\n    }\\n}\\nimpl From<HStateField> for StateList {\\n    /// Convert a HStateField into a StateList with a single item.\\n    /// \\n    fn from(hout_n: HStateField) -> Self {\\n        Self::from_hout_n(hout_n)\\n    }\\n}\\n\\n/// A set of states used during matching operations. Implemented as a vector\\n/// internally. The methods that take `set_id` use that variable to check\\n/// for set membership. This value increments each step operation.\\n/// \\nstruct FollowSet {\\n    set: Vec<HState>,\\n}\\nimpl FollowSet {\\n    fn new() -> Self { \\n        FollowSet { set: vec![] } \\n    }\\n    /// Compute initial state set.\\n    /// \\n    fn start(&mut self, \\n             start  : HState, \\n             states : &mut States, \\n             set_id : usize) \\n    { \\n        self.add(Some(start), states, set_id);\\n    }\\n    /// Returns the number of states.\\n    /// \\n    fn count(&self) -> usize {\\n        self.set.len()\\n    }\\n    \\n    fn clear(&mut self) {\\n        self.set.clear();\\n    }\\n    /// Add `state` to set, following \"unlabeled arrows\" (transitions).\\n    /// \\n    fn add(&mut self, \\n           state    : Option<HState>, \\n           states   : &mut States, \\n           set_id   : usize) \\n    {\\n        use Transition::*;\\n        macro_rules! state { ($h:expr) => { states.h2state($h) }; }\\n\\n        if let Some(h) = state {\\n            if state!(h).last_set != set_id {\\n                states.h2state_mut(h).last_set = set_id;\\n                if state!(h).c == Split {\\n                    // Follow unlabeled transitions.\\n                    self.add(state!(h).out_1, states, set_id);\\n                    self.add(state!(h).out_2, states, set_id);\\n                }\\n                else {\\n                    self.set.push(h);\\n                }\\n            }\\n        }\\n    }\\n    /// Step the NFA from the states in this set past the character `c` to\\n    /// create next NFA state set `next_set`.\\n    /// \\n    fn step(&mut self, \\n            c        : char, \\n            next_set : &mut FollowSet, \\n            states   : &mut States, \\n            set_id   : &mut usize) \\n    {\\n        use Transition::*;\\n        *set_id += 1;\\n        next_set.clear();\\n        for &h in &self.set {\\n            let s = states.h2state(h);\\n            if s.c == Char(c) || s.c == Char(\\'.\\') {\\n                next_set.add(s.out_1, states, *set_id);\\n            }\\n        }\\n    }\\n    /// Determine if set contains a match.\\n    /// \\n    fn is_match(&self, states: &States) -> bool {\\n        self.set.iter().any(|&h| states.h2state(h).c == Transition::Match)\\n    }\\n}\\n\\n/// Convert regular expression to its postfix representation.\\n///\\nfn re2postfix(re: String) -> Vec<char> {\\n    let mut outputq = vec![];\\n    let mut opstack = vec![];\\n    let mut buf     = Vec::with_capacity(2);\\n    let mut chars   = re.chars();\\n\\n    if let Some(ch) = chars.next() {\\n        outputq.push(ch);\\n    }\\n    for ch in chars {\\n        if ch != \\'*\\' { buf.push(\\'\\\\0\\'); }\\n\\n        buf.push(ch);\\n\\n        for ch in buf.drain(..) {\\n            match ch {\\n                \\'*\\' => {\\n                    while opstack.last() == Some(&\\'*\\') {\\n                        outputq.push(opstack.pop().unwrap());\\n                    }\\n                    opstack.push(ch);\\n                }\\n                \\'\\\\0\\' => {\\n                    while let Some(op) = opstack.pop() {\\n                        outputq.push(op);\\n                    }\\n                    opstack.push(ch);\\n                }\\n                _ => {\\n                    outputq.push(ch);\\n                }\\n            }\\n        }\\n    }\\n    while let Some(op) = opstack.pop() {\\n        outputq.push(op);\\n    }\\n    outputq\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1618940,
                "title": "beginner-friendly-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isMatch(String text, String pattern) {\\n//      This will help us at the end mainly for the else part given below.\\n        if(pattern.length() == 0)\\n           return text.length() == 0;\\n//      here is the condition if * encountered and then we are focusion how to handle the cases\\n        if(pattern.length() > 1 && pattern.charAt(1) == \\'*\\'){\\n            if(isMatch(text, pattern.substring(2)))\\n               return true;\\n            if(text.length() > 0 && (pattern.charAt(0) == \\'.\\' || text.charAt(0) == pattern.charAt(0)))\\n                return isMatch(text.substring(1), pattern);\\n            return false;\\n        }else{\\n//      here we just have to check if characters are eqal to each other else if \\'.\\' is present working as single integer\\n            if(text.length() > 0 && (pattern.charAt(0) == \\'.\\' || text.charAt(0) == pattern.charAt(0)))\\n                return isMatch(text.substring(1), pattern.substring(1));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String text, String pattern) {\\n//      This will help us at the end mainly for the else part given below.\\n        if(pattern.length() == 0)\\n           return text.length() == 0;\\n//      here is the condition if * encountered and then we are focusion how to handle the cases\\n        if(pattern.length() > 1 && pattern.charAt(1) == \\'*\\'){\\n            if(isMatch(text, pattern.substring(2)))\\n               return true;\\n            if(text.length() > 0 && (pattern.charAt(0) == \\'.\\' || text.charAt(0) == pattern.charAt(0)))\\n                return isMatch(text.substring(1), pattern);\\n            return false;\\n        }else{\\n//      here we just have to check if characters are eqal to each other else if \\'.\\' is present working as single integer\\n            if(text.length() > 0 && (pattern.charAt(0) == \\'.\\' || text.charAt(0) == pattern.charAt(0)))\\n                return isMatch(text.substring(1), pattern.substring(1));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902592,
                "title": "c-100-faster-solution",
                "content": "```\\nbool isMatch(string s, string p) {\\n        int n = s.length(),m=p.length();\\n        int t[n+1][m+1];\\n        t[0][0]=true; \\n        // if both of are 0 length\\n        \\n        if(m) t[0][1]=false;\\n        // if string length is 0 and pattern length is 1 it will always be 0\\n        \\n        // if length of string is greater than 1 ans pattern length is 0\\n        for(int i=1;i<=n;i++)\\n        {\\n            t[i][0]=false;\\n        }\\n        \\n        // A base case where string length is 0 but pattern length is not 0\\n        for(int j=2;j<=m;j++)\\n        {\\n            if(p[j-1]==\\'*\\') // consider example p = \"a*b*c*\" but s=\"\"\\n                t[0][j] = t[0][j-2];\\n            else t[0][j] = false;\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n        \\n                if(p[j-1]==\\'.\\'|| p[j-1]==s[i-1]) t[i][j] = t[i-1][j-1];\\n                // if two character matches or one of them is \".\"\\n                \\n                else if(p[j-1]==\\'*\\' && j>1){ // if there is * in pattern we have to check for character behind * \\n                    if(p[j-2]==s[i-1] || p[j-2]==\\'.\\'){\\n                        t[i][j] = t[i][j-2] || t[i-1][j];\\n                    }\\n                    else{\\n                        t[i][j] = t[i][j-2];\\n                    }\\n                }\\n                else t[i][j]=false;\\n            }\\n        }\\n        return t[n][m];\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nbool isMatch(string s, string p) {\\n        int n = s.length(),m=p.length();\\n        int t[n+1][m+1];\\n        t[0][0]=true; \\n        // if both of are 0 length\\n        \\n        if(m) t[0][1]=false;\\n        // if string length is 0 and pattern length is 1 it will always be 0\\n        \\n        // if length of string is greater than 1 ans pattern length is 0\\n        for(int i=1;i<=n;i++)\\n        {\\n            t[i][0]=false;\\n        }\\n        \\n        // A base case where string length is 0 but pattern length is not 0\\n        for(int j=2;j<=m;j++)\\n        {\\n            if(p[j-1]==\\'*\\') // consider example p = \"a*b*c*\" but s=\"\"\\n                t[0][j] = t[0][j-2];\\n            else t[0][j] = false;\\n        }\\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n        \\n                if(p[j-1]==\\'.\\'|| p[j-1]==s[i-1]) t[i][j] = t[i-1][j-1];\\n                // if two character matches or one of them is \".\"\\n                \\n                else if(p[j-1]==\\'*\\' && j>1){ // if there is * in pattern we have to check for character behind * \\n                    if(p[j-2]==s[i-1] || p[j-2]==\\'.\\'){\\n                        t[i][j] = t[i][j-2] || t[i-1][j];\\n                    }\\n                    else{\\n                        t[i][j] = t[i][j-2];\\n                    }\\n                }\\n                else t[i][j]=false;\\n            }\\n        }\\n        return t[n][m];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 887574,
                "title": "solved-invalid-test-case-leetcode-admin-please-check-this-post",
                "content": "When I submitted my code, it gave me error with one of the test case\\ntext: \"aa\"\\npattern: \"*a\"\\n\\nBut when I tried it using console, it says, invalid testcase. \\n\\n@leetcode @leetcodeAdmin\\n\\nPlease find below code \\n\\n```\\n\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        //DP Solution from Tushar Roy\\n        \\n        \\n        \\n        char[] text = s.toCharArray();\\n        char[] pattern = p.toCharArray();\\n        \\n        if(pattern[0] == \\'*\\'){\\n            return false;\\n        }\\n        \\n        boolean T[][] = new boolean[text.length + 1][pattern.length + 1];\\n        T[0][0] = true;\\n       \\n        /*\\n        Below First for loop deals with patterns like a* or a*b* or a*b*c*\\n        \\n        If pattern contains * as suffix of every letter then \\n        with empty String at every *, we can mark it true;\\n        \\n        For ex: text =\"\" pattern = \"a*b*c*\"\\n                    1   2   3   4   5   6\\n              (0)   a   *   b   *   c   *\\n   \"\"       \\n        (0)    T    F   T   F   T   F   T\\n               |        |       |       |\\n               | i=2-2  | i=4-2 | i=6-2 |\\n               |________|_______|_______|       \\n       */\\n        \\n        for (int i = 1; i < T[0].length; i++) {\\n            if (pattern[i - 1] == \\'*\\') {\\n                T[0][i] = T[0][i - 2];\\n            }\\n        }\\n        \\n        \\n        \\n        for (int i = 1; i < T.length; i++) {\\n            for (int j = 1; j < T[0].length; j++) {\\n                \\n                //if character matches or there is a . check the diagonal value\\n                \\n                if (pattern[j - 1] == \\'.\\' || pattern[j - 1] == text[i - 1]) {\\n                    T[i][j] = T[i - 1][j - 1];    \\n                } \\n                //else if there is a \\'*\\' then either character before * (which could be . as well)\\n\\t\\t\\t\\t//can appear or may not appear at all. \\n\\t\\t\\t\\t//So just take value from 2 steps behind or from top.\\n\\t\\t\\t\\t//If either of them is True, it means, regex is possible.\\n                else if (pattern[j - 1] == \\'*\\') {\\n                    T[i][j] = T[i][j - 2];\\n                    if (pattern[j - 2] == \\'.\\' || pattern[j - 2] == text[i - 1]) {\\n                        T[i][j] = T[i][j] | T[i - 1][j];\\n                    }\\n                } \\n                //If none of the above conditions are true, just make it false.\\n                \\n                else {\\n                    T[i][j] = false;\\n                }\\n            }\\n        }\\n        //at the end just return last value\\n        return T[text.length][pattern.length]; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isMatch(String s, String p) {\\n        //DP Solution from Tushar Roy\\n        \\n        \\n        \\n        char[] text = s.toCharArray();\\n        char[] pattern = p.toCharArray();\\n        \\n        if(pattern[0] == \\'*\\'){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 443752,
                "title": "clear-explanation-of-java-dynamic-programming-all-100",
                "content": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        /**\\n         * dp is a N+1 x M+1 matrix; N is the length of s and M is the length of p\\n         * dp[i][j] represents if first i characters of s match first j characters of p\\n         * */\\n        boolean[][] dp = new boolean[s.length()+1][p.length()+1];\\n        /**\\n         * base case:\\n         * empty string s matches empty string p -> dp[0][0] = true\\n         * non-empty string s never match empty string p -> dp[i][0] = false\\n         */\\n        dp[0][0] = true;\\n        for (int i = 1; i < dp.length; i++) {\\n            dp[i][0] = false;\\n        }\\n\\n        /**\\n         * dynamic programming process\\n         * skip the first column because already filled as base case\\n         */\\n        for (int i = 0; i < dp.length; i++) {\\n            for (int j = 1; j < dp[i].length; j++) {\\n                if (i == 0) {\\n                    // at the first row\\n                    if (p.charAt(j-1) == \\'*\\' && j > 1) {\\n                        /**\\n                         * only if jth character in p is \\'*\\', possible to evaluate to true\\n                         * if j == 2, dp[0][2] definitely true because \\'*\\' means can also mean 0 occurrence\\n                         * Similarly, if dp[i][j-2] is true, dp[i][j] is true becuase of 0 occurrence\\n                         */\\n                        dp[i][j] = (j == 2 || dp[i][j-2]);\\n                    } else {\\n                         // otherwise, a non-empty p and an empty s never match without the use of \\'*\\'\\n                        dp[i][j] = false;\\n                    }\\n                } else if (p.charAt(j-1) == \\'.\\') {\\n                    // If p\\'s latest character is \\'.\\', dp[i][j] is equivalent to dp[i-1][j-1] because the newest characters are guaranteed to match\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else if (p.charAt(j-1) == \\'*\\') {\\n                    if (dp[i-1][j]) {\\n                        /**\\n                         * if p\\'s newest chracter is \\'*\\' and dp[i-1][j] is true (this substring in p has been matching)\\n                         * dp[i][j] is true when the newst character in s matches the one representeed by \\'*\\': s.charAt(i-1) == p.charAt(j-2)\\n                         * dp[i][j] is true when the \\'*\\' represents \\'.\\': p.charAt(j-2) == \\'.\\'\\n                         * dp[i][j] is true when dp[i][j-2] is true because 0 occurrence of the character represented by \\'*\\'\\n                         **/\\n                        dp[i][j] = s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == \\'.\\' || dp[i][j-2];\\n                    } else {\\n                        /**\\n                         * if p\\'s newest chracter is \\'*\\' and dp[i-1][j] is false (this substring in p hasn\\'t matched)\\n                         * check if this new one gives a match: if dp[i][j-2] is true, dp[i][j] is true because of 0 occurrence of the \\'*\\' character\\n                         **/\\n                        dp[i][j] = dp[i][j-2];\\n                    }\\n                } else {\\n                    /**\\n                     * if jth character in p is just a normal letter, check if this matches with the ith character in s\\n                     * If they match, dp[i][j] is true only if dp[i-1][j-1] is true (same idea as palindrome)\\n                     */\\n                    dp[i][j] = dp[i-1][j-1] && s.charAt(i-1) == p.charAt(j-1);\\n                }\\n            }\\n        }\\n\\n        return dp[s.length()][p.length()];\\n    }\\n}\\n\\n/**\\n * Time: O(MN)\\n * Space: O(MN)\\n * N is the length of string s, M is the length of string p\\n *\\n * Intuition: (DP)\\n * f(i,j) = if the length i prefix of s matches the length j prefix of p\\n *\\n * Base:\\n * f(0,0) = true; empty s matches empty p\\n * f(i,0) = false, where i > 0; non-empty s never matches empty p\\n * f(0,1) = false; empty s never matches length 1 p\\n *\\n * Result: f(length of s, length of p)\\n *\\n * Tansition:\\n * f(i,j) = f(i-1,j-1) && ith character in s == jth character in p; exact character match\\n * OR\\n * f(i,j) = f(i-1,j-1) && jth character in p is \\'.\\'; \\'.\\' is a universial match\\n * OR\\n * if jth character in p is \\'*\\':\\n *     f(i,j) = f(i-1,j) && (ith character in s == the character represented by * || * represents . || f(i,j-2))\\n *         {if p already matches with s before the newest character in s,\\n *         then the newest character in s just needs to equal to the character represented by *\\n *         OR s matches p with 0 occurrence of the character represented by *, which is f(i,j-2)}\\n *     f(i,j) = !f(i-1,j) && f(i,j-2)\\n *          {if p didn\\'t match with s before the newest character in s,\\n *          then check if the newest character in s makes it a match: f(i,j-2) -> 0 occurrence of the character represented by *}\\n *     f(i,j) = true if i == 0 && (j == 2 || f(i,j-2))\\n *          {if s is empty, true, if the last character is \\'*\\' on the 2nd index or if f(i,j-2) because of 0 occurrence of character represented by *}\\n *\\n *\\n * s = \\'aaa\\'\\n * p = \\'ab*a*c*a\\'\\n *\\n * Base Case:\\n *   - a b * a * c * a\\n * - T F\\n * a F\\n * a F\\n * a F\\n *\\n * Keep Going (non-empty p matches empty s olny when using \\'*\\' appropriately):\\n *   - a b * a * c * a\\n * - T F F F F F F F F\\n * a F\\n * a F\\n * a F\\n *\\n * Keep Going (0 occurrence of character represented by * would give it true):\\n *   - a b * a * c * a\\n * - T F F F F F F F F\\n * a F T F T F T F T F\\n * a F F F F T T F F T\\n * a F F F F F T F T T -> result\\n *\\n * */\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        /**\\n         * dp is a N+1 x M+1 matrix; N is the length of s and M is the length of p\\n         * dp[i][j] represents if first i characters of s match first j characters of p\\n         * */\\n        boolean[][] dp = new boolean[s.length()+1][p.length()+1];\\n        /**\\n         * base case:\\n         * empty string s matches empty string p -> dp[0][0] = true\\n         * non-empty string s never match empty string p -> dp[i][0] = false\\n         */\\n        dp[0][0] = true;\\n        for (int i = 1; i < dp.length; i++) {\\n            dp[i][0] = false;\\n        }\\n\\n        /**\\n         * dynamic programming process\\n         * skip the first column because already filled as base case\\n         */\\n        for (int i = 0; i < dp.length; i++) {\\n            for (int j = 1; j < dp[i].length; j++) {\\n                if (i == 0) {\\n                    // at the first row\\n                    if (p.charAt(j-1) == \\'*\\' && j > 1) {\\n                        /**\\n                         * only if jth character in p is \\'*\\', possible to evaluate to true\\n                         * if j == 2, dp[0][2] definitely true because \\'*\\' means can also mean 0 occurrence\\n                         * Similarly, if dp[i][j-2] is true, dp[i][j] is true becuase of 0 occurrence\\n                         */\\n                        dp[i][j] = (j == 2 || dp[i][j-2]);\\n                    } else {\\n                         // otherwise, a non-empty p and an empty s never match without the use of \\'*\\'\\n                        dp[i][j] = false;\\n                    }\\n                } else if (p.charAt(j-1) == \\'.\\') {\\n                    // If p\\'s latest character is \\'.\\', dp[i][j] is equivalent to dp[i-1][j-1] because the newest characters are guaranteed to match\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else if (p.charAt(j-1) == \\'*\\') {\\n                    if (dp[i-1][j]) {\\n                        /**\\n                         * if p\\'s newest chracter is \\'*\\' and dp[i-1][j] is true (this substring in p has been matching)\\n                         * dp[i][j] is true when the newst character in s matches the one representeed by \\'*\\': s.charAt(i-1) == p.charAt(j-2)\\n                         * dp[i][j] is true when the \\'*\\' represents \\'.\\': p.charAt(j-2) == \\'.\\'\\n                         * dp[i][j] is true when dp[i][j-2] is true because 0 occurrence of the character represented by \\'*\\'\\n                         **/\\n                        dp[i][j] = s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == \\'.\\' || dp[i][j-2];\\n                    } else {\\n                        /**\\n                         * if p\\'s newest chracter is \\'*\\' and dp[i-1][j] is false (this substring in p hasn\\'t matched)\\n                         * check if this new one gives a match: if dp[i][j-2] is true, dp[i][j] is true because of 0 occurrence of the \\'*\\' character\\n                         **/\\n                        dp[i][j] = dp[i][j-2];\\n                    }\\n                } else {\\n                    /**\\n                     * if jth character in p is just a normal letter, check if this matches with the ith character in s\\n                     * If they match, dp[i][j] is true only if dp[i-1][j-1] is true (same idea as palindrome)\\n                     */\\n                    dp[i][j] = dp[i-1][j-1] && s.charAt(i-1) == p.charAt(j-1);\\n                }\\n            }\\n        }\\n\\n        return dp[s.length()][p.length()];\\n    }\\n}\\n\\n/**\\n * Time: O(MN)\\n * Space: O(MN)\\n * N is the length of string s, M is the length of string p\\n *\\n * Intuition: (DP)\\n * f(i,j) = if the length i prefix of s matches the length j prefix of p\\n *\\n * Base:\\n * f(0,0) = true; empty s matches empty p\\n * f(i,0) = false, where i > 0; non-empty s never matches empty p\\n * f(0,1) = false; empty s never matches length 1 p\\n *\\n * Result: f(length of s, length of p)\\n *\\n * Tansition:\\n * f(i,j) = f(i-1,j-1) && ith character in s == jth character in p; exact character match\\n * OR\\n * f(i,j) = f(i-1,j-1) && jth character in p is \\'.\\'; \\'.\\' is a universial match\\n * OR\\n * if jth character in p is \\'*\\':\\n *     f(i,j) = f(i-1,j) && (ith character in s == the character represented by * || * represents . || f(i,j-2))\\n *         {if p already matches with s before the newest character in s,\\n *         then the newest character in s just needs to equal to the character represented by *\\n *         OR s matches p with 0 occurrence of the character represented by *, which is f(i,j-2)}\\n *     f(i,j) = !f(i-1,j) && f(i,j-2)\\n *          {if p didn\\'t match with s before the newest character in s,\\n *          then check if the newest character in s makes it a match: f(i,j-2) -> 0 occurrence of the character represented by *}\\n *     f(i,j) = true if i == 0 && (j == 2 || f(i,j-2))\\n *          {if s is empty, true, if the last character is \\'*\\' on the 2nd index or if f(i,j-2) because of 0 occurrence of character represented by *}\\n *\\n *\\n * s = \\'aaa\\'\\n * p = \\'ab*a*c*a\\'\\n *\\n * Base Case:\\n *   - a b * a * c * a\\n * - T F\\n * a F\\n * a F\\n * a F\\n *\\n * Keep Going (non-empty p matches empty s olny when using \\'*\\' appropriately):\\n *   - a b * a * c * a\\n * - T F F F F F F F F\\n * a F\\n * a F\\n * a F\\n *\\n * Keep Going (0 occurrence of character represented by * would give it true):\\n *   - a b * a * c * a\\n * - T F F F F F F F F\\n * a F T F T F T F T F\\n * a F F F F T T F F T\\n * a F F F F F T F T T -> result\\n *\\n * */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5777,
                "title": "golang-concise-3ms-dp-solution-with-an-explanation-comment",
                "content": "I first deal with the \"empty\" string case for both s and p, then proceed the normal cases.\\nThis was quite difficult, especially to figure out the exact condition when `p[j-1] == '*'` :-\\\\\\n\\n```\\npackage main\\n\\nfunc isMatch(s string, p string) bool {\\n\\tslen, plen := len(s), len(p)\\n\\tvar dp [][]bool\\n\\tvar t []bool\\n\\tfor i := 0; i <= slen; i++ {\\n\\t\\tt = make([]bool, plen+1)\\n\\t\\tdp = append(dp, t)\\n\\t}\\n\\n\\t// dp[i][j] holds a flag that whether s[0:i] mathes to p[0:j].\\n\\t// (Note that we take the 0th index as \"empty\" string case)\\n\\tfor i := 0; i <= slen; i++ {\\n\\t\\tfor j := 0; j <= plen; j++ {\\n\\t\\t\\tif i == 0 && j == 0 {\\n\\t\\t\\t\\t// in case both s and p are empty\\n\\t\\t\\t\\tdp[i][j] = true\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else if i == 0 {\\n\\t\\t\\t\\t// in case only s is empty.\\n\\t\\t\\t\\t// To match an empty string, p should be like a*, a*b*, a*.*a*, ....\\n\\t\\t\\t\\t// (* should appear in all odd indexes of p)\\n\\t\\t\\t\\tdp[i][j] = ((j-1)%2 == 1 && p[j-1] == '*' && dp[i][j-2])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else if j == 0 {\\n\\t\\t\\t\\t// in case only p is mepty.\\n\\t\\t\\t\\t// No string s cannot match to empty regular expression\\n\\t\\t\\t\\t// unless s itself is empty too (which is already handled)\\n\\t\\t\\t\\tdp[i][j] = false\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\t// in case both s and p are non-empty\\n\\t\\t\\t// consider what should be sufficed to be able to say s[i-1] matches to p[j-1]\\n\\t\\t\\t// (= dp[i][j] is true).\\n\\t\\t\\tif p[j-1] != '*' {\\n\\t\\t\\t\\t// if p[j-1] is not '*', then\\n\\t\\t\\t\\t// 1) p[j-1] and s[j-1] should match (same character or p[j-1] == '.')\\n\\t\\t\\t\\t// 2) p[0:j-1] should match to s[0:i-1]\\n\\t\\t\\t\\tdp[i][j] = (p[j-1] == s[i-1] || p[j-1] == '.') && dp[i-1][j-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// if p[j-1] is '*', we need to consider two scenarios\\n\\t\\t\\t\\t// case1) consume the '*'\\n\\t\\t\\t\\t// to consume * and have s[:i] match to p[:j],\\n\\t\\t\\t\\t// p[j-2] should equal to s[i-1] (or p[j-2] can be '.' to be equal to any s[i-1])\\n\\t\\t\\t\\t// AND s[:i-1] should match to p[:j] as well.\\n\\t\\t\\t\\t//                 \\u2193 i-1\\n\\t\\t\\t\\t// s: [ ] [ ] [a] [a]\\n\\t\\t\\t\\t// p: [ ] [a] [*] [ ]\\n\\t\\t\\t\\t//             \\u2191 j-1\\n\\t\\t\\t\\t//\\n\\t\\t\\t\\t//                 \\u2193 i-1\\n\\t\\t\\t\\t// s: [ ] [ ] [b] [a]\\n\\t\\t\\t\\t// p: [ ] [.] [*] [ ]\\n\\t\\t\\t\\t//             \\u2191 j-1\\n\\t\\t\\t\\t// in other words, because '*' is used with its previous character,\\n\\t\\t\\t\\t// for s[i-1] to be included as \"a*\" or \".*\" in p,\\n\\t\\t\\t\\t// s[i-2] should also be included in \"a*\" or \".*\".\\n\\t\\t\\t\\tif p[j-2] == '.' || p[j-2] == s[i-1] {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// case2) skip the '*'\\n\\t\\t\\t\\t//                 \\u2193 i-1\\n\\t\\t\\t\\t// s: [ ] [ ] [b] [a]\\n\\t\\t\\t\\t// p: [a] [b] [*] [ ]\\n\\t\\t\\t\\t//     \\u2191 j-3   \\u2191 j-1\\n\\t\\t\\t\\t// even if we can't fulfill the condition above, if s[:i-1] matches to p[j-3],\\n\\t\\t\\t\\t// we can say s[:i-1] also matches to p[j-1]\\n\\t\\t\\t\\t// because '*' can mean \"zero\" appearance of the previous character.\\n\\t\\t\\t\\t// in other words, we can just skip \"b*\", not using it.\\n\\t\\t\\t\\tif dp[i][j-2] == true {\\n\\t\\t\\t\\t\\tdp[i][j] = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[slen][plen]\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nfunc isMatch(s string, p string) bool {\\n\\tslen, plen := len(s), len(p)\\n\\tvar dp [][]bool\\n\\tvar t []bool\\n\\tfor i := 0; i <= slen; i++ {\\n\\t\\tt = make([]bool, plen+1)\\n\\t\\tdp = append(dp, t)\\n\\t}\\n\\n\\t// dp[i][j] holds a flag that whether s[0:i] mathes to p[0:j].\\n\\t// (Note that we take the 0th index as \"empty\" string case)\\n\\tfor i := 0; i <= slen; i++ {\\n\\t\\tfor j := 0; j <= plen; j++ {\\n\\t\\t\\tif i == 0 && j == 0 {\\n\\t\\t\\t\\t// in case both s and p are empty\\n\\t\\t\\t\\tdp[i][j] = true\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else if i == 0 {\\n\\t\\t\\t\\t// in case only s is empty.\\n\\t\\t\\t\\t// To match an empty string, p should be like a*, a*b*, a*.*a*, ....\\n\\t\\t\\t\\t// (* should appear in all odd indexes of p)\\n\\t\\t\\t\\tdp[i][j] = ((j-1)%2 == 1 && p[j-1] == '*' && dp[i][j-2])\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else if j == 0 {\\n\\t\\t\\t\\t// in case only p is mepty.\\n\\t\\t\\t\\t// No string s cannot match to empty regular expression\\n\\t\\t\\t\\t// unless s itself is empty too (which is already handled)\\n\\t\\t\\t\\tdp[i][j] = false\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\t// in case both s and p are non-empty\\n\\t\\t\\t// consider what should be sufficed to be able to say s[i-1] matches to p[j-1]\\n\\t\\t\\t// (= dp[i][j] is true).\\n\\t\\t\\tif p[j-1] != '*' {\\n\\t\\t\\t\\t// if p[j-1] is not '*', then\\n\\t\\t\\t\\t// 1) p[j-1] and s[j-1] should match (same character or p[j-1] == '.')\\n\\t\\t\\t\\t// 2) p[0:j-1] should match to s[0:i-1]\\n\\t\\t\\t\\tdp[i][j] = (p[j-1] == s[i-1] || p[j-1] == '.') && dp[i-1][j-1]\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// if p[j-1] is '*', we need to consider two scenarios\\n\\t\\t\\t\\t// case1) consume the '*'\\n\\t\\t\\t\\t// to consume * and have s[:i] match to p[:j],\\n\\t\\t\\t\\t// p[j-2] should equal to s[i-1] (or p[j-2] can be '.' to be equal to any s[i-1])\\n\\t\\t\\t\\t// AND s[:i-1] should match to p[:j] as well.\\n\\t\\t\\t\\t//                 \\u2193 i-1\\n\\t\\t\\t\\t// s: [ ] [ ] [a] [a]\\n\\t\\t\\t\\t// p: [ ] [a] [*] [ ]\\n\\t\\t\\t\\t//             \\u2191 j-1\\n\\t\\t\\t\\t//\\n\\t\\t\\t\\t//                 \\u2193 i-1\\n\\t\\t\\t\\t// s: [ ] [ ] [b] [a]\\n\\t\\t\\t\\t// p: [ ] [.] [*] [ ]\\n\\t\\t\\t\\t//             \\u2191 j-1\\n\\t\\t\\t\\t// in other words, because '*' is used with its previous character,\\n\\t\\t\\t\\t// for s[i-1] to be included as \"a*\" or \".*\" in p,\\n\\t\\t\\t\\t// s[i-2] should also be included in \"a*\" or \".*\".\\n\\t\\t\\t\\tif p[j-2] == '.' || p[j-2] == s[i-1] {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// case2) skip the '*'\\n\\t\\t\\t\\t//                 \\u2193 i-1\\n\\t\\t\\t\\t// s: [ ] [ ] [b] [a]\\n\\t\\t\\t\\t// p: [a] [b] [*] [ ]\\n\\t\\t\\t\\t//     \\u2191 j-3   \\u2191 j-1\\n\\t\\t\\t\\t// even if we can't fulfill the condition above, if s[:i-1] matches to p[j-3],\\n\\t\\t\\t\\t// we can say s[:i-1] also matches to p[j-1]\\n\\t\\t\\t\\t// because '*' can mean \"zero\" appearance of the previous character.\\n\\t\\t\\t\\t// in other words, we can just skip \"b*\", not using it.\\n\\t\\t\\t\\tif dp[i][j-2] == true {\\n\\t\\t\\t\\t\\tdp[i][j] = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[slen][plen]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5998,
                "title": "share-a-java-solution-just-like-a-nfa-regex-engine",
                "content": "\\n\\n\\n    public boolean isMatch(String s, String p) {\\n        return _isMatch(0, 0, s, p);\\n    }\\n    \\n    private boolean _isMatch(int tPos, int rPos, String s, String p) {\\n    \\t//boundary checking\\n        if (tPos == s.length() || rPos == p.length()) {\\n            if (tPos == s.length() && rPos == p.length())\\n                return true;\\n            //The following is used to check \"aaaa\", \"aaaaa*a*\"\\n            if (tPos == s.length() && rPos < p.length() - 1 && p.charAt(rPos + 1) == '*')\\n                return _isMatch(tPos, rPos + 2, s, p);\\n            //match failed\\n            return false;\\n        }\\n        //not match at current position, if no *, then match failed\\n        //Otherwise we can skip the current * in the regex and continue\\n        //to next match.\\n        if (s.charAt(tPos) != p.charAt(rPos) && p.charAt(rPos) != '.') {\\n        \\t//no *, match failed\\n            if (rPos == p.length() - 1 || p.charAt(rPos + 1) != '*') \\n                return false;\\n            //skip the *\\n            return _isMatch(tPos, rPos + 2, s, p);\\n        }\\n        //match at current position, if no *, then continue to match the next\\n        //position both in text and regex.\\n        //Otherwise try to match one more chars and provide states for backtrack\\n        if (rPos == p.length() - 1 || p.charAt(rPos + 1) != '*') \\n            return _isMatch(tPos + 1, rPos + 1, s, p);\\n\\n        return _isMatch(tPos + 1, rPos, s, p) || _isMatch(tPos, rPos + 2, s, p);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "\\n\\n\\n    public boolean isMatch(String s, String p) {\\n        return _isMatch(0, 0, s, p);\\n    }\\n    \\n    private boolean _isMatch(int tPos, int rPos, String s, String p) {\\n    \\t//boundary checking\\n        if (tPos == s.length() || rPos == p.length()) {\\n            if (tPos == s.length() && rPos == p.length())\\n                return true;\\n            //The following is used to check \"aaaa\", \"aaaaa*a*\"\\n            if (tPos == s.length() && rPos < p.length() - 1 && p.charAt(rPos + 1) == '*')\\n                return _isMatch(tPos, rPos + 2, s, p);\\n            //match failed\\n            return false;\\n        }\\n        //not match at current position, if no *, then match failed\\n        //Otherwise we can skip the current * in the regex and continue\\n        //to next match.\\n        if (s.charAt(tPos) != p.charAt(rPos) && p.charAt(rPos) != '.') {\\n        \\t//no *, match failed\\n            if (rPos == p.length() - 1 || p.charAt(rPos + 1) != '*') \\n                return false;\\n            //skip the *\\n            return _isMatch(tPos, rPos + 2, s, p);\\n        }\\n        //match at current position, if no *, then continue to match the next\\n        //position both in text and regex.\\n        //Otherwise try to match one more chars and provide states for backtrack\\n        if (rPos == p.length() - 1 || p.charAt(rPos + 1) != '*') \\n            return _isMatch(tPos + 1, rPos + 1, s, p);\\n\\n        return _isMatch(tPos + 1, rPos, s, p) || _isMatch(tPos, rPos + 2, s, p);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2532721,
                "title": "dynamic-programming-python",
                "content": "Please upvote this post if you find it helpful.\\n\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n_s=len(s)\\n        n_p=len(p)\\n        dp=[[False]*(n_p+1) for _ in range(n_s+1)]\\n        dp[0][0]=True\\n        \\n        \\n        #For empty string but the \"*\" in pattern might return True\\n        for i in range(1,n_p+1):\\n            if p[i-1]==\"*\":\\n                dp[0][i]=dp[0][i-2]\\n        \\n        for i in range(1,n_s+1):\\n            for j in range(1,n_p+1):\\n                #When the character in string matches with the patter or the pattern has \\'.\\', which accepts any character\\n                if s[i-1]==p[j-1] or p[j-1]==\\'.\\':\\n                    dp[i][j]=dp[i-1][j-1]\\n                #When the pattern has \"*\", this shows that we need to check the [j-2] for the character, which can be the string character or \\'.\\'. In this case we will check the [i-1][j], to check if the character except the current one is True.\\n                \\n                elif p[j-1]==\"*\":\\n                    dp[i][j]=dp[i][j-2]\\n                    if p[j-2]==\\'.\\' or p[j-2]==s[i-1]:\\n                        dp[i][j]=dp[i][j] or dp[i-1][j]\\n                    \\n            \\n        return dp[n_s][n_p]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n_s=len(s)\\n        n_p=len(p)\\n        dp=[[False]*(n_p+1) for _ in range(n_s+1)]\\n        dp[0][0]=True\\n        \\n        \\n        #For empty string but the \"*\" in pattern might return True\\n        for i in range(1,n_p+1):\\n            if p[i-1]==\"*\":\\n                dp[0][i]=dp[0][i-2]\\n        \\n        for i in range(1,n_s+1):\\n            for j in range(1,n_p+1):\\n                #When the character in string matches with the patter or the pattern has \\'.\\', which accepts any character\\n                if s[i-1]==p[j-1] or p[j-1]==\\'.\\':\\n                    dp[i][j]=dp[i-1][j-1]\\n                #When the pattern has \"*\", this shows that we need to check the [j-2] for the character, which can be the string character or \\'.\\'. In this case we will check the [i-1][j], to check if the character except the current one is True.\\n                \\n                elif p[j-1]==\"*\":\\n                    dp[i][j]=dp[i][j-2]\\n                    if p[j-2]==\\'.\\' or p[j-2]==s[i-1]:\\n                        dp[i][j]=dp[i][j] or dp[i-1][j]\\n                    \\n            \\n        return dp[n_s][n_p]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503790,
                "title": "readable-and-clear-solution-solution-one-transform-to-js",
                "content": "```js\\n/**\\n * @param {string} s\\n * @param {string} p\\n * @return {boolean}\\n */\\nvar isMatch = function(s, p) {\\n    // recursion basic case\\n    if (!p || !p.length) return !Boolean(s.length);\\n    \\n    // first char match condition\\n    const first_match = s.length && (p[0] === s[0] || p[0] === \\'.\\');\\n\\t\\n    if (p.length > 1 && p[1] === \\'*\\') {\\n\\t\\t// If the second char is wildcard, then result to two cases:\\n\\t\\t\\n\\t\\t// 1.the first char doesn\\'t match, so the second wildcard can repeat the first char of p 0 times\\n\\t\\t// then continue to match the rest part of s\\n\\t\\tconst condition1 = isMatch(s, p.substring(2));\\n\\t\\t\\n\\t\\t// Example\\n\\t\\t// s: aab\\n\\t\\t// p: c*a*b*\\n\\t\\t\\n\\t\\t// Explaination: c* can repeat c 0 times, then continue to match s with the rest part of p\\n\\t\\t\\n\\t\\t// 2.The first char does matches, so the second wildcard can repeat the first char any times\\n\\t\\t// then continue to match the rest part of s\\n\\t\\tconst condition2 = first_match && isMatch(s.substring(1), p);\\n\\t\\t\\n\\t\\t// Example 1\\n\\t\\t// s: aa\\n\\t\\t// p: a*\\n\\t\\t\\n\\t\\t// Explaination: a* can repeat a two times then becomes to aa which matches aa\\n\\t\\t\\n\\t\\t// Example 2\\n\\t\\t// s: ab\\n\\t\\t// p: .*\\n\\t\\t\\n\\t\\t//Explaination: .* can repeat . two times then becomes to .. which matches ab\\n\\t\\t\\n\\t\\treturn condition1 || condition2;\\n    } else {\\n        // The normal case is to match the first char then recursively match the rest chars\\n        return first_match && isMatch(s.substring(1), p.substring(1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\n/**\\n * @param {string} s\\n * @param {string} p\\n * @return {boolean}\\n */\\nvar isMatch = function(s, p) {\\n    // recursion basic case\\n    if (!p || !p.length) return !Boolean(s.length);\\n    \\n    // first char match condition\\n    const first_match = s.length && (p[0] === s[0] || p[0] === \\'.\\');\\n\\t\\n    if (p.length > 1 && p[1] === \\'*\\') {\\n\\t\\t// If the second char is wildcard, then result to two cases:\\n\\t\\t\\n\\t\\t// 1.the first char doesn\\'t match, so the second wildcard can repeat the first char of p 0 times\\n\\t\\t// then continue to match the rest part of s\\n\\t\\tconst condition1 = isMatch(s, p.substring(2));\\n\\t\\t\\n\\t\\t// Example\\n\\t\\t// s: aab\\n\\t\\t// p: c*a*b*\\n\\t\\t\\n\\t\\t// Explaination: c* can repeat c 0 times, then continue to match s with the rest part of p\\n\\t\\t\\n\\t\\t// 2.The first char does matches, so the second wildcard can repeat the first char any times\\n\\t\\t// then continue to match the rest part of s\\n\\t\\tconst condition2 = first_match && isMatch(s.substring(1), p);\\n\\t\\t\\n\\t\\t// Example 1\\n\\t\\t// s: aa\\n\\t\\t// p: a*\\n\\t\\t\\n\\t\\t// Explaination: a* can repeat a two times then becomes to aa which matches aa\\n\\t\\t\\n\\t\\t// Example 2\\n\\t\\t// s: ab\\n\\t\\t// p: .*\\n\\t\\t\\n\\t\\t//Explaination: .* can repeat . two times then becomes to .. which matches ab\\n\\t\\t\\n\\t\\treturn condition1 || condition2;\\n    } else {\\n        // The normal case is to match the first char then recursively match the rest chars\\n        return first_match && isMatch(s.substring(1), p.substring(1));\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1222028,
                "title": "shortest-c-0ms-solution-with-explanation",
                "content": "**We divide the problem into two situations, one is a simple situation,the other is a complicated situation.**\\n\\n# Simple situation:\\nlet i be current index in string s\\nansd j be current index in string p\\n\\nif(s[i] == p[j] || p[j] == \\'.\\') then simply  return  dp[i+1][j+1];\\n\\n# Complicated situation(p[j] == \\'*\\'):\\n\\nif we dont consider star then  we can have  res1 = dp[i][j+2];\\n\\nif i < length(s) and s[i] == p[j], indicates that the * character can be used, \\nso simply  res2 = dp[i+1][j]; \\n\\nhere we  have two choices if we can use star or not \\nso our result here will be \\nres1 && res2\\n\\n\\n\\n# **IMPLEMENTATION**\\n*if you can not understand the progress , you can try to simulate matching the string abb with the string ab**\\n      \\n\\t\\n\\t  \\n```\\nclass Solution {\\npublic:\\n    bool solver(string &s,string &p,int a ,int b,vector<vector<int>> &dp)  {   \\n        if(dp[a][b]!=-1) return dp[a][b];\\n        if(a>=s.length() and b>=p.length())  return dp[a][b] = true;\\n        if(b>=p.length())  return dp[a][b] = false;\\n        bool match = ( a <s.length() and (s[a]==p[b] or p[b]==\\'.\\'));\\n        if( b<p.length() and p[b+1]==\\'*\\') return dp[a][b] = solver(s,p,a,b+2,dp) or ( match and solver(s,p,a+1,b,dp));\\n        if(match) return dp[a][b] = solver(s,p,a+1,b+1,dp);\\n        return dp[a][b] = false;\\n    }\\n    bool isMatch(string s, string p) {\\n    vector<vector<int>> dp( s.length()+1, vector<int>(p.length()+1,-1) );\\n    return solver(s,p,0,0,dp);\\n    }\\n};\\n```\\n\\n# Upvote If this solution is helpful for you",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solver(string &s,string &p,int a ,int b,vector<vector<int>> &dp)  {   \\n        if(dp[a][b]!=-1) return dp[a][b];\\n        if(a>=s.length() and b>=p.length())  return dp[a][b] = true;\\n        if(b>=p.length())  return dp[a][b] = false;\\n        bool match = ( a <s.length() and (s[a]==p[b] or p[b]==\\'.\\'));\\n        if( b<p.length() and p[b+1]==\\'*\\') return dp[a][b] = solver(s,p,a,b+2,dp) or ( match and solver(s,p,a+1,b,dp));\\n        if(match) return dp[a][b] = solver(s,p,a+1,b+1,dp);\\n        return dp[a][b] = false;\\n    }\\n    bool isMatch(string s, string p) {\\n    vector<vector<int>> dp( s.length()+1, vector<int>(p.length()+1,-1) );\\n    return solver(s,p,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746398,
                "title": "intuitive-recursive-solution-and-its-memoized-variant",
                "content": "Simple recursive solution :\\n```\\nclass Solution {\\npublic boolean isMatch(String s, String p) {\\n        if (p.length() == 0)\\n            return s.length() == 0;\\n        if (p.length() > 1 && p.charAt(1) == \\'*\\') {\\n            if(isMatch(s, p.substring(2))) //for handling when s = \"aab\" , p = \"c*a*b\" and output : true\\n                return true;\\n            if (s.length() > 0 && (s.charAt(0) == p.charAt(0) || p.charAt(0) == \\'.\\')) //for handling when s = \"ab\" , p = \".*\" and output : true\\n                return isMatch(s.substring(1),p);\\n        } else {\\n            if (s.length() > 0 && p.length() > 0 && (s.charAt(0) == p.charAt(0) || p.charAt(0) == \\'.\\')) //for handling when s = \"abXXX\" , p = \"abXXX\" and output : true\\n                return isMatch(s.substring(1), p.substring(1));\\n        }\\n        return false;\\n    }\\n}\\n\\n```\\n\\n\\nMemoization based solution :\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        return isMatch(s, p, new HashMap<>());\\n    }\\n    \\n    private boolean isMatch(String s, String p, Map<String, Boolean> dp) {\\n        String key = s + \"-\" + p;\\n        if (dp.containsKey(key))\\n            return dp.get(key);\\n        boolean ans = false;\\n        if (p.length() == 0)\\n            return s.length() == 0;\\n        if (p.length() > 1 && p.charAt(1) == \\'*\\') {\\n            ans = isMatch(s, p.substring(2), dp);\\n            if(ans)\\n                return true;\\n            if (s.length() > 0 && (s.charAt(0) == p.charAt(0) || p.charAt(0) == \\'.\\'))\\n                ans = isMatch(s.substring(1),p, dp);\\n        } else {\\n            if (s.length() > 0 && p.length() > 0 && (s.charAt(0) == p.charAt(0) || p.charAt(0) == \\'.\\'))\\n                ans = isMatch(s.substring(1), p.substring(1), dp);\\n        }\\n        \\n        dp.put(key, ans);\\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic boolean isMatch(String s, String p) {\\n        if (p.length() == 0)\\n            return s.length() == 0;\\n        if (p.length() > 1 && p.charAt(1) == \\'*\\') {\\n            if(isMatch(s, p.substring(2))) //for handling when s = \"aab\" , p = \"c*a*b\" and output : true\\n                return true;\\n            if (s.length() > 0 && (s.charAt(0) == p.charAt(0) || p.charAt(0) == \\'.\\')) //for handling when s = \"ab\" , p = \".*\" and output : true\\n                return isMatch(s.substring(1),p);\\n        } else {\\n            if (s.length() > 0 && p.length() > 0 && (s.charAt(0) == p.charAt(0) || p.charAt(0) == \\'.\\')) //for handling when s = \"abXXX\" , p = \"abXXX\" and output : true\\n                return isMatch(s.substring(1), p.substring(1));\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318006,
                "title": "if-you-don-t-want-dp-let-s-dfs-memoization",
                "content": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] visited = new boolean[s.length() + 1][p.length() + 1];\\n        boolean[][] memo = new boolean[s.length() + 1][p.length() + 1];\\n        return dfs(s, 0, p, 0, visited, memo);\\n    }\\n    \\n    private boolean dfs(String s, int sIndex, String p, int pIndex, boolean[][] visited, boolean[][] memo) {\\n        if (pIndex == p.length()) {\\n            return sIndex == s.length();\\n        }\\n        if (visited[sIndex][pIndex]) {\\n            return memo[sIndex][pIndex];\\n        }\\n        \\n        boolean result = false;\\n        boolean isFirstMatch = sIndex != s.length() \\n            && (p.charAt(pIndex) == s.charAt(sIndex) || p.charAt(pIndex) == \\'.\\');\\n        \\n        // directly check if pIndex + 1 is \\'*\\', and wrap x* as a whole\\n        if (pIndex <= p.length() - 2 && p.charAt(pIndex + 1) == \\'*\\') {\\n            result = dfs(s, sIndex, p, pIndex + 2, visited, memo) ||\\n                (isFirstMatch && dfs(s, sIndex + 1, p, pIndex, visited, memo));\\n        } else{\\n            result = isFirstMatch && dfs(s, sIndex + 1, p, pIndex + 1, visited, memo);\\n        }\\n        \\n        visited[sIndex][pIndex] = true;\\n        memo[sIndex][pIndex] = result;\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] visited = new boolean[s.length() + 1][p.length() + 1];\\n        boolean[][] memo = new boolean[s.length() + 1][p.length() + 1];\\n        return dfs(s, 0, p, 0, visited, memo);\\n    }\\n    \\n    private boolean dfs(String s, int sIndex, String p, int pIndex, boolean[][] visited, boolean[][] memo) {\\n        if (pIndex == p.length()) {\\n            return sIndex == s.length();\\n        }\\n        if (visited[sIndex][pIndex]) {\\n            return memo[sIndex][pIndex];\\n        }\\n        \\n        boolean result = false;\\n        boolean isFirstMatch = sIndex != s.length() \\n            && (p.charAt(pIndex) == s.charAt(sIndex) || p.charAt(pIndex) == \\'.\\');\\n        \\n        // directly check if pIndex + 1 is \\'*\\', and wrap x* as a whole\\n        if (pIndex <= p.length() - 2 && p.charAt(pIndex + 1) == \\'*\\') {\\n            result = dfs(s, sIndex, p, pIndex + 2, visited, memo) ||\\n                (isFirstMatch && dfs(s, sIndex + 1, p, pIndex, visited, memo));\\n        } else{\\n            result = isFirstMatch && dfs(s, sIndex + 1, p, pIndex + 1, visited, memo);\\n        }\\n        \\n        visited[sIndex][pIndex] = true;\\n        memo[sIndex][pIndex] = result;\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239391,
                "title": "python-solution",
                "content": "Dynamic programming. The idea is to use a `(m+1) * (n+1)` array `dp` to store the result of regular expression matching for prefix substrings of `s` and `p`. More specifically, `dp[i][j] = True` if `s[:i]` can be matched with `p[:j]`, and `dp[i][j] = False` otherwise.\\n\\nTime complexity: `O(mn)`, space complexity: `O(mn)`, where `n = len(s)`, `m = len(p)`. \\n\\n```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        n = len(s)\\n        m = len(p)\\n        dp = [[False]*(n+1) for _ in range(m+1)]\\n        dp[0][0] = True\\n        for i in range(m):\\n            for j in range(-1, n):\\n                if j == -1:\\n                    if p[i] == \"*\":\\n                        dp[i+1][j+1] = dp[i-1][j+1]\\n                    continue\\n                if p[i].isalpha():\\n                    if p[i] == s[j]:\\n                        dp[i+1][j+1] = dp[i][j]\\n                elif p[i] == \".\":\\n                    dp[i+1][j+1] = dp[i][j]\\n                else:\\n                    dp[i+1][j+1] = dp[i-1][j+1] or (dp[i+1][j] and (p[i-1] == s[j] or p[i-1] == \".\"))\\n        return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        n = len(s)\\n        m = len(p)\\n        dp = [[False]*(n+1) for _ in range(m+1)]\\n        dp[0][0] = True\\n        for i in range(m):\\n            for j in range(-1, n):\\n                if j == -1:\\n                    if p[i] == \"*\":\\n                        dp[i+1][j+1] = dp[i-1][j+1]\\n                    continue\\n                if p[i].isalpha():\\n                    if p[i] == s[j]:\\n                        dp[i+1][j+1] = dp[i][j]\\n                elif p[i] == \".\":\\n                    dp[i+1][j+1] = dp[i][j]\\n                else:\\n                    dp[i+1][j+1] = dp[i-1][j+1] or (dp[i+1][j] and (p[i-1] == s[j] or p[i-1] == \".\"))\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5759,
                "title": "very-beautiful-nfa-solution-using-javascript",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} p\\n * @return {boolean}\\n */\\nvar isMatch = function(s, p) {\\n    let states = new Set();\\n    addStat(states, 0, p);\\n    for (let c of s) {\\n        let next = new Set();\\n        for (let stat of states) {\\n            if (c === p[stat] || p[stat] === '.') {\\n                addStat(next, stat + 1, p);\\n            }\\n        }\\n        states = next;\\n    }\\n    return states.has(p.length);\\n};\\n\\nfunction addStat(states, stat, p) {\\n    if (p[stat] === '*') {\\n        states.add(stat - 1);\\n        addStat(states, stat + 1, p);\\n    } else {\\n        states.add(stat);\\n        if (p[stat + 1] === '*') {\\n            addStat(states, stat + 2, p);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} p\\n * @return {boolean}\\n */\\nvar isMatch = function(s, p) {\\n    let states = new Set();\\n    addStat(states, 0, p);\\n    for (let c of s) {\\n        let next = new Set();\\n        for (let stat of states) {\\n            if (c === p[stat] || p[stat] === '.') {\\n                addStat(next, stat + 1, p);\\n            }\\n        }\\n        states = next;\\n    }\\n    return states.has(p.length);\\n};\\n\\nfunction addStat(states, stat, p) {\\n    if (p[stat] === '*') {\\n        states.add(stat - 1);\\n        addStat(states, stat + 1, p);\\n    } else {\\n        states.add(stat);\\n        if (p[stat + 1] === '*') {\\n            addStat(states, stat + 2, p);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5995,
                "title": "just-another-python-solution-with-recursion",
                "content": "    class Solution:\\n        # @param {string} s\\n        # @param {string} p\\n        # @return {boolean}\\n        def isMatch(self, s, p):\\n            if not s and not p:\\n                return True\\n    \\n            if not p and s:\\n                return False\\n    \\n            if p[-1] == '*':\\n                rep = p[-2]\\n                if s and (s[-1] == rep or rep == '.'):\\n                    return self.isMatch(s[:-1], p) or self.isMatch(s, p[:-2]) \\n                else:\\n                    return self.isMatch(s, p[:-2])\\n            else:\\n                if s and (p[-1] == s[-1] or p[-1] == '.'):\\n                    return self.isMatch(s[:-1], p[:-1])\\n                else:\\n                    return False\\n\\n\\nMight be a little easier to read. 181 ms cost.",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "class Solution:\\n        # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 2712241,
                "title": "c-dp-faster-easy-to-understand",
                "content": "* ***Using Bottom Up DP***\\n\\n* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(N * M)***\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string str, string pat) {\\n\\n        int n = str.size();\\n        \\n        int m = pat.size();\\n\\n        // \\'.\\' can be any character\\n        \\n        // \"s*\" can be replace with \"\", \"s\", \"ss\", \"sss\", \"ssss\" and so on .....\\n        \\n        // above possibility can be replaced with \"\", \"ss*\"\\n\\n        // str in on i direction and pat is on j direction\\n\\n        // for the 0th row if we encounter \\'*\\' then we look for dp[0][j - 2]\\n\\n        vector<vector<bool>> dp(n + 1, vector<bool> (m + 1, false));\\n\\n        for(int i = 0; i <= n; i++)\\n        {\\n            for(int j = 0; j <= m ; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                {\\n                    dp[i][j] = true;\\n                }\\n                else if(j == 0)\\n                {\\n                    dp[i][j] = false;\\n                }\\n                else if(i == 0)\\n                {\\n                    if(pat[j - 1] == \\'*\\')\\n                    {\\n                        dp[i][j] = dp[i][j - 2];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = false;\\n                    }\\n                }\\n                else\\n                {\\n                    if(str[i - 1] == pat[j - 1] || pat[j - 1] == \\'.\\')\\n                    {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    else if(pat[j - 1] == \\'*\\')\\n                    {\\n                        // eg. replace \"mis*\" with \"mi\"\\n\\n                        dp[i][j] = dp[i][j - 2];\\n\\n                        // eg. replace \"mis*\" with \"miss*\"\\n\\n                        if(dp[i][j] == false && (str[i - 1] == pat[j - 2] || pat[j - 2] == \\'.\\'))\\n                        {\\n                            dp[i][j] = dp[i - 1][j];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string str, string pat) {\\n\\n        int n = str.size();\\n        \\n        int m = pat.size();\\n\\n        // \\'.\\' can be any character\\n        \\n        // \"s*\" can be replace with \"\", \"s\", \"ss\", \"sss\", \"ssss\" and so on .....\\n        \\n        // above possibility can be replaced with \"\", \"ss*\"\\n\\n        // str in on i direction and pat is on j direction\\n\\n        // for the 0th row if we encounter \\'*\\' then we look for dp[0][j - 2]\\n\\n        vector<vector<bool>> dp(n + 1, vector<bool> (m + 1, false));\\n\\n        for(int i = 0; i <= n; i++)\\n        {\\n            for(int j = 0; j <= m ; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                {\\n                    dp[i][j] = true;\\n                }\\n                else if(j == 0)\\n                {\\n                    dp[i][j] = false;\\n                }\\n                else if(i == 0)\\n                {\\n                    if(pat[j - 1] == \\'*\\')\\n                    {\\n                        dp[i][j] = dp[i][j - 2];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = false;\\n                    }\\n                }\\n                else\\n                {\\n                    if(str[i - 1] == pat[j - 1] || pat[j - 1] == \\'.\\')\\n                    {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    else if(pat[j - 1] == \\'*\\')\\n                    {\\n                        // eg. replace \"mis*\" with \"mi\"\\n\\n                        dp[i][j] = dp[i][j - 2];\\n\\n                        // eg. replace \"mis*\" with \"miss*\"\\n\\n                        if(dp[i][j] == false && (str[i - 1] == pat[j - 2] || pat[j - 2] == \\'.\\'))\\n                        {\\n                            dp[i][j] = dp[i - 1][j];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519358,
                "title": "java-solution-in-one-line-of-code",
                "content": "public boolean isMatch(String s, String p) {\\n        return s.matches(p);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public boolean isMatch(String s, String p) {\\n        return s.matches(p);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2235646,
                "title": "very-short-intuitive-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[25][35];\\n    bool check(string &s, string &p, int i, int j, int &m, int &n) {\\n        if(i == m && j == n) return true;\\n        if(j == n) return false;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        bool valid = (i < m) && (s[i] == p[j] || p[j] == \\'.\\');\\n        if(j+1 < n && p[j+1] == \\'*\\') {\\n            return dp[i][j] = check(s, p, i, j+2, m, n) || valid && check(s, p, i+1, j, m, n);\\n        }\\n        if(valid) {\\n            return dp[i][j] = check(s, p, i+1, j+1, m, n);\\n        }\\n        return dp[i][j] = false;\\n    }\\n    bool isMatch(string s, string p) {\\n        int m = s.length(), n = p.length();\\n        memset(dp, -1, sizeof(dp));\\n        return check(s, p, 0, 0, m, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[25][35];\\n    bool check(string &s, string &p, int i, int j, int &m, int &n) {\\n        if(i == m && j == n) return true;\\n        if(j == n) return false;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        bool valid = (i < m) && (s[i] == p[j] || p[j] == \\'.\\');\\n        if(j+1 < n && p[j+1] == \\'*\\') {\\n            return dp[i][j] = check(s, p, i, j+2, m, n) || valid && check(s, p, i+1, j, m, n);\\n        }\\n        if(valid) {\\n            return dp[i][j] = check(s, p, i+1, j+1, m, n);\\n        }\\n        return dp[i][j] = false;\\n    }\\n    bool isMatch(string s, string p) {\\n        int m = s.length(), n = p.length();\\n        memset(dp, -1, sizeof(dp));\\n        return check(s, p, 0, 0, m, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801863,
                "title": "java-recursive-to-top-down-memoization",
                "content": "```\\n/*\\n    \\n    main idea:\\n    \\n        using two pointers i, j go through each character of s and p\\n        \\n        for wildcard * the two options are not use it or use it one or more times\\n        \\n        s=aa  p=a*                  a*\\n                                /        \\\\\\n                             a(use)   \"\"(not use)\\n                            /     \\\\\\n                        aa(use)    a(not use)\\n                        \\n        \\n        \\n        if we decide not to use it, \\n            \\n            we need to move j fwd twice (so that we skip *)\\n            i remains the same\\n\\n        each time we use it,\\n            move i fwd (meaning we matched one char of s)\\n            j remains the same\\n    \\n    \\n    recursive approach\\n    \\n        if i and j reach the end of s and s and p, means s matches the pattern\\n    \\n        if only j reaches the end, means s doesn\\'t match the pattern\\n        \\n        if chars of s and p at index i and j are equal or if char at p is . we can move i and j fwd\\n        \\n        if char after p at j + 1 is *\\n            \\n            recurse without current char\\n            recurse using current char       << check if chars at i, j are equal\\n        \\n        otherwise, we can recurse moving both i and j fwd\\n        \\n    --\\n    \\n    improve time complexity using DP Top/Down Memoization\\n    \\n    dp cache is a bidimensional array of size i + 1, j + 1\\n    \\n    if cache has the answer for a given i, j, return from there, otherwise, compute and update cache\\n    */\\n    public boolean isMatch(String s, String p) {\\n        return isMatch(s, p, 0, 0, new Boolean[s.length() + 1][p.length() + 1]);\\n    }\\n    \\n    private boolean isMatch(String s, String p, int i, int j, Boolean[][] dp){\\n        // if both i and j reach the end\\n        if(i >= s.length() && j >= p.length()){\\n            return true;\\n        }\\n        \\n        // if only j reaches the end, means s doesn\\'t match the pattern\\n        if(j >= p.length()){\\n            return false;\\n        }\\n        \\n        if(dp[i][j] != null){\\n            return dp[i][j];\\n        }\\n        \\n        // make sure that i is still in bounds\\n        // also make sure that the chars at i and j are equal\\n        // if both conditions are met, we can keep going\\n        boolean matchCondition = i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'.\\');\\n        \\n        if(j + 1 < p.length() && p.charAt(j + 1) == \\'*\\'){\\n            dp[i][j] = isMatch(s, p, i, j + 2, dp) ||                        // not using it\\n                       matchCondition && isMatch(s, p, i + 1, j, dp);        // using it - check if current chars match before recursing\\n        } else {\\n            if(matchCondition){\\n                dp[i][j] = isMatch(s, p, i + 1, j + 1, dp);                  // if both chars match, we can keep going\\n            } else {\\n                dp[i][j] = false;\\n            }\\n        }\\n        \\n        return dp[i][j];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n/*\\n    \\n    main idea:\\n    \\n        using two pointers i, j go through each character of s and p\\n        \\n        for wildcard * the two options are not use it or use it one or more times\\n        \\n        s=aa  p=a*                  a*\\n                                /        \\\\\\n                             a(use)   \"\"(not use)\\n                            /     \\\\\\n                        aa(use)    a(not use)\\n                        \\n        \\n        \\n        if we decide not to use it, \\n            \\n            we need to move j fwd twice (so that we skip *)\\n            i remains the same\\n\\n        each time we use it,\\n            move i fwd (meaning we matched one char of s)\\n            j remains the same\\n    \\n    \\n    recursive approach\\n    \\n        if i and j reach the end of s and s and p, means s matches the pattern\\n    \\n        if only j reaches the end, means s doesn\\'t match the pattern\\n        \\n        if chars of s and p at index i and j are equal or if char at p is . we can move i and j fwd\\n        \\n        if char after p at j + 1 is *\\n            \\n            recurse without current char\\n            recurse using current char       << check if chars at i, j are equal\\n        \\n        otherwise, we can recurse moving both i and j fwd\\n        \\n    --\\n    \\n    improve time complexity using DP Top/Down Memoization\\n    \\n    dp cache is a bidimensional array of size i + 1, j + 1\\n    \\n    if cache has the answer for a given i, j, return from there, otherwise, compute and update cache\\n    */\\n    public boolean isMatch(String s, String p) {\\n        return isMatch(s, p, 0, 0, new Boolean[s.length() + 1][p.length() + 1]);\\n    }\\n    \\n    private boolean isMatch(String s, String p, int i, int j, Boolean[][] dp){\\n        // if both i and j reach the end\\n        if(i >= s.length() && j >= p.length()){\\n            return true;\\n        }\\n        \\n        // if only j reaches the end, means s doesn\\'t match the pattern\\n        if(j >= p.length()){\\n            return false;\\n        }\\n        \\n        if(dp[i][j] != null){\\n            return dp[i][j];\\n        }\\n        \\n        // make sure that i is still in bounds\\n        // also make sure that the chars at i and j are equal\\n        // if both conditions are met, we can keep going\\n        boolean matchCondition = i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'.\\');\\n        \\n        if(j + 1 < p.length() && p.charAt(j + 1) == \\'*\\'){\\n            dp[i][j] = isMatch(s, p, i, j + 2, dp) ||                        // not using it\\n                       matchCondition && isMatch(s, p, i + 1, j, dp);        // using it - check if current chars match before recursing\\n        } else {\\n            if(matchCondition){\\n                dp[i][j] = isMatch(s, p, i + 1, j + 1, dp);                  // if both chars match, we can keep going\\n            } else {\\n                dp[i][j] = false;\\n            }\\n        }\\n        \\n        return dp[i][j];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1706373,
                "title": "sinkinben-c-dp-dfa-stl-detailed-explanation",
                "content": "## Regex Matching\\n\\nLeetcode: [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/).\\n\\nThe description of this problem is clear:\\n\\n- Given an input string `s` and a pattern `p`, implement regular expression matching with support for `\\'.\\'` and `\\'*\\'`.\\n  - `\\'.\\'` matches any single character.\\n  - `\\'*\\'` matches zero or more of the preceding element.\\n  - It is guaranteed for each appearance of the character `\\'*\\'`, there will be a previous valid character to match.\\n- The matching should cover the **entire** input string (not partial).\\n\\n\\n\\n## Dynamic Programming\\n\\nA popular solution is using dynamic programming. \\n\\nLet `dp[i, j]` be true if `s[1 ... i]` matches `p[1 ... j]`. And the state equations will be:\\n\\n- `dp[i, j] = dp[i-1, j-1]` if `p[j] == \\'.\\' || p[j] == s[i] `\\n- `dp[i, j] = dp[i, j-2]` if `p[j] == \\'*\\'`, which means that we skip `\"x*\"` and matching nothing (or match `x` for zero times).\\n- `dp[i, j] = dp[i-1, j] && (s[i] == p[j-1] || p[j-1] == \\'.\\')`, if `p[j] == \\'*\\'`, which means that `\"x*\"` repeats >=1 times, and `x` can be character or a dot `\\'.\\'`.\\n\\nPlease note that the index of `s` and `p` in the program start with `0`, which is a little different from the state equations above.\\n\\n```cpp\\nclass Solution \\n{\\npublic:\\n    bool isMatch(string s, string p) \\n    {\\n        int slen = s.length(), plen = p.length();\\n        vector<vector<bool>> dp(slen + 1, vector<bool>(plen + 1, false));\\n        dp[0][0] = true;\\n        // Note that s = \"\", can match p = \"a*b*c*\", hence `i` should be start with 0\\n        for (int i = 0; i <= slen; ++i)\\n        {\\n            for (int j = 1; j <= plen; ++j)\\n            {\\n                /* the index of \\'*\\' in `p`, must be >= 1, otherwise `p` is invalid,\\n                 * i.e. (j - 1 >= 1) ==> (j >= 2)\\n                 */\\n                if (p[j - 1] == \\'*\\')\\n                {\\n                    dp[i][j] = dp[i][j -  2] || \\n                               (i > 0 && dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\'));\\n                }\\n                else if (i > 0 && (p[j - 1] == \\'.\\' || s[i - 1] == p[j - 1]))\\n                {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n                \\n            }\\n        }\\n        return dp[slen][plen];\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n## DFA\\n\\nHere I want to show how to solve this problem by **deterministic finite automaton (DFA)**.\\n\\nPlease note that you should know the concept of DFA before you read this article.\\n\\nFor a pattern `p = \"a.b*c\"`, we can construct such a DFA:\\n\\n<img src=\"https://github.com/Sin-Kinben/PicGo/raw/master/img/20220121134600.png\" style=\"background: #fff\"/>\\n\\nThe `\\'$\\'` sign means that, we do not need any character to reach next state, since `\\'*\\'` matches **zero** or more of the preceding element. \\n\\nDFA can be represented by a graph in the program.\\n\\n- `state` points to the last valid state we can reach.\\n-  `state = 0` denote the invalid state, since `0` is the default value of `unordered_map`. Of course, we can use `-1`.\\n\\n```cpp\\nclass Solution \\n{\\npublic:\\n    unordered_map<int, unordered_map<char, int>> automaton;\\n    int state = 1;\\n    bool isMatch(string s, string p)\\n    {\\n        int plen = p.length();\\n        for (int i = 0; i < plen; ++i)\\n        {\\n            char x = p[i];\\n            if (\\'a\\' <= x && x <= \\'z\\' || x == \\'.\\')\\n                automaton[state][x] = state + 1, state += 1;\\n            else if (x == \\'*\\' && i > 0)\\n            {\\n                automaton[state - 1][p[i - 1]] = state - 1; // match >= 1 p[i - 1]\\n                automaton[state - 1][\\'$\\'] = state;          // match zero p[i - 1]\\n            }\\n        }\\n        return match(s, 0, 1);\\n    }\\n    \\n    /* idx - we are matching s[idx]\\n     * cur - current state in automaton\\n     */\\n    bool match(string &s, int idx, int cur)\\n    {\\n        int n = s.length();\\n        \\n        if (cur == 0) return false;\\n        if (idx >= n && cur == state) return true;\\n        \\n        if (idx < n)\\n        {\\n            /* Each node in automaton, has no more than 3 edges,\\n             * \\'$\\' means matching no character, hence still use `idx` in next matching.\\n             * For example, p = \"a.b*c\", s = \"aac\", we should output true,\\n             * match(s, idx, s3) means that, we skip matching \"b*\" in automaton (matched zero \\'b\\').\\n             */\\n            int s1 = automaton[cur][s[idx]];\\n            int s2 = automaton[cur][\\'.\\'];\\n            int s3 = automaton[cur][\\'$\\'];\\n            return match(s, idx + 1, s1) || match(s, idx + 1, s2) || match(s, idx, s3);\\n        }\\n        else if (idx == n) \\n        {\\n            /* May be the last edge of automaton is `state[n-1] -- $ --> state[n]`\\n             * e.g. s = \"aa\", p = \"a*\"\\n             */\\n            return match(s, idx, automaton[cur][\\'$\\']);\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\n\\nAt last, we can also pass this problem by STL library :-D.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return regex_match(s, regex(p));\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution \\n{\\npublic:\\n    bool isMatch(string s, string p) \\n    {\\n        int slen = s.length(), plen = p.length();\\n        vector<vector<bool>> dp(slen + 1, vector<bool>(plen + 1, false));\\n        dp[0][0] = true;\\n        // Note that s = \"\", can match p = \"a*b*c*\", hence `i` should be start with 0\\n        for (int i = 0; i <= slen; ++i)\\n        {\\n            for (int j = 1; j <= plen; ++j)\\n            {\\n                /* the index of \\'*\\' in `p`, must be >= 1, otherwise `p` is invalid,\\n                 * i.e. (j - 1 >= 1) ==> (j >= 2)\\n                 */\\n                if (p[j - 1] == \\'*\\')\\n                {\\n                    dp[i][j] = dp[i][j -  2] || \\n                               (i > 0 && dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == \\'.\\'));\\n                }\\n                else if (i > 0 && (p[j - 1] == \\'.\\' || s[i - 1] == p[j - 1]))\\n                {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n                \\n            }\\n        }\\n        return dp[slen][plen];\\n    }\\n};\\n```\n```cpp\\nclass Solution \\n{\\npublic:\\n    unordered_map<int, unordered_map<char, int>> automaton;\\n    int state = 1;\\n    bool isMatch(string s, string p)\\n    {\\n        int plen = p.length();\\n        for (int i = 0; i < plen; ++i)\\n        {\\n            char x = p[i];\\n            if (\\'a\\' <= x && x <= \\'z\\' || x == \\'.\\')\\n                automaton[state][x] = state + 1, state += 1;\\n            else if (x == \\'*\\' && i > 0)\\n            {\\n                automaton[state - 1][p[i - 1]] = state - 1; // match >= 1 p[i - 1]\\n                automaton[state - 1][\\'$\\'] = state;          // match zero p[i - 1]\\n            }\\n        }\\n        return match(s, 0, 1);\\n    }\\n    \\n    /* idx - we are matching s[idx]\\n     * cur - current state in automaton\\n     */\\n    bool match(string &s, int idx, int cur)\\n    {\\n        int n = s.length();\\n        \\n        if (cur == 0) return false;\\n        if (idx >= n && cur == state) return true;\\n        \\n        if (idx < n)\\n        {\\n            /* Each node in automaton, has no more than 3 edges,\\n             * \\'$\\' means matching no character, hence still use `idx` in next matching.\\n             * For example, p = \"a.b*c\", s = \"aac\", we should output true,\\n             * match(s, idx, s3) means that, we skip matching \"b*\" in automaton (matched zero \\'b\\').\\n             */\\n            int s1 = automaton[cur][s[idx]];\\n            int s2 = automaton[cur][\\'.\\'];\\n            int s3 = automaton[cur][\\'$\\'];\\n            return match(s, idx + 1, s1) || match(s, idx + 1, s2) || match(s, idx, s3);\\n        }\\n        else if (idx == n) \\n        {\\n            /* May be the last edge of automaton is `state[n-1] -- $ --> state[n]`\\n             * e.g. s = \"aa\", p = \"a*\"\\n             */\\n            return match(s, idx, automaton[cur][\\'$\\']);\\n        }\\n        return false;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return regex_match(s, regex(p));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686612,
                "title": "c-one-line-solution",
                "content": "```\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsMatch(string s, string p) {\\n        return Regex.IsMatch(s, \"^\"+p+\"$\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsMatch(string s, string p) {\\n        return Regex.IsMatch(s, \"^\"+p+\"$\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570688,
                "title": "c-solution-with-different-approaches",
                "content": "**1. Easiest:**\\nEasiest solution I could think of is using the regex_match function that matches a string, with a regex pattern\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return regex_match(s, regex(p));\\n    }\\n};\\n```\\n**2. Recursion:**\\nWe check if the pattern is empty, if it is, just return is the string in itself is empty. Now check if the first char of both string and pattern match. \\nIf pattern still has length >=2 and p[1]==\\' * \\', then there can be ZERO or more characters like p[0]. hence, either we match the s[0], or dont. Think same the first if condition returns->  (isMatch(s, p.substr(2))||(fchar && isMatch(s.substr(1), p))) -> the condition after OR is that now that s[0] is matched, match string from s[1] and further with same pattern (remember pattern can remain same as we have covered the case for zero matchs.\\nNow in the else condition, if the p.length()<2 or p[1]!=\\' * \\', just check if the first chars of s and p match and proceed ahead -> just like you would done in trivial string matching function.\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if(p.empty())\\n            return s.empty();\\n        bool fchar = (!s.empty() && ((p[0]==s[0]) || (p[0]==\\'.\\')));\\n        if(p.length()>=2 && p[1]==\\'*\\')\\n            return (isMatch(s, p.substr(2))||(fchar && isMatch(s.substr(1), p)));\\n        //zero or more char matches, therefore 1\\n        //and first char matches, so send from second into matching same pattern\\n        else\\n            return fchar && isMatch(s.substr(1), p.substr(1));\\n            //simplest case, matching char one by one\\n    }\\n};\\n```\\n\\n**3. DP:**\\nUse same approach but with memoization, so create a 2D vector that states if I am able to match string s until char \\'i\\' with pattern p until char \\'j\\'.\\n```\\nclass Solution {\\n    bool dp(int i, int j, string s, string p, vector<vector<int>> &memo)\\n    {\\n        if(memo[i][j]!=-1)\\n            return memo[i][j] == 1;\\n        bool ans;\\n        if(j==p.length())\\n            ans = i == s.length();\\n        else\\n        {\\n            bool fchar =  (i<s.length() && (p[j]==s[i] || p[j]==\\'.\\'));\\n            if(j+1<p.length() && p[j+1]==\\'*\\')\\n                ans = (dp(i, j+2, s, p, memo)||(fchar && dp(i+1, j, s, p, memo)));\\n            else\\n                ans = fchar && dp(i+1, j+1, s, p, memo);\\n        }\\n        memo[i][j] = ans?1:0;\\n        return ans;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> memo(s.length()+1, vector<int>(p.length()+1, -1));\\n        return dp(0, 0, s, p, memo);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return regex_match(s, regex(p));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if(p.empty())\\n            return s.empty();\\n        bool fchar = (!s.empty() && ((p[0]==s[0]) || (p[0]==\\'.\\')));\\n        if(p.length()>=2 && p[1]==\\'*\\')\\n            return (isMatch(s, p.substr(2))||(fchar && isMatch(s.substr(1), p)));\\n        //zero or more char matches, therefore 1\\n        //and first char matches, so send from second into matching same pattern\\n        else\\n            return fchar && isMatch(s.substr(1), p.substr(1));\\n            //simplest case, matching char one by one\\n    }\\n};\\n```\n```\\nclass Solution {\\n    bool dp(int i, int j, string s, string p, vector<vector<int>> &memo)\\n    {\\n        if(memo[i][j]!=-1)\\n            return memo[i][j] == 1;\\n        bool ans;\\n        if(j==p.length())\\n            ans = i == s.length();\\n        else\\n        {\\n            bool fchar =  (i<s.length() && (p[j]==s[i] || p[j]==\\'.\\'));\\n            if(j+1<p.length() && p[j+1]==\\'*\\')\\n                ans = (dp(i, j+2, s, p, memo)||(fchar && dp(i+1, j, s, p, memo)));\\n            else\\n                ans = fchar && dp(i+1, j+1, s, p, memo);\\n        }\\n        memo[i][j] = ans?1:0;\\n        return ans;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> memo(s.length()+1, vector<int>(p.length()+1, -1));\\n        return dp(0, 0, s, p, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562368,
                "title": "java-fastest-solution-beginner-friendly-1-ms-100-faster-memoization-dp",
                "content": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        Boolean[][] memo = new Boolean[s.length()+1][p.length()+1];\\n        return recursion(0,s,0,p,memo);\\n    }\\n    boolean recursion(int si,String s,int pi,String p,Boolean[][] memo)\\n    {\\n        if(pi == p.length())\\n            return si == s.length();\\n        \\n        if(memo[si][pi] != null)\\n            return memo[si][pi];\\n        \\n        boolean match = si < s.length() && (s.charAt(si) == p.charAt(pi) || p.charAt(pi) == \\'.\\');\\n            \\n        if(pi+1 < p.length() && p.charAt(pi+1) == \\'*\\')\\n        {\\n            memo[si][pi] = (match && recursion(si+1,s,pi,p,memo)) || (recursion(si,s,pi+2,p,memo));\\n        }\\n        else    memo[si][pi] = match && recursion(si+1,s,pi+1,p,memo);\\n            \\n        return memo[si][pi];\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        Boolean[][] memo = new Boolean[s.length()+1][p.length()+1];\\n        return recursion(0,s,0,p,memo);\\n    }\\n    boolean recursion(int si,String s,int pi,String p,Boolean[][] memo)\\n    {\\n        if(pi == p.length())\\n            return si == s.length();\\n        \\n        if(memo[si][pi] != null)\\n            return memo[si][pi];\\n        \\n        boolean match = si < s.length() && (s.charAt(si) == p.charAt(pi) || p.charAt(pi) == \\'.\\');\\n            \\n        if(pi+1 < p.length() && p.charAt(pi+1) == \\'*\\')\\n        {\\n            memo[si][pi] = (match && recursion(si+1,s,pi,p,memo)) || (recursion(si,s,pi+2,p,memo));\\n        }\\n        else    memo[si][pi] = match && recursion(si+1,s,pi+1,p,memo);\\n            \\n        return memo[si][pi];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375313,
                "title": "recursive-java-solution-explain-with-simple-diagram",
                "content": "Problem Description:\\nGiven an input string s and a pattern p, implement regular expression matching with support for \\'.\\' and \\'*\\' where:\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\nAccording to the second description [\\'*\\' Matches zero or more of the preceding element.], \\nwe must process two characher in pattern p when the following character conatains \\'*\\'.\\n\\nThat\\'s separate the problem into 4 cases using pattern \\'p\\':\\n![image](https://assets.leetcode.com/users/images/3d6fe330-4fce-4351-a23a-ec62b3ad48fe_1627782638.5297766.png)\\n\\n---\\n\\nCase1: This case took me lots time to understand the testcase....\\n![image](https://assets.leetcode.com/users/images/dec5eaf3-eed2-408d-9f2e-999bda9a3c80_1627782757.7386117.png)\\nEnter condition\\n**If p.length()>=2 && p.charAt(0)==\\u2018.\\u2019 && p.charAt(1)==\\u2018*\\u2019**\\nTestcase:\\n1. s=\\u2018\\u2019, p=.*, true\\n1. s=ab, p=.*, true\\n1. s=abc, p=.*, true\\n1. s=abcd, p=.*e, false (s is not endswith \\u2018e\\u2019)\\n\\nTestcase Conclusion:\\n**If p=\\u2018.*\\u2019 , no matter s is, is all true**\\n\\n---\\nCase2:\\n![image](https://assets.leetcode.com/users/images/aa1b88db-4c55-4d11-877f-dbd7ef1940d6_1627783106.4455247.png)\\nEnter condition\\n**If p.length()>=2 && p.charAt(0)!=\\u2018.\\u2019 && p.charAt(1)==\\u2018*\\u2019**\\nTestcase:\\n1. s=\\u2018\\u2019, p=a*, true\\n1. s=a, p=a*, true\\n1. s=aa, p=a*, true\\n1. s=ab, p=a*, false (p is not endswith \\u2018e\\u2019)\\n\\nTestcase Conclusion:\\n**a\\\\* means empty string or sequential a (\\u2018\\u2019 or aaaaaa)**\\n\\n---\\n\\nCase3:\\n![image](https://assets.leetcode.com/users/images/30385096-f762-4f08-b068-e74c0f16ad95_1627783131.1002207.png)\\nEnter condition\\n**If p.length()>=2 && p.charAt(1)!=\\u2018*\\u2019**\\nConclusion\\n**Just compare two char is equal or not\\nIf p[0]==\\u2018.\\u2019 , then is always true. (\\u2018.\\u2019 can be any char)**\\n\\n\\n---\\n\\nCase4:\\n![image](https://assets.leetcode.com/users/images/e066e3a0-eb4a-4f60-8ff6-8b29810c7bbf_1627783622.9966438.png)\\nEnter condition\\n**If p.length()<2**\\nConclusion\\n**p.length() is 1 so\\u2026 , if s.length()!=1, the result is false\\nIf p[0]==\\u2018.\\u2019 or p[0]==s[0], the result is true\\nelse return false**\\n\\n---\\n\\nAfter understanding 4 cases below, we can implemtent the first version of coding (Not the best solution, but it works):\\n**Hint: if p[1]==\\'*\\', we process two chars\\nHint: It\\'s important to fully understand the String.substring(int) function**\\n\\nAfter we complete the first vesrion of codeing, we can add memo(like hashmap or int[][]) to increase our efficiency.\\nOr we can apply those concepts and implement the dynamic programming.\\n\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int slen = s.length();\\n        int plen = p.length();\\n        \\n        if(slen==0 && plen==0)\\n            return true;\\n        \\n        if(plen>=2){\\n            if(p.charAt(1)==\\'*\\'){\\n                if(p.charAt(0)==\\'.\\'){\\n                    //Case1 for p= .*\\n                    for(int i=0;i<=slen;i++){\\n                        if(isMatch(s.substring(i),p.substring(2))){\\n                            return true;\\n                        }\\n                    }\\n                    return false;\\n                }else{\\n                    //Case2 for p= a*\\n                    for(int i=0;i<=slen;i++){\\n                        if(isMatch(s.substring(i),p.substring(2))){\\n                            return true;\\n                        }\\n                        if(i<slen && s.charAt(i)!=p.charAt(0)){\\n                            //if next char is not equal\\n                            //ab vs a*, we stop the loop when (ab) b!=a (a*)\\n                            break;\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }else{\\n                //p do not startwith .* or a* or * (Those cases will be processed in case1 and case2)\\n                //The possibility of p is .a or a or . or a.\\n                //if slen is 0, there is no possibility of matching\\n                if(slen==0)\\n                    return false;\\n                //Case3 for p= aa .a a.\\n                if(p.charAt(0)==\\'.\\' || s.charAt(0)==p.charAt(0)){\\n                    return isMatch(s.substring(1),p.substring(1));\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }else{\\n            if(slen!=plen)\\n                return false;\\n            //Case4 for p= . or a\\n            if(p.charAt(0)==\\'.\\' || s.charAt(0)==p.charAt(0))\\n                return true;\\n            return false;\\n        }\\n    }\\n}\\n```\\n\\nThank you for time, hope the description may help others to understand the problem.\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int slen = s.length();\\n        int plen = p.length();\\n        \\n        if(slen==0 && plen==0)\\n            return true;\\n        \\n        if(plen>=2){\\n            if(p.charAt(1)==\\'*\\'){\\n                if(p.charAt(0)==\\'.\\'){\\n                    //Case1 for p= .*\\n                    for(int i=0;i<=slen;i++){\\n                        if(isMatch(s.substring(i),p.substring(2))){\\n                            return true;\\n                        }\\n                    }\\n                    return false;\\n                }else{\\n                    //Case2 for p= a*\\n                    for(int i=0;i<=slen;i++){\\n                        if(isMatch(s.substring(i),p.substring(2))){\\n                            return true;\\n                        }\\n                        if(i<slen && s.charAt(i)!=p.charAt(0)){\\n                            //if next char is not equal\\n                            //ab vs a*, we stop the loop when (ab) b!=a (a*)\\n                            break;\\n                        }\\n                    }\\n                    return false;\\n                }\\n            }else{\\n                //p do not startwith .* or a* or * (Those cases will be processed in case1 and case2)\\n                //The possibility of p is .a or a or . or a.\\n                //if slen is 0, there is no possibility of matching\\n                if(slen==0)\\n                    return false;\\n                //Case3 for p= aa .a a.\\n                if(p.charAt(0)==\\'.\\' || s.charAt(0)==p.charAt(0)){\\n                    return isMatch(s.substring(1),p.substring(1));\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }else{\\n            if(slen!=plen)\\n                return false;\\n            //Case4 for p= . or a\\n            if(p.charAt(0)==\\'.\\' || s.charAt(0)==p.charAt(0))\\n                return true;\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247973,
                "title": "python-dp-bottom-up-48-ms",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m=len(s)\\n        n=len(p)\\n        dp=[[None]*(m+1) for _ in range(n+1)]\\n        for i in range(n+1):\\n            for j in range(m+1):\\n                if (i==0 and j==0):\\n                    dp[i][j]=True\\n                elif i==0:\\n                    dp[i][j]=False\\n                elif j==0:\\n                    if p[i-1]==\\'*\\':\\n                        dp[i][j]=dp[i-2][j]\\n                    else:\\n                        dp[i][j]=False\\n                else:\\n                    if p[i-1]==\\'*\\':\\n                        dp[i][j]=dp[i-2][j]\\n                        if (p[i-2]==s[j-1] or p[i-2]==\\'.\\'):\\n                            dp[i][j]=(dp[i][j-1] or dp[i][j])\\n                    elif (p[i-1]==s[j-1] or p[i-1]==\\'.\\'):\\n                            dp[i][j]=dp[i-1][j-1]\\n                    else:\\n                        dp[i][j]=False\\n        return dp[n][m]                \\n                            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m=len(s)\\n        n=len(p)\\n        dp=[[None]*(m+1) for _ in range(n+1)]\\n        for i in range(n+1):\\n            for j in range(m+1):\\n                if (i==0 and j==0):\\n                    dp[i][j]=True\\n                elif i==0:\\n                    dp[i][j]=False\\n                elif j==0:\\n                    if p[i-1]==\\'*\\':\\n                        dp[i][j]=dp[i-2][j]\\n                    else:\\n                        dp[i][j]=False\\n                else:\\n                    if p[i-1]==\\'*\\':\\n                        dp[i][j]=dp[i-2][j]\\n                        if (p[i-2]==s[j-1] or p[i-2]==\\'.\\'):\\n                            dp[i][j]=(dp[i][j-1] or dp[i][j])\\n                    elif (p[i-1]==s[j-1] or p[i-1]==\\'.\\'):\\n                            dp[i][j]=dp[i-1][j-1]\\n                    else:\\n                        dp[i][j]=False\\n        return dp[n][m]                \\n                            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 618936,
                "title": "c-faster-than-98-65-less-than-25-00-mem-o-s-p",
                "content": "Runtime: 68 ms\\nMemory Usage: 24.4 MB\\n\\nO(S * P) where S is s.Length and P is p.Length\\n\\n```\\n    public bool IsMatch(string s, string p) {\\n        bool[,] dp = new bool[p.Length+1, s.Length+1];\\n        dp[0,0] = true;\\n        \\n        for(int i=0, x=1; i < p.Length; i++, x++)\\n        {\\n            if (p[i] == \\'*\\') { dp[x,0] = dp[x-2, 0]; }\\n            \\n            for(int j=0, y=1; j < s.Length; j++, y++)\\n            {\\n                if (p[i] == \\'*\\')\\n                {\\n                    dp[x,y] = dp[x-1,y] || dp[x-2, y] || (dp[x, y-1] && (p[i-1] == s[j] || p[i-1] == \\'.\\'));\\n                }\\n                else  if (p[i] == s[j] || p[i] == \\'.\\')\\n                {\\n                     dp[x,y] = dp[x-1, y-1];\\n                }\\n            }\\n        }\\n        \\n        return dp[p.Length, s.Length];\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Runtime: 68 ms\\nMemory Usage: 24.4 MB\\n\\nO(S * P) where S is s.Length and P is p.Length\\n\\n```\\n    public bool IsMatch(string s, string p) {\\n        bool[,] dp = new bool[p.Length+1, s.Length+1];\\n        dp[0,0] = true;\\n        \\n        for(int i=0, x=1; i < p.Length; i++, x++)\\n        {\\n            if (p[i] == \\'*\\') { dp[x,0] = dp[x-2, 0]; }\\n            \\n            for(int j=0, y=1; j < s.Length; j++, y++)\\n            {\\n                if (p[i] == \\'*\\')\\n                {\\n                    dp[x,y] = dp[x-1,y] || dp[x-2, y] || (dp[x, y-1] && (p[i-1] == s[j] || p[i-1] == \\'.\\'));\\n                }\\n                else  if (p[i] == s[j] || p[i] == \\'.\\')\\n                {\\n                     dp[x,y] = dp[x-1, y-1];\\n                }\\n            }\\n        }\\n        \\n        return dp[p.Length, s.Length];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 5857,
                "title": "6-liner-in-python-beats-98-20",
                "content": "```\\nclass Solution(object):\\n    def isMatch(self, s, p, memo={(\"\",\"\"):True}):\\n        if not p and s:      return False\\n        if not s and p:      return set(p[1::2]) == {\"*\"} and not (len(p) % 2)\\n        if (s,p) in memo:    return memo[s,p]\\n        \\n        char, exp, prev = s[-1], p[-1], 0 if len(p) < 2 else p[-2]\\n        memo[s,p] =\\\\\\n               (exp == '*' and ((prev in {char, '.'} and self.isMatch(s[:-1], p, memo)) or self.isMatch(s, p[:-2], memo)))\\\\\\n               or\\\\\\n               (exp in {char, '.'} and self.isMatch(s[:-1], p[:-1], memo))\\n        return memo[s,p]\\n\\n# 445 / 445 test cases passed.\\n# Status: Accepted\\n# Runtime: 72 ms\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isMatch(self, s, p, memo={(\"\",\"\"):True}):\\n        if not p and s:      return False\\n        if not s and p:      return set(p[1::2]) == {\"*\"} and not (len(p) % 2)\\n        if (s,p) in memo:    return memo[s,p]\\n        \\n        char, exp, prev = s[-1], p[-1], 0 if len(p) < 2 else p[-2]\\n        memo[s,p] =\\\\\\n               (exp == '*' and ((prev in {char, '.'} and self.isMatch(s[:-1], p, memo)) or self.isMatch(s, p[:-2], memo)))\\\\\\n               or\\\\\\n               (exp in {char, '.'} and self.isMatch(s[:-1], p[:-1], memo))\\n        return memo[s,p]\\n\\n# 445 / 445 test cases passed.\\n# Status: Accepted\\n# Runtime: 72 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5926,
                "title": "30-lines-of-java-code-easy-to-read",
                "content": "    public class Solution {\\n        public boolean isMatch(String s, String p) {\\n            if (s == null && p == null) return true;\\n            if (s == null || p == null) return false;\\n            return isMatch(s, 0, p, 0);\\n        }\\n        \\n        public boolean isMatch(String s, int idx1, String p, int idx2) {\\n            if (s.length() == idx1 && p.length() == idx2) return true;\\n            if (p.length() == idx2) return false;\\n            if (s.length() == idx1) {\\n                if (idx2 + 1 >= p.length() || p.charAt(idx2 + 1) != '*') {\\n                    return false;\\n                }\\n                return isMatch(s, idx1, p, idx2 + 2);\\n            }\\n    \\n            if (idx2 + 1 <= p.length() - 1 && p.charAt(idx2 + 1) == '*') {\\n                if (s.charAt(idx1) == p.charAt(idx2) || p.charAt(idx2) == '.') {\\n                    return isMatch(s, idx1 + 1, p, idx2) || isMatch(s, idx1, p, idx2 + 2);\\n                }\\n                return isMatch(s, idx1, p, idx2 + 2);\\n            } else if (p.charAt(idx2) == '.') {\\n                return isMatch(s, idx1 + 1, p, idx2 + 1);\\n            } else {\\n                return p.charAt(idx2) == s.charAt(idx1) && isMatch(s, idx1 + 1, p, idx2 + 1);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isMatch(String s, String p) {\\n            if (s == null && p == null) return true;\\n            if (s == null || p == null) return false;\\n            return isMatch(s, 0, p, 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3762048,
                "title": "c-memoization-recursive-approach-with-comment-included",
                "content": "\\n# Approach\\nIn this optimized version, a memoization technique is used to store the computed results. The isMatchHelper function is called recursively, and its results are stored in the memo map to avoid redundant calculations.\\n\\nThe function takes two strings, s and p, along with the memoization map as parameters. It first checks if the result for the current input has already been computed. If so, it returns the stored result from the memo map.\\n\\nThe function then proceeds with the base case and recursive cases, just like the original code. However, after computing the match result, it stores it in the memo map using the key formed from s and p.\\n\\nBy utilizing memoization, the optimized code avoids redundant recursive calls and improves the overall efficiency of the algorithm.\\n\\n# C++ Code :\\n```\\n\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        // Create a map to store computed results\\n        unordered_map<string, bool> memo;\\n\\n        return isMatchHelper(s, p, memo);\\n    }\\n\\nprivate:\\n    bool isMatchHelper(const string& s, const string& p, unordered_map<string, bool>& memo) {\\n        // Check if the result has already been computed\\n        string key = s + \"-\" + p;\\n        if (memo.count(key))\\n            return memo[key];\\n\\n        // Base case: pattern is empty\\n        if (p.empty())\\n            return s.empty();\\n\\n        bool match = false;\\n\\n        // Check if the second character of the pattern is \\'*\\'\\n        if (p.length() > 1 && p[1] == \\'*\\') {\\n            // Case 1: Skip the current pattern character and \\'*\\'\\n            match = isMatchHelper(s, p.substr(2), memo);\\n\\n            // Case 2: Check if the current string character matches the pattern character (or the pattern is a dot)\\n            if (!match && !s.empty() && (s[0] == p[0] || p[0] == \\'.\\'))\\n                match = isMatchHelper(s.substr(1), p, memo);\\n        }\\n        else {\\n            // Check if the current string character matches the pattern character (or the pattern is a dot)\\n            if (!s.empty() && (s[0] == p[0] || p[0] == \\'.\\'))\\n                match = isMatchHelper(s.substr(1), p.substr(1), memo);\\n        }\\n\\n        // Store the computed result in the memoization map\\n        memo[key] = match;\\n\\n        return match;\\n    }\\n};\\n\\n```\\n![upvote1.jpg](https://assets.leetcode.com/users/images/22c4bd4a-4876-4b96-980d-9c170c1305a1_1689310629.18675.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        // Create a map to store computed results\\n        unordered_map<string, bool> memo;\\n\\n        return isMatchHelper(s, p, memo);\\n    }\\n\\nprivate:\\n    bool isMatchHelper(const string& s, const string& p, unordered_map<string, bool>& memo) {\\n        // Check if the result has already been computed\\n        string key = s + \"-\" + p;\\n        if (memo.count(key))\\n            return memo[key];\\n\\n        // Base case: pattern is empty\\n        if (p.empty())\\n            return s.empty();\\n\\n        bool match = false;\\n\\n        // Check if the second character of the pattern is \\'*\\'\\n        if (p.length() > 1 && p[1] == \\'*\\') {\\n            // Case 1: Skip the current pattern character and \\'*\\'\\n            match = isMatchHelper(s, p.substr(2), memo);\\n\\n            // Case 2: Check if the current string character matches the pattern character (or the pattern is a dot)\\n            if (!match && !s.empty() && (s[0] == p[0] || p[0] == \\'.\\'))\\n                match = isMatchHelper(s.substr(1), p, memo);\\n        }\\n        else {\\n            // Check if the current string character matches the pattern character (or the pattern is a dot)\\n            if (!s.empty() && (s[0] == p[0] || p[0] == \\'.\\'))\\n                match = isMatchHelper(s.substr(1), p.substr(1), memo);\\n        }\\n\\n        // Store the computed result in the memoization map\\n        memo[key] = match;\\n\\n        return match;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194902,
                "title": "dp-python3-time-o-mn-space-o-mn",
                "content": "This problem can be solved using dynamic programming. Let dp[i][j] be a boolean indicating whether the first i characters of s match the first j characters of p. We can initialize dp[0][0] = True because an empty string matches an empty pattern.\\n\\nFor the first row dp[0][j], we need to consider two cases: if p[j-1] is \\'*\\', we can ignore it and look at dp[0][j-2] (the pattern without the \\'*\\' and its preceding character), or if p[j-2] matches the empty string, we can look at dp[0][j-1] (the pattern with only the \\'*\\' and its preceding character).\\n\\nFor each subsequent cell dp[i][j], we need to consider three cases: if p[j-1] is a regular character and matches s[i-1], then dp[i][j] = dp[i-1][j-1]. If p[j-1] is a \\'*\\', then we can either ignore the preceding character and look at dp[i][j-2] (the pattern without the \\'*\\' and its preceding character), or if the preceding character matches s[i-1], we can look at dp[i-1][j] (the pattern with the \\'*\\' and one more repetition of the preceding character), or if the preceding character does not match s[i-1], we can ignore both the preceding character and the \\'*\\' and look at dp[i][j-2]. If p[j-1] is a ., then dp[i][j] = dp[i-1][j-1].\\n\\nThe final answer is dp[m][n], where m and n are the lengths of s and p, respectively.\\n\\nThe time complexity of this algorithm is O(mn) and the space complexity is O(mn), where m and n are the lengths of s and p, respectively.\\n\\n# Code\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n+1) for _ in range(m+1)]\\n        dp[0][0] = True\\n        for j in range(1, n+1):\\n            if p[j-1] == \\'*\\':\\n                dp[0][j] = dp[0][j-2]\\n            else:\\n                dp[0][j] = j > 1 and p[j-2] == \\'*\\' and dp[0][j-2]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if p[j-1] == s[i-1] or p[j-1] == \\'.\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i][j-2] or (p[j-2] == s[i-1] or p[j-2] == \\'.\\') and dp[i-1][j]\\n                else:\\n                    dp[i][j] = False\\n        return dp[m][n]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n+1) for _ in range(m+1)]\\n        dp[0][0] = True\\n        for j in range(1, n+1):\\n            if p[j-1] == \\'*\\':\\n                dp[0][j] = dp[0][j-2]\\n            else:\\n                dp[0][j] = j > 1 and p[j-2] == \\'*\\' and dp[0][j-2]\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if p[j-1] == s[i-1] or p[j-1] == \\'.\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i][j-2] or (p[j-2] == s[i-1] or p[j-2] == \\'.\\') and dp[i-1][j]\\n                else:\\n                    dp[i][j] = False\\n        return dp[m][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103833,
                "title": "go-solution-dp-tabulation-o-m-n-annotated",
                "content": "#### Tabulation\\n\\n```go\\nfunc isMatch(s string, p string) bool {\\n\\t// 1.\\n    table := make([][]bool, len(s)+1)\\n    for i := 0; i < len(table); i++ {\\n        table[i] = make([]bool, len(p)+1)\\n    }\\n    table[0][0] = true\\n    \\n\\t// 2.\\n    for j := 2; j < len(p)+1; j++ {\\n        if p[j-1] == \\'*\\' {\\n            table[0][j] = table[0][j-2]\\n        }\\n    }\\n    \\n\\t// 3.\\n    for i := 1; i < len(s)+1; i++ {\\n        for j := 1; j < len(p)+1; j++ {\\n            if s[i-1] == p[j-1] || p[j-1] == \\'.\\' {\\n\\t\\t\\t\\t// 4.\\n                table[i][j] = table[i-1][j-1]\\n            } else if p[j-1] == \\'*\\' { \\n                // 5.\\n\\t\\t\\t\\tempty := table[i][j-2]\\n                nonempty := (s[i-1] == p[j-2] || p[j-2] == \\'.\\') && table[i-1][j]\\n                table[i][j] = empty || nonempty\\n            }\\n        }\\n    }\\n    \\n\\t// 6.\\n    return table[len(s)][len(p)]\\n}\\n```\\n\\n1. Allocate a 2D boolean matrix with `len(s)+1` rows and `len(p)+1` columns. Throughout the solution, let `i` represent the row index and `j` represent the column index. The motivation for using this matrix is to compose (tabulate) our solution. We want to enforce the rule that for some `i` and some `j`, `table[i][j]` represents the answer to whether string `s[:i]` matches pattern `p[:j]`. `table[0][0]` represents the valid matching of the empty string `\"\"` and the empty pattern `\"\"`, thus we can set `table[0][0] = true`. \\n\\n\\n2. We\\'d like to iterate through each row and determine which patterns match the string at row index `i`. However, we must first determine which patterns match the empty string (represented by row 0). It\\'s only possible for patterns ending wtih `*` to match the empty string, becuase for some pattern  `x*` where `x` is some valid character, the empty string `\"\"` is also a match. At each index `j` where `p[j-1] == \\'*\\'` (remember that the 0 index represents the empty string, thus `j` is one greater than typical string indexing) we can set `table[0][j]` to the result found for `table[0][j-2]`, which is what remains after removing the empty representation of the pattern.\\n\\n\\n3.  Now we may iterate through our substrings, and for each iterate through each possible sub-pattern. Note that it is unnecessary to iterate through column `0` because no non-empty string matches an empty pattern, nor do we need to iterate through row `0` since we did this in step 2. There are two possible cases at each string-pattern combination: 4. and 5.\\n\\n\\n4.  Case A: The last character in the string `s[i-1]` matches the last character in the pattern `p[j-1]` -- this can occur when the characters are equivalent or the last pattern character is `.`. In this case, we the result of this comparison must equal to the already computed result for the substring / subpattern `s[:i-1]` and `p[:j-1]`. Thus `table[i][j]` is assigned the result at `table[i-1][j-1]`.   \\n\\n\\n5.  Case B: The last character in the pattern `p[j-1]` is equal to `\\'*\\'`. In this case, the pattern may be considered a match when `\\'*\\'` and its preceding character represent the empty set `\"\"` (already computed at `table[i][j-2]`) or some non-empty set, in which case the last character in our substring must match the preceding character `p[j-2]` AND the substring `s[:i-1]` must be a valid match to the same pattern. Thus `table[i][j]` is valid if either the empty or nonempty matched pattern matches the substring.\\n\\n\\n6.  The result is the dynamically computed result for our full input string and pattern at `table[len(s)][len(p)]`.\\n\\n#### Memoization\\n\\n```go\\ntype pair struct {\\n    s, p string\\n}\\n\\nfunc isMatch(s string, p string) bool {\\n\\t// 1. \\n    cache := map[pair]bool{\\n        pair{\"\", \"\"}: true,\\n    }\\n    \\n\\t// 2. \\n    var matches func(s, p string) bool\\n    matches = func(s, p string) bool {\\n\\t\\t// 3. \\n        if cache[pair{s, p}] {\\n            return true\\n        }\\n        if p == \"\" {\\n            return false\\n        }\\n        \\n        match := false\\n        if p[len(p)-1] == \\'*\\' {\\n\\t\\t\\t// 4. \\n            match = match || matches(s, p[:len(p)-2])\\n            idx := len(s)-1\\n            for 0 <= idx && (s[idx] == p[len(p)-2] || p[len(p)-2] == \\'.\\') {\\n                match = match || matches(s[:idx], p[:len(p)-2])\\n                idx--\\n            }\\n        } else if s != \"\" && (s[len(s)-1] == p[len(p)-1] || p[len(p)-1] == \\'.\\') {\\n\\t\\t\\t// 5. \\n            match = match || matches(s[:len(s)-1], p[:len(p)-1])\\n        }\\n        \\n\\t\\t// 6. \\n        cache[pair{s, p}] = match\\n        return match\\n    }\\n    \\n\\t// 7.\\n    return matches(s, p)\\n}\\n```\\n\\n1. Define a cache that can be used to lookup whether a given pair is a valid match. We know that the empty string - empty pattern pair is a valid match, so set it to `true`. This will also serve as our initial base case. \\n\\n2. Define a nested function `matches` that can be called recursively. By nesting the function we give it access to the `isMatch()` scoped `cache` map.\\n\\n3. Check the base cases. If the validity for pair `s, p` has already been computed, return it. If the pattern `p` is empty but `s` is not, we can be certain that the pattern is invalid, and return `false`.  \\n\\n4. If the last character in our pattern is `*`, we must compute the validity of each substring for which `x*` matches its suffix, where `x` is the second to last character in pattern `p`. Start by computing the case where `x*` represents the empty suffix, and then try every valid non-empty suffix in for loop.  \\n\\n5. Check the last characters of `s` and `p`. If they are a match, i.e. the last character of `p` is either equivalent to the last character of `s` or the special character `.`, then compute the match for the substring up to the last characters of both `s` and `p`.\\n6. Finally, store the result of the pair `s, p` in the cache.\\n\\n7. Call matches on the full length string and pattern `s` and `p`.",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc isMatch(s string, p string) bool {\\n\\t// 1.\\n    table := make([][]bool, len(s)+1)\\n    for i := 0; i < len(table); i++ {\\n        table[i] = make([]bool, len(p)+1)\\n    }\\n    table[0][0] = true\\n    \\n\\t// 2.\\n    for j := 2; j < len(p)+1; j++ {\\n        if p[j-1] == \\'*\\' {\\n            table[0][j] = table[0][j-2]\\n        }\\n    }\\n    \\n\\t// 3.\\n    for i := 1; i < len(s)+1; i++ {\\n        for j := 1; j < len(p)+1; j++ {\\n            if s[i-1] == p[j-1] || p[j-1] == \\'.\\' {\\n\\t\\t\\t\\t// 4.\\n                table[i][j] = table[i-1][j-1]\\n            } else if p[j-1] == \\'*\\' { \\n                // 5.\\n\\t\\t\\t\\tempty := table[i][j-2]\\n                nonempty := (s[i-1] == p[j-2] || p[j-2] == \\'.\\') && table[i-1][j]\\n                table[i][j] = empty || nonempty\\n            }\\n        }\\n    }\\n    \\n\\t// 6.\\n    return table[len(s)][len(p)]\\n}\\n```\n```go\\ntype pair struct {\\n    s, p string\\n}\\n\\nfunc isMatch(s string, p string) bool {\\n\\t// 1. \\n    cache := map[pair]bool{\\n        pair{\"\", \"\"}: true,\\n    }\\n    \\n\\t// 2. \\n    var matches func(s, p string) bool\\n    matches = func(s, p string) bool {\\n\\t\\t// 3. \\n        if cache[pair{s, p}] {\\n            return true\\n        }\\n        if p == \"\" {\\n            return false\\n        }\\n        \\n        match := false\\n        if p[len(p)-1] == \\'*\\' {\\n\\t\\t\\t// 4. \\n            match = match || matches(s, p[:len(p)-2])\\n            idx := len(s)-1\\n            for 0 <= idx && (s[idx] == p[len(p)-2] || p[len(p)-2] == \\'.\\') {\\n                match = match || matches(s[:idx], p[:len(p)-2])\\n                idx--\\n            }\\n        } else if s != \"\" && (s[len(s)-1] == p[len(p)-1] || p[len(p)-1] == \\'.\\') {\\n\\t\\t\\t// 5. \\n            match = match || matches(s[:len(s)-1], p[:len(p)-1])\\n        }\\n        \\n\\t\\t// 6. \\n        cache[pair{s, p}] = match\\n        return match\\n    }\\n    \\n\\t// 7.\\n    return matches(s, p)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2779500,
                "title": "java-solution-1-line-easy-to-read",
                "content": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        return s.matches(\"^\" + p + \"$\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        return s.matches(\"^\" + p + \"$\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626825,
                "title": "python-o-mn-top-down-dp-w-hint",
                "content": "**Matching rule on sepcial symbol**:\\n\\nDot symbol \\'.\\'  matches any single character.\\nStar symbol \\'*\\'  matches zero or more of the preceding element.\\n\\n---\\n\\n**Important**:\\n\\nFirst, it is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\\n\\nIn addition, leading character of * comes from not only english letters, but also \\'.\\' dot symbol\\nFor example,\\n```\\ns = \"abc\"\\np = \".*\"\\n```\\nis valid input, and **p** matches with **s**, return True\\n[The reason is that . match any arbitrary character]\\n\\n---\\n\\n**Hint and keypoint**:\\n\\nThe core of this string matching algorithm is the **handling of wildcard * star symbol**\\n\\nThere are total three possible next moves for wildcard * star symbol.\\n\\nWrite down some small cases, and derive corresponding state transfer function.\\n\\n```\\n\\n# deinfe L = leading character of \\'*\\' in pattern\\n\\n# Type_1: L* match current character once, pattern discards * after this round\\n# Type_2: L* match current character more than once, pattern keeps * after this round\\n# Type_3: L* match nothing, pattern discards L* after this round\\n\\t\\n```\\t\\n\\n\\nfor **Type_#1**: \\n\\n**L*** match current character **once**, pattern discards * after this round\\n\\nObserve the matching process and derive the state transfer function with\\n```\\ns = \"ba\"\\np = \"ba*\"\\n```\\n\\n```\\ndp(src, pattern) -> dp(src, pattern-1)\\n```\\n\\n---\\n\\nfor **Type_#2**:\\n\\n**L*** match current character **more than once**, pattern keeps * after this round\\n\\nObserve the matching process and derive the state transfer function with\\n```\\ns = \"baaa\"\\np = \"ba*\"\\n```\\n\\n```\\ndp(src, pattern) -> dp(src-1, pattern)\\n```\\n\\n---\\n\\nfor **Type_#3**:\\n\\nL* **match nothing,** pattern discards L* after this round\\n\\nObserve the matching process and derive the state transfer function with\\n```\\ns = \"b\"\\np = \"ba*\"\\n```\\n\\t\\n```\\ndp(src, pattern) -> dp(src, pattern-2)\\n```\\n\\n---\\n\\n\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        \\n        is_non_empty = lambda i : i > -1\\n        is_empty = lambda i: not is_non_empty(i)\\n        \\n        # use python built-in cache as memoization for DP\\n        @cache\\n        def dp(src, pattern):\\n            \\n            if is_empty(src) and is_empty(pattern):\\n                \\n                # Accept on perfect match\\n                return True\\n            \\n            elif ( is_empty(src) and p[pattern] != \\'*\\') or is_empty(pattern):\\n                \\n                # Reject on invalid boundary cases\\n                \\n                # source string is empty with no wildcard star *  in pattern, or\\n                # pattern string is empty\\n                return False\\n            \\n            elif ( s[src] == p[pattern] ) or ( p[pattern] == \\'.\\' ):\\n                \\n                # Either current character is the same, or current character is matched with \\'.\\'\\n                # go to next round dp(src-1, pattern-1)\\n                return dp(src-1, pattern-1)\\n            \\n            elif p[pattern] == \\'*\\':\\n                \\n                # deinfe L = leading character of \\'*\\' in pattern\\n                L = p[pattern-1]\\n                \\n                if is_non_empty(src) and ( ( s[src] == L ) or ( L == \\'.\\' ) ):\\n                    \\n                    # Type_1: L* match current character once, pattern discards * after this round\\n                    # Type_2: L* match current character more than once, pattern keeps * after this round\\n                    # Type_3: L* match nothing, pattern discard L* after this round\\n                    return dp(src, pattern-1) or dp(src-1, pattern) or dp(src, pattern-2)\\n                \\n                else:\\n                    # Type_3: L* match nothing, pattern discard L* after this round\\n                    return dp(src, pattern-2)\\n            \\n            else:\\n                \\n                # Reject\\n                # current p[pattern] is not wildcard symbol, and s[src] != p[pattern]\\n                return False\\n        \\n        # --------------------------------------------\\n        tail_source_idx, tail_pattern_idx = len(s)-1, len(p)-1\\n        \\n        return dp(tail_source_idx, tail_pattern_idx)\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n**Highly recomended practing the following one** in order to review and strengthen the concept about DP, state transfer function, as well as string-operation.\\n\\n[Leetcode #44 Wildcard matching](https://leetcode.com/problems/wildcard-matching/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about @cache and memoization](https://docs.python.org/3/library/functools.html#functools.cache)\\n\\n[2] [Python official docs about lambda expression](https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\ns = \"abc\"\\np = \".*\"\\n```\n```\\n\\n# deinfe L = leading character of \\'*\\' in pattern\\n\\n# Type_1: L* match current character once, pattern discards * after this round\\n# Type_2: L* match current character more than once, pattern keeps * after this round\\n# Type_3: L* match nothing, pattern discards L* after this round\\n\\t\\n```\n```\\ns = \"ba\"\\np = \"ba*\"\\n```\n```\\ndp(src, pattern) -> dp(src, pattern-1)\\n```\n```\\ns = \"baaa\"\\np = \"ba*\"\\n```\n```\\ndp(src, pattern) -> dp(src-1, pattern)\\n```\n```\\ns = \"b\"\\np = \"ba*\"\\n```\n```\\ndp(src, pattern) -> dp(src, pattern-2)\\n```\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        \\n        is_non_empty = lambda i : i > -1\\n        is_empty = lambda i: not is_non_empty(i)\\n        \\n        # use python built-in cache as memoization for DP\\n        @cache\\n        def dp(src, pattern):\\n            \\n            if is_empty(src) and is_empty(pattern):\\n                \\n                # Accept on perfect match\\n                return True\\n            \\n            elif ( is_empty(src) and p[pattern] != \\'*\\') or is_empty(pattern):\\n                \\n                # Reject on invalid boundary cases\\n                \\n                # source string is empty with no wildcard star *  in pattern, or\\n                # pattern string is empty\\n                return False\\n            \\n            elif ( s[src] == p[pattern] ) or ( p[pattern] == \\'.\\' ):\\n                \\n                # Either current character is the same, or current character is matched with \\'.\\'\\n                # go to next round dp(src-1, pattern-1)\\n                return dp(src-1, pattern-1)\\n            \\n            elif p[pattern] == \\'*\\':\\n                \\n                # deinfe L = leading character of \\'*\\' in pattern\\n                L = p[pattern-1]\\n                \\n                if is_non_empty(src) and ( ( s[src] == L ) or ( L == \\'.\\' ) ):\\n                    \\n                    # Type_1: L* match current character once, pattern discards * after this round\\n                    # Type_2: L* match current character more than once, pattern keeps * after this round\\n                    # Type_3: L* match nothing, pattern discard L* after this round\\n                    return dp(src, pattern-1) or dp(src-1, pattern) or dp(src, pattern-2)\\n                \\n                else:\\n                    # Type_3: L* match nothing, pattern discard L* after this round\\n                    return dp(src, pattern-2)\\n            \\n            else:\\n                \\n                # Reject\\n                # current p[pattern] is not wildcard symbol, and s[src] != p[pattern]\\n                return False\\n        \\n        # --------------------------------------------\\n        tail_source_idx, tail_pattern_idx = len(s)-1, len(p)-1\\n        \\n        return dp(tail_source_idx, tail_pattern_idx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459437,
                "title": "c-0ms-100-faster-solution-dp-easy",
                "content": "```\\n1, If p[i-1] == s[j-1]  ->  dp[i][j] = dp[i-1][j-1];\\n2, If p[i-1] == \\'.\\'  ->  dp[i][j] = dp[i-1][j-1];\\n3, If p[i-1] == \\'*\\' :\\n   There are two possible conditions in such case:\\n               1   if p[i-2] != s[j-1] and p[i-2] != \\'.\\'  ->  dp[i][j] = dp[i-2][j]  // in this case, a* counts as empty\\n               2   if p[i-2] == s[j-1] or p[i-2] == \\'.\\':\\n                              dp[i][j] = dp[i-2][j]    //in this case, a* counts as empty \\n                           or dp[i][j] = dp[i-2][j-1]   // in this case, a* counts as single a\\n                           or dp[i][j] = dp[i][j-1]   // in this case, a* counts as multiple a\\n```\\t\\t   \\n  Here\\'s the code:\\n  ```\\n  bool isMatch(string s, string p) {\\n        int sn = s.size();\\n        int pn = p.size();\\n        \\n        if(sn==0 and pn==0)\\n            return true;\\n        if(sn==0 || pn==0)\\n            return false;\\n        \\n        bool dp[pn+1][sn+1];\\n        memset(dp, false, sizeof(dp));\\n        dp[0][0] = true; // because empty pattern matches empty string\\n        \\n\\t\\t/*\\n\\t\\tBelow for loop updates the first column of the dp matrix which pertains to empty string(here, s) and non-empty pattern(here, p).\\n\\t\\tBasically the concept is that for an empty string and non-empty pattern, if we come across any \\'*\\' then:\\n\\t\\t\\t\\t- Check two rows above. (Reason for 2 rows above is because 1 row above element can be consumed by the current \\'*\\').\\n\\t\\t\\t\\t- If for 2 rows above, pattern matches empty string then set dp[i][j] -> true\\n\\t\\t\\t\\t- else dp[i][j] -> false\\n\\t\\t*/\\n        for(int i=2; i<=pn; i++)\\n            if(p[i-1] == \\'*\\')\\n                dp[i][0] = dp[i-2][0];\\n        \\n        for(int i=1; i<=pn; i++){\\n            for(int j=1; j<=sn; j++){\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'.\\')\\n                    dp[i][j] = dp[i-1][j-1];\\n                else if(p[i-1] == \\'*\\'){\\n                    if((p[i-2] != s[j-1]) and p[i-2] != \\'.\\')\\n                        dp[i][j] = dp[i-2][j];\\n                    else\\n                        dp[i][j] = dp[i-2][j] || dp[i-2][j-1] || dp[i][j-1];\\n                }\\n            }\\n        }\\n        \\n        return dp[pn][sn];\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n1, If p[i-1] == s[j-1]  ->  dp[i][j] = dp[i-1][j-1];\\n2, If p[i-1] == \\'.\\'  ->  dp[i][j] = dp[i-1][j-1];\\n3, If p[i-1] == \\'*\\' :\\n   There are two possible conditions in such case:\\n               1   if p[i-2] != s[j-1] and p[i-2] != \\'.\\'  ->  dp[i][j] = dp[i-2][j]  // in this case, a* counts as empty\\n               2   if p[i-2] == s[j-1] or p[i-2] == \\'.\\':\\n                              dp[i][j] = dp[i-2][j]    //in this case, a* counts as empty \\n                           or dp[i][j] = dp[i-2][j-1]   // in this case, a* counts as single a\\n                           or dp[i][j] = dp[i][j-1]   // in this case, a* counts as multiple a\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1440437,
                "title": "c-bottom-up-dp-explanation-o-m-n-time-0ms-runtime",
                "content": "**Definitions:**\\n**dp[i][j] :**  boolean denoting whether it is possible  to match `string s of length i`(from start) with `pattern t of length j`(from start)\\n\\n**Base Cases:**\\n* for i == 0 and j ==0 , dp[0][0] = true as both are empty strings(length = 0)\\n* for i != 0 and j = 0 (i.e. non-empty string s and empty pattern p) , it isn\\'t possible to match both of them, thus `dp[i][0] = false`(when j != 0)\\n* for i=0 and j!= 0 (i.e. empty string s and non-empty pattern p),  if pattern string only contains `(some char)*`, then we can easily take 0 of `some char` to match with the empty string s.\\n\\n**Recursive relation**\\nFor each string of len i in string s (s[0... i-1]) and len j in pattern p (p[0.... j-1])  :\\n1. if p[j-1] != \\'* \\':\\n\\t\\tdp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == \\'.\\')    \\n\\t\\tThis is straightforward as we just match the current characters and the previous substrings.\\n2. if p[j-1] == \\'* \\'    `(some char)*`:\\n\\t\\tcase 1:\\n\\t\\t\\t\\tWe take zero occurence of `(some char)`\\n\\t\\t\\t\\tThen we will just match the current substring of string s and current substring of pattern p excluding `(some char) and *`.\\n\\t\\t\\t\\tdp[i][j] = dp[i][j] || dp[i][j-2];\\n\\t\\tcase 2:\\n\\t\\t\\t\\t\\tIf current char in string s is same as `(some char)` or if `(some char) == \\'. \\'`(so that it can replace any char), we set the * to one   `(some char)`(note that * is still in the current substring of pattern p so more than * can match more than one char in string s with `(some char)` but it hasalready ebeen calculated) and match it with rest of substring of s.\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i][j] || dp[i-1][j]; \\n\\t\\t\\t\\t\\t\\n**Time Complexity**\\nO(mn) where m and n are lengths of pattern p and string   s respectively.\\nReason : We are visiting each block of N X M matrix once and each block requires constant time operations.\\n\\n**Space Complexity**\\nO(mn)\\nCan be improved to O(m) as we only need the prev row to calculate the values of current row.\\n\\n\\n* Be careful of the indexing in dp matrix(1-index) and in strings(0-indexed)\\n\\n```\\nbool isMatch(string s, string p) {\\n        int n = s.size() , m = p.size();\\n        vector<vector<bool> > dp(n+1 ,vector<bool>(m+1 , false));            //base case 2 is already taken care of here\\n        dp[0][0] = true;                //base case 1\\n        \\n\\t\\t//base case 3\\n        for(int i = 2; i<=m ; i+=2)\\n            if(p[i-1] == \\'*\\')\\n            {\\n                dp[0][i-1] = true;\\n                dp[0][i] = true;\\n            }\\n            else\\n                break;\\n        \\n        for(int i = 1; i <=n; ++i)\\n            for(int j = 1; j <=m; ++j)\\n            {\\n                if(p[j-1] != \\'*\\')\\n                    dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == \\'.\\');\\n                else\\n                {\\n                    char curr = p[j-2];\\n                    dp[i][j] = dp[i][j] || dp[i][j-2];\\n                    \\n                    if(curr == \\'.\\' || s[i-1] == curr)\\n                        dp[i][j] = dp[i][j] || dp[i-1][j];                    \\n                }\\n            }\\n        \\n             \\n        return dp[n][m];\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nbool isMatch(string s, string p) {\\n        int n = s.size() , m = p.size();\\n        vector<vector<bool> > dp(n+1 ,vector<bool>(m+1 , false));            //base case 2 is already taken care of here\\n        dp[0][0] = true;                //base case 1\\n        \\n\\t\\t//base case 3\\n        for(int i = 2; i<=m ; i+=2)\\n            if(p[i-1] == \\'*\\')\\n            {\\n                dp[0][i-1] = true;\\n                dp[0][i] = true;\\n            }\\n            else\\n                break;\\n        \\n        for(int i = 1; i <=n; ++i)\\n            for(int j = 1; j <=m; ++j)\\n            {\\n                if(p[j-1] != \\'*\\')\\n                    dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1] || p[j-1] == \\'.\\');\\n                else\\n                {\\n                    char curr = p[j-2];\\n                    dp[i][j] = dp[i][j] || dp[i][j-2];\\n                    \\n                    if(curr == \\'.\\' || s[i-1] == curr)\\n                        dp[i][j] = dp[i][j] || dp[i-1][j];                    \\n                }\\n            }\\n        \\n             \\n        return dp[n][m];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 817520,
                "title": "well-documented-c-recursion-converted-to-dp",
                "content": "\\nLet\\'s define problem statement\\nWe are given two strings-> input string and a pattern\\nWe have to return whether pattern matches input string or not.\\n\\nstring can contain characters a-z or it may be empty\\npattern can contain a-z,\\'.\\',\\'*\\' or it may be empty\\n\\n. matches with any single character of input string\\n* matches zero or more of the preceding element(For example: input:\"aaab\",pattern b* since precedding element of * in pattern is b it matches b in input string)\\n\\nLets move on to solution:\\nFirst i will describe recursive solution:\\n```\\nbool dfs(string s, string p, int l1, int l2)\\n{\\n    //base cases\\n\\t//if both strings are empty it will be a match so we return true\\n    if (l1 == 0 && l2 == 0)\\n    {\\n        return true;\\n    }\\n\\t//if input string is empty\\n    if (l1 == 0)\\n    {\\n\\t\\t/*if length of pattern is 1 while input is empty it cannot be a match since a pattern may be \\'.\\',\\'*\\' or \\'a-z\\'\\n\\t\\tnow let us understand case by case :\\n\\t\\t. -> matches with a single character but since input is empty so no match\\n\\t\\tsimilarily for a-z no match\\n\\t\\t* -> it does not have any preceeding element as length is one so no match*/\\n        if (l2 == 1)\\n        {\\n            return false;\\n        }\\n\\t\\t/*here pattern length>1\\n\\t\\tif last character is not * it can not be a match*/\\n        else if (p[l2 - 1] != \\'*\\')\\n        {\\n            return false;\\n        }\\n\\t\\t/*here last character is * and length>1\\n\\t\\tsince * can match 0 or more of preceding element \\n\\t\\t\\there since first string is empty * will match zero occurences of preceding element so we \\n\\t\\t\\twill recur for rec(input,patt-2)*/\\n        else\\n        {\\n            return dfs(s, p, l1, l2 - 2);\\n        }\\n    }\\n\\t/*if input is non-empty and pattern is empty then no match*/\\n    if (l2 == 0)\\n    {\\n        return false;\\n    }\\n\\n    //main body\\n\\t/*if last character of pattern is either . or matches with last character of input then recur for rec(in-1,pat-1)*/\\n    if (s[l1 - 1] == p[l2 - 1] || p[l2 - 1] == \\'.\\')\\n    {\\n        return dfs(s, p, l1 - 1, l2 - 1);\\n    }\\n\\t\\n\\t/*if last character of pattern is * */\\n    else if (p[l2 - 1] == \\'*\\')\\n    {\\n        if (p[l2 - 2] == s[l1 - 1] || p[l2 - 2] == \\'.\\')\\n        {\\n\\t\\t//it can match will either zero occurences of preceding char -> recur for(in,pat-2)\\n\\t\\t//it can match with last char ->recur for rec(in-1,pat)\\n            return dfs(s, p, l1 - 1, l2) || dfs(s, p, l1, l2 - 2);\\n        }\\n        else\\n        {\\n            return dfs(s, p, l1, l2 - 2);\\n        }\\n    }\\n    return false;\\n}\\n```\\nsimilarily dp solution can be constructed\\n```\\nbool optimizedDFS(string s, string p)\\n{\\n    int l1 = s.length();\\n    int l2 = p.length();\\n\\n    bool dp[l1 + 1][l2 + 1];\\n\\n    for (int i = 0; i <= l1; i++)\\n    {\\n        for (int j = 0; j <= l2; j++)\\n        {\\n            //base cases\\n\\n            if (i == 0 && j == 0)\\n            {\\n                dp[i][j] = true;\\n            }\\n            else if (i == 0)\\n            {\\n                if (j == 1)\\n                {\\n                    dp[i][j] = false;\\n                }\\n                else if (p[j - 1] != \\'*\\')\\n                {\\n                    dp[i][j] = false;\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i][j - 2];\\n                }\\n            }\\n\\n            else if (j == 0)\\n            {\\n                dp[i][j] = false;\\n            }\\n\\n            //main body\\n\\n            else\\n            {\\n                if (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\')\\n                {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n                else if (p[j - 1] == \\'*\\')\\n                {\\n                    if (p[j - 2] == s[i - 1] || p[j - 2] == \\'.\\')\\n                    {\\n                        dp[i][j] = dp[i - 1][j] || dp[i][j - 2];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = dp[i][j - 2];\\n                    }\\n                }\\n                else\\n                {\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n    }\\n    return dp[l1][l2];\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nbool dfs(string s, string p, int l1, int l2)\\n{\\n    //base cases\\n\\t//if both strings are empty it will be a match so we return true\\n    if (l1 == 0 && l2 == 0)\\n    {\\n        return true;\\n    }\\n\\t//if input string is empty\\n    if (l1 == 0)\\n    {\\n\\t\\t/*if length of pattern is 1 while input is empty it cannot be a match since a pattern may be \\'.\\',\\'*\\' or \\'a-z\\'\\n\\t\\tnow let us understand case by case :\\n\\t\\t. -> matches with a single character but since input is empty so no match\\n\\t\\tsimilarily for a-z no match\\n\\t\\t* -> it does not have any preceeding element as length is one so no match*/\\n        if (l2 == 1)\\n        {\\n            return false;\\n        }\\n\\t\\t/*here pattern length>1\\n\\t\\tif last character is not * it can not be a match*/\\n        else if (p[l2 - 1] != \\'*\\')\\n        {\\n            return false;\\n        }\\n\\t\\t/*here last character is * and length>1\\n\\t\\tsince * can match 0 or more of preceding element \\n\\t\\t\\there since first string is empty * will match zero occurences of preceding element so we \\n\\t\\t\\twill recur for rec(input,patt-2)*/\\n        else\\n        {\\n            return dfs(s, p, l1, l2 - 2);\\n        }\\n    }\\n\\t/*if input is non-empty and pattern is empty then no match*/\\n    if (l2 == 0)\\n    {\\n        return false;\\n    }\\n\\n    //main body\\n\\t/*if last character of pattern is either . or matches with last character of input then recur for rec(in-1,pat-1)*/\\n    if (s[l1 - 1] == p[l2 - 1] || p[l2 - 1] == \\'.\\')\\n    {\\n        return dfs(s, p, l1 - 1, l2 - 1);\\n    }\\n\\t\\n\\t/*if last character of pattern is * */\\n    else if (p[l2 - 1] == \\'*\\')\\n    {\\n        if (p[l2 - 2] == s[l1 - 1] || p[l2 - 2] == \\'.\\')\\n        {\\n\\t\\t//it can match will either zero occurences of preceding char -> recur for(in,pat-2)\\n\\t\\t//it can match with last char ->recur for rec(in-1,pat)\\n            return dfs(s, p, l1 - 1, l2) || dfs(s, p, l1, l2 - 2);\\n        }\\n        else\\n        {\\n            return dfs(s, p, l1, l2 - 2);\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\nbool optimizedDFS(string s, string p)\\n{\\n    int l1 = s.length();\\n    int l2 = p.length();\\n\\n    bool dp[l1 + 1][l2 + 1];\\n\\n    for (int i = 0; i <= l1; i++)\\n    {\\n        for (int j = 0; j <= l2; j++)\\n        {\\n            //base cases\\n\\n            if (i == 0 && j == 0)\\n            {\\n                dp[i][j] = true;\\n            }\\n            else if (i == 0)\\n            {\\n                if (j == 1)\\n                {\\n                    dp[i][j] = false;\\n                }\\n                else if (p[j - 1] != \\'*\\')\\n                {\\n                    dp[i][j] = false;\\n                }\\n                else\\n                {\\n                    dp[i][j] = dp[i][j - 2];\\n                }\\n            }\\n\\n            else if (j == 0)\\n            {\\n                dp[i][j] = false;\\n            }\\n\\n            //main body\\n\\n            else\\n            {\\n                if (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\')\\n                {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n                else if (p[j - 1] == \\'*\\')\\n                {\\n                    if (p[j - 2] == s[i - 1] || p[j - 2] == \\'.\\')\\n                    {\\n                        dp[i][j] = dp[i - 1][j] || dp[i][j - 2];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = dp[i][j - 2];\\n                    }\\n                }\\n                else\\n                {\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n    }\\n    return dp[l1][l2];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 471944,
                "title": "javascript",
                "content": "Runtime: 120 ms, faster than 38.07% of JavaScript online submissions for Regular Expression Matching.\\nMemory Usage: 37.3 MB, less than 47.06% of JavaScript online submissions for Regular Expression Matching.\\n\\ninspired by @ivan_allen\\n\\n```\\nvar isMatch = function(s, p) {\\n  if (p.length === 0) {\\n    return s.length === 0;\\n  }\\n  const firstMatch = s.length > 0 && (s[0] === p[0] || p[0] === \".\");\\n  if (p.length >= 2 && p[1] === \"*\") {\\n    return (\\n      isMatch(s, p.substring(2)) || (firstMatch && isMatch(s.substring(1), p))\\n    );\\n  } else {\\n    return firstMatch && isMatch(s.substring(1), p.substring(1));\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isMatch = function(s, p) {\\n  if (p.length === 0) {\\n    return s.length === 0;\\n  }\\n  const firstMatch = s.length > 0 && (s[0] === p[0] || p[0] === \".\");\\n  if (p.length >= 2 && p[1] === \"*\") {\\n    return (\\n      isMatch(s, p.substring(2)) || (firstMatch && isMatch(s.substring(1), p))\\n    );\\n  } else {\\n    return firstMatch && isMatch(s.substring(1), p.substring(1));\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234998,
                "title": "javascript-solution",
                "content": "```\\nvar isMatch = function(s, p) {\\n    if (s.length === 0 && p.length === 0) {\\n        return true\\n    }\\n    \\n    if (s.length !== 0 && p.length === 0) {\\n        return false\\n    }\\n    \\n    if (s.length === 0 && p.length !== 0) {\\n        if (p[1] === \\'*\\') {\\n            return isMatch(s, p.slice(2))\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    if (p[1] === \\'*\\') {\\n        if (s[0] === p[0] || p[0] === \\'.\\') {\\n            return isMatch(s.slice(1), p) || isMatch(s, p.slice(2))    \\n        } else {\\n            return isMatch(s, p.slice(2))\\n        }\\n    } else {\\n        if (s[0] === p[0] || p[0] === \\'.\\') {\\n            return isMatch(s.slice(1), p.slice(1))\\n        } else {\\n            return false\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isMatch = function(s, p) {\\n    if (s.length === 0 && p.length === 0) {\\n        return true\\n    }\\n    \\n    if (s.length !== 0 && p.length === 0) {\\n        return false\\n    }\\n    \\n    if (s.length === 0 && p.length !== 0) {\\n        if (p[1] === \\'*\\') {\\n            return isMatch(s, p.slice(2))\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    if (p[1] === \\'*\\') {\\n        if (s[0] === p[0] || p[0] === \\'.\\') {\\n            return isMatch(s.slice(1), p) || isMatch(s, p.slice(2))    \\n        } else {\\n            return isMatch(s, p.slice(2))\\n        }\\n    } else {\\n        if (s[0] === p[0] || p[0] === \\'.\\') {\\n            return isMatch(s.slice(1), p.slice(1))\\n        } else {\\n            return false\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 231360,
                "title": "ruby-version-with-thought-process",
                "content": "Recursive version, e.g. given (str, \"c\\\\*a\\\\*b\")\\n  - it\\'s the same as (str, \"a\\\\*b\") if \"a\\\\*b\" can still match str (e.g. \"aab\" \"ab\")\\n  - it\\'s the same as (str[1..-1], \"c\\\\*a\\\\*b\") if the first character is \\'c\\' or \\'.\\' (e.g. \"ccab\" \".ab\")\\n  ...\\n  - otherwise just check if both first character matches and recursively call on their tails\\n  - when to stop: if there is no more pattern to match, str should also be empty\\n\\n``` ruby\\ndef is_match(s, p)\\n  return s.empty? if p.empty?\\n  first = !s.empty? && [s[0], \\'.\\'].include?(p[0])\\n  if p[1] == \\'*\\'\\n    is_match(s, p[2..-1]) || (first && is_match(s[1..-1], p))\\n  else\\n    first && is_match(s[1..-1], p[1..-1])\\n  end\\nend\\n```\\n\\nNow how to optimize this? Let\\'s first use indices instead of slicing strings, the runtime is the same\\n``` ruby\\ndef is_match_a(i, j, s, p)\\n  return i == s.length if j == p.length\\n  first = i < s.length && [s[i], \\'.\\'].include?(p[j])\\n  if p[j+1] == \\'*\\'\\n    is_match(i, j+2, s, p) || (first && is_match(i+1, j, s, p))\\n  else\\n    first && is_match(i+1, j+1, s, p)\\n  end\\nend\\n```\\n\\n``` ruby\\nAt last, we can use DP instead of recursion, with some optimization\\ndef is_match(s, p)\\n  s = s.bytes\\n  p= p.bytes\\n  dp = Array.new(s.length+1) { Array.new(p.length+1, false) }\\n  m, n = s.length, p.length\\n  dp[m][n] = true\\n  m.downto(0) do |i| \\n    (n-1).downto(0) do |j| \\n      first = i < m && (s[i] == p[j] || p[j] == 46)\\n      if p[j+1] == 42\\n        dp[i][j] = dp[i][j+2] || (first && dp[i+1][j])\\n      else\\n        dp[i][j] = first && dp[i+1][j+1]\\n      end\\n    end\\n  end\\n  dp[0][0]\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "``` ruby\\ndef is_match(s, p)\\n  return s.empty? if p.empty?\\n  first = !s.empty? && [s[0], \\'.\\'].include?(p[0])\\n  if p[1] == \\'*\\'\\n    is_match(s, p[2..-1]) || (first && is_match(s[1..-1], p))\\n  else\\n    first && is_match(s[1..-1], p[1..-1])\\n  end\\nend\\n```\n``` ruby\\ndef is_match_a(i, j, s, p)\\n  return i == s.length if j == p.length\\n  first = i < s.length && [s[i], \\'.\\'].include?(p[j])\\n  if p[j+1] == \\'*\\'\\n    is_match(i, j+2, s, p) || (first && is_match(i+1, j, s, p))\\n  else\\n    first && is_match(i+1, j+1, s, p)\\n  end\\nend\\n```\n``` ruby\\nAt last, we can use DP instead of recursion, with some optimization\\ndef is_match(s, p)\\n  s = s.bytes\\n  p= p.bytes\\n  dp = Array.new(s.length+1) { Array.new(p.length+1, false) }\\n  m, n = s.length, p.length\\n  dp[m][n] = true\\n  m.downto(0) do |i| \\n    (n-1).downto(0) do |j| \\n      first = i < m && (s[i] == p[j] || p[j] == 46)\\n      if p[j+1] == 42\\n        dp[i][j] = dp[i][j+2] || (first && dp[i+1][j])\\n      else\\n        dp[i][j] = first && dp[i+1][j+1]\\n      end\\n    end\\n  end\\n  dp[0][0]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 5732,
                "title": "my-concise-20-line-c-solution-using-recursion",
                "content": "Run-time is 160 ms. One thing to note is that several of the recursive calls are tail-recursive so compiler can optimize it. \\n\\n    public class Solution {\\n        public bool IsMatch(string s, string p) {\\n            return IsMatch(s,p,0,0);\\n        }\\n        \\n        bool IsMatch(string s, string p, int i, int j) {\\n            \\n            //base case - reached end of pattern\\n            if(j >= p.Length) {\\n                return i >= s.Length && j >= p.Length; \\n            }\\n            \\n            if(j+1 < p.Length && p[j+1]=='*') { //peek ahead for *\\n                while(i < s.Length && (s[i]==p[j] || p[j]=='.')) { \\n                    if(IsMatch(s,p,i,j+2)) return true;\\n                    i++;\\n                }\\n                return IsMatch(s,p,i,j+2);\\n            } else if(i < s.Length && (s[i]==p[j] || p[j]=='.')) { //direct 1-to-1 match\\n                return IsMatch(s,p,i+1,j+1);\\n            }\\n            \\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public bool IsMatch(string s, string p) {\\n            return IsMatch(s,p,0,0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3436834,
                "title": "beats-100-0ms-0-row-col-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        \\n        int rows = s.length();\\n        int columns = p.length();\\n \\n        if (rows == 0 && columns == 0) {\\n            return true;\\n        }\\n        if (columns == 0) {\\n            return false;\\n        }\\n       \\n        boolean[][] dp = new boolean[rows + 1][columns + 1];\\n       \\n        dp[0][0] = true;\\n      \\n        for (int i = 2; i < columns + 1; i++) {\\n            if (p.charAt(i - 1) == \\'*\\') {\\n                dp[0][i] = dp[0][i - 2];\\n            }\\n        }\\n        \\n        for (int i = 1; i < rows + 1; i++) {\\n            for (int j = 1; j < columns + 1; j++) {\\n                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == \\'.\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else if (j > 1 && p.charAt(j - 1) == \\'*\\') {\\n                    dp[i][j] = dp[i][j - 2];\\n                    if (p.charAt(j - 2) == \\'.\\' || p.charAt(j - 2) == s.charAt(i - 1)) {\\n                        dp[i][j] = dp[i][j] | dp[i - 1][j];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[rows][columns];\\n    }\\n}\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        \\n        int rows = s.length();\\n        int columns = p.length();\\n \\n        if (rows == 0 && columns == 0) {\\n            return true;\\n        }\\n        if (columns == 0) {\\n            return false;\\n        }\\n       \\n        boolean[][] dp = new boolean[rows + 1][columns + 1];\\n       \\n        dp[0][0] = true;\\n      \\n        for (int i = 2; i < columns + 1; i++) {\\n            if (p.charAt(i - 1) == \\'*\\') {\\n                dp[0][i] = dp[0][i - 2];\\n            }\\n        }\\n        \\n        for (int i = 1; i < rows + 1; i++) {\\n            for (int j = 1; j < columns + 1; j++) {\\n                if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == \\'.\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else if (j > 1 && p.charAt(j - 1) == \\'*\\') {\\n                    dp[i][j] = dp[i][j - 2];\\n                    if (p.charAt(j - 2) == \\'.\\' || p.charAt(j - 2) == s.charAt(i - 1)) {\\n                        dp[i][j] = dp[i][j] | dp[i - 1][j];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[rows][columns];\\n    }\\n}\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932089,
                "title": "c-3-liner-accepted-using-recursion-and-backtracking-also-dp-solution-o-nm-time",
                "content": "<h1>Recursion and Backtracking </h1>\\ntime Complexity   <h3><strong>O(2^N)</strong></h3>\\n\\n```\\nif (p.empty()) return s.empty();\\n    bool first_match = !s.empty() && (s[0] == p[0] || p[0] == \\'.\\');\\n    if (p.size() >= 2 && p[1] == \\'*\\')     return isMatch(s, p.substr(2)) || (first_match && isMatch(s.substr(1), p));\\n    else  return first_match && isMatch(s.substr(1), p.substr(1)); \\n\\t\\n```\\n\\n<h1> Dynamic Programming Approach </h1>\\n\\n```\\nbool isMatch(string s, string p) {\\n    // Initialize the 2D table for dynamic programming\\n    int m = s.size(), n = p.size();\\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n\\n    // Base case: both s and p are empty\\n    dp[0][0] = true;\\n\\n    // Fill the table for the empty input string\\n    for (int j = 2; j <= n; j++) {\\n        dp[0][j] = (p[j - 1] == \\'*\\') && dp[0][j - 2];\\n    }\\n\\n    // Fill the rest of the table\\n    for (int i = 1; i <= m; i++) {\\n        for (int j = 1; j <= n; j++) {\\n            // Check if the characters match or if the pattern character is \\'.\\'\\n            bool first_match = (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\');\\n            if (j >= 2 && p[j - 1] == \\'*\\') {\\n                // If the pattern character is \\'*\\', try matching zero or more characters\\n                dp[i][j] = dp[i][j - 2] || (first_match && dp[i - 1][j]);\\n            }\\n            else {\\n                // Otherwise, try matching the first characters and then move on to the rest of the strings\\n                dp[i][j] = first_match && dp[i - 1][j - 1];\\n            }\\n        }\\n    }\\n\\n    // Return the result of matching the entire input string and pattern\\n    return dp[m][n];\\n}\\n```\\n\\nUpvote if it helped",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nif (p.empty()) return s.empty();\\n    bool first_match = !s.empty() && (s[0] == p[0] || p[0] == \\'.\\');\\n    if (p.size() >= 2 && p[1] == \\'*\\')     return isMatch(s, p.substr(2)) || (first_match && isMatch(s.substr(1), p));\\n    else  return first_match && isMatch(s.substr(1), p.substr(1)); \\n\\t\\n```\n```\\nbool isMatch(string s, string p) {\\n    // Initialize the 2D table for dynamic programming\\n    int m = s.size(), n = p.size();\\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\\n\\n    // Base case: both s and p are empty\\n    dp[0][0] = true;\\n\\n    // Fill the table for the empty input string\\n    for (int j = 2; j <= n; j++) {\\n        dp[0][j] = (p[j - 1] == \\'*\\') && dp[0][j - 2];\\n    }\\n\\n    // Fill the rest of the table\\n    for (int i = 1; i <= m; i++) {\\n        for (int j = 1; j <= n; j++) {\\n            // Check if the characters match or if the pattern character is \\'.\\'\\n            bool first_match = (s[i - 1] == p[j - 1] || p[j - 1] == \\'.\\');\\n            if (j >= 2 && p[j - 1] == \\'*\\') {\\n                // If the pattern character is \\'*\\', try matching zero or more characters\\n                dp[i][j] = dp[i][j - 2] || (first_match && dp[i - 1][j]);\\n            }\\n            else {\\n                // Otherwise, try matching the first characters and then move on to the rest of the strings\\n                dp[i][j] = first_match && dp[i - 1][j - 1];\\n            }\\n        }\\n    }\\n\\n    // Return the result of matching the entire input string and pattern\\n    return dp[m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2743721,
                "title": "simple-solutions-in-c",
                "content": "class Solution {\\npublic:\\n    bool isMatch(string str, string pat) {\\n\\n        int n = str.size();\\n        \\n        int m = pat.size();\\n\\n        // \\'.\\' can be any character\\n        \\n        // \"s*\" can be replace with \"\", \"s\", \"ss\", \"sss\", \"ssss\" and so on .....\\n        \\n        // above possibility can be replaced with \"\", \"ss*\"\\n\\n        // str in on i direction and pat is on j direction\\n\\n        // for the 0th row if we encounter \\'*\\' then we look for dp[0][j - 2]\\n\\n        vector<vector<bool>> dp(n + 1, vector<bool> (m + 1, false));\\n\\n        for(int i = 0; i <= n; i++)\\n        {\\n            for(int j = 0; j <= m ; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                {\\n                    dp[i][j] = true;\\n                }\\n                else if(j == 0)\\n                {\\n                    dp[i][j] = false;\\n                }\\n                else if(i == 0)\\n                {\\n                    if(pat[j - 1] == \\'*\\')\\n                    {\\n                        dp[i][j] = dp[i][j - 2];\\n                    }\\n                    else\\n                    {\\n                        dp[i][j] = false;\\n                    }\\n                }\\n                else\\n                {\\n                    if(str[i - 1] == pat[j - 1] || pat[j - 1] == \\'.\\')\\n                    {\\n                        dp[i][j] = dp[i - 1][j - 1];\\n                    }\\n                    else if(pat[j - 1] == \\'*\\')\\n                    {\\n                        // eg. replace \"mis*\" with \"mi\"\\n\\n                        dp[i][j] = dp[i][j - 2];\\n\\n                        // eg. replace \"mis*\" with \"miss*\"\\n\\n                        if(dp[i][j] == false && (str[i - 1] == pat[j - 2] || pat[j - 2] == \\'.\\'))\\n                        {\\n                            dp[i][j] = dp[i - 1][j];\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isMatch(string str, string pat) {\\n\\n        int n = str.size();\\n        \\n        int m = pat.size();\\n\\n        // \\'.\\' can be any character\\n        \\n        // \"s*\" can be replace with \"\", \"s\", \"ss\", \"sss\", \"ssss\" and so on .....\\n        \\n        // above possibility can be replaced with \"\", \"ss*\"\\n\\n        // str in on i direction and pat is on j direction\\n\\n        // for the 0th row if we encounter \\'*\\' then we look for dp[0][j - 2]\\n\\n        vector<vector<bool>> dp(n + 1, vector<bool> (m + 1, false));\\n\\n        for(int i = 0; i <= n; i++)\\n        {\\n            for(int j = 0; j <= m ; j++)\\n            {\\n                if(i == 0 && j == 0)\\n                {\\n                    dp[i][j] = true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2692988,
                "title": "problem-with-test-case",
                "content": "Can someone please help me to understand the below test case\\n```\\n\"mississippi\"\\n\"mis*is*p*.\"\\n\\n\"aab\"\\n\"c*a*b\"\\n```\\n\\nwhy it 1st one expected false and 2nd one expected true\\n",
                "solutionTags": [],
                "code": "```\\n\"mississippi\"\\n\"mis*is*p*.\"\\n\\n\"aab\"\\n\"c*a*b\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2689919,
                "title": "dp-recurison-solution",
                "content": "\\tclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        return helper(0,0,s,p,new Boolean[s.length()][p.length()]);\\n    }\\n    public boolean helper(int index1,int index2, String s, String p, Boolean[][] dp) {\\n        if(index1>=s.length()|| index2>= p.length()) {\\n            if(index1>=s.length()&& index2>= p.length())\\n                return true;\\n            else  if(index2+1<p.length() && p.charAt(index2+1)==\\'*\\')  {\\n            \\treturn helper(index1, index2+2, s, p, dp);\\n            }\\n            \\n                return false;\\n            \\n        }\\n        if(dp[index1][index2] != null)\\n            return dp[index1][index2];\\n        \\n        if(index2+1<p.length() && p.charAt(index2+1)==\\'*\\')\\n        {\\n        \\tif(p.charAt(index2) == \\'.\\')\\n            {\\n                return  dp[index1][index2] = helper(index1+1,index2,s,p,dp) || helper(index1,index2+2,s,p,dp);\\n            }\\n        \\telse {\\n        \\t\\tif(s.charAt(index1) == p.charAt(index2))    {\\n                   return dp[index1][index2] =helper(index1+1,index2,s,p,dp) || helper(index1,index2+2,s,p,dp); \\n                }\\n        \\t\\telse {\\n        \\t\\t\\treturn dp[index1][index2]=helper(index1,index2+2,s,p,dp);\\n        \\t\\t}\\n        \\t\\t\\t\\n        \\t}\\n        }\\n        else {\\n        \\t if(s.charAt(index1) == p.charAt(index2))  {\\n                return dp[index1][index2] =helper(index1+1,index2+1,s,p,dp); \\n             }\\n             else if(p.charAt(index2) == \\'.\\')  {\\n                 return  dp[index1][index2] = helper(index1+1,index2+1,s,p,dp);\\n             }\\n        }\\n        \\n        return false;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public boolean isMatch(String s, String p) {\\n        return helper(0,0,s,p,new Boolean[s.length()][p.length()]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2508564,
                "title": "python-elegant-short-top-down-dp-lru-cache",
                "content": "\\tdef isMatch(self, string: str, pattern: str) -> bool:\\n        is_empty = lambda i: i < 0\\n\\n        @lru_cache(None)\\n        def dp(p: int, s: int) -> bool:\\n            if is_empty(p) and is_empty(s):\\n                return True\\n\\n            if is_empty(p) or (is_empty(s) and pattern[p] != \\'*\\'):\\n                return False\\n\\n            if pattern[p] == \\'.\\' or pattern[p] == string[s]:\\n                return dp(p - 1, s - 1)\\n\\n            if pattern[p] == \\'*\\':\\n                prev = pattern[p - 1]\\n\\n                if not is_empty(s) and (string[s] == prev or prev == \\'.\\'):\\n                    return dp(p - 1, s) or dp(p, s - 1) or dp(p - 2, s)\\n\\n                return dp(p - 2, s)\\n\\n            return False\\n\\n        return dp(len(pattern) - 1, len(string) - 1)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\tdef isMatch(self, string: str, pattern: str) -> bool:\\n        is_empty = lambda i: i < 0\\n\\n        @lru_cache(None)\\n        def dp(p: int, s: int) -> bool:\\n            if is_empty(p) and is_empty(s):\\n                return True\\n\\n            if is_empty(p) or (is_empty(s) and pattern[p] != \\'*\\'):\\n                return False\\n\\n            if pattern[p] == \\'.\\' or pattern[p] == string[s]:\\n                return dp(p - 1, s - 1)\\n\\n            if pattern[p] == \\'*\\':\\n                prev = pattern[p - 1]\\n\\n                if not is_empty(s) and (string[s] == prev or prev == \\'.\\'):\\n                    return dp(p - 1, s) or dp(p, s - 1) or dp(p - 2, s)\\n\\n                return dp(p - 2, s)\\n\\n            return False\\n\\n        return dp(len(pattern) - 1, len(string) - 1)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2421442,
                "title": "python-c-beginner-level-solution-beats-95-44-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q10. Regular Expression Matching***\\n\\nGiven an input string s and a pattern p, implement regular expression matching with support for \\'.\\' and \\'*\\' where:\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\nThe matching should cover the **entire** input string (not partial)\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n\\n***Approach 1:***\\n\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        try:\\n            return s==re.findall(p,s)[0]\\n        except:\\n            return False\\n```\\n**Runtime:**  116ms\\n**Memory Usage:**  13.1 MB\\n\\n***Approach 2:***\\n```\\nclass Solution(object):\\n    def isMatch(self, text, pattern):\\n        if not pattern:\\n            return not text\\n\\n        first_match = bool(text) and pattern[0] in {text[0], \\'.\\'}\\n\\n        if len(pattern) >= 2 and pattern[1] == \\'*\\':\\n            return (self.isMatch(text, pattern[2:]) or\\n                    first_match and self.isMatch(text[1:], pattern))\\n        else:\\n            return first_match and self.isMatch(text[1:], pattern[1:])\\n```\\n**Runtime:**  2227ms\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n\\n**Runtime** beats 95.44% of C++ online submissions for Palindrome Number.\\n```\\nclass Solution {\\npublic:\\n    bool f(int i,int j,string &s,string &p)\\n    { \\n        if(i<0 && j<0) return true;   \\n        if(j<0 && i>=0) return false;  \\n        if(i<0 && j>=0)  \\n        {\\n            while(j>=0)\\n            {\\n                if(p[j]==\\'*\\') \\n                    j-=2;\\n                else \\n                    return false;\\n            }\\n            return true;\\n        }\\n        \\n        if(p[j]==s[i] || p[j]==\\'.\\') return f(i-1,j-1,s,p);\\n        \\n        if(p[j]==\\'*\\')\\n        {\\n            if(p[j-1]!=s[i] && p[j-1]!=\\'.\\')\\n                return f(i,j-2,s,p);  \\n            else\\n                return f(i,j-2,s,p) || f(i-1,j,s,p); \\n        }\\n        return false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        return f(n-1,m-1,s,p);\\n    }\\n};\\n```\\n**Runtime:**  3ms\\n**Memory Usage:**  6.1 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        try:\\n            return s==re.findall(p,s)[0]\\n        except:\\n            return False\\n```\n```\\nclass Solution(object):\\n    def isMatch(self, text, pattern):\\n        if not pattern:\\n            return not text\\n\\n        first_match = bool(text) and pattern[0] in {text[0], \\'.\\'}\\n\\n        if len(pattern) >= 2 and pattern[1] == \\'*\\':\\n            return (self.isMatch(text, pattern[2:]) or\\n                    first_match and self.isMatch(text[1:], pattern))\\n        else:\\n            return first_match and self.isMatch(text[1:], pattern[1:])\\n```\n```\\nclass Solution {\\npublic:\\n    bool f(int i,int j,string &s,string &p)\\n    { \\n        if(i<0 && j<0) return true;   \\n        if(j<0 && i>=0) return false;  \\n        if(i<0 && j>=0)  \\n        {\\n            while(j>=0)\\n            {\\n                if(p[j]==\\'*\\') \\n                    j-=2;\\n                else \\n                    return false;\\n            }\\n            return true;\\n        }\\n        \\n        if(p[j]==s[i] || p[j]==\\'.\\') return f(i-1,j-1,s,p);\\n        \\n        if(p[j]==\\'*\\')\\n        {\\n            if(p[j-1]!=s[i] && p[j-1]!=\\'.\\')\\n                return f(i,j-2,s,p);  \\n            else\\n                return f(i,j-2,s,p) || f(i-1,j,s,p); \\n        }\\n        return false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        return f(n-1,m-1,s,p);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2392873,
                "title": "java-single-line-solution-but-65ms-runtime",
                "content": "\\n\\n    class Solution {\\n    public boolean isMatch(String s, String p) {\\n\\t\\n\\treturn s.matches(p);\\n    \\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isMatch(String s, String p) {\\n\\t\\n\\treturn s.matches(p);\\n    \\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2378347,
                "title": "one-line-in-javascript",
                "content": "```\\nvar isMatch = function(s, p) {\\n    return eval(\"/^\"+ p + \"$/\").test(s)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isMatch = function(s, p) {\\n    return eval(\"/^\"+ p + \"$/\").test(s)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2349867,
                "title": "c-solution-using-dp-recursively",
                "content": "\\tbool solve(string &s,string &p,int i,int j, vector<vector<int>>&dp){\\n \\n\\t\\t// base case\\n\\t\\tif(s.size()<=i and p.size()<=j){\\n        return true;\\n\\t\\t}\\n\\t\\tif(p.size()<=j){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n        \\n        // if in dp it\\'s present then return it\\n        int &ans = dp[i][j];\\n        if(ans!=-1){\\n            return ans;\\n        }\\n        \\n        // check char at i and j are match or not\\n        bool match = false;\\n        if(i<s.size() and (s[i]==p[j] || p[j]==\\'.\\')){\\n            match = true;\\n        }\\n        \\n        \\n        // if next of j is \\'*\\' then we have two choice skip * if not match is false or if match is true then increment the \\'i\\' and \\'j\\' remain same\\n        if(j<p.size()-1 and p[j+1] == \\'*\\'){\\n            return ans = solve(s,p,i,j+2,dp) || (match and solve(s,p,i+1,j,dp));\\n        }\\n        \\n        // if match\\n        if(match){\\n            return ans = solve(s,p,i+1,j+1,dp);\\n        }\\n        // retunr fasle if not match no * present\\n        return ans = false;    \\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        vector<vector<int>>dp(s.size() + 1,vector<int>(p.size() + 1,-1));\\n        return solve(s,p,0,0,dp);\\n    }\\n\\t\\n### upvote to motivate me HAPPY CODING :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "\\tbool solve(string &s,string &p,int i,int j, vector<vector<int>>&dp){\\n \\n\\t\\t// base case\\n\\t\\tif(s.size()<=i and p.size()<=j){\\n        return true;\\n\\t\\t}\\n\\t\\tif(p.size()<=j){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n        \\n        // if in dp it\\'s present then return it\\n        int &ans = dp[i][j];\\n        if(ans!=-1){\\n            return ans;\\n        }\\n        \\n        // check char at i and j are match or not\\n        bool match = false;\\n        if(i<s.size() and (s[i]==p[j] || p[j]==\\'.\\')){\\n            match = true;\\n        }\\n        \\n        \\n        // if next of j is \\'*\\' then we have two choice skip * if not match is false or if match is true then increment the \\'i\\' and \\'j\\' remain same\\n        if(j<p.size()-1 and p[j+1] == \\'*\\'){\\n            return ans = solve(s,p,i,j+2,dp) || (match and solve(s,p,i+1,j,dp));\\n        }\\n        \\n        // if match\\n        if(match){\\n            return ans = solve(s,p,i+1,j+1,dp);\\n        }\\n        // retunr fasle if not match no * present\\n        return ans = false;    \\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        vector<vector<int>>dp(s.size() + 1,vector<int>(p.size() + 1,-1));\\n        return solve(s,p,0,0,dp);\\n    }\\n\\t\\n### upvote to motivate me HAPPY CODING :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2320645,
                "title": "can-someone-please-explain-this-testcase",
                "content": "```\\n1. Input: \\n\\ts = \"aab\"\\n\\tp = \"c*a*b\"\\n\\nThe expected output by leetcode solution is True for this test case.\\n\\n2. Input:\\n\\ts = \"abcdeadabzcfgcdhh\"\\n\\tp = \"ab*ab.*cd..\"\\n\\nThe expected output by leetcode solution is False for this test case.\\n```\\n\\nCan someone please explain me what should be right solution for the above two test cases?\\n\\n",
                "solutionTags": [],
                "code": "```\\n1. Input: \\n\\ts = \"aab\"\\n\\tp = \"c*a*b\"\\n\\nThe expected output by leetcode solution is True for this test case.\\n\\n2. Input:\\n\\ts = \"abcdeadabzcfgcdhh\"\\n\\tp = \"ab*ab.*cd..\"\\n\\nThe expected output by leetcode solution is False for this test case.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2267218,
                "title": "1-line-python-solution",
                "content": "```\\nimport re\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        return re.search(\"^\" + p + \"$\", s)!=None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport re\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        return re.search(\"^\" + p + \"$\", s)!=None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2059134,
                "title": "100-passed-java-recursicve-memoization-o-n-m-time-complexity-easy-understandable",
                "content": "for . you can simply check s.charAt(i)==p.charAt(j)\\nfor * you have to simply do if(s.charAt(i)==p.charAt(j)) and j+1<m && p.charAt(j+1)==\\'*\\'\\nthen u have two option one is to  move i+1,j that is move the pointer of s to +1 position and let the pointer of p be there it means u consider that character and * or else dont consider the character and * and take the or of the two\\n\\n\\n```\\nclass Solution \\n{\\n    public static int Matching(String s,String p,int i,int j,int n,int m,int dp[][])\\n    {\\n       if(i==n && j==m)\\n       {\\n           return 1;\\n       }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int flag=0;\\n        if(j+1<m && p.charAt(j+1)==\\'*\\')\\n        {\\n             if(i<n && (s.charAt(i)==p.charAt(j) ||  (p.charAt(j)==\\'.\\')))\\n             {\\n                 flag=Matching(s,p,i+1,j,n,m,dp);\\n             }\\n               flag|=Matching(s,p,i,j+2,n,m,dp);\\n        }\\n        else\\n        if(j<m && i<n && (p.charAt(j)==s.charAt(i)||(p.charAt(j)==\\'.\\')))\\n            {\\n                flag=Matching(s,p,i+1,j+1,n,m,dp);\\n            }\\n        \\n        return dp[i][j]=flag;\\n    }\\n      \\n    \\n     \\n     \\n    public boolean isMatch(String s, String p)\\n    {\\n        int dp[][]=new int[s.length()+1][p.length()+1];\\n        for(int i=0;i<=s.length();i++)\\n        {\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return Matching(s,p,0,0,s.length(),p.length(),dp)==1?true:false;\\n        \\n    }\\n}\\n```\\n\\n\\n**PLS UPVOTE MY SOLUTION**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\n    public static int Matching(String s,String p,int i,int j,int n,int m,int dp[][])\\n    {\\n       if(i==n && j==m)\\n       {\\n           return 1;\\n       }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n        int flag=0;\\n        if(j+1<m && p.charAt(j+1)==\\'*\\')\\n        {\\n             if(i<n && (s.charAt(i)==p.charAt(j) ||  (p.charAt(j)==\\'.\\')))\\n             {\\n                 flag=Matching(s,p,i+1,j,n,m,dp);\\n             }\\n               flag|=Matching(s,p,i,j+2,n,m,dp);\\n        }\\n        else\\n        if(j<m && i<n && (p.charAt(j)==s.charAt(i)||(p.charAt(j)==\\'.\\')))\\n            {\\n                flag=Matching(s,p,i+1,j+1,n,m,dp);\\n            }\\n        \\n        return dp[i][j]=flag;\\n    }\\n      \\n    \\n     \\n     \\n    public boolean isMatch(String s, String p)\\n    {\\n        int dp[][]=new int[s.length()+1][p.length()+1];\\n        for(int i=0;i<=s.length();i++)\\n        {\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return Matching(s,p,0,0,s.length(),p.length(),dp)==1?true:false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057899,
                "title": "greatly-explained-two-methods-dfs-memo-dp-in-python-very-easy-to-understand",
                "content": "**Very classical question** that could be solved using **DFS + Memo** & **DP**!\\n\\nVery similar to **\"Q44: Wildcard Matching\"**, solutions are also **very similar**!!!\\n\\n**Reference:**\\nhttps://leetcode.com/problems/wildcard-matching/\\nhttps://leetcode.com/problems/wildcard-matching/discuss/1992492/Two-Methods-in-Python-DFS-%2B-Memo-and-DP-Explained-in-Details!\\n\\n**Method 1:**\\n**DFS + Memoization**\\n\\nWhenever will come across a * , we will generate two paths, either **not match any** or **match**.\\n\\nWe will use index of the string as the signature of each state. Every state reached will be stored in the memo hash.\\n\\n**Time:** O(m * n), m is the length of string s, n is the length of string p\\n**Space:** O(m * n)\\n\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        memo = {}\\n        s_index, p_index = 0, 0\\n        return self.memo_dfs(s, s_index, p, p_index, memo)\\n    \\n    def memo_dfs(self, s, i, p, j, memo):\\n        \\n        if j == len(p):\\n            return i == len(s)\\n        \\n        if i == len(s):\\n            return self.could_be_empty(p[j:])\\n        \\n        if (i, j) in memo:\\n            return memo[(i, j)]\\n        \\n        if j + 1 < len(p) and  p[j + 1] == \\'*\\': # matched & not matched\\n            matched = ((s[i] == p[j] or p[j] == \\'.\\') and self.memo_dfs(s, i + 1, p, j, memo)) or self.memo_dfs(s, i, p, j + 2, memo)\\n        else:\\n            matched = (s[i] == p[j] or p[j] == \\'.\\') and self.memo_dfs(s, i + 1, p, j + 1, memo)\\n        \\n        memo[(i, j)] = matched\\n        \\n        return matched\\n    \\n    def could_be_empty(self, l):\\n        if len(l) % 2 == 1:\\n            return False\\n        i = 0\\n        while i < len(l) // 2:\\n            if l[2 * i + 1] != \\'*\\':\\n                return False\\n            i += 1\\n        return True\\n```\\n\\n**Method 2:**\\n**DP**\\n\\nThe idea is very similar, **dp[i][j]** means that by index i of s and by index j of p, whether there is a matching.\\n\\n**Time:** O(m * n), m is the length of string s, n is the length of string p\\n**Space:** O(m * n)\\n\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if s is None or p is None:\\n            return False\\n\\n        m, n = len(s), len(p)\\n        \\n        dp = [[False] * (n + 1) for _ in range(2)]\\n        \\n        dp[0][0] = True\\n        if n >= 1 and p[0] == \\'*\\':\\n            dp[0][1] = True\\n        for j in range(2, n + 1):       \\n            dp[0][j] = dp[0][j - 2] and p[j - 1] == \\'*\\'\\n        \\n        for i in range(1, m + 1):\\n            dp[i % 2][0] = False # Note that: we might miss this!\\n            for j in range(1, n + 1):\\n                if p[j - 1] == \\'*\\':\\n                    if j == 1:\\n                        dp[i % 2][j] = False\\n                    else: # not match & match\\n                        dp[i % 2][j] = dp[i % 2][j - 2] or dp[i % 2 - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \\'.\\')\\n                else:\\n                    dp[i % 2][j] = dp[i % 2 - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == \\'.\\')\\n        \\n        return dp[m % 2][n]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        memo = {}\\n        s_index, p_index = 0, 0\\n        return self.memo_dfs(s, s_index, p, p_index, memo)\\n    \\n    def memo_dfs(self, s, i, p, j, memo):\\n        \\n        if j == len(p):\\n            return i == len(s)\\n        \\n        if i == len(s):\\n            return self.could_be_empty(p[j:])\\n        \\n        if (i, j) in memo:\\n            return memo[(i, j)]\\n        \\n        if j + 1 < len(p) and  p[j + 1] == \\'*\\': # matched & not matched\\n            matched = ((s[i] == p[j] or p[j] == \\'.\\') and self.memo_dfs(s, i + 1, p, j, memo)) or self.memo_dfs(s, i, p, j + 2, memo)\\n        else:\\n            matched = (s[i] == p[j] or p[j] == \\'.\\') and self.memo_dfs(s, i + 1, p, j + 1, memo)\\n        \\n        memo[(i, j)] = matched\\n        \\n        return matched\\n    \\n    def could_be_empty(self, l):\\n        if len(l) % 2 == 1:\\n            return False\\n        i = 0\\n        while i < len(l) // 2:\\n            if l[2 * i + 1] != \\'*\\':\\n                return False\\n            i += 1\\n        return True\\n```\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if s is None or p is None:\\n            return False\\n\\n        m, n = len(s), len(p)\\n        \\n        dp = [[False] * (n + 1) for _ in range(2)]\\n        \\n        dp[0][0] = True\\n        if n >= 1 and p[0] == \\'*\\':\\n            dp[0][1] = True\\n        for j in range(2, n + 1):       \\n            dp[0][j] = dp[0][j - 2] and p[j - 1] == \\'*\\'\\n        \\n        for i in range(1, m + 1):\\n            dp[i % 2][0] = False # Note that: we might miss this!\\n            for j in range(1, n + 1):\\n                if p[j - 1] == \\'*\\':\\n                    if j == 1:\\n                        dp[i % 2][j] = False\\n                    else: # not match & match\\n                        dp[i % 2][j] = dp[i % 2][j - 2] or dp[i % 2 - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \\'.\\')\\n                else:\\n                    dp[i % 2][j] = dp[i % 2 - 1][j - 1] and (s[i - 1] == p[j - 1] or p[j - 1] == \\'.\\')\\n        \\n        return dp[m % 2][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1896681,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        var string = Array(s)\\n        var chars: [Character] = []\\n        var marks: [Bool] = []\\n        var isMark: Bool = false\\n        var list = [[-1, -1, 1]] // [start, end, is need to add next start]\\n        var max = Int.min\\n\\n\\n        func nextRange(_ list: [[Int]], _ char: Character, _ mark: Bool) -> [[Int]] {\\n            var res = Set<[Int]>()\\n\\n            for range in list {\\n                let lower = range[0] + range[2]\\n                let upper = range[1] + 1\\n                for i in lower...upper {\\n                    if mark {\\n                        var j = i\\n                        var count = 0\\n                        while j < string.count {\\n                            if char == string[j] || char == \".\" {\\n                                j += 1\\n                                count += 1\\n                            } else { break }\\n                        }\\n                        j = i + (count > 0 ? count - 1 : 0) \\n                        if count > 0 {\\n                            res.insert([i, j, 0])\\n                        } else {\\n                            res.insert(range)\\n                        }\\n                    } else {\\n                        if i < string.count && (char == string[i] || char == \".\") { res.insert([i, i, 1]) }\\n                    }\\n                }\\n            }\\n            return Array(res)\\n        }\\n\\n        for (_, c) in p.enumerated().reversed() {\\n            if c == \"*\" {\\n                isMark = true\\n            } else {\\n                chars.insert(c, at: 0)\\n                marks.insert(isMark, at: 0)\\n                isMark = false\\n            }\\n        }\\n\\n        for (index, c) in chars.enumerated() {\\n            let mark = marks[index]\\n            list = nextRange(list, c, mark)\\n        }\\n        for rang in list { max = max > rang[1] ? max : rang[1] }\\n        return max == string.count - 1\\n    }\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        var string = Array(s)\\n        var chars: [Character] = []\\n        var marks: [Bool] = []\\n        var isMark: Bool = false\\n        var list = [[-1, -1, 1]] // [start, end, is need to add next start]\\n        var max = Int.min\\n\\n\\n        func nextRange(_ list: [[Int]], _ char: Character, _ mark: Bool) -> [[Int]] {\\n            var res = Set<[Int]>()\\n\\n            for range in list {\\n                let lower = range[0] + range[2]\\n                let upper = range[1] + 1\\n                for i in lower...upper {\\n                    if mark {\\n                        var j = i\\n                        var count = 0\\n                        while j < string.count {\\n                            if char == string[j] || char == \".\" {\\n                                j += 1\\n                                count += 1\\n                            } else { break }\\n                        }\\n                        j = i + (count > 0 ? count - 1 : 0) \\n                        if count > 0 {\\n                            res.insert([i, j, 0])\\n                        } else {\\n                            res.insert(range)\\n                        }\\n                    } else {\\n                        if i < string.count && (char == string[i] || char == \".\") { res.insert([i, i, 1]) }\\n                    }\\n                }\\n            }\\n            return Array(res)\\n        }\\n\\n        for (_, c) in p.enumerated().reversed() {\\n            if c == \"*\" {\\n                isMark = true\\n            } else {\\n                chars.insert(c, at: 0)\\n                marks.insert(isMark, at: 0)\\n                isMark = false\\n            }\\n        }\\n\\n        for (index, c) in chars.enumerated() {\\n            let mark = marks[index]\\n            list = nextRange(list, c, mark)\\n        }\\n        for rang in list { max = max > rang[1] ? max : rang[1] }\\n        return max == string.count - 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788981,
                "title": "python-solution-dp-top-down-memoization-o-n-m-suitable-comments",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        len_s = len(s)\\n        len_p = len(p)\\n\\n        cache = {}  # Memoization\\n\\n        def dfs(i, j):\\n            \\'\\'\\' i :- index for string {s}  // string\\n                j :- index for string {p}  // pattern\\n            \\'\\'\\'\\n            if (i, j) in cache: return cache[(i,j)]\\n\\n            s_exhaust = i == len_s\\n            p_exhaust = j == len_p\\n            if s_exhaust and p_exhaust:  # Both String & Pattern Consume entirely matching each character at resp positions\\n                return True \\n\\n            if p_exhaust:\\n                return False  # as some pattern is missing\\n\\n            # check if char at {i} in {s} is same as {j} in {p}\\n            match = (not s_exhaust) and (p[j] in (s[i], \\'.\\')) \\n\\n            res = False   # res for (i,j)\\n\\n            # check for neighbor `*`\\n            if (j+1 < len_p) and p[j+1] == \\'*\\':\\n                res = (dfs(i, j+2)  or     # 1. don\\'t use (ie ignore) \\'*\\'\\n                        (match and dfs(i+1, j)))  # 2. use \\'*\\' only if current character matches\\n            elif match:\\n                res = dfs(i+1, j+1)\\n\\n            cache[(i,j)] = res        \\n            return res\\n\\n        return dfs(0, 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        len_s = len(s)\\n        len_p = len(p)\\n\\n        cache = {}  # Memoization\\n\\n        def dfs(i, j):\\n            \\'\\'\\' i :- index for string {s}  // string\\n                j :- index for string {p}  // pattern\\n            \\'\\'\\'\\n            if (i, j) in cache: return cache[(i,j)]\\n\\n            s_exhaust = i == len_s\\n            p_exhaust = j == len_p\\n            if s_exhaust and p_exhaust:  # Both String & Pattern Consume entirely matching each character at resp positions\\n                return True \\n\\n            if p_exhaust:\\n                return False  # as some pattern is missing\\n\\n            # check if char at {i} in {s} is same as {j} in {p}\\n            match = (not s_exhaust) and (p[j] in (s[i], \\'.\\')) \\n\\n            res = False   # res for (i,j)\\n\\n            # check for neighbor `*`\\n            if (j+1 < len_p) and p[j+1] == \\'*\\':\\n                res = (dfs(i, j+2)  or     # 1. don\\'t use (ie ignore) \\'*\\'\\n                        (match and dfs(i+1, j)))  # 2. use \\'*\\' only if current character matches\\n            elif match:\\n                res = dfs(i+1, j+1)\\n\\n            cache[(i,j)] = res        \\n            return res\\n\\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673390,
                "title": "simple-intuitive-c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        \\n        if(p.size() == 0)\\n            return s.size() == 0;\\n        \\n        if(p.size() > 1 && p[1] == \\'*\\')\\n        {\\n            if(isMatch(s,p.substr(2)))\\n                return true;\\n            \\n            if((s[0] == p[0] || p[0] == \\'.\\') && s.size() > 0)\\n                return isMatch(s.substr(1),p);\\n            \\n            return false;\\n        }\\n        else\\n        {\\n            if((s[0] == p[0] || p[0] == \\'.\\') && s.size() > 0)\\n                return isMatch(s.substr(1), p.substr(1));\\n            \\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        \\n        if(p.size() == 0)\\n            return s.size() == 0;\\n        \\n        if(p.size() > 1 && p[1] == \\'*\\')\\n        {\\n            if(isMatch(s,p.substr(2)))\\n                return true;\\n            \\n            if((s[0] == p[0] || p[0] == \\'.\\') && s.size() > 0)\\n                return isMatch(s.substr(1),p);\\n            \\n            return false;\\n        }\\n        else\\n        {\\n            if((s[0] == p[0] || p[0] == \\'.\\') && s.size() > 0)\\n                return isMatch(s.substr(1), p.substr(1));\\n            \\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606218,
                "title": "memoization-0-ms-commented-c",
                "content": "```\\nbool dfs(string &s, string &p, int i, int j,vector<vector<int>>& dp){\\n        \\n        if(i>=s.size() and j>=p.size()) return true; //if both s and p get read at the same time. Return true. We have a match.\\n        if(j>=p.size()) return false; //if s string hasnt been read fully but p string has been traveresed entirely, return false\\n        \\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        //declaring a variable to check whether the first characters of s and p are a match or not\\n        bool match = i<s.size() and (s[i] == p[j] or p[j] == \\'.\\');  //a dot is a match too\\n        \\n        //checking for second character\\n        if((j+1)<p.size() and p[j+1] == \\'*\\'){\\n            bool dontTake = dfs(s,p,i,j+2,dp); //we do a j+2 because we want to get the next character and not land on the star itself\\n            bool take = match ? dfs(s,p,i+1,j,dp) : false; //we take only if the first characters are a match\\n            return dp[i][j] = take or dontTake;\\n        }\\n        \\n        if(match) return dp[i][j] = dfs(s,p,i+1,j+1,dp); //simple comparison without any star or dot\\n        \\n        return dp[i][j] = false;\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.size()+1,vector<int>(p.size()+1,-1));\\n        return dfs(s,p,0,0,dp);\\n    }\\n```",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nbool dfs(string &s, string &p, int i, int j,vector<vector<int>>& dp){\\n        \\n        if(i>=s.size() and j>=p.size()) return true; //if both s and p get read at the same time. Return true. We have a match.\\n        if(j>=p.size()) return false; //if s string hasnt been read fully but p string has been traveresed entirely, return false\\n        \\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        //declaring a variable to check whether the first characters of s and p are a match or not\\n        bool match = i<s.size() and (s[i] == p[j] or p[j] == \\'.\\');  //a dot is a match too\\n        \\n        //checking for second character\\n        if((j+1)<p.size() and p[j+1] == \\'*\\'){\\n            bool dontTake = dfs(s,p,i,j+2,dp); //we do a j+2 because we want to get the next character and not land on the star itself\\n            bool take = match ? dfs(s,p,i+1,j,dp) : false; //we take only if the first characters are a match\\n            return dp[i][j] = take or dontTake;\\n        }\\n        \\n        if(match) return dp[i][j] = dfs(s,p,i+1,j+1,dp); //simple comparison without any star or dot\\n        \\n        return dp[i][j] = false;\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.size()+1,vector<int>(p.size()+1,-1));\\n        return dfs(s,p,0,0,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1367125,
                "title": "c-easy-recursive-solution-with-simple-explanations",
                "content": "```\\n        public bool IsMatch(string s, string p)\\n        {\\n            return IsMatch(s, 0, p, 0);\\n        }\\n\\n        private bool IsMatch(string s, int si, string p, int pi)\\n        {\\n            // base case\\n            //// 1. success if full match\\n            if (pi >= p.Length && si >= s.Length)\\n            {\\n                return true;\\n            }\\n\\n            //// 2. running out of pattern but still has strings means failure\\n            if (pi >= p.Length && si < s.Length)\\n            {\\n                return false;\\n            }\\n\\n\\n            // case A\\n            // running out of strings but still has patterns\\n            if (pi < p.Length && si >= s.Length)\\n            {\\n                // only possible case is to match a STAR pattern\\n                return pi < p.Length - 1 && p[pi + 1] == \\'*\\'\\n                                         && IsMatch(s, si, p, pi + 2);\\n            }\\n\\n            // case B\\n            var thisMatch = p[pi] == \\'.\\' || s[si] == p[pi];\\n\\n            //// 1. want to match STAR pattern\\n            if (pi < p.Length - 1 && p[pi + 1] == \\'*\\')\\n            {\\n                if (!thisMatch)\\n                {\\n                    // the STAR has to go\\n                    return IsMatch(s, si, p, pi + 2);\\n                }\\n                else\\n                {\\n                    ////// (a) choose to consume and remove STAR\\n                    ////// (b) choose to consume and keep the STAR\\n                    ////// (c) choose to ignore the STAR\\n                    ////// any success is success\\n                    return IsMatch(s, si + 1, p, pi + 2) ||\\n                           IsMatch(s, si + 1, p, pi) ||\\n                           IsMatch(s, si, p, pi + 2);\\n                }\\n            }\\n\\n            //// 2. just match a single char\\n            return thisMatch && IsMatch(s, si + 1, p, pi + 1);\\n        }\\n```\\n\\nUse a two dimensional array to cache `[si, pi]` and get good performance. This will result in performance better than 86.17% C# submissions. Details avoided for clarity.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n        public bool IsMatch(string s, string p)\\n        {\\n            return IsMatch(s, 0, p, 0);\\n        }\\n\\n        private bool IsMatch(string s, int si, string p, int pi)\\n        {\\n            // base case\\n            //// 1. success if full match\\n            if (pi >= p.Length && si >= s.Length)\\n            {\\n                return true;\\n            }\\n\\n            //// 2. running out of pattern but still has strings means failure\\n            if (pi >= p.Length && si < s.Length)\\n            {\\n                return false;\\n            }\\n\\n\\n            // case A\\n            // running out of strings but still has patterns\\n            if (pi < p.Length && si >= s.Length)\\n            {\\n                // only possible case is to match a STAR pattern\\n                return pi < p.Length - 1 && p[pi + 1] == \\'*\\'\\n                                         && IsMatch(s, si, p, pi + 2);\\n            }\\n\\n            // case B\\n            var thisMatch = p[pi] == \\'.\\' || s[si] == p[pi];\\n\\n            //// 1. want to match STAR pattern\\n            if (pi < p.Length - 1 && p[pi + 1] == \\'*\\')\\n            {\\n                if (!thisMatch)\\n                {\\n                    // the STAR has to go\\n                    return IsMatch(s, si, p, pi + 2);\\n                }\\n                else\\n                {\\n                    ////// (a) choose to consume and remove STAR\\n                    ////// (b) choose to consume and keep the STAR\\n                    ////// (c) choose to ignore the STAR\\n                    ////// any success is success\\n                    return IsMatch(s, si + 1, p, pi + 2) ||\\n                           IsMatch(s, si + 1, p, pi) ||\\n                           IsMatch(s, si, p, pi + 2);\\n                }\\n            }\\n\\n            //// 2. just match a single char\\n            return thisMatch && IsMatch(s, si + 1, p, pi + 1);\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1026895,
                "title": "can-any-one-tell-me-how-the-ans-for-this-is-true-ab",
                "content": "```\\nCan any one tell me how the ans for this is true?\\n\\n\"ab\"\\n\".*\"\\n```",
                "solutionTags": [],
                "code": "```\\nCan any one tell me how the ans for this is true?\\n\\n\"ab\"\\n\".*\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 858689,
                "title": "c-recursion-solution",
                "content": "```c\\nbool isMatch(char * s, char * p){\\n    if (!*p) return !*s;\\n    if (*(p + 1) == \\'*\\') {\\n        do {\\n            if (isMatch(s, p + 2)) return true;\\n        } while (*s && (*s++ == *p || *p == \\'.\\'));\\n    }\\n    if (*s && (*p == \\'.\\' || *p == *s)) return isMatch(s + 1, p + 1);\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```c\\nbool isMatch(char * s, char * p){\\n    if (!*p) return !*s;\\n    if (*(p + 1) == \\'*\\') {\\n        do {\\n            if (isMatch(s, p + 2)) return true;\\n        } while (*s && (*s++ == *p || *p == \\'.\\'));\\n    }\\n    if (*s && (*p == \\'.\\' || *p == *s)) return isMatch(s + 1, p + 1);\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 833185,
                "title": "python-dp-with-explanations",
                "content": "**Explanations**: \\n`dp[i][j]` = is `s[:i]` and `p[:j]` matched or not\\nTherefore, for `dp[0][0]`, it means \"is `s[:0]`(`\"\"`) and `p[:0]`(`\"\"`) matched\", and it should be true.\\nThere are some points that should be noted for `*`:\\n1. Multiple `*`(`****`) is the same as single `*`\\n2. if current p character is `*`, we can use zero or more of the preceding element. \\n\\t* \\tIf we use zero of the preceding element, the result of `dp[i][j]` will be whether we ignore the preceding element, it will still match (`dp[i][j] = dp[i][j - 2]`). \\n\\t* \\tIf we use the preceding element, we first have to check whether the preceding element of p match our current element of s (`p[j - 2] == s[i - 1] or p[j - 2] == \\'.\\'`). If so, we know that we can resue the preceding element. Hence we can succeed the previous result (`dp[i][j] |= dp[i - 1][j]`). \\n\\t* \\tWhy`dp[i - 1][j]`? we need to check whether `*` can still reuse the preceding element to make current state to be true. For example, `s = \"aba\"` and `p = \"a*\"`, `s[-1] == p[-2]`, but since the second char of `s` is `\"b\"`, we know `s[-1]` can\\'t use `*` to make `s[:]` match `p[:]`\\n\\n**Complexity**: Time: O(MN), M is `len(s)` and N is `len(p)`. Space O(MN)\\n\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        dp = [[False for _ in range(len(p) + 1)] for _ in range(len(s) + 1)]\\n        dp[0][0] = True\\n        for j in range(1, len(p) + 1):\\n            if j > 1 and p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 2]\\n        for i in range(1, len(s) + 1):\\n            for j in range(1, len(p) + 1):\\n                if p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 2]\\n                    if j > 1 and (p[j - 2] == s[i - 1] or p[j - 2] == \\'.\\'):\\n                        dp[i][j] |= dp[i - 1][j]\\n                else:\\n                    dp[i][j] = dp[i - 1][j - 1] and (p[j - 1] == s[i - 1] or p[j - 1] == \\'.\\')\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        dp = [[False for _ in range(len(p) + 1)] for _ in range(len(s) + 1)]\\n        dp[0][0] = True\\n        for j in range(1, len(p) + 1):\\n            if j > 1 and p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 2]\\n        for i in range(1, len(s) + 1):\\n            for j in range(1, len(p) + 1):\\n                if p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 2]\\n                    if j > 1 and (p[j - 2] == s[i - 1] or p[j - 2] == \\'.\\'):\\n                        dp[i][j] |= dp[i - 1][j]\\n                else:\\n                    dp[i][j] = dp[i - 1][j - 1] and (p[j - 1] == s[i - 1] or p[j - 1] == \\'.\\')\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774697,
                "title": "swift-recursion-and-dp",
                "content": "# Recursion\\n```\\nfunc isMatch(_ s: String, _ p: String) -> Bool {\\n\\tlet sArray = Array(s)\\n\\tlet pArray = Array(p)\\n\\treturn isMatch(sArray, 0, pArray, 0)\\n}\\n\\nfunc isMatch(_ s: [Character], _ i: Int, _ p: [Character], _ j: Int) -> Bool {\\n\\tif j == p.count { return i == s.count }\\n\\n\\tlet isCurrentMatching = i != s.count && (s[i] == p[j] || p[j] == \".\")\\n\\tif j < p.count - 1 && p[j + 1] == \"*\" {\\n\\t\\treturn (isCurrentMatching && isMatch(s, i + 1, p, j)) ||\\n\\t\\t\\t\\tisMatch(s, i, p, j + 2)\\n\\t} else {\\n\\t\\treturn isCurrentMatching && isMatch(s, i + 1, p, j + 1)\\n\\t}\\n}\\n```\\n\\n# Dynamic Programming solution\\n```\\nfunc isMatch(_ s: String, _ p: String) -> Bool {\\n\\tvar dp = Array(repeating: Array(repeating: false, count: p.count + 1), count: s.count + 1)\\n\\tdp[0][0] = true\\n\\tvar prevPattern: Character = \"a\"\\n\\n\\tfor (j, pattern) in p.enumerated() {\\n\\t\\tif pattern == \"*\" { dp[0][j + 1] = dp[0][j - 1] }\\n\\t}\\n\\n\\tfor (i, char) in s.enumerated() {\\n\\t\\tfor (j, pattern) in p.enumerated() {\\n\\t\\t\\tif char == pattern || pattern == \".\" { dp[i + 1][j + 1] = dp[i][j] }\\n\\t\\t\\telse if pattern == \"*\" {\\n\\t\\t\\t\\tdp[i + 1][j + 1] = dp[i + 1][j - 1]\\n\\t\\t\\t\\tif char == prevPattern || prevPattern == \".\" {\\n\\t\\t\\t\\t\\tdp[i + 1][j + 1] = dp[i + 1][j + 1] || dp[i][j + 1]\\n\\t\\t\\t\\t}       \\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[i + 1][j + 1] = false\\n\\t\\t\\t}\\n\\t\\t\\tprevPattern = pattern\\n\\t\\t}\\n\\t\\tprint(dp[i])\\n\\t}\\n\\n\\treturn dp[s.count][p.count]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isMatch(_ s: String, _ p: String) -> Bool {\\n\\tlet sArray = Array(s)\\n\\tlet pArray = Array(p)\\n\\treturn isMatch(sArray, 0, pArray, 0)\\n}\\n\\nfunc isMatch(_ s: [Character], _ i: Int, _ p: [Character], _ j: Int) -> Bool {\\n\\tif j == p.count { return i == s.count }\\n\\n\\tlet isCurrentMatching = i != s.count && (s[i] == p[j] || p[j] == \".\")\\n\\tif j < p.count - 1 && p[j + 1] == \"*\" {\\n\\t\\treturn (isCurrentMatching && isMatch(s, i + 1, p, j)) ||\\n\\t\\t\\t\\tisMatch(s, i, p, j + 2)\\n\\t} else {\\n\\t\\treturn isCurrentMatching && isMatch(s, i + 1, p, j + 1)\\n\\t}\\n}\\n```\n```\\nfunc isMatch(_ s: String, _ p: String) -> Bool {\\n\\tvar dp = Array(repeating: Array(repeating: false, count: p.count + 1), count: s.count + 1)\\n\\tdp[0][0] = true\\n\\tvar prevPattern: Character = \"a\"\\n\\n\\tfor (j, pattern) in p.enumerated() {\\n\\t\\tif pattern == \"*\" { dp[0][j + 1] = dp[0][j - 1] }\\n\\t}\\n\\n\\tfor (i, char) in s.enumerated() {\\n\\t\\tfor (j, pattern) in p.enumerated() {\\n\\t\\t\\tif char == pattern || pattern == \".\" { dp[i + 1][j + 1] = dp[i][j] }\\n\\t\\t\\telse if pattern == \"*\" {\\n\\t\\t\\t\\tdp[i + 1][j + 1] = dp[i + 1][j - 1]\\n\\t\\t\\t\\tif char == prevPattern || prevPattern == \".\" {\\n\\t\\t\\t\\t\\tdp[i + 1][j + 1] = dp[i + 1][j + 1] || dp[i][j + 1]\\n\\t\\t\\t\\t}       \\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[i + 1][j + 1] = false\\n\\t\\t\\t}\\n\\t\\t\\tprevPattern = pattern\\n\\t\\t}\\n\\t\\tprint(dp[i])\\n\\t}\\n\\n\\treturn dp[s.count][p.count]\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 755731,
                "title": "sharing-my-dp-solution-with-detailed-explanation",
                "content": "Let dp = new boolean[m+1][n+1]\\ndp[0][0] = true (s empty and p empty)\\n\\nFIRST ROW:\\nIn the 1st row, row 0, s is empty; Therefore, the only pattern that will \\nmatch s will be strings where each character is followed by a *\\nThe * here represents 0 matching of the previous character.\\n\\nIn the examples below, we assume that we are dealing with the last\\ncharacters of both s and p (i = s.length() -1, j = p.length() - 1)\\nFor simplification, I\\'ll note s[i] as s.charAt(i), p[j] as p.charAt(j).\\n\\n(1) Case for (s[i] = p[j]) or if (p[j] = \\'.\\')\\nExample s = \"abc\", p = \"dec\" or p = \"de.\"\\nThe solution for this case will be the same as s1 = \"ab\"and p1 = \"de\"\\nThus, dp[i][j] = dp[i-1][j-1]\\n\\n(2) Case for p[j] = \\'*\\'\\nWe consider 2 subcases:\\n\\n(2-1) Case s[i] != p[j-1] and p[j-1] != \\'.\\'\\nExample s = \"abc\", p = \"cd*\"\\nIn this case, \\'*\\' counts as 0 (0 match of preceding character d). \\nThus, the solution is the same as that of s = \"abc\", p1 = \"c\"\\nTherefore, dp[i][j] = dp[i][j-2]\\n\\n(2-2) Else of 2-1, i.e.  s[i] == p[j-1] or p[j-1] == \\'.\\'\\nExample, s = \"abc\", p = \"dbc*\" or p = \"db.*\" \\nWe then get 3 subcases depending if * counts for 0 match, 1 match, or \\nmultiple (more than 1) matches of the preceding element\\n\\n(2-2-a) * counts for 0 match of the preceding element:\\ns = \"abc\", p = \"dbc*\" or p = \"db.*\"\\n0 match means it is the same as having s1 = \"abc\", p1 = \"db\" \\nTherefore, dp[i][j] = dp[i][j-2]\\n\\n(2-2-b) * counts for 1 match of the preceding element:\\ns = \"abc\", p = \"dbc*\" or p = \"db.*\"\\n1 match means it is the same as having s1 = \"abc\", p1 = \"dbc\" or \"db.\"\\nTherefore, dp[i][j] = dp[i][j-1]\\n\\n(2-2-c) * counts for more than 1 matches. For simplicity, let\\'s assume that\\nit counts for 2 matches of the preceding character. \\ns = \"abc\", p = \"dbc*\" or p = \"db.*\"\\n2 matches means it is the same as s1 = \"abc\", p1 = \"dbcc\" or p1 = \"db..\"\\nThe soulution would be the same as s2 = \"ab\", p2 = \"dbcc\" or p2 = \"db..\"\\nTherefore, dp[i][j] = dp[i-1][j]\\n\\nWhy do we only change s and not p? Actually, they both get changed but \\nonly that of s is visible and here is why. What is happening is that the\\ncount of * decreases each time we remove the last char of s. We keep on\\ndoing that until there is either a match or mismatch. Let\\'s give a couple\\nof examples, 1 with a mathch and another 1 with a mismatch.\\n\\nExample1: s = abccc, p = abc* \\nFor there to be a match * should count for 3\\nIf we remove the last char of s, we have: s1 = abcc, p1 = abc* \\nNow * counts for 2. Remove the last char of s1 again to get:\\ns2 = abc, p2 = abc* (now * counts for 1). At this point, we are\\ntaken to case (2-2-b) and we get a match.\\n\\nExample 2 (no match): s = abc, p = dec*\\nClearly, this is not a match, but let\\'s prove it.\\nIf we remove the last char of s, we have: s1 = ab, p1 = dec*\\nSince s1[i] != p1[j-1], we are taken to case (2-1) where * will count \\nas 0 match. Thus the solution will be the same as s2 = ab, p2 = de\\nThis takes us to case (3) - no match.\\n\\n(3) For all other cases, there is no match\\n\\nNOTE: For s[i] ,p[j], the corresponding element of dp in our code will\\nbe dp[i+1][j+1]. This is because we don\\'t want to go to negative indices \\nwhen we go backward.\\nExample, in Case 1, where dp[i][j] = dp[i-1][j-1]. What if i or j is 0, then\\ndp[i-1][j-1] would be undefined. So in our code, we would instead write \\nthe above as: dp[i+1][j+1] = dp[i][j]\\n\\n```\\npublic boolean isMatch(String s, String p) {\\n    if (s == null || p == null) return false;\\n    int m = s.length(), n = p.length();\\n    boolean[][] dp = new boolean[m+1][n+1];\\n    dp[0][0] = true; // both s and p are empty\\n    \\n    // 1st row (s empty). True only for patterns p = a*, a*b*, a*b*c* \\n    for (int j = 0; j < n; j++) {\\n      if (p.charAt(j) == \\'*\\' && dp[0][j-1])\\n        dp[0][j+1] = true;\\n    }\\n    \\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {        \\n        if ( (s.charAt(i) == p.charAt(j)) || (p.charAt(j) == \\'.\\') ) {\\n          dp[i+1][j+1] = dp[i][j];\\n        } else if (p.charAt(j) == \\'*\\') {\\n          if ( (s.charAt(i) != p.charAt(j-1)) && p.charAt(j-1) != \\'.\\' ) {\\n            dp[i+1][j+1] = dp[i+1][j-1];\\n          } else {\\n            dp[i+1][j+1] = dp[i+1][j-1] || dp[i+1][j] || dp[i][j+1];\\n          }\\n        } else {\\n          dp[i+1][j+1] = false;\\n        }\\n      }\\n    }\\n    return dp[m][n];\\n  }\\n  ```\\n  O(mn) runtime and O(mn) space complexities, where m and n\\n  are the corresponding lengths of both s and p.",
                "solutionTags": [],
                "code": "```\\npublic boolean isMatch(String s, String p) {\\n    if (s == null || p == null) return false;\\n    int m = s.length(), n = p.length();\\n    boolean[][] dp = new boolean[m+1][n+1];\\n    dp[0][0] = true; // both s and p are empty\\n    \\n    // 1st row (s empty). True only for patterns p = a*, a*b*, a*b*c* \\n    for (int j = 0; j < n; j++) {\\n      if (p.charAt(j) == \\'*\\' && dp[0][j-1])\\n        dp[0][j+1] = true;\\n    }\\n    \\n    for (int i = 0; i < m; i++) {\\n      for (int j = 0; j < n; j++) {        \\n        if ( (s.charAt(i) == p.charAt(j)) || (p.charAt(j) == \\'.\\') ) {\\n          dp[i+1][j+1] = dp[i][j];\\n        } else if (p.charAt(j) == \\'*\\') {\\n          if ( (s.charAt(i) != p.charAt(j-1)) && p.charAt(j-1) != \\'.\\' ) {\\n            dp[i+1][j+1] = dp[i+1][j-1];\\n          } else {\\n            dp[i+1][j+1] = dp[i+1][j-1] || dp[i+1][j] || dp[i][j+1];\\n          }\\n        } else {\\n          dp[i+1][j+1] = false;\\n        }\\n      }\\n    }\\n    return dp[m][n];\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 752273,
                "title": "how-i-transformed-a-recursive-solution-to-dp-easy-to-understand",
                "content": "I never try to write direct DP solution. I always try to solve it naively using recusrion then use memorization (top down DP). I personally found this is easy way to tackle DP problem.\\n\\n**Recursive using two indexes:**\\n* sIndex: index for actual string\\n* pIndex: index for pattern string\\n\\nRuntime: 29 ms\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if(s == null && p == null || s.length() == 0 && p.length() == 0) return true;\\n        return helper(s,p,0,0);\\n    }\\n    \\n    private boolean helper(String s, String p, int sIndex, int pIndex){\\n        // base case - reached end of pattern, why we\\'re not doing if(pIndex >= p.length() && sIndex >= s.length()), because end of pattern \\n\\t\\t// meaning we have to return a result. If we add those two conditions together then we will not be returning any result and will cause out of bound exception\\n        if(pIndex >= p.length()) {\\n            return sIndex >= s.length(); \\n        }\\n        \\n        // if next pattern char is \\'*\\', example \"aaab\", \"a*b\"\\n        if(pIndex < p.length()-1 && p.charAt(pIndex+1) == \\'*\\'){\\n            // we have two choices, zero char match, meaning no change in the actual string index but pattern index will jump after * character\\n            if(helper(s,p,sIndex,pIndex+2)) return true;           \\n            // match multiple time prev character, as * can match multiple times the previous character\\n            if(sIndex < s.length() && (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == \\'.\\')){\\n                if(helper(s,p,sIndex+1,pIndex)) return true;\\n            }\\n        }else if(sIndex < s.length() && (p.charAt(pIndex) == \\'.\\' || p.charAt(pIndex) == s.charAt(sIndex))){\\n            if(helper(s,p,sIndex+1,pIndex+1)) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n**DP using Memorization:**\\nAs we can see in the above approach, in each recursive call we\\'re looking for answer, for a particular sIndex, pIndex combination. So if we can cache the result in a 2D array then BOOM. Now if we take a boolean matrix that will not work, as we have to maintain 3 states in the cache (a. result not available b. we found a match c. no match found). So I took an integer matrix with -1 as default value meaning we don\\'t have any result. 1 meaning we found a match, 0 meaning no match found for this sIndex and pIndex combination. Code is exactly same as above recursive one, just accomodated the memrozation. Hope this is helpful.\\n\\nRuntime: 2ms\\n\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if(s == null && p == null || s.length() == 0 && p.length() == 0) return true;\\n        int[][] cache = new int[s.length()+1][p.length()+1];\\n        // initialize cache with -1\\n        for(int i=0; i<cache.length; i++){\\n            for(int j=0; j<cache[0].length; j++){\\n                cache[i][j] = -1;\\n            }\\n        }\\n        \\n        return helper(s,p,0,0,cache) == 1 ? true : false;        \\n    }\\n    \\n    private int helper(String s, String p, int sIndex, int pIndex, int[][] cache){\\n        //base case - reached end of pattern\\n        if(pIndex >= p.length()) {\\n            return sIndex >= s.length() ? 1:0; \\n        }\\n\\n        // check the cache\\n        if(cache[sIndex][pIndex] != -1) return cache[sIndex][pIndex];\\n        \\n        // if next pattern char is \\'*\\'\\n        if(pIndex < p.length()-1 && p.charAt(pIndex+1) == \\'*\\'){\\n            // we have two choices, zero char match\\n            if(helper(s,p,sIndex,pIndex+2,cache) == 1){\\n                cache[sIndex][pIndex] = 1;\\n                return 1;  \\n            }          \\n            // match multiple time prev character\\n            if(sIndex < s.length() && (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == \\'.\\')){\\n                if(helper(s,p,sIndex+1,pIndex,cache) == 1){\\n                    cache[sIndex][pIndex] = 1;\\n                    return 1; \\n                }\\n            }\\n        }else if(sIndex < s.length() && (p.charAt(pIndex) == \\'.\\' || p.charAt(pIndex) == s.charAt(sIndex))){\\n            if(helper(s,p,sIndex+1,pIndex+1,cache) == 1){\\n                cache[sIndex][pIndex] = 1;\\n                return 1;\\n            }\\n        }\\n        // if we\\'re here meaning we didn\\'t find any match, lets save the result in the cache\\n        cache[sIndex][pIndex] = 0;\\n        return 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if(s == null && p == null || s.length() == 0 && p.length() == 0) return true;\\n        return helper(s,p,0,0);\\n    }\\n    \\n    private boolean helper(String s, String p, int sIndex, int pIndex){\\n        // base case - reached end of pattern, why we\\'re not doing if(pIndex >= p.length() && sIndex >= s.length()), because end of pattern \\n\\t\\t// meaning we have to return a result. If we add those two conditions together then we will not be returning any result and will cause out of bound exception\\n        if(pIndex >= p.length()) {\\n            return sIndex >= s.length(); \\n        }\\n        \\n        // if next pattern char is \\'*\\', example \"aaab\", \"a*b\"\\n        if(pIndex < p.length()-1 && p.charAt(pIndex+1) == \\'*\\'){\\n            // we have two choices, zero char match, meaning no change in the actual string index but pattern index will jump after * character\\n            if(helper(s,p,sIndex,pIndex+2)) return true;           \\n            // match multiple time prev character, as * can match multiple times the previous character\\n            if(sIndex < s.length() && (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == \\'.\\')){\\n                if(helper(s,p,sIndex+1,pIndex)) return true;\\n            }\\n        }else if(sIndex < s.length() && (p.charAt(pIndex) == \\'.\\' || p.charAt(pIndex) == s.charAt(sIndex))){\\n            if(helper(s,p,sIndex+1,pIndex+1)) return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if(s == null && p == null || s.length() == 0 && p.length() == 0) return true;\\n        int[][] cache = new int[s.length()+1][p.length()+1];\\n        // initialize cache with -1\\n        for(int i=0; i<cache.length; i++){\\n            for(int j=0; j<cache[0].length; j++){\\n                cache[i][j] = -1;\\n            }\\n        }\\n        \\n        return helper(s,p,0,0,cache) == 1 ? true : false;        \\n    }\\n    \\n    private int helper(String s, String p, int sIndex, int pIndex, int[][] cache){\\n        //base case - reached end of pattern\\n        if(pIndex >= p.length()) {\\n            return sIndex >= s.length() ? 1:0; \\n        }\\n\\n        // check the cache\\n        if(cache[sIndex][pIndex] != -1) return cache[sIndex][pIndex];\\n        \\n        // if next pattern char is \\'*\\'\\n        if(pIndex < p.length()-1 && p.charAt(pIndex+1) == \\'*\\'){\\n            // we have two choices, zero char match\\n            if(helper(s,p,sIndex,pIndex+2,cache) == 1){\\n                cache[sIndex][pIndex] = 1;\\n                return 1;  \\n            }          \\n            // match multiple time prev character\\n            if(sIndex < s.length() && (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == \\'.\\')){\\n                if(helper(s,p,sIndex+1,pIndex,cache) == 1){\\n                    cache[sIndex][pIndex] = 1;\\n                    return 1; \\n                }\\n            }\\n        }else if(sIndex < s.length() && (p.charAt(pIndex) == \\'.\\' || p.charAt(pIndex) == s.charAt(sIndex))){\\n            if(helper(s,p,sIndex+1,pIndex+1,cache) == 1){\\n                cache[sIndex][pIndex] = 1;\\n                return 1;\\n            }\\n        }\\n        // if we\\'re here meaning we didn\\'t find any match, lets save the result in the cache\\n        cache[sIndex][pIndex] = 0;\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650273,
                "title": "c-dp-easy-to-understand-explanation",
                "content": "This post has been inspired by great post from @serdaroquai (https://leetcode.com/problems/regular-expression-matching/discuss/191830/Java-DP-solution-beats-100-with-explanation)\\n\\nThe most critical observation is that \"x*\" can either match empty string, or at least one x.\\n\\ndp[i][j] denotes if s[0...i-1] is valid for pattern p[0...j-1].\\n\\nRecurrence relation:\\n```\\n1. If p[j] == s[i] : dp[i][j] = dp[i-1][j-1];\\n2. If p[j] == \\'.\\'  : dp[i][j] = dp[i-1][j-1];\\n3. If p[j] == \\'*\\'  : \\n   here are two sub conditions:\\n   1. if p[j-1] != s[i] : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty\\n   2. if p[j-1] == s[i] or p[j-1] == \\'.\\':\\n            dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a \\n            or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a\\n            or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty\\n```\\n\\nConsider following example\\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y\\na 1\\na 2\\nb 3\\n```\\nSo what about the first column? for and empty pattern p=\"\" only thing that is valid is an empty string s=\"\" and that is already our dp[0][0] which is true. That means rest of `dp[i][0]\\' is false.\\n\\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y\\na 1 n\\na 2 n\\nb 3 n\\n```\\n\\nWhat about the first row? In other words which pattern p matches empty string s=\"\"? The answer is either an empty pattern p=\"\" or a pattern that can represent an empty string such as p=\"a*\", p=\"z*\" or more interestingly a combiation of them as in p=\"a*b*c*\". Below for loop is used to populate dp[0][j]. Note how it uses previous states by checking dp[0][j-2]\\n\\n```\\n for (int j=2; j<=p.length(); j++) {\\n       dp[0][j] = p.charAt(j-1) == \\'*\\' && dp[0][j-2]; \\n }\\n```\\n\\nAt this stage our matrix has become as follows: Notice dp[0][2] and dp[0][4] are both true because p=\"c*\" and p=\"c*a*\" can both match an empty string.\\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y n y n y n\\na 1 n\\na 2 n\\nb 3 n\\n```\\n\\nSo now we can start our main iteration. It is basically the same, we will iterate all possible s lengths (i) for all possible p lengths (j) and we will try to find a relation based on previous results. Turns out there are two cases.\\n1. (p.charAt(j-1) == s.charAt(i-1) || p.charAt(j-1) == \\'.\\') if the current characters match or pattern has . then the result is determined by the previous state dp[i][j] = dp[i-1][j-1]. Don\\'t be confused by the charAt(j-1) charAt(i-1) indexes using a -1 offset that is because our dp array is actually one index bigger than our string and pattern lenghts to hold the initial state dp[0][0]\\n2. if p.charAt(j-1) == \\'*\\' then either it acts as an empty set and the result is dp[i][j] = dp[i][j-2] or (s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == \\'.\\') current char of string equals the char preceding * in pattern so the result is dp[i-1][j]\\n\\nSo here is the final state of matrix after we evaluate all elements:\\n\\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y n y n y n\\na 1 n n n y y n\\na 2 n n n n y n\\nb 3 n n n n n y\\n```\\n\\n\\n```\\nbool isMatch(string s, string p) {\\n\\tint m = s.size(), n = p.size();\\n\\tvector<vector<bool>> dp( m+1, vector<bool>( n+1, false ) );\\n\\n\\tdp[0][0] = true; // when empty pattern and empty string\\n\\t// match row for pattern with empty text\\n\\tfor( int j=2; j<=n; j++ ) {\\n\\t\\tdp[0][j] = p[j-1] == \\'*\\' && dp[0][j-2]; \\n\\t}\\n\\n\\tfor( int i=1; i<=m ; i++ ) {\\n\\t\\tfor( int j=1; j<=n ; j++) {\\n\\t\\t    // if there is a match\\n\\t\\t\\tif( p[j-1] == s[i-1] || p[j-1] == \\'.\\' ) \\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\telse if( p[j-1] == \\'*\\' )\\n\\t\\t\\t    // 0 occurrence of character prev to \\'*\\'\\n\\t\\t\\t\\t// OR\\n\\t\\t\\t\\t// pattern and text matches till the last occurrence\\n\\t\\t\\t\\tdp[i][j] = dp[i][j-2] || \\n\\t\\t\\t\\t\\t\\t   ( (s[i-1] == p[j-2] || p[j-2] == \\'.\\') && dp[i-1][j] ); \\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n]; \\n}\\n```\\n\\nTime and space complexity are O(m * n).",
                "solutionTags": [],
                "code": "```\\n1. If p[j] == s[i] : dp[i][j] = dp[i-1][j-1];\\n2. If p[j] == \\'.\\'  : dp[i][j] = dp[i-1][j-1];\\n3. If p[j] == \\'*\\'  : \\n   here are two sub conditions:\\n   1. if p[j-1] != s[i] : dp[i][j] = dp[i][j-2]  //in this case, a* only counts as empty\\n   2. if p[j-1] == s[i] or p[j-1] == \\'.\\':\\n            dp[i][j] = dp[i-1][j]    //in this case, a* counts as multiple a \\n            or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a\\n            or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty\\n```\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y\\na 1\\na 2\\nb 3\\n```\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y\\na 1 n\\na 2 n\\nb 3 n\\n```\n```\\n for (int j=2; j<=p.length(); j++) {\\n       dp[0][j] = p.charAt(j-1) == \\'*\\' && dp[0][j-2]; \\n }\\n```\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y n y n y n\\na 1 n\\na 2 n\\nb 3 n\\n```\n```\\ns=\\'aab\\', p=\\'c*a*b\\'\\n\\n      c * a * b \\n    0 1 2 3 4 5\\n  0 y n y n y n\\na 1 n n n y y n\\na 2 n n n n y n\\nb 3 n n n n n y\\n```\n```\\nbool isMatch(string s, string p) {\\n\\tint m = s.size(), n = p.size();\\n\\tvector<vector<bool>> dp( m+1, vector<bool>( n+1, false ) );\\n\\n\\tdp[0][0] = true; // when empty pattern and empty string\\n\\t// match row for pattern with empty text\\n\\tfor( int j=2; j<=n; j++ ) {\\n\\t\\tdp[0][j] = p[j-1] == \\'*\\' && dp[0][j-2]; \\n\\t}\\n\\n\\tfor( int i=1; i<=m ; i++ ) {\\n\\t\\tfor( int j=1; j<=n ; j++) {\\n\\t\\t    // if there is a match\\n\\t\\t\\tif( p[j-1] == s[i-1] || p[j-1] == \\'.\\' ) \\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\telse if( p[j-1] == \\'*\\' )\\n\\t\\t\\t    // 0 occurrence of character prev to \\'*\\'\\n\\t\\t\\t\\t// OR\\n\\t\\t\\t\\t// pattern and text matches till the last occurrence\\n\\t\\t\\t\\tdp[i][j] = dp[i][j-2] || \\n\\t\\t\\t\\t\\t\\t   ( (s[i-1] == p[j-2] || p[j-2] == \\'.\\') && dp[i-1][j] ); \\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n]; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 496112,
                "title": "pure-recursion-solution-without-dp-1ms-beats-100-java-why",
                "content": "**My pure recursion solution (without DP) is taking 1ms (Beats 100%)**. I am traversing both text and pattern from right to left. I have not used any memoization or tabulation. Does that mean it does not require DP? Or is it an issue with the test cases?\\nHere\\'s the code:\\n```\\nclass Solution {\\n    public boolean isMatch(String text, String pattern) {\\n        return isMatch(text.toCharArray(), text.length()-1, pattern.toCharArray(), pattern.length()-1);\\n    }\\n    \\n    // matches pattern and text right to left starting pattern at index p and text at index t\\n    private boolean isMatch(char[] text, int t, char[] pattern, int p) {\\n        // case 1: we have finished traversing the entire pattern\\n        if (p==-1) return t==-1;\\n        \\n        // case 2: we have finished traversing the entire text\\n        if (t==-1) return emptyMatch(pattern, p);\\n        \\n        // case 3: pattern[p] is not \\'*\\'\\n        if (p==0 || pattern[p]!=\\'*\\') {\\n            return charMatch(text[t], pattern[p]) && isMatch(text, t-1, pattern, p-1);\\n        }\\n        \\n        // case 4: p>0 && pattern[p]==\\'*\\'\\n        return charMatch(text[t], pattern[p-1]) && isMatch(text, t-1, pattern, p) ||\\n                isMatch(text, t, pattern, p-2);\\n    }\\n    \\n    private boolean charMatch(char t, char p) {\\n        return p==\\'.\\' || t==p;\\n    }\\n    \\n    private boolean emptyMatch(char[] pattern, int p) {\\n        if(p%2==0) return false;\\n        while(p>=0) {\\n            if (pattern[p]!=\\'*\\') return false;\\n            p -=2;\\n        }\\n        return true;\\n    }\\n}\\n```\\n**I feel that case 4 should make the time complexity exponential. Wondering why I am not getting TLE or long run time. Would appreciate any insights.**\\n\\nI also tried coding the **left to right traversal** version of this code. In that case it takes **13 ms**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String text, String pattern) {\\n        return isMatch(text.toCharArray(), text.length()-1, pattern.toCharArray(), pattern.length()-1);\\n    }\\n    \\n    // matches pattern and text right to left starting pattern at index p and text at index t\\n    private boolean isMatch(char[] text, int t, char[] pattern, int p) {\\n        // case 1: we have finished traversing the entire pattern\\n        if (p==-1) return t==-1;\\n        \\n        // case 2: we have finished traversing the entire text\\n        if (t==-1) return emptyMatch(pattern, p);\\n        \\n        // case 3: pattern[p] is not \\'*\\'\\n        if (p==0 || pattern[p]!=\\'*\\') {\\n            return charMatch(text[t], pattern[p]) && isMatch(text, t-1, pattern, p-1);\\n        }\\n        \\n        // case 4: p>0 && pattern[p]==\\'*\\'\\n        return charMatch(text[t], pattern[p-1]) && isMatch(text, t-1, pattern, p) ||\\n                isMatch(text, t, pattern, p-2);\\n    }\\n    \\n    private boolean charMatch(char t, char p) {\\n        return p==\\'.\\' || t==p;\\n    }\\n    \\n    private boolean emptyMatch(char[] pattern, int p) {\\n        if(p%2==0) return false;\\n        while(p>=0) {\\n            if (pattern[p]!=\\'*\\') return false;\\n            p -=2;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382005,
                "title": "js-recursive-solution",
                "content": "```\\n/**\\n * @param {string} str\\n * @param {string} pattern\\n * @return {boolean}\\n */\\nconst isMatch = (str, pattern) => {\\n    // if pattern and string are empty, it\\'s a match, return true otherwise return false\\n    if (!pattern) return !str;\\n\\n    // check if the first character in pattern and str match\\n    // or if the first character of pattern is the . wild card\\n\\tconst firstCharMatch = str && (pattern[0] === str[0] || pattern[0] === \\'.\\');\\n\\n    // If the pattern length is at least 2 and the second character is a * we check\\n    // both paths where the next character in the string is the same as the previous\\n    // and if the next character in the string is different\\n    return pattern.length > 1 && pattern[1] === \\'*\\'\\n        ? isMatch(str, pattern.substr(2)) || (firstCharMatch && isMatch(str.substr(1), pattern))\\n        // otherwise we continue checking if the next character in the string\\n        // matches the next character in the pattern\\n        : firstCharMatch && isMatch(str.substr(1), pattern.substr(1));\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} str\\n * @param {string} pattern\\n * @return {boolean}\\n */\\nconst isMatch = (str, pattern) => {\\n    // if pattern and string are empty, it\\'s a match, return true otherwise return false\\n    if (!pattern) return !str;\\n\\n    // check if the first character in pattern and str match\\n    // or if the first character of pattern is the . wild card\\n\\tconst firstCharMatch = str && (pattern[0] === str[0] || pattern[0] === \\'.\\');\\n\\n    // If the pattern length is at least 2 and the second character is a * we check\\n    // both paths where the next character in the string is the same as the previous\\n    // and if the next character in the string is different\\n    return pattern.length > 1 && pattern[1] === \\'*\\'\\n        ? isMatch(str, pattern.substr(2)) || (firstCharMatch && isMatch(str.substr(1), pattern))\\n        // otherwise we continue checking if the next character in the string\\n        // matches the next character in the pattern\\n        : firstCharMatch && isMatch(str.substr(1), pattern.substr(1));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 333699,
                "title": "python-nfa-with-detailed-explanation-beats-96-74",
                "content": "NFA stands for non-deterministic finite automata. If you are unfamiliar with NFA, better check out [UC Berkeley CS164 Compilers and Programming Languages](http://www-inst.eecs.berkeley.edu/~cs164/sp19/)\\'s Lecture 4 slides.\\n\\nThe NFA approach consists of two stages\\n\\n1. construct the transition table from the pattern string: iterate over the pattern string `p`, and construct a transition table `transitions`, where `transition[state][input]` represents the state that the NFA should transfer into if it is currently in state `state` and received an input `input`. \\n2. execute the NFA with the string to match as input: iterate over the string `s`, and make NFA transfer to different states according to the transition table `transitions` that we have just constructed.\\n\\nSince it is an NFA not a DFA, which means some states can accept epsilon as input, and epsilon represents *no input* , there can be multiple *NFA clones* at some point.\\n\\nThe idea of epsilon and *no input* can be hard to accept at first (IMHO). Whenever NFA reaches some state that can accept epsilon input, NFA *clones* itself once (it\\'s like `fork()` function in UNIX). Now that we have two NFAs namely NFA 1 and NFA 2, both sitting on the same state, one NFA (suppose NFA 1) remains still on current state, and another NFA (suppose NFA 2) takes the epsilon input and transfers to the next state where the epsilon input points to. It is possible that when NFA 2 reaches the next state, it amazingly finds that the new state can accept epsilon too. So NFA 2 forks again, into NFA 2.1 and NFA 2.2 ...This forking process continues on and on until no more forks can be made.\\n\\nIf you still can\\'t get the idea, better check out Keith Cooper and Linda Torczon\\'s book *Engineering a Compiler* Chapter 2, Page 44.\\n\\n```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        p = p + \"\\\\x00\" # append a dummy character so we do not have to check out-of-bounds\\n        transitions = {} # transition table. `transition[state][input]` indicates which state the NFA should transfer into if it is current in state `state` and receives an input `input`\\n        default = True # the default input. When the current state does not accept some certain character as input, the NFA transfers into whatever the default input points to. The default input represents some kind of input (at least there *is* some input), so it does not cover the case of epsilon input.\\n        errorState = float(\"nan\") # error state\\n        epsilon = -1 # epsilon input, or no input\\n        lastState = 0 # the last valid state in the transition table so far\\n        initialState = 0 # initial state\\n\\n        for i, v in enumerate(p[: -1]): # iterate over the pattern string and construct the transition table\\n            if v == \"*\": # here I choose to process `a*` when we meet `a` so if current character is `*` that means it has been processed in the previous iteration\\n                continue # so just skip\\n            else: # current character is a common character or `.`\\n                if p[i + 1] != \"*\": # the character right after current character is not a `*`, so this pattern character only matches one character in the string\\n                    transitions[lastState] = dict()\\n                    if v == \".\": # `.` matches any single character\\n                        transitions[lastState][default] = lastState + 1 # so just set the default input\\n                    else: # other than `.`\\n                        transitions[lastState][v] = lastState + 1\\n                        transitions[lastState][default] = errorState # otherwise go to error state\\n                    lastState += 1 # our transition table has a new state, so future states should be built upon it\\n                else: # something like `a*`\\n                    # check lecture 4 slides to see how to construct states for a pattern like `a*`\\n                    transitions[lastState] = dict()\\n                    transitions[lastState + 1] = dict()\\n                    if v == \".\": # something like `.*`\\n                        transitions[lastState][default] = lastState + 1\\n                        transitions[lastState][epsilon] = lastState + 2\\n                        transitions[lastState + 1][epsilon] = lastState\\n                        transitions[lastState + 1][default] = errorState\\n                    else: # `a*`\\n                        transitions[lastState][v] = lastState + 1\\n                        transitions[lastState][epsilon] = lastState + 2\\n                        transitions[lastState][default] = errorState\\n                        transitions[lastState + 1][epsilon] = lastState\\n                        transitions[lastState + 1][default] = errorState\\n                    lastState += 2\\n\\n        beforeState = float(\"-inf\") # insert a dummy state before initial state to make life easier, because initial state can probably accept epsilon input\\n        transitions[beforeState] = dict()\\n        transitions[beforeState][default] = initialState # points dummy state to initial state, make it transfer to initial state when it receives any input\\n        acceptingState = lastState # so far we have constructed the core part of our transition table. Since it is required to return match success when the pattern `covers the entire input string (not partial)`, there is only one acceptable state.\\n        transitions[acceptingState] = dict()\\n        transitions[acceptingState][default] = errorState # NFA should not accept any input when it reaches the final, acceptable state, so make it point to error state when it receives any input\\n        transitions[errorState] = dict()\\n        transitions[errorState][default] = errorState # NFA should either not accept any input when it reaches the error state, so make it point to itself\\n        # print(transitions)\\n        states = {beforeState} # use a set to avoid duplicate NFA clones\\n\\n        for i, v in enumerate(\"\\\\x00\" + s): # execute NFA. Insert a dummy character to make dummy state accept it and transfer to initial state.\\n            nextStates = set()\\n\\n            for state in states: # iterate over all NFA clones and make them transfer to next states (probably more clones)\\n                if v in transitions[state]: # current state can accept current character as input\\n                    nextState = transitions[state][v] # make it transfer to next state\\n                else: # oops, not an acceptable character\\n                    nextState = transitions[state][default] # transfer to default\\n                nextStates.add(nextState)\\n\\n                # check whether current NFA should be forked to more clones\\n                while epsilon in transitions[nextState]: # stop when some cloned version does not accept epsilon input any more\\n                    nextState = transitions[nextState][epsilon]\\n                    nextStates.add(nextState)\\n\\n            states = nextStates # transfer to new states\\n            # print(states)\\n            # if states == set() or all(state == errorState for state in states): # If the string has not yet been exhausted and all clones have inevitably gone into error state, they will forever get stuck in error state and will never have a chance to go out, so there is no point to continue executing\\n            if states == set() or (len(states) == 1 and errorState in states): # make it faster using set\\'s O(1) `in`\\n                return False # the string must mismatch pattern\\n        else: # string exhausted\\n            if acceptingState in states: # at least one clone sits on the final, acceptable state\\n                return True # it is a match!\\n            else: # oops\\n                return False # mismatch\\n\\n# s = Solution()\\n# print(s.isMatch(\"aa\", \"a\")) # false\\n# print(s.isMatch(\"aa\", \"aa\")) # true\\n# print(s.isMatch(\"aa\", \"a*\")) # true\\n# print(s.isMatch(\"ab\", \".*\")) # true\\n# print(s.isMatch(\"aab\", \"c*a*b\")) # true\\n# print(s.isMatch(\"mississippi\", \"mis*is*p*.\")) # false\\n```\\n\\n44ms beats 96.74%\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        p = p + \"\\\\x00\" # append a dummy character so we do not have to check out-of-bounds\\n        transitions = {} # transition table. `transition[state][input]` indicates which state the NFA should transfer into if it is current in state `state` and receives an input `input`\\n        default = True # the default input. When the current state does not accept some certain character as input, the NFA transfers into whatever the default input points to. The default input represents some kind of input (at least there *is* some input), so it does not cover the case of epsilon input.\\n        errorState = float(\"nan\") # error state\\n        epsilon = -1 # epsilon input, or no input\\n        lastState = 0 # the last valid state in the transition table so far\\n        initialState = 0 # initial state\\n\\n        for i, v in enumerate(p[: -1]): # iterate over the pattern string and construct the transition table\\n            if v == \"*\": # here I choose to process `a*` when we meet `a` so if current character is `*` that means it has been processed in the previous iteration\\n                continue # so just skip\\n            else: # current character is a common character or `.`\\n                if p[i + 1] != \"*\": # the character right after current character is not a `*`, so this pattern character only matches one character in the string\\n                    transitions[lastState] = dict()\\n                    if v == \".\": # `.` matches any single character\\n                        transitions[lastState][default] = lastState + 1 # so just set the default input\\n                    else: # other than `.`\\n                        transitions[lastState][v] = lastState + 1\\n                        transitions[lastState][default] = errorState # otherwise go to error state\\n                    lastState += 1 # our transition table has a new state, so future states should be built upon it\\n                else: # something like `a*`\\n                    # check lecture 4 slides to see how to construct states for a pattern like `a*`\\n                    transitions[lastState] = dict()\\n                    transitions[lastState + 1] = dict()\\n                    if v == \".\": # something like `.*`\\n                        transitions[lastState][default] = lastState + 1\\n                        transitions[lastState][epsilon] = lastState + 2\\n                        transitions[lastState + 1][epsilon] = lastState\\n                        transitions[lastState + 1][default] = errorState\\n                    else: # `a*`\\n                        transitions[lastState][v] = lastState + 1\\n                        transitions[lastState][epsilon] = lastState + 2\\n                        transitions[lastState][default] = errorState\\n                        transitions[lastState + 1][epsilon] = lastState\\n                        transitions[lastState + 1][default] = errorState\\n                    lastState += 2\\n\\n        beforeState = float(\"-inf\") # insert a dummy state before initial state to make life easier, because initial state can probably accept epsilon input\\n        transitions[beforeState] = dict()\\n        transitions[beforeState][default] = initialState # points dummy state to initial state, make it transfer to initial state when it receives any input\\n        acceptingState = lastState # so far we have constructed the core part of our transition table. Since it is required to return match success when the pattern `covers the entire input string (not partial)`, there is only one acceptable state.\\n        transitions[acceptingState] = dict()\\n        transitions[acceptingState][default] = errorState # NFA should not accept any input when it reaches the final, acceptable state, so make it point to error state when it receives any input\\n        transitions[errorState] = dict()\\n        transitions[errorState][default] = errorState # NFA should either not accept any input when it reaches the error state, so make it point to itself\\n        # print(transitions)\\n        states = {beforeState} # use a set to avoid duplicate NFA clones\\n\\n        for i, v in enumerate(\"\\\\x00\" + s): # execute NFA. Insert a dummy character to make dummy state accept it and transfer to initial state.\\n            nextStates = set()\\n\\n            for state in states: # iterate over all NFA clones and make them transfer to next states (probably more clones)\\n                if v in transitions[state]: # current state can accept current character as input\\n                    nextState = transitions[state][v] # make it transfer to next state\\n                else: # oops, not an acceptable character\\n                    nextState = transitions[state][default] # transfer to default\\n                nextStates.add(nextState)\\n\\n                # check whether current NFA should be forked to more clones\\n                while epsilon in transitions[nextState]: # stop when some cloned version does not accept epsilon input any more\\n                    nextState = transitions[nextState][epsilon]\\n                    nextStates.add(nextState)\\n\\n            states = nextStates # transfer to new states\\n            # print(states)\\n            # if states == set() or all(state == errorState for state in states): # If the string has not yet been exhausted and all clones have inevitably gone into error state, they will forever get stuck in error state and will never have a chance to go out, so there is no point to continue executing\\n            if states == set() or (len(states) == 1 and errorState in states): # make it faster using set\\'s O(1) `in`\\n                return False # the string must mismatch pattern\\n        else: # string exhausted\\n            if acceptingState in states: # at least one clone sits on the final, acceptable state\\n                return True # it is a match!\\n            else: # oops\\n                return False # mismatch\\n\\n# s = Solution()\\n# print(s.isMatch(\"aa\", \"a\")) # false\\n# print(s.isMatch(\"aa\", \"aa\")) # true\\n# print(s.isMatch(\"aa\", \"a*\")) # true\\n# print(s.isMatch(\"ab\", \".*\")) # true\\n# print(s.isMatch(\"aab\", \"c*a*b\")) # true\\n# print(s.isMatch(\"mississippi\", \"mis*is*p*.\")) # false\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274032,
                "title": "c-recursion-with-memoization",
                "content": "Check the documents.\\n```\\nclass Solution {\\n    /*\\n     * Recursion with memoization.\\n     *      if s[i] == p[j] or p[j] == \\'.\\' --> isMatch(i, j) = isMatch(i-1, j-1)\\n     *      if s[i] != p[j] and p[j] != \\'*\\':\\n     *              --> isMatch(i, j) = False\\n     *      if p[j] == \\'*\\':\\n     *              --> isMatch(i, j) = isMatch(i, j-1) # single precedding character\\n     *              --> isMatch(i, j) = isMatch(i, j-2) # zero preceeding character\\n     *              --> isMatch(i, j) = isMatch(i-1, j) and (s[i] == p[j-1] || p[j-1] == \\'.\\') ## multiple preceeding characters\\n     * \\n     * add Memoization\\n     *      duplicates: isMatch(i, j)\\n     */\\n    \\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size();\\n        int n = p.size();\\n        memo = vector<vector<int>> (m+1, vector<int>(n+1, -1));\\n        return isMatch(s, p, m-1, n-1);\\n    }\\nprivate:\\n    vector<vector<int>> memo;\\n    bool isMatch(string s, string p, int i, int j) {\\n        if(i < 0 && j < 0) return true;\\n        if(j < 0) return false;\\n\\n        if(memo[i+1][j+1] >= 0) return memo[i+1][j+1];\\n        \\n        if(i >= 0 && (s[i] == p[j] || p[j] == \\'.\\')) {\\n            memo[i+1][j+1] = isMatch(s, p, i-1, j-1);\\n            return memo[i+1][j+1];\\n        }\\n\\n        if(p[j] == \\'*\\') {\\n            bool c0 = isMatch(s, p, i, j-2);\\n            bool c1 = i >= 0 ? isMatch(s, p, i, j-1) : false;\\n            bool c2 = i >= 1 ? isMatch(s, p, i-1, j) && (s[i] == p[j-1] || p[j-1] == \\'.\\') : false;\\n            memo[i+1][j+1] = (c1 || c0 || c2);\\n            return memo[i+1][j+1];\\n        }\\n        memo[i+1][j+1] = 0;\\n        return memo[i+1][j+1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n     * Recursion with memoization.\\n     *      if s[i] == p[j] or p[j] == \\'.\\' --> isMatch(i, j) = isMatch(i-1, j-1)\\n     *      if s[i] != p[j] and p[j] != \\'*\\':\\n     *              --> isMatch(i, j) = False\\n     *      if p[j] == \\'*\\':\\n     *              --> isMatch(i, j) = isMatch(i, j-1) # single precedding character\\n     *              --> isMatch(i, j) = isMatch(i, j-2) # zero preceeding character\\n     *              --> isMatch(i, j) = isMatch(i-1, j) and (s[i] == p[j-1] || p[j-1] == \\'.\\') ## multiple preceeding characters\\n     * \\n     * add Memoization\\n     *      duplicates: isMatch(i, j)\\n     */\\n    \\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = s.size();\\n        int n = p.size();\\n        memo = vector<vector<int>> (m+1, vector<int>(n+1, -1));\\n        return isMatch(s, p, m-1, n-1);\\n    }\\nprivate:\\n    vector<vector<int>> memo;\\n    bool isMatch(string s, string p, int i, int j) {\\n        if(i < 0 && j < 0) return true;\\n        if(j < 0) return false;\\n\\n        if(memo[i+1][j+1] >= 0) return memo[i+1][j+1];\\n        \\n        if(i >= 0 && (s[i] == p[j] || p[j] == \\'.\\')) {\\n            memo[i+1][j+1] = isMatch(s, p, i-1, j-1);\\n            return memo[i+1][j+1];\\n        }\\n\\n        if(p[j] == \\'*\\') {\\n            bool c0 = isMatch(s, p, i, j-2);\\n            bool c1 = i >= 0 ? isMatch(s, p, i, j-1) : false;\\n            bool c2 = i >= 1 ? isMatch(s, p, i-1, j) && (s[i] == p[j-1] || p[j-1] == \\'.\\') : false;\\n            memo[i+1][j+1] = (c1 || c0 || c2);\\n            return memo[i+1][j+1];\\n        }\\n        memo[i+1][j+1] = 0;\\n        return memo[i+1][j+1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 219682,
                "title": "recursive-c-solution",
                "content": "\\u9996\\u5148\\u7406\\u89E3\\u9898\\u76EE\\u610F\\u601D\\uFF0C\\u8FD9\\u9053\\u9898\\u4E2D * \\u8868\\u793A\\u4E4B\\u524D\\u7684\\u5B57\\u7B26\\u53EF\\u4EE5\\u67090\\u30011\\u6216\\u591A\\u4E2A\\u3002\\n\\u6BD4\\u5982\\u201Ca * b\\u201D\\u53EF\\u4EE5\\u4E3A\\uFF1A\\u201Cb\\u201D\\uFF0C\\u201Cab\\u201D\\uFF0C\\u201Caaaaaab\\u201D\\u3002\\n\\n\\u7136\\u540E\\u7528\\u9012\\u5F52\\u3002\\n1. s\\u4E3A\\u7A7A\\uFF0Cp\\u4E3A\\u7A7A\\uFF0C\\u8FD4\\u56DEtrue\\uFF0C\\u5426\\u5219false\\u3002\\n2. \\u5224\\u65AD\\u5F53\\u524D\\u9996\\u5B57\\u7B26\\u662F\\u5426\\u5339\\u914D\\u3002\\n3. \\u5982\\u679Cp\\u4E2D\\u7B2C\\u4E8C\\u4E2A\\u5B57\\u7B26\\u4E3A * \\uFF0C\\u5206\\u4E24\\u79CD\\u60C5\\u51B5\\uFF1A\\u4E00\\u79CD\\u662F * \\u4E4B\\u524D\\u7684\\u5B57\\u7B26\\u4E3A0\\u4E2A\\uFF0C\\u76F4\\u63A5\\u8DF3\\u8FC72\\u4E2A\\u5B57\\u7B26\\u63A5\\u7740\\u6BD4\\u8F83\\uFF1B\\u53E6\\u4E00\\u79CD\\u662F\\u5F53\\u524D\\u9996\\u5B57\\u7B26\\u5339\\u914D\\uFF0Cs\\u5F80\\u540E\\u632A\\u4E00\\u4F4D\\uFF0Cp\\u4E0D\\u52A8\\u3002else\\u5C31\\u662F\\u5F53\\u524D\\u5B57\\u7B26\\u5339\\u914D\\uFF0C\\u4E24\\u8005\\u90FD\\u5F80\\u540E\\u632A\\u4E00\\u4F4D\\u63A5\\u7740\\u6BD4\\u8F83\\u3002\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if (p.size() == 0) return s.size() == 0;\\n        bool first_match = (!s.size() == 0 && (s[0] == p[0] || p[0] == \\'.\\'));\\n        if (p.size() >= 2 && p[1] == \\'*\\') {\\n            return (isMatch(s, p.substr(2, p.size() - 2)) || (first_match && isMatch(s.substr(1, s.size() - 1), p)));\\n        } else {\\n            return first_match && isMatch(s.substr(1, s.size() - 1), p.substr(1, p.size() - 1));\\n        }\\n    }\\n};\\n```\\n\\n\\u5929\\u5566\\u565C\\u8FD9\\u9053\\u9898\\u597D\\u96BE:-I",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if (p.size() == 0) return s.size() == 0;\\n        bool first_match = (!s.size() == 0 && (s[0] == p[0] || p[0] == \\'.\\'));\\n        if (p.size() >= 2 && p[1] == \\'*\\') {\\n            return (isMatch(s, p.substr(2, p.size() - 2)) || (first_match && isMatch(s.substr(1, s.size() - 1), p)));\\n        } else {\\n            return first_match && isMatch(s.substr(1, s.size() - 1), p.substr(1, p.size() - 1));\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180345,
                "title": "the-easiest-java-solution-no-dp-just-talk-case-by-case",
                "content": "Thank u for see my code, this is the code which recode from Python. I will illustrate line by line.\\n\\nMainly, it is recusive method by substring the String.\\n\\nMethod **FirstMatch** just used to compare the first letter between two String\\n\\nIn the function of **isMatch** , \\n\\nFirst, we consider about the end condtion, if p is null, if s is null, return true\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tif s is not null, return false\\n\\t\\t\\t\\t\\t\\t\\nThen, when p is more than two and include *, \\n\\nJust consider zero match and one or multiple match.\\n\\nZero match, remove the letter and * in p\\nOne or multiple match, do **firstMatch** , if it is true, then remove the first letter in s\\nBecause u just can make sure first letter in s is match.\\n\\nNext, in other condition, it is necessary to meet the requirement as followed:\\n\\nTotally match in the first letter in both s and p.\\n\\n\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if(p.length()==0){\\n\\t\\t\\tif(s.length()==0){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(p.length()>=2 && p.charAt(1)==\\'*\\'){\\n\\t\\t\\treturn isMatch(s,p.substring(2,p.length())) || (firstMatch(s,p) && isMatch(s.substring(1,s.length()),p));\\n\\t\\t}else{\\n\\t\\t\\treturn firstMatch(s,p) && isMatch(s.substring(1,s.length()),p.substring(1,p.length()));\\n\\t\\t}\\n    }\\n\\tpublic boolean firstMatch(String s, String p){\\n\\t\\tif(s.length()==0 || p.length()==0) return false;\\n\\t\\tif(s.charAt(0) == p.charAt(0) || p.charAt(0)==\\'.\\'){\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if(p.length()==0){\\n\\t\\t\\tif(s.length()==0){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif(p.length()>=2 && p.charAt(1)==\\'*\\'){\\n\\t\\t\\treturn isMatch(s,p.substring(2,p.length())) || (firstMatch(s,p) && isMatch(s.substring(1,s.length()),p));\\n\\t\\t}else{\\n\\t\\t\\treturn firstMatch(s,p) && isMatch(s.substring(1,s.length()),p.substring(1,p.length()));\\n\\t\\t}\\n    }\\n\\tpublic boolean firstMatch(String s, String p){\\n\\t\\tif(s.length()==0 || p.length()==0) return false;\\n\\t\\tif(s.charAt(0) == p.charAt(0) || p.charAt(0)==\\'.\\'){\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 168534,
                "title": "python-short-mem-search-beat-99",
                "content": "The idea is similiar to [here](https://leetcode.com/problems/regular-expression-matching/discuss/5651/Easy-DP-Java-Solution-with-detailed-Explanation). But using mem search is much faster than DP since we do not need the time and space to build the DP array. \\n\\n```python\\nclass Solution(object):\\n    \\n    def __init__(self):\\n        self.mem = {}\\n    \\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        if (s, p) in self.mem:\\n            return self.mem[(s, p)]\\n        if not p:\\n            return s == \\'\\'\\n        res = False\\n        if len(p) > 1 and p[1] == \\'*\\':\\n            res = self.isMatch(s, p[2:]) or (s != \\'\\' and (s[0] == p[0] or p[0] == \\'.\\') and self.isMatch(s[1:], p))\\n        else:\\n            res = s != \\'\\' and (p[0] == \\'.\\' or s[0] == p[0]) and self.isMatch(s[1:], p[1:])\\n        self.mem[(s, p)] = res\\n        return res\\n```\\n\\nIt is worth think why using memorization would work. The short answer is that when we recursively call `isMatch()` function, we might compare a lot of duplicate pairs of `(s, p)`. For example, suppose `len(s) == n`, `len(p) == m`, then we migt call `isMatch(s, p[2:])` and then `isMatch(s[1:], p[2:])` , or we may first call `isMatch(s[1:], p)` and `isMatch(s[1:], p[2:])`. In this case,  `isMatch(s[1:], p[2:])` is called twice. \\n\\nJust FYI, here is the DP solution:\\n\\n```python\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n\\t\\t\\t\\t\\n        m, n = len(s), len(p)\\n        dp = [[False for _ in range(n+1)] for _ in range(m+1)]\\n        dp[0][0] = True\\n        for i in range(m+1):\\n            for j in range(1, n+1):\\n                if p[j-1] != \\'*\\':\\n                    dp[i][j] = (i >= 1) and dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == \\'.\\')\\n                else:\\n                    dp[i][j] = (j >= 2) and dp[i][j-2]\\n                    dp[i][j] |= (i >= 1) and dp[i-1][j] and (s[i-1] == p[j-2] or p[j-2] == \\'.\\')\\n        return dp[-1][-1]\\n```\\n\\nHowever, it is surprisingly easy to make mistake when coding with DP. For example be careful of the loop range of `i` and `j`, we start loop from `0->m` for `i` because a pattern could match empty string (`s = \\'aa\\', p = \\'a*\\'`). We start loop from `1->n` for `j` becuase an empty pattern can match nothing but an empty string. \\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    \\n    def __init__(self):\\n        self.mem = {}\\n    \\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        if (s, p) in self.mem:\\n            return self.mem[(s, p)]\\n        if not p:\\n            return s == \\'\\'\\n        res = False\\n        if len(p) > 1 and p[1] == \\'*\\':\\n            res = self.isMatch(s, p[2:]) or (s != \\'\\' and (s[0] == p[0] or p[0] == \\'.\\') and self.isMatch(s[1:], p))\\n        else:\\n            res = s != \\'\\' and (p[0] == \\'.\\' or s[0] == p[0]) and self.isMatch(s[1:], p[1:])\\n        self.mem[(s, p)] = res\\n        return res\\n```\n```python\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n\\t\\t\\t\\t\\n        m, n = len(s), len(p)\\n        dp = [[False for _ in range(n+1)] for _ in range(m+1)]\\n        dp[0][0] = True\\n        for i in range(m+1):\\n            for j in range(1, n+1):\\n                if p[j-1] != \\'*\\':\\n                    dp[i][j] = (i >= 1) and dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == \\'.\\')\\n                else:\\n                    dp[i][j] = (j >= 2) and dp[i][j-2]\\n                    dp[i][j] |= (i >= 1) and dp[i-1][j] and (s[i-1] == p[j-2] or p[j-2] == \\'.\\')\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156453,
                "title": "bottom-up-dp",
                "content": ">Define **state** as:\\nstate[i][j] is true if s[0..i] matches p[0..j]\\n\\n> Then **goal state** is:\\nstate[slen-1][plen-1]\\n\\n> **state transition**\\n```\\nif s[i] == p[j] , state[i][j] = state[i - 1][j - 1]\\nelse {\\n  if p[j] == \\'.\\', state[i][j] = state[i - 1][j - 1]\\n  else if p[j] == \\'*\\', // to expand\\n  else state[i][j] = false\\n}\\n\\nTo expand: \\n\\t\\t\\tif (s[i] == p[j-1] || p[j-1] == .) state[i][j] = true if\\n\\t\\t\\t\\tstate[i][j-2] = true // if * means 0 preceding element       \\n\\t\\t\\t\\t|| state[i][j-1] = true // if * means 1 preceding element        \\n\\t\\t\\t\\t|| state[i-1][j] = true and (s[i] = p[j-1] or p[j-1] = .) // if * means >1 preceding elements # to explain\\n\\t\\t\\telse // * can only mean 0 preceding element   \\n\\t\\t\\t\\tstate[i][j] = state[i][j-2]  \\n```\\n>Explanation for `# to explain`\\n```\\ne.g. when i = 2, j = 1,\\ns = aaa\\n      i\\np = a*\\n     j\\n> p = \"a*\" can be represented as p = \"aa\"\\n> the last \\'a\\' in p matches s[2], and it may keep matching s[1] and s[0]\\n> thus,\\n> state[2][1] should be true if state[1][1] is true\\n> state[1][1] should be true if state[0][1] is true\\n```\\n>**note**\\nin the code below, we add one more row and one more column to the state array to avoid if - elses. \\nIn this way, \\n\\n****\\n```\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] state = new boolean[s.length() + 1][p.length() + 1];\\n        state[0][0] = true;\\n        for (int j = 2; j <= p.length(); j++)\\n            state[0][j] = p.charAt(j - 1) == \\'*\\' && state[0][j - 2];\\n        \\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 1; j <= p.length(); j++ ) {\\n                if (s.charAt(i - 1) == p.charAt(j - 1)) {\\n                    state[i][j] = state[i - 1][j - 1];\\n                } else {\\n                    if (p.charAt(j - 1) == \\'.\\') {\\n                        state[i][j] = state[i - 1][j - 1];\\n                    } else if (p.charAt(j - 1) == \\'*\\') {\\n                        // * matches 0, 1, > 1 preceding elements\\n                        state[i][j] = (j > 1 && state[i][j - 2])\\n                            || state[i][j - 1] \\n                            || (state[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == \\'.\\'));\\n                    }\\n                    // else {\\n                    //     state[i][j] = false;\\n                    // }\\n                }\\n            }\\n        }\\n        return state[s.length()][p.length()];\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nif s[i] == p[j] , state[i][j] = state[i - 1][j - 1]\\nelse {\\n  if p[j] == \\'.\\', state[i][j] = state[i - 1][j - 1]\\n  else if p[j] == \\'*\\', // to expand\\n  else state[i][j] = false\\n}\\n\\nTo expand: \\n\\t\\t\\tif (s[i] == p[j-1] || p[j-1] == .) state[i][j] = true if\\n\\t\\t\\t\\tstate[i][j-2] = true // if * means 0 preceding element       \\n\\t\\t\\t\\t|| state[i][j-1] = true // if * means 1 preceding element        \\n\\t\\t\\t\\t|| state[i-1][j] = true and (s[i] = p[j-1] or p[j-1] = .) // if * means >1 preceding elements # to explain\\n\\t\\t\\telse // * can only mean 0 preceding element   \\n\\t\\t\\t\\tstate[i][j] = state[i][j-2]  \\n```\n```\\ne.g. when i = 2, j = 1,\\ns = aaa\\n      i\\np = a*\\n     j\\n> p = \"a*\" can be represented as p = \"aa\"\\n> the last \\'a\\' in p matches s[2], and it may keep matching s[1] and s[0]\\n> thus,\\n> state[2][1] should be true if state[1][1] is true\\n> state[1][1] should be true if state[0][1] is true\\n```\n```\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] state = new boolean[s.length() + 1][p.length() + 1];\\n        state[0][0] = true;\\n        for (int j = 2; j <= p.length(); j++)\\n            state[0][j] = p.charAt(j - 1) == \\'*\\' && state[0][j - 2];\\n        \\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 1; j <= p.length(); j++ ) {\\n                if (s.charAt(i - 1) == p.charAt(j - 1)) {\\n                    state[i][j] = state[i - 1][j - 1];\\n                } else {\\n                    if (p.charAt(j - 1) == \\'.\\') {\\n                        state[i][j] = state[i - 1][j - 1];\\n                    } else if (p.charAt(j - 1) == \\'*\\') {\\n                        // * matches 0, 1, > 1 preceding elements\\n                        state[i][j] = (j > 1 && state[i][j - 2])\\n                            || state[i][j - 1] \\n                            || (state[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == \\'.\\'));\\n                    }\\n                    // else {\\n                    //     state[i][j] = false;\\n                    // }\\n                }\\n            }\\n        }\\n        return state[s.length()][p.length()];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5744,
                "title": "2-d-dp",
                "content": "**C++**\\n```cpp\\nbool isMatch(string s, string p) {\\n    bool dp[21][31] = { true };\\n    for (auto i = 0; i <= s.size(); ++i)\\n        for (auto j = 1; j <= p.size(); ++j)\\n            if (p[j - 1] == \\'*\\') \\n                dp[i][j] = dp[i][j - 2] || (i > 0 && dp[i - 1][j] && (p[j - 2] == \\'.\\' || p[j - 2] == s[i - 1]));\\n            else \\n                dp[i][j] = i > 0 && dp[i - 1][j - 1] && (p[j - 1] == \\'.\\' || p[j - 1] == s[i - 1]); \\n    return dp[s.size()][p.size()];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool isMatch(string s, string p) {\\n    bool dp[21][31] = { true };\\n    for (auto i = 0; i <= s.size(); ++i)\\n        for (auto j = 1; j <= p.size(); ++j)\\n            if (p[j - 1] == \\'*\\') \\n                dp[i][j] = dp[i][j - 2] || (i > 0 && dp[i - 1][j] && (p[j - 2] == \\'.\\' || p[j - 2] == s[i - 1]));\\n            else \\n                dp[i][j] = i > 0 && dp[i - 1][j - 1] && (p[j - 1] == \\'.\\' || p[j - 1] == s[i - 1]); \\n    return dp[s.size()][p.size()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 5813,
                "title": "python-code-beats-97-with-o-n-space-and-o-mn-time",
                "content": "Adapt rolling window DP, reduce space complexity to O(len(p))\\n```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        # time: O(m*n)\\n        # space: O(n)\\n        k = 2\\n        dp = [ [False for i in xrange(len(p)+1)] for j in xrange(k) ]\\n        dp[0][0] = True\\n        for i in xrange(2, len(p)+1):\\n            if p[i-1] == '*':\\n                dp[0][i] = dp[0][i-2]\\n        for i in xrange(1, len(s)+1):\\n            if i > 1:\\n                dp[0][0] = False\\n            for j in xrange(1, len(p)+1):\\n                if p[j-1] == '*':\\n                    dp[i%k][j] = dp[i%k][j-2] or (dp[(i-1)%k][j] and (s[i-1]==p[j-2] or p[j-2] == '.'))\\n                else:\\n                    dp[i%k][j] = dp[(i-1)%k][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.')\\n        return dp[len(s)%k][len(p)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        # time: O(m*n)\\n        # space: O(n)\\n        k = 2\\n        dp = [ [False for i in xrange(len(p)+1)] for j in xrange(k) ]\\n        dp[0][0] = True\\n        for i in xrange(2, len(p)+1):\\n            if p[i-1] == '*':\\n                dp[0][i] = dp[0][i-2]\\n        for i in xrange(1, len(s)+1):\\n            if i > 1:\\n                dp[0][0] = False\\n            for j in xrange(1, len(p)+1):\\n                if p[j-1] == '*':\\n                    dp[i%k][j] = dp[i%k][j-2] or (dp[(i-1)%k][j] and (s[i-1]==p[j-2] or p[j-2] == '.'))\\n                else:\\n                    dp[i%k][j] = dp[(i-1)%k][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.')\\n        return dp[len(s)%k][len(p)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5841,
                "title": "a-pattern-based-dp-solution-in-c-best-submission-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) \\n    {\\n        int sLen = s.length(), pLen = p.length();\\n        int match[pLen+1][sLen+1];\\n        memset(match, 0, sizeof(int)*(pLen+1)*(sLen+1));\\n        match[0][0] = 1;\\n        for(int i = 2; i <= pLen; i += 2)\\n            if(p[i-1] == '*') match[i][0] = 1; else break;\\n        for(int i = 1; i <= pLen; ++i)\\n        {\\n            if(p[i-1] == '*')\\n                for(int j = 1; j <= sLen; ++j)\\n                    match[i][j] = match[i-2][j] || ((p[i-2]=='.' || p[i-2]==s[j-1]) && match[i][j-1]);\\n            else\\n                for(int j = 1; j <= sLen; ++j)\\n                    match[i][j] = match[i-1][j-1] && (p[i-1]=='.' || p[i-1]==s[j-1]);\\n        }\\n        return match[pLen][sLen];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) \\n    {\\n        int sLen = s.length(), pLen = p.length();\\n        int match[pLen+1][sLen+1];\\n        memset(match, 0, sizeof(int)*(pLen+1)*(sLen+1));\\n        match[0][0] = 1;\\n        for(int i = 2; i <= pLen; i += 2)\\n            if(p[i-1] == '*') match[i][0] = 1; else break;\\n        for(int i = 1; i <= pLen; ++i)\\n        {\\n            if(p[i-1] == '*')\\n                for(int j = 1; j <= sLen; ++j)\\n                    match[i][j] = match[i-2][j] || ((p[i-2]=='.' || p[i-2]==s[j-1]) && match[i][j-1]);\\n            else\\n                for(int j = 1; j <= sLen; ++j)\\n                    match[i][j] = match[i-1][j-1] && (p[i-1]=='.' || p[i-1]==s[j-1]);\\n        }\\n        return match[pLen][sLen];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 5893,
                "title": "my-20ms-c-solution-in-10-lines",
                "content": "    bool isMatch(char* s, char* p) {\\n        while (*s) {\\n            if (*p&&*(p+1)=='*') {\\n                if (!(*p==*s||*p=='.')) {p+=2;continue;} \\n                if (!isMatch(s,p+2)) {s++;continue;} else return true;\\n            }\\n            if (*p==*s||*p=='.') {s++;p++;continue;}\\n            return false;\\n        }\\n        while(*p&&*(p+1)=='*') p+=2;\\n        return !*p;\\n}",
                "solutionTags": [],
                "code": "    bool isMatch(char* s, char* p) {\\n        while (*s) {\\n            if (*p&&*(p+1)=='*') {\\n                if (!(*p==*s||*p=='.')) {p+=2;continue;} \\n                if (!isMatch(s,p+2)) {s++;continue;} else return true;\\n            }\\n            if (*p==*s||*p=='.') {s++;p++;continue;}\\n            return false;\\n        }\\n        while(*p&&*(p+1)=='*') p+=2;\\n        return !*p;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 5895,
                "title": "4-ms-c-recursion-with-memorization-o-mn-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        bool helper(string &s, int i, string &p, int j, vector<vector<int>> &f) {\\n            if (f[i][j] != -1)\\n                return f[i][j];\\n            \\n            if (j == p.length())\\n                f[i][j] = (i == s.length());\\n            else if (j + 1 < p.length() && p[j + 1] == '*')\\n                f[i][j] = helper(s, i, p, j + 2, f) || i < s.length() && (s[i] == p[j] || p[j] == '.') && helper(s, i + 1, p, j, f);\\n            else\\n                f[i][j] = i < s.length() && (s[i] == p[j] || p[j] == '.') && helper(s, i + 1, p, j + 1, f);\\n            \\n            return f[i][j];\\n        }\\n        \\n        bool isMatch(string s, string p) {\\n            vector<vector<int>> f(s.length() + 1, vector<int>(p.length() + 1, -1));\\n            return helper(s, 0, p, 0, f);\\n        }\\n    };\\n\\n\\nIt was based on the recursion solution of:\\nhttps://leetcode.com/discuss/18970/concise-recursive-and-dp-solutions-with-full-explanation-in\\n\\n1) Every element in the 2D memorization array would be assigned a value for at most once;\\n2) no need to calculate unnecessary elements in 2D array.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool helper(string &s, int i, string &p, int j, vector<vector<int>> &f) {\\n            if (f[i][j] != -1)\\n                return f[i][j];\\n            \\n            if (j == p.length())\\n                f[i][j] = (i == s.length());\\n            else if (j + 1 < p.length() && p[j + 1] == '*')\\n                f[i][j] = helper(s, i, p, j + 2, f) || i < s.length() && (s[i] == p[j] || p[j] == '.') && helper(s, i + 1, p, j, f);\\n            else\\n                f[i][j] = i < s.length() && (s[i] == p[j] || p[j] == '.') && helper(s, i + 1, p, j + 1, f);\\n            \\n            return f[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3913892,
                "title": "2-line",
                "content": "\\n# Code\\n```\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsMatch(string s, string p) {\\n        if(p.Contains(\"**\"))\\n            return true;\\n        return Regex.IsMatch(s, \"^\"+p+\"$\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Text.RegularExpressions;\\npublic class Solution {\\n    public bool IsMatch(string s, string p) {\\n        if(p.Contains(\"**\"))\\n            return true;\\n        return Regex.IsMatch(s, \"^\"+p+\"$\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364697,
                "title": "one-line-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        return re.match(fr\"^{p}$\", s) is not None\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        return re.match(fr\"^{p}$\", s) is not None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364264,
                "title": "golang-solution",
                "content": "```\\npackage main\\n\\nfunc isMatch(s string, p string) bool {\\n\\ts = \" \" + s\\n\\tp = \" \" + p\\n\\n\\tm := len(p)\\n\\tn := len(s)\\n\\n\\tdp := createBool2dSlice(m, n)\\n\\tdp[0][0] = true\\n\\tfor i := 1; i < m; i++ {\\n\\t\\tif p[i] == \\'*\\' {\\n\\t\\t\\tdp[i][0] = dp[i-2][0]\\n\\t\\t}\\n\\t\\tfor j := 1; j < n; j++ {\\n\\t\\t\\tif p[i] == s[j] || p[i] == \\'.\\' {\\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1]\\n\\t\\t\\t} else if p[i] == \\'*\\' {\\n\\t\\t\\t\\tdp[i][j] = dp[i-2][j] || ((p[i-1] == s[j] || p[i-1] == \\'.\\') && dp[i][j-1])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m-1][n-1]\\n}\\n\\nfunc createBool2dSlice(m int, n int) [][]bool {\\n\\tans := make([][]bool, m)\\n\\tfor i := range ans {\\n\\t\\tans[i] = make([]bool, n)\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nfunc isMatch(s string, p string) bool {\\n\\ts = \" \" + s\\n\\tp = \" \" + p\\n\\n\\tm := len(p)\\n\\tn := len(s)\\n\\n\\tdp := createBool2dSlice(m, n)\\n\\tdp[0][0] = true\\n\\tfor i := 1; i < m; i++ {\\n\\t\\tif p[i] == \\'*\\' {\\n\\t\\t\\tdp[i][0] = dp[i-2][0]\\n\\t\\t}\\n\\t\\tfor j := 1; j < n; j++ {\\n\\t\\t\\tif p[i] == s[j] || p[i] == \\'.\\' {\\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1]\\n\\t\\t\\t} else if p[i] == \\'*\\' {\\n\\t\\t\\t\\tdp[i][j] = dp[i-2][j] || ((p[i-1] == s[j] || p[i-1] == \\'.\\') && dp[i][j-1])\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m-1][n-1]\\n}\\n\\nfunc createBool2dSlice(m int, n int) [][]bool {\\n\\tans := make([][]bool, m)\\n\\tfor i := range ans {\\n\\t\\tans[i] = make([]bool, n)\\n\\t}\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3189011,
                "title": "2-ms-faster-than-86-76-java-solution",
                "content": "Hi, this is my first leetcode solution.\\n\\n# Explaination\\nThe idea is to use a dynamic programming approach where we create a 2D boolean array dp of size (m+1) x (n+1) where m is the length of the string s and n is the length of the pattern p. dp[i][j] represents whether the substring of s from index 0 to i-1 matches the substring of p from index 0 to j-1.\\n\\nWe start by initializing dp[0][0] to true because an empty string matches an empty pattern. We also initialize the first row of dp based on the pattern. If p[j-1] is \\'*\\', then we can ignore the preceding character and see if the pattern matches the string without it. If p[j-1] is not \\'*\\', then the first character of the pattern must match the first character of the string, so dp[0][j] is false.\\n\\nFor each dp[i][j], we check if the current characters in s and p match, or if the current character in p is a . that can match any character. If they match, then dp[i][j] is the same as dp[i-1][j-1]. If the current character in p is \\'*\\', then we have two options: either we ignore the preceding character in p and see if the remaining pattern matches the current substring of s (in this case, dp[i][j] is the same as dp[i][j-2]), or we can repeat the preceding character and see if the resulting pattern matches the current substring of s (in this case, dp[i][j] is the same as dp[i-1][j] if the preceding character matches the current character in s, otherwise it is false).\\n\\nFinally, we return dp[m][n], which indicates whether the entire string s matches the entire pattern p.\\n```\\npublic boolean isMatch(String s, String p) {\\n        int m = s.length();\\n        int n = p.length();\\n        boolean[][] dp = new boolean[m+1][n+1];\\n        dp[0][0] = true;\\n        for (int i = 1; i <= n; i++) {\\n            if (p.charAt(i-1) == \\'*\\') {\\n                dp[0][i] = dp[0][i-2];\\n            }\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (p.charAt(j-1) == \\'.\\' || p.charAt(j-1) == s.charAt(i-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else if (p.charAt(j-1) == \\'*\\') {\\n                    dp[i][j] = dp[i][j-2];\\n                    if (p.charAt(j-2) == \\'.\\' || p.charAt(j-2) == s.charAt(i-1)) {\\n                        dp[i][j] = dp[i][j] || dp[i-1][j];\\n                    }\\n                } else {\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\\nUpvote if you like the solution.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isMatch(String s, String p) {\\n        int m = s.length();\\n        int n = p.length();\\n        boolean[][] dp = new boolean[m+1][n+1];\\n        dp[0][0] = true;\\n        for (int i = 1; i <= n; i++) {\\n            if (p.charAt(i-1) == \\'*\\') {\\n                dp[0][i] = dp[0][i-2];\\n            }\\n        }\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 1; j <= n; j++) {\\n                if (p.charAt(j-1) == \\'.\\' || p.charAt(j-1) == s.charAt(i-1)) {\\n                    dp[i][j] = dp[i-1][j-1];\\n                } else if (p.charAt(j-1) == \\'*\\') {\\n                    dp[i][j] = dp[i][j-2];\\n                    if (p.charAt(j-2) == \\'.\\' || p.charAt(j-2) == s.charAt(i-1)) {\\n                        dp[i][j] = dp[i][j] || dp[i-1][j];\\n                    }\\n                } else {\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162298,
                "title": "java-regex-solution",
                "content": "simple three line solution by using regex in java. but this solution was not so fair because it beats only 28% time and it takes 48ms to complete. \\n\\n- Time complexity: `O(n^2)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n^2)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.regex.*;\\n\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        \\n        if(p.equals(\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"))\\n        return false;\\n\\n        return s.matches(\"^\" + p + \"$\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.regex.*;\\n\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        \\n        if(p.equals(\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"))\\n        return false;\\n\\n        return s.matches(\"^\" + p + \"$\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564591,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1566604,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1565224,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1565477,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1566732,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1567161,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1576782,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1567709,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1565521,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1566822,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1564591,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1566604,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1565224,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1565477,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1566732,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1567161,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1576782,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1567709,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1565521,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1566822,
                "content": [
                    {
                        "username": "shawnForsythe",
                        "content": "In the given examples, the last one `isMatch(\"aab\", \"c*a*b\") \\u2192 true`; don't understand why these two strings matches?\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "Hyperblaze456",
                        "content": "i think this is true because there are two a\\'s and one b on the given string s, and the pattern says that a, b, c could exist on the string s"
                    },
                    {
                        "username": "Tusharrathore",
                        "content": "I Think my answer is correct.\\nif * comes after any character, it can be 0 also, i mean if a* is writen NULL value will also be consider, so c* can be NULL."
                    },
                    {
                        "username": "filiptodev",
                        "content": "'*' denotes zero or more of a character. So zero or more of 'c', then zero or more of 'a', and then exactly 1 'b'. So from the beginning:\nZero or more of 'c'? Check, there are zero 'c'\nThen zero or more of 'a'? Check, there are 2 'a'\nThen finally exactly 1 'b'? Check, there is 1 'b'"
                    },
                    {
                        "username": "hatrungquyen89",
                        "content": "Yeah, at first i read the problem I fail at the exact same test as you. It should be described clearer that is c* is a whole, this mean that this is ether no \\'c\\' or a lot of \\'c\\', not one \\'c\\' only and \\'c\\' with a lot of c follow it. So confusing, the stupid test case cost me an hour to realize. "
                    },
                    {
                        "username": "rk_161",
                        "content": "In ```c*a*b```, c* means 0 more than 0 'c' at the start of string, similarly a* means 0 more than 0 'a', then b means only one b\nSo in this case, it matches due to presence of 0 c then 2 a the 1 b."
                    },
                    {
                        "username": "UsamaShahzad",
                        "content": "Same as they are partially same not entirely same"
                    },
                    {
                        "username": "crash-burn",
                        "content": "this test case makes no logical sense!"
                    },
                    {
                        "username": "pratyushmishra7",
                        "content": "c can appear at any times a as well and bcan appear only one time so c is 0 a is 2 and b is 1 therefore its true"
                    },
                    {
                        "username": "nadavhoro",
                        "content": "[@Vaibhav0](/Vaibhav0) c* -> c can appear 0 or more times, in this case it doesn\\'t.\\nthen a* -> a can appear 0 or more times, which appears 2 times.\\nfollowed by \"b\" which must appear once (it isn\\'t followed by \"*\")"
                    },
                    {
                        "username": "vaibhav_0911",
                        "content": "Same herer brooo.\\n"
                    },
                    {
                        "username": "xelab04",
                        "content": "[@Kit_Kat12](/Kit_Kat12) Oh... Thank you, that\\'s helped me tremendously! I totally misunderstood the question!"
                    },
                    {
                        "username": "aruuu____",
                        "content": "c* means any combination /any number of c(according to Kleen closure)..that is it can be 0 also, a* means any combinations of a and so aa is accepted and one b is there"
                    },
                    {
                        "username": "ruturaj_dm",
                        "content": "c* = 0 occurrence +\\na* = 2 occurrences +\\nb = 1 occurrence\\n\\nWhich makes \"aab\""
                    },
                    {
                        "username": "akshithreddystd",
                        "content": "[@aprekshamathur](/aprekshamathur) \\nisMatch(\"aab\", \"c*a*b\")     isMatch(String s, String p) \\n\\nit is not given that p should be same as s\\np should contain s"
                    },
                    {
                        "username": "Kit_Kat12",
                        "content": "When You But * After A Letter It Means The Letter Behind * Could Be fount 0 Or More Then 1 time So c Is Not In aab a Is included Two Times And b Is Included (1)"
                    },
                    {
                        "username": "mengjiuxi",
                        "content": "[@aprekshamathur](/aprekshamathur) I\\'m not a native speaker, but to me, zero of the preceding element seems more like * itself is matching to an empty string, rather than c* matching to an empty string. I guess I will just have to remember this expression."
                    },
                    {
                        "username": "urbanowi",
                        "content": " **Matches zero or more of the preceding element. \nKey word is ZERO"
                    },
                    {
                        "username": "aprekshamathur",
                        "content": "c* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string \\na* will be considered as aa\\nso p = aab hence it matches with s."
                    },
                    {
                        "username": "pratt06",
                        "content": "Test case\\ns = \"ab\"\\np =  .*\\n\\n.* is equivalent to \"\", \".\", \"..\", \"...\" so on. And then each \".\" can be replaced with a different character.\\n\\nThat\\'s why for this test case output is: true"
                    },
                    {
                        "username": "Gi-Totev",
                        "content": "[@james1c1](/james1c1)  You\\'re correct. The Constraints say: 1 <= s <= 20, so an empty string will never be the input. \\nHowever\\nIf you write \\'\\'.match(/.*/) in the browser console, on the other hand, it does return a match. \\nIf you write \\'\\'.match(/./) instead, it returns null.\\nI\\'m not sure about other languages"
                    },
                    {
                        "username": "james1c1",
                        "content": "not sure if \"\" should be included"
                    },
                    {
                        "username": "issac2e",
                        "content": "thanks a lot"
                    },
                    {
                        "username": "cherry.cheng.3720",
                        "content": "Here is the output:\\n\\nInput:\\t\"ab\", \".*\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you\\'re only given \\'.*\\', then any number of anything is correct. So any string is valid, even an empty one.\\n\\'.*\\' does NOT mean any number of a single random character, so if the first letter is \\'a\\' that doesn\\'t mean that the next characters have to be \\'a\\', they could be anything, or nothing."
                    },
                    {
                        "username": "Mahammad_ahmadov2",
                        "content": "( dot ) -> only single char element - a in the 0th index,\n( star ) ->  multi char elements or single char element - b in the 1th index\nit's true i mean "
                    },
                    {
                        "username": "JayFang1993",
                        "content": "In the problem example case:\\nisMatch(\"ab\", \".*\") \\u2192 true\\n\\nwhile the Input (\"ab\", \".*c\") Expected output is false??"
                    },
                    {
                        "username": "filiptodev",
                        "content": "If you isolate the \\'*\\' with it\\'s preceding character, then you\\'ll get a better understanding of why it\\'s false:\\nLet\\'s replace \\'.*\\' with [?] denoting any number of any character, or none. Then we have:\\n[?]c\\nWhich means any character (or nothing) at the beginning, but it must end with \\'c\\'"
                    },
                    {
                        "username": "Bala_1543",
                        "content": "[@euthiago](/euthiago) considering \".\" multiple times . it can be matched to any given char in s"
                    },
                    {
                        "username": "rk_161",
                        "content": "It results in false, because ```.*``` and ```.*c``` are different, former could be any string, but latter resembles the string that must end with \\'c\\'."
                    },
                    {
                        "username": "euthiago",
                        "content": ".* matches any char, any number of times, so any input results in true\n.*c matches any char, any number of times FOLLOWED by one single \"c\"\nso all inputs that end with \"c\" are valid matches and any other input is not a valid match"
                    },
                    {
                        "username": "wonderflow",
                        "content": "I'm not very understand why?\\n\\nCould someone explain for me? Thanks!\\n\\n383 / 445 test cases passed.\\n\\nInput:\\t\"aaa\", \"ab\\\\*ac\\\\*a\"\\nOutput:\\tfalse\\nExpected:\\ttrue"
                    },
                    {
                        "username": "nik216",
                        "content": "[@5tarfir3](/5tarfir3)  bro just read the question again there it says that a* means a can come zero times, one times or more than 1 times, now,\\nIn ab*a*c*a = \"aaa\"\\nhere b* comes 0 times,\\n         a* comes 1 times,\\n         c* comes o times\\nthats while all these conditions are true ...\\n         "
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@5tarfir3](/5tarfir3) any char have \\'*\\' next to it can be present none, once or more than once in given string s..here b and c are totally absent ..so its true"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "I'm stuck on a similar test case, s=\"aaa\" and p=\"ab* a* c* a\"  \nHow do I know the \"a*\" in the middle of p should be considered as \"a\" instead of \"aa\" in s before knowing that there's one more \"a\" in the end of p?\nIs there a way to solve this other than running all the possible cases of \"a*\"?"
                    },
                    {
                        "username": "hrshihab10",
                        "content": "b* means either empty string or b, bb, bbb, ....... hence b* will be considered as empty string\nc* means either empty string or c, cc, ccc, ....... hence c* will be considered as empty string\n"
                    },
                    {
                        "username": "purpleman233",
                        "content": "\"b*\" and \"c*\" can both be \"\""
                    },
                    {
                        "username": "jiong2",
                        "content": "Why \"aab\" match \"c\\\\*a\\\\*b\"?\\nshould not \"c\\\\*a\\\\*b\" match something start with a \"c\"?\\n\\nThank you very much for clarifying this!"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "You can read this as:\\nzero or more number of \"c\" followed by zero or more number of \"a\" followed by a single b "
                    },
                    {
                        "username": "kuelf",
                        "content": "c\\*a\\*b doesn't need to start with a c. \\* means none or many."
                    },
                    {
                        "username": "weindiancoders",
                        "content": "Input:\\n\"mississippi\"\\n\"mis* is * p *. \"\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\n\\nCan anyone explain me please , why expected output is false here."
                    },
                    {
                        "username": "PriyadarseenyPasayat",
                        "content": "[@Karthik_Balaji_V](/Karthik_Balaji_V) But isn\\'t dot(.) supposed to match any single character"
                    },
                    {
                        "username": "ayannn_",
                        "content": "in the pattern part \" mis* \" is ok as 's' can be repeated as many time \n\nmis* --> miss\n\nin the \" is* \" part it is also okay  as here also ' s ' can be repeated as many times \n\nmis*is* --> mississ\n\nbut just after ' * ' there is    \" p*.\" here comes the problem as in the pattern part there is no ' i ' before \" p*. \" so it will not result into the string that is to be obtained.\n\nmis*is*p*. --> mississppi.  != mississippi"
                    },
                    {
                        "username": "Karthik_Balaji_V",
                        "content": "\\'i\\' fourth character from the end of the string is missing."
                    },
                    {
                        "username": "Francesyfy",
                        "content": "Input:\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue"
                    },
                    {
                        "username": "athravmehta06",
                        "content": "c* can also be null, so you are left with only a*b which can produce \"aab\""
                    },
                    {
                        "username": "jack11",
                        "content": "My code is wrong, but the test case input just one string , is the string mean the partial or input?"
                    },
                    {
                        "username": "rocket_wind",
                        "content": "s = \"ab\"\\np = \".*\"\\n\\n\".\" means it matches any single character and \" * \" means it matches 0 or more occurence of the preceding character.\\nSo, if we take the value of \".\" as \"a\", then \\np = \"a *\" => p = \"aaaaa....\"\\np is a sequence of same characters. there cant be separate characters in p.\\nso, p wont have s as its substring."
                    }
                ]
            },
            {
                "id": 1568366,
                "content": [
                    {
                        "username": "harsh3226",
                        "content": "This is my code\\nif it is valid for \"ab\"\\n\".*\"   why it is showing wrong for \\n \"ab\" \".*c\""
                    },
                    {
                        "username": "Manhattim",
                        "content": "Hi All,\\nShouldn\\'t s=\"aaa\" p=\"a*a\"eveluate to False?  \\nas the first \"a\\\\*\" is greedy and would consume the whole \\'s\\' leaving an evaluation of s=\\'\\' and p=\\'a\\'"
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "I think that\\'s the trickiest part of the test. `a*` is greedy but _until_ the last occurrence of `a`.\\n\\nThe similar case: pattern `.*abc` matches `123abc` but doesn\\'t match `123` even having `.*` greedy."
                    },
                    {
                        "username": "newbaby",
                        "content": "is this case valid? i.e. *p=\".*********************************\", *p=\"afava.*******cdada\""
                    },
                    {
                        "username": "ravidl",
                        "content": "Wrong Answer\\nDetails \\nInput\\n\"ab\"\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@Subhajit_Lai](/Subhajit_Lai) \".*c\" requires the string to end with \"c\", which \"ab\" doesn\\'t meet"
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "anyone can help with the logic please"
                    },
                    {
                        "username": "Metody",
                        "content": "Yup but\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\ntrue\\nExpected\\ntrue\\n\\nI have no idea what\\'s the logic behind these test cases."
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "How is the .* regular expression evaluated for input string ab?\\na matches to . (which is any character once) - so good\\nbut b matches * (which is n occurrences of previous character) which is \\'a\\' here. \\nSo how is this evaluated to true?"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "\".\" present a single character and *  Matches zero or more of the preceding element, so .* can be \"aa\" or \"bb\" , how can it present ab?"
                    },
                    {
                        "username": "wrares",
                        "content": "input : \"ab\"\\n           \".*c\"\\nshouldn\\'t this be true since \".*c\" can be \"..c\" the .. part match with \"ab\"?"
                    },
                    {
                        "username": "LucHuang",
                        "content": "No matter \"aa\" is the pattern or the string, match \"aa\" with \"\" or \"\" with \"aa\" should always yield to false. Therefore, the judge has a wrong answer at the first place."
                    },
                    {
                        "username": "atulkumartata",
                        "content": "input: s : \"aab\" p: \"c^a^b\"\\n\\nI\\'ve replaced the asterisk with ^ because the editor is interpreting it as italic text.\\n\\nOutput:false\\nExpected:true\\n\\n\\nHow can can the first \\'c\\' from pattern match with \\'a\\' from s? Am I misinterpreting the question here? \\n"
                    },
                    {
                        "username": "rulinsun",
                        "content": "Can anyone explain why this case expects output of \"true\"?\\n\"mississippi\"\\n\"mis\\\\*is\\\\*ip*.\"\\n\\n"
                    },
                    {
                        "username": "Cha0ticAnt",
                        "content": "Hello. This is comment is old but there\\'s no reply on it. One way to explain it is, starting at the back, the dot can match the final i. The p* can match pp, the \\'i\\' matches normally, s* matches \"ss\", another \\'i\\' matches normally, another \"s*\" for \"ss\", and the \"mi\" at the beginning match normally. So the pattern matches \\'s\\', so the output should be \"true\". I think the tricky part is the dot at the end. It\\'s a wildcard and handles the \\'i\\' at the end."
                    }
                ]
            },
            {
                "id": 1567331,
                "content": [
                    {
                        "username": "harsh3226",
                        "content": "This is my code\\nif it is valid for \"ab\"\\n\".*\"   why it is showing wrong for \\n \"ab\" \".*c\""
                    },
                    {
                        "username": "Manhattim",
                        "content": "Hi All,\\nShouldn\\'t s=\"aaa\" p=\"a*a\"eveluate to False?  \\nas the first \"a\\\\*\" is greedy and would consume the whole \\'s\\' leaving an evaluation of s=\\'\\' and p=\\'a\\'"
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "I think that\\'s the trickiest part of the test. `a*` is greedy but _until_ the last occurrence of `a`.\\n\\nThe similar case: pattern `.*abc` matches `123abc` but doesn\\'t match `123` even having `.*` greedy."
                    },
                    {
                        "username": "newbaby",
                        "content": "is this case valid? i.e. *p=\".*********************************\", *p=\"afava.*******cdada\""
                    },
                    {
                        "username": "ravidl",
                        "content": "Wrong Answer\\nDetails \\nInput\\n\"ab\"\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@Subhajit_Lai](/Subhajit_Lai) \".*c\" requires the string to end with \"c\", which \"ab\" doesn\\'t meet"
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "anyone can help with the logic please"
                    },
                    {
                        "username": "Metody",
                        "content": "Yup but\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\ntrue\\nExpected\\ntrue\\n\\nI have no idea what\\'s the logic behind these test cases."
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "How is the .* regular expression evaluated for input string ab?\\na matches to . (which is any character once) - so good\\nbut b matches * (which is n occurrences of previous character) which is \\'a\\' here. \\nSo how is this evaluated to true?"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "\".\" present a single character and *  Matches zero or more of the preceding element, so .* can be \"aa\" or \"bb\" , how can it present ab?"
                    },
                    {
                        "username": "wrares",
                        "content": "input : \"ab\"\\n           \".*c\"\\nshouldn\\'t this be true since \".*c\" can be \"..c\" the .. part match with \"ab\"?"
                    },
                    {
                        "username": "LucHuang",
                        "content": "No matter \"aa\" is the pattern or the string, match \"aa\" with \"\" or \"\" with \"aa\" should always yield to false. Therefore, the judge has a wrong answer at the first place."
                    },
                    {
                        "username": "atulkumartata",
                        "content": "input: s : \"aab\" p: \"c^a^b\"\\n\\nI\\'ve replaced the asterisk with ^ because the editor is interpreting it as italic text.\\n\\nOutput:false\\nExpected:true\\n\\n\\nHow can can the first \\'c\\' from pattern match with \\'a\\' from s? Am I misinterpreting the question here? \\n"
                    },
                    {
                        "username": "rulinsun",
                        "content": "Can anyone explain why this case expects output of \"true\"?\\n\"mississippi\"\\n\"mis\\\\*is\\\\*ip*.\"\\n\\n"
                    },
                    {
                        "username": "Cha0ticAnt",
                        "content": "Hello. This is comment is old but there\\'s no reply on it. One way to explain it is, starting at the back, the dot can match the final i. The p* can match pp, the \\'i\\' matches normally, s* matches \"ss\", another \\'i\\' matches normally, another \"s*\" for \"ss\", and the \"mi\" at the beginning match normally. So the pattern matches \\'s\\', so the output should be \"true\". I think the tricky part is the dot at the end. It\\'s a wildcard and handles the \\'i\\' at the end."
                    }
                ]
            },
            {
                "id": 1566733,
                "content": [
                    {
                        "username": "harsh3226",
                        "content": "This is my code\\nif it is valid for \"ab\"\\n\".*\"   why it is showing wrong for \\n \"ab\" \".*c\""
                    },
                    {
                        "username": "Manhattim",
                        "content": "Hi All,\\nShouldn\\'t s=\"aaa\" p=\"a*a\"eveluate to False?  \\nas the first \"a\\\\*\" is greedy and would consume the whole \\'s\\' leaving an evaluation of s=\\'\\' and p=\\'a\\'"
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "I think that\\'s the trickiest part of the test. `a*` is greedy but _until_ the last occurrence of `a`.\\n\\nThe similar case: pattern `.*abc` matches `123abc` but doesn\\'t match `123` even having `.*` greedy."
                    },
                    {
                        "username": "newbaby",
                        "content": "is this case valid? i.e. *p=\".*********************************\", *p=\"afava.*******cdada\""
                    },
                    {
                        "username": "ravidl",
                        "content": "Wrong Answer\\nDetails \\nInput\\n\"ab\"\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@Subhajit_Lai](/Subhajit_Lai) \".*c\" requires the string to end with \"c\", which \"ab\" doesn\\'t meet"
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "anyone can help with the logic please"
                    },
                    {
                        "username": "Metody",
                        "content": "Yup but\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\ntrue\\nExpected\\ntrue\\n\\nI have no idea what\\'s the logic behind these test cases."
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "How is the .* regular expression evaluated for input string ab?\\na matches to . (which is any character once) - so good\\nbut b matches * (which is n occurrences of previous character) which is \\'a\\' here. \\nSo how is this evaluated to true?"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "\".\" present a single character and *  Matches zero or more of the preceding element, so .* can be \"aa\" or \"bb\" , how can it present ab?"
                    },
                    {
                        "username": "wrares",
                        "content": "input : \"ab\"\\n           \".*c\"\\nshouldn\\'t this be true since \".*c\" can be \"..c\" the .. part match with \"ab\"?"
                    },
                    {
                        "username": "LucHuang",
                        "content": "No matter \"aa\" is the pattern or the string, match \"aa\" with \"\" or \"\" with \"aa\" should always yield to false. Therefore, the judge has a wrong answer at the first place."
                    },
                    {
                        "username": "atulkumartata",
                        "content": "input: s : \"aab\" p: \"c^a^b\"\\n\\nI\\'ve replaced the asterisk with ^ because the editor is interpreting it as italic text.\\n\\nOutput:false\\nExpected:true\\n\\n\\nHow can can the first \\'c\\' from pattern match with \\'a\\' from s? Am I misinterpreting the question here? \\n"
                    },
                    {
                        "username": "rulinsun",
                        "content": "Can anyone explain why this case expects output of \"true\"?\\n\"mississippi\"\\n\"mis\\\\*is\\\\*ip*.\"\\n\\n"
                    },
                    {
                        "username": "Cha0ticAnt",
                        "content": "Hello. This is comment is old but there\\'s no reply on it. One way to explain it is, starting at the back, the dot can match the final i. The p* can match pp, the \\'i\\' matches normally, s* matches \"ss\", another \\'i\\' matches normally, another \"s*\" for \"ss\", and the \"mi\" at the beginning match normally. So the pattern matches \\'s\\', so the output should be \"true\". I think the tricky part is the dot at the end. It\\'s a wildcard and handles the \\'i\\' at the end."
                    }
                ]
            },
            {
                "id": 1570854,
                "content": [
                    {
                        "username": "harsh3226",
                        "content": "This is my code\\nif it is valid for \"ab\"\\n\".*\"   why it is showing wrong for \\n \"ab\" \".*c\""
                    },
                    {
                        "username": "Manhattim",
                        "content": "Hi All,\\nShouldn\\'t s=\"aaa\" p=\"a*a\"eveluate to False?  \\nas the first \"a\\\\*\" is greedy and would consume the whole \\'s\\' leaving an evaluation of s=\\'\\' and p=\\'a\\'"
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "I think that\\'s the trickiest part of the test. `a*` is greedy but _until_ the last occurrence of `a`.\\n\\nThe similar case: pattern `.*abc` matches `123abc` but doesn\\'t match `123` even having `.*` greedy."
                    },
                    {
                        "username": "newbaby",
                        "content": "is this case valid? i.e. *p=\".*********************************\", *p=\"afava.*******cdada\""
                    },
                    {
                        "username": "ravidl",
                        "content": "Wrong Answer\\nDetails \\nInput\\n\"ab\"\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@Subhajit_Lai](/Subhajit_Lai) \".*c\" requires the string to end with \"c\", which \"ab\" doesn\\'t meet"
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "anyone can help with the logic please"
                    },
                    {
                        "username": "Metody",
                        "content": "Yup but\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\ntrue\\nExpected\\ntrue\\n\\nI have no idea what\\'s the logic behind these test cases."
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "How is the .* regular expression evaluated for input string ab?\\na matches to . (which is any character once) - so good\\nbut b matches * (which is n occurrences of previous character) which is \\'a\\' here. \\nSo how is this evaluated to true?"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "\".\" present a single character and *  Matches zero or more of the preceding element, so .* can be \"aa\" or \"bb\" , how can it present ab?"
                    },
                    {
                        "username": "wrares",
                        "content": "input : \"ab\"\\n           \".*c\"\\nshouldn\\'t this be true since \".*c\" can be \"..c\" the .. part match with \"ab\"?"
                    },
                    {
                        "username": "LucHuang",
                        "content": "No matter \"aa\" is the pattern or the string, match \"aa\" with \"\" or \"\" with \"aa\" should always yield to false. Therefore, the judge has a wrong answer at the first place."
                    },
                    {
                        "username": "atulkumartata",
                        "content": "input: s : \"aab\" p: \"c^a^b\"\\n\\nI\\'ve replaced the asterisk with ^ because the editor is interpreting it as italic text.\\n\\nOutput:false\\nExpected:true\\n\\n\\nHow can can the first \\'c\\' from pattern match with \\'a\\' from s? Am I misinterpreting the question here? \\n"
                    },
                    {
                        "username": "rulinsun",
                        "content": "Can anyone explain why this case expects output of \"true\"?\\n\"mississippi\"\\n\"mis\\\\*is\\\\*ip*.\"\\n\\n"
                    },
                    {
                        "username": "Cha0ticAnt",
                        "content": "Hello. This is comment is old but there\\'s no reply on it. One way to explain it is, starting at the back, the dot can match the final i. The p* can match pp, the \\'i\\' matches normally, s* matches \"ss\", another \\'i\\' matches normally, another \"s*\" for \"ss\", and the \"mi\" at the beginning match normally. So the pattern matches \\'s\\', so the output should be \"true\". I think the tricky part is the dot at the end. It\\'s a wildcard and handles the \\'i\\' at the end."
                    }
                ]
            },
            {
                "id": 1567507,
                "content": [
                    {
                        "username": "harsh3226",
                        "content": "This is my code\\nif it is valid for \"ab\"\\n\".*\"   why it is showing wrong for \\n \"ab\" \".*c\""
                    },
                    {
                        "username": "Manhattim",
                        "content": "Hi All,\\nShouldn\\'t s=\"aaa\" p=\"a*a\"eveluate to False?  \\nas the first \"a\\\\*\" is greedy and would consume the whole \\'s\\' leaving an evaluation of s=\\'\\' and p=\\'a\\'"
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "I think that\\'s the trickiest part of the test. `a*` is greedy but _until_ the last occurrence of `a`.\\n\\nThe similar case: pattern `.*abc` matches `123abc` but doesn\\'t match `123` even having `.*` greedy."
                    },
                    {
                        "username": "newbaby",
                        "content": "is this case valid? i.e. *p=\".*********************************\", *p=\"afava.*******cdada\""
                    },
                    {
                        "username": "ravidl",
                        "content": "Wrong Answer\\nDetails \\nInput\\n\"ab\"\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@Subhajit_Lai](/Subhajit_Lai) \".*c\" requires the string to end with \"c\", which \"ab\" doesn\\'t meet"
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "anyone can help with the logic please"
                    },
                    {
                        "username": "Metody",
                        "content": "Yup but\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\ntrue\\nExpected\\ntrue\\n\\nI have no idea what\\'s the logic behind these test cases."
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "How is the .* regular expression evaluated for input string ab?\\na matches to . (which is any character once) - so good\\nbut b matches * (which is n occurrences of previous character) which is \\'a\\' here. \\nSo how is this evaluated to true?"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "\".\" present a single character and *  Matches zero or more of the preceding element, so .* can be \"aa\" or \"bb\" , how can it present ab?"
                    },
                    {
                        "username": "wrares",
                        "content": "input : \"ab\"\\n           \".*c\"\\nshouldn\\'t this be true since \".*c\" can be \"..c\" the .. part match with \"ab\"?"
                    },
                    {
                        "username": "LucHuang",
                        "content": "No matter \"aa\" is the pattern or the string, match \"aa\" with \"\" or \"\" with \"aa\" should always yield to false. Therefore, the judge has a wrong answer at the first place."
                    },
                    {
                        "username": "atulkumartata",
                        "content": "input: s : \"aab\" p: \"c^a^b\"\\n\\nI\\'ve replaced the asterisk with ^ because the editor is interpreting it as italic text.\\n\\nOutput:false\\nExpected:true\\n\\n\\nHow can can the first \\'c\\' from pattern match with \\'a\\' from s? Am I misinterpreting the question here? \\n"
                    },
                    {
                        "username": "rulinsun",
                        "content": "Can anyone explain why this case expects output of \"true\"?\\n\"mississippi\"\\n\"mis\\\\*is\\\\*ip*.\"\\n\\n"
                    },
                    {
                        "username": "Cha0ticAnt",
                        "content": "Hello. This is comment is old but there\\'s no reply on it. One way to explain it is, starting at the back, the dot can match the final i. The p* can match pp, the \\'i\\' matches normally, s* matches \"ss\", another \\'i\\' matches normally, another \"s*\" for \"ss\", and the \"mi\" at the beginning match normally. So the pattern matches \\'s\\', so the output should be \"true\". I think the tricky part is the dot at the end. It\\'s a wildcard and handles the \\'i\\' at the end."
                    }
                ]
            },
            {
                "id": 1567379,
                "content": [
                    {
                        "username": "harsh3226",
                        "content": "This is my code\\nif it is valid for \"ab\"\\n\".*\"   why it is showing wrong for \\n \"ab\" \".*c\""
                    },
                    {
                        "username": "Manhattim",
                        "content": "Hi All,\\nShouldn\\'t s=\"aaa\" p=\"a*a\"eveluate to False?  \\nas the first \"a\\\\*\" is greedy and would consume the whole \\'s\\' leaving an evaluation of s=\\'\\' and p=\\'a\\'"
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "I think that\\'s the trickiest part of the test. `a*` is greedy but _until_ the last occurrence of `a`.\\n\\nThe similar case: pattern `.*abc` matches `123abc` but doesn\\'t match `123` even having `.*` greedy."
                    },
                    {
                        "username": "newbaby",
                        "content": "is this case valid? i.e. *p=\".*********************************\", *p=\"afava.*******cdada\""
                    },
                    {
                        "username": "ravidl",
                        "content": "Wrong Answer\\nDetails \\nInput\\n\"ab\"\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@Subhajit_Lai](/Subhajit_Lai) \".*c\" requires the string to end with \"c\", which \"ab\" doesn\\'t meet"
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "anyone can help with the logic please"
                    },
                    {
                        "username": "Metody",
                        "content": "Yup but\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\ntrue\\nExpected\\ntrue\\n\\nI have no idea what\\'s the logic behind these test cases."
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "How is the .* regular expression evaluated for input string ab?\\na matches to . (which is any character once) - so good\\nbut b matches * (which is n occurrences of previous character) which is \\'a\\' here. \\nSo how is this evaluated to true?"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "\".\" present a single character and *  Matches zero or more of the preceding element, so .* can be \"aa\" or \"bb\" , how can it present ab?"
                    },
                    {
                        "username": "wrares",
                        "content": "input : \"ab\"\\n           \".*c\"\\nshouldn\\'t this be true since \".*c\" can be \"..c\" the .. part match with \"ab\"?"
                    },
                    {
                        "username": "LucHuang",
                        "content": "No matter \"aa\" is the pattern or the string, match \"aa\" with \"\" or \"\" with \"aa\" should always yield to false. Therefore, the judge has a wrong answer at the first place."
                    },
                    {
                        "username": "atulkumartata",
                        "content": "input: s : \"aab\" p: \"c^a^b\"\\n\\nI\\'ve replaced the asterisk with ^ because the editor is interpreting it as italic text.\\n\\nOutput:false\\nExpected:true\\n\\n\\nHow can can the first \\'c\\' from pattern match with \\'a\\' from s? Am I misinterpreting the question here? \\n"
                    },
                    {
                        "username": "rulinsun",
                        "content": "Can anyone explain why this case expects output of \"true\"?\\n\"mississippi\"\\n\"mis\\\\*is\\\\*ip*.\"\\n\\n"
                    },
                    {
                        "username": "Cha0ticAnt",
                        "content": "Hello. This is comment is old but there\\'s no reply on it. One way to explain it is, starting at the back, the dot can match the final i. The p* can match pp, the \\'i\\' matches normally, s* matches \"ss\", another \\'i\\' matches normally, another \"s*\" for \"ss\", and the \"mi\" at the beginning match normally. So the pattern matches \\'s\\', so the output should be \"true\". I think the tricky part is the dot at the end. It\\'s a wildcard and handles the \\'i\\' at the end."
                    }
                ]
            },
            {
                "id": 1572454,
                "content": [
                    {
                        "username": "harsh3226",
                        "content": "This is my code\\nif it is valid for \"ab\"\\n\".*\"   why it is showing wrong for \\n \"ab\" \".*c\""
                    },
                    {
                        "username": "Manhattim",
                        "content": "Hi All,\\nShouldn\\'t s=\"aaa\" p=\"a*a\"eveluate to False?  \\nas the first \"a\\\\*\" is greedy and would consume the whole \\'s\\' leaving an evaluation of s=\\'\\' and p=\\'a\\'"
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "I think that\\'s the trickiest part of the test. `a*` is greedy but _until_ the last occurrence of `a`.\\n\\nThe similar case: pattern `.*abc` matches `123abc` but doesn\\'t match `123` even having `.*` greedy."
                    },
                    {
                        "username": "newbaby",
                        "content": "is this case valid? i.e. *p=\".*********************************\", *p=\"afava.*******cdada\""
                    },
                    {
                        "username": "ravidl",
                        "content": "Wrong Answer\\nDetails \\nInput\\n\"ab\"\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@Subhajit_Lai](/Subhajit_Lai) \".*c\" requires the string to end with \"c\", which \"ab\" doesn\\'t meet"
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "anyone can help with the logic please"
                    },
                    {
                        "username": "Metody",
                        "content": "Yup but\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\ntrue\\nExpected\\ntrue\\n\\nI have no idea what\\'s the logic behind these test cases."
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "How is the .* regular expression evaluated for input string ab?\\na matches to . (which is any character once) - so good\\nbut b matches * (which is n occurrences of previous character) which is \\'a\\' here. \\nSo how is this evaluated to true?"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "\".\" present a single character and *  Matches zero or more of the preceding element, so .* can be \"aa\" or \"bb\" , how can it present ab?"
                    },
                    {
                        "username": "wrares",
                        "content": "input : \"ab\"\\n           \".*c\"\\nshouldn\\'t this be true since \".*c\" can be \"..c\" the .. part match with \"ab\"?"
                    },
                    {
                        "username": "LucHuang",
                        "content": "No matter \"aa\" is the pattern or the string, match \"aa\" with \"\" or \"\" with \"aa\" should always yield to false. Therefore, the judge has a wrong answer at the first place."
                    },
                    {
                        "username": "atulkumartata",
                        "content": "input: s : \"aab\" p: \"c^a^b\"\\n\\nI\\'ve replaced the asterisk with ^ because the editor is interpreting it as italic text.\\n\\nOutput:false\\nExpected:true\\n\\n\\nHow can can the first \\'c\\' from pattern match with \\'a\\' from s? Am I misinterpreting the question here? \\n"
                    },
                    {
                        "username": "rulinsun",
                        "content": "Can anyone explain why this case expects output of \"true\"?\\n\"mississippi\"\\n\"mis\\\\*is\\\\*ip*.\"\\n\\n"
                    },
                    {
                        "username": "Cha0ticAnt",
                        "content": "Hello. This is comment is old but there\\'s no reply on it. One way to explain it is, starting at the back, the dot can match the final i. The p* can match pp, the \\'i\\' matches normally, s* matches \"ss\", another \\'i\\' matches normally, another \"s*\" for \"ss\", and the \"mi\" at the beginning match normally. So the pattern matches \\'s\\', so the output should be \"true\". I think the tricky part is the dot at the end. It\\'s a wildcard and handles the \\'i\\' at the end."
                    }
                ]
            },
            {
                "id": 1565654,
                "content": [
                    {
                        "username": "harsh3226",
                        "content": "This is my code\\nif it is valid for \"ab\"\\n\".*\"   why it is showing wrong for \\n \"ab\" \".*c\""
                    },
                    {
                        "username": "Manhattim",
                        "content": "Hi All,\\nShouldn\\'t s=\"aaa\" p=\"a*a\"eveluate to False?  \\nas the first \"a\\\\*\" is greedy and would consume the whole \\'s\\' leaving an evaluation of s=\\'\\' and p=\\'a\\'"
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "I think that\\'s the trickiest part of the test. `a*` is greedy but _until_ the last occurrence of `a`.\\n\\nThe similar case: pattern `.*abc` matches `123abc` but doesn\\'t match `123` even having `.*` greedy."
                    },
                    {
                        "username": "newbaby",
                        "content": "is this case valid? i.e. *p=\".*********************************\", *p=\"afava.*******cdada\""
                    },
                    {
                        "username": "ravidl",
                        "content": "Wrong Answer\\nDetails \\nInput\\n\"ab\"\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@Subhajit_Lai](/Subhajit_Lai) \".*c\" requires the string to end with \"c\", which \"ab\" doesn\\'t meet"
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "anyone can help with the logic please"
                    },
                    {
                        "username": "Metody",
                        "content": "Yup but\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\ntrue\\nExpected\\ntrue\\n\\nI have no idea what\\'s the logic behind these test cases."
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "How is the .* regular expression evaluated for input string ab?\\na matches to . (which is any character once) - so good\\nbut b matches * (which is n occurrences of previous character) which is \\'a\\' here. \\nSo how is this evaluated to true?"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "\".\" present a single character and *  Matches zero or more of the preceding element, so .* can be \"aa\" or \"bb\" , how can it present ab?"
                    },
                    {
                        "username": "wrares",
                        "content": "input : \"ab\"\\n           \".*c\"\\nshouldn\\'t this be true since \".*c\" can be \"..c\" the .. part match with \"ab\"?"
                    },
                    {
                        "username": "LucHuang",
                        "content": "No matter \"aa\" is the pattern or the string, match \"aa\" with \"\" or \"\" with \"aa\" should always yield to false. Therefore, the judge has a wrong answer at the first place."
                    },
                    {
                        "username": "atulkumartata",
                        "content": "input: s : \"aab\" p: \"c^a^b\"\\n\\nI\\'ve replaced the asterisk with ^ because the editor is interpreting it as italic text.\\n\\nOutput:false\\nExpected:true\\n\\n\\nHow can can the first \\'c\\' from pattern match with \\'a\\' from s? Am I misinterpreting the question here? \\n"
                    },
                    {
                        "username": "rulinsun",
                        "content": "Can anyone explain why this case expects output of \"true\"?\\n\"mississippi\"\\n\"mis\\\\*is\\\\*ip*.\"\\n\\n"
                    },
                    {
                        "username": "Cha0ticAnt",
                        "content": "Hello. This is comment is old but there\\'s no reply on it. One way to explain it is, starting at the back, the dot can match the final i. The p* can match pp, the \\'i\\' matches normally, s* matches \"ss\", another \\'i\\' matches normally, another \"s*\" for \"ss\", and the \"mi\" at the beginning match normally. So the pattern matches \\'s\\', so the output should be \"true\". I think the tricky part is the dot at the end. It\\'s a wildcard and handles the \\'i\\' at the end."
                    }
                ]
            },
            {
                "id": 1570881,
                "content": [
                    {
                        "username": "harsh3226",
                        "content": "This is my code\\nif it is valid for \"ab\"\\n\".*\"   why it is showing wrong for \\n \"ab\" \".*c\""
                    },
                    {
                        "username": "Manhattim",
                        "content": "Hi All,\\nShouldn\\'t s=\"aaa\" p=\"a*a\"eveluate to False?  \\nas the first \"a\\\\*\" is greedy and would consume the whole \\'s\\' leaving an evaluation of s=\\'\\' and p=\\'a\\'"
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "I think that\\'s the trickiest part of the test. `a*` is greedy but _until_ the last occurrence of `a`.\\n\\nThe similar case: pattern `.*abc` matches `123abc` but doesn\\'t match `123` even having `.*` greedy."
                    },
                    {
                        "username": "newbaby",
                        "content": "is this case valid? i.e. *p=\".*********************************\", *p=\"afava.*******cdada\""
                    },
                    {
                        "username": "ravidl",
                        "content": "Wrong Answer\\nDetails \\nInput\\n\"ab\"\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@Subhajit_Lai](/Subhajit_Lai) \".*c\" requires the string to end with \"c\", which \"ab\" doesn\\'t meet"
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "anyone can help with the logic please"
                    },
                    {
                        "username": "Metody",
                        "content": "Yup but\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\ntrue\\nExpected\\ntrue\\n\\nI have no idea what\\'s the logic behind these test cases."
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "How is the .* regular expression evaluated for input string ab?\\na matches to . (which is any character once) - so good\\nbut b matches * (which is n occurrences of previous character) which is \\'a\\' here. \\nSo how is this evaluated to true?"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "\".\" present a single character and *  Matches zero or more of the preceding element, so .* can be \"aa\" or \"bb\" , how can it present ab?"
                    },
                    {
                        "username": "wrares",
                        "content": "input : \"ab\"\\n           \".*c\"\\nshouldn\\'t this be true since \".*c\" can be \"..c\" the .. part match with \"ab\"?"
                    },
                    {
                        "username": "LucHuang",
                        "content": "No matter \"aa\" is the pattern or the string, match \"aa\" with \"\" or \"\" with \"aa\" should always yield to false. Therefore, the judge has a wrong answer at the first place."
                    },
                    {
                        "username": "atulkumartata",
                        "content": "input: s : \"aab\" p: \"c^a^b\"\\n\\nI\\'ve replaced the asterisk with ^ because the editor is interpreting it as italic text.\\n\\nOutput:false\\nExpected:true\\n\\n\\nHow can can the first \\'c\\' from pattern match with \\'a\\' from s? Am I misinterpreting the question here? \\n"
                    },
                    {
                        "username": "rulinsun",
                        "content": "Can anyone explain why this case expects output of \"true\"?\\n\"mississippi\"\\n\"mis\\\\*is\\\\*ip*.\"\\n\\n"
                    },
                    {
                        "username": "Cha0ticAnt",
                        "content": "Hello. This is comment is old but there\\'s no reply on it. One way to explain it is, starting at the back, the dot can match the final i. The p* can match pp, the \\'i\\' matches normally, s* matches \"ss\", another \\'i\\' matches normally, another \"s*\" for \"ss\", and the \"mi\" at the beginning match normally. So the pattern matches \\'s\\', so the output should be \"true\". I think the tricky part is the dot at the end. It\\'s a wildcard and handles the \\'i\\' at the end."
                    }
                ]
            },
            {
                "id": 1570845,
                "content": [
                    {
                        "username": "harsh3226",
                        "content": "This is my code\\nif it is valid for \"ab\"\\n\".*\"   why it is showing wrong for \\n \"ab\" \".*c\""
                    },
                    {
                        "username": "Manhattim",
                        "content": "Hi All,\\nShouldn\\'t s=\"aaa\" p=\"a*a\"eveluate to False?  \\nas the first \"a\\\\*\" is greedy and would consume the whole \\'s\\' leaving an evaluation of s=\\'\\' and p=\\'a\\'"
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "I think that\\'s the trickiest part of the test. `a*` is greedy but _until_ the last occurrence of `a`.\\n\\nThe similar case: pattern `.*abc` matches `123abc` but doesn\\'t match `123` even having `.*` greedy."
                    },
                    {
                        "username": "newbaby",
                        "content": "is this case valid? i.e. *p=\".*********************************\", *p=\"afava.*******cdada\""
                    },
                    {
                        "username": "ravidl",
                        "content": "Wrong Answer\\nDetails \\nInput\\n\"ab\"\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse"
                    },
                    {
                        "username": "webguru77777",
                        "content": "[@Subhajit_Lai](/Subhajit_Lai) \".*c\" requires the string to end with \"c\", which \"ab\" doesn\\'t meet"
                    },
                    {
                        "username": "Subhajit_Lai",
                        "content": "anyone can help with the logic please"
                    },
                    {
                        "username": "Metody",
                        "content": "Yup but\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\ntrue\\nExpected\\ntrue\\n\\nI have no idea what\\'s the logic behind these test cases."
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "How is the .* regular expression evaluated for input string ab?\\na matches to . (which is any character once) - so good\\nbut b matches * (which is n occurrences of previous character) which is \\'a\\' here. \\nSo how is this evaluated to true?"
                    },
                    {
                        "username": "AngelaJP",
                        "content": "\".\" present a single character and *  Matches zero or more of the preceding element, so .* can be \"aa\" or \"bb\" , how can it present ab?"
                    },
                    {
                        "username": "wrares",
                        "content": "input : \"ab\"\\n           \".*c\"\\nshouldn\\'t this be true since \".*c\" can be \"..c\" the .. part match with \"ab\"?"
                    },
                    {
                        "username": "LucHuang",
                        "content": "No matter \"aa\" is the pattern or the string, match \"aa\" with \"\" or \"\" with \"aa\" should always yield to false. Therefore, the judge has a wrong answer at the first place."
                    },
                    {
                        "username": "atulkumartata",
                        "content": "input: s : \"aab\" p: \"c^a^b\"\\n\\nI\\'ve replaced the asterisk with ^ because the editor is interpreting it as italic text.\\n\\nOutput:false\\nExpected:true\\n\\n\\nHow can can the first \\'c\\' from pattern match with \\'a\\' from s? Am I misinterpreting the question here? \\n"
                    },
                    {
                        "username": "rulinsun",
                        "content": "Can anyone explain why this case expects output of \"true\"?\\n\"mississippi\"\\n\"mis\\\\*is\\\\*ip*.\"\\n\\n"
                    },
                    {
                        "username": "Cha0ticAnt",
                        "content": "Hello. This is comment is old but there\\'s no reply on it. One way to explain it is, starting at the back, the dot can match the final i. The p* can match pp, the \\'i\\' matches normally, s* matches \"ss\", another \\'i\\' matches normally, another \"s*\" for \"ss\", and the \"mi\" at the beginning match normally. So the pattern matches \\'s\\', so the output should be \"true\". I think the tricky part is the dot at the end. It\\'s a wildcard and handles the \\'i\\' at the end."
                    }
                ]
            },
            {
                "id": 1567001,
                "content": [
                    {
                        "username": "alex4747",
                        "content": "I am mostly dealing with greedy  algorithms and it took me time to realise that this one is non-greedy. Yes, it was my fault reading more into description that it was there, but I still think that it would feel better it was spelled out."
                    },
                    {
                        "username": "priyanka1230",
                        "content": "why this case is true??\\ns = \"ab\", p = \".*\""
                    },
                    {
                        "username": "lancewang",
                        "content": "In the problem description: \".\" can represent any single character and \"\\\\*\" represent any numbers of previous character. So if \".\" represents \"a\", then \".*\" is like \"a\\\\*\".  So what is representing \"b\"?"
                    },
                    {
                        "username": "shipper",
                        "content": "My code has passed. However, I found a case I cannot pass and I\\'m cofused about the right answer.\\n\\n\"aab\"\\n\"c*aa**b\"\\n\\nI expect it is True but the expected result is false. Can anyone explain it to me?"
                    },
                    {
                        "username": "lancelot1998kym",
                        "content": "![image](https://assets.leetcode.com/users/images/ac0c245d-33b5-4564-b7d9-3e1b9d60d7b2_1601695762.9707453.png)\\n![image](https://assets.leetcode.com/users/images/3a71f9b4-e207-430e-a363-5fb8db7b058e_1601695762.939302.png)\\nThe expected outputs given those two patterns are different. However, in my opinion they should be the same. \\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "a** should not be possible.  It is guaranteed that preceding a * there should be a lowercase alpha character or a \\'.\\'"
                    },
                    {
                        "username": "zhengyang1988",
                        "content": "I see there is a testcase:\\ninput:\\ns=\"aab\"\\np=\"c*a*b\"\\nexpected=True\\n\\nHow can this to be true? They definitely don\\'t match!"
                    },
                    {
                        "username": "xidui",
                        "content": "Does it mean that \".*\" matches every input?"
                    },
                    {
                        "username": "sherlock24",
                        "content": "Input:\\t\"b\", \"aaa.\"\\nOutput:\\ttrue\\nExpected:\\tfalse"
                    },
                    {
                        "username": "GCweixi",
                        "content": "I was wondering if string s can also contain '.' or '*'?\\nOr only string p contains the notation?\\nThanks!"
                    },
                    {
                        "username": "mhy8958",
                        "content": "RT\\ni don't understand this???\\nif `(isMatch(\"ab\", \".*\"))` is true, why `ab`, `.*c` is false? Are't they the same?"
                    }
                ]
            },
            {
                "id": 1568616,
                "content": [
                    {
                        "username": "alex4747",
                        "content": "I am mostly dealing with greedy  algorithms and it took me time to realise that this one is non-greedy. Yes, it was my fault reading more into description that it was there, but I still think that it would feel better it was spelled out."
                    },
                    {
                        "username": "priyanka1230",
                        "content": "why this case is true??\\ns = \"ab\", p = \".*\""
                    },
                    {
                        "username": "lancewang",
                        "content": "In the problem description: \".\" can represent any single character and \"\\\\*\" represent any numbers of previous character. So if \".\" represents \"a\", then \".*\" is like \"a\\\\*\".  So what is representing \"b\"?"
                    },
                    {
                        "username": "shipper",
                        "content": "My code has passed. However, I found a case I cannot pass and I\\'m cofused about the right answer.\\n\\n\"aab\"\\n\"c*aa**b\"\\n\\nI expect it is True but the expected result is false. Can anyone explain it to me?"
                    },
                    {
                        "username": "lancelot1998kym",
                        "content": "![image](https://assets.leetcode.com/users/images/ac0c245d-33b5-4564-b7d9-3e1b9d60d7b2_1601695762.9707453.png)\\n![image](https://assets.leetcode.com/users/images/3a71f9b4-e207-430e-a363-5fb8db7b058e_1601695762.939302.png)\\nThe expected outputs given those two patterns are different. However, in my opinion they should be the same. \\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "a** should not be possible.  It is guaranteed that preceding a * there should be a lowercase alpha character or a \\'.\\'"
                    },
                    {
                        "username": "zhengyang1988",
                        "content": "I see there is a testcase:\\ninput:\\ns=\"aab\"\\np=\"c*a*b\"\\nexpected=True\\n\\nHow can this to be true? They definitely don\\'t match!"
                    },
                    {
                        "username": "xidui",
                        "content": "Does it mean that \".*\" matches every input?"
                    },
                    {
                        "username": "sherlock24",
                        "content": "Input:\\t\"b\", \"aaa.\"\\nOutput:\\ttrue\\nExpected:\\tfalse"
                    },
                    {
                        "username": "GCweixi",
                        "content": "I was wondering if string s can also contain '.' or '*'?\\nOr only string p contains the notation?\\nThanks!"
                    },
                    {
                        "username": "mhy8958",
                        "content": "RT\\ni don't understand this???\\nif `(isMatch(\"ab\", \".*\"))` is true, why `ab`, `.*c` is false? Are't they the same?"
                    }
                ]
            },
            {
                "id": 1568011,
                "content": [
                    {
                        "username": "alex4747",
                        "content": "I am mostly dealing with greedy  algorithms and it took me time to realise that this one is non-greedy. Yes, it was my fault reading more into description that it was there, but I still think that it would feel better it was spelled out."
                    },
                    {
                        "username": "priyanka1230",
                        "content": "why this case is true??\\ns = \"ab\", p = \".*\""
                    },
                    {
                        "username": "lancewang",
                        "content": "In the problem description: \".\" can represent any single character and \"\\\\*\" represent any numbers of previous character. So if \".\" represents \"a\", then \".*\" is like \"a\\\\*\".  So what is representing \"b\"?"
                    },
                    {
                        "username": "shipper",
                        "content": "My code has passed. However, I found a case I cannot pass and I\\'m cofused about the right answer.\\n\\n\"aab\"\\n\"c*aa**b\"\\n\\nI expect it is True but the expected result is false. Can anyone explain it to me?"
                    },
                    {
                        "username": "lancelot1998kym",
                        "content": "![image](https://assets.leetcode.com/users/images/ac0c245d-33b5-4564-b7d9-3e1b9d60d7b2_1601695762.9707453.png)\\n![image](https://assets.leetcode.com/users/images/3a71f9b4-e207-430e-a363-5fb8db7b058e_1601695762.939302.png)\\nThe expected outputs given those two patterns are different. However, in my opinion they should be the same. \\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "a** should not be possible.  It is guaranteed that preceding a * there should be a lowercase alpha character or a \\'.\\'"
                    },
                    {
                        "username": "zhengyang1988",
                        "content": "I see there is a testcase:\\ninput:\\ns=\"aab\"\\np=\"c*a*b\"\\nexpected=True\\n\\nHow can this to be true? They definitely don\\'t match!"
                    },
                    {
                        "username": "xidui",
                        "content": "Does it mean that \".*\" matches every input?"
                    },
                    {
                        "username": "sherlock24",
                        "content": "Input:\\t\"b\", \"aaa.\"\\nOutput:\\ttrue\\nExpected:\\tfalse"
                    },
                    {
                        "username": "GCweixi",
                        "content": "I was wondering if string s can also contain '.' or '*'?\\nOr only string p contains the notation?\\nThanks!"
                    },
                    {
                        "username": "mhy8958",
                        "content": "RT\\ni don't understand this???\\nif `(isMatch(\"ab\", \".*\"))` is true, why `ab`, `.*c` is false? Are't they the same?"
                    }
                ]
            },
            {
                "id": 1570204,
                "content": [
                    {
                        "username": "alex4747",
                        "content": "I am mostly dealing with greedy  algorithms and it took me time to realise that this one is non-greedy. Yes, it was my fault reading more into description that it was there, but I still think that it would feel better it was spelled out."
                    },
                    {
                        "username": "priyanka1230",
                        "content": "why this case is true??\\ns = \"ab\", p = \".*\""
                    },
                    {
                        "username": "lancewang",
                        "content": "In the problem description: \".\" can represent any single character and \"\\\\*\" represent any numbers of previous character. So if \".\" represents \"a\", then \".*\" is like \"a\\\\*\".  So what is representing \"b\"?"
                    },
                    {
                        "username": "shipper",
                        "content": "My code has passed. However, I found a case I cannot pass and I\\'m cofused about the right answer.\\n\\n\"aab\"\\n\"c*aa**b\"\\n\\nI expect it is True but the expected result is false. Can anyone explain it to me?"
                    },
                    {
                        "username": "lancelot1998kym",
                        "content": "![image](https://assets.leetcode.com/users/images/ac0c245d-33b5-4564-b7d9-3e1b9d60d7b2_1601695762.9707453.png)\\n![image](https://assets.leetcode.com/users/images/3a71f9b4-e207-430e-a363-5fb8db7b058e_1601695762.939302.png)\\nThe expected outputs given those two patterns are different. However, in my opinion they should be the same. \\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "a** should not be possible.  It is guaranteed that preceding a * there should be a lowercase alpha character or a \\'.\\'"
                    },
                    {
                        "username": "zhengyang1988",
                        "content": "I see there is a testcase:\\ninput:\\ns=\"aab\"\\np=\"c*a*b\"\\nexpected=True\\n\\nHow can this to be true? They definitely don\\'t match!"
                    },
                    {
                        "username": "xidui",
                        "content": "Does it mean that \".*\" matches every input?"
                    },
                    {
                        "username": "sherlock24",
                        "content": "Input:\\t\"b\", \"aaa.\"\\nOutput:\\ttrue\\nExpected:\\tfalse"
                    },
                    {
                        "username": "GCweixi",
                        "content": "I was wondering if string s can also contain '.' or '*'?\\nOr only string p contains the notation?\\nThanks!"
                    },
                    {
                        "username": "mhy8958",
                        "content": "RT\\ni don't understand this???\\nif `(isMatch(\"ab\", \".*\"))` is true, why `ab`, `.*c` is false? Are't they the same?"
                    }
                ]
            },
            {
                "id": 1568456,
                "content": [
                    {
                        "username": "alex4747",
                        "content": "I am mostly dealing with greedy  algorithms and it took me time to realise that this one is non-greedy. Yes, it was my fault reading more into description that it was there, but I still think that it would feel better it was spelled out."
                    },
                    {
                        "username": "priyanka1230",
                        "content": "why this case is true??\\ns = \"ab\", p = \".*\""
                    },
                    {
                        "username": "lancewang",
                        "content": "In the problem description: \".\" can represent any single character and \"\\\\*\" represent any numbers of previous character. So if \".\" represents \"a\", then \".*\" is like \"a\\\\*\".  So what is representing \"b\"?"
                    },
                    {
                        "username": "shipper",
                        "content": "My code has passed. However, I found a case I cannot pass and I\\'m cofused about the right answer.\\n\\n\"aab\"\\n\"c*aa**b\"\\n\\nI expect it is True but the expected result is false. Can anyone explain it to me?"
                    },
                    {
                        "username": "lancelot1998kym",
                        "content": "![image](https://assets.leetcode.com/users/images/ac0c245d-33b5-4564-b7d9-3e1b9d60d7b2_1601695762.9707453.png)\\n![image](https://assets.leetcode.com/users/images/3a71f9b4-e207-430e-a363-5fb8db7b058e_1601695762.939302.png)\\nThe expected outputs given those two patterns are different. However, in my opinion they should be the same. \\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "a** should not be possible.  It is guaranteed that preceding a * there should be a lowercase alpha character or a \\'.\\'"
                    },
                    {
                        "username": "zhengyang1988",
                        "content": "I see there is a testcase:\\ninput:\\ns=\"aab\"\\np=\"c*a*b\"\\nexpected=True\\n\\nHow can this to be true? They definitely don\\'t match!"
                    },
                    {
                        "username": "xidui",
                        "content": "Does it mean that \".*\" matches every input?"
                    },
                    {
                        "username": "sherlock24",
                        "content": "Input:\\t\"b\", \"aaa.\"\\nOutput:\\ttrue\\nExpected:\\tfalse"
                    },
                    {
                        "username": "GCweixi",
                        "content": "I was wondering if string s can also contain '.' or '*'?\\nOr only string p contains the notation?\\nThanks!"
                    },
                    {
                        "username": "mhy8958",
                        "content": "RT\\ni don't understand this???\\nif `(isMatch(\"ab\", \".*\"))` is true, why `ab`, `.*c` is false? Are't they the same?"
                    }
                ]
            },
            {
                "id": 1569685,
                "content": [
                    {
                        "username": "alex4747",
                        "content": "I am mostly dealing with greedy  algorithms and it took me time to realise that this one is non-greedy. Yes, it was my fault reading more into description that it was there, but I still think that it would feel better it was spelled out."
                    },
                    {
                        "username": "priyanka1230",
                        "content": "why this case is true??\\ns = \"ab\", p = \".*\""
                    },
                    {
                        "username": "lancewang",
                        "content": "In the problem description: \".\" can represent any single character and \"\\\\*\" represent any numbers of previous character. So if \".\" represents \"a\", then \".*\" is like \"a\\\\*\".  So what is representing \"b\"?"
                    },
                    {
                        "username": "shipper",
                        "content": "My code has passed. However, I found a case I cannot pass and I\\'m cofused about the right answer.\\n\\n\"aab\"\\n\"c*aa**b\"\\n\\nI expect it is True but the expected result is false. Can anyone explain it to me?"
                    },
                    {
                        "username": "lancelot1998kym",
                        "content": "![image](https://assets.leetcode.com/users/images/ac0c245d-33b5-4564-b7d9-3e1b9d60d7b2_1601695762.9707453.png)\\n![image](https://assets.leetcode.com/users/images/3a71f9b4-e207-430e-a363-5fb8db7b058e_1601695762.939302.png)\\nThe expected outputs given those two patterns are different. However, in my opinion they should be the same. \\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "a** should not be possible.  It is guaranteed that preceding a * there should be a lowercase alpha character or a \\'.\\'"
                    },
                    {
                        "username": "zhengyang1988",
                        "content": "I see there is a testcase:\\ninput:\\ns=\"aab\"\\np=\"c*a*b\"\\nexpected=True\\n\\nHow can this to be true? They definitely don\\'t match!"
                    },
                    {
                        "username": "xidui",
                        "content": "Does it mean that \".*\" matches every input?"
                    },
                    {
                        "username": "sherlock24",
                        "content": "Input:\\t\"b\", \"aaa.\"\\nOutput:\\ttrue\\nExpected:\\tfalse"
                    },
                    {
                        "username": "GCweixi",
                        "content": "I was wondering if string s can also contain '.' or '*'?\\nOr only string p contains the notation?\\nThanks!"
                    },
                    {
                        "username": "mhy8958",
                        "content": "RT\\ni don't understand this???\\nif `(isMatch(\"ab\", \".*\"))` is true, why `ab`, `.*c` is false? Are't they the same?"
                    }
                ]
            },
            {
                "id": 1567800,
                "content": [
                    {
                        "username": "alex4747",
                        "content": "I am mostly dealing with greedy  algorithms and it took me time to realise that this one is non-greedy. Yes, it was my fault reading more into description that it was there, but I still think that it would feel better it was spelled out."
                    },
                    {
                        "username": "priyanka1230",
                        "content": "why this case is true??\\ns = \"ab\", p = \".*\""
                    },
                    {
                        "username": "lancewang",
                        "content": "In the problem description: \".\" can represent any single character and \"\\\\*\" represent any numbers of previous character. So if \".\" represents \"a\", then \".*\" is like \"a\\\\*\".  So what is representing \"b\"?"
                    },
                    {
                        "username": "shipper",
                        "content": "My code has passed. However, I found a case I cannot pass and I\\'m cofused about the right answer.\\n\\n\"aab\"\\n\"c*aa**b\"\\n\\nI expect it is True but the expected result is false. Can anyone explain it to me?"
                    },
                    {
                        "username": "lancelot1998kym",
                        "content": "![image](https://assets.leetcode.com/users/images/ac0c245d-33b5-4564-b7d9-3e1b9d60d7b2_1601695762.9707453.png)\\n![image](https://assets.leetcode.com/users/images/3a71f9b4-e207-430e-a363-5fb8db7b058e_1601695762.939302.png)\\nThe expected outputs given those two patterns are different. However, in my opinion they should be the same. \\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "a** should not be possible.  It is guaranteed that preceding a * there should be a lowercase alpha character or a \\'.\\'"
                    },
                    {
                        "username": "zhengyang1988",
                        "content": "I see there is a testcase:\\ninput:\\ns=\"aab\"\\np=\"c*a*b\"\\nexpected=True\\n\\nHow can this to be true? They definitely don\\'t match!"
                    },
                    {
                        "username": "xidui",
                        "content": "Does it mean that \".*\" matches every input?"
                    },
                    {
                        "username": "sherlock24",
                        "content": "Input:\\t\"b\", \"aaa.\"\\nOutput:\\ttrue\\nExpected:\\tfalse"
                    },
                    {
                        "username": "GCweixi",
                        "content": "I was wondering if string s can also contain '.' or '*'?\\nOr only string p contains the notation?\\nThanks!"
                    },
                    {
                        "username": "mhy8958",
                        "content": "RT\\ni don't understand this???\\nif `(isMatch(\"ab\", \".*\"))` is true, why `ab`, `.*c` is false? Are't they the same?"
                    }
                ]
            },
            {
                "id": 1567801,
                "content": [
                    {
                        "username": "alex4747",
                        "content": "I am mostly dealing with greedy  algorithms and it took me time to realise that this one is non-greedy. Yes, it was my fault reading more into description that it was there, but I still think that it would feel better it was spelled out."
                    },
                    {
                        "username": "priyanka1230",
                        "content": "why this case is true??\\ns = \"ab\", p = \".*\""
                    },
                    {
                        "username": "lancewang",
                        "content": "In the problem description: \".\" can represent any single character and \"\\\\*\" represent any numbers of previous character. So if \".\" represents \"a\", then \".*\" is like \"a\\\\*\".  So what is representing \"b\"?"
                    },
                    {
                        "username": "shipper",
                        "content": "My code has passed. However, I found a case I cannot pass and I\\'m cofused about the right answer.\\n\\n\"aab\"\\n\"c*aa**b\"\\n\\nI expect it is True but the expected result is false. Can anyone explain it to me?"
                    },
                    {
                        "username": "lancelot1998kym",
                        "content": "![image](https://assets.leetcode.com/users/images/ac0c245d-33b5-4564-b7d9-3e1b9d60d7b2_1601695762.9707453.png)\\n![image](https://assets.leetcode.com/users/images/3a71f9b4-e207-430e-a363-5fb8db7b058e_1601695762.939302.png)\\nThe expected outputs given those two patterns are different. However, in my opinion they should be the same. \\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "a** should not be possible.  It is guaranteed that preceding a * there should be a lowercase alpha character or a \\'.\\'"
                    },
                    {
                        "username": "zhengyang1988",
                        "content": "I see there is a testcase:\\ninput:\\ns=\"aab\"\\np=\"c*a*b\"\\nexpected=True\\n\\nHow can this to be true? They definitely don\\'t match!"
                    },
                    {
                        "username": "xidui",
                        "content": "Does it mean that \".*\" matches every input?"
                    },
                    {
                        "username": "sherlock24",
                        "content": "Input:\\t\"b\", \"aaa.\"\\nOutput:\\ttrue\\nExpected:\\tfalse"
                    },
                    {
                        "username": "GCweixi",
                        "content": "I was wondering if string s can also contain '.' or '*'?\\nOr only string p contains the notation?\\nThanks!"
                    },
                    {
                        "username": "mhy8958",
                        "content": "RT\\ni don't understand this???\\nif `(isMatch(\"ab\", \".*\"))` is true, why `ab`, `.*c` is false? Are't they the same?"
                    }
                ]
            },
            {
                "id": 1567162,
                "content": [
                    {
                        "username": "alex4747",
                        "content": "I am mostly dealing with greedy  algorithms and it took me time to realise that this one is non-greedy. Yes, it was my fault reading more into description that it was there, but I still think that it would feel better it was spelled out."
                    },
                    {
                        "username": "priyanka1230",
                        "content": "why this case is true??\\ns = \"ab\", p = \".*\""
                    },
                    {
                        "username": "lancewang",
                        "content": "In the problem description: \".\" can represent any single character and \"\\\\*\" represent any numbers of previous character. So if \".\" represents \"a\", then \".*\" is like \"a\\\\*\".  So what is representing \"b\"?"
                    },
                    {
                        "username": "shipper",
                        "content": "My code has passed. However, I found a case I cannot pass and I\\'m cofused about the right answer.\\n\\n\"aab\"\\n\"c*aa**b\"\\n\\nI expect it is True but the expected result is false. Can anyone explain it to me?"
                    },
                    {
                        "username": "lancelot1998kym",
                        "content": "![image](https://assets.leetcode.com/users/images/ac0c245d-33b5-4564-b7d9-3e1b9d60d7b2_1601695762.9707453.png)\\n![image](https://assets.leetcode.com/users/images/3a71f9b4-e207-430e-a363-5fb8db7b058e_1601695762.939302.png)\\nThe expected outputs given those two patterns are different. However, in my opinion they should be the same. \\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "a** should not be possible.  It is guaranteed that preceding a * there should be a lowercase alpha character or a \\'.\\'"
                    },
                    {
                        "username": "zhengyang1988",
                        "content": "I see there is a testcase:\\ninput:\\ns=\"aab\"\\np=\"c*a*b\"\\nexpected=True\\n\\nHow can this to be true? They definitely don\\'t match!"
                    },
                    {
                        "username": "xidui",
                        "content": "Does it mean that \".*\" matches every input?"
                    },
                    {
                        "username": "sherlock24",
                        "content": "Input:\\t\"b\", \"aaa.\"\\nOutput:\\ttrue\\nExpected:\\tfalse"
                    },
                    {
                        "username": "GCweixi",
                        "content": "I was wondering if string s can also contain '.' or '*'?\\nOr only string p contains the notation?\\nThanks!"
                    },
                    {
                        "username": "mhy8958",
                        "content": "RT\\ni don't understand this???\\nif `(isMatch(\"ab\", \".*\"))` is true, why `ab`, `.*c` is false? Are't they the same?"
                    }
                ]
            },
            {
                "id": 1567160,
                "content": [
                    {
                        "username": "alex4747",
                        "content": "I am mostly dealing with greedy  algorithms and it took me time to realise that this one is non-greedy. Yes, it was my fault reading more into description that it was there, but I still think that it would feel better it was spelled out."
                    },
                    {
                        "username": "priyanka1230",
                        "content": "why this case is true??\\ns = \"ab\", p = \".*\""
                    },
                    {
                        "username": "lancewang",
                        "content": "In the problem description: \".\" can represent any single character and \"\\\\*\" represent any numbers of previous character. So if \".\" represents \"a\", then \".*\" is like \"a\\\\*\".  So what is representing \"b\"?"
                    },
                    {
                        "username": "shipper",
                        "content": "My code has passed. However, I found a case I cannot pass and I\\'m cofused about the right answer.\\n\\n\"aab\"\\n\"c*aa**b\"\\n\\nI expect it is True but the expected result is false. Can anyone explain it to me?"
                    },
                    {
                        "username": "lancelot1998kym",
                        "content": "![image](https://assets.leetcode.com/users/images/ac0c245d-33b5-4564-b7d9-3e1b9d60d7b2_1601695762.9707453.png)\\n![image](https://assets.leetcode.com/users/images/3a71f9b4-e207-430e-a363-5fb8db7b058e_1601695762.939302.png)\\nThe expected outputs given those two patterns are different. However, in my opinion they should be the same. \\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "a** should not be possible.  It is guaranteed that preceding a * there should be a lowercase alpha character or a \\'.\\'"
                    },
                    {
                        "username": "zhengyang1988",
                        "content": "I see there is a testcase:\\ninput:\\ns=\"aab\"\\np=\"c*a*b\"\\nexpected=True\\n\\nHow can this to be true? They definitely don\\'t match!"
                    },
                    {
                        "username": "xidui",
                        "content": "Does it mean that \".*\" matches every input?"
                    },
                    {
                        "username": "sherlock24",
                        "content": "Input:\\t\"b\", \"aaa.\"\\nOutput:\\ttrue\\nExpected:\\tfalse"
                    },
                    {
                        "username": "GCweixi",
                        "content": "I was wondering if string s can also contain '.' or '*'?\\nOr only string p contains the notation?\\nThanks!"
                    },
                    {
                        "username": "mhy8958",
                        "content": "RT\\ni don't understand this???\\nif `(isMatch(\"ab\", \".*\"))` is true, why `ab`, `.*c` is false? Are't they the same?"
                    }
                ]
            },
            {
                "id": 1567096,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "ok, so I done it by my self but I must admit this one was horribly frustraiting.\\nI need to go for a walk..."
                    },
                    {
                        "username": "neizod",
                        "content": "what the fuck is the pattern: a***abc ??? thet\\'s not even in the specification !!!"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Even if consider that * is a character, then\\n\\'s contains only lowercase English letters\\'\\nhow can * match lowercase english letters"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "\\n\\'It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\\'\\n\\nHow is this constraint being followed???"
                    },
                    {
                        "username": "rvjcode",
                        "content": "Input\\n\"aab\"\\n\"c*a*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue\\n\\ncan someone explain how the above results to true?"
                    },
                    {
                        "username": "xieweizhuang",
                        "content": "The example \"ab\" \".\" returns true, but why test case \"ab\" \".*c\" return false?"
                    },
                    {
                        "username": "algopirate",
                        "content": "If here . is a, then * can only repeat a, so it would be ab and aa or ab and bb. How come it is true?"
                    },
                    {
                        "username": "lurosset",
                        "content": "A regular expression can be translated into a nondeterministic finite automaton (NFA). One common algorithm for such is Thompson\\'s Construction (https://en.wikipedia.org/wiki/Thompson\\'s_construction).\\nThen, any NFA can be transformed into a deterministic finite automaton (DFA). It is a tiresome task but easy. Here\\'s a tutorial on it: https://www.tutorialspoint.com/automata_theory/ndfa_to_dfa_conversion.htm.\\n\\nOf course, it\\'s not the fastest way to check for a single pair of _s_ and _p_, but if you happen to be using the same _p_ for many different strings, this approach can save time by checking the string only once.\\n\\n:)"
                    },
                    {
                        "username": "challapalli",
                        "content": "\"aab\"\\n\"c**aab\"\\n\\nFor the above input, I expect the regex to match the given string. Apparently it doesn\\'t. Can anyone explain why?"
                    },
                    {
                        "username": "ameyabp",
                        "content": "There seems to be some ambiguity in the example.\\ns = \"ab\"\\np = \".\\\\*\"\\nanswer = true\\n\\nThere seem to be 2 ways of interpreting the regex p.\\n1. p can be interpreted as **multiple instances of the wildcard** itself. p = \"......\" in which case, s can be generated from p and the result is true\\n2. However, in a second interpretation, we fix the first character, and then we have to stick to it for the multiple instances. We cannot change the character we are writing, midway in a string.\\n\\nCould anyone please help me with understanding this correctly? I might be wrong!"
                    },
                    {
                        "username": "chenghaoqw",
                        "content": "Why \\n\"ab\" \\n\".*c\"\\n is false???"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I think it is exponential, but I am not sure how to analyze it exactly, what is it?"
                    }
                ]
            },
            {
                "id": 2037142,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "ok, so I done it by my self but I must admit this one was horribly frustraiting.\\nI need to go for a walk..."
                    },
                    {
                        "username": "neizod",
                        "content": "what the fuck is the pattern: a***abc ??? thet\\'s not even in the specification !!!"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Even if consider that * is a character, then\\n\\'s contains only lowercase English letters\\'\\nhow can * match lowercase english letters"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "\\n\\'It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\\'\\n\\nHow is this constraint being followed???"
                    },
                    {
                        "username": "rvjcode",
                        "content": "Input\\n\"aab\"\\n\"c*a*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue\\n\\ncan someone explain how the above results to true?"
                    },
                    {
                        "username": "xieweizhuang",
                        "content": "The example \"ab\" \".\" returns true, but why test case \"ab\" \".*c\" return false?"
                    },
                    {
                        "username": "algopirate",
                        "content": "If here . is a, then * can only repeat a, so it would be ab and aa or ab and bb. How come it is true?"
                    },
                    {
                        "username": "lurosset",
                        "content": "A regular expression can be translated into a nondeterministic finite automaton (NFA). One common algorithm for such is Thompson\\'s Construction (https://en.wikipedia.org/wiki/Thompson\\'s_construction).\\nThen, any NFA can be transformed into a deterministic finite automaton (DFA). It is a tiresome task but easy. Here\\'s a tutorial on it: https://www.tutorialspoint.com/automata_theory/ndfa_to_dfa_conversion.htm.\\n\\nOf course, it\\'s not the fastest way to check for a single pair of _s_ and _p_, but if you happen to be using the same _p_ for many different strings, this approach can save time by checking the string only once.\\n\\n:)"
                    },
                    {
                        "username": "challapalli",
                        "content": "\"aab\"\\n\"c**aab\"\\n\\nFor the above input, I expect the regex to match the given string. Apparently it doesn\\'t. Can anyone explain why?"
                    },
                    {
                        "username": "ameyabp",
                        "content": "There seems to be some ambiguity in the example.\\ns = \"ab\"\\np = \".\\\\*\"\\nanswer = true\\n\\nThere seem to be 2 ways of interpreting the regex p.\\n1. p can be interpreted as **multiple instances of the wildcard** itself. p = \"......\" in which case, s can be generated from p and the result is true\\n2. However, in a second interpretation, we fix the first character, and then we have to stick to it for the multiple instances. We cannot change the character we are writing, midway in a string.\\n\\nCould anyone please help me with understanding this correctly? I might be wrong!"
                    },
                    {
                        "username": "chenghaoqw",
                        "content": "Why \\n\"ab\" \\n\".*c\"\\n is false???"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I think it is exponential, but I am not sure how to analyze it exactly, what is it?"
                    }
                ]
            },
            {
                "id": 1568729,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "ok, so I done it by my self but I must admit this one was horribly frustraiting.\\nI need to go for a walk..."
                    },
                    {
                        "username": "neizod",
                        "content": "what the fuck is the pattern: a***abc ??? thet\\'s not even in the specification !!!"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Even if consider that * is a character, then\\n\\'s contains only lowercase English letters\\'\\nhow can * match lowercase english letters"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "\\n\\'It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\\'\\n\\nHow is this constraint being followed???"
                    },
                    {
                        "username": "rvjcode",
                        "content": "Input\\n\"aab\"\\n\"c*a*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue\\n\\ncan someone explain how the above results to true?"
                    },
                    {
                        "username": "xieweizhuang",
                        "content": "The example \"ab\" \".\" returns true, but why test case \"ab\" \".*c\" return false?"
                    },
                    {
                        "username": "algopirate",
                        "content": "If here . is a, then * can only repeat a, so it would be ab and aa or ab and bb. How come it is true?"
                    },
                    {
                        "username": "lurosset",
                        "content": "A regular expression can be translated into a nondeterministic finite automaton (NFA). One common algorithm for such is Thompson\\'s Construction (https://en.wikipedia.org/wiki/Thompson\\'s_construction).\\nThen, any NFA can be transformed into a deterministic finite automaton (DFA). It is a tiresome task but easy. Here\\'s a tutorial on it: https://www.tutorialspoint.com/automata_theory/ndfa_to_dfa_conversion.htm.\\n\\nOf course, it\\'s not the fastest way to check for a single pair of _s_ and _p_, but if you happen to be using the same _p_ for many different strings, this approach can save time by checking the string only once.\\n\\n:)"
                    },
                    {
                        "username": "challapalli",
                        "content": "\"aab\"\\n\"c**aab\"\\n\\nFor the above input, I expect the regex to match the given string. Apparently it doesn\\'t. Can anyone explain why?"
                    },
                    {
                        "username": "ameyabp",
                        "content": "There seems to be some ambiguity in the example.\\ns = \"ab\"\\np = \".\\\\*\"\\nanswer = true\\n\\nThere seem to be 2 ways of interpreting the regex p.\\n1. p can be interpreted as **multiple instances of the wildcard** itself. p = \"......\" in which case, s can be generated from p and the result is true\\n2. However, in a second interpretation, we fix the first character, and then we have to stick to it for the multiple instances. We cannot change the character we are writing, midway in a string.\\n\\nCould anyone please help me with understanding this correctly? I might be wrong!"
                    },
                    {
                        "username": "chenghaoqw",
                        "content": "Why \\n\"ab\" \\n\".*c\"\\n is false???"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I think it is exponential, but I am not sure how to analyze it exactly, what is it?"
                    }
                ]
            },
            {
                "id": 1570142,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "ok, so I done it by my self but I must admit this one was horribly frustraiting.\\nI need to go for a walk..."
                    },
                    {
                        "username": "neizod",
                        "content": "what the fuck is the pattern: a***abc ??? thet\\'s not even in the specification !!!"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Even if consider that * is a character, then\\n\\'s contains only lowercase English letters\\'\\nhow can * match lowercase english letters"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "\\n\\'It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\\'\\n\\nHow is this constraint being followed???"
                    },
                    {
                        "username": "rvjcode",
                        "content": "Input\\n\"aab\"\\n\"c*a*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue\\n\\ncan someone explain how the above results to true?"
                    },
                    {
                        "username": "xieweizhuang",
                        "content": "The example \"ab\" \".\" returns true, but why test case \"ab\" \".*c\" return false?"
                    },
                    {
                        "username": "algopirate",
                        "content": "If here . is a, then * can only repeat a, so it would be ab and aa or ab and bb. How come it is true?"
                    },
                    {
                        "username": "lurosset",
                        "content": "A regular expression can be translated into a nondeterministic finite automaton (NFA). One common algorithm for such is Thompson\\'s Construction (https://en.wikipedia.org/wiki/Thompson\\'s_construction).\\nThen, any NFA can be transformed into a deterministic finite automaton (DFA). It is a tiresome task but easy. Here\\'s a tutorial on it: https://www.tutorialspoint.com/automata_theory/ndfa_to_dfa_conversion.htm.\\n\\nOf course, it\\'s not the fastest way to check for a single pair of _s_ and _p_, but if you happen to be using the same _p_ for many different strings, this approach can save time by checking the string only once.\\n\\n:)"
                    },
                    {
                        "username": "challapalli",
                        "content": "\"aab\"\\n\"c**aab\"\\n\\nFor the above input, I expect the regex to match the given string. Apparently it doesn\\'t. Can anyone explain why?"
                    },
                    {
                        "username": "ameyabp",
                        "content": "There seems to be some ambiguity in the example.\\ns = \"ab\"\\np = \".\\\\*\"\\nanswer = true\\n\\nThere seem to be 2 ways of interpreting the regex p.\\n1. p can be interpreted as **multiple instances of the wildcard** itself. p = \"......\" in which case, s can be generated from p and the result is true\\n2. However, in a second interpretation, we fix the first character, and then we have to stick to it for the multiple instances. We cannot change the character we are writing, midway in a string.\\n\\nCould anyone please help me with understanding this correctly? I might be wrong!"
                    },
                    {
                        "username": "chenghaoqw",
                        "content": "Why \\n\"ab\" \\n\".*c\"\\n is false???"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I think it is exponential, but I am not sure how to analyze it exactly, what is it?"
                    }
                ]
            },
            {
                "id": 1570075,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "ok, so I done it by my self but I must admit this one was horribly frustraiting.\\nI need to go for a walk..."
                    },
                    {
                        "username": "neizod",
                        "content": "what the fuck is the pattern: a***abc ??? thet\\'s not even in the specification !!!"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Even if consider that * is a character, then\\n\\'s contains only lowercase English letters\\'\\nhow can * match lowercase english letters"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "\\n\\'It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\\'\\n\\nHow is this constraint being followed???"
                    },
                    {
                        "username": "rvjcode",
                        "content": "Input\\n\"aab\"\\n\"c*a*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue\\n\\ncan someone explain how the above results to true?"
                    },
                    {
                        "username": "xieweizhuang",
                        "content": "The example \"ab\" \".\" returns true, but why test case \"ab\" \".*c\" return false?"
                    },
                    {
                        "username": "algopirate",
                        "content": "If here . is a, then * can only repeat a, so it would be ab and aa or ab and bb. How come it is true?"
                    },
                    {
                        "username": "lurosset",
                        "content": "A regular expression can be translated into a nondeterministic finite automaton (NFA). One common algorithm for such is Thompson\\'s Construction (https://en.wikipedia.org/wiki/Thompson\\'s_construction).\\nThen, any NFA can be transformed into a deterministic finite automaton (DFA). It is a tiresome task but easy. Here\\'s a tutorial on it: https://www.tutorialspoint.com/automata_theory/ndfa_to_dfa_conversion.htm.\\n\\nOf course, it\\'s not the fastest way to check for a single pair of _s_ and _p_, but if you happen to be using the same _p_ for many different strings, this approach can save time by checking the string only once.\\n\\n:)"
                    },
                    {
                        "username": "challapalli",
                        "content": "\"aab\"\\n\"c**aab\"\\n\\nFor the above input, I expect the regex to match the given string. Apparently it doesn\\'t. Can anyone explain why?"
                    },
                    {
                        "username": "ameyabp",
                        "content": "There seems to be some ambiguity in the example.\\ns = \"ab\"\\np = \".\\\\*\"\\nanswer = true\\n\\nThere seem to be 2 ways of interpreting the regex p.\\n1. p can be interpreted as **multiple instances of the wildcard** itself. p = \"......\" in which case, s can be generated from p and the result is true\\n2. However, in a second interpretation, we fix the first character, and then we have to stick to it for the multiple instances. We cannot change the character we are writing, midway in a string.\\n\\nCould anyone please help me with understanding this correctly? I might be wrong!"
                    },
                    {
                        "username": "chenghaoqw",
                        "content": "Why \\n\"ab\" \\n\".*c\"\\n is false???"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I think it is exponential, but I am not sure how to analyze it exactly, what is it?"
                    }
                ]
            },
            {
                "id": 1569806,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "ok, so I done it by my self but I must admit this one was horribly frustraiting.\\nI need to go for a walk..."
                    },
                    {
                        "username": "neizod",
                        "content": "what the fuck is the pattern: a***abc ??? thet\\'s not even in the specification !!!"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Even if consider that * is a character, then\\n\\'s contains only lowercase English letters\\'\\nhow can * match lowercase english letters"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "\\n\\'It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\\'\\n\\nHow is this constraint being followed???"
                    },
                    {
                        "username": "rvjcode",
                        "content": "Input\\n\"aab\"\\n\"c*a*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue\\n\\ncan someone explain how the above results to true?"
                    },
                    {
                        "username": "xieweizhuang",
                        "content": "The example \"ab\" \".\" returns true, but why test case \"ab\" \".*c\" return false?"
                    },
                    {
                        "username": "algopirate",
                        "content": "If here . is a, then * can only repeat a, so it would be ab and aa or ab and bb. How come it is true?"
                    },
                    {
                        "username": "lurosset",
                        "content": "A regular expression can be translated into a nondeterministic finite automaton (NFA). One common algorithm for such is Thompson\\'s Construction (https://en.wikipedia.org/wiki/Thompson\\'s_construction).\\nThen, any NFA can be transformed into a deterministic finite automaton (DFA). It is a tiresome task but easy. Here\\'s a tutorial on it: https://www.tutorialspoint.com/automata_theory/ndfa_to_dfa_conversion.htm.\\n\\nOf course, it\\'s not the fastest way to check for a single pair of _s_ and _p_, but if you happen to be using the same _p_ for many different strings, this approach can save time by checking the string only once.\\n\\n:)"
                    },
                    {
                        "username": "challapalli",
                        "content": "\"aab\"\\n\"c**aab\"\\n\\nFor the above input, I expect the regex to match the given string. Apparently it doesn\\'t. Can anyone explain why?"
                    },
                    {
                        "username": "ameyabp",
                        "content": "There seems to be some ambiguity in the example.\\ns = \"ab\"\\np = \".\\\\*\"\\nanswer = true\\n\\nThere seem to be 2 ways of interpreting the regex p.\\n1. p can be interpreted as **multiple instances of the wildcard** itself. p = \"......\" in which case, s can be generated from p and the result is true\\n2. However, in a second interpretation, we fix the first character, and then we have to stick to it for the multiple instances. We cannot change the character we are writing, midway in a string.\\n\\nCould anyone please help me with understanding this correctly? I might be wrong!"
                    },
                    {
                        "username": "chenghaoqw",
                        "content": "Why \\n\"ab\" \\n\".*c\"\\n is false???"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I think it is exponential, but I am not sure how to analyze it exactly, what is it?"
                    }
                ]
            },
            {
                "id": 1569394,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "ok, so I done it by my self but I must admit this one was horribly frustraiting.\\nI need to go for a walk..."
                    },
                    {
                        "username": "neizod",
                        "content": "what the fuck is the pattern: a***abc ??? thet\\'s not even in the specification !!!"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Even if consider that * is a character, then\\n\\'s contains only lowercase English letters\\'\\nhow can * match lowercase english letters"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "\\n\\'It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\\'\\n\\nHow is this constraint being followed???"
                    },
                    {
                        "username": "rvjcode",
                        "content": "Input\\n\"aab\"\\n\"c*a*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue\\n\\ncan someone explain how the above results to true?"
                    },
                    {
                        "username": "xieweizhuang",
                        "content": "The example \"ab\" \".\" returns true, but why test case \"ab\" \".*c\" return false?"
                    },
                    {
                        "username": "algopirate",
                        "content": "If here . is a, then * can only repeat a, so it would be ab and aa or ab and bb. How come it is true?"
                    },
                    {
                        "username": "lurosset",
                        "content": "A regular expression can be translated into a nondeterministic finite automaton (NFA). One common algorithm for such is Thompson\\'s Construction (https://en.wikipedia.org/wiki/Thompson\\'s_construction).\\nThen, any NFA can be transformed into a deterministic finite automaton (DFA). It is a tiresome task but easy. Here\\'s a tutorial on it: https://www.tutorialspoint.com/automata_theory/ndfa_to_dfa_conversion.htm.\\n\\nOf course, it\\'s not the fastest way to check for a single pair of _s_ and _p_, but if you happen to be using the same _p_ for many different strings, this approach can save time by checking the string only once.\\n\\n:)"
                    },
                    {
                        "username": "challapalli",
                        "content": "\"aab\"\\n\"c**aab\"\\n\\nFor the above input, I expect the regex to match the given string. Apparently it doesn\\'t. Can anyone explain why?"
                    },
                    {
                        "username": "ameyabp",
                        "content": "There seems to be some ambiguity in the example.\\ns = \"ab\"\\np = \".\\\\*\"\\nanswer = true\\n\\nThere seem to be 2 ways of interpreting the regex p.\\n1. p can be interpreted as **multiple instances of the wildcard** itself. p = \"......\" in which case, s can be generated from p and the result is true\\n2. However, in a second interpretation, we fix the first character, and then we have to stick to it for the multiple instances. We cannot change the character we are writing, midway in a string.\\n\\nCould anyone please help me with understanding this correctly? I might be wrong!"
                    },
                    {
                        "username": "chenghaoqw",
                        "content": "Why \\n\"ab\" \\n\".*c\"\\n is false???"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I think it is exponential, but I am not sure how to analyze it exactly, what is it?"
                    }
                ]
            },
            {
                "id": 1568085,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "ok, so I done it by my self but I must admit this one was horribly frustraiting.\\nI need to go for a walk..."
                    },
                    {
                        "username": "neizod",
                        "content": "what the fuck is the pattern: a***abc ??? thet\\'s not even in the specification !!!"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Even if consider that * is a character, then\\n\\'s contains only lowercase English letters\\'\\nhow can * match lowercase english letters"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "\\n\\'It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\\'\\n\\nHow is this constraint being followed???"
                    },
                    {
                        "username": "rvjcode",
                        "content": "Input\\n\"aab\"\\n\"c*a*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue\\n\\ncan someone explain how the above results to true?"
                    },
                    {
                        "username": "xieweizhuang",
                        "content": "The example \"ab\" \".\" returns true, but why test case \"ab\" \".*c\" return false?"
                    },
                    {
                        "username": "algopirate",
                        "content": "If here . is a, then * can only repeat a, so it would be ab and aa or ab and bb. How come it is true?"
                    },
                    {
                        "username": "lurosset",
                        "content": "A regular expression can be translated into a nondeterministic finite automaton (NFA). One common algorithm for such is Thompson\\'s Construction (https://en.wikipedia.org/wiki/Thompson\\'s_construction).\\nThen, any NFA can be transformed into a deterministic finite automaton (DFA). It is a tiresome task but easy. Here\\'s a tutorial on it: https://www.tutorialspoint.com/automata_theory/ndfa_to_dfa_conversion.htm.\\n\\nOf course, it\\'s not the fastest way to check for a single pair of _s_ and _p_, but if you happen to be using the same _p_ for many different strings, this approach can save time by checking the string only once.\\n\\n:)"
                    },
                    {
                        "username": "challapalli",
                        "content": "\"aab\"\\n\"c**aab\"\\n\\nFor the above input, I expect the regex to match the given string. Apparently it doesn\\'t. Can anyone explain why?"
                    },
                    {
                        "username": "ameyabp",
                        "content": "There seems to be some ambiguity in the example.\\ns = \"ab\"\\np = \".\\\\*\"\\nanswer = true\\n\\nThere seem to be 2 ways of interpreting the regex p.\\n1. p can be interpreted as **multiple instances of the wildcard** itself. p = \"......\" in which case, s can be generated from p and the result is true\\n2. However, in a second interpretation, we fix the first character, and then we have to stick to it for the multiple instances. We cannot change the character we are writing, midway in a string.\\n\\nCould anyone please help me with understanding this correctly? I might be wrong!"
                    },
                    {
                        "username": "chenghaoqw",
                        "content": "Why \\n\"ab\" \\n\".*c\"\\n is false???"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I think it is exponential, but I am not sure how to analyze it exactly, what is it?"
                    }
                ]
            },
            {
                "id": 1571018,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "ok, so I done it by my self but I must admit this one was horribly frustraiting.\\nI need to go for a walk..."
                    },
                    {
                        "username": "neizod",
                        "content": "what the fuck is the pattern: a***abc ??? thet\\'s not even in the specification !!!"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Even if consider that * is a character, then\\n\\'s contains only lowercase English letters\\'\\nhow can * match lowercase english letters"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "\\n\\'It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\\'\\n\\nHow is this constraint being followed???"
                    },
                    {
                        "username": "rvjcode",
                        "content": "Input\\n\"aab\"\\n\"c*a*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue\\n\\ncan someone explain how the above results to true?"
                    },
                    {
                        "username": "xieweizhuang",
                        "content": "The example \"ab\" \".\" returns true, but why test case \"ab\" \".*c\" return false?"
                    },
                    {
                        "username": "algopirate",
                        "content": "If here . is a, then * can only repeat a, so it would be ab and aa or ab and bb. How come it is true?"
                    },
                    {
                        "username": "lurosset",
                        "content": "A regular expression can be translated into a nondeterministic finite automaton (NFA). One common algorithm for such is Thompson\\'s Construction (https://en.wikipedia.org/wiki/Thompson\\'s_construction).\\nThen, any NFA can be transformed into a deterministic finite automaton (DFA). It is a tiresome task but easy. Here\\'s a tutorial on it: https://www.tutorialspoint.com/automata_theory/ndfa_to_dfa_conversion.htm.\\n\\nOf course, it\\'s not the fastest way to check for a single pair of _s_ and _p_, but if you happen to be using the same _p_ for many different strings, this approach can save time by checking the string only once.\\n\\n:)"
                    },
                    {
                        "username": "challapalli",
                        "content": "\"aab\"\\n\"c**aab\"\\n\\nFor the above input, I expect the regex to match the given string. Apparently it doesn\\'t. Can anyone explain why?"
                    },
                    {
                        "username": "ameyabp",
                        "content": "There seems to be some ambiguity in the example.\\ns = \"ab\"\\np = \".\\\\*\"\\nanswer = true\\n\\nThere seem to be 2 ways of interpreting the regex p.\\n1. p can be interpreted as **multiple instances of the wildcard** itself. p = \"......\" in which case, s can be generated from p and the result is true\\n2. However, in a second interpretation, we fix the first character, and then we have to stick to it for the multiple instances. We cannot change the character we are writing, midway in a string.\\n\\nCould anyone please help me with understanding this correctly? I might be wrong!"
                    },
                    {
                        "username": "chenghaoqw",
                        "content": "Why \\n\"ab\" \\n\".*c\"\\n is false???"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I think it is exponential, but I am not sure how to analyze it exactly, what is it?"
                    }
                ]
            },
            {
                "id": 1568822,
                "content": [
                    {
                        "username": "trpaslik",
                        "content": "ok, so I done it by my self but I must admit this one was horribly frustraiting.\\nI need to go for a walk..."
                    },
                    {
                        "username": "neizod",
                        "content": "what the fuck is the pattern: a***abc ??? thet\\'s not even in the specification !!!"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "Even if consider that * is a character, then\\n\\'s contains only lowercase English letters\\'\\nhow can * match lowercase english letters"
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "\\n\\'It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\\'\\n\\nHow is this constraint being followed???"
                    },
                    {
                        "username": "rvjcode",
                        "content": "Input\\n\"aab\"\\n\"c*a*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue\\n\\ncan someone explain how the above results to true?"
                    },
                    {
                        "username": "xieweizhuang",
                        "content": "The example \"ab\" \".\" returns true, but why test case \"ab\" \".*c\" return false?"
                    },
                    {
                        "username": "algopirate",
                        "content": "If here . is a, then * can only repeat a, so it would be ab and aa or ab and bb. How come it is true?"
                    },
                    {
                        "username": "lurosset",
                        "content": "A regular expression can be translated into a nondeterministic finite automaton (NFA). One common algorithm for such is Thompson\\'s Construction (https://en.wikipedia.org/wiki/Thompson\\'s_construction).\\nThen, any NFA can be transformed into a deterministic finite automaton (DFA). It is a tiresome task but easy. Here\\'s a tutorial on it: https://www.tutorialspoint.com/automata_theory/ndfa_to_dfa_conversion.htm.\\n\\nOf course, it\\'s not the fastest way to check for a single pair of _s_ and _p_, but if you happen to be using the same _p_ for many different strings, this approach can save time by checking the string only once.\\n\\n:)"
                    },
                    {
                        "username": "challapalli",
                        "content": "\"aab\"\\n\"c**aab\"\\n\\nFor the above input, I expect the regex to match the given string. Apparently it doesn\\'t. Can anyone explain why?"
                    },
                    {
                        "username": "ameyabp",
                        "content": "There seems to be some ambiguity in the example.\\ns = \"ab\"\\np = \".\\\\*\"\\nanswer = true\\n\\nThere seem to be 2 ways of interpreting the regex p.\\n1. p can be interpreted as **multiple instances of the wildcard** itself. p = \"......\" in which case, s can be generated from p and the result is true\\n2. However, in a second interpretation, we fix the first character, and then we have to stick to it for the multiple instances. We cannot change the character we are writing, midway in a string.\\n\\nCould anyone please help me with understanding this correctly? I might be wrong!"
                    },
                    {
                        "username": "chenghaoqw",
                        "content": "Why \\n\"ab\" \\n\".*c\"\\n is false???"
                    },
                    {
                        "username": "IWantToPass",
                        "content": "I think it is exponential, but I am not sure how to analyze it exactly, what is it?"
                    }
                ]
            },
            {
                "id": 1568823,
                "content": [
                    {
                        "username": "zhaozhongyu_",
                        "content": "Input: \"ab\", \".*c\"\\nOutput: true\\nExpected: false\\n\\nI think the '.' matches any single character. And then '*' Matches zero or more of the preceding element.\\nSo when the '.' meet '*' , It can be one or more of the '.', isn't it? And in the example, isMatch(\"ab\", \".*\") \\u2192 true"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "Case 355:\n\"abc\"\n\"a***abc\"\n\nWhy is this case valid?\nNote that: It is guaranteed for each appearance of the character '\\*', there will be a previous valid character to match. While the second '\\*' is not a valid character since it is a special character."
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "[@yashwantraokoyeri](/yashwantraokoyeri) Yeah I\\'ve sent my feedback too."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "This shouldnot be valid, I posted this on the Support page but I still did not get any reply, Why don\\'t you post about this too?"
                    },
                    {
                        "username": "neolyamr",
                        "content": "s =\\n\"aaa\"\\np =\\n\"aaaa\"\\n\\n\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhaaaaaaaaat???? \\njajajjajajjajajaj I can\\'t with this \\n"
                    },
                    {
                        "username": "neildawg",
                        "content": "It\\'s crazy Microsoft asked me this on a phone screen..\\nNow the follow up is changed to `List<String> search(List<String> input, String pattern);`\\nI guess we could naively reuse the `boolean match(String s, String p)`, but is there a more efficient solution like using Trie, and that was what my interviewer was expecting!"
                    },
                    {
                        "username": "hasjgidusabdjsadsa",
                        "content": "s: \"ab\"\\np: \".*c\"\\nAnd the result is false,why?\\n"
                    },
                    {
                        "username": "dyson1204",
                        "content": "can anyone tell me  why \"ab\" and \".*c\" return false, I think i could return true. \\nbecause in the example, \"ab\" and \".*\" return true."
                    },
                    {
                        "username": "niddhi",
                        "content": "as far as i understand * means 0 or more of preceding character.\\nIn the example:\\ns = \"ab\"\\np = \".*\"\\n\\n\\'.\\' matches a and then * is basically on \\'a\\' or can it again consider \\'.\\' as any other character and matches with that?"
                    },
                    {
                        "username": "familytime001",
                        "content": "Preceding element of * could just be \"\" (empty string) in this case,  but (ab, *ab)  returns false.\\n\\nSo I have two questions regarding the validity of a regular expression:\\n\\n1. Is it illegal to have * as a leading character in the pattern(regular expression)?\\n\\n2. Additionally, is it illegal to have ** anywhere in the pattern(regular expression)? \\n"
                    },
                    {
                        "username": "orangetouch",
                        "content": "Example 5:\\nInput:\\ns = \"mississippi\"\\np = \"mis*is*p*.\"\\nOutput: false\\n\\nI think the output should be true.\\nSince mississippi matches 2s, 0s, 0p and any character."
                    },
                    {
                        "username": "xuan3",
                        "content": "If I understand it correctly, * can mean \"any string\" or mean \"remove the previous element\", as seen in the isMatch(\"aab\",\"c*a*b)\" case.\\n\\nIf that is correct, ab*a*c*a can do the following:\\n1. b* means removal of b, ab*a*c*a becomes aa*c*a\\n2. c* means removal of c,  aa*c*a becomes aa*a\\nso why does \"aaba\" not match \"aa*a\"?"
                    }
                ]
            },
            {
                "id": 2054497,
                "content": [
                    {
                        "username": "zhaozhongyu_",
                        "content": "Input: \"ab\", \".*c\"\\nOutput: true\\nExpected: false\\n\\nI think the '.' matches any single character. And then '*' Matches zero or more of the preceding element.\\nSo when the '.' meet '*' , It can be one or more of the '.', isn't it? And in the example, isMatch(\"ab\", \".*\") \\u2192 true"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "Case 355:\n\"abc\"\n\"a***abc\"\n\nWhy is this case valid?\nNote that: It is guaranteed for each appearance of the character '\\*', there will be a previous valid character to match. While the second '\\*' is not a valid character since it is a special character."
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "[@yashwantraokoyeri](/yashwantraokoyeri) Yeah I\\'ve sent my feedback too."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "This shouldnot be valid, I posted this on the Support page but I still did not get any reply, Why don\\'t you post about this too?"
                    },
                    {
                        "username": "neolyamr",
                        "content": "s =\\n\"aaa\"\\np =\\n\"aaaa\"\\n\\n\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhaaaaaaaaat???? \\njajajjajajjajajaj I can\\'t with this \\n"
                    },
                    {
                        "username": "neildawg",
                        "content": "It\\'s crazy Microsoft asked me this on a phone screen..\\nNow the follow up is changed to `List<String> search(List<String> input, String pattern);`\\nI guess we could naively reuse the `boolean match(String s, String p)`, but is there a more efficient solution like using Trie, and that was what my interviewer was expecting!"
                    },
                    {
                        "username": "hasjgidusabdjsadsa",
                        "content": "s: \"ab\"\\np: \".*c\"\\nAnd the result is false,why?\\n"
                    },
                    {
                        "username": "dyson1204",
                        "content": "can anyone tell me  why \"ab\" and \".*c\" return false, I think i could return true. \\nbecause in the example, \"ab\" and \".*\" return true."
                    },
                    {
                        "username": "niddhi",
                        "content": "as far as i understand * means 0 or more of preceding character.\\nIn the example:\\ns = \"ab\"\\np = \".*\"\\n\\n\\'.\\' matches a and then * is basically on \\'a\\' or can it again consider \\'.\\' as any other character and matches with that?"
                    },
                    {
                        "username": "familytime001",
                        "content": "Preceding element of * could just be \"\" (empty string) in this case,  but (ab, *ab)  returns false.\\n\\nSo I have two questions regarding the validity of a regular expression:\\n\\n1. Is it illegal to have * as a leading character in the pattern(regular expression)?\\n\\n2. Additionally, is it illegal to have ** anywhere in the pattern(regular expression)? \\n"
                    },
                    {
                        "username": "orangetouch",
                        "content": "Example 5:\\nInput:\\ns = \"mississippi\"\\np = \"mis*is*p*.\"\\nOutput: false\\n\\nI think the output should be true.\\nSince mississippi matches 2s, 0s, 0p and any character."
                    },
                    {
                        "username": "xuan3",
                        "content": "If I understand it correctly, * can mean \"any string\" or mean \"remove the previous element\", as seen in the isMatch(\"aab\",\"c*a*b)\" case.\\n\\nIf that is correct, ab*a*c*a can do the following:\\n1. b* means removal of b, ab*a*c*a becomes aa*c*a\\n2. c* means removal of c,  aa*c*a becomes aa*a\\nso why does \"aaba\" not match \"aa*a\"?"
                    }
                ]
            },
            {
                "id": 1868108,
                "content": [
                    {
                        "username": "zhaozhongyu_",
                        "content": "Input: \"ab\", \".*c\"\\nOutput: true\\nExpected: false\\n\\nI think the '.' matches any single character. And then '*' Matches zero or more of the preceding element.\\nSo when the '.' meet '*' , It can be one or more of the '.', isn't it? And in the example, isMatch(\"ab\", \".*\") \\u2192 true"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "Case 355:\n\"abc\"\n\"a***abc\"\n\nWhy is this case valid?\nNote that: It is guaranteed for each appearance of the character '\\*', there will be a previous valid character to match. While the second '\\*' is not a valid character since it is a special character."
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "[@yashwantraokoyeri](/yashwantraokoyeri) Yeah I\\'ve sent my feedback too."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "This shouldnot be valid, I posted this on the Support page but I still did not get any reply, Why don\\'t you post about this too?"
                    },
                    {
                        "username": "neolyamr",
                        "content": "s =\\n\"aaa\"\\np =\\n\"aaaa\"\\n\\n\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhaaaaaaaaat???? \\njajajjajajjajajaj I can\\'t with this \\n"
                    },
                    {
                        "username": "neildawg",
                        "content": "It\\'s crazy Microsoft asked me this on a phone screen..\\nNow the follow up is changed to `List<String> search(List<String> input, String pattern);`\\nI guess we could naively reuse the `boolean match(String s, String p)`, but is there a more efficient solution like using Trie, and that was what my interviewer was expecting!"
                    },
                    {
                        "username": "hasjgidusabdjsadsa",
                        "content": "s: \"ab\"\\np: \".*c\"\\nAnd the result is false,why?\\n"
                    },
                    {
                        "username": "dyson1204",
                        "content": "can anyone tell me  why \"ab\" and \".*c\" return false, I think i could return true. \\nbecause in the example, \"ab\" and \".*\" return true."
                    },
                    {
                        "username": "niddhi",
                        "content": "as far as i understand * means 0 or more of preceding character.\\nIn the example:\\ns = \"ab\"\\np = \".*\"\\n\\n\\'.\\' matches a and then * is basically on \\'a\\' or can it again consider \\'.\\' as any other character and matches with that?"
                    },
                    {
                        "username": "familytime001",
                        "content": "Preceding element of * could just be \"\" (empty string) in this case,  but (ab, *ab)  returns false.\\n\\nSo I have two questions regarding the validity of a regular expression:\\n\\n1. Is it illegal to have * as a leading character in the pattern(regular expression)?\\n\\n2. Additionally, is it illegal to have ** anywhere in the pattern(regular expression)? \\n"
                    },
                    {
                        "username": "orangetouch",
                        "content": "Example 5:\\nInput:\\ns = \"mississippi\"\\np = \"mis*is*p*.\"\\nOutput: false\\n\\nI think the output should be true.\\nSince mississippi matches 2s, 0s, 0p and any character."
                    },
                    {
                        "username": "xuan3",
                        "content": "If I understand it correctly, * can mean \"any string\" or mean \"remove the previous element\", as seen in the isMatch(\"aab\",\"c*a*b)\" case.\\n\\nIf that is correct, ab*a*c*a can do the following:\\n1. b* means removal of b, ab*a*c*a becomes aa*c*a\\n2. c* means removal of c,  aa*c*a becomes aa*a\\nso why does \"aaba\" not match \"aa*a\"?"
                    }
                ]
            },
            {
                "id": 1574164,
                "content": [
                    {
                        "username": "zhaozhongyu_",
                        "content": "Input: \"ab\", \".*c\"\\nOutput: true\\nExpected: false\\n\\nI think the '.' matches any single character. And then '*' Matches zero or more of the preceding element.\\nSo when the '.' meet '*' , It can be one or more of the '.', isn't it? And in the example, isMatch(\"ab\", \".*\") \\u2192 true"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "Case 355:\n\"abc\"\n\"a***abc\"\n\nWhy is this case valid?\nNote that: It is guaranteed for each appearance of the character '\\*', there will be a previous valid character to match. While the second '\\*' is not a valid character since it is a special character."
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "[@yashwantraokoyeri](/yashwantraokoyeri) Yeah I\\'ve sent my feedback too."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "This shouldnot be valid, I posted this on the Support page but I still did not get any reply, Why don\\'t you post about this too?"
                    },
                    {
                        "username": "neolyamr",
                        "content": "s =\\n\"aaa\"\\np =\\n\"aaaa\"\\n\\n\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhaaaaaaaaat???? \\njajajjajajjajajaj I can\\'t with this \\n"
                    },
                    {
                        "username": "neildawg",
                        "content": "It\\'s crazy Microsoft asked me this on a phone screen..\\nNow the follow up is changed to `List<String> search(List<String> input, String pattern);`\\nI guess we could naively reuse the `boolean match(String s, String p)`, but is there a more efficient solution like using Trie, and that was what my interviewer was expecting!"
                    },
                    {
                        "username": "hasjgidusabdjsadsa",
                        "content": "s: \"ab\"\\np: \".*c\"\\nAnd the result is false,why?\\n"
                    },
                    {
                        "username": "dyson1204",
                        "content": "can anyone tell me  why \"ab\" and \".*c\" return false, I think i could return true. \\nbecause in the example, \"ab\" and \".*\" return true."
                    },
                    {
                        "username": "niddhi",
                        "content": "as far as i understand * means 0 or more of preceding character.\\nIn the example:\\ns = \"ab\"\\np = \".*\"\\n\\n\\'.\\' matches a and then * is basically on \\'a\\' or can it again consider \\'.\\' as any other character and matches with that?"
                    },
                    {
                        "username": "familytime001",
                        "content": "Preceding element of * could just be \"\" (empty string) in this case,  but (ab, *ab)  returns false.\\n\\nSo I have two questions regarding the validity of a regular expression:\\n\\n1. Is it illegal to have * as a leading character in the pattern(regular expression)?\\n\\n2. Additionally, is it illegal to have ** anywhere in the pattern(regular expression)? \\n"
                    },
                    {
                        "username": "orangetouch",
                        "content": "Example 5:\\nInput:\\ns = \"mississippi\"\\np = \"mis*is*p*.\"\\nOutput: false\\n\\nI think the output should be true.\\nSince mississippi matches 2s, 0s, 0p and any character."
                    },
                    {
                        "username": "xuan3",
                        "content": "If I understand it correctly, * can mean \"any string\" or mean \"remove the previous element\", as seen in the isMatch(\"aab\",\"c*a*b)\" case.\\n\\nIf that is correct, ab*a*c*a can do the following:\\n1. b* means removal of b, ab*a*c*a becomes aa*c*a\\n2. c* means removal of c,  aa*c*a becomes aa*a\\nso why does \"aaba\" not match \"aa*a\"?"
                    }
                ]
            },
            {
                "id": 1572771,
                "content": [
                    {
                        "username": "zhaozhongyu_",
                        "content": "Input: \"ab\", \".*c\"\\nOutput: true\\nExpected: false\\n\\nI think the '.' matches any single character. And then '*' Matches zero or more of the preceding element.\\nSo when the '.' meet '*' , It can be one or more of the '.', isn't it? And in the example, isMatch(\"ab\", \".*\") \\u2192 true"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "Case 355:\n\"abc\"\n\"a***abc\"\n\nWhy is this case valid?\nNote that: It is guaranteed for each appearance of the character '\\*', there will be a previous valid character to match. While the second '\\*' is not a valid character since it is a special character."
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "[@yashwantraokoyeri](/yashwantraokoyeri) Yeah I\\'ve sent my feedback too."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "This shouldnot be valid, I posted this on the Support page but I still did not get any reply, Why don\\'t you post about this too?"
                    },
                    {
                        "username": "neolyamr",
                        "content": "s =\\n\"aaa\"\\np =\\n\"aaaa\"\\n\\n\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhaaaaaaaaat???? \\njajajjajajjajajaj I can\\'t with this \\n"
                    },
                    {
                        "username": "neildawg",
                        "content": "It\\'s crazy Microsoft asked me this on a phone screen..\\nNow the follow up is changed to `List<String> search(List<String> input, String pattern);`\\nI guess we could naively reuse the `boolean match(String s, String p)`, but is there a more efficient solution like using Trie, and that was what my interviewer was expecting!"
                    },
                    {
                        "username": "hasjgidusabdjsadsa",
                        "content": "s: \"ab\"\\np: \".*c\"\\nAnd the result is false,why?\\n"
                    },
                    {
                        "username": "dyson1204",
                        "content": "can anyone tell me  why \"ab\" and \".*c\" return false, I think i could return true. \\nbecause in the example, \"ab\" and \".*\" return true."
                    },
                    {
                        "username": "niddhi",
                        "content": "as far as i understand * means 0 or more of preceding character.\\nIn the example:\\ns = \"ab\"\\np = \".*\"\\n\\n\\'.\\' matches a and then * is basically on \\'a\\' or can it again consider \\'.\\' as any other character and matches with that?"
                    },
                    {
                        "username": "familytime001",
                        "content": "Preceding element of * could just be \"\" (empty string) in this case,  but (ab, *ab)  returns false.\\n\\nSo I have two questions regarding the validity of a regular expression:\\n\\n1. Is it illegal to have * as a leading character in the pattern(regular expression)?\\n\\n2. Additionally, is it illegal to have ** anywhere in the pattern(regular expression)? \\n"
                    },
                    {
                        "username": "orangetouch",
                        "content": "Example 5:\\nInput:\\ns = \"mississippi\"\\np = \"mis*is*p*.\"\\nOutput: false\\n\\nI think the output should be true.\\nSince mississippi matches 2s, 0s, 0p and any character."
                    },
                    {
                        "username": "xuan3",
                        "content": "If I understand it correctly, * can mean \"any string\" or mean \"remove the previous element\", as seen in the isMatch(\"aab\",\"c*a*b)\" case.\\n\\nIf that is correct, ab*a*c*a can do the following:\\n1. b* means removal of b, ab*a*c*a becomes aa*c*a\\n2. c* means removal of c,  aa*c*a becomes aa*a\\nso why does \"aaba\" not match \"aa*a\"?"
                    }
                ]
            },
            {
                "id": 1572746,
                "content": [
                    {
                        "username": "zhaozhongyu_",
                        "content": "Input: \"ab\", \".*c\"\\nOutput: true\\nExpected: false\\n\\nI think the '.' matches any single character. And then '*' Matches zero or more of the preceding element.\\nSo when the '.' meet '*' , It can be one or more of the '.', isn't it? And in the example, isMatch(\"ab\", \".*\") \\u2192 true"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "Case 355:\n\"abc\"\n\"a***abc\"\n\nWhy is this case valid?\nNote that: It is guaranteed for each appearance of the character '\\*', there will be a previous valid character to match. While the second '\\*' is not a valid character since it is a special character."
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "[@yashwantraokoyeri](/yashwantraokoyeri) Yeah I\\'ve sent my feedback too."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "This shouldnot be valid, I posted this on the Support page but I still did not get any reply, Why don\\'t you post about this too?"
                    },
                    {
                        "username": "neolyamr",
                        "content": "s =\\n\"aaa\"\\np =\\n\"aaaa\"\\n\\n\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhaaaaaaaaat???? \\njajajjajajjajajaj I can\\'t with this \\n"
                    },
                    {
                        "username": "neildawg",
                        "content": "It\\'s crazy Microsoft asked me this on a phone screen..\\nNow the follow up is changed to `List<String> search(List<String> input, String pattern);`\\nI guess we could naively reuse the `boolean match(String s, String p)`, but is there a more efficient solution like using Trie, and that was what my interviewer was expecting!"
                    },
                    {
                        "username": "hasjgidusabdjsadsa",
                        "content": "s: \"ab\"\\np: \".*c\"\\nAnd the result is false,why?\\n"
                    },
                    {
                        "username": "dyson1204",
                        "content": "can anyone tell me  why \"ab\" and \".*c\" return false, I think i could return true. \\nbecause in the example, \"ab\" and \".*\" return true."
                    },
                    {
                        "username": "niddhi",
                        "content": "as far as i understand * means 0 or more of preceding character.\\nIn the example:\\ns = \"ab\"\\np = \".*\"\\n\\n\\'.\\' matches a and then * is basically on \\'a\\' or can it again consider \\'.\\' as any other character and matches with that?"
                    },
                    {
                        "username": "familytime001",
                        "content": "Preceding element of * could just be \"\" (empty string) in this case,  but (ab, *ab)  returns false.\\n\\nSo I have two questions regarding the validity of a regular expression:\\n\\n1. Is it illegal to have * as a leading character in the pattern(regular expression)?\\n\\n2. Additionally, is it illegal to have ** anywhere in the pattern(regular expression)? \\n"
                    },
                    {
                        "username": "orangetouch",
                        "content": "Example 5:\\nInput:\\ns = \"mississippi\"\\np = \"mis*is*p*.\"\\nOutput: false\\n\\nI think the output should be true.\\nSince mississippi matches 2s, 0s, 0p and any character."
                    },
                    {
                        "username": "xuan3",
                        "content": "If I understand it correctly, * can mean \"any string\" or mean \"remove the previous element\", as seen in the isMatch(\"aab\",\"c*a*b)\" case.\\n\\nIf that is correct, ab*a*c*a can do the following:\\n1. b* means removal of b, ab*a*c*a becomes aa*c*a\\n2. c* means removal of c,  aa*c*a becomes aa*a\\nso why does \"aaba\" not match \"aa*a\"?"
                    }
                ]
            },
            {
                "id": 1569383,
                "content": [
                    {
                        "username": "zhaozhongyu_",
                        "content": "Input: \"ab\", \".*c\"\\nOutput: true\\nExpected: false\\n\\nI think the '.' matches any single character. And then '*' Matches zero or more of the preceding element.\\nSo when the '.' meet '*' , It can be one or more of the '.', isn't it? And in the example, isMatch(\"ab\", \".*\") \\u2192 true"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "Case 355:\n\"abc\"\n\"a***abc\"\n\nWhy is this case valid?\nNote that: It is guaranteed for each appearance of the character '\\*', there will be a previous valid character to match. While the second '\\*' is not a valid character since it is a special character."
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "[@yashwantraokoyeri](/yashwantraokoyeri) Yeah I\\'ve sent my feedback too."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "This shouldnot be valid, I posted this on the Support page but I still did not get any reply, Why don\\'t you post about this too?"
                    },
                    {
                        "username": "neolyamr",
                        "content": "s =\\n\"aaa\"\\np =\\n\"aaaa\"\\n\\n\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhaaaaaaaaat???? \\njajajjajajjajajaj I can\\'t with this \\n"
                    },
                    {
                        "username": "neildawg",
                        "content": "It\\'s crazy Microsoft asked me this on a phone screen..\\nNow the follow up is changed to `List<String> search(List<String> input, String pattern);`\\nI guess we could naively reuse the `boolean match(String s, String p)`, but is there a more efficient solution like using Trie, and that was what my interviewer was expecting!"
                    },
                    {
                        "username": "hasjgidusabdjsadsa",
                        "content": "s: \"ab\"\\np: \".*c\"\\nAnd the result is false,why?\\n"
                    },
                    {
                        "username": "dyson1204",
                        "content": "can anyone tell me  why \"ab\" and \".*c\" return false, I think i could return true. \\nbecause in the example, \"ab\" and \".*\" return true."
                    },
                    {
                        "username": "niddhi",
                        "content": "as far as i understand * means 0 or more of preceding character.\\nIn the example:\\ns = \"ab\"\\np = \".*\"\\n\\n\\'.\\' matches a and then * is basically on \\'a\\' or can it again consider \\'.\\' as any other character and matches with that?"
                    },
                    {
                        "username": "familytime001",
                        "content": "Preceding element of * could just be \"\" (empty string) in this case,  but (ab, *ab)  returns false.\\n\\nSo I have two questions regarding the validity of a regular expression:\\n\\n1. Is it illegal to have * as a leading character in the pattern(regular expression)?\\n\\n2. Additionally, is it illegal to have ** anywhere in the pattern(regular expression)? \\n"
                    },
                    {
                        "username": "orangetouch",
                        "content": "Example 5:\\nInput:\\ns = \"mississippi\"\\np = \"mis*is*p*.\"\\nOutput: false\\n\\nI think the output should be true.\\nSince mississippi matches 2s, 0s, 0p and any character."
                    },
                    {
                        "username": "xuan3",
                        "content": "If I understand it correctly, * can mean \"any string\" or mean \"remove the previous element\", as seen in the isMatch(\"aab\",\"c*a*b)\" case.\\n\\nIf that is correct, ab*a*c*a can do the following:\\n1. b* means removal of b, ab*a*c*a becomes aa*c*a\\n2. c* means removal of c,  aa*c*a becomes aa*a\\nso why does \"aaba\" not match \"aa*a\"?"
                    }
                ]
            },
            {
                "id": 1569271,
                "content": [
                    {
                        "username": "zhaozhongyu_",
                        "content": "Input: \"ab\", \".*c\"\\nOutput: true\\nExpected: false\\n\\nI think the '.' matches any single character. And then '*' Matches zero or more of the preceding element.\\nSo when the '.' meet '*' , It can be one or more of the '.', isn't it? And in the example, isMatch(\"ab\", \".*\") \\u2192 true"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "Case 355:\n\"abc\"\n\"a***abc\"\n\nWhy is this case valid?\nNote that: It is guaranteed for each appearance of the character '\\*', there will be a previous valid character to match. While the second '\\*' is not a valid character since it is a special character."
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "[@yashwantraokoyeri](/yashwantraokoyeri) Yeah I\\'ve sent my feedback too."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "This shouldnot be valid, I posted this on the Support page but I still did not get any reply, Why don\\'t you post about this too?"
                    },
                    {
                        "username": "neolyamr",
                        "content": "s =\\n\"aaa\"\\np =\\n\"aaaa\"\\n\\n\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhaaaaaaaaat???? \\njajajjajajjajajaj I can\\'t with this \\n"
                    },
                    {
                        "username": "neildawg",
                        "content": "It\\'s crazy Microsoft asked me this on a phone screen..\\nNow the follow up is changed to `List<String> search(List<String> input, String pattern);`\\nI guess we could naively reuse the `boolean match(String s, String p)`, but is there a more efficient solution like using Trie, and that was what my interviewer was expecting!"
                    },
                    {
                        "username": "hasjgidusabdjsadsa",
                        "content": "s: \"ab\"\\np: \".*c\"\\nAnd the result is false,why?\\n"
                    },
                    {
                        "username": "dyson1204",
                        "content": "can anyone tell me  why \"ab\" and \".*c\" return false, I think i could return true. \\nbecause in the example, \"ab\" and \".*\" return true."
                    },
                    {
                        "username": "niddhi",
                        "content": "as far as i understand * means 0 or more of preceding character.\\nIn the example:\\ns = \"ab\"\\np = \".*\"\\n\\n\\'.\\' matches a and then * is basically on \\'a\\' or can it again consider \\'.\\' as any other character and matches with that?"
                    },
                    {
                        "username": "familytime001",
                        "content": "Preceding element of * could just be \"\" (empty string) in this case,  but (ab, *ab)  returns false.\\n\\nSo I have two questions regarding the validity of a regular expression:\\n\\n1. Is it illegal to have * as a leading character in the pattern(regular expression)?\\n\\n2. Additionally, is it illegal to have ** anywhere in the pattern(regular expression)? \\n"
                    },
                    {
                        "username": "orangetouch",
                        "content": "Example 5:\\nInput:\\ns = \"mississippi\"\\np = \"mis*is*p*.\"\\nOutput: false\\n\\nI think the output should be true.\\nSince mississippi matches 2s, 0s, 0p and any character."
                    },
                    {
                        "username": "xuan3",
                        "content": "If I understand it correctly, * can mean \"any string\" or mean \"remove the previous element\", as seen in the isMatch(\"aab\",\"c*a*b)\" case.\\n\\nIf that is correct, ab*a*c*a can do the following:\\n1. b* means removal of b, ab*a*c*a becomes aa*c*a\\n2. c* means removal of c,  aa*c*a becomes aa*a\\nso why does \"aaba\" not match \"aa*a\"?"
                    }
                ]
            },
            {
                "id": 1569261,
                "content": [
                    {
                        "username": "zhaozhongyu_",
                        "content": "Input: \"ab\", \".*c\"\\nOutput: true\\nExpected: false\\n\\nI think the '.' matches any single character. And then '*' Matches zero or more of the preceding element.\\nSo when the '.' meet '*' , It can be one or more of the '.', isn't it? And in the example, isMatch(\"ab\", \".*\") \\u2192 true"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "Case 355:\n\"abc\"\n\"a***abc\"\n\nWhy is this case valid?\nNote that: It is guaranteed for each appearance of the character '\\*', there will be a previous valid character to match. While the second '\\*' is not a valid character since it is a special character."
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "[@yashwantraokoyeri](/yashwantraokoyeri) Yeah I\\'ve sent my feedback too."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "This shouldnot be valid, I posted this on the Support page but I still did not get any reply, Why don\\'t you post about this too?"
                    },
                    {
                        "username": "neolyamr",
                        "content": "s =\\n\"aaa\"\\np =\\n\"aaaa\"\\n\\n\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhaaaaaaaaat???? \\njajajjajajjajajaj I can\\'t with this \\n"
                    },
                    {
                        "username": "neildawg",
                        "content": "It\\'s crazy Microsoft asked me this on a phone screen..\\nNow the follow up is changed to `List<String> search(List<String> input, String pattern);`\\nI guess we could naively reuse the `boolean match(String s, String p)`, but is there a more efficient solution like using Trie, and that was what my interviewer was expecting!"
                    },
                    {
                        "username": "hasjgidusabdjsadsa",
                        "content": "s: \"ab\"\\np: \".*c\"\\nAnd the result is false,why?\\n"
                    },
                    {
                        "username": "dyson1204",
                        "content": "can anyone tell me  why \"ab\" and \".*c\" return false, I think i could return true. \\nbecause in the example, \"ab\" and \".*\" return true."
                    },
                    {
                        "username": "niddhi",
                        "content": "as far as i understand * means 0 or more of preceding character.\\nIn the example:\\ns = \"ab\"\\np = \".*\"\\n\\n\\'.\\' matches a and then * is basically on \\'a\\' or can it again consider \\'.\\' as any other character and matches with that?"
                    },
                    {
                        "username": "familytime001",
                        "content": "Preceding element of * could just be \"\" (empty string) in this case,  but (ab, *ab)  returns false.\\n\\nSo I have two questions regarding the validity of a regular expression:\\n\\n1. Is it illegal to have * as a leading character in the pattern(regular expression)?\\n\\n2. Additionally, is it illegal to have ** anywhere in the pattern(regular expression)? \\n"
                    },
                    {
                        "username": "orangetouch",
                        "content": "Example 5:\\nInput:\\ns = \"mississippi\"\\np = \"mis*is*p*.\"\\nOutput: false\\n\\nI think the output should be true.\\nSince mississippi matches 2s, 0s, 0p and any character."
                    },
                    {
                        "username": "xuan3",
                        "content": "If I understand it correctly, * can mean \"any string\" or mean \"remove the previous element\", as seen in the isMatch(\"aab\",\"c*a*b)\" case.\\n\\nIf that is correct, ab*a*c*a can do the following:\\n1. b* means removal of b, ab*a*c*a becomes aa*c*a\\n2. c* means removal of c,  aa*c*a becomes aa*a\\nso why does \"aaba\" not match \"aa*a\"?"
                    }
                ]
            },
            {
                "id": 1568825,
                "content": [
                    {
                        "username": "zhaozhongyu_",
                        "content": "Input: \"ab\", \".*c\"\\nOutput: true\\nExpected: false\\n\\nI think the '.' matches any single character. And then '*' Matches zero or more of the preceding element.\\nSo when the '.' meet '*' , It can be one or more of the '.', isn't it? And in the example, isMatch(\"ab\", \".*\") \\u2192 true"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "Case 355:\n\"abc\"\n\"a***abc\"\n\nWhy is this case valid?\nNote that: It is guaranteed for each appearance of the character '\\*', there will be a previous valid character to match. While the second '\\*' is not a valid character since it is a special character."
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "[@yashwantraokoyeri](/yashwantraokoyeri) Yeah I\\'ve sent my feedback too."
                    },
                    {
                        "username": "yashwantraokoyeri",
                        "content": "This shouldnot be valid, I posted this on the Support page but I still did not get any reply, Why don\\'t you post about this too?"
                    },
                    {
                        "username": "neolyamr",
                        "content": "s =\\n\"aaa\"\\np =\\n\"aaaa\"\\n\\n\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhaaaaaaaaat???? \\njajajjajajjajajaj I can\\'t with this \\n"
                    },
                    {
                        "username": "neildawg",
                        "content": "It\\'s crazy Microsoft asked me this on a phone screen..\\nNow the follow up is changed to `List<String> search(List<String> input, String pattern);`\\nI guess we could naively reuse the `boolean match(String s, String p)`, but is there a more efficient solution like using Trie, and that was what my interviewer was expecting!"
                    },
                    {
                        "username": "hasjgidusabdjsadsa",
                        "content": "s: \"ab\"\\np: \".*c\"\\nAnd the result is false,why?\\n"
                    },
                    {
                        "username": "dyson1204",
                        "content": "can anyone tell me  why \"ab\" and \".*c\" return false, I think i could return true. \\nbecause in the example, \"ab\" and \".*\" return true."
                    },
                    {
                        "username": "niddhi",
                        "content": "as far as i understand * means 0 or more of preceding character.\\nIn the example:\\ns = \"ab\"\\np = \".*\"\\n\\n\\'.\\' matches a and then * is basically on \\'a\\' or can it again consider \\'.\\' as any other character and matches with that?"
                    },
                    {
                        "username": "familytime001",
                        "content": "Preceding element of * could just be \"\" (empty string) in this case,  but (ab, *ab)  returns false.\\n\\nSo I have two questions regarding the validity of a regular expression:\\n\\n1. Is it illegal to have * as a leading character in the pattern(regular expression)?\\n\\n2. Additionally, is it illegal to have ** anywhere in the pattern(regular expression)? \\n"
                    },
                    {
                        "username": "orangetouch",
                        "content": "Example 5:\\nInput:\\ns = \"mississippi\"\\np = \"mis*is*p*.\"\\nOutput: false\\n\\nI think the output should be true.\\nSince mississippi matches 2s, 0s, 0p and any character."
                    },
                    {
                        "username": "xuan3",
                        "content": "If I understand it correctly, * can mean \"any string\" or mean \"remove the previous element\", as seen in the isMatch(\"aab\",\"c*a*b)\" case.\\n\\nIf that is correct, ab*a*c*a can do the following:\\n1. b* means removal of b, ab*a*c*a becomes aa*c*a\\n2. c* means removal of c,  aa*c*a becomes aa*a\\nso why does \"aaba\" not match \"aa*a\"?"
                    }
                ]
            },
            {
                "id": 1567799,
                "content": [
                    {
                        "username": "mylemoncake",
                        "content": "So the * matches the wild character . itself but not the actual char it may represents?"
                    },
                    {
                        "username": "guapter",
                        "content": "it is NOT valid regex! \n```\ns =\"abc\"\np =\"a***abc\"\n```\n\nin task conditions there is a constraint: \"It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\"\nfor case of a*** it is invalid regex expression. If imagine we should convert it to real regex - it could be too many options here - a*/*/* a/**/* a/*/*/* and so on, thats why regex dont accept this expression! \nyour tests have syntax error! Fix pls! "
                    },
                    {
                        "username": "weraponpat",
                        "content": "believe me or not I got this question in the actual interview."
                    },
                    {
                        "username": "user8272RT",
                        "content": "This was hard. Took multiple attempts to resolve the edge cases."
                    },
                    {
                        "username": "Suharkov",
                        "content": "What i\\'m doing wrong?\\n`s = \"abc\"`\\n`p = \"a***abc\"`\\nExpected true, but `a***abc` is not a valid regular expression.."
                    },
                    {
                        "username": "Andrew_Richards_CS",
                        "content": "The leetcode top-down java solution fails the last test case on this question due to time limit exceeded when executing case:\\ns=\"aaaaaaaaaaaaaaaaaaab\"\\np=\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nI\\'m considering this one completed with my original solution. If this test case gets removed, I will revisit."
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "For some reason it gets accepted on Submission, even when it fails on individual run with TLE."
                    },
                    {
                        "username": "nesenenkoav",
                        "content": "67 tescases is invalid and should be fixed\\n\\n        std::map< std::pair<std::string, std::string>, bool > invalidCases = {\\n            { {\"aab\", \"c*a*b\"}, true },\\n            { {\"mississippi\", \"mis*is*p*.\"}, false },\\n            { {\"aaa\", \"ab*ac*a\"}, true },\\n            { {\"aaa\", \"ab*a*c*a\"}, true },\\n            { {\"aaca\", \"ab*a*c*a\"}, true },\\n            { {\"a\", \"ab*\"}, true },\\n            { {\"bbbba\", \".*a*a\"}, true },\\n            { {\"ab\", \".*..\"}, true },\\n            { {\"ab\", \".*..c*\"}, true },\\n            { {\"a\", \".*.\"}, true },\\n            { {\"aasdfasdfasdfasdfas\", \"aasdf.*asdf.*asdf.*asdf.*s\"}, true },\\n            { {\"abbbcd\", \"ab*bbbcd\"}, true },\\n            { {\"bbab\", \"b*a*\"}, false },\\n            { {\"a\", \"c*.\"}, true },\\n            { {\"a\", \"c*a\"}, true },\\n            { {\"b\", \"a*.\"}, true },\\n            { {\"a\", \".*a*\"}, true },\\n            { {\"a\", \"..*\"}, true },\\n            { {\"aabcbcbcaccbcaabc\", \".*a*aa*.*b*.c*.*a*\"}, true },\\n            { {\"abbabaaaaaaacaa\", \"a*.*b.a.*c*b*a*c*\"}, true },\\n            { {\"bcaccbbacbcbcab\", \"b*.c*..*.b*b*.*c*\"}, true },\\n            { {\"baabbbaccbccacacc\", \"c*..b*a*a.*a..*c\"}, true },\\n            { {\"abcaaaaaaabaabcabac\", \".*ab.a.*a*a*.*b*b*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cabbbbcbcacbabc\", \".*b.*.ab*.*b*a*c\"}, true },\\n            { {\"abbcacbbbbbabcbaca\", \"a*a*.*a*.*a*.b*a*\"}, true },\\n            { {\"aababbabacaabacbbbc\", \".b*ac*.*c*a*b*.*\"}, true },\\n            { {\"aaabaaaababcbccbaab\", \"c*c*.*c*a*..*c*\"}, true },\\n            { {\"cbccaababcbabac\", \"c*aab*.*b.b.*.*a*.\"}, false },\\n            { {\"caccccaccbabbcb\", \"c*c*b*a*.*c*.a*a*a*\"}, true },\\n            { {\"bbbaccbbbaababbac\", \".b*b*.*...*.*c*.\"}, true },\\n            { {\"ccbbcabcbbaabaccc\", \"c*a*.*a*a*.*c*b*b*.\"}, true },\\n            { {\"abbaaaabaabbcba\", \"a*.*ba.*c*..a*.a*.\"}, true },\\n            { {\"bbcacbabbcbaaccabc\", \"b*a*a*.c*bb*b*.*.*\"}, true },\\n            { {\"aabccbcbacabaab\", \".*c*a*b.*a*ba*bb*\"}, true },\\n            { {\"cbbbaccbcacbcca\", \"b*.*b*a*.a*b*.a*\"}, true },\\n            { {\"cbacbbabbcaabbb\", \"b*c*.*a*..a.*c*.*\"}, true },\\n            { {\"abaabababbcbcabbcbc\", \"b*ab.*.*.*.b..*\"}, true },\\n            { {\"caaacccbaababbb\", \"c*.*b*ba*ac*c*b*.*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"cacbacccbbbccab\", \".b*b*.*c*a*.*bb*\"}, true },\\n            { {\"abcbccbcbaabbcbb\", \"c*a.*ab*.*ab*a*..b*\"}, true },\\n            { {\"caabbabbbbccccbbbcc\", \".b*c*.*.*bb*.*.*\"}, true },\\n            { {\"caaccabbbabcacaac\", \"b*c*b*b*.b*.*c*a*c\"}, true },\\n            { {\"cbcaabcbaabccbaa\", \"c*b*ab*.*b*c*a*\"}, false },\\n            { {\"bccbcccbcbbbcbb\", \"c*c*c*c*c*.*.*b*b*\"}, true },\\n            { {\"ccacbcbcccabbab\", \".c*a*aa*b*.*b*.*\"}, true },\\n            { {\"aabbcbcacbacaaccacc\", \"c*b*b*.*.*.*a*.*\"}, true },\\n            { {\"bcbabcaacacbcabac\", \"a*c*a*b*.*aa*c*a*a*\"}, true },\\n            { {\"acabbabacaccacccabc\", \"a*.*c*a*.b.*a*.*\"}, true },\\n            { {\"babbcccbacaabcbac\", \"b.*.*c*b*b*.*c*c\"}, true },            \\n            { {\"cbbbbabaabbacbbc\", \"a*c*b*.*bb*a*.*a*\"}, true },            \\n            { {\"accbabbacbbbacb\", \".*.*.*a*bba*ba*\"}, false },\\n            { {\"ababbcaaabbaccb\", \"c*c*..*a*a*a*.*\"}, true },\\n            { {\"bcabcbcaccabcbb\", \"a*a*c*a*.*a*c*bc*.\"}, true },\\n            { {\"bcbbbacbabccbabbac\", \"c*.*b*a.*a*a*a*\"}, true },\\n            { {\"ccbbbbbacacaaabcaa\", \".*ba*.*.b*c*c*b*a.*\"}, true },\\n            { {\"acaababbccbaacabcab\", \"..*bb*b*c*a*c*.*.b\"}, true },\\n            { {\"cbabcabbbacbcaca\", \"a*c*.*a*a*b*c*a*.*\"}, true },\\n            { {\"bacacaababbbcbc\", \".*a*.*a*.aa*c*b*c\"}, false },\\n            { {\"cbabcbbaabbcaca\", \".a*b*.*.*b*c*.*b*a*\"}, true },\\n            { {\"bbaaaacabccbcac\", \"b*b*a*c*c*a*c*.*\"}, true },\\n            { {\"bcccccbaccccacaa\", \".*bb*c*a*b*.*b*b*c*\"}, true },\\n            { {\"bcbaccbbbccabaac\", \"c*.*a*b*ac*a*a*\"}, true },\\n            { {\"bacacbacaaabccbcbaa\", \"a*.c*c*c*a*b*..*\"}, true },\\n            { {\"baccbbcbcacacbbc\", \"c*.*b*c*ba*b*b*.a*\"}, true },\\n\\n        };"
                    },
                    {
                        "username": "Husoski",
                        "content": "Which test are you complaining about?  I only checked the first six patterns and they are all good.  If you have doubts, try using an IDE or code-friendly editor with regex search to \"find\" the target string using the given pattern."
                    },
                    {
                        "username": "ophirrachman",
                        "content": "Wrong Answer\\n\\nDetails \\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@ophirrachman](/ophirrachman) In this case `c*` can be removed, `a*` can occur 2 times so it forms `aab`, hence it returns `true`"
                    },
                    {
                        "username": "taxpayer61543",
                        "content": "\"aab\"\\n\"c\\\\*a*b\"\\n\\nThis test case is wrong. Should output False, not True."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/\\n"
                    }
                ]
            },
            {
                "id": 2064303,
                "content": [
                    {
                        "username": "mylemoncake",
                        "content": "So the * matches the wild character . itself but not the actual char it may represents?"
                    },
                    {
                        "username": "guapter",
                        "content": "it is NOT valid regex! \n```\ns =\"abc\"\np =\"a***abc\"\n```\n\nin task conditions there is a constraint: \"It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\"\nfor case of a*** it is invalid regex expression. If imagine we should convert it to real regex - it could be too many options here - a*/*/* a/**/* a/*/*/* and so on, thats why regex dont accept this expression! \nyour tests have syntax error! Fix pls! "
                    },
                    {
                        "username": "weraponpat",
                        "content": "believe me or not I got this question in the actual interview."
                    },
                    {
                        "username": "user8272RT",
                        "content": "This was hard. Took multiple attempts to resolve the edge cases."
                    },
                    {
                        "username": "Suharkov",
                        "content": "What i\\'m doing wrong?\\n`s = \"abc\"`\\n`p = \"a***abc\"`\\nExpected true, but `a***abc` is not a valid regular expression.."
                    },
                    {
                        "username": "Andrew_Richards_CS",
                        "content": "The leetcode top-down java solution fails the last test case on this question due to time limit exceeded when executing case:\\ns=\"aaaaaaaaaaaaaaaaaaab\"\\np=\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nI\\'m considering this one completed with my original solution. If this test case gets removed, I will revisit."
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "For some reason it gets accepted on Submission, even when it fails on individual run with TLE."
                    },
                    {
                        "username": "nesenenkoav",
                        "content": "67 tescases is invalid and should be fixed\\n\\n        std::map< std::pair<std::string, std::string>, bool > invalidCases = {\\n            { {\"aab\", \"c*a*b\"}, true },\\n            { {\"mississippi\", \"mis*is*p*.\"}, false },\\n            { {\"aaa\", \"ab*ac*a\"}, true },\\n            { {\"aaa\", \"ab*a*c*a\"}, true },\\n            { {\"aaca\", \"ab*a*c*a\"}, true },\\n            { {\"a\", \"ab*\"}, true },\\n            { {\"bbbba\", \".*a*a\"}, true },\\n            { {\"ab\", \".*..\"}, true },\\n            { {\"ab\", \".*..c*\"}, true },\\n            { {\"a\", \".*.\"}, true },\\n            { {\"aasdfasdfasdfasdfas\", \"aasdf.*asdf.*asdf.*asdf.*s\"}, true },\\n            { {\"abbbcd\", \"ab*bbbcd\"}, true },\\n            { {\"bbab\", \"b*a*\"}, false },\\n            { {\"a\", \"c*.\"}, true },\\n            { {\"a\", \"c*a\"}, true },\\n            { {\"b\", \"a*.\"}, true },\\n            { {\"a\", \".*a*\"}, true },\\n            { {\"a\", \"..*\"}, true },\\n            { {\"aabcbcbcaccbcaabc\", \".*a*aa*.*b*.c*.*a*\"}, true },\\n            { {\"abbabaaaaaaacaa\", \"a*.*b.a.*c*b*a*c*\"}, true },\\n            { {\"bcaccbbacbcbcab\", \"b*.c*..*.b*b*.*c*\"}, true },\\n            { {\"baabbbaccbccacacc\", \"c*..b*a*a.*a..*c\"}, true },\\n            { {\"abcaaaaaaabaabcabac\", \".*ab.a.*a*a*.*b*b*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cabbbbcbcacbabc\", \".*b.*.ab*.*b*a*c\"}, true },\\n            { {\"abbcacbbbbbabcbaca\", \"a*a*.*a*.*a*.b*a*\"}, true },\\n            { {\"aababbabacaabacbbbc\", \".b*ac*.*c*a*b*.*\"}, true },\\n            { {\"aaabaaaababcbccbaab\", \"c*c*.*c*a*..*c*\"}, true },\\n            { {\"cbccaababcbabac\", \"c*aab*.*b.b.*.*a*.\"}, false },\\n            { {\"caccccaccbabbcb\", \"c*c*b*a*.*c*.a*a*a*\"}, true },\\n            { {\"bbbaccbbbaababbac\", \".b*b*.*...*.*c*.\"}, true },\\n            { {\"ccbbcabcbbaabaccc\", \"c*a*.*a*a*.*c*b*b*.\"}, true },\\n            { {\"abbaaaabaabbcba\", \"a*.*ba.*c*..a*.a*.\"}, true },\\n            { {\"bbcacbabbcbaaccabc\", \"b*a*a*.c*bb*b*.*.*\"}, true },\\n            { {\"aabccbcbacabaab\", \".*c*a*b.*a*ba*bb*\"}, true },\\n            { {\"cbbbaccbcacbcca\", \"b*.*b*a*.a*b*.a*\"}, true },\\n            { {\"cbacbbabbcaabbb\", \"b*c*.*a*..a.*c*.*\"}, true },\\n            { {\"abaabababbcbcabbcbc\", \"b*ab.*.*.*.b..*\"}, true },\\n            { {\"caaacccbaababbb\", \"c*.*b*ba*ac*c*b*.*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"cacbacccbbbccab\", \".b*b*.*c*a*.*bb*\"}, true },\\n            { {\"abcbccbcbaabbcbb\", \"c*a.*ab*.*ab*a*..b*\"}, true },\\n            { {\"caabbabbbbccccbbbcc\", \".b*c*.*.*bb*.*.*\"}, true },\\n            { {\"caaccabbbabcacaac\", \"b*c*b*b*.b*.*c*a*c\"}, true },\\n            { {\"cbcaabcbaabccbaa\", \"c*b*ab*.*b*c*a*\"}, false },\\n            { {\"bccbcccbcbbbcbb\", \"c*c*c*c*c*.*.*b*b*\"}, true },\\n            { {\"ccacbcbcccabbab\", \".c*a*aa*b*.*b*.*\"}, true },\\n            { {\"aabbcbcacbacaaccacc\", \"c*b*b*.*.*.*a*.*\"}, true },\\n            { {\"bcbabcaacacbcabac\", \"a*c*a*b*.*aa*c*a*a*\"}, true },\\n            { {\"acabbabacaccacccabc\", \"a*.*c*a*.b.*a*.*\"}, true },\\n            { {\"babbcccbacaabcbac\", \"b.*.*c*b*b*.*c*c\"}, true },            \\n            { {\"cbbbbabaabbacbbc\", \"a*c*b*.*bb*a*.*a*\"}, true },            \\n            { {\"accbabbacbbbacb\", \".*.*.*a*bba*ba*\"}, false },\\n            { {\"ababbcaaabbaccb\", \"c*c*..*a*a*a*.*\"}, true },\\n            { {\"bcabcbcaccabcbb\", \"a*a*c*a*.*a*c*bc*.\"}, true },\\n            { {\"bcbbbacbabccbabbac\", \"c*.*b*a.*a*a*a*\"}, true },\\n            { {\"ccbbbbbacacaaabcaa\", \".*ba*.*.b*c*c*b*a.*\"}, true },\\n            { {\"acaababbccbaacabcab\", \"..*bb*b*c*a*c*.*.b\"}, true },\\n            { {\"cbabcabbbacbcaca\", \"a*c*.*a*a*b*c*a*.*\"}, true },\\n            { {\"bacacaababbbcbc\", \".*a*.*a*.aa*c*b*c\"}, false },\\n            { {\"cbabcbbaabbcaca\", \".a*b*.*.*b*c*.*b*a*\"}, true },\\n            { {\"bbaaaacabccbcac\", \"b*b*a*c*c*a*c*.*\"}, true },\\n            { {\"bcccccbaccccacaa\", \".*bb*c*a*b*.*b*b*c*\"}, true },\\n            { {\"bcbaccbbbccabaac\", \"c*.*a*b*ac*a*a*\"}, true },\\n            { {\"bacacbacaaabccbcbaa\", \"a*.c*c*c*a*b*..*\"}, true },\\n            { {\"baccbbcbcacacbbc\", \"c*.*b*c*ba*b*b*.a*\"}, true },\\n\\n        };"
                    },
                    {
                        "username": "Husoski",
                        "content": "Which test are you complaining about?  I only checked the first six patterns and they are all good.  If you have doubts, try using an IDE or code-friendly editor with regex search to \"find\" the target string using the given pattern."
                    },
                    {
                        "username": "ophirrachman",
                        "content": "Wrong Answer\\n\\nDetails \\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@ophirrachman](/ophirrachman) In this case `c*` can be removed, `a*` can occur 2 times so it forms `aab`, hence it returns `true`"
                    },
                    {
                        "username": "taxpayer61543",
                        "content": "\"aab\"\\n\"c\\\\*a*b\"\\n\\nThis test case is wrong. Should output False, not True."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/\\n"
                    }
                ]
            },
            {
                "id": 2024427,
                "content": [
                    {
                        "username": "mylemoncake",
                        "content": "So the * matches the wild character . itself but not the actual char it may represents?"
                    },
                    {
                        "username": "guapter",
                        "content": "it is NOT valid regex! \n```\ns =\"abc\"\np =\"a***abc\"\n```\n\nin task conditions there is a constraint: \"It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\"\nfor case of a*** it is invalid regex expression. If imagine we should convert it to real regex - it could be too many options here - a*/*/* a/**/* a/*/*/* and so on, thats why regex dont accept this expression! \nyour tests have syntax error! Fix pls! "
                    },
                    {
                        "username": "weraponpat",
                        "content": "believe me or not I got this question in the actual interview."
                    },
                    {
                        "username": "user8272RT",
                        "content": "This was hard. Took multiple attempts to resolve the edge cases."
                    },
                    {
                        "username": "Suharkov",
                        "content": "What i\\'m doing wrong?\\n`s = \"abc\"`\\n`p = \"a***abc\"`\\nExpected true, but `a***abc` is not a valid regular expression.."
                    },
                    {
                        "username": "Andrew_Richards_CS",
                        "content": "The leetcode top-down java solution fails the last test case on this question due to time limit exceeded when executing case:\\ns=\"aaaaaaaaaaaaaaaaaaab\"\\np=\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nI\\'m considering this one completed with my original solution. If this test case gets removed, I will revisit."
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "For some reason it gets accepted on Submission, even when it fails on individual run with TLE."
                    },
                    {
                        "username": "nesenenkoav",
                        "content": "67 tescases is invalid and should be fixed\\n\\n        std::map< std::pair<std::string, std::string>, bool > invalidCases = {\\n            { {\"aab\", \"c*a*b\"}, true },\\n            { {\"mississippi\", \"mis*is*p*.\"}, false },\\n            { {\"aaa\", \"ab*ac*a\"}, true },\\n            { {\"aaa\", \"ab*a*c*a\"}, true },\\n            { {\"aaca\", \"ab*a*c*a\"}, true },\\n            { {\"a\", \"ab*\"}, true },\\n            { {\"bbbba\", \".*a*a\"}, true },\\n            { {\"ab\", \".*..\"}, true },\\n            { {\"ab\", \".*..c*\"}, true },\\n            { {\"a\", \".*.\"}, true },\\n            { {\"aasdfasdfasdfasdfas\", \"aasdf.*asdf.*asdf.*asdf.*s\"}, true },\\n            { {\"abbbcd\", \"ab*bbbcd\"}, true },\\n            { {\"bbab\", \"b*a*\"}, false },\\n            { {\"a\", \"c*.\"}, true },\\n            { {\"a\", \"c*a\"}, true },\\n            { {\"b\", \"a*.\"}, true },\\n            { {\"a\", \".*a*\"}, true },\\n            { {\"a\", \"..*\"}, true },\\n            { {\"aabcbcbcaccbcaabc\", \".*a*aa*.*b*.c*.*a*\"}, true },\\n            { {\"abbabaaaaaaacaa\", \"a*.*b.a.*c*b*a*c*\"}, true },\\n            { {\"bcaccbbacbcbcab\", \"b*.c*..*.b*b*.*c*\"}, true },\\n            { {\"baabbbaccbccacacc\", \"c*..b*a*a.*a..*c\"}, true },\\n            { {\"abcaaaaaaabaabcabac\", \".*ab.a.*a*a*.*b*b*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cabbbbcbcacbabc\", \".*b.*.ab*.*b*a*c\"}, true },\\n            { {\"abbcacbbbbbabcbaca\", \"a*a*.*a*.*a*.b*a*\"}, true },\\n            { {\"aababbabacaabacbbbc\", \".b*ac*.*c*a*b*.*\"}, true },\\n            { {\"aaabaaaababcbccbaab\", \"c*c*.*c*a*..*c*\"}, true },\\n            { {\"cbccaababcbabac\", \"c*aab*.*b.b.*.*a*.\"}, false },\\n            { {\"caccccaccbabbcb\", \"c*c*b*a*.*c*.a*a*a*\"}, true },\\n            { {\"bbbaccbbbaababbac\", \".b*b*.*...*.*c*.\"}, true },\\n            { {\"ccbbcabcbbaabaccc\", \"c*a*.*a*a*.*c*b*b*.\"}, true },\\n            { {\"abbaaaabaabbcba\", \"a*.*ba.*c*..a*.a*.\"}, true },\\n            { {\"bbcacbabbcbaaccabc\", \"b*a*a*.c*bb*b*.*.*\"}, true },\\n            { {\"aabccbcbacabaab\", \".*c*a*b.*a*ba*bb*\"}, true },\\n            { {\"cbbbaccbcacbcca\", \"b*.*b*a*.a*b*.a*\"}, true },\\n            { {\"cbacbbabbcaabbb\", \"b*c*.*a*..a.*c*.*\"}, true },\\n            { {\"abaabababbcbcabbcbc\", \"b*ab.*.*.*.b..*\"}, true },\\n            { {\"caaacccbaababbb\", \"c*.*b*ba*ac*c*b*.*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"cacbacccbbbccab\", \".b*b*.*c*a*.*bb*\"}, true },\\n            { {\"abcbccbcbaabbcbb\", \"c*a.*ab*.*ab*a*..b*\"}, true },\\n            { {\"caabbabbbbccccbbbcc\", \".b*c*.*.*bb*.*.*\"}, true },\\n            { {\"caaccabbbabcacaac\", \"b*c*b*b*.b*.*c*a*c\"}, true },\\n            { {\"cbcaabcbaabccbaa\", \"c*b*ab*.*b*c*a*\"}, false },\\n            { {\"bccbcccbcbbbcbb\", \"c*c*c*c*c*.*.*b*b*\"}, true },\\n            { {\"ccacbcbcccabbab\", \".c*a*aa*b*.*b*.*\"}, true },\\n            { {\"aabbcbcacbacaaccacc\", \"c*b*b*.*.*.*a*.*\"}, true },\\n            { {\"bcbabcaacacbcabac\", \"a*c*a*b*.*aa*c*a*a*\"}, true },\\n            { {\"acabbabacaccacccabc\", \"a*.*c*a*.b.*a*.*\"}, true },\\n            { {\"babbcccbacaabcbac\", \"b.*.*c*b*b*.*c*c\"}, true },            \\n            { {\"cbbbbabaabbacbbc\", \"a*c*b*.*bb*a*.*a*\"}, true },            \\n            { {\"accbabbacbbbacb\", \".*.*.*a*bba*ba*\"}, false },\\n            { {\"ababbcaaabbaccb\", \"c*c*..*a*a*a*.*\"}, true },\\n            { {\"bcabcbcaccabcbb\", \"a*a*c*a*.*a*c*bc*.\"}, true },\\n            { {\"bcbbbacbabccbabbac\", \"c*.*b*a.*a*a*a*\"}, true },\\n            { {\"ccbbbbbacacaaabcaa\", \".*ba*.*.b*c*c*b*a.*\"}, true },\\n            { {\"acaababbccbaacabcab\", \"..*bb*b*c*a*c*.*.b\"}, true },\\n            { {\"cbabcabbbacbcaca\", \"a*c*.*a*a*b*c*a*.*\"}, true },\\n            { {\"bacacaababbbcbc\", \".*a*.*a*.aa*c*b*c\"}, false },\\n            { {\"cbabcbbaabbcaca\", \".a*b*.*.*b*c*.*b*a*\"}, true },\\n            { {\"bbaaaacabccbcac\", \"b*b*a*c*c*a*c*.*\"}, true },\\n            { {\"bcccccbaccccacaa\", \".*bb*c*a*b*.*b*b*c*\"}, true },\\n            { {\"bcbaccbbbccabaac\", \"c*.*a*b*ac*a*a*\"}, true },\\n            { {\"bacacbacaaabccbcbaa\", \"a*.c*c*c*a*b*..*\"}, true },\\n            { {\"baccbbcbcacacbbc\", \"c*.*b*c*ba*b*b*.a*\"}, true },\\n\\n        };"
                    },
                    {
                        "username": "Husoski",
                        "content": "Which test are you complaining about?  I only checked the first six patterns and they are all good.  If you have doubts, try using an IDE or code-friendly editor with regex search to \"find\" the target string using the given pattern."
                    },
                    {
                        "username": "ophirrachman",
                        "content": "Wrong Answer\\n\\nDetails \\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@ophirrachman](/ophirrachman) In this case `c*` can be removed, `a*` can occur 2 times so it forms `aab`, hence it returns `true`"
                    },
                    {
                        "username": "taxpayer61543",
                        "content": "\"aab\"\\n\"c\\\\*a*b\"\\n\\nThis test case is wrong. Should output False, not True."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/\\n"
                    }
                ]
            },
            {
                "id": 2024383,
                "content": [
                    {
                        "username": "mylemoncake",
                        "content": "So the * matches the wild character . itself but not the actual char it may represents?"
                    },
                    {
                        "username": "guapter",
                        "content": "it is NOT valid regex! \n```\ns =\"abc\"\np =\"a***abc\"\n```\n\nin task conditions there is a constraint: \"It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\"\nfor case of a*** it is invalid regex expression. If imagine we should convert it to real regex - it could be too many options here - a*/*/* a/**/* a/*/*/* and so on, thats why regex dont accept this expression! \nyour tests have syntax error! Fix pls! "
                    },
                    {
                        "username": "weraponpat",
                        "content": "believe me or not I got this question in the actual interview."
                    },
                    {
                        "username": "user8272RT",
                        "content": "This was hard. Took multiple attempts to resolve the edge cases."
                    },
                    {
                        "username": "Suharkov",
                        "content": "What i\\'m doing wrong?\\n`s = \"abc\"`\\n`p = \"a***abc\"`\\nExpected true, but `a***abc` is not a valid regular expression.."
                    },
                    {
                        "username": "Andrew_Richards_CS",
                        "content": "The leetcode top-down java solution fails the last test case on this question due to time limit exceeded when executing case:\\ns=\"aaaaaaaaaaaaaaaaaaab\"\\np=\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nI\\'m considering this one completed with my original solution. If this test case gets removed, I will revisit."
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "For some reason it gets accepted on Submission, even when it fails on individual run with TLE."
                    },
                    {
                        "username": "nesenenkoav",
                        "content": "67 tescases is invalid and should be fixed\\n\\n        std::map< std::pair<std::string, std::string>, bool > invalidCases = {\\n            { {\"aab\", \"c*a*b\"}, true },\\n            { {\"mississippi\", \"mis*is*p*.\"}, false },\\n            { {\"aaa\", \"ab*ac*a\"}, true },\\n            { {\"aaa\", \"ab*a*c*a\"}, true },\\n            { {\"aaca\", \"ab*a*c*a\"}, true },\\n            { {\"a\", \"ab*\"}, true },\\n            { {\"bbbba\", \".*a*a\"}, true },\\n            { {\"ab\", \".*..\"}, true },\\n            { {\"ab\", \".*..c*\"}, true },\\n            { {\"a\", \".*.\"}, true },\\n            { {\"aasdfasdfasdfasdfas\", \"aasdf.*asdf.*asdf.*asdf.*s\"}, true },\\n            { {\"abbbcd\", \"ab*bbbcd\"}, true },\\n            { {\"bbab\", \"b*a*\"}, false },\\n            { {\"a\", \"c*.\"}, true },\\n            { {\"a\", \"c*a\"}, true },\\n            { {\"b\", \"a*.\"}, true },\\n            { {\"a\", \".*a*\"}, true },\\n            { {\"a\", \"..*\"}, true },\\n            { {\"aabcbcbcaccbcaabc\", \".*a*aa*.*b*.c*.*a*\"}, true },\\n            { {\"abbabaaaaaaacaa\", \"a*.*b.a.*c*b*a*c*\"}, true },\\n            { {\"bcaccbbacbcbcab\", \"b*.c*..*.b*b*.*c*\"}, true },\\n            { {\"baabbbaccbccacacc\", \"c*..b*a*a.*a..*c\"}, true },\\n            { {\"abcaaaaaaabaabcabac\", \".*ab.a.*a*a*.*b*b*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cabbbbcbcacbabc\", \".*b.*.ab*.*b*a*c\"}, true },\\n            { {\"abbcacbbbbbabcbaca\", \"a*a*.*a*.*a*.b*a*\"}, true },\\n            { {\"aababbabacaabacbbbc\", \".b*ac*.*c*a*b*.*\"}, true },\\n            { {\"aaabaaaababcbccbaab\", \"c*c*.*c*a*..*c*\"}, true },\\n            { {\"cbccaababcbabac\", \"c*aab*.*b.b.*.*a*.\"}, false },\\n            { {\"caccccaccbabbcb\", \"c*c*b*a*.*c*.a*a*a*\"}, true },\\n            { {\"bbbaccbbbaababbac\", \".b*b*.*...*.*c*.\"}, true },\\n            { {\"ccbbcabcbbaabaccc\", \"c*a*.*a*a*.*c*b*b*.\"}, true },\\n            { {\"abbaaaabaabbcba\", \"a*.*ba.*c*..a*.a*.\"}, true },\\n            { {\"bbcacbabbcbaaccabc\", \"b*a*a*.c*bb*b*.*.*\"}, true },\\n            { {\"aabccbcbacabaab\", \".*c*a*b.*a*ba*bb*\"}, true },\\n            { {\"cbbbaccbcacbcca\", \"b*.*b*a*.a*b*.a*\"}, true },\\n            { {\"cbacbbabbcaabbb\", \"b*c*.*a*..a.*c*.*\"}, true },\\n            { {\"abaabababbcbcabbcbc\", \"b*ab.*.*.*.b..*\"}, true },\\n            { {\"caaacccbaababbb\", \"c*.*b*ba*ac*c*b*.*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"cacbacccbbbccab\", \".b*b*.*c*a*.*bb*\"}, true },\\n            { {\"abcbccbcbaabbcbb\", \"c*a.*ab*.*ab*a*..b*\"}, true },\\n            { {\"caabbabbbbccccbbbcc\", \".b*c*.*.*bb*.*.*\"}, true },\\n            { {\"caaccabbbabcacaac\", \"b*c*b*b*.b*.*c*a*c\"}, true },\\n            { {\"cbcaabcbaabccbaa\", \"c*b*ab*.*b*c*a*\"}, false },\\n            { {\"bccbcccbcbbbcbb\", \"c*c*c*c*c*.*.*b*b*\"}, true },\\n            { {\"ccacbcbcccabbab\", \".c*a*aa*b*.*b*.*\"}, true },\\n            { {\"aabbcbcacbacaaccacc\", \"c*b*b*.*.*.*a*.*\"}, true },\\n            { {\"bcbabcaacacbcabac\", \"a*c*a*b*.*aa*c*a*a*\"}, true },\\n            { {\"acabbabacaccacccabc\", \"a*.*c*a*.b.*a*.*\"}, true },\\n            { {\"babbcccbacaabcbac\", \"b.*.*c*b*b*.*c*c\"}, true },            \\n            { {\"cbbbbabaabbacbbc\", \"a*c*b*.*bb*a*.*a*\"}, true },            \\n            { {\"accbabbacbbbacb\", \".*.*.*a*bba*ba*\"}, false },\\n            { {\"ababbcaaabbaccb\", \"c*c*..*a*a*a*.*\"}, true },\\n            { {\"bcabcbcaccabcbb\", \"a*a*c*a*.*a*c*bc*.\"}, true },\\n            { {\"bcbbbacbabccbabbac\", \"c*.*b*a.*a*a*a*\"}, true },\\n            { {\"ccbbbbbacacaaabcaa\", \".*ba*.*.b*c*c*b*a.*\"}, true },\\n            { {\"acaababbccbaacabcab\", \"..*bb*b*c*a*c*.*.b\"}, true },\\n            { {\"cbabcabbbacbcaca\", \"a*c*.*a*a*b*c*a*.*\"}, true },\\n            { {\"bacacaababbbcbc\", \".*a*.*a*.aa*c*b*c\"}, false },\\n            { {\"cbabcbbaabbcaca\", \".a*b*.*.*b*c*.*b*a*\"}, true },\\n            { {\"bbaaaacabccbcac\", \"b*b*a*c*c*a*c*.*\"}, true },\\n            { {\"bcccccbaccccacaa\", \".*bb*c*a*b*.*b*b*c*\"}, true },\\n            { {\"bcbaccbbbccabaac\", \"c*.*a*b*ac*a*a*\"}, true },\\n            { {\"bacacbacaaabccbcbaa\", \"a*.c*c*c*a*b*..*\"}, true },\\n            { {\"baccbbcbcacacbbc\", \"c*.*b*c*ba*b*b*.a*\"}, true },\\n\\n        };"
                    },
                    {
                        "username": "Husoski",
                        "content": "Which test are you complaining about?  I only checked the first six patterns and they are all good.  If you have doubts, try using an IDE or code-friendly editor with regex search to \"find\" the target string using the given pattern."
                    },
                    {
                        "username": "ophirrachman",
                        "content": "Wrong Answer\\n\\nDetails \\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@ophirrachman](/ophirrachman) In this case `c*` can be removed, `a*` can occur 2 times so it forms `aab`, hence it returns `true`"
                    },
                    {
                        "username": "taxpayer61543",
                        "content": "\"aab\"\\n\"c\\\\*a*b\"\\n\\nThis test case is wrong. Should output False, not True."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/\\n"
                    }
                ]
            },
            {
                "id": 2016308,
                "content": [
                    {
                        "username": "mylemoncake",
                        "content": "So the * matches the wild character . itself but not the actual char it may represents?"
                    },
                    {
                        "username": "guapter",
                        "content": "it is NOT valid regex! \n```\ns =\"abc\"\np =\"a***abc\"\n```\n\nin task conditions there is a constraint: \"It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\"\nfor case of a*** it is invalid regex expression. If imagine we should convert it to real regex - it could be too many options here - a*/*/* a/**/* a/*/*/* and so on, thats why regex dont accept this expression! \nyour tests have syntax error! Fix pls! "
                    },
                    {
                        "username": "weraponpat",
                        "content": "believe me or not I got this question in the actual interview."
                    },
                    {
                        "username": "user8272RT",
                        "content": "This was hard. Took multiple attempts to resolve the edge cases."
                    },
                    {
                        "username": "Suharkov",
                        "content": "What i\\'m doing wrong?\\n`s = \"abc\"`\\n`p = \"a***abc\"`\\nExpected true, but `a***abc` is not a valid regular expression.."
                    },
                    {
                        "username": "Andrew_Richards_CS",
                        "content": "The leetcode top-down java solution fails the last test case on this question due to time limit exceeded when executing case:\\ns=\"aaaaaaaaaaaaaaaaaaab\"\\np=\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nI\\'m considering this one completed with my original solution. If this test case gets removed, I will revisit."
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "For some reason it gets accepted on Submission, even when it fails on individual run with TLE."
                    },
                    {
                        "username": "nesenenkoav",
                        "content": "67 tescases is invalid and should be fixed\\n\\n        std::map< std::pair<std::string, std::string>, bool > invalidCases = {\\n            { {\"aab\", \"c*a*b\"}, true },\\n            { {\"mississippi\", \"mis*is*p*.\"}, false },\\n            { {\"aaa\", \"ab*ac*a\"}, true },\\n            { {\"aaa\", \"ab*a*c*a\"}, true },\\n            { {\"aaca\", \"ab*a*c*a\"}, true },\\n            { {\"a\", \"ab*\"}, true },\\n            { {\"bbbba\", \".*a*a\"}, true },\\n            { {\"ab\", \".*..\"}, true },\\n            { {\"ab\", \".*..c*\"}, true },\\n            { {\"a\", \".*.\"}, true },\\n            { {\"aasdfasdfasdfasdfas\", \"aasdf.*asdf.*asdf.*asdf.*s\"}, true },\\n            { {\"abbbcd\", \"ab*bbbcd\"}, true },\\n            { {\"bbab\", \"b*a*\"}, false },\\n            { {\"a\", \"c*.\"}, true },\\n            { {\"a\", \"c*a\"}, true },\\n            { {\"b\", \"a*.\"}, true },\\n            { {\"a\", \".*a*\"}, true },\\n            { {\"a\", \"..*\"}, true },\\n            { {\"aabcbcbcaccbcaabc\", \".*a*aa*.*b*.c*.*a*\"}, true },\\n            { {\"abbabaaaaaaacaa\", \"a*.*b.a.*c*b*a*c*\"}, true },\\n            { {\"bcaccbbacbcbcab\", \"b*.c*..*.b*b*.*c*\"}, true },\\n            { {\"baabbbaccbccacacc\", \"c*..b*a*a.*a..*c\"}, true },\\n            { {\"abcaaaaaaabaabcabac\", \".*ab.a.*a*a*.*b*b*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cabbbbcbcacbabc\", \".*b.*.ab*.*b*a*c\"}, true },\\n            { {\"abbcacbbbbbabcbaca\", \"a*a*.*a*.*a*.b*a*\"}, true },\\n            { {\"aababbabacaabacbbbc\", \".b*ac*.*c*a*b*.*\"}, true },\\n            { {\"aaabaaaababcbccbaab\", \"c*c*.*c*a*..*c*\"}, true },\\n            { {\"cbccaababcbabac\", \"c*aab*.*b.b.*.*a*.\"}, false },\\n            { {\"caccccaccbabbcb\", \"c*c*b*a*.*c*.a*a*a*\"}, true },\\n            { {\"bbbaccbbbaababbac\", \".b*b*.*...*.*c*.\"}, true },\\n            { {\"ccbbcabcbbaabaccc\", \"c*a*.*a*a*.*c*b*b*.\"}, true },\\n            { {\"abbaaaabaabbcba\", \"a*.*ba.*c*..a*.a*.\"}, true },\\n            { {\"bbcacbabbcbaaccabc\", \"b*a*a*.c*bb*b*.*.*\"}, true },\\n            { {\"aabccbcbacabaab\", \".*c*a*b.*a*ba*bb*\"}, true },\\n            { {\"cbbbaccbcacbcca\", \"b*.*b*a*.a*b*.a*\"}, true },\\n            { {\"cbacbbabbcaabbb\", \"b*c*.*a*..a.*c*.*\"}, true },\\n            { {\"abaabababbcbcabbcbc\", \"b*ab.*.*.*.b..*\"}, true },\\n            { {\"caaacccbaababbb\", \"c*.*b*ba*ac*c*b*.*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"cacbacccbbbccab\", \".b*b*.*c*a*.*bb*\"}, true },\\n            { {\"abcbccbcbaabbcbb\", \"c*a.*ab*.*ab*a*..b*\"}, true },\\n            { {\"caabbabbbbccccbbbcc\", \".b*c*.*.*bb*.*.*\"}, true },\\n            { {\"caaccabbbabcacaac\", \"b*c*b*b*.b*.*c*a*c\"}, true },\\n            { {\"cbcaabcbaabccbaa\", \"c*b*ab*.*b*c*a*\"}, false },\\n            { {\"bccbcccbcbbbcbb\", \"c*c*c*c*c*.*.*b*b*\"}, true },\\n            { {\"ccacbcbcccabbab\", \".c*a*aa*b*.*b*.*\"}, true },\\n            { {\"aabbcbcacbacaaccacc\", \"c*b*b*.*.*.*a*.*\"}, true },\\n            { {\"bcbabcaacacbcabac\", \"a*c*a*b*.*aa*c*a*a*\"}, true },\\n            { {\"acabbabacaccacccabc\", \"a*.*c*a*.b.*a*.*\"}, true },\\n            { {\"babbcccbacaabcbac\", \"b.*.*c*b*b*.*c*c\"}, true },            \\n            { {\"cbbbbabaabbacbbc\", \"a*c*b*.*bb*a*.*a*\"}, true },            \\n            { {\"accbabbacbbbacb\", \".*.*.*a*bba*ba*\"}, false },\\n            { {\"ababbcaaabbaccb\", \"c*c*..*a*a*a*.*\"}, true },\\n            { {\"bcabcbcaccabcbb\", \"a*a*c*a*.*a*c*bc*.\"}, true },\\n            { {\"bcbbbacbabccbabbac\", \"c*.*b*a.*a*a*a*\"}, true },\\n            { {\"ccbbbbbacacaaabcaa\", \".*ba*.*.b*c*c*b*a.*\"}, true },\\n            { {\"acaababbccbaacabcab\", \"..*bb*b*c*a*c*.*.b\"}, true },\\n            { {\"cbabcabbbacbcaca\", \"a*c*.*a*a*b*c*a*.*\"}, true },\\n            { {\"bacacaababbbcbc\", \".*a*.*a*.aa*c*b*c\"}, false },\\n            { {\"cbabcbbaabbcaca\", \".a*b*.*.*b*c*.*b*a*\"}, true },\\n            { {\"bbaaaacabccbcac\", \"b*b*a*c*c*a*c*.*\"}, true },\\n            { {\"bcccccbaccccacaa\", \".*bb*c*a*b*.*b*b*c*\"}, true },\\n            { {\"bcbaccbbbccabaac\", \"c*.*a*b*ac*a*a*\"}, true },\\n            { {\"bacacbacaaabccbcbaa\", \"a*.c*c*c*a*b*..*\"}, true },\\n            { {\"baccbbcbcacacbbc\", \"c*.*b*c*ba*b*b*.a*\"}, true },\\n\\n        };"
                    },
                    {
                        "username": "Husoski",
                        "content": "Which test are you complaining about?  I only checked the first six patterns and they are all good.  If you have doubts, try using an IDE or code-friendly editor with regex search to \"find\" the target string using the given pattern."
                    },
                    {
                        "username": "ophirrachman",
                        "content": "Wrong Answer\\n\\nDetails \\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@ophirrachman](/ophirrachman) In this case `c*` can be removed, `a*` can occur 2 times so it forms `aab`, hence it returns `true`"
                    },
                    {
                        "username": "taxpayer61543",
                        "content": "\"aab\"\\n\"c\\\\*a*b\"\\n\\nThis test case is wrong. Should output False, not True."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/\\n"
                    }
                ]
            },
            {
                "id": 1762088,
                "content": [
                    {
                        "username": "mylemoncake",
                        "content": "So the * matches the wild character . itself but not the actual char it may represents?"
                    },
                    {
                        "username": "guapter",
                        "content": "it is NOT valid regex! \n```\ns =\"abc\"\np =\"a***abc\"\n```\n\nin task conditions there is a constraint: \"It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\"\nfor case of a*** it is invalid regex expression. If imagine we should convert it to real regex - it could be too many options here - a*/*/* a/**/* a/*/*/* and so on, thats why regex dont accept this expression! \nyour tests have syntax error! Fix pls! "
                    },
                    {
                        "username": "weraponpat",
                        "content": "believe me or not I got this question in the actual interview."
                    },
                    {
                        "username": "user8272RT",
                        "content": "This was hard. Took multiple attempts to resolve the edge cases."
                    },
                    {
                        "username": "Suharkov",
                        "content": "What i\\'m doing wrong?\\n`s = \"abc\"`\\n`p = \"a***abc\"`\\nExpected true, but `a***abc` is not a valid regular expression.."
                    },
                    {
                        "username": "Andrew_Richards_CS",
                        "content": "The leetcode top-down java solution fails the last test case on this question due to time limit exceeded when executing case:\\ns=\"aaaaaaaaaaaaaaaaaaab\"\\np=\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nI\\'m considering this one completed with my original solution. If this test case gets removed, I will revisit."
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "For some reason it gets accepted on Submission, even when it fails on individual run with TLE."
                    },
                    {
                        "username": "nesenenkoav",
                        "content": "67 tescases is invalid and should be fixed\\n\\n        std::map< std::pair<std::string, std::string>, bool > invalidCases = {\\n            { {\"aab\", \"c*a*b\"}, true },\\n            { {\"mississippi\", \"mis*is*p*.\"}, false },\\n            { {\"aaa\", \"ab*ac*a\"}, true },\\n            { {\"aaa\", \"ab*a*c*a\"}, true },\\n            { {\"aaca\", \"ab*a*c*a\"}, true },\\n            { {\"a\", \"ab*\"}, true },\\n            { {\"bbbba\", \".*a*a\"}, true },\\n            { {\"ab\", \".*..\"}, true },\\n            { {\"ab\", \".*..c*\"}, true },\\n            { {\"a\", \".*.\"}, true },\\n            { {\"aasdfasdfasdfasdfas\", \"aasdf.*asdf.*asdf.*asdf.*s\"}, true },\\n            { {\"abbbcd\", \"ab*bbbcd\"}, true },\\n            { {\"bbab\", \"b*a*\"}, false },\\n            { {\"a\", \"c*.\"}, true },\\n            { {\"a\", \"c*a\"}, true },\\n            { {\"b\", \"a*.\"}, true },\\n            { {\"a\", \".*a*\"}, true },\\n            { {\"a\", \"..*\"}, true },\\n            { {\"aabcbcbcaccbcaabc\", \".*a*aa*.*b*.c*.*a*\"}, true },\\n            { {\"abbabaaaaaaacaa\", \"a*.*b.a.*c*b*a*c*\"}, true },\\n            { {\"bcaccbbacbcbcab\", \"b*.c*..*.b*b*.*c*\"}, true },\\n            { {\"baabbbaccbccacacc\", \"c*..b*a*a.*a..*c\"}, true },\\n            { {\"abcaaaaaaabaabcabac\", \".*ab.a.*a*a*.*b*b*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cabbbbcbcacbabc\", \".*b.*.ab*.*b*a*c\"}, true },\\n            { {\"abbcacbbbbbabcbaca\", \"a*a*.*a*.*a*.b*a*\"}, true },\\n            { {\"aababbabacaabacbbbc\", \".b*ac*.*c*a*b*.*\"}, true },\\n            { {\"aaabaaaababcbccbaab\", \"c*c*.*c*a*..*c*\"}, true },\\n            { {\"cbccaababcbabac\", \"c*aab*.*b.b.*.*a*.\"}, false },\\n            { {\"caccccaccbabbcb\", \"c*c*b*a*.*c*.a*a*a*\"}, true },\\n            { {\"bbbaccbbbaababbac\", \".b*b*.*...*.*c*.\"}, true },\\n            { {\"ccbbcabcbbaabaccc\", \"c*a*.*a*a*.*c*b*b*.\"}, true },\\n            { {\"abbaaaabaabbcba\", \"a*.*ba.*c*..a*.a*.\"}, true },\\n            { {\"bbcacbabbcbaaccabc\", \"b*a*a*.c*bb*b*.*.*\"}, true },\\n            { {\"aabccbcbacabaab\", \".*c*a*b.*a*ba*bb*\"}, true },\\n            { {\"cbbbaccbcacbcca\", \"b*.*b*a*.a*b*.a*\"}, true },\\n            { {\"cbacbbabbcaabbb\", \"b*c*.*a*..a.*c*.*\"}, true },\\n            { {\"abaabababbcbcabbcbc\", \"b*ab.*.*.*.b..*\"}, true },\\n            { {\"caaacccbaababbb\", \"c*.*b*ba*ac*c*b*.*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"cacbacccbbbccab\", \".b*b*.*c*a*.*bb*\"}, true },\\n            { {\"abcbccbcbaabbcbb\", \"c*a.*ab*.*ab*a*..b*\"}, true },\\n            { {\"caabbabbbbccccbbbcc\", \".b*c*.*.*bb*.*.*\"}, true },\\n            { {\"caaccabbbabcacaac\", \"b*c*b*b*.b*.*c*a*c\"}, true },\\n            { {\"cbcaabcbaabccbaa\", \"c*b*ab*.*b*c*a*\"}, false },\\n            { {\"bccbcccbcbbbcbb\", \"c*c*c*c*c*.*.*b*b*\"}, true },\\n            { {\"ccacbcbcccabbab\", \".c*a*aa*b*.*b*.*\"}, true },\\n            { {\"aabbcbcacbacaaccacc\", \"c*b*b*.*.*.*a*.*\"}, true },\\n            { {\"bcbabcaacacbcabac\", \"a*c*a*b*.*aa*c*a*a*\"}, true },\\n            { {\"acabbabacaccacccabc\", \"a*.*c*a*.b.*a*.*\"}, true },\\n            { {\"babbcccbacaabcbac\", \"b.*.*c*b*b*.*c*c\"}, true },            \\n            { {\"cbbbbabaabbacbbc\", \"a*c*b*.*bb*a*.*a*\"}, true },            \\n            { {\"accbabbacbbbacb\", \".*.*.*a*bba*ba*\"}, false },\\n            { {\"ababbcaaabbaccb\", \"c*c*..*a*a*a*.*\"}, true },\\n            { {\"bcabcbcaccabcbb\", \"a*a*c*a*.*a*c*bc*.\"}, true },\\n            { {\"bcbbbacbabccbabbac\", \"c*.*b*a.*a*a*a*\"}, true },\\n            { {\"ccbbbbbacacaaabcaa\", \".*ba*.*.b*c*c*b*a.*\"}, true },\\n            { {\"acaababbccbaacabcab\", \"..*bb*b*c*a*c*.*.b\"}, true },\\n            { {\"cbabcabbbacbcaca\", \"a*c*.*a*a*b*c*a*.*\"}, true },\\n            { {\"bacacaababbbcbc\", \".*a*.*a*.aa*c*b*c\"}, false },\\n            { {\"cbabcbbaabbcaca\", \".a*b*.*.*b*c*.*b*a*\"}, true },\\n            { {\"bbaaaacabccbcac\", \"b*b*a*c*c*a*c*.*\"}, true },\\n            { {\"bcccccbaccccacaa\", \".*bb*c*a*b*.*b*b*c*\"}, true },\\n            { {\"bcbaccbbbccabaac\", \"c*.*a*b*ac*a*a*\"}, true },\\n            { {\"bacacbacaaabccbcbaa\", \"a*.c*c*c*a*b*..*\"}, true },\\n            { {\"baccbbcbcacacbbc\", \"c*.*b*c*ba*b*b*.a*\"}, true },\\n\\n        };"
                    },
                    {
                        "username": "Husoski",
                        "content": "Which test are you complaining about?  I only checked the first six patterns and they are all good.  If you have doubts, try using an IDE or code-friendly editor with regex search to \"find\" the target string using the given pattern."
                    },
                    {
                        "username": "ophirrachman",
                        "content": "Wrong Answer\\n\\nDetails \\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@ophirrachman](/ophirrachman) In this case `c*` can be removed, `a*` can occur 2 times so it forms `aab`, hence it returns `true`"
                    },
                    {
                        "username": "taxpayer61543",
                        "content": "\"aab\"\\n\"c\\\\*a*b\"\\n\\nThis test case is wrong. Should output False, not True."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/\\n"
                    }
                ]
            },
            {
                "id": 1711280,
                "content": [
                    {
                        "username": "mylemoncake",
                        "content": "So the * matches the wild character . itself but not the actual char it may represents?"
                    },
                    {
                        "username": "guapter",
                        "content": "it is NOT valid regex! \n```\ns =\"abc\"\np =\"a***abc\"\n```\n\nin task conditions there is a constraint: \"It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\"\nfor case of a*** it is invalid regex expression. If imagine we should convert it to real regex - it could be too many options here - a*/*/* a/**/* a/*/*/* and so on, thats why regex dont accept this expression! \nyour tests have syntax error! Fix pls! "
                    },
                    {
                        "username": "weraponpat",
                        "content": "believe me or not I got this question in the actual interview."
                    },
                    {
                        "username": "user8272RT",
                        "content": "This was hard. Took multiple attempts to resolve the edge cases."
                    },
                    {
                        "username": "Suharkov",
                        "content": "What i\\'m doing wrong?\\n`s = \"abc\"`\\n`p = \"a***abc\"`\\nExpected true, but `a***abc` is not a valid regular expression.."
                    },
                    {
                        "username": "Andrew_Richards_CS",
                        "content": "The leetcode top-down java solution fails the last test case on this question due to time limit exceeded when executing case:\\ns=\"aaaaaaaaaaaaaaaaaaab\"\\np=\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nI\\'m considering this one completed with my original solution. If this test case gets removed, I will revisit."
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "For some reason it gets accepted on Submission, even when it fails on individual run with TLE."
                    },
                    {
                        "username": "nesenenkoav",
                        "content": "67 tescases is invalid and should be fixed\\n\\n        std::map< std::pair<std::string, std::string>, bool > invalidCases = {\\n            { {\"aab\", \"c*a*b\"}, true },\\n            { {\"mississippi\", \"mis*is*p*.\"}, false },\\n            { {\"aaa\", \"ab*ac*a\"}, true },\\n            { {\"aaa\", \"ab*a*c*a\"}, true },\\n            { {\"aaca\", \"ab*a*c*a\"}, true },\\n            { {\"a\", \"ab*\"}, true },\\n            { {\"bbbba\", \".*a*a\"}, true },\\n            { {\"ab\", \".*..\"}, true },\\n            { {\"ab\", \".*..c*\"}, true },\\n            { {\"a\", \".*.\"}, true },\\n            { {\"aasdfasdfasdfasdfas\", \"aasdf.*asdf.*asdf.*asdf.*s\"}, true },\\n            { {\"abbbcd\", \"ab*bbbcd\"}, true },\\n            { {\"bbab\", \"b*a*\"}, false },\\n            { {\"a\", \"c*.\"}, true },\\n            { {\"a\", \"c*a\"}, true },\\n            { {\"b\", \"a*.\"}, true },\\n            { {\"a\", \".*a*\"}, true },\\n            { {\"a\", \"..*\"}, true },\\n            { {\"aabcbcbcaccbcaabc\", \".*a*aa*.*b*.c*.*a*\"}, true },\\n            { {\"abbabaaaaaaacaa\", \"a*.*b.a.*c*b*a*c*\"}, true },\\n            { {\"bcaccbbacbcbcab\", \"b*.c*..*.b*b*.*c*\"}, true },\\n            { {\"baabbbaccbccacacc\", \"c*..b*a*a.*a..*c\"}, true },\\n            { {\"abcaaaaaaabaabcabac\", \".*ab.a.*a*a*.*b*b*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cabbbbcbcacbabc\", \".*b.*.ab*.*b*a*c\"}, true },\\n            { {\"abbcacbbbbbabcbaca\", \"a*a*.*a*.*a*.b*a*\"}, true },\\n            { {\"aababbabacaabacbbbc\", \".b*ac*.*c*a*b*.*\"}, true },\\n            { {\"aaabaaaababcbccbaab\", \"c*c*.*c*a*..*c*\"}, true },\\n            { {\"cbccaababcbabac\", \"c*aab*.*b.b.*.*a*.\"}, false },\\n            { {\"caccccaccbabbcb\", \"c*c*b*a*.*c*.a*a*a*\"}, true },\\n            { {\"bbbaccbbbaababbac\", \".b*b*.*...*.*c*.\"}, true },\\n            { {\"ccbbcabcbbaabaccc\", \"c*a*.*a*a*.*c*b*b*.\"}, true },\\n            { {\"abbaaaabaabbcba\", \"a*.*ba.*c*..a*.a*.\"}, true },\\n            { {\"bbcacbabbcbaaccabc\", \"b*a*a*.c*bb*b*.*.*\"}, true },\\n            { {\"aabccbcbacabaab\", \".*c*a*b.*a*ba*bb*\"}, true },\\n            { {\"cbbbaccbcacbcca\", \"b*.*b*a*.a*b*.a*\"}, true },\\n            { {\"cbacbbabbcaabbb\", \"b*c*.*a*..a.*c*.*\"}, true },\\n            { {\"abaabababbcbcabbcbc\", \"b*ab.*.*.*.b..*\"}, true },\\n            { {\"caaacccbaababbb\", \"c*.*b*ba*ac*c*b*.*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"cacbacccbbbccab\", \".b*b*.*c*a*.*bb*\"}, true },\\n            { {\"abcbccbcbaabbcbb\", \"c*a.*ab*.*ab*a*..b*\"}, true },\\n            { {\"caabbabbbbccccbbbcc\", \".b*c*.*.*bb*.*.*\"}, true },\\n            { {\"caaccabbbabcacaac\", \"b*c*b*b*.b*.*c*a*c\"}, true },\\n            { {\"cbcaabcbaabccbaa\", \"c*b*ab*.*b*c*a*\"}, false },\\n            { {\"bccbcccbcbbbcbb\", \"c*c*c*c*c*.*.*b*b*\"}, true },\\n            { {\"ccacbcbcccabbab\", \".c*a*aa*b*.*b*.*\"}, true },\\n            { {\"aabbcbcacbacaaccacc\", \"c*b*b*.*.*.*a*.*\"}, true },\\n            { {\"bcbabcaacacbcabac\", \"a*c*a*b*.*aa*c*a*a*\"}, true },\\n            { {\"acabbabacaccacccabc\", \"a*.*c*a*.b.*a*.*\"}, true },\\n            { {\"babbcccbacaabcbac\", \"b.*.*c*b*b*.*c*c\"}, true },            \\n            { {\"cbbbbabaabbacbbc\", \"a*c*b*.*bb*a*.*a*\"}, true },            \\n            { {\"accbabbacbbbacb\", \".*.*.*a*bba*ba*\"}, false },\\n            { {\"ababbcaaabbaccb\", \"c*c*..*a*a*a*.*\"}, true },\\n            { {\"bcabcbcaccabcbb\", \"a*a*c*a*.*a*c*bc*.\"}, true },\\n            { {\"bcbbbacbabccbabbac\", \"c*.*b*a.*a*a*a*\"}, true },\\n            { {\"ccbbbbbacacaaabcaa\", \".*ba*.*.b*c*c*b*a.*\"}, true },\\n            { {\"acaababbccbaacabcab\", \"..*bb*b*c*a*c*.*.b\"}, true },\\n            { {\"cbabcabbbacbcaca\", \"a*c*.*a*a*b*c*a*.*\"}, true },\\n            { {\"bacacaababbbcbc\", \".*a*.*a*.aa*c*b*c\"}, false },\\n            { {\"cbabcbbaabbcaca\", \".a*b*.*.*b*c*.*b*a*\"}, true },\\n            { {\"bbaaaacabccbcac\", \"b*b*a*c*c*a*c*.*\"}, true },\\n            { {\"bcccccbaccccacaa\", \".*bb*c*a*b*.*b*b*c*\"}, true },\\n            { {\"bcbaccbbbccabaac\", \"c*.*a*b*ac*a*a*\"}, true },\\n            { {\"bacacbacaaabccbcbaa\", \"a*.c*c*c*a*b*..*\"}, true },\\n            { {\"baccbbcbcacacbbc\", \"c*.*b*c*ba*b*b*.a*\"}, true },\\n\\n        };"
                    },
                    {
                        "username": "Husoski",
                        "content": "Which test are you complaining about?  I only checked the first six patterns and they are all good.  If you have doubts, try using an IDE or code-friendly editor with regex search to \"find\" the target string using the given pattern."
                    },
                    {
                        "username": "ophirrachman",
                        "content": "Wrong Answer\\n\\nDetails \\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@ophirrachman](/ophirrachman) In this case `c*` can be removed, `a*` can occur 2 times so it forms `aab`, hence it returns `true`"
                    },
                    {
                        "username": "taxpayer61543",
                        "content": "\"aab\"\\n\"c\\\\*a*b\"\\n\\nThis test case is wrong. Should output False, not True."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/\\n"
                    }
                ]
            },
            {
                "id": 1576979,
                "content": [
                    {
                        "username": "mylemoncake",
                        "content": "So the * matches the wild character . itself but not the actual char it may represents?"
                    },
                    {
                        "username": "guapter",
                        "content": "it is NOT valid regex! \n```\ns =\"abc\"\np =\"a***abc\"\n```\n\nin task conditions there is a constraint: \"It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\"\nfor case of a*** it is invalid regex expression. If imagine we should convert it to real regex - it could be too many options here - a*/*/* a/**/* a/*/*/* and so on, thats why regex dont accept this expression! \nyour tests have syntax error! Fix pls! "
                    },
                    {
                        "username": "weraponpat",
                        "content": "believe me or not I got this question in the actual interview."
                    },
                    {
                        "username": "user8272RT",
                        "content": "This was hard. Took multiple attempts to resolve the edge cases."
                    },
                    {
                        "username": "Suharkov",
                        "content": "What i\\'m doing wrong?\\n`s = \"abc\"`\\n`p = \"a***abc\"`\\nExpected true, but `a***abc` is not a valid regular expression.."
                    },
                    {
                        "username": "Andrew_Richards_CS",
                        "content": "The leetcode top-down java solution fails the last test case on this question due to time limit exceeded when executing case:\\ns=\"aaaaaaaaaaaaaaaaaaab\"\\np=\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nI\\'m considering this one completed with my original solution. If this test case gets removed, I will revisit."
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "For some reason it gets accepted on Submission, even when it fails on individual run with TLE."
                    },
                    {
                        "username": "nesenenkoav",
                        "content": "67 tescases is invalid and should be fixed\\n\\n        std::map< std::pair<std::string, std::string>, bool > invalidCases = {\\n            { {\"aab\", \"c*a*b\"}, true },\\n            { {\"mississippi\", \"mis*is*p*.\"}, false },\\n            { {\"aaa\", \"ab*ac*a\"}, true },\\n            { {\"aaa\", \"ab*a*c*a\"}, true },\\n            { {\"aaca\", \"ab*a*c*a\"}, true },\\n            { {\"a\", \"ab*\"}, true },\\n            { {\"bbbba\", \".*a*a\"}, true },\\n            { {\"ab\", \".*..\"}, true },\\n            { {\"ab\", \".*..c*\"}, true },\\n            { {\"a\", \".*.\"}, true },\\n            { {\"aasdfasdfasdfasdfas\", \"aasdf.*asdf.*asdf.*asdf.*s\"}, true },\\n            { {\"abbbcd\", \"ab*bbbcd\"}, true },\\n            { {\"bbab\", \"b*a*\"}, false },\\n            { {\"a\", \"c*.\"}, true },\\n            { {\"a\", \"c*a\"}, true },\\n            { {\"b\", \"a*.\"}, true },\\n            { {\"a\", \".*a*\"}, true },\\n            { {\"a\", \"..*\"}, true },\\n            { {\"aabcbcbcaccbcaabc\", \".*a*aa*.*b*.c*.*a*\"}, true },\\n            { {\"abbabaaaaaaacaa\", \"a*.*b.a.*c*b*a*c*\"}, true },\\n            { {\"bcaccbbacbcbcab\", \"b*.c*..*.b*b*.*c*\"}, true },\\n            { {\"baabbbaccbccacacc\", \"c*..b*a*a.*a..*c\"}, true },\\n            { {\"abcaaaaaaabaabcabac\", \".*ab.a.*a*a*.*b*b*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cabbbbcbcacbabc\", \".*b.*.ab*.*b*a*c\"}, true },\\n            { {\"abbcacbbbbbabcbaca\", \"a*a*.*a*.*a*.b*a*\"}, true },\\n            { {\"aababbabacaabacbbbc\", \".b*ac*.*c*a*b*.*\"}, true },\\n            { {\"aaabaaaababcbccbaab\", \"c*c*.*c*a*..*c*\"}, true },\\n            { {\"cbccaababcbabac\", \"c*aab*.*b.b.*.*a*.\"}, false },\\n            { {\"caccccaccbabbcb\", \"c*c*b*a*.*c*.a*a*a*\"}, true },\\n            { {\"bbbaccbbbaababbac\", \".b*b*.*...*.*c*.\"}, true },\\n            { {\"ccbbcabcbbaabaccc\", \"c*a*.*a*a*.*c*b*b*.\"}, true },\\n            { {\"abbaaaabaabbcba\", \"a*.*ba.*c*..a*.a*.\"}, true },\\n            { {\"bbcacbabbcbaaccabc\", \"b*a*a*.c*bb*b*.*.*\"}, true },\\n            { {\"aabccbcbacabaab\", \".*c*a*b.*a*ba*bb*\"}, true },\\n            { {\"cbbbaccbcacbcca\", \"b*.*b*a*.a*b*.a*\"}, true },\\n            { {\"cbacbbabbcaabbb\", \"b*c*.*a*..a.*c*.*\"}, true },\\n            { {\"abaabababbcbcabbcbc\", \"b*ab.*.*.*.b..*\"}, true },\\n            { {\"caaacccbaababbb\", \"c*.*b*ba*ac*c*b*.*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"cacbacccbbbccab\", \".b*b*.*c*a*.*bb*\"}, true },\\n            { {\"abcbccbcbaabbcbb\", \"c*a.*ab*.*ab*a*..b*\"}, true },\\n            { {\"caabbabbbbccccbbbcc\", \".b*c*.*.*bb*.*.*\"}, true },\\n            { {\"caaccabbbabcacaac\", \"b*c*b*b*.b*.*c*a*c\"}, true },\\n            { {\"cbcaabcbaabccbaa\", \"c*b*ab*.*b*c*a*\"}, false },\\n            { {\"bccbcccbcbbbcbb\", \"c*c*c*c*c*.*.*b*b*\"}, true },\\n            { {\"ccacbcbcccabbab\", \".c*a*aa*b*.*b*.*\"}, true },\\n            { {\"aabbcbcacbacaaccacc\", \"c*b*b*.*.*.*a*.*\"}, true },\\n            { {\"bcbabcaacacbcabac\", \"a*c*a*b*.*aa*c*a*a*\"}, true },\\n            { {\"acabbabacaccacccabc\", \"a*.*c*a*.b.*a*.*\"}, true },\\n            { {\"babbcccbacaabcbac\", \"b.*.*c*b*b*.*c*c\"}, true },            \\n            { {\"cbbbbabaabbacbbc\", \"a*c*b*.*bb*a*.*a*\"}, true },            \\n            { {\"accbabbacbbbacb\", \".*.*.*a*bba*ba*\"}, false },\\n            { {\"ababbcaaabbaccb\", \"c*c*..*a*a*a*.*\"}, true },\\n            { {\"bcabcbcaccabcbb\", \"a*a*c*a*.*a*c*bc*.\"}, true },\\n            { {\"bcbbbacbabccbabbac\", \"c*.*b*a.*a*a*a*\"}, true },\\n            { {\"ccbbbbbacacaaabcaa\", \".*ba*.*.b*c*c*b*a.*\"}, true },\\n            { {\"acaababbccbaacabcab\", \"..*bb*b*c*a*c*.*.b\"}, true },\\n            { {\"cbabcabbbacbcaca\", \"a*c*.*a*a*b*c*a*.*\"}, true },\\n            { {\"bacacaababbbcbc\", \".*a*.*a*.aa*c*b*c\"}, false },\\n            { {\"cbabcbbaabbcaca\", \".a*b*.*.*b*c*.*b*a*\"}, true },\\n            { {\"bbaaaacabccbcac\", \"b*b*a*c*c*a*c*.*\"}, true },\\n            { {\"bcccccbaccccacaa\", \".*bb*c*a*b*.*b*b*c*\"}, true },\\n            { {\"bcbaccbbbccabaac\", \"c*.*a*b*ac*a*a*\"}, true },\\n            { {\"bacacbacaaabccbcbaa\", \"a*.c*c*c*a*b*..*\"}, true },\\n            { {\"baccbbcbcacacbbc\", \"c*.*b*c*ba*b*b*.a*\"}, true },\\n\\n        };"
                    },
                    {
                        "username": "Husoski",
                        "content": "Which test are you complaining about?  I only checked the first six patterns and they are all good.  If you have doubts, try using an IDE or code-friendly editor with regex search to \"find\" the target string using the given pattern."
                    },
                    {
                        "username": "ophirrachman",
                        "content": "Wrong Answer\\n\\nDetails \\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@ophirrachman](/ophirrachman) In this case `c*` can be removed, `a*` can occur 2 times so it forms `aab`, hence it returns `true`"
                    },
                    {
                        "username": "taxpayer61543",
                        "content": "\"aab\"\\n\"c\\\\*a*b\"\\n\\nThis test case is wrong. Should output False, not True."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/\\n"
                    }
                ]
            },
            {
                "id": 1576922,
                "content": [
                    {
                        "username": "mylemoncake",
                        "content": "So the * matches the wild character . itself but not the actual char it may represents?"
                    },
                    {
                        "username": "guapter",
                        "content": "it is NOT valid regex! \n```\ns =\"abc\"\np =\"a***abc\"\n```\n\nin task conditions there is a constraint: \"It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\"\nfor case of a*** it is invalid regex expression. If imagine we should convert it to real regex - it could be too many options here - a*/*/* a/**/* a/*/*/* and so on, thats why regex dont accept this expression! \nyour tests have syntax error! Fix pls! "
                    },
                    {
                        "username": "weraponpat",
                        "content": "believe me or not I got this question in the actual interview."
                    },
                    {
                        "username": "user8272RT",
                        "content": "This was hard. Took multiple attempts to resolve the edge cases."
                    },
                    {
                        "username": "Suharkov",
                        "content": "What i\\'m doing wrong?\\n`s = \"abc\"`\\n`p = \"a***abc\"`\\nExpected true, but `a***abc` is not a valid regular expression.."
                    },
                    {
                        "username": "Andrew_Richards_CS",
                        "content": "The leetcode top-down java solution fails the last test case on this question due to time limit exceeded when executing case:\\ns=\"aaaaaaaaaaaaaaaaaaab\"\\np=\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nI\\'m considering this one completed with my original solution. If this test case gets removed, I will revisit."
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "For some reason it gets accepted on Submission, even when it fails on individual run with TLE."
                    },
                    {
                        "username": "nesenenkoav",
                        "content": "67 tescases is invalid and should be fixed\\n\\n        std::map< std::pair<std::string, std::string>, bool > invalidCases = {\\n            { {\"aab\", \"c*a*b\"}, true },\\n            { {\"mississippi\", \"mis*is*p*.\"}, false },\\n            { {\"aaa\", \"ab*ac*a\"}, true },\\n            { {\"aaa\", \"ab*a*c*a\"}, true },\\n            { {\"aaca\", \"ab*a*c*a\"}, true },\\n            { {\"a\", \"ab*\"}, true },\\n            { {\"bbbba\", \".*a*a\"}, true },\\n            { {\"ab\", \".*..\"}, true },\\n            { {\"ab\", \".*..c*\"}, true },\\n            { {\"a\", \".*.\"}, true },\\n            { {\"aasdfasdfasdfasdfas\", \"aasdf.*asdf.*asdf.*asdf.*s\"}, true },\\n            { {\"abbbcd\", \"ab*bbbcd\"}, true },\\n            { {\"bbab\", \"b*a*\"}, false },\\n            { {\"a\", \"c*.\"}, true },\\n            { {\"a\", \"c*a\"}, true },\\n            { {\"b\", \"a*.\"}, true },\\n            { {\"a\", \".*a*\"}, true },\\n            { {\"a\", \"..*\"}, true },\\n            { {\"aabcbcbcaccbcaabc\", \".*a*aa*.*b*.c*.*a*\"}, true },\\n            { {\"abbabaaaaaaacaa\", \"a*.*b.a.*c*b*a*c*\"}, true },\\n            { {\"bcaccbbacbcbcab\", \"b*.c*..*.b*b*.*c*\"}, true },\\n            { {\"baabbbaccbccacacc\", \"c*..b*a*a.*a..*c\"}, true },\\n            { {\"abcaaaaaaabaabcabac\", \".*ab.a.*a*a*.*b*b*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cabbbbcbcacbabc\", \".*b.*.ab*.*b*a*c\"}, true },\\n            { {\"abbcacbbbbbabcbaca\", \"a*a*.*a*.*a*.b*a*\"}, true },\\n            { {\"aababbabacaabacbbbc\", \".b*ac*.*c*a*b*.*\"}, true },\\n            { {\"aaabaaaababcbccbaab\", \"c*c*.*c*a*..*c*\"}, true },\\n            { {\"cbccaababcbabac\", \"c*aab*.*b.b.*.*a*.\"}, false },\\n            { {\"caccccaccbabbcb\", \"c*c*b*a*.*c*.a*a*a*\"}, true },\\n            { {\"bbbaccbbbaababbac\", \".b*b*.*...*.*c*.\"}, true },\\n            { {\"ccbbcabcbbaabaccc\", \"c*a*.*a*a*.*c*b*b*.\"}, true },\\n            { {\"abbaaaabaabbcba\", \"a*.*ba.*c*..a*.a*.\"}, true },\\n            { {\"bbcacbabbcbaaccabc\", \"b*a*a*.c*bb*b*.*.*\"}, true },\\n            { {\"aabccbcbacabaab\", \".*c*a*b.*a*ba*bb*\"}, true },\\n            { {\"cbbbaccbcacbcca\", \"b*.*b*a*.a*b*.a*\"}, true },\\n            { {\"cbacbbabbcaabbb\", \"b*c*.*a*..a.*c*.*\"}, true },\\n            { {\"abaabababbcbcabbcbc\", \"b*ab.*.*.*.b..*\"}, true },\\n            { {\"caaacccbaababbb\", \"c*.*b*ba*ac*c*b*.*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"cacbacccbbbccab\", \".b*b*.*c*a*.*bb*\"}, true },\\n            { {\"abcbccbcbaabbcbb\", \"c*a.*ab*.*ab*a*..b*\"}, true },\\n            { {\"caabbabbbbccccbbbcc\", \".b*c*.*.*bb*.*.*\"}, true },\\n            { {\"caaccabbbabcacaac\", \"b*c*b*b*.b*.*c*a*c\"}, true },\\n            { {\"cbcaabcbaabccbaa\", \"c*b*ab*.*b*c*a*\"}, false },\\n            { {\"bccbcccbcbbbcbb\", \"c*c*c*c*c*.*.*b*b*\"}, true },\\n            { {\"ccacbcbcccabbab\", \".c*a*aa*b*.*b*.*\"}, true },\\n            { {\"aabbcbcacbacaaccacc\", \"c*b*b*.*.*.*a*.*\"}, true },\\n            { {\"bcbabcaacacbcabac\", \"a*c*a*b*.*aa*c*a*a*\"}, true },\\n            { {\"acabbabacaccacccabc\", \"a*.*c*a*.b.*a*.*\"}, true },\\n            { {\"babbcccbacaabcbac\", \"b.*.*c*b*b*.*c*c\"}, true },            \\n            { {\"cbbbbabaabbacbbc\", \"a*c*b*.*bb*a*.*a*\"}, true },            \\n            { {\"accbabbacbbbacb\", \".*.*.*a*bba*ba*\"}, false },\\n            { {\"ababbcaaabbaccb\", \"c*c*..*a*a*a*.*\"}, true },\\n            { {\"bcabcbcaccabcbb\", \"a*a*c*a*.*a*c*bc*.\"}, true },\\n            { {\"bcbbbacbabccbabbac\", \"c*.*b*a.*a*a*a*\"}, true },\\n            { {\"ccbbbbbacacaaabcaa\", \".*ba*.*.b*c*c*b*a.*\"}, true },\\n            { {\"acaababbccbaacabcab\", \"..*bb*b*c*a*c*.*.b\"}, true },\\n            { {\"cbabcabbbacbcaca\", \"a*c*.*a*a*b*c*a*.*\"}, true },\\n            { {\"bacacaababbbcbc\", \".*a*.*a*.aa*c*b*c\"}, false },\\n            { {\"cbabcbbaabbcaca\", \".a*b*.*.*b*c*.*b*a*\"}, true },\\n            { {\"bbaaaacabccbcac\", \"b*b*a*c*c*a*c*.*\"}, true },\\n            { {\"bcccccbaccccacaa\", \".*bb*c*a*b*.*b*b*c*\"}, true },\\n            { {\"bcbaccbbbccabaac\", \"c*.*a*b*ac*a*a*\"}, true },\\n            { {\"bacacbacaaabccbcbaa\", \"a*.c*c*c*a*b*..*\"}, true },\\n            { {\"baccbbcbcacacbbc\", \"c*.*b*c*ba*b*b*.a*\"}, true },\\n\\n        };"
                    },
                    {
                        "username": "Husoski",
                        "content": "Which test are you complaining about?  I only checked the first six patterns and they are all good.  If you have doubts, try using an IDE or code-friendly editor with regex search to \"find\" the target string using the given pattern."
                    },
                    {
                        "username": "ophirrachman",
                        "content": "Wrong Answer\\n\\nDetails \\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@ophirrachman](/ophirrachman) In this case `c*` can be removed, `a*` can occur 2 times so it forms `aab`, hence it returns `true`"
                    },
                    {
                        "username": "taxpayer61543",
                        "content": "\"aab\"\\n\"c\\\\*a*b\"\\n\\nThis test case is wrong. Should output False, not True."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/\\n"
                    }
                ]
            },
            {
                "id": 1576732,
                "content": [
                    {
                        "username": "mylemoncake",
                        "content": "So the * matches the wild character . itself but not the actual char it may represents?"
                    },
                    {
                        "username": "guapter",
                        "content": "it is NOT valid regex! \n```\ns =\"abc\"\np =\"a***abc\"\n```\n\nin task conditions there is a constraint: \"It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\"\nfor case of a*** it is invalid regex expression. If imagine we should convert it to real regex - it could be too many options here - a*/*/* a/**/* a/*/*/* and so on, thats why regex dont accept this expression! \nyour tests have syntax error! Fix pls! "
                    },
                    {
                        "username": "weraponpat",
                        "content": "believe me or not I got this question in the actual interview."
                    },
                    {
                        "username": "user8272RT",
                        "content": "This was hard. Took multiple attempts to resolve the edge cases."
                    },
                    {
                        "username": "Suharkov",
                        "content": "What i\\'m doing wrong?\\n`s = \"abc\"`\\n`p = \"a***abc\"`\\nExpected true, but `a***abc` is not a valid regular expression.."
                    },
                    {
                        "username": "Andrew_Richards_CS",
                        "content": "The leetcode top-down java solution fails the last test case on this question due to time limit exceeded when executing case:\\ns=\"aaaaaaaaaaaaaaaaaaab\"\\np=\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nI\\'m considering this one completed with my original solution. If this test case gets removed, I will revisit."
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "For some reason it gets accepted on Submission, even when it fails on individual run with TLE."
                    },
                    {
                        "username": "nesenenkoav",
                        "content": "67 tescases is invalid and should be fixed\\n\\n        std::map< std::pair<std::string, std::string>, bool > invalidCases = {\\n            { {\"aab\", \"c*a*b\"}, true },\\n            { {\"mississippi\", \"mis*is*p*.\"}, false },\\n            { {\"aaa\", \"ab*ac*a\"}, true },\\n            { {\"aaa\", \"ab*a*c*a\"}, true },\\n            { {\"aaca\", \"ab*a*c*a\"}, true },\\n            { {\"a\", \"ab*\"}, true },\\n            { {\"bbbba\", \".*a*a\"}, true },\\n            { {\"ab\", \".*..\"}, true },\\n            { {\"ab\", \".*..c*\"}, true },\\n            { {\"a\", \".*.\"}, true },\\n            { {\"aasdfasdfasdfasdfas\", \"aasdf.*asdf.*asdf.*asdf.*s\"}, true },\\n            { {\"abbbcd\", \"ab*bbbcd\"}, true },\\n            { {\"bbab\", \"b*a*\"}, false },\\n            { {\"a\", \"c*.\"}, true },\\n            { {\"a\", \"c*a\"}, true },\\n            { {\"b\", \"a*.\"}, true },\\n            { {\"a\", \".*a*\"}, true },\\n            { {\"a\", \"..*\"}, true },\\n            { {\"aabcbcbcaccbcaabc\", \".*a*aa*.*b*.c*.*a*\"}, true },\\n            { {\"abbabaaaaaaacaa\", \"a*.*b.a.*c*b*a*c*\"}, true },\\n            { {\"bcaccbbacbcbcab\", \"b*.c*..*.b*b*.*c*\"}, true },\\n            { {\"baabbbaccbccacacc\", \"c*..b*a*a.*a..*c\"}, true },\\n            { {\"abcaaaaaaabaabcabac\", \".*ab.a.*a*a*.*b*b*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cbaacacaaccbaabcb\", \"c*b*b*.*ac*.*bc*a*\"}, true },\\n            { {\"cabbbbcbcacbabc\", \".*b.*.ab*.*b*a*c\"}, true },\\n            { {\"abbcacbbbbbabcbaca\", \"a*a*.*a*.*a*.b*a*\"}, true },\\n            { {\"aababbabacaabacbbbc\", \".b*ac*.*c*a*b*.*\"}, true },\\n            { {\"aaabaaaababcbccbaab\", \"c*c*.*c*a*..*c*\"}, true },\\n            { {\"cbccaababcbabac\", \"c*aab*.*b.b.*.*a*.\"}, false },\\n            { {\"caccccaccbabbcb\", \"c*c*b*a*.*c*.a*a*a*\"}, true },\\n            { {\"bbbaccbbbaababbac\", \".b*b*.*...*.*c*.\"}, true },\\n            { {\"ccbbcabcbbaabaccc\", \"c*a*.*a*a*.*c*b*b*.\"}, true },\\n            { {\"abbaaaabaabbcba\", \"a*.*ba.*c*..a*.a*.\"}, true },\\n            { {\"bbcacbabbcbaaccabc\", \"b*a*a*.c*bb*b*.*.*\"}, true },\\n            { {\"aabccbcbacabaab\", \".*c*a*b.*a*ba*bb*\"}, true },\\n            { {\"cbbbaccbcacbcca\", \"b*.*b*a*.a*b*.a*\"}, true },\\n            { {\"cbacbbabbcaabbb\", \"b*c*.*a*..a.*c*.*\"}, true },\\n            { {\"abaabababbcbcabbcbc\", \"b*ab.*.*.*.b..*\"}, true },\\n            { {\"caaacccbaababbb\", \"c*.*b*ba*ac*c*b*.*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"abbbaabccbaabacab\", \"ab*b*b*bc*ac*.*bb*\"}, true },\\n            { {\"cacbacccbbbccab\", \".b*b*.*c*a*.*bb*\"}, true },\\n            { {\"abcbccbcbaabbcbb\", \"c*a.*ab*.*ab*a*..b*\"}, true },\\n            { {\"caabbabbbbccccbbbcc\", \".b*c*.*.*bb*.*.*\"}, true },\\n            { {\"caaccabbbabcacaac\", \"b*c*b*b*.b*.*c*a*c\"}, true },\\n            { {\"cbcaabcbaabccbaa\", \"c*b*ab*.*b*c*a*\"}, false },\\n            { {\"bccbcccbcbbbcbb\", \"c*c*c*c*c*.*.*b*b*\"}, true },\\n            { {\"ccacbcbcccabbab\", \".c*a*aa*b*.*b*.*\"}, true },\\n            { {\"aabbcbcacbacaaccacc\", \"c*b*b*.*.*.*a*.*\"}, true },\\n            { {\"bcbabcaacacbcabac\", \"a*c*a*b*.*aa*c*a*a*\"}, true },\\n            { {\"acabbabacaccacccabc\", \"a*.*c*a*.b.*a*.*\"}, true },\\n            { {\"babbcccbacaabcbac\", \"b.*.*c*b*b*.*c*c\"}, true },            \\n            { {\"cbbbbabaabbacbbc\", \"a*c*b*.*bb*a*.*a*\"}, true },            \\n            { {\"accbabbacbbbacb\", \".*.*.*a*bba*ba*\"}, false },\\n            { {\"ababbcaaabbaccb\", \"c*c*..*a*a*a*.*\"}, true },\\n            { {\"bcabcbcaccabcbb\", \"a*a*c*a*.*a*c*bc*.\"}, true },\\n            { {\"bcbbbacbabccbabbac\", \"c*.*b*a.*a*a*a*\"}, true },\\n            { {\"ccbbbbbacacaaabcaa\", \".*ba*.*.b*c*c*b*a.*\"}, true },\\n            { {\"acaababbccbaacabcab\", \"..*bb*b*c*a*c*.*.b\"}, true },\\n            { {\"cbabcabbbacbcaca\", \"a*c*.*a*a*b*c*a*.*\"}, true },\\n            { {\"bacacaababbbcbc\", \".*a*.*a*.aa*c*b*c\"}, false },\\n            { {\"cbabcbbaabbcaca\", \".a*b*.*.*b*c*.*b*a*\"}, true },\\n            { {\"bbaaaacabccbcac\", \"b*b*a*c*c*a*c*.*\"}, true },\\n            { {\"bcccccbaccccacaa\", \".*bb*c*a*b*.*b*b*c*\"}, true },\\n            { {\"bcbaccbbbccabaac\", \"c*.*a*b*ac*a*a*\"}, true },\\n            { {\"bacacbacaaabccbcbaa\", \"a*.c*c*c*a*b*..*\"}, true },\\n            { {\"baccbbcbcacacbbc\", \"c*.*b*c*ba*b*b*.a*\"}, true },\\n\\n        };"
                    },
                    {
                        "username": "Husoski",
                        "content": "Which test are you complaining about?  I only checked the first six patterns and they are all good.  If you have doubts, try using an IDE or code-friendly editor with regex search to \"find\" the target string using the given pattern."
                    },
                    {
                        "username": "ophirrachman",
                        "content": "Wrong Answer\\n\\nDetails \\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nOutput\\nfalse\\n\\nExpected\\ntrue"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@ophirrachman](/ophirrachman) In this case `c*` can be removed, `a*` can occur 2 times so it forms `aab`, hence it returns `true`"
                    },
                    {
                        "username": "taxpayer61543",
                        "content": "\"aab\"\\n\"c\\\\*a*b\"\\n\\nThis test case is wrong. Should output False, not True."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/\\n"
                    }
                ]
            },
            {
                "id": 1576654,
                "content": [
                    {
                        "username": "el_cucuy",
                        "content": "why is expected solution for aaa, ab*a false? can anybody explain?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1968319/Fast-Java-or-JavaScript-or-C%2B%2B-or-Python-Solution"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    },
                    {
                        "username": "jleducq",
                        "content": "Looks like there is an error in one of the test case (287)?\\n\\nInput:\\n\"aab\"\\n\"c\\\\*a*b\"\\n\\nOutput:  <--- my output\\nfalse\\n\\nExpected:\\ntrue\\n\\nAm I right to say that the output should be false and not true ? The pattern starts with \\'c\\' there is no \\'c\\' in the string. How can we expect to have true as output? Am I missing something here?"
                    },
                    {
                        "username": "Naharul98",
                        "content": "Why is the expected output of the following test case True?\\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nExpected\\ntrue\\n\\nThe pattern starts with c, however, the input starts with a, therefore it doesn\\'t match a literal. Why is the expected output a match then?"
                    },
                    {
                        "username": "tushar091",
                        "content": "Why does this case evaluate to be true?\\n\\n\"aabcde\"\\n\"a*..*\""
                    },
                    {
                        "username": "deadlogic",
                        "content": "return s.matches(p);"
                    },
                    {
                        "username": "yakovina",
                        "content": "What is about this test case?\\n\"ab\"\\n\".*\" -> True\\n\\nHow it possible that this pattern match given string?\\nIt\\'s clear how \".*\" matches \"a\", \"aa\", \"aaa\"... but how \"b\" fits here ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "venumedidi",
                        "content": "Why the test \"s = ab\" & \"p = .*\" expected result is true. \\nwhere as \"s = ab\" & \"p = .*c\" expected is false?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "July 2, 2020\\n\\nIt take some time for me to review all my past practice on this hard level algorithm. What I like to do is to write a few discussion posts first, and then I will figure out how to review those practice. \\n\\nI went through very good learning experience to work with over 10 programmers as an interviewer or interviewee. I documented my p-r-a-m-p mock interview website over  10 times practice [here](https://github.com/jianminchen/Mock-interviews/tree/master/Sort%20by%20Algorithm/Regular%20expression%20parser). \\n\\n**Leetcode 10: regular expression**\\nJuly 2, 2017\\n[Case study - mock interview as an interviewer on July 2, 2017](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716760/Case-study-mock-interview-as-an-interviewer-on-July-2-2017)\\n\\n[C# code review memoization practice on July 2 2017](https://leetcode.com/problems/regular-expression-matching/discuss/716875/C-code-review-memoization-practice-on-July-2-2017)\\n\\nJanuary 26, 2018\\n[Case study: dynamic programming solution on January 26, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716835/Case-study%3A-dynamic-programming-solution-on-January-26-2018)\\n\\nApril 21, 2018\\n[Case study: mock interview as an interviewee on April 21, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716784/Case-study%3A-mock-interview-as-an-interviewee-on-April-21-2018)\\n\\n**Practice with a bug**\\nMarch 29, 2018\\n[Case study: dynamic programming solution with a bug on March 29, 2018](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716812/Case-study%3A-dynamic-programming-solution-with-a-bug-on-March-29-2020)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1576652,
                "content": [
                    {
                        "username": "el_cucuy",
                        "content": "why is expected solution for aaa, ab*a false? can anybody explain?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1968319/Fast-Java-or-JavaScript-or-C%2B%2B-or-Python-Solution"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    },
                    {
                        "username": "jleducq",
                        "content": "Looks like there is an error in one of the test case (287)?\\n\\nInput:\\n\"aab\"\\n\"c\\\\*a*b\"\\n\\nOutput:  <--- my output\\nfalse\\n\\nExpected:\\ntrue\\n\\nAm I right to say that the output should be false and not true ? The pattern starts with \\'c\\' there is no \\'c\\' in the string. How can we expect to have true as output? Am I missing something here?"
                    },
                    {
                        "username": "Naharul98",
                        "content": "Why is the expected output of the following test case True?\\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nExpected\\ntrue\\n\\nThe pattern starts with c, however, the input starts with a, therefore it doesn\\'t match a literal. Why is the expected output a match then?"
                    },
                    {
                        "username": "tushar091",
                        "content": "Why does this case evaluate to be true?\\n\\n\"aabcde\"\\n\"a*..*\""
                    },
                    {
                        "username": "deadlogic",
                        "content": "return s.matches(p);"
                    },
                    {
                        "username": "yakovina",
                        "content": "What is about this test case?\\n\"ab\"\\n\".*\" -> True\\n\\nHow it possible that this pattern match given string?\\nIt\\'s clear how \".*\" matches \"a\", \"aa\", \"aaa\"... but how \"b\" fits here ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "venumedidi",
                        "content": "Why the test \"s = ab\" & \"p = .*\" expected result is true. \\nwhere as \"s = ab\" & \"p = .*c\" expected is false?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "July 2, 2020\\n\\nIt take some time for me to review all my past practice on this hard level algorithm. What I like to do is to write a few discussion posts first, and then I will figure out how to review those practice. \\n\\nI went through very good learning experience to work with over 10 programmers as an interviewer or interviewee. I documented my p-r-a-m-p mock interview website over  10 times practice [here](https://github.com/jianminchen/Mock-interviews/tree/master/Sort%20by%20Algorithm/Regular%20expression%20parser). \\n\\n**Leetcode 10: regular expression**\\nJuly 2, 2017\\n[Case study - mock interview as an interviewer on July 2, 2017](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716760/Case-study-mock-interview-as-an-interviewer-on-July-2-2017)\\n\\n[C# code review memoization practice on July 2 2017](https://leetcode.com/problems/regular-expression-matching/discuss/716875/C-code-review-memoization-practice-on-July-2-2017)\\n\\nJanuary 26, 2018\\n[Case study: dynamic programming solution on January 26, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716835/Case-study%3A-dynamic-programming-solution-on-January-26-2018)\\n\\nApril 21, 2018\\n[Case study: mock interview as an interviewee on April 21, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716784/Case-study%3A-mock-interview-as-an-interviewee-on-April-21-2018)\\n\\n**Practice with a bug**\\nMarch 29, 2018\\n[Case study: dynamic programming solution with a bug on March 29, 2018](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716812/Case-study%3A-dynamic-programming-solution-with-a-bug-on-March-29-2020)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1576516,
                "content": [
                    {
                        "username": "el_cucuy",
                        "content": "why is expected solution for aaa, ab*a false? can anybody explain?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1968319/Fast-Java-or-JavaScript-or-C%2B%2B-or-Python-Solution"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    },
                    {
                        "username": "jleducq",
                        "content": "Looks like there is an error in one of the test case (287)?\\n\\nInput:\\n\"aab\"\\n\"c\\\\*a*b\"\\n\\nOutput:  <--- my output\\nfalse\\n\\nExpected:\\ntrue\\n\\nAm I right to say that the output should be false and not true ? The pattern starts with \\'c\\' there is no \\'c\\' in the string. How can we expect to have true as output? Am I missing something here?"
                    },
                    {
                        "username": "Naharul98",
                        "content": "Why is the expected output of the following test case True?\\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nExpected\\ntrue\\n\\nThe pattern starts with c, however, the input starts with a, therefore it doesn\\'t match a literal. Why is the expected output a match then?"
                    },
                    {
                        "username": "tushar091",
                        "content": "Why does this case evaluate to be true?\\n\\n\"aabcde\"\\n\"a*..*\""
                    },
                    {
                        "username": "deadlogic",
                        "content": "return s.matches(p);"
                    },
                    {
                        "username": "yakovina",
                        "content": "What is about this test case?\\n\"ab\"\\n\".*\" -> True\\n\\nHow it possible that this pattern match given string?\\nIt\\'s clear how \".*\" matches \"a\", \"aa\", \"aaa\"... but how \"b\" fits here ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "venumedidi",
                        "content": "Why the test \"s = ab\" & \"p = .*\" expected result is true. \\nwhere as \"s = ab\" & \"p = .*c\" expected is false?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "July 2, 2020\\n\\nIt take some time for me to review all my past practice on this hard level algorithm. What I like to do is to write a few discussion posts first, and then I will figure out how to review those practice. \\n\\nI went through very good learning experience to work with over 10 programmers as an interviewer or interviewee. I documented my p-r-a-m-p mock interview website over  10 times practice [here](https://github.com/jianminchen/Mock-interviews/tree/master/Sort%20by%20Algorithm/Regular%20expression%20parser). \\n\\n**Leetcode 10: regular expression**\\nJuly 2, 2017\\n[Case study - mock interview as an interviewer on July 2, 2017](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716760/Case-study-mock-interview-as-an-interviewer-on-July-2-2017)\\n\\n[C# code review memoization practice on July 2 2017](https://leetcode.com/problems/regular-expression-matching/discuss/716875/C-code-review-memoization-practice-on-July-2-2017)\\n\\nJanuary 26, 2018\\n[Case study: dynamic programming solution on January 26, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716835/Case-study%3A-dynamic-programming-solution-on-January-26-2018)\\n\\nApril 21, 2018\\n[Case study: mock interview as an interviewee on April 21, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716784/Case-study%3A-mock-interview-as-an-interviewee-on-April-21-2018)\\n\\n**Practice with a bug**\\nMarch 29, 2018\\n[Case study: dynamic programming solution with a bug on March 29, 2018](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716812/Case-study%3A-dynamic-programming-solution-with-a-bug-on-March-29-2020)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1576512,
                "content": [
                    {
                        "username": "el_cucuy",
                        "content": "why is expected solution for aaa, ab*a false? can anybody explain?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1968319/Fast-Java-or-JavaScript-or-C%2B%2B-or-Python-Solution"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    },
                    {
                        "username": "jleducq",
                        "content": "Looks like there is an error in one of the test case (287)?\\n\\nInput:\\n\"aab\"\\n\"c\\\\*a*b\"\\n\\nOutput:  <--- my output\\nfalse\\n\\nExpected:\\ntrue\\n\\nAm I right to say that the output should be false and not true ? The pattern starts with \\'c\\' there is no \\'c\\' in the string. How can we expect to have true as output? Am I missing something here?"
                    },
                    {
                        "username": "Naharul98",
                        "content": "Why is the expected output of the following test case True?\\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nExpected\\ntrue\\n\\nThe pattern starts with c, however, the input starts with a, therefore it doesn\\'t match a literal. Why is the expected output a match then?"
                    },
                    {
                        "username": "tushar091",
                        "content": "Why does this case evaluate to be true?\\n\\n\"aabcde\"\\n\"a*..*\""
                    },
                    {
                        "username": "deadlogic",
                        "content": "return s.matches(p);"
                    },
                    {
                        "username": "yakovina",
                        "content": "What is about this test case?\\n\"ab\"\\n\".*\" -> True\\n\\nHow it possible that this pattern match given string?\\nIt\\'s clear how \".*\" matches \"a\", \"aa\", \"aaa\"... but how \"b\" fits here ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "venumedidi",
                        "content": "Why the test \"s = ab\" & \"p = .*\" expected result is true. \\nwhere as \"s = ab\" & \"p = .*c\" expected is false?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "July 2, 2020\\n\\nIt take some time for me to review all my past practice on this hard level algorithm. What I like to do is to write a few discussion posts first, and then I will figure out how to review those practice. \\n\\nI went through very good learning experience to work with over 10 programmers as an interviewer or interviewee. I documented my p-r-a-m-p mock interview website over  10 times practice [here](https://github.com/jianminchen/Mock-interviews/tree/master/Sort%20by%20Algorithm/Regular%20expression%20parser). \\n\\n**Leetcode 10: regular expression**\\nJuly 2, 2017\\n[Case study - mock interview as an interviewer on July 2, 2017](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716760/Case-study-mock-interview-as-an-interviewer-on-July-2-2017)\\n\\n[C# code review memoization practice on July 2 2017](https://leetcode.com/problems/regular-expression-matching/discuss/716875/C-code-review-memoization-practice-on-July-2-2017)\\n\\nJanuary 26, 2018\\n[Case study: dynamic programming solution on January 26, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716835/Case-study%3A-dynamic-programming-solution-on-January-26-2018)\\n\\nApril 21, 2018\\n[Case study: mock interview as an interviewee on April 21, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716784/Case-study%3A-mock-interview-as-an-interviewee-on-April-21-2018)\\n\\n**Practice with a bug**\\nMarch 29, 2018\\n[Case study: dynamic programming solution with a bug on March 29, 2018](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716812/Case-study%3A-dynamic-programming-solution-with-a-bug-on-March-29-2020)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1576477,
                "content": [
                    {
                        "username": "el_cucuy",
                        "content": "why is expected solution for aaa, ab*a false? can anybody explain?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1968319/Fast-Java-or-JavaScript-or-C%2B%2B-or-Python-Solution"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    },
                    {
                        "username": "jleducq",
                        "content": "Looks like there is an error in one of the test case (287)?\\n\\nInput:\\n\"aab\"\\n\"c\\\\*a*b\"\\n\\nOutput:  <--- my output\\nfalse\\n\\nExpected:\\ntrue\\n\\nAm I right to say that the output should be false and not true ? The pattern starts with \\'c\\' there is no \\'c\\' in the string. How can we expect to have true as output? Am I missing something here?"
                    },
                    {
                        "username": "Naharul98",
                        "content": "Why is the expected output of the following test case True?\\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nExpected\\ntrue\\n\\nThe pattern starts with c, however, the input starts with a, therefore it doesn\\'t match a literal. Why is the expected output a match then?"
                    },
                    {
                        "username": "tushar091",
                        "content": "Why does this case evaluate to be true?\\n\\n\"aabcde\"\\n\"a*..*\""
                    },
                    {
                        "username": "deadlogic",
                        "content": "return s.matches(p);"
                    },
                    {
                        "username": "yakovina",
                        "content": "What is about this test case?\\n\"ab\"\\n\".*\" -> True\\n\\nHow it possible that this pattern match given string?\\nIt\\'s clear how \".*\" matches \"a\", \"aa\", \"aaa\"... but how \"b\" fits here ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "venumedidi",
                        "content": "Why the test \"s = ab\" & \"p = .*\" expected result is true. \\nwhere as \"s = ab\" & \"p = .*c\" expected is false?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "July 2, 2020\\n\\nIt take some time for me to review all my past practice on this hard level algorithm. What I like to do is to write a few discussion posts first, and then I will figure out how to review those practice. \\n\\nI went through very good learning experience to work with over 10 programmers as an interviewer or interviewee. I documented my p-r-a-m-p mock interview website over  10 times practice [here](https://github.com/jianminchen/Mock-interviews/tree/master/Sort%20by%20Algorithm/Regular%20expression%20parser). \\n\\n**Leetcode 10: regular expression**\\nJuly 2, 2017\\n[Case study - mock interview as an interviewer on July 2, 2017](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716760/Case-study-mock-interview-as-an-interviewer-on-July-2-2017)\\n\\n[C# code review memoization practice on July 2 2017](https://leetcode.com/problems/regular-expression-matching/discuss/716875/C-code-review-memoization-practice-on-July-2-2017)\\n\\nJanuary 26, 2018\\n[Case study: dynamic programming solution on January 26, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716835/Case-study%3A-dynamic-programming-solution-on-January-26-2018)\\n\\nApril 21, 2018\\n[Case study: mock interview as an interviewee on April 21, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716784/Case-study%3A-mock-interview-as-an-interviewee-on-April-21-2018)\\n\\n**Practice with a bug**\\nMarch 29, 2018\\n[Case study: dynamic programming solution with a bug on March 29, 2018](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716812/Case-study%3A-dynamic-programming-solution-with-a-bug-on-March-29-2020)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1575164,
                "content": [
                    {
                        "username": "el_cucuy",
                        "content": "why is expected solution for aaa, ab*a false? can anybody explain?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1968319/Fast-Java-or-JavaScript-or-C%2B%2B-or-Python-Solution"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    },
                    {
                        "username": "jleducq",
                        "content": "Looks like there is an error in one of the test case (287)?\\n\\nInput:\\n\"aab\"\\n\"c\\\\*a*b\"\\n\\nOutput:  <--- my output\\nfalse\\n\\nExpected:\\ntrue\\n\\nAm I right to say that the output should be false and not true ? The pattern starts with \\'c\\' there is no \\'c\\' in the string. How can we expect to have true as output? Am I missing something here?"
                    },
                    {
                        "username": "Naharul98",
                        "content": "Why is the expected output of the following test case True?\\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nExpected\\ntrue\\n\\nThe pattern starts with c, however, the input starts with a, therefore it doesn\\'t match a literal. Why is the expected output a match then?"
                    },
                    {
                        "username": "tushar091",
                        "content": "Why does this case evaluate to be true?\\n\\n\"aabcde\"\\n\"a*..*\""
                    },
                    {
                        "username": "deadlogic",
                        "content": "return s.matches(p);"
                    },
                    {
                        "username": "yakovina",
                        "content": "What is about this test case?\\n\"ab\"\\n\".*\" -> True\\n\\nHow it possible that this pattern match given string?\\nIt\\'s clear how \".*\" matches \"a\", \"aa\", \"aaa\"... but how \"b\" fits here ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "venumedidi",
                        "content": "Why the test \"s = ab\" & \"p = .*\" expected result is true. \\nwhere as \"s = ab\" & \"p = .*c\" expected is false?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "July 2, 2020\\n\\nIt take some time for me to review all my past practice on this hard level algorithm. What I like to do is to write a few discussion posts first, and then I will figure out how to review those practice. \\n\\nI went through very good learning experience to work with over 10 programmers as an interviewer or interviewee. I documented my p-r-a-m-p mock interview website over  10 times practice [here](https://github.com/jianminchen/Mock-interviews/tree/master/Sort%20by%20Algorithm/Regular%20expression%20parser). \\n\\n**Leetcode 10: regular expression**\\nJuly 2, 2017\\n[Case study - mock interview as an interviewer on July 2, 2017](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716760/Case-study-mock-interview-as-an-interviewer-on-July-2-2017)\\n\\n[C# code review memoization practice on July 2 2017](https://leetcode.com/problems/regular-expression-matching/discuss/716875/C-code-review-memoization-practice-on-July-2-2017)\\n\\nJanuary 26, 2018\\n[Case study: dynamic programming solution on January 26, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716835/Case-study%3A-dynamic-programming-solution-on-January-26-2018)\\n\\nApril 21, 2018\\n[Case study: mock interview as an interviewee on April 21, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716784/Case-study%3A-mock-interview-as-an-interviewee-on-April-21-2018)\\n\\n**Practice with a bug**\\nMarch 29, 2018\\n[Case study: dynamic programming solution with a bug on March 29, 2018](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716812/Case-study%3A-dynamic-programming-solution-with-a-bug-on-March-29-2020)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1574840,
                "content": [
                    {
                        "username": "el_cucuy",
                        "content": "why is expected solution for aaa, ab*a false? can anybody explain?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1968319/Fast-Java-or-JavaScript-or-C%2B%2B-or-Python-Solution"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    },
                    {
                        "username": "jleducq",
                        "content": "Looks like there is an error in one of the test case (287)?\\n\\nInput:\\n\"aab\"\\n\"c\\\\*a*b\"\\n\\nOutput:  <--- my output\\nfalse\\n\\nExpected:\\ntrue\\n\\nAm I right to say that the output should be false and not true ? The pattern starts with \\'c\\' there is no \\'c\\' in the string. How can we expect to have true as output? Am I missing something here?"
                    },
                    {
                        "username": "Naharul98",
                        "content": "Why is the expected output of the following test case True?\\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nExpected\\ntrue\\n\\nThe pattern starts with c, however, the input starts with a, therefore it doesn\\'t match a literal. Why is the expected output a match then?"
                    },
                    {
                        "username": "tushar091",
                        "content": "Why does this case evaluate to be true?\\n\\n\"aabcde\"\\n\"a*..*\""
                    },
                    {
                        "username": "deadlogic",
                        "content": "return s.matches(p);"
                    },
                    {
                        "username": "yakovina",
                        "content": "What is about this test case?\\n\"ab\"\\n\".*\" -> True\\n\\nHow it possible that this pattern match given string?\\nIt\\'s clear how \".*\" matches \"a\", \"aa\", \"aaa\"... but how \"b\" fits here ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "venumedidi",
                        "content": "Why the test \"s = ab\" & \"p = .*\" expected result is true. \\nwhere as \"s = ab\" & \"p = .*c\" expected is false?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "July 2, 2020\\n\\nIt take some time for me to review all my past practice on this hard level algorithm. What I like to do is to write a few discussion posts first, and then I will figure out how to review those practice. \\n\\nI went through very good learning experience to work with over 10 programmers as an interviewer or interviewee. I documented my p-r-a-m-p mock interview website over  10 times practice [here](https://github.com/jianminchen/Mock-interviews/tree/master/Sort%20by%20Algorithm/Regular%20expression%20parser). \\n\\n**Leetcode 10: regular expression**\\nJuly 2, 2017\\n[Case study - mock interview as an interviewer on July 2, 2017](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716760/Case-study-mock-interview-as-an-interviewer-on-July-2-2017)\\n\\n[C# code review memoization practice on July 2 2017](https://leetcode.com/problems/regular-expression-matching/discuss/716875/C-code-review-memoization-practice-on-July-2-2017)\\n\\nJanuary 26, 2018\\n[Case study: dynamic programming solution on January 26, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716835/Case-study%3A-dynamic-programming-solution-on-January-26-2018)\\n\\nApril 21, 2018\\n[Case study: mock interview as an interviewee on April 21, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716784/Case-study%3A-mock-interview-as-an-interviewee-on-April-21-2018)\\n\\n**Practice with a bug**\\nMarch 29, 2018\\n[Case study: dynamic programming solution with a bug on March 29, 2018](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716812/Case-study%3A-dynamic-programming-solution-with-a-bug-on-March-29-2020)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1574783,
                "content": [
                    {
                        "username": "el_cucuy",
                        "content": "why is expected solution for aaa, ab*a false? can anybody explain?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1968319/Fast-Java-or-JavaScript-or-C%2B%2B-or-Python-Solution"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    },
                    {
                        "username": "jleducq",
                        "content": "Looks like there is an error in one of the test case (287)?\\n\\nInput:\\n\"aab\"\\n\"c\\\\*a*b\"\\n\\nOutput:  <--- my output\\nfalse\\n\\nExpected:\\ntrue\\n\\nAm I right to say that the output should be false and not true ? The pattern starts with \\'c\\' there is no \\'c\\' in the string. How can we expect to have true as output? Am I missing something here?"
                    },
                    {
                        "username": "Naharul98",
                        "content": "Why is the expected output of the following test case True?\\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nExpected\\ntrue\\n\\nThe pattern starts with c, however, the input starts with a, therefore it doesn\\'t match a literal. Why is the expected output a match then?"
                    },
                    {
                        "username": "tushar091",
                        "content": "Why does this case evaluate to be true?\\n\\n\"aabcde\"\\n\"a*..*\""
                    },
                    {
                        "username": "deadlogic",
                        "content": "return s.matches(p);"
                    },
                    {
                        "username": "yakovina",
                        "content": "What is about this test case?\\n\"ab\"\\n\".*\" -> True\\n\\nHow it possible that this pattern match given string?\\nIt\\'s clear how \".*\" matches \"a\", \"aa\", \"aaa\"... but how \"b\" fits here ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "venumedidi",
                        "content": "Why the test \"s = ab\" & \"p = .*\" expected result is true. \\nwhere as \"s = ab\" & \"p = .*c\" expected is false?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "July 2, 2020\\n\\nIt take some time for me to review all my past practice on this hard level algorithm. What I like to do is to write a few discussion posts first, and then I will figure out how to review those practice. \\n\\nI went through very good learning experience to work with over 10 programmers as an interviewer or interviewee. I documented my p-r-a-m-p mock interview website over  10 times practice [here](https://github.com/jianminchen/Mock-interviews/tree/master/Sort%20by%20Algorithm/Regular%20expression%20parser). \\n\\n**Leetcode 10: regular expression**\\nJuly 2, 2017\\n[Case study - mock interview as an interviewer on July 2, 2017](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716760/Case-study-mock-interview-as-an-interviewer-on-July-2-2017)\\n\\n[C# code review memoization practice on July 2 2017](https://leetcode.com/problems/regular-expression-matching/discuss/716875/C-code-review-memoization-practice-on-July-2-2017)\\n\\nJanuary 26, 2018\\n[Case study: dynamic programming solution on January 26, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716835/Case-study%3A-dynamic-programming-solution-on-January-26-2018)\\n\\nApril 21, 2018\\n[Case study: mock interview as an interviewee on April 21, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716784/Case-study%3A-mock-interview-as-an-interviewee-on-April-21-2018)\\n\\n**Practice with a bug**\\nMarch 29, 2018\\n[Case study: dynamic programming solution with a bug on March 29, 2018](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716812/Case-study%3A-dynamic-programming-solution-with-a-bug-on-March-29-2020)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1574157,
                "content": [
                    {
                        "username": "el_cucuy",
                        "content": "why is expected solution for aaa, ab*a false? can anybody explain?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1968319/Fast-Java-or-JavaScript-or-C%2B%2B-or-Python-Solution"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    },
                    {
                        "username": "jleducq",
                        "content": "Looks like there is an error in one of the test case (287)?\\n\\nInput:\\n\"aab\"\\n\"c\\\\*a*b\"\\n\\nOutput:  <--- my output\\nfalse\\n\\nExpected:\\ntrue\\n\\nAm I right to say that the output should be false and not true ? The pattern starts with \\'c\\' there is no \\'c\\' in the string. How can we expect to have true as output? Am I missing something here?"
                    },
                    {
                        "username": "Naharul98",
                        "content": "Why is the expected output of the following test case True?\\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nExpected\\ntrue\\n\\nThe pattern starts with c, however, the input starts with a, therefore it doesn\\'t match a literal. Why is the expected output a match then?"
                    },
                    {
                        "username": "tushar091",
                        "content": "Why does this case evaluate to be true?\\n\\n\"aabcde\"\\n\"a*..*\""
                    },
                    {
                        "username": "deadlogic",
                        "content": "return s.matches(p);"
                    },
                    {
                        "username": "yakovina",
                        "content": "What is about this test case?\\n\"ab\"\\n\".*\" -> True\\n\\nHow it possible that this pattern match given string?\\nIt\\'s clear how \".*\" matches \"a\", \"aa\", \"aaa\"... but how \"b\" fits here ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "venumedidi",
                        "content": "Why the test \"s = ab\" & \"p = .*\" expected result is true. \\nwhere as \"s = ab\" & \"p = .*c\" expected is false?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "July 2, 2020\\n\\nIt take some time for me to review all my past practice on this hard level algorithm. What I like to do is to write a few discussion posts first, and then I will figure out how to review those practice. \\n\\nI went through very good learning experience to work with over 10 programmers as an interviewer or interviewee. I documented my p-r-a-m-p mock interview website over  10 times practice [here](https://github.com/jianminchen/Mock-interviews/tree/master/Sort%20by%20Algorithm/Regular%20expression%20parser). \\n\\n**Leetcode 10: regular expression**\\nJuly 2, 2017\\n[Case study - mock interview as an interviewer on July 2, 2017](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716760/Case-study-mock-interview-as-an-interviewer-on-July-2-2017)\\n\\n[C# code review memoization practice on July 2 2017](https://leetcode.com/problems/regular-expression-matching/discuss/716875/C-code-review-memoization-practice-on-July-2-2017)\\n\\nJanuary 26, 2018\\n[Case study: dynamic programming solution on January 26, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716835/Case-study%3A-dynamic-programming-solution-on-January-26-2018)\\n\\nApril 21, 2018\\n[Case study: mock interview as an interviewee on April 21, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716784/Case-study%3A-mock-interview-as-an-interviewee-on-April-21-2018)\\n\\n**Practice with a bug**\\nMarch 29, 2018\\n[Case study: dynamic programming solution with a bug on March 29, 2018](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716812/Case-study%3A-dynamic-programming-solution-with-a-bug-on-March-29-2020)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1574004,
                "content": [
                    {
                        "username": "el_cucuy",
                        "content": "why is expected solution for aaa, ab*a false? can anybody explain?"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1968319/Fast-Java-or-JavaScript-or-C%2B%2B-or-Python-Solution"
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    },
                    {
                        "username": "jleducq",
                        "content": "Looks like there is an error in one of the test case (287)?\\n\\nInput:\\n\"aab\"\\n\"c\\\\*a*b\"\\n\\nOutput:  <--- my output\\nfalse\\n\\nExpected:\\ntrue\\n\\nAm I right to say that the output should be false and not true ? The pattern starts with \\'c\\' there is no \\'c\\' in the string. How can we expect to have true as output? Am I missing something here?"
                    },
                    {
                        "username": "Naharul98",
                        "content": "Why is the expected output of the following test case True?\\n\\nInput\\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\n\\nExpected\\ntrue\\n\\nThe pattern starts with c, however, the input starts with a, therefore it doesn\\'t match a literal. Why is the expected output a match then?"
                    },
                    {
                        "username": "tushar091",
                        "content": "Why does this case evaluate to be true?\\n\\n\"aabcde\"\\n\"a*..*\""
                    },
                    {
                        "username": "deadlogic",
                        "content": "return s.matches(p);"
                    },
                    {
                        "username": "yakovina",
                        "content": "What is about this test case?\\n\"ab\"\\n\".*\" -> True\\n\\nHow it possible that this pattern match given string?\\nIt\\'s clear how \".*\" matches \"a\", \"aa\", \"aaa\"... but how \"b\" fits here ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "venumedidi",
                        "content": "Why the test \"s = ab\" & \"p = .*\" expected result is true. \\nwhere as \"s = ab\" & \"p = .*c\" expected is false?"
                    },
                    {
                        "username": "jianminchen",
                        "content": "July 2, 2020\\n\\nIt take some time for me to review all my past practice on this hard level algorithm. What I like to do is to write a few discussion posts first, and then I will figure out how to review those practice. \\n\\nI went through very good learning experience to work with over 10 programmers as an interviewer or interviewee. I documented my p-r-a-m-p mock interview website over  10 times practice [here](https://github.com/jianminchen/Mock-interviews/tree/master/Sort%20by%20Algorithm/Regular%20expression%20parser). \\n\\n**Leetcode 10: regular expression**\\nJuly 2, 2017\\n[Case study - mock interview as an interviewer on July 2, 2017](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716760/Case-study-mock-interview-as-an-interviewer-on-July-2-2017)\\n\\n[C# code review memoization practice on July 2 2017](https://leetcode.com/problems/regular-expression-matching/discuss/716875/C-code-review-memoization-practice-on-July-2-2017)\\n\\nJanuary 26, 2018\\n[Case study: dynamic programming solution on January 26, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716835/Case-study%3A-dynamic-programming-solution-on-January-26-2018)\\n\\nApril 21, 2018\\n[Case study: mock interview as an interviewee on April 21, 2018](https://leetcode.com/problems/regular-expression-matching/discuss/716784/Case-study%3A-mock-interview-as-an-interviewee-on-April-21-2018)\\n\\n**Practice with a bug**\\nMarch 29, 2018\\n[Case study: dynamic programming solution with a bug on March 29, 2018](\\nhttps://leetcode.com/problems/regular-expression-matching/discuss/716812/Case-study%3A-dynamic-programming-solution-with-a-bug-on-March-29-2020)\\n\\n\\n"
                    }
                ]
            },
            {
                "id": 1573982,
                "content": [
                    {
                        "username": "teracross",
                        "content": "The questions states that \"\\\\*\" means 0 or more of the preceding element in the pattern, in the case where s = \"aa\" and p=\"c*\", then wouldn\\'t this be a match since \"c*\" could be interpreted as any string with where there were zero occurrences of the element \"c\"??"
                    },
                    {
                        "username": "koogicho",
                        "content": "\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\n\\'.\\' is matched with \\'a\\' but \\'*\\' can\\'t be matched with \\'b\\'.\\nThe expected result of this case is true.\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nDo I think incorrectly?\\n\\n"
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "Let\\'s say: \\ndp[i][j] means length of i of source string match length of j pattern\\n\\nif p.charAt(j - 1) == \\'*\\' && p.charAt(j - 2) == s.charAt(i - 1), and I want to simulate * matches more of preceding element, \\nwhy dp[i][j] = dp[i - 1][j] ?\\n\\nfor example:\\ns: abc.....bc\\np: ......c* \\n\\nI feel like I\\u2019m stuck in a mindset, thx."
                    },
                    {
                        "username": "sd439",
                        "content": "By definition, \\'.\\\\*\\' means any number of \\'.\\', therefore should cover any input string.\\nIn the example 3, \\'.\\\\*\\' covers \\'ab\\' already. Obviously \\'.\\\\*c\\' covers \\'.\\\\*\\', why it doesn\\'t cover \\'ab\\'?\\nIs it a bug or if I misunderstand the question?"
                    },
                    {
                        "username": "HiteshRathi",
                        "content": "I find the above test case invalid. \\n.* with ab  is true as per question disciption. \\nBut .* means 0 or more repeteation of any one of the character.\\nright ?"
                    },
                    {
                        "username": "HasMirror",
                        "content": "s = \"aa\"\\np = \"ab * a * \"\\nresult is true.\\nIs there any one who can help me understand this test case? Why this test case is true? What the meaing of the last \"*\"?"
                    },
                    {
                        "username": "wing1001",
                        "content": "\\'\\'\\'\\nvar isMatch = function(s, p) {\\n   return s.match(p)==s ;     \\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Yassine7295",
                        "content": "Can someone explain why \".*\" matches \"ab\"?\\n\\n. matches one character. in this case, it should match with a. What matches with b?"
                    },
                    {
                        "username": "vaibhavbhosale15",
                        "content": "Whenever I am submitting my code, it first shows Accepted. Moments later it turns to Pending and after a while it becomes Internal Error. I also tried with a previously solved question. Same problem there. Is there some outage going on?"
                    },
                    {
                        "username": "rpd12138",
                        "content": "why (\"ab\" \".*\") is different of (\"ab\", \".*c\"),?"
                    }
                ]
            },
            {
                "id": 1573938,
                "content": [
                    {
                        "username": "teracross",
                        "content": "The questions states that \"\\\\*\" means 0 or more of the preceding element in the pattern, in the case where s = \"aa\" and p=\"c*\", then wouldn\\'t this be a match since \"c*\" could be interpreted as any string with where there were zero occurrences of the element \"c\"??"
                    },
                    {
                        "username": "koogicho",
                        "content": "\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\n\\'.\\' is matched with \\'a\\' but \\'*\\' can\\'t be matched with \\'b\\'.\\nThe expected result of this case is true.\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nDo I think incorrectly?\\n\\n"
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "Let\\'s say: \\ndp[i][j] means length of i of source string match length of j pattern\\n\\nif p.charAt(j - 1) == \\'*\\' && p.charAt(j - 2) == s.charAt(i - 1), and I want to simulate * matches more of preceding element, \\nwhy dp[i][j] = dp[i - 1][j] ?\\n\\nfor example:\\ns: abc.....bc\\np: ......c* \\n\\nI feel like I\\u2019m stuck in a mindset, thx."
                    },
                    {
                        "username": "sd439",
                        "content": "By definition, \\'.\\\\*\\' means any number of \\'.\\', therefore should cover any input string.\\nIn the example 3, \\'.\\\\*\\' covers \\'ab\\' already. Obviously \\'.\\\\*c\\' covers \\'.\\\\*\\', why it doesn\\'t cover \\'ab\\'?\\nIs it a bug or if I misunderstand the question?"
                    },
                    {
                        "username": "HiteshRathi",
                        "content": "I find the above test case invalid. \\n.* with ab  is true as per question disciption. \\nBut .* means 0 or more repeteation of any one of the character.\\nright ?"
                    },
                    {
                        "username": "HasMirror",
                        "content": "s = \"aa\"\\np = \"ab * a * \"\\nresult is true.\\nIs there any one who can help me understand this test case? Why this test case is true? What the meaing of the last \"*\"?"
                    },
                    {
                        "username": "wing1001",
                        "content": "\\'\\'\\'\\nvar isMatch = function(s, p) {\\n   return s.match(p)==s ;     \\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Yassine7295",
                        "content": "Can someone explain why \".*\" matches \"ab\"?\\n\\n. matches one character. in this case, it should match with a. What matches with b?"
                    },
                    {
                        "username": "vaibhavbhosale15",
                        "content": "Whenever I am submitting my code, it first shows Accepted. Moments later it turns to Pending and after a while it becomes Internal Error. I also tried with a previously solved question. Same problem there. Is there some outage going on?"
                    },
                    {
                        "username": "rpd12138",
                        "content": "why (\"ab\" \".*\") is different of (\"ab\", \".*c\"),?"
                    }
                ]
            },
            {
                "id": 1573908,
                "content": [
                    {
                        "username": "teracross",
                        "content": "The questions states that \"\\\\*\" means 0 or more of the preceding element in the pattern, in the case where s = \"aa\" and p=\"c*\", then wouldn\\'t this be a match since \"c*\" could be interpreted as any string with where there were zero occurrences of the element \"c\"??"
                    },
                    {
                        "username": "koogicho",
                        "content": "\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\n\\'.\\' is matched with \\'a\\' but \\'*\\' can\\'t be matched with \\'b\\'.\\nThe expected result of this case is true.\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nDo I think incorrectly?\\n\\n"
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "Let\\'s say: \\ndp[i][j] means length of i of source string match length of j pattern\\n\\nif p.charAt(j - 1) == \\'*\\' && p.charAt(j - 2) == s.charAt(i - 1), and I want to simulate * matches more of preceding element, \\nwhy dp[i][j] = dp[i - 1][j] ?\\n\\nfor example:\\ns: abc.....bc\\np: ......c* \\n\\nI feel like I\\u2019m stuck in a mindset, thx."
                    },
                    {
                        "username": "sd439",
                        "content": "By definition, \\'.\\\\*\\' means any number of \\'.\\', therefore should cover any input string.\\nIn the example 3, \\'.\\\\*\\' covers \\'ab\\' already. Obviously \\'.\\\\*c\\' covers \\'.\\\\*\\', why it doesn\\'t cover \\'ab\\'?\\nIs it a bug or if I misunderstand the question?"
                    },
                    {
                        "username": "HiteshRathi",
                        "content": "I find the above test case invalid. \\n.* with ab  is true as per question disciption. \\nBut .* means 0 or more repeteation of any one of the character.\\nright ?"
                    },
                    {
                        "username": "HasMirror",
                        "content": "s = \"aa\"\\np = \"ab * a * \"\\nresult is true.\\nIs there any one who can help me understand this test case? Why this test case is true? What the meaing of the last \"*\"?"
                    },
                    {
                        "username": "wing1001",
                        "content": "\\'\\'\\'\\nvar isMatch = function(s, p) {\\n   return s.match(p)==s ;     \\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Yassine7295",
                        "content": "Can someone explain why \".*\" matches \"ab\"?\\n\\n. matches one character. in this case, it should match with a. What matches with b?"
                    },
                    {
                        "username": "vaibhavbhosale15",
                        "content": "Whenever I am submitting my code, it first shows Accepted. Moments later it turns to Pending and after a while it becomes Internal Error. I also tried with a previously solved question. Same problem there. Is there some outage going on?"
                    },
                    {
                        "username": "rpd12138",
                        "content": "why (\"ab\" \".*\") is different of (\"ab\", \".*c\"),?"
                    }
                ]
            },
            {
                "id": 1573738,
                "content": [
                    {
                        "username": "teracross",
                        "content": "The questions states that \"\\\\*\" means 0 or more of the preceding element in the pattern, in the case where s = \"aa\" and p=\"c*\", then wouldn\\'t this be a match since \"c*\" could be interpreted as any string with where there were zero occurrences of the element \"c\"??"
                    },
                    {
                        "username": "koogicho",
                        "content": "\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\n\\'.\\' is matched with \\'a\\' but \\'*\\' can\\'t be matched with \\'b\\'.\\nThe expected result of this case is true.\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nDo I think incorrectly?\\n\\n"
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "Let\\'s say: \\ndp[i][j] means length of i of source string match length of j pattern\\n\\nif p.charAt(j - 1) == \\'*\\' && p.charAt(j - 2) == s.charAt(i - 1), and I want to simulate * matches more of preceding element, \\nwhy dp[i][j] = dp[i - 1][j] ?\\n\\nfor example:\\ns: abc.....bc\\np: ......c* \\n\\nI feel like I\\u2019m stuck in a mindset, thx."
                    },
                    {
                        "username": "sd439",
                        "content": "By definition, \\'.\\\\*\\' means any number of \\'.\\', therefore should cover any input string.\\nIn the example 3, \\'.\\\\*\\' covers \\'ab\\' already. Obviously \\'.\\\\*c\\' covers \\'.\\\\*\\', why it doesn\\'t cover \\'ab\\'?\\nIs it a bug or if I misunderstand the question?"
                    },
                    {
                        "username": "HiteshRathi",
                        "content": "I find the above test case invalid. \\n.* with ab  is true as per question disciption. \\nBut .* means 0 or more repeteation of any one of the character.\\nright ?"
                    },
                    {
                        "username": "HasMirror",
                        "content": "s = \"aa\"\\np = \"ab * a * \"\\nresult is true.\\nIs there any one who can help me understand this test case? Why this test case is true? What the meaing of the last \"*\"?"
                    },
                    {
                        "username": "wing1001",
                        "content": "\\'\\'\\'\\nvar isMatch = function(s, p) {\\n   return s.match(p)==s ;     \\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Yassine7295",
                        "content": "Can someone explain why \".*\" matches \"ab\"?\\n\\n. matches one character. in this case, it should match with a. What matches with b?"
                    },
                    {
                        "username": "vaibhavbhosale15",
                        "content": "Whenever I am submitting my code, it first shows Accepted. Moments later it turns to Pending and after a while it becomes Internal Error. I also tried with a previously solved question. Same problem there. Is there some outage going on?"
                    },
                    {
                        "username": "rpd12138",
                        "content": "why (\"ab\" \".*\") is different of (\"ab\", \".*c\"),?"
                    }
                ]
            },
            {
                "id": 1572930,
                "content": [
                    {
                        "username": "teracross",
                        "content": "The questions states that \"\\\\*\" means 0 or more of the preceding element in the pattern, in the case where s = \"aa\" and p=\"c*\", then wouldn\\'t this be a match since \"c*\" could be interpreted as any string with where there were zero occurrences of the element \"c\"??"
                    },
                    {
                        "username": "koogicho",
                        "content": "\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\n\\'.\\' is matched with \\'a\\' but \\'*\\' can\\'t be matched with \\'b\\'.\\nThe expected result of this case is true.\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nDo I think incorrectly?\\n\\n"
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "Let\\'s say: \\ndp[i][j] means length of i of source string match length of j pattern\\n\\nif p.charAt(j - 1) == \\'*\\' && p.charAt(j - 2) == s.charAt(i - 1), and I want to simulate * matches more of preceding element, \\nwhy dp[i][j] = dp[i - 1][j] ?\\n\\nfor example:\\ns: abc.....bc\\np: ......c* \\n\\nI feel like I\\u2019m stuck in a mindset, thx."
                    },
                    {
                        "username": "sd439",
                        "content": "By definition, \\'.\\\\*\\' means any number of \\'.\\', therefore should cover any input string.\\nIn the example 3, \\'.\\\\*\\' covers \\'ab\\' already. Obviously \\'.\\\\*c\\' covers \\'.\\\\*\\', why it doesn\\'t cover \\'ab\\'?\\nIs it a bug or if I misunderstand the question?"
                    },
                    {
                        "username": "HiteshRathi",
                        "content": "I find the above test case invalid. \\n.* with ab  is true as per question disciption. \\nBut .* means 0 or more repeteation of any one of the character.\\nright ?"
                    },
                    {
                        "username": "HasMirror",
                        "content": "s = \"aa\"\\np = \"ab * a * \"\\nresult is true.\\nIs there any one who can help me understand this test case? Why this test case is true? What the meaing of the last \"*\"?"
                    },
                    {
                        "username": "wing1001",
                        "content": "\\'\\'\\'\\nvar isMatch = function(s, p) {\\n   return s.match(p)==s ;     \\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Yassine7295",
                        "content": "Can someone explain why \".*\" matches \"ab\"?\\n\\n. matches one character. in this case, it should match with a. What matches with b?"
                    },
                    {
                        "username": "vaibhavbhosale15",
                        "content": "Whenever I am submitting my code, it first shows Accepted. Moments later it turns to Pending and after a while it becomes Internal Error. I also tried with a previously solved question. Same problem there. Is there some outage going on?"
                    },
                    {
                        "username": "rpd12138",
                        "content": "why (\"ab\" \".*\") is different of (\"ab\", \".*c\"),?"
                    }
                ]
            },
            {
                "id": 1572875,
                "content": [
                    {
                        "username": "teracross",
                        "content": "The questions states that \"\\\\*\" means 0 or more of the preceding element in the pattern, in the case where s = \"aa\" and p=\"c*\", then wouldn\\'t this be a match since \"c*\" could be interpreted as any string with where there were zero occurrences of the element \"c\"??"
                    },
                    {
                        "username": "koogicho",
                        "content": "\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\n\\'.\\' is matched with \\'a\\' but \\'*\\' can\\'t be matched with \\'b\\'.\\nThe expected result of this case is true.\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nDo I think incorrectly?\\n\\n"
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "Let\\'s say: \\ndp[i][j] means length of i of source string match length of j pattern\\n\\nif p.charAt(j - 1) == \\'*\\' && p.charAt(j - 2) == s.charAt(i - 1), and I want to simulate * matches more of preceding element, \\nwhy dp[i][j] = dp[i - 1][j] ?\\n\\nfor example:\\ns: abc.....bc\\np: ......c* \\n\\nI feel like I\\u2019m stuck in a mindset, thx."
                    },
                    {
                        "username": "sd439",
                        "content": "By definition, \\'.\\\\*\\' means any number of \\'.\\', therefore should cover any input string.\\nIn the example 3, \\'.\\\\*\\' covers \\'ab\\' already. Obviously \\'.\\\\*c\\' covers \\'.\\\\*\\', why it doesn\\'t cover \\'ab\\'?\\nIs it a bug or if I misunderstand the question?"
                    },
                    {
                        "username": "HiteshRathi",
                        "content": "I find the above test case invalid. \\n.* with ab  is true as per question disciption. \\nBut .* means 0 or more repeteation of any one of the character.\\nright ?"
                    },
                    {
                        "username": "HasMirror",
                        "content": "s = \"aa\"\\np = \"ab * a * \"\\nresult is true.\\nIs there any one who can help me understand this test case? Why this test case is true? What the meaing of the last \"*\"?"
                    },
                    {
                        "username": "wing1001",
                        "content": "\\'\\'\\'\\nvar isMatch = function(s, p) {\\n   return s.match(p)==s ;     \\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Yassine7295",
                        "content": "Can someone explain why \".*\" matches \"ab\"?\\n\\n. matches one character. in this case, it should match with a. What matches with b?"
                    },
                    {
                        "username": "vaibhavbhosale15",
                        "content": "Whenever I am submitting my code, it first shows Accepted. Moments later it turns to Pending and after a while it becomes Internal Error. I also tried with a previously solved question. Same problem there. Is there some outage going on?"
                    },
                    {
                        "username": "rpd12138",
                        "content": "why (\"ab\" \".*\") is different of (\"ab\", \".*c\"),?"
                    }
                ]
            },
            {
                "id": 1572735,
                "content": [
                    {
                        "username": "teracross",
                        "content": "The questions states that \"\\\\*\" means 0 or more of the preceding element in the pattern, in the case where s = \"aa\" and p=\"c*\", then wouldn\\'t this be a match since \"c*\" could be interpreted as any string with where there were zero occurrences of the element \"c\"??"
                    },
                    {
                        "username": "koogicho",
                        "content": "\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\n\\'.\\' is matched with \\'a\\' but \\'*\\' can\\'t be matched with \\'b\\'.\\nThe expected result of this case is true.\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nDo I think incorrectly?\\n\\n"
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "Let\\'s say: \\ndp[i][j] means length of i of source string match length of j pattern\\n\\nif p.charAt(j - 1) == \\'*\\' && p.charAt(j - 2) == s.charAt(i - 1), and I want to simulate * matches more of preceding element, \\nwhy dp[i][j] = dp[i - 1][j] ?\\n\\nfor example:\\ns: abc.....bc\\np: ......c* \\n\\nI feel like I\\u2019m stuck in a mindset, thx."
                    },
                    {
                        "username": "sd439",
                        "content": "By definition, \\'.\\\\*\\' means any number of \\'.\\', therefore should cover any input string.\\nIn the example 3, \\'.\\\\*\\' covers \\'ab\\' already. Obviously \\'.\\\\*c\\' covers \\'.\\\\*\\', why it doesn\\'t cover \\'ab\\'?\\nIs it a bug or if I misunderstand the question?"
                    },
                    {
                        "username": "HiteshRathi",
                        "content": "I find the above test case invalid. \\n.* with ab  is true as per question disciption. \\nBut .* means 0 or more repeteation of any one of the character.\\nright ?"
                    },
                    {
                        "username": "HasMirror",
                        "content": "s = \"aa\"\\np = \"ab * a * \"\\nresult is true.\\nIs there any one who can help me understand this test case? Why this test case is true? What the meaing of the last \"*\"?"
                    },
                    {
                        "username": "wing1001",
                        "content": "\\'\\'\\'\\nvar isMatch = function(s, p) {\\n   return s.match(p)==s ;     \\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Yassine7295",
                        "content": "Can someone explain why \".*\" matches \"ab\"?\\n\\n. matches one character. in this case, it should match with a. What matches with b?"
                    },
                    {
                        "username": "vaibhavbhosale15",
                        "content": "Whenever I am submitting my code, it first shows Accepted. Moments later it turns to Pending and after a while it becomes Internal Error. I also tried with a previously solved question. Same problem there. Is there some outage going on?"
                    },
                    {
                        "username": "rpd12138",
                        "content": "why (\"ab\" \".*\") is different of (\"ab\", \".*c\"),?"
                    }
                ]
            },
            {
                "id": 1572726,
                "content": [
                    {
                        "username": "teracross",
                        "content": "The questions states that \"\\\\*\" means 0 or more of the preceding element in the pattern, in the case where s = \"aa\" and p=\"c*\", then wouldn\\'t this be a match since \"c*\" could be interpreted as any string with where there were zero occurrences of the element \"c\"??"
                    },
                    {
                        "username": "koogicho",
                        "content": "\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\n\\'.\\' is matched with \\'a\\' but \\'*\\' can\\'t be matched with \\'b\\'.\\nThe expected result of this case is true.\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nDo I think incorrectly?\\n\\n"
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "Let\\'s say: \\ndp[i][j] means length of i of source string match length of j pattern\\n\\nif p.charAt(j - 1) == \\'*\\' && p.charAt(j - 2) == s.charAt(i - 1), and I want to simulate * matches more of preceding element, \\nwhy dp[i][j] = dp[i - 1][j] ?\\n\\nfor example:\\ns: abc.....bc\\np: ......c* \\n\\nI feel like I\\u2019m stuck in a mindset, thx."
                    },
                    {
                        "username": "sd439",
                        "content": "By definition, \\'.\\\\*\\' means any number of \\'.\\', therefore should cover any input string.\\nIn the example 3, \\'.\\\\*\\' covers \\'ab\\' already. Obviously \\'.\\\\*c\\' covers \\'.\\\\*\\', why it doesn\\'t cover \\'ab\\'?\\nIs it a bug or if I misunderstand the question?"
                    },
                    {
                        "username": "HiteshRathi",
                        "content": "I find the above test case invalid. \\n.* with ab  is true as per question disciption. \\nBut .* means 0 or more repeteation of any one of the character.\\nright ?"
                    },
                    {
                        "username": "HasMirror",
                        "content": "s = \"aa\"\\np = \"ab * a * \"\\nresult is true.\\nIs there any one who can help me understand this test case? Why this test case is true? What the meaing of the last \"*\"?"
                    },
                    {
                        "username": "wing1001",
                        "content": "\\'\\'\\'\\nvar isMatch = function(s, p) {\\n   return s.match(p)==s ;     \\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Yassine7295",
                        "content": "Can someone explain why \".*\" matches \"ab\"?\\n\\n. matches one character. in this case, it should match with a. What matches with b?"
                    },
                    {
                        "username": "vaibhavbhosale15",
                        "content": "Whenever I am submitting my code, it first shows Accepted. Moments later it turns to Pending and after a while it becomes Internal Error. I also tried with a previously solved question. Same problem there. Is there some outage going on?"
                    },
                    {
                        "username": "rpd12138",
                        "content": "why (\"ab\" \".*\") is different of (\"ab\", \".*c\"),?"
                    }
                ]
            },
            {
                "id": 1572718,
                "content": [
                    {
                        "username": "teracross",
                        "content": "The questions states that \"\\\\*\" means 0 or more of the preceding element in the pattern, in the case where s = \"aa\" and p=\"c*\", then wouldn\\'t this be a match since \"c*\" could be interpreted as any string with where there were zero occurrences of the element \"c\"??"
                    },
                    {
                        "username": "koogicho",
                        "content": "\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\n\\'.\\' is matched with \\'a\\' but \\'*\\' can\\'t be matched with \\'b\\'.\\nThe expected result of this case is true.\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nDo I think incorrectly?\\n\\n"
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "Let\\'s say: \\ndp[i][j] means length of i of source string match length of j pattern\\n\\nif p.charAt(j - 1) == \\'*\\' && p.charAt(j - 2) == s.charAt(i - 1), and I want to simulate * matches more of preceding element, \\nwhy dp[i][j] = dp[i - 1][j] ?\\n\\nfor example:\\ns: abc.....bc\\np: ......c* \\n\\nI feel like I\\u2019m stuck in a mindset, thx."
                    },
                    {
                        "username": "sd439",
                        "content": "By definition, \\'.\\\\*\\' means any number of \\'.\\', therefore should cover any input string.\\nIn the example 3, \\'.\\\\*\\' covers \\'ab\\' already. Obviously \\'.\\\\*c\\' covers \\'.\\\\*\\', why it doesn\\'t cover \\'ab\\'?\\nIs it a bug or if I misunderstand the question?"
                    },
                    {
                        "username": "HiteshRathi",
                        "content": "I find the above test case invalid. \\n.* with ab  is true as per question disciption. \\nBut .* means 0 or more repeteation of any one of the character.\\nright ?"
                    },
                    {
                        "username": "HasMirror",
                        "content": "s = \"aa\"\\np = \"ab * a * \"\\nresult is true.\\nIs there any one who can help me understand this test case? Why this test case is true? What the meaing of the last \"*\"?"
                    },
                    {
                        "username": "wing1001",
                        "content": "\\'\\'\\'\\nvar isMatch = function(s, p) {\\n   return s.match(p)==s ;     \\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Yassine7295",
                        "content": "Can someone explain why \".*\" matches \"ab\"?\\n\\n. matches one character. in this case, it should match with a. What matches with b?"
                    },
                    {
                        "username": "vaibhavbhosale15",
                        "content": "Whenever I am submitting my code, it first shows Accepted. Moments later it turns to Pending and after a while it becomes Internal Error. I also tried with a previously solved question. Same problem there. Is there some outage going on?"
                    },
                    {
                        "username": "rpd12138",
                        "content": "why (\"ab\" \".*\") is different of (\"ab\", \".*c\"),?"
                    }
                ]
            },
            {
                "id": 1572409,
                "content": [
                    {
                        "username": "teracross",
                        "content": "The questions states that \"\\\\*\" means 0 or more of the preceding element in the pattern, in the case where s = \"aa\" and p=\"c*\", then wouldn\\'t this be a match since \"c*\" could be interpreted as any string with where there were zero occurrences of the element \"c\"??"
                    },
                    {
                        "username": "koogicho",
                        "content": "\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\n\\'.\\' is matched with \\'a\\' but \\'*\\' can\\'t be matched with \\'b\\'.\\nThe expected result of this case is true.\\n\\nInput\\n\"ab\"\\n\".*\"\\nOutput\\nfalse\\nExpected\\ntrue\\n\\nDo I think incorrectly?\\n\\n"
                    },
                    {
                        "username": "AskaNeverEnd",
                        "content": "Let\\'s say: \\ndp[i][j] means length of i of source string match length of j pattern\\n\\nif p.charAt(j - 1) == \\'*\\' && p.charAt(j - 2) == s.charAt(i - 1), and I want to simulate * matches more of preceding element, \\nwhy dp[i][j] = dp[i - 1][j] ?\\n\\nfor example:\\ns: abc.....bc\\np: ......c* \\n\\nI feel like I\\u2019m stuck in a mindset, thx."
                    },
                    {
                        "username": "sd439",
                        "content": "By definition, \\'.\\\\*\\' means any number of \\'.\\', therefore should cover any input string.\\nIn the example 3, \\'.\\\\*\\' covers \\'ab\\' already. Obviously \\'.\\\\*c\\' covers \\'.\\\\*\\', why it doesn\\'t cover \\'ab\\'?\\nIs it a bug or if I misunderstand the question?"
                    },
                    {
                        "username": "HiteshRathi",
                        "content": "I find the above test case invalid. \\n.* with ab  is true as per question disciption. \\nBut .* means 0 or more repeteation of any one of the character.\\nright ?"
                    },
                    {
                        "username": "HasMirror",
                        "content": "s = \"aa\"\\np = \"ab * a * \"\\nresult is true.\\nIs there any one who can help me understand this test case? Why this test case is true? What the meaing of the last \"*\"?"
                    },
                    {
                        "username": "wing1001",
                        "content": "\\'\\'\\'\\nvar isMatch = function(s, p) {\\n   return s.match(p)==s ;     \\n};\\n\\'\\'\\'\\n"
                    },
                    {
                        "username": "Yassine7295",
                        "content": "Can someone explain why \".*\" matches \"ab\"?\\n\\n. matches one character. in this case, it should match with a. What matches with b?"
                    },
                    {
                        "username": "vaibhavbhosale15",
                        "content": "Whenever I am submitting my code, it first shows Accepted. Moments later it turns to Pending and after a while it becomes Internal Error. I also tried with a previously solved question. Same problem there. Is there some outage going on?"
                    },
                    {
                        "username": "rpd12138",
                        "content": "why (\"ab\" \".*\") is different of (\"ab\", \".*c\"),?"
                    }
                ]
            },
            {
                "id": 1572355,
                "content": [
                    {
                        "username": "ohmahjump",
                        "content": "why \"abcdede\" \"ab.*de\" is true?"
                    },
                    {
                        "username": "sheepzh",
                        "content": "HELP\\uFF01\\uFF01\\uFF01\\nAND MAY I USE DFA TO SOLVE IT?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "I think it should be true. But OJ thinks it\\'s false ? Why should that be false?"
                    },
                    {
                        "username": "JYang1887",
                        "content": "Should pattern \"*\" accept the empty string?"
                    },
                    {
                        "username": "ajhaveri",
                        "content": "Input: \"ab\"\\n\".*c\"\\nOutput: true\\nExpected: false <----This is suppose to be true as dot \".\" is repeated with the asterick \"\" following it. Which means first two values can be any value and it matches the source string."
                    },
                    {
                        "username": "springcat",
                        "content": "it says\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\nbut when i submit my code, the test case says\\n\\nInput:\\n\"ab\"\\n\".*c\"\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "gyb527935945",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573425.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573429.png)\\nWhy for the first one is true but the second is false?\\nIs p is the pattern, should p matches part of s be the true result? But why then \"aab\" matches \"c*a*b\"?"
                    },
                    {
                        "username": "guptanik",
                        "content": "Why is the result of matching \"ab\" with \".*\" true? It should be false.\\n'.' matches with any character so it takes value of 'a' and * allows previous value 0 or more times so it can replicate previous value of 'a' but can't give 'b' which is needed. This was my understanding. Please do let me know if i have some mistaken something."
                    },
                    {
                        "username": "mobucur",
                        "content": "In the evaluator, isMatch(\"ab\", \".\\\\*c\") is false while isMatch(\"ab\", \".*\") is expected to be true. Is it me or that's just plain wrong?"
                    },
                    {
                        "username": "LordLeet",
                        "content": "Following discussion applies to this problem\\nhttps://leetcode.com/problems/regular-expression-matching/description/\\n\\nGiven the following constraints:\\n'.' Matches any single character.\\n'\\\\*' Matches zero or more of the **preceding** element.\\n\\nThis test case does not make sense:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 true\\n\\n'\\\\*' should match zero or more of **preceding** characters, in this case '.' matches 'a' so the expression in effect becomes \"a\\\\*\" which must not match input string \"ab\".\\n\\nThis test case needs to be amended to following:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 false"
                    }
                ]
            },
            {
                "id": 1572343,
                "content": [
                    {
                        "username": "ohmahjump",
                        "content": "why \"abcdede\" \"ab.*de\" is true?"
                    },
                    {
                        "username": "sheepzh",
                        "content": "HELP\\uFF01\\uFF01\\uFF01\\nAND MAY I USE DFA TO SOLVE IT?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "I think it should be true. But OJ thinks it\\'s false ? Why should that be false?"
                    },
                    {
                        "username": "JYang1887",
                        "content": "Should pattern \"*\" accept the empty string?"
                    },
                    {
                        "username": "ajhaveri",
                        "content": "Input: \"ab\"\\n\".*c\"\\nOutput: true\\nExpected: false <----This is suppose to be true as dot \".\" is repeated with the asterick \"\" following it. Which means first two values can be any value and it matches the source string."
                    },
                    {
                        "username": "springcat",
                        "content": "it says\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\nbut when i submit my code, the test case says\\n\\nInput:\\n\"ab\"\\n\".*c\"\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "gyb527935945",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573425.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573429.png)\\nWhy for the first one is true but the second is false?\\nIs p is the pattern, should p matches part of s be the true result? But why then \"aab\" matches \"c*a*b\"?"
                    },
                    {
                        "username": "guptanik",
                        "content": "Why is the result of matching \"ab\" with \".*\" true? It should be false.\\n'.' matches with any character so it takes value of 'a' and * allows previous value 0 or more times so it can replicate previous value of 'a' but can't give 'b' which is needed. This was my understanding. Please do let me know if i have some mistaken something."
                    },
                    {
                        "username": "mobucur",
                        "content": "In the evaluator, isMatch(\"ab\", \".\\\\*c\") is false while isMatch(\"ab\", \".*\") is expected to be true. Is it me or that's just plain wrong?"
                    },
                    {
                        "username": "LordLeet",
                        "content": "Following discussion applies to this problem\\nhttps://leetcode.com/problems/regular-expression-matching/description/\\n\\nGiven the following constraints:\\n'.' Matches any single character.\\n'\\\\*' Matches zero or more of the **preceding** element.\\n\\nThis test case does not make sense:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 true\\n\\n'\\\\*' should match zero or more of **preceding** characters, in this case '.' matches 'a' so the expression in effect becomes \"a\\\\*\" which must not match input string \"ab\".\\n\\nThis test case needs to be amended to following:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 false"
                    }
                ]
            },
            {
                "id": 1572206,
                "content": [
                    {
                        "username": "ohmahjump",
                        "content": "why \"abcdede\" \"ab.*de\" is true?"
                    },
                    {
                        "username": "sheepzh",
                        "content": "HELP\\uFF01\\uFF01\\uFF01\\nAND MAY I USE DFA TO SOLVE IT?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "I think it should be true. But OJ thinks it\\'s false ? Why should that be false?"
                    },
                    {
                        "username": "JYang1887",
                        "content": "Should pattern \"*\" accept the empty string?"
                    },
                    {
                        "username": "ajhaveri",
                        "content": "Input: \"ab\"\\n\".*c\"\\nOutput: true\\nExpected: false <----This is suppose to be true as dot \".\" is repeated with the asterick \"\" following it. Which means first two values can be any value and it matches the source string."
                    },
                    {
                        "username": "springcat",
                        "content": "it says\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\nbut when i submit my code, the test case says\\n\\nInput:\\n\"ab\"\\n\".*c\"\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "gyb527935945",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573425.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573429.png)\\nWhy for the first one is true but the second is false?\\nIs p is the pattern, should p matches part of s be the true result? But why then \"aab\" matches \"c*a*b\"?"
                    },
                    {
                        "username": "guptanik",
                        "content": "Why is the result of matching \"ab\" with \".*\" true? It should be false.\\n'.' matches with any character so it takes value of 'a' and * allows previous value 0 or more times so it can replicate previous value of 'a' but can't give 'b' which is needed. This was my understanding. Please do let me know if i have some mistaken something."
                    },
                    {
                        "username": "mobucur",
                        "content": "In the evaluator, isMatch(\"ab\", \".\\\\*c\") is false while isMatch(\"ab\", \".*\") is expected to be true. Is it me or that's just plain wrong?"
                    },
                    {
                        "username": "LordLeet",
                        "content": "Following discussion applies to this problem\\nhttps://leetcode.com/problems/regular-expression-matching/description/\\n\\nGiven the following constraints:\\n'.' Matches any single character.\\n'\\\\*' Matches zero or more of the **preceding** element.\\n\\nThis test case does not make sense:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 true\\n\\n'\\\\*' should match zero or more of **preceding** characters, in this case '.' matches 'a' so the expression in effect becomes \"a\\\\*\" which must not match input string \"ab\".\\n\\nThis test case needs to be amended to following:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 false"
                    }
                ]
            },
            {
                "id": 1572112,
                "content": [
                    {
                        "username": "ohmahjump",
                        "content": "why \"abcdede\" \"ab.*de\" is true?"
                    },
                    {
                        "username": "sheepzh",
                        "content": "HELP\\uFF01\\uFF01\\uFF01\\nAND MAY I USE DFA TO SOLVE IT?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "I think it should be true. But OJ thinks it\\'s false ? Why should that be false?"
                    },
                    {
                        "username": "JYang1887",
                        "content": "Should pattern \"*\" accept the empty string?"
                    },
                    {
                        "username": "ajhaveri",
                        "content": "Input: \"ab\"\\n\".*c\"\\nOutput: true\\nExpected: false <----This is suppose to be true as dot \".\" is repeated with the asterick \"\" following it. Which means first two values can be any value and it matches the source string."
                    },
                    {
                        "username": "springcat",
                        "content": "it says\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\nbut when i submit my code, the test case says\\n\\nInput:\\n\"ab\"\\n\".*c\"\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "gyb527935945",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573425.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573429.png)\\nWhy for the first one is true but the second is false?\\nIs p is the pattern, should p matches part of s be the true result? But why then \"aab\" matches \"c*a*b\"?"
                    },
                    {
                        "username": "guptanik",
                        "content": "Why is the result of matching \"ab\" with \".*\" true? It should be false.\\n'.' matches with any character so it takes value of 'a' and * allows previous value 0 or more times so it can replicate previous value of 'a' but can't give 'b' which is needed. This was my understanding. Please do let me know if i have some mistaken something."
                    },
                    {
                        "username": "mobucur",
                        "content": "In the evaluator, isMatch(\"ab\", \".\\\\*c\") is false while isMatch(\"ab\", \".*\") is expected to be true. Is it me or that's just plain wrong?"
                    },
                    {
                        "username": "LordLeet",
                        "content": "Following discussion applies to this problem\\nhttps://leetcode.com/problems/regular-expression-matching/description/\\n\\nGiven the following constraints:\\n'.' Matches any single character.\\n'\\\\*' Matches zero or more of the **preceding** element.\\n\\nThis test case does not make sense:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 true\\n\\n'\\\\*' should match zero or more of **preceding** characters, in this case '.' matches 'a' so the expression in effect becomes \"a\\\\*\" which must not match input string \"ab\".\\n\\nThis test case needs to be amended to following:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 false"
                    }
                ]
            },
            {
                "id": 1572069,
                "content": [
                    {
                        "username": "ohmahjump",
                        "content": "why \"abcdede\" \"ab.*de\" is true?"
                    },
                    {
                        "username": "sheepzh",
                        "content": "HELP\\uFF01\\uFF01\\uFF01\\nAND MAY I USE DFA TO SOLVE IT?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "I think it should be true. But OJ thinks it\\'s false ? Why should that be false?"
                    },
                    {
                        "username": "JYang1887",
                        "content": "Should pattern \"*\" accept the empty string?"
                    },
                    {
                        "username": "ajhaveri",
                        "content": "Input: \"ab\"\\n\".*c\"\\nOutput: true\\nExpected: false <----This is suppose to be true as dot \".\" is repeated with the asterick \"\" following it. Which means first two values can be any value and it matches the source string."
                    },
                    {
                        "username": "springcat",
                        "content": "it says\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\nbut when i submit my code, the test case says\\n\\nInput:\\n\"ab\"\\n\".*c\"\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "gyb527935945",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573425.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573429.png)\\nWhy for the first one is true but the second is false?\\nIs p is the pattern, should p matches part of s be the true result? But why then \"aab\" matches \"c*a*b\"?"
                    },
                    {
                        "username": "guptanik",
                        "content": "Why is the result of matching \"ab\" with \".*\" true? It should be false.\\n'.' matches with any character so it takes value of 'a' and * allows previous value 0 or more times so it can replicate previous value of 'a' but can't give 'b' which is needed. This was my understanding. Please do let me know if i have some mistaken something."
                    },
                    {
                        "username": "mobucur",
                        "content": "In the evaluator, isMatch(\"ab\", \".\\\\*c\") is false while isMatch(\"ab\", \".*\") is expected to be true. Is it me or that's just plain wrong?"
                    },
                    {
                        "username": "LordLeet",
                        "content": "Following discussion applies to this problem\\nhttps://leetcode.com/problems/regular-expression-matching/description/\\n\\nGiven the following constraints:\\n'.' Matches any single character.\\n'\\\\*' Matches zero or more of the **preceding** element.\\n\\nThis test case does not make sense:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 true\\n\\n'\\\\*' should match zero or more of **preceding** characters, in this case '.' matches 'a' so the expression in effect becomes \"a\\\\*\" which must not match input string \"ab\".\\n\\nThis test case needs to be amended to following:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 false"
                    }
                ]
            },
            {
                "id": 1572066,
                "content": [
                    {
                        "username": "ohmahjump",
                        "content": "why \"abcdede\" \"ab.*de\" is true?"
                    },
                    {
                        "username": "sheepzh",
                        "content": "HELP\\uFF01\\uFF01\\uFF01\\nAND MAY I USE DFA TO SOLVE IT?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "I think it should be true. But OJ thinks it\\'s false ? Why should that be false?"
                    },
                    {
                        "username": "JYang1887",
                        "content": "Should pattern \"*\" accept the empty string?"
                    },
                    {
                        "username": "ajhaveri",
                        "content": "Input: \"ab\"\\n\".*c\"\\nOutput: true\\nExpected: false <----This is suppose to be true as dot \".\" is repeated with the asterick \"\" following it. Which means first two values can be any value and it matches the source string."
                    },
                    {
                        "username": "springcat",
                        "content": "it says\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\nbut when i submit my code, the test case says\\n\\nInput:\\n\"ab\"\\n\".*c\"\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "gyb527935945",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573425.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573429.png)\\nWhy for the first one is true but the second is false?\\nIs p is the pattern, should p matches part of s be the true result? But why then \"aab\" matches \"c*a*b\"?"
                    },
                    {
                        "username": "guptanik",
                        "content": "Why is the result of matching \"ab\" with \".*\" true? It should be false.\\n'.' matches with any character so it takes value of 'a' and * allows previous value 0 or more times so it can replicate previous value of 'a' but can't give 'b' which is needed. This was my understanding. Please do let me know if i have some mistaken something."
                    },
                    {
                        "username": "mobucur",
                        "content": "In the evaluator, isMatch(\"ab\", \".\\\\*c\") is false while isMatch(\"ab\", \".*\") is expected to be true. Is it me or that's just plain wrong?"
                    },
                    {
                        "username": "LordLeet",
                        "content": "Following discussion applies to this problem\\nhttps://leetcode.com/problems/regular-expression-matching/description/\\n\\nGiven the following constraints:\\n'.' Matches any single character.\\n'\\\\*' Matches zero or more of the **preceding** element.\\n\\nThis test case does not make sense:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 true\\n\\n'\\\\*' should match zero or more of **preceding** characters, in this case '.' matches 'a' so the expression in effect becomes \"a\\\\*\" which must not match input string \"ab\".\\n\\nThis test case needs to be amended to following:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 false"
                    }
                ]
            },
            {
                "id": 1571996,
                "content": [
                    {
                        "username": "ohmahjump",
                        "content": "why \"abcdede\" \"ab.*de\" is true?"
                    },
                    {
                        "username": "sheepzh",
                        "content": "HELP\\uFF01\\uFF01\\uFF01\\nAND MAY I USE DFA TO SOLVE IT?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "I think it should be true. But OJ thinks it\\'s false ? Why should that be false?"
                    },
                    {
                        "username": "JYang1887",
                        "content": "Should pattern \"*\" accept the empty string?"
                    },
                    {
                        "username": "ajhaveri",
                        "content": "Input: \"ab\"\\n\".*c\"\\nOutput: true\\nExpected: false <----This is suppose to be true as dot \".\" is repeated with the asterick \"\" following it. Which means first two values can be any value and it matches the source string."
                    },
                    {
                        "username": "springcat",
                        "content": "it says\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\nbut when i submit my code, the test case says\\n\\nInput:\\n\"ab\"\\n\".*c\"\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "gyb527935945",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573425.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573429.png)\\nWhy for the first one is true but the second is false?\\nIs p is the pattern, should p matches part of s be the true result? But why then \"aab\" matches \"c*a*b\"?"
                    },
                    {
                        "username": "guptanik",
                        "content": "Why is the result of matching \"ab\" with \".*\" true? It should be false.\\n'.' matches with any character so it takes value of 'a' and * allows previous value 0 or more times so it can replicate previous value of 'a' but can't give 'b' which is needed. This was my understanding. Please do let me know if i have some mistaken something."
                    },
                    {
                        "username": "mobucur",
                        "content": "In the evaluator, isMatch(\"ab\", \".\\\\*c\") is false while isMatch(\"ab\", \".*\") is expected to be true. Is it me or that's just plain wrong?"
                    },
                    {
                        "username": "LordLeet",
                        "content": "Following discussion applies to this problem\\nhttps://leetcode.com/problems/regular-expression-matching/description/\\n\\nGiven the following constraints:\\n'.' Matches any single character.\\n'\\\\*' Matches zero or more of the **preceding** element.\\n\\nThis test case does not make sense:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 true\\n\\n'\\\\*' should match zero or more of **preceding** characters, in this case '.' matches 'a' so the expression in effect becomes \"a\\\\*\" which must not match input string \"ab\".\\n\\nThis test case needs to be amended to following:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 false"
                    }
                ]
            },
            {
                "id": 1571016,
                "content": [
                    {
                        "username": "ohmahjump",
                        "content": "why \"abcdede\" \"ab.*de\" is true?"
                    },
                    {
                        "username": "sheepzh",
                        "content": "HELP\\uFF01\\uFF01\\uFF01\\nAND MAY I USE DFA TO SOLVE IT?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "I think it should be true. But OJ thinks it\\'s false ? Why should that be false?"
                    },
                    {
                        "username": "JYang1887",
                        "content": "Should pattern \"*\" accept the empty string?"
                    },
                    {
                        "username": "ajhaveri",
                        "content": "Input: \"ab\"\\n\".*c\"\\nOutput: true\\nExpected: false <----This is suppose to be true as dot \".\" is repeated with the asterick \"\" following it. Which means first two values can be any value and it matches the source string."
                    },
                    {
                        "username": "springcat",
                        "content": "it says\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\nbut when i submit my code, the test case says\\n\\nInput:\\n\"ab\"\\n\".*c\"\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "gyb527935945",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573425.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573429.png)\\nWhy for the first one is true but the second is false?\\nIs p is the pattern, should p matches part of s be the true result? But why then \"aab\" matches \"c*a*b\"?"
                    },
                    {
                        "username": "guptanik",
                        "content": "Why is the result of matching \"ab\" with \".*\" true? It should be false.\\n'.' matches with any character so it takes value of 'a' and * allows previous value 0 or more times so it can replicate previous value of 'a' but can't give 'b' which is needed. This was my understanding. Please do let me know if i have some mistaken something."
                    },
                    {
                        "username": "mobucur",
                        "content": "In the evaluator, isMatch(\"ab\", \".\\\\*c\") is false while isMatch(\"ab\", \".*\") is expected to be true. Is it me or that's just plain wrong?"
                    },
                    {
                        "username": "LordLeet",
                        "content": "Following discussion applies to this problem\\nhttps://leetcode.com/problems/regular-expression-matching/description/\\n\\nGiven the following constraints:\\n'.' Matches any single character.\\n'\\\\*' Matches zero or more of the **preceding** element.\\n\\nThis test case does not make sense:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 true\\n\\n'\\\\*' should match zero or more of **preceding** characters, in this case '.' matches 'a' so the expression in effect becomes \"a\\\\*\" which must not match input string \"ab\".\\n\\nThis test case needs to be amended to following:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 false"
                    }
                ]
            },
            {
                "id": 1571017,
                "content": [
                    {
                        "username": "ohmahjump",
                        "content": "why \"abcdede\" \"ab.*de\" is true?"
                    },
                    {
                        "username": "sheepzh",
                        "content": "HELP\\uFF01\\uFF01\\uFF01\\nAND MAY I USE DFA TO SOLVE IT?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "I think it should be true. But OJ thinks it\\'s false ? Why should that be false?"
                    },
                    {
                        "username": "JYang1887",
                        "content": "Should pattern \"*\" accept the empty string?"
                    },
                    {
                        "username": "ajhaveri",
                        "content": "Input: \"ab\"\\n\".*c\"\\nOutput: true\\nExpected: false <----This is suppose to be true as dot \".\" is repeated with the asterick \"\" following it. Which means first two values can be any value and it matches the source string."
                    },
                    {
                        "username": "springcat",
                        "content": "it says\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\nbut when i submit my code, the test case says\\n\\nInput:\\n\"ab\"\\n\".*c\"\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "gyb527935945",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573425.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573429.png)\\nWhy for the first one is true but the second is false?\\nIs p is the pattern, should p matches part of s be the true result? But why then \"aab\" matches \"c*a*b\"?"
                    },
                    {
                        "username": "guptanik",
                        "content": "Why is the result of matching \"ab\" with \".*\" true? It should be false.\\n'.' matches with any character so it takes value of 'a' and * allows previous value 0 or more times so it can replicate previous value of 'a' but can't give 'b' which is needed. This was my understanding. Please do let me know if i have some mistaken something."
                    },
                    {
                        "username": "mobucur",
                        "content": "In the evaluator, isMatch(\"ab\", \".\\\\*c\") is false while isMatch(\"ab\", \".*\") is expected to be true. Is it me or that's just plain wrong?"
                    },
                    {
                        "username": "LordLeet",
                        "content": "Following discussion applies to this problem\\nhttps://leetcode.com/problems/regular-expression-matching/description/\\n\\nGiven the following constraints:\\n'.' Matches any single character.\\n'\\\\*' Matches zero or more of the **preceding** element.\\n\\nThis test case does not make sense:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 true\\n\\n'\\\\*' should match zero or more of **preceding** characters, in this case '.' matches 'a' so the expression in effect becomes \"a\\\\*\" which must not match input string \"ab\".\\n\\nThis test case needs to be amended to following:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 false"
                    }
                ]
            },
            {
                "id": 1571019,
                "content": [
                    {
                        "username": "ohmahjump",
                        "content": "why \"abcdede\" \"ab.*de\" is true?"
                    },
                    {
                        "username": "sheepzh",
                        "content": "HELP\\uFF01\\uFF01\\uFF01\\nAND MAY I USE DFA TO SOLVE IT?"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "I think it should be true. But OJ thinks it\\'s false ? Why should that be false?"
                    },
                    {
                        "username": "JYang1887",
                        "content": "Should pattern \"*\" accept the empty string?"
                    },
                    {
                        "username": "ajhaveri",
                        "content": "Input: \"ab\"\\n\".*c\"\\nOutput: true\\nExpected: false <----This is suppose to be true as dot \".\" is repeated with the asterick \"\" following it. Which means first two values can be any value and it matches the source string."
                    },
                    {
                        "username": "springcat",
                        "content": "it says\\n\\'.\\' Matches any single character.\\n\\'*\\' Matches zero or more of the preceding element.\\n\\nbut when i submit my code, the test case says\\n\\nInput:\\n\"ab\"\\n\".*c\"\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "gyb527935945",
                        "content": "![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573425.png)\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/gyb527935945/image_1529573429.png)\\nWhy for the first one is true but the second is false?\\nIs p is the pattern, should p matches part of s be the true result? But why then \"aab\" matches \"c*a*b\"?"
                    },
                    {
                        "username": "guptanik",
                        "content": "Why is the result of matching \"ab\" with \".*\" true? It should be false.\\n'.' matches with any character so it takes value of 'a' and * allows previous value 0 or more times so it can replicate previous value of 'a' but can't give 'b' which is needed. This was my understanding. Please do let me know if i have some mistaken something."
                    },
                    {
                        "username": "mobucur",
                        "content": "In the evaluator, isMatch(\"ab\", \".\\\\*c\") is false while isMatch(\"ab\", \".*\") is expected to be true. Is it me or that's just plain wrong?"
                    },
                    {
                        "username": "LordLeet",
                        "content": "Following discussion applies to this problem\\nhttps://leetcode.com/problems/regular-expression-matching/description/\\n\\nGiven the following constraints:\\n'.' Matches any single character.\\n'\\\\*' Matches zero or more of the **preceding** element.\\n\\nThis test case does not make sense:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 true\\n\\n'\\\\*' should match zero or more of **preceding** characters, in this case '.' matches 'a' so the expression in effect becomes \"a\\\\*\" which must not match input string \"ab\".\\n\\nThis test case needs to be amended to following:\\nisMatch(\"ab\", \".\\\\*\") \\u2192 false"
                    }
                ]
            },
            {
                "id": 1571020,
                "content": [
                    {
                        "username": "yuryant",
                        "content": "I thought it would be true, since \".*\"  has already covered \"ab\",  but the answer is false, can someone help me  please?"
                    },
                    {
                        "username": "mockinjay",
                        "content": "I don't really understand why the example here\\nisMatch(\"ab\", \".*\") is true ?\\nas per given definition:\\n'.' -> matches any single character\\n'\\\\*' -> matches 0+ of proceeding character right ?\\nso by definition what I understand is \".\\\\*\" => '.' picks any character and '\\\\*' repeats it's preceeding character 0+ times right ?? \\nso as per my understanding :\\n* isMatch(\"ab\",\".*\") - false\\n\\n* isMatch(\"bbb\",\".*\") - true\\n\\n* isMatch(\"aaaaaaaa\",\".*\") - true\\n\\n* isMatch(\"ccccccc\",\".*\") - true\\n\\nCorrect me if I'm missing anything here ?"
                    },
                    {
                        "username": "Su_23",
                        "content": "why the result of  isMatch(\"ab\",\".*\") is ture,but isMatch(\"ab\",\".*c\") is  false, this result confuesed me. help me ."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "I don't understand why here \"isMatch(\"aab\", \"c * a * b\") \\u2192 true\" ,  could somebody explain why ?"
                    },
                    {
                        "username": "leonard-sxy",
                        "content": "\"a.*cc\"\\n\\n\"abbcc\"\\n\\n\\n'.' be **b**, and then '*' will also be **b** then **abbcc** exactly matches the 2nd line **abbcc**"
                    },
                    {
                        "username": "michellezlxy",
                        "content": "Is \"a**\" or \"a***\" allowed for input?"
                    },
                    {
                        "username": "sazbad",
                        "content": "According to this http://articles.leetcode.com/2011/09/regular-expression-matching.html, isMatch(\\u201caab\\u201d, \\u201cc*a*b\\u201d) \\u2192 true. That makes sense, because C* means 0 or more characters of c. So that should return true but the test code is returning false. Even the question says it's false."
                    },
                    {
                        "username": "jiong2",
                        "content": "How come (\"ab\", \".*\") is a match while (\"ab\", \".*c\") is not?\\nI am confused with the problem description. Thank you for any clarification!"
                    },
                    {
                        "username": "zhukov",
                        "content": "Based on the problem description, \"bbbba\" should be a match for \".*a*a\": repeat \".\" for 4 times to match \"bbbb\", omit \"a*\", and then add \"a\". My solution returns true for this case but the judge reports that it should be false."
                    },
                    {
                        "username": "yomin",
                        "content": "the sample cases are all a regular expression matches a definite string.\\nIs there any cases that two regular expression match? \\nHow to do that?\\nthis reminds me of the course of compilers. In that, it shows that regular expression is a type 3 language, and a regular expression which matches a string can be only one, all other possible expressions can be converted to this minimum expression."
                    }
                ]
            },
            {
                "id": 1571021,
                "content": [
                    {
                        "username": "yuryant",
                        "content": "I thought it would be true, since \".*\"  has already covered \"ab\",  but the answer is false, can someone help me  please?"
                    },
                    {
                        "username": "mockinjay",
                        "content": "I don't really understand why the example here\\nisMatch(\"ab\", \".*\") is true ?\\nas per given definition:\\n'.' -> matches any single character\\n'\\\\*' -> matches 0+ of proceeding character right ?\\nso by definition what I understand is \".\\\\*\" => '.' picks any character and '\\\\*' repeats it's preceeding character 0+ times right ?? \\nso as per my understanding :\\n* isMatch(\"ab\",\".*\") - false\\n\\n* isMatch(\"bbb\",\".*\") - true\\n\\n* isMatch(\"aaaaaaaa\",\".*\") - true\\n\\n* isMatch(\"ccccccc\",\".*\") - true\\n\\nCorrect me if I'm missing anything here ?"
                    },
                    {
                        "username": "Su_23",
                        "content": "why the result of  isMatch(\"ab\",\".*\") is ture,but isMatch(\"ab\",\".*c\") is  false, this result confuesed me. help me ."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "I don't understand why here \"isMatch(\"aab\", \"c * a * b\") \\u2192 true\" ,  could somebody explain why ?"
                    },
                    {
                        "username": "leonard-sxy",
                        "content": "\"a.*cc\"\\n\\n\"abbcc\"\\n\\n\\n'.' be **b**, and then '*' will also be **b** then **abbcc** exactly matches the 2nd line **abbcc**"
                    },
                    {
                        "username": "michellezlxy",
                        "content": "Is \"a**\" or \"a***\" allowed for input?"
                    },
                    {
                        "username": "sazbad",
                        "content": "According to this http://articles.leetcode.com/2011/09/regular-expression-matching.html, isMatch(\\u201caab\\u201d, \\u201cc*a*b\\u201d) \\u2192 true. That makes sense, because C* means 0 or more characters of c. So that should return true but the test code is returning false. Even the question says it's false."
                    },
                    {
                        "username": "jiong2",
                        "content": "How come (\"ab\", \".*\") is a match while (\"ab\", \".*c\") is not?\\nI am confused with the problem description. Thank you for any clarification!"
                    },
                    {
                        "username": "zhukov",
                        "content": "Based on the problem description, \"bbbba\" should be a match for \".*a*a\": repeat \".\" for 4 times to match \"bbbb\", omit \"a*\", and then add \"a\". My solution returns true for this case but the judge reports that it should be false."
                    },
                    {
                        "username": "yomin",
                        "content": "the sample cases are all a regular expression matches a definite string.\\nIs there any cases that two regular expression match? \\nHow to do that?\\nthis reminds me of the course of compilers. In that, it shows that regular expression is a type 3 language, and a regular expression which matches a string can be only one, all other possible expressions can be converted to this minimum expression."
                    }
                ]
            },
            {
                "id": 1571022,
                "content": [
                    {
                        "username": "yuryant",
                        "content": "I thought it would be true, since \".*\"  has already covered \"ab\",  but the answer is false, can someone help me  please?"
                    },
                    {
                        "username": "mockinjay",
                        "content": "I don't really understand why the example here\\nisMatch(\"ab\", \".*\") is true ?\\nas per given definition:\\n'.' -> matches any single character\\n'\\\\*' -> matches 0+ of proceeding character right ?\\nso by definition what I understand is \".\\\\*\" => '.' picks any character and '\\\\*' repeats it's preceeding character 0+ times right ?? \\nso as per my understanding :\\n* isMatch(\"ab\",\".*\") - false\\n\\n* isMatch(\"bbb\",\".*\") - true\\n\\n* isMatch(\"aaaaaaaa\",\".*\") - true\\n\\n* isMatch(\"ccccccc\",\".*\") - true\\n\\nCorrect me if I'm missing anything here ?"
                    },
                    {
                        "username": "Su_23",
                        "content": "why the result of  isMatch(\"ab\",\".*\") is ture,but isMatch(\"ab\",\".*c\") is  false, this result confuesed me. help me ."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "I don't understand why here \"isMatch(\"aab\", \"c * a * b\") \\u2192 true\" ,  could somebody explain why ?"
                    },
                    {
                        "username": "leonard-sxy",
                        "content": "\"a.*cc\"\\n\\n\"abbcc\"\\n\\n\\n'.' be **b**, and then '*' will also be **b** then **abbcc** exactly matches the 2nd line **abbcc**"
                    },
                    {
                        "username": "michellezlxy",
                        "content": "Is \"a**\" or \"a***\" allowed for input?"
                    },
                    {
                        "username": "sazbad",
                        "content": "According to this http://articles.leetcode.com/2011/09/regular-expression-matching.html, isMatch(\\u201caab\\u201d, \\u201cc*a*b\\u201d) \\u2192 true. That makes sense, because C* means 0 or more characters of c. So that should return true but the test code is returning false. Even the question says it's false."
                    },
                    {
                        "username": "jiong2",
                        "content": "How come (\"ab\", \".*\") is a match while (\"ab\", \".*c\") is not?\\nI am confused with the problem description. Thank you for any clarification!"
                    },
                    {
                        "username": "zhukov",
                        "content": "Based on the problem description, \"bbbba\" should be a match for \".*a*a\": repeat \".\" for 4 times to match \"bbbb\", omit \"a*\", and then add \"a\". My solution returns true for this case but the judge reports that it should be false."
                    },
                    {
                        "username": "yomin",
                        "content": "the sample cases are all a regular expression matches a definite string.\\nIs there any cases that two regular expression match? \\nHow to do that?\\nthis reminds me of the course of compilers. In that, it shows that regular expression is a type 3 language, and a regular expression which matches a string can be only one, all other possible expressions can be converted to this minimum expression."
                    }
                ]
            },
            {
                "id": 1571024,
                "content": [
                    {
                        "username": "yuryant",
                        "content": "I thought it would be true, since \".*\"  has already covered \"ab\",  but the answer is false, can someone help me  please?"
                    },
                    {
                        "username": "mockinjay",
                        "content": "I don't really understand why the example here\\nisMatch(\"ab\", \".*\") is true ?\\nas per given definition:\\n'.' -> matches any single character\\n'\\\\*' -> matches 0+ of proceeding character right ?\\nso by definition what I understand is \".\\\\*\" => '.' picks any character and '\\\\*' repeats it's preceeding character 0+ times right ?? \\nso as per my understanding :\\n* isMatch(\"ab\",\".*\") - false\\n\\n* isMatch(\"bbb\",\".*\") - true\\n\\n* isMatch(\"aaaaaaaa\",\".*\") - true\\n\\n* isMatch(\"ccccccc\",\".*\") - true\\n\\nCorrect me if I'm missing anything here ?"
                    },
                    {
                        "username": "Su_23",
                        "content": "why the result of  isMatch(\"ab\",\".*\") is ture,but isMatch(\"ab\",\".*c\") is  false, this result confuesed me. help me ."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "I don't understand why here \"isMatch(\"aab\", \"c * a * b\") \\u2192 true\" ,  could somebody explain why ?"
                    },
                    {
                        "username": "leonard-sxy",
                        "content": "\"a.*cc\"\\n\\n\"abbcc\"\\n\\n\\n'.' be **b**, and then '*' will also be **b** then **abbcc** exactly matches the 2nd line **abbcc**"
                    },
                    {
                        "username": "michellezlxy",
                        "content": "Is \"a**\" or \"a***\" allowed for input?"
                    },
                    {
                        "username": "sazbad",
                        "content": "According to this http://articles.leetcode.com/2011/09/regular-expression-matching.html, isMatch(\\u201caab\\u201d, \\u201cc*a*b\\u201d) \\u2192 true. That makes sense, because C* means 0 or more characters of c. So that should return true but the test code is returning false. Even the question says it's false."
                    },
                    {
                        "username": "jiong2",
                        "content": "How come (\"ab\", \".*\") is a match while (\"ab\", \".*c\") is not?\\nI am confused with the problem description. Thank you for any clarification!"
                    },
                    {
                        "username": "zhukov",
                        "content": "Based on the problem description, \"bbbba\" should be a match for \".*a*a\": repeat \".\" for 4 times to match \"bbbb\", omit \"a*\", and then add \"a\". My solution returns true for this case but the judge reports that it should be false."
                    },
                    {
                        "username": "yomin",
                        "content": "the sample cases are all a regular expression matches a definite string.\\nIs there any cases that two regular expression match? \\nHow to do that?\\nthis reminds me of the course of compilers. In that, it shows that regular expression is a type 3 language, and a regular expression which matches a string can be only one, all other possible expressions can be converted to this minimum expression."
                    }
                ]
            },
            {
                "id": 1571025,
                "content": [
                    {
                        "username": "yuryant",
                        "content": "I thought it would be true, since \".*\"  has already covered \"ab\",  but the answer is false, can someone help me  please?"
                    },
                    {
                        "username": "mockinjay",
                        "content": "I don't really understand why the example here\\nisMatch(\"ab\", \".*\") is true ?\\nas per given definition:\\n'.' -> matches any single character\\n'\\\\*' -> matches 0+ of proceeding character right ?\\nso by definition what I understand is \".\\\\*\" => '.' picks any character and '\\\\*' repeats it's preceeding character 0+ times right ?? \\nso as per my understanding :\\n* isMatch(\"ab\",\".*\") - false\\n\\n* isMatch(\"bbb\",\".*\") - true\\n\\n* isMatch(\"aaaaaaaa\",\".*\") - true\\n\\n* isMatch(\"ccccccc\",\".*\") - true\\n\\nCorrect me if I'm missing anything here ?"
                    },
                    {
                        "username": "Su_23",
                        "content": "why the result of  isMatch(\"ab\",\".*\") is ture,but isMatch(\"ab\",\".*c\") is  false, this result confuesed me. help me ."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "I don't understand why here \"isMatch(\"aab\", \"c * a * b\") \\u2192 true\" ,  could somebody explain why ?"
                    },
                    {
                        "username": "leonard-sxy",
                        "content": "\"a.*cc\"\\n\\n\"abbcc\"\\n\\n\\n'.' be **b**, and then '*' will also be **b** then **abbcc** exactly matches the 2nd line **abbcc**"
                    },
                    {
                        "username": "michellezlxy",
                        "content": "Is \"a**\" or \"a***\" allowed for input?"
                    },
                    {
                        "username": "sazbad",
                        "content": "According to this http://articles.leetcode.com/2011/09/regular-expression-matching.html, isMatch(\\u201caab\\u201d, \\u201cc*a*b\\u201d) \\u2192 true. That makes sense, because C* means 0 or more characters of c. So that should return true but the test code is returning false. Even the question says it's false."
                    },
                    {
                        "username": "jiong2",
                        "content": "How come (\"ab\", \".*\") is a match while (\"ab\", \".*c\") is not?\\nI am confused with the problem description. Thank you for any clarification!"
                    },
                    {
                        "username": "zhukov",
                        "content": "Based on the problem description, \"bbbba\" should be a match for \".*a*a\": repeat \".\" for 4 times to match \"bbbb\", omit \"a*\", and then add \"a\". My solution returns true for this case but the judge reports that it should be false."
                    },
                    {
                        "username": "yomin",
                        "content": "the sample cases are all a regular expression matches a definite string.\\nIs there any cases that two regular expression match? \\nHow to do that?\\nthis reminds me of the course of compilers. In that, it shows that regular expression is a type 3 language, and a regular expression which matches a string can be only one, all other possible expressions can be converted to this minimum expression."
                    }
                ]
            },
            {
                "id": 1571027,
                "content": [
                    {
                        "username": "yuryant",
                        "content": "I thought it would be true, since \".*\"  has already covered \"ab\",  but the answer is false, can someone help me  please?"
                    },
                    {
                        "username": "mockinjay",
                        "content": "I don't really understand why the example here\\nisMatch(\"ab\", \".*\") is true ?\\nas per given definition:\\n'.' -> matches any single character\\n'\\\\*' -> matches 0+ of proceeding character right ?\\nso by definition what I understand is \".\\\\*\" => '.' picks any character and '\\\\*' repeats it's preceeding character 0+ times right ?? \\nso as per my understanding :\\n* isMatch(\"ab\",\".*\") - false\\n\\n* isMatch(\"bbb\",\".*\") - true\\n\\n* isMatch(\"aaaaaaaa\",\".*\") - true\\n\\n* isMatch(\"ccccccc\",\".*\") - true\\n\\nCorrect me if I'm missing anything here ?"
                    },
                    {
                        "username": "Su_23",
                        "content": "why the result of  isMatch(\"ab\",\".*\") is ture,but isMatch(\"ab\",\".*c\") is  false, this result confuesed me. help me ."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "I don't understand why here \"isMatch(\"aab\", \"c * a * b\") \\u2192 true\" ,  could somebody explain why ?"
                    },
                    {
                        "username": "leonard-sxy",
                        "content": "\"a.*cc\"\\n\\n\"abbcc\"\\n\\n\\n'.' be **b**, and then '*' will also be **b** then **abbcc** exactly matches the 2nd line **abbcc**"
                    },
                    {
                        "username": "michellezlxy",
                        "content": "Is \"a**\" or \"a***\" allowed for input?"
                    },
                    {
                        "username": "sazbad",
                        "content": "According to this http://articles.leetcode.com/2011/09/regular-expression-matching.html, isMatch(\\u201caab\\u201d, \\u201cc*a*b\\u201d) \\u2192 true. That makes sense, because C* means 0 or more characters of c. So that should return true but the test code is returning false. Even the question says it's false."
                    },
                    {
                        "username": "jiong2",
                        "content": "How come (\"ab\", \".*\") is a match while (\"ab\", \".*c\") is not?\\nI am confused with the problem description. Thank you for any clarification!"
                    },
                    {
                        "username": "zhukov",
                        "content": "Based on the problem description, \"bbbba\" should be a match for \".*a*a\": repeat \".\" for 4 times to match \"bbbb\", omit \"a*\", and then add \"a\". My solution returns true for this case but the judge reports that it should be false."
                    },
                    {
                        "username": "yomin",
                        "content": "the sample cases are all a regular expression matches a definite string.\\nIs there any cases that two regular expression match? \\nHow to do that?\\nthis reminds me of the course of compilers. In that, it shows that regular expression is a type 3 language, and a regular expression which matches a string can be only one, all other possible expressions can be converted to this minimum expression."
                    }
                ]
            },
            {
                "id": 1571028,
                "content": [
                    {
                        "username": "yuryant",
                        "content": "I thought it would be true, since \".*\"  has already covered \"ab\",  but the answer is false, can someone help me  please?"
                    },
                    {
                        "username": "mockinjay",
                        "content": "I don't really understand why the example here\\nisMatch(\"ab\", \".*\") is true ?\\nas per given definition:\\n'.' -> matches any single character\\n'\\\\*' -> matches 0+ of proceeding character right ?\\nso by definition what I understand is \".\\\\*\" => '.' picks any character and '\\\\*' repeats it's preceeding character 0+ times right ?? \\nso as per my understanding :\\n* isMatch(\"ab\",\".*\") - false\\n\\n* isMatch(\"bbb\",\".*\") - true\\n\\n* isMatch(\"aaaaaaaa\",\".*\") - true\\n\\n* isMatch(\"ccccccc\",\".*\") - true\\n\\nCorrect me if I'm missing anything here ?"
                    },
                    {
                        "username": "Su_23",
                        "content": "why the result of  isMatch(\"ab\",\".*\") is ture,but isMatch(\"ab\",\".*c\") is  false, this result confuesed me. help me ."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "I don't understand why here \"isMatch(\"aab\", \"c * a * b\") \\u2192 true\" ,  could somebody explain why ?"
                    },
                    {
                        "username": "leonard-sxy",
                        "content": "\"a.*cc\"\\n\\n\"abbcc\"\\n\\n\\n'.' be **b**, and then '*' will also be **b** then **abbcc** exactly matches the 2nd line **abbcc**"
                    },
                    {
                        "username": "michellezlxy",
                        "content": "Is \"a**\" or \"a***\" allowed for input?"
                    },
                    {
                        "username": "sazbad",
                        "content": "According to this http://articles.leetcode.com/2011/09/regular-expression-matching.html, isMatch(\\u201caab\\u201d, \\u201cc*a*b\\u201d) \\u2192 true. That makes sense, because C* means 0 or more characters of c. So that should return true but the test code is returning false. Even the question says it's false."
                    },
                    {
                        "username": "jiong2",
                        "content": "How come (\"ab\", \".*\") is a match while (\"ab\", \".*c\") is not?\\nI am confused with the problem description. Thank you for any clarification!"
                    },
                    {
                        "username": "zhukov",
                        "content": "Based on the problem description, \"bbbba\" should be a match for \".*a*a\": repeat \".\" for 4 times to match \"bbbb\", omit \"a*\", and then add \"a\". My solution returns true for this case but the judge reports that it should be false."
                    },
                    {
                        "username": "yomin",
                        "content": "the sample cases are all a regular expression matches a definite string.\\nIs there any cases that two regular expression match? \\nHow to do that?\\nthis reminds me of the course of compilers. In that, it shows that regular expression is a type 3 language, and a regular expression which matches a string can be only one, all other possible expressions can be converted to this minimum expression."
                    }
                ]
            },
            {
                "id": 1571029,
                "content": [
                    {
                        "username": "yuryant",
                        "content": "I thought it would be true, since \".*\"  has already covered \"ab\",  but the answer is false, can someone help me  please?"
                    },
                    {
                        "username": "mockinjay",
                        "content": "I don't really understand why the example here\\nisMatch(\"ab\", \".*\") is true ?\\nas per given definition:\\n'.' -> matches any single character\\n'\\\\*' -> matches 0+ of proceeding character right ?\\nso by definition what I understand is \".\\\\*\" => '.' picks any character and '\\\\*' repeats it's preceeding character 0+ times right ?? \\nso as per my understanding :\\n* isMatch(\"ab\",\".*\") - false\\n\\n* isMatch(\"bbb\",\".*\") - true\\n\\n* isMatch(\"aaaaaaaa\",\".*\") - true\\n\\n* isMatch(\"ccccccc\",\".*\") - true\\n\\nCorrect me if I'm missing anything here ?"
                    },
                    {
                        "username": "Su_23",
                        "content": "why the result of  isMatch(\"ab\",\".*\") is ture,but isMatch(\"ab\",\".*c\") is  false, this result confuesed me. help me ."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "I don't understand why here \"isMatch(\"aab\", \"c * a * b\") \\u2192 true\" ,  could somebody explain why ?"
                    },
                    {
                        "username": "leonard-sxy",
                        "content": "\"a.*cc\"\\n\\n\"abbcc\"\\n\\n\\n'.' be **b**, and then '*' will also be **b** then **abbcc** exactly matches the 2nd line **abbcc**"
                    },
                    {
                        "username": "michellezlxy",
                        "content": "Is \"a**\" or \"a***\" allowed for input?"
                    },
                    {
                        "username": "sazbad",
                        "content": "According to this http://articles.leetcode.com/2011/09/regular-expression-matching.html, isMatch(\\u201caab\\u201d, \\u201cc*a*b\\u201d) \\u2192 true. That makes sense, because C* means 0 or more characters of c. So that should return true but the test code is returning false. Even the question says it's false."
                    },
                    {
                        "username": "jiong2",
                        "content": "How come (\"ab\", \".*\") is a match while (\"ab\", \".*c\") is not?\\nI am confused with the problem description. Thank you for any clarification!"
                    },
                    {
                        "username": "zhukov",
                        "content": "Based on the problem description, \"bbbba\" should be a match for \".*a*a\": repeat \".\" for 4 times to match \"bbbb\", omit \"a*\", and then add \"a\". My solution returns true for this case but the judge reports that it should be false."
                    },
                    {
                        "username": "yomin",
                        "content": "the sample cases are all a regular expression matches a definite string.\\nIs there any cases that two regular expression match? \\nHow to do that?\\nthis reminds me of the course of compilers. In that, it shows that regular expression is a type 3 language, and a regular expression which matches a string can be only one, all other possible expressions can be converted to this minimum expression."
                    }
                ]
            },
            {
                "id": 1571030,
                "content": [
                    {
                        "username": "yuryant",
                        "content": "I thought it would be true, since \".*\"  has already covered \"ab\",  but the answer is false, can someone help me  please?"
                    },
                    {
                        "username": "mockinjay",
                        "content": "I don't really understand why the example here\\nisMatch(\"ab\", \".*\") is true ?\\nas per given definition:\\n'.' -> matches any single character\\n'\\\\*' -> matches 0+ of proceeding character right ?\\nso by definition what I understand is \".\\\\*\" => '.' picks any character and '\\\\*' repeats it's preceeding character 0+ times right ?? \\nso as per my understanding :\\n* isMatch(\"ab\",\".*\") - false\\n\\n* isMatch(\"bbb\",\".*\") - true\\n\\n* isMatch(\"aaaaaaaa\",\".*\") - true\\n\\n* isMatch(\"ccccccc\",\".*\") - true\\n\\nCorrect me if I'm missing anything here ?"
                    },
                    {
                        "username": "Su_23",
                        "content": "why the result of  isMatch(\"ab\",\".*\") is ture,but isMatch(\"ab\",\".*c\") is  false, this result confuesed me. help me ."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "I don't understand why here \"isMatch(\"aab\", \"c * a * b\") \\u2192 true\" ,  could somebody explain why ?"
                    },
                    {
                        "username": "leonard-sxy",
                        "content": "\"a.*cc\"\\n\\n\"abbcc\"\\n\\n\\n'.' be **b**, and then '*' will also be **b** then **abbcc** exactly matches the 2nd line **abbcc**"
                    },
                    {
                        "username": "michellezlxy",
                        "content": "Is \"a**\" or \"a***\" allowed for input?"
                    },
                    {
                        "username": "sazbad",
                        "content": "According to this http://articles.leetcode.com/2011/09/regular-expression-matching.html, isMatch(\\u201caab\\u201d, \\u201cc*a*b\\u201d) \\u2192 true. That makes sense, because C* means 0 or more characters of c. So that should return true but the test code is returning false. Even the question says it's false."
                    },
                    {
                        "username": "jiong2",
                        "content": "How come (\"ab\", \".*\") is a match while (\"ab\", \".*c\") is not?\\nI am confused with the problem description. Thank you for any clarification!"
                    },
                    {
                        "username": "zhukov",
                        "content": "Based on the problem description, \"bbbba\" should be a match for \".*a*a\": repeat \".\" for 4 times to match \"bbbb\", omit \"a*\", and then add \"a\". My solution returns true for this case but the judge reports that it should be false."
                    },
                    {
                        "username": "yomin",
                        "content": "the sample cases are all a regular expression matches a definite string.\\nIs there any cases that two regular expression match? \\nHow to do that?\\nthis reminds me of the course of compilers. In that, it shows that regular expression is a type 3 language, and a regular expression which matches a string can be only one, all other possible expressions can be converted to this minimum expression."
                    }
                ]
            },
            {
                "id": 1571031,
                "content": [
                    {
                        "username": "yuryant",
                        "content": "I thought it would be true, since \".*\"  has already covered \"ab\",  but the answer is false, can someone help me  please?"
                    },
                    {
                        "username": "mockinjay",
                        "content": "I don't really understand why the example here\\nisMatch(\"ab\", \".*\") is true ?\\nas per given definition:\\n'.' -> matches any single character\\n'\\\\*' -> matches 0+ of proceeding character right ?\\nso by definition what I understand is \".\\\\*\" => '.' picks any character and '\\\\*' repeats it's preceeding character 0+ times right ?? \\nso as per my understanding :\\n* isMatch(\"ab\",\".*\") - false\\n\\n* isMatch(\"bbb\",\".*\") - true\\n\\n* isMatch(\"aaaaaaaa\",\".*\") - true\\n\\n* isMatch(\"ccccccc\",\".*\") - true\\n\\nCorrect me if I'm missing anything here ?"
                    },
                    {
                        "username": "Su_23",
                        "content": "why the result of  isMatch(\"ab\",\".*\") is ture,but isMatch(\"ab\",\".*c\") is  false, this result confuesed me. help me ."
                    },
                    {
                        "username": "vogelkaka",
                        "content": "I don't understand why here \"isMatch(\"aab\", \"c * a * b\") \\u2192 true\" ,  could somebody explain why ?"
                    },
                    {
                        "username": "leonard-sxy",
                        "content": "\"a.*cc\"\\n\\n\"abbcc\"\\n\\n\\n'.' be **b**, and then '*' will also be **b** then **abbcc** exactly matches the 2nd line **abbcc**"
                    },
                    {
                        "username": "michellezlxy",
                        "content": "Is \"a**\" or \"a***\" allowed for input?"
                    },
                    {
                        "username": "sazbad",
                        "content": "According to this http://articles.leetcode.com/2011/09/regular-expression-matching.html, isMatch(\\u201caab\\u201d, \\u201cc*a*b\\u201d) \\u2192 true. That makes sense, because C* means 0 or more characters of c. So that should return true but the test code is returning false. Even the question says it's false."
                    },
                    {
                        "username": "jiong2",
                        "content": "How come (\"ab\", \".*\") is a match while (\"ab\", \".*c\") is not?\\nI am confused with the problem description. Thank you for any clarification!"
                    },
                    {
                        "username": "zhukov",
                        "content": "Based on the problem description, \"bbbba\" should be a match for \".*a*a\": repeat \".\" for 4 times to match \"bbbb\", omit \"a*\", and then add \"a\". My solution returns true for this case but the judge reports that it should be false."
                    },
                    {
                        "username": "yomin",
                        "content": "the sample cases are all a regular expression matches a definite string.\\nIs there any cases that two regular expression match? \\nHow to do that?\\nthis reminds me of the course of compilers. In that, it shows that regular expression is a type 3 language, and a regular expression which matches a string can be only one, all other possible expressions can be converted to this minimum expression."
                    }
                ]
            },
            {
                "id": 1571032,
                "content": [
                    {
                        "username": "godrays",
                        "content": "I believe (\"ab\", \".*\") -> true should be changed to (\"ab\", \".*b\") -> true. \\n\\nAny ideas why this is not?"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/207f3b69-5e37-403d-954e-78bc0015e0e9_1651123059.4005842.png)\\n![image](https://assets.leetcode.com/users/images/6aaf139b-0869-477e-b7de-b0af6b5e3fac_1651123063.0122378.jpeg)\\n**PLease upvote this post if you get any help from it.**"
                    },
                    {
                        "username": "koyun",
                        "content": "Input: \\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nMy output is correct. Input doesn\\'t start with c so can never match. The test is wrong. Who can fix that?"
                    },
                    {
                        "username": "user3529M",
                        "content": "No explanation is provided on how to treat cases of \"\\\\**\" in pattern.\\nIt makes the question very annoying to complete, because I need to guess how to treat those states and hope that my guess will be correct."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer this awesome explanation and code in C++/Java/Python:\\nhttps://www.techiedelight.com/wildcard-pattern-matching/"
                    },
                    {
                        "username": "himanshukandwal",
                        "content": "How come this test case is true ?\\n\\nas . will get matched to 'a' and then * as the description says, Matches zero or more of the preceding element. In this case that is 'a'(previously matched character), so '*' shouldn't get matched to b at all. \\n\\nisMatch(\"aa\", \".*\") = true, this test case makes the right sense, I believe."
                    },
                    {
                        "username": "laimanyou",
                        "content": "Input:   \"ab\", \".*c\"\\n\\nOutput:    true\\n\\nExpected:  false\\n\\nWhy? I think \".*\" means \"........\"(unlimited number) which can include any string.\\n\\nAnd in the example \\u2014\\u2014isMatch(\"ab\", \".*\") \\u2192 true\\n\\nI was very confused."
                    },
                    {
                        "username": "KoHu",
                        "content": "return s.matches(p) ;"
                    },
                    {
                        "username": "muditsen1234",
                        "content": "Duplicate of  [https://leetcode.com/problems/wildcard-matching/]"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**What is worng with my  solution it is giving heap buffer overflow error!**\\nclass solution{\\n![image](https://assets.leetcode.com/users/images/ea1cd395-b88d-41b3-b804-cc5dcfb979f8_1620375104.7723796.png)\\n"
                    }
                ]
            },
            {
                "id": 1570861,
                "content": [
                    {
                        "username": "godrays",
                        "content": "I believe (\"ab\", \".*\") -> true should be changed to (\"ab\", \".*b\") -> true. \\n\\nAny ideas why this is not?"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/207f3b69-5e37-403d-954e-78bc0015e0e9_1651123059.4005842.png)\\n![image](https://assets.leetcode.com/users/images/6aaf139b-0869-477e-b7de-b0af6b5e3fac_1651123063.0122378.jpeg)\\n**PLease upvote this post if you get any help from it.**"
                    },
                    {
                        "username": "koyun",
                        "content": "Input: \\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nMy output is correct. Input doesn\\'t start with c so can never match. The test is wrong. Who can fix that?"
                    },
                    {
                        "username": "user3529M",
                        "content": "No explanation is provided on how to treat cases of \"\\\\**\" in pattern.\\nIt makes the question very annoying to complete, because I need to guess how to treat those states and hope that my guess will be correct."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer this awesome explanation and code in C++/Java/Python:\\nhttps://www.techiedelight.com/wildcard-pattern-matching/"
                    },
                    {
                        "username": "himanshukandwal",
                        "content": "How come this test case is true ?\\n\\nas . will get matched to 'a' and then * as the description says, Matches zero or more of the preceding element. In this case that is 'a'(previously matched character), so '*' shouldn't get matched to b at all. \\n\\nisMatch(\"aa\", \".*\") = true, this test case makes the right sense, I believe."
                    },
                    {
                        "username": "laimanyou",
                        "content": "Input:   \"ab\", \".*c\"\\n\\nOutput:    true\\n\\nExpected:  false\\n\\nWhy? I think \".*\" means \"........\"(unlimited number) which can include any string.\\n\\nAnd in the example \\u2014\\u2014isMatch(\"ab\", \".*\") \\u2192 true\\n\\nI was very confused."
                    },
                    {
                        "username": "KoHu",
                        "content": "return s.matches(p) ;"
                    },
                    {
                        "username": "muditsen1234",
                        "content": "Duplicate of  [https://leetcode.com/problems/wildcard-matching/]"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**What is worng with my  solution it is giving heap buffer overflow error!**\\nclass solution{\\n![image](https://assets.leetcode.com/users/images/ea1cd395-b88d-41b3-b804-cc5dcfb979f8_1620375104.7723796.png)\\n"
                    }
                ]
            },
            {
                "id": 1570210,
                "content": [
                    {
                        "username": "godrays",
                        "content": "I believe (\"ab\", \".*\") -> true should be changed to (\"ab\", \".*b\") -> true. \\n\\nAny ideas why this is not?"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/207f3b69-5e37-403d-954e-78bc0015e0e9_1651123059.4005842.png)\\n![image](https://assets.leetcode.com/users/images/6aaf139b-0869-477e-b7de-b0af6b5e3fac_1651123063.0122378.jpeg)\\n**PLease upvote this post if you get any help from it.**"
                    },
                    {
                        "username": "koyun",
                        "content": "Input: \\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nMy output is correct. Input doesn\\'t start with c so can never match. The test is wrong. Who can fix that?"
                    },
                    {
                        "username": "user3529M",
                        "content": "No explanation is provided on how to treat cases of \"\\\\**\" in pattern.\\nIt makes the question very annoying to complete, because I need to guess how to treat those states and hope that my guess will be correct."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer this awesome explanation and code in C++/Java/Python:\\nhttps://www.techiedelight.com/wildcard-pattern-matching/"
                    },
                    {
                        "username": "himanshukandwal",
                        "content": "How come this test case is true ?\\n\\nas . will get matched to 'a' and then * as the description says, Matches zero or more of the preceding element. In this case that is 'a'(previously matched character), so '*' shouldn't get matched to b at all. \\n\\nisMatch(\"aa\", \".*\") = true, this test case makes the right sense, I believe."
                    },
                    {
                        "username": "laimanyou",
                        "content": "Input:   \"ab\", \".*c\"\\n\\nOutput:    true\\n\\nExpected:  false\\n\\nWhy? I think \".*\" means \"........\"(unlimited number) which can include any string.\\n\\nAnd in the example \\u2014\\u2014isMatch(\"ab\", \".*\") \\u2192 true\\n\\nI was very confused."
                    },
                    {
                        "username": "KoHu",
                        "content": "return s.matches(p) ;"
                    },
                    {
                        "username": "muditsen1234",
                        "content": "Duplicate of  [https://leetcode.com/problems/wildcard-matching/]"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**What is worng with my  solution it is giving heap buffer overflow error!**\\nclass solution{\\n![image](https://assets.leetcode.com/users/images/ea1cd395-b88d-41b3-b804-cc5dcfb979f8_1620375104.7723796.png)\\n"
                    }
                ]
            },
            {
                "id": 1570202,
                "content": [
                    {
                        "username": "godrays",
                        "content": "I believe (\"ab\", \".*\") -> true should be changed to (\"ab\", \".*b\") -> true. \\n\\nAny ideas why this is not?"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/207f3b69-5e37-403d-954e-78bc0015e0e9_1651123059.4005842.png)\\n![image](https://assets.leetcode.com/users/images/6aaf139b-0869-477e-b7de-b0af6b5e3fac_1651123063.0122378.jpeg)\\n**PLease upvote this post if you get any help from it.**"
                    },
                    {
                        "username": "koyun",
                        "content": "Input: \\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nMy output is correct. Input doesn\\'t start with c so can never match. The test is wrong. Who can fix that?"
                    },
                    {
                        "username": "user3529M",
                        "content": "No explanation is provided on how to treat cases of \"\\\\**\" in pattern.\\nIt makes the question very annoying to complete, because I need to guess how to treat those states and hope that my guess will be correct."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer this awesome explanation and code in C++/Java/Python:\\nhttps://www.techiedelight.com/wildcard-pattern-matching/"
                    },
                    {
                        "username": "himanshukandwal",
                        "content": "How come this test case is true ?\\n\\nas . will get matched to 'a' and then * as the description says, Matches zero or more of the preceding element. In this case that is 'a'(previously matched character), so '*' shouldn't get matched to b at all. \\n\\nisMatch(\"aa\", \".*\") = true, this test case makes the right sense, I believe."
                    },
                    {
                        "username": "laimanyou",
                        "content": "Input:   \"ab\", \".*c\"\\n\\nOutput:    true\\n\\nExpected:  false\\n\\nWhy? I think \".*\" means \"........\"(unlimited number) which can include any string.\\n\\nAnd in the example \\u2014\\u2014isMatch(\"ab\", \".*\") \\u2192 true\\n\\nI was very confused."
                    },
                    {
                        "username": "KoHu",
                        "content": "return s.matches(p) ;"
                    },
                    {
                        "username": "muditsen1234",
                        "content": "Duplicate of  [https://leetcode.com/problems/wildcard-matching/]"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**What is worng with my  solution it is giving heap buffer overflow error!**\\nclass solution{\\n![image](https://assets.leetcode.com/users/images/ea1cd395-b88d-41b3-b804-cc5dcfb979f8_1620375104.7723796.png)\\n"
                    }
                ]
            },
            {
                "id": 1570072,
                "content": [
                    {
                        "username": "godrays",
                        "content": "I believe (\"ab\", \".*\") -> true should be changed to (\"ab\", \".*b\") -> true. \\n\\nAny ideas why this is not?"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/207f3b69-5e37-403d-954e-78bc0015e0e9_1651123059.4005842.png)\\n![image](https://assets.leetcode.com/users/images/6aaf139b-0869-477e-b7de-b0af6b5e3fac_1651123063.0122378.jpeg)\\n**PLease upvote this post if you get any help from it.**"
                    },
                    {
                        "username": "koyun",
                        "content": "Input: \\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nMy output is correct. Input doesn\\'t start with c so can never match. The test is wrong. Who can fix that?"
                    },
                    {
                        "username": "user3529M",
                        "content": "No explanation is provided on how to treat cases of \"\\\\**\" in pattern.\\nIt makes the question very annoying to complete, because I need to guess how to treat those states and hope that my guess will be correct."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer this awesome explanation and code in C++/Java/Python:\\nhttps://www.techiedelight.com/wildcard-pattern-matching/"
                    },
                    {
                        "username": "himanshukandwal",
                        "content": "How come this test case is true ?\\n\\nas . will get matched to 'a' and then * as the description says, Matches zero or more of the preceding element. In this case that is 'a'(previously matched character), so '*' shouldn't get matched to b at all. \\n\\nisMatch(\"aa\", \".*\") = true, this test case makes the right sense, I believe."
                    },
                    {
                        "username": "laimanyou",
                        "content": "Input:   \"ab\", \".*c\"\\n\\nOutput:    true\\n\\nExpected:  false\\n\\nWhy? I think \".*\" means \"........\"(unlimited number) which can include any string.\\n\\nAnd in the example \\u2014\\u2014isMatch(\"ab\", \".*\") \\u2192 true\\n\\nI was very confused."
                    },
                    {
                        "username": "KoHu",
                        "content": "return s.matches(p) ;"
                    },
                    {
                        "username": "muditsen1234",
                        "content": "Duplicate of  [https://leetcode.com/problems/wildcard-matching/]"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**What is worng with my  solution it is giving heap buffer overflow error!**\\nclass solution{\\n![image](https://assets.leetcode.com/users/images/ea1cd395-b88d-41b3-b804-cc5dcfb979f8_1620375104.7723796.png)\\n"
                    }
                ]
            },
            {
                "id": 1568821,
                "content": [
                    {
                        "username": "godrays",
                        "content": "I believe (\"ab\", \".*\") -> true should be changed to (\"ab\", \".*b\") -> true. \\n\\nAny ideas why this is not?"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/207f3b69-5e37-403d-954e-78bc0015e0e9_1651123059.4005842.png)\\n![image](https://assets.leetcode.com/users/images/6aaf139b-0869-477e-b7de-b0af6b5e3fac_1651123063.0122378.jpeg)\\n**PLease upvote this post if you get any help from it.**"
                    },
                    {
                        "username": "koyun",
                        "content": "Input: \\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nMy output is correct. Input doesn\\'t start with c so can never match. The test is wrong. Who can fix that?"
                    },
                    {
                        "username": "user3529M",
                        "content": "No explanation is provided on how to treat cases of \"\\\\**\" in pattern.\\nIt makes the question very annoying to complete, because I need to guess how to treat those states and hope that my guess will be correct."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer this awesome explanation and code in C++/Java/Python:\\nhttps://www.techiedelight.com/wildcard-pattern-matching/"
                    },
                    {
                        "username": "himanshukandwal",
                        "content": "How come this test case is true ?\\n\\nas . will get matched to 'a' and then * as the description says, Matches zero or more of the preceding element. In this case that is 'a'(previously matched character), so '*' shouldn't get matched to b at all. \\n\\nisMatch(\"aa\", \".*\") = true, this test case makes the right sense, I believe."
                    },
                    {
                        "username": "laimanyou",
                        "content": "Input:   \"ab\", \".*c\"\\n\\nOutput:    true\\n\\nExpected:  false\\n\\nWhy? I think \".*\" means \"........\"(unlimited number) which can include any string.\\n\\nAnd in the example \\u2014\\u2014isMatch(\"ab\", \".*\") \\u2192 true\\n\\nI was very confused."
                    },
                    {
                        "username": "KoHu",
                        "content": "return s.matches(p) ;"
                    },
                    {
                        "username": "muditsen1234",
                        "content": "Duplicate of  [https://leetcode.com/problems/wildcard-matching/]"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**What is worng with my  solution it is giving heap buffer overflow error!**\\nclass solution{\\n![image](https://assets.leetcode.com/users/images/ea1cd395-b88d-41b3-b804-cc5dcfb979f8_1620375104.7723796.png)\\n"
                    }
                ]
            },
            {
                "id": 1568824,
                "content": [
                    {
                        "username": "godrays",
                        "content": "I believe (\"ab\", \".*\") -> true should be changed to (\"ab\", \".*b\") -> true. \\n\\nAny ideas why this is not?"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/207f3b69-5e37-403d-954e-78bc0015e0e9_1651123059.4005842.png)\\n![image](https://assets.leetcode.com/users/images/6aaf139b-0869-477e-b7de-b0af6b5e3fac_1651123063.0122378.jpeg)\\n**PLease upvote this post if you get any help from it.**"
                    },
                    {
                        "username": "koyun",
                        "content": "Input: \\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nMy output is correct. Input doesn\\'t start with c so can never match. The test is wrong. Who can fix that?"
                    },
                    {
                        "username": "user3529M",
                        "content": "No explanation is provided on how to treat cases of \"\\\\**\" in pattern.\\nIt makes the question very annoying to complete, because I need to guess how to treat those states and hope that my guess will be correct."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer this awesome explanation and code in C++/Java/Python:\\nhttps://www.techiedelight.com/wildcard-pattern-matching/"
                    },
                    {
                        "username": "himanshukandwal",
                        "content": "How come this test case is true ?\\n\\nas . will get matched to 'a' and then * as the description says, Matches zero or more of the preceding element. In this case that is 'a'(previously matched character), so '*' shouldn't get matched to b at all. \\n\\nisMatch(\"aa\", \".*\") = true, this test case makes the right sense, I believe."
                    },
                    {
                        "username": "laimanyou",
                        "content": "Input:   \"ab\", \".*c\"\\n\\nOutput:    true\\n\\nExpected:  false\\n\\nWhy? I think \".*\" means \"........\"(unlimited number) which can include any string.\\n\\nAnd in the example \\u2014\\u2014isMatch(\"ab\", \".*\") \\u2192 true\\n\\nI was very confused."
                    },
                    {
                        "username": "KoHu",
                        "content": "return s.matches(p) ;"
                    },
                    {
                        "username": "muditsen1234",
                        "content": "Duplicate of  [https://leetcode.com/problems/wildcard-matching/]"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**What is worng with my  solution it is giving heap buffer overflow error!**\\nclass solution{\\n![image](https://assets.leetcode.com/users/images/ea1cd395-b88d-41b3-b804-cc5dcfb979f8_1620375104.7723796.png)\\n"
                    }
                ]
            },
            {
                "id": 1570353,
                "content": [
                    {
                        "username": "godrays",
                        "content": "I believe (\"ab\", \".*\") -> true should be changed to (\"ab\", \".*b\") -> true. \\n\\nAny ideas why this is not?"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/207f3b69-5e37-403d-954e-78bc0015e0e9_1651123059.4005842.png)\\n![image](https://assets.leetcode.com/users/images/6aaf139b-0869-477e-b7de-b0af6b5e3fac_1651123063.0122378.jpeg)\\n**PLease upvote this post if you get any help from it.**"
                    },
                    {
                        "username": "koyun",
                        "content": "Input: \\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nMy output is correct. Input doesn\\'t start with c so can never match. The test is wrong. Who can fix that?"
                    },
                    {
                        "username": "user3529M",
                        "content": "No explanation is provided on how to treat cases of \"\\\\**\" in pattern.\\nIt makes the question very annoying to complete, because I need to guess how to treat those states and hope that my guess will be correct."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer this awesome explanation and code in C++/Java/Python:\\nhttps://www.techiedelight.com/wildcard-pattern-matching/"
                    },
                    {
                        "username": "himanshukandwal",
                        "content": "How come this test case is true ?\\n\\nas . will get matched to 'a' and then * as the description says, Matches zero or more of the preceding element. In this case that is 'a'(previously matched character), so '*' shouldn't get matched to b at all. \\n\\nisMatch(\"aa\", \".*\") = true, this test case makes the right sense, I believe."
                    },
                    {
                        "username": "laimanyou",
                        "content": "Input:   \"ab\", \".*c\"\\n\\nOutput:    true\\n\\nExpected:  false\\n\\nWhy? I think \".*\" means \"........\"(unlimited number) which can include any string.\\n\\nAnd in the example \\u2014\\u2014isMatch(\"ab\", \".*\") \\u2192 true\\n\\nI was very confused."
                    },
                    {
                        "username": "KoHu",
                        "content": "return s.matches(p) ;"
                    },
                    {
                        "username": "muditsen1234",
                        "content": "Duplicate of  [https://leetcode.com/problems/wildcard-matching/]"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**What is worng with my  solution it is giving heap buffer overflow error!**\\nclass solution{\\n![image](https://assets.leetcode.com/users/images/ea1cd395-b88d-41b3-b804-cc5dcfb979f8_1620375104.7723796.png)\\n"
                    }
                ]
            },
            {
                "id": 1575745,
                "content": [
                    {
                        "username": "godrays",
                        "content": "I believe (\"ab\", \".*\") -> true should be changed to (\"ab\", \".*b\") -> true. \\n\\nAny ideas why this is not?"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/207f3b69-5e37-403d-954e-78bc0015e0e9_1651123059.4005842.png)\\n![image](https://assets.leetcode.com/users/images/6aaf139b-0869-477e-b7de-b0af6b5e3fac_1651123063.0122378.jpeg)\\n**PLease upvote this post if you get any help from it.**"
                    },
                    {
                        "username": "koyun",
                        "content": "Input: \\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nMy output is correct. Input doesn\\'t start with c so can never match. The test is wrong. Who can fix that?"
                    },
                    {
                        "username": "user3529M",
                        "content": "No explanation is provided on how to treat cases of \"\\\\**\" in pattern.\\nIt makes the question very annoying to complete, because I need to guess how to treat those states and hope that my guess will be correct."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer this awesome explanation and code in C++/Java/Python:\\nhttps://www.techiedelight.com/wildcard-pattern-matching/"
                    },
                    {
                        "username": "himanshukandwal",
                        "content": "How come this test case is true ?\\n\\nas . will get matched to 'a' and then * as the description says, Matches zero or more of the preceding element. In this case that is 'a'(previously matched character), so '*' shouldn't get matched to b at all. \\n\\nisMatch(\"aa\", \".*\") = true, this test case makes the right sense, I believe."
                    },
                    {
                        "username": "laimanyou",
                        "content": "Input:   \"ab\", \".*c\"\\n\\nOutput:    true\\n\\nExpected:  false\\n\\nWhy? I think \".*\" means \"........\"(unlimited number) which can include any string.\\n\\nAnd in the example \\u2014\\u2014isMatch(\"ab\", \".*\") \\u2192 true\\n\\nI was very confused."
                    },
                    {
                        "username": "KoHu",
                        "content": "return s.matches(p) ;"
                    },
                    {
                        "username": "muditsen1234",
                        "content": "Duplicate of  [https://leetcode.com/problems/wildcard-matching/]"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**What is worng with my  solution it is giving heap buffer overflow error!**\\nclass solution{\\n![image](https://assets.leetcode.com/users/images/ea1cd395-b88d-41b3-b804-cc5dcfb979f8_1620375104.7723796.png)\\n"
                    }
                ]
            },
            {
                "id": 1575236,
                "content": [
                    {
                        "username": "godrays",
                        "content": "I believe (\"ab\", \".*\") -> true should be changed to (\"ab\", \".*b\") -> true. \\n\\nAny ideas why this is not?"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/207f3b69-5e37-403d-954e-78bc0015e0e9_1651123059.4005842.png)\\n![image](https://assets.leetcode.com/users/images/6aaf139b-0869-477e-b7de-b0af6b5e3fac_1651123063.0122378.jpeg)\\n**PLease upvote this post if you get any help from it.**"
                    },
                    {
                        "username": "koyun",
                        "content": "Input: \\n\"aab\"\\n\"c\\\\*a\\\\*b\"\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nMy output is correct. Input doesn\\'t start with c so can never match. The test is wrong. Who can fix that?"
                    },
                    {
                        "username": "user3529M",
                        "content": "No explanation is provided on how to treat cases of \"\\\\**\" in pattern.\\nIt makes the question very annoying to complete, because I need to guess how to treat those states and hope that my guess will be correct."
                    },
                    {
                        "username": "msn_user",
                        "content": "Refer this awesome explanation and code in C++/Java/Python:\\nhttps://www.techiedelight.com/wildcard-pattern-matching/"
                    },
                    {
                        "username": "himanshukandwal",
                        "content": "How come this test case is true ?\\n\\nas . will get matched to 'a' and then * as the description says, Matches zero or more of the preceding element. In this case that is 'a'(previously matched character), so '*' shouldn't get matched to b at all. \\n\\nisMatch(\"aa\", \".*\") = true, this test case makes the right sense, I believe."
                    },
                    {
                        "username": "laimanyou",
                        "content": "Input:   \"ab\", \".*c\"\\n\\nOutput:    true\\n\\nExpected:  false\\n\\nWhy? I think \".*\" means \"........\"(unlimited number) which can include any string.\\n\\nAnd in the example \\u2014\\u2014isMatch(\"ab\", \".*\") \\u2192 true\\n\\nI was very confused."
                    },
                    {
                        "username": "KoHu",
                        "content": "return s.matches(p) ;"
                    },
                    {
                        "username": "muditsen1234",
                        "content": "Duplicate of  [https://leetcode.com/problems/wildcard-matching/]"
                    },
                    {
                        "username": "Mayank_Shahria",
                        "content": "**What is worng with my  solution it is giving heap buffer overflow error!**\\nclass solution{\\n![image](https://assets.leetcode.com/users/images/ea1cd395-b88d-41b3-b804-cc5dcfb979f8_1620375104.7723796.png)\\n"
                    }
                ]
            },
            {
                "id": 1573449,
                "content": [
                    {
                        "username": "soumojitsarkar",
                        "content": "Is this problem exactly same as the following?\\nhttps://leetcode.com/problems/wildcard-matching/"
                    },
                    {
                        "username": "free2o",
                        "content": "    s = \"aab\" ;\\n    p = \"c*a*b\"\\n\\nwhy is the above input is matched ?\\n\\nwhile \\n`p = \"dc*a*b\"` not matched ?\\n\\nI not really understand the question.\\n\\nwho can explain a little more about it ?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "At c*a*b case it\\'ll be always true if last word is b, and at dc*a*b case it\\'ll be always true if first character is d and last character is b"
                    },
                    {
                        "username": "iuashrafi",
                        "content": "Some Testcases before submitting: \n1) s=\"aab\", p=\"c*a *b\"   [Ignore white spaces in pattern p]\n2) s=\"aaa\" , p=\"ab*a *c *a\"\n3) s=\"aaa\" , p=\"ab* ac* a\"\n4) s=\"ab\" , p=\".*\""
                    },
                    {
                        "username": "saimalar",
                        "content": "Why we should create dp of size n+1 * m+1 instead of n*m. can someone please explain\\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "My understanding is, however you traverse the list, you\\'ll have an empty spot at the top or bottom which will hold a true or 1 (whatever you are using to represent true).  This makes the loop work the same way throughout. I\\'m not as familiar with dp, so hopefully that helps."
                    },
                    {
                        "username": "user8433dM",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nExpected output is true\\n\\ns =\\n\"aaa\"\\np =\\n\"ab*ac*a\"\\n\\nExpected output is false\\n\\nIf someone could explain these test cases please, both of them should be either true or both should be false, why the different outputs for similar patterns?"
                    },
                    {
                        "username": "mrinaldenre",
                        "content": "s = \"mississippi\"    p =\"mis*is*p*.\"   output=true    Expected=false\\n\\nAnyone can help why it should be false in this case?"
                    },
                    {
                        "username": "ArchitektApx",
                        "content": " `It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.`\\n\\nSo why is `\"a***abc`a testcase then?"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "I don\\'t have that as a testcase. I never had it as a failure for that as a testcase. Is it possible that someone added it to their testcase?  "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a hard among hards."
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "s= \"mississippi\" and p=\"mis*is*p*.\" test should be true why it should be false Kindly guide me"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "You need another \"i\" between \"mis\\\\*is\\\\*\" and \"p\\\\*.\""
                    },
                    {
                        "username": "SeineAle",
                        "content": "Do not look for solutions. This question does not have any special way or trick. It is similar to other sting dp questions, just the process is bit complex. Try it on your own, you will feal insanely amazing after solving it, just like me :)"
                    }
                ]
            },
            {
                "id": 1571023,
                "content": [
                    {
                        "username": "soumojitsarkar",
                        "content": "Is this problem exactly same as the following?\\nhttps://leetcode.com/problems/wildcard-matching/"
                    },
                    {
                        "username": "free2o",
                        "content": "    s = \"aab\" ;\\n    p = \"c*a*b\"\\n\\nwhy is the above input is matched ?\\n\\nwhile \\n`p = \"dc*a*b\"` not matched ?\\n\\nI not really understand the question.\\n\\nwho can explain a little more about it ?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "At c*a*b case it\\'ll be always true if last word is b, and at dc*a*b case it\\'ll be always true if first character is d and last character is b"
                    },
                    {
                        "username": "iuashrafi",
                        "content": "Some Testcases before submitting: \n1) s=\"aab\", p=\"c*a *b\"   [Ignore white spaces in pattern p]\n2) s=\"aaa\" , p=\"ab*a *c *a\"\n3) s=\"aaa\" , p=\"ab* ac* a\"\n4) s=\"ab\" , p=\".*\""
                    },
                    {
                        "username": "saimalar",
                        "content": "Why we should create dp of size n+1 * m+1 instead of n*m. can someone please explain\\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "My understanding is, however you traverse the list, you\\'ll have an empty spot at the top or bottom which will hold a true or 1 (whatever you are using to represent true).  This makes the loop work the same way throughout. I\\'m not as familiar with dp, so hopefully that helps."
                    },
                    {
                        "username": "user8433dM",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nExpected output is true\\n\\ns =\\n\"aaa\"\\np =\\n\"ab*ac*a\"\\n\\nExpected output is false\\n\\nIf someone could explain these test cases please, both of them should be either true or both should be false, why the different outputs for similar patterns?"
                    },
                    {
                        "username": "mrinaldenre",
                        "content": "s = \"mississippi\"    p =\"mis*is*p*.\"   output=true    Expected=false\\n\\nAnyone can help why it should be false in this case?"
                    },
                    {
                        "username": "ArchitektApx",
                        "content": " `It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.`\\n\\nSo why is `\"a***abc`a testcase then?"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "I don\\'t have that as a testcase. I never had it as a failure for that as a testcase. Is it possible that someone added it to their testcase?  "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a hard among hards."
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "s= \"mississippi\" and p=\"mis*is*p*.\" test should be true why it should be false Kindly guide me"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "You need another \"i\" between \"mis\\\\*is\\\\*\" and \"p\\\\*.\""
                    },
                    {
                        "username": "SeineAle",
                        "content": "Do not look for solutions. This question does not have any special way or trick. It is similar to other sting dp questions, just the process is bit complex. Try it on your own, you will feal insanely amazing after solving it, just like me :)"
                    }
                ]
            },
            {
                "id": 2075276,
                "content": [
                    {
                        "username": "soumojitsarkar",
                        "content": "Is this problem exactly same as the following?\\nhttps://leetcode.com/problems/wildcard-matching/"
                    },
                    {
                        "username": "free2o",
                        "content": "    s = \"aab\" ;\\n    p = \"c*a*b\"\\n\\nwhy is the above input is matched ?\\n\\nwhile \\n`p = \"dc*a*b\"` not matched ?\\n\\nI not really understand the question.\\n\\nwho can explain a little more about it ?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "At c*a*b case it\\'ll be always true if last word is b, and at dc*a*b case it\\'ll be always true if first character is d and last character is b"
                    },
                    {
                        "username": "iuashrafi",
                        "content": "Some Testcases before submitting: \n1) s=\"aab\", p=\"c*a *b\"   [Ignore white spaces in pattern p]\n2) s=\"aaa\" , p=\"ab*a *c *a\"\n3) s=\"aaa\" , p=\"ab* ac* a\"\n4) s=\"ab\" , p=\".*\""
                    },
                    {
                        "username": "saimalar",
                        "content": "Why we should create dp of size n+1 * m+1 instead of n*m. can someone please explain\\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "My understanding is, however you traverse the list, you\\'ll have an empty spot at the top or bottom which will hold a true or 1 (whatever you are using to represent true).  This makes the loop work the same way throughout. I\\'m not as familiar with dp, so hopefully that helps."
                    },
                    {
                        "username": "user8433dM",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nExpected output is true\\n\\ns =\\n\"aaa\"\\np =\\n\"ab*ac*a\"\\n\\nExpected output is false\\n\\nIf someone could explain these test cases please, both of them should be either true or both should be false, why the different outputs for similar patterns?"
                    },
                    {
                        "username": "mrinaldenre",
                        "content": "s = \"mississippi\"    p =\"mis*is*p*.\"   output=true    Expected=false\\n\\nAnyone can help why it should be false in this case?"
                    },
                    {
                        "username": "ArchitektApx",
                        "content": " `It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.`\\n\\nSo why is `\"a***abc`a testcase then?"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "I don\\'t have that as a testcase. I never had it as a failure for that as a testcase. Is it possible that someone added it to their testcase?  "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a hard among hards."
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "s= \"mississippi\" and p=\"mis*is*p*.\" test should be true why it should be false Kindly guide me"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "You need another \"i\" between \"mis\\\\*is\\\\*\" and \"p\\\\*.\""
                    },
                    {
                        "username": "SeineAle",
                        "content": "Do not look for solutions. This question does not have any special way or trick. It is similar to other sting dp questions, just the process is bit complex. Try it on your own, you will feal insanely amazing after solving it, just like me :)"
                    }
                ]
            },
            {
                "id": 2074658,
                "content": [
                    {
                        "username": "soumojitsarkar",
                        "content": "Is this problem exactly same as the following?\\nhttps://leetcode.com/problems/wildcard-matching/"
                    },
                    {
                        "username": "free2o",
                        "content": "    s = \"aab\" ;\\n    p = \"c*a*b\"\\n\\nwhy is the above input is matched ?\\n\\nwhile \\n`p = \"dc*a*b\"` not matched ?\\n\\nI not really understand the question.\\n\\nwho can explain a little more about it ?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "At c*a*b case it\\'ll be always true if last word is b, and at dc*a*b case it\\'ll be always true if first character is d and last character is b"
                    },
                    {
                        "username": "iuashrafi",
                        "content": "Some Testcases before submitting: \n1) s=\"aab\", p=\"c*a *b\"   [Ignore white spaces in pattern p]\n2) s=\"aaa\" , p=\"ab*a *c *a\"\n3) s=\"aaa\" , p=\"ab* ac* a\"\n4) s=\"ab\" , p=\".*\""
                    },
                    {
                        "username": "saimalar",
                        "content": "Why we should create dp of size n+1 * m+1 instead of n*m. can someone please explain\\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "My understanding is, however you traverse the list, you\\'ll have an empty spot at the top or bottom which will hold a true or 1 (whatever you are using to represent true).  This makes the loop work the same way throughout. I\\'m not as familiar with dp, so hopefully that helps."
                    },
                    {
                        "username": "user8433dM",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nExpected output is true\\n\\ns =\\n\"aaa\"\\np =\\n\"ab*ac*a\"\\n\\nExpected output is false\\n\\nIf someone could explain these test cases please, both of them should be either true or both should be false, why the different outputs for similar patterns?"
                    },
                    {
                        "username": "mrinaldenre",
                        "content": "s = \"mississippi\"    p =\"mis*is*p*.\"   output=true    Expected=false\\n\\nAnyone can help why it should be false in this case?"
                    },
                    {
                        "username": "ArchitektApx",
                        "content": " `It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.`\\n\\nSo why is `\"a***abc`a testcase then?"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "I don\\'t have that as a testcase. I never had it as a failure for that as a testcase. Is it possible that someone added it to their testcase?  "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a hard among hards."
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "s= \"mississippi\" and p=\"mis*is*p*.\" test should be true why it should be false Kindly guide me"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "You need another \"i\" between \"mis\\\\*is\\\\*\" and \"p\\\\*.\""
                    },
                    {
                        "username": "SeineAle",
                        "content": "Do not look for solutions. This question does not have any special way or trick. It is similar to other sting dp questions, just the process is bit complex. Try it on your own, you will feal insanely amazing after solving it, just like me :)"
                    }
                ]
            },
            {
                "id": 2072439,
                "content": [
                    {
                        "username": "soumojitsarkar",
                        "content": "Is this problem exactly same as the following?\\nhttps://leetcode.com/problems/wildcard-matching/"
                    },
                    {
                        "username": "free2o",
                        "content": "    s = \"aab\" ;\\n    p = \"c*a*b\"\\n\\nwhy is the above input is matched ?\\n\\nwhile \\n`p = \"dc*a*b\"` not matched ?\\n\\nI not really understand the question.\\n\\nwho can explain a little more about it ?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "At c*a*b case it\\'ll be always true if last word is b, and at dc*a*b case it\\'ll be always true if first character is d and last character is b"
                    },
                    {
                        "username": "iuashrafi",
                        "content": "Some Testcases before submitting: \n1) s=\"aab\", p=\"c*a *b\"   [Ignore white spaces in pattern p]\n2) s=\"aaa\" , p=\"ab*a *c *a\"\n3) s=\"aaa\" , p=\"ab* ac* a\"\n4) s=\"ab\" , p=\".*\""
                    },
                    {
                        "username": "saimalar",
                        "content": "Why we should create dp of size n+1 * m+1 instead of n*m. can someone please explain\\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "My understanding is, however you traverse the list, you\\'ll have an empty spot at the top or bottom which will hold a true or 1 (whatever you are using to represent true).  This makes the loop work the same way throughout. I\\'m not as familiar with dp, so hopefully that helps."
                    },
                    {
                        "username": "user8433dM",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nExpected output is true\\n\\ns =\\n\"aaa\"\\np =\\n\"ab*ac*a\"\\n\\nExpected output is false\\n\\nIf someone could explain these test cases please, both of them should be either true or both should be false, why the different outputs for similar patterns?"
                    },
                    {
                        "username": "mrinaldenre",
                        "content": "s = \"mississippi\"    p =\"mis*is*p*.\"   output=true    Expected=false\\n\\nAnyone can help why it should be false in this case?"
                    },
                    {
                        "username": "ArchitektApx",
                        "content": " `It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.`\\n\\nSo why is `\"a***abc`a testcase then?"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "I don\\'t have that as a testcase. I never had it as a failure for that as a testcase. Is it possible that someone added it to their testcase?  "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a hard among hards."
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "s= \"mississippi\" and p=\"mis*is*p*.\" test should be true why it should be false Kindly guide me"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "You need another \"i\" between \"mis\\\\*is\\\\*\" and \"p\\\\*.\""
                    },
                    {
                        "username": "SeineAle",
                        "content": "Do not look for solutions. This question does not have any special way or trick. It is similar to other sting dp questions, just the process is bit complex. Try it on your own, you will feal insanely amazing after solving it, just like me :)"
                    }
                ]
            },
            {
                "id": 2070856,
                "content": [
                    {
                        "username": "soumojitsarkar",
                        "content": "Is this problem exactly same as the following?\\nhttps://leetcode.com/problems/wildcard-matching/"
                    },
                    {
                        "username": "free2o",
                        "content": "    s = \"aab\" ;\\n    p = \"c*a*b\"\\n\\nwhy is the above input is matched ?\\n\\nwhile \\n`p = \"dc*a*b\"` not matched ?\\n\\nI not really understand the question.\\n\\nwho can explain a little more about it ?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "At c*a*b case it\\'ll be always true if last word is b, and at dc*a*b case it\\'ll be always true if first character is d and last character is b"
                    },
                    {
                        "username": "iuashrafi",
                        "content": "Some Testcases before submitting: \n1) s=\"aab\", p=\"c*a *b\"   [Ignore white spaces in pattern p]\n2) s=\"aaa\" , p=\"ab*a *c *a\"\n3) s=\"aaa\" , p=\"ab* ac* a\"\n4) s=\"ab\" , p=\".*\""
                    },
                    {
                        "username": "saimalar",
                        "content": "Why we should create dp of size n+1 * m+1 instead of n*m. can someone please explain\\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "My understanding is, however you traverse the list, you\\'ll have an empty spot at the top or bottom which will hold a true or 1 (whatever you are using to represent true).  This makes the loop work the same way throughout. I\\'m not as familiar with dp, so hopefully that helps."
                    },
                    {
                        "username": "user8433dM",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nExpected output is true\\n\\ns =\\n\"aaa\"\\np =\\n\"ab*ac*a\"\\n\\nExpected output is false\\n\\nIf someone could explain these test cases please, both of them should be either true or both should be false, why the different outputs for similar patterns?"
                    },
                    {
                        "username": "mrinaldenre",
                        "content": "s = \"mississippi\"    p =\"mis*is*p*.\"   output=true    Expected=false\\n\\nAnyone can help why it should be false in this case?"
                    },
                    {
                        "username": "ArchitektApx",
                        "content": " `It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.`\\n\\nSo why is `\"a***abc`a testcase then?"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "I don\\'t have that as a testcase. I never had it as a failure for that as a testcase. Is it possible that someone added it to their testcase?  "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a hard among hards."
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "s= \"mississippi\" and p=\"mis*is*p*.\" test should be true why it should be false Kindly guide me"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "You need another \"i\" between \"mis\\\\*is\\\\*\" and \"p\\\\*.\""
                    },
                    {
                        "username": "SeineAle",
                        "content": "Do not look for solutions. This question does not have any special way or trick. It is similar to other sting dp questions, just the process is bit complex. Try it on your own, you will feal insanely amazing after solving it, just like me :)"
                    }
                ]
            },
            {
                "id": 2067589,
                "content": [
                    {
                        "username": "soumojitsarkar",
                        "content": "Is this problem exactly same as the following?\\nhttps://leetcode.com/problems/wildcard-matching/"
                    },
                    {
                        "username": "free2o",
                        "content": "    s = \"aab\" ;\\n    p = \"c*a*b\"\\n\\nwhy is the above input is matched ?\\n\\nwhile \\n`p = \"dc*a*b\"` not matched ?\\n\\nI not really understand the question.\\n\\nwho can explain a little more about it ?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "At c*a*b case it\\'ll be always true if last word is b, and at dc*a*b case it\\'ll be always true if first character is d and last character is b"
                    },
                    {
                        "username": "iuashrafi",
                        "content": "Some Testcases before submitting: \n1) s=\"aab\", p=\"c*a *b\"   [Ignore white spaces in pattern p]\n2) s=\"aaa\" , p=\"ab*a *c *a\"\n3) s=\"aaa\" , p=\"ab* ac* a\"\n4) s=\"ab\" , p=\".*\""
                    },
                    {
                        "username": "saimalar",
                        "content": "Why we should create dp of size n+1 * m+1 instead of n*m. can someone please explain\\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "My understanding is, however you traverse the list, you\\'ll have an empty spot at the top or bottom which will hold a true or 1 (whatever you are using to represent true).  This makes the loop work the same way throughout. I\\'m not as familiar with dp, so hopefully that helps."
                    },
                    {
                        "username": "user8433dM",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nExpected output is true\\n\\ns =\\n\"aaa\"\\np =\\n\"ab*ac*a\"\\n\\nExpected output is false\\n\\nIf someone could explain these test cases please, both of them should be either true or both should be false, why the different outputs for similar patterns?"
                    },
                    {
                        "username": "mrinaldenre",
                        "content": "s = \"mississippi\"    p =\"mis*is*p*.\"   output=true    Expected=false\\n\\nAnyone can help why it should be false in this case?"
                    },
                    {
                        "username": "ArchitektApx",
                        "content": " `It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.`\\n\\nSo why is `\"a***abc`a testcase then?"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "I don\\'t have that as a testcase. I never had it as a failure for that as a testcase. Is it possible that someone added it to their testcase?  "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a hard among hards."
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "s= \"mississippi\" and p=\"mis*is*p*.\" test should be true why it should be false Kindly guide me"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "You need another \"i\" between \"mis\\\\*is\\\\*\" and \"p\\\\*.\""
                    },
                    {
                        "username": "SeineAle",
                        "content": "Do not look for solutions. This question does not have any special way or trick. It is similar to other sting dp questions, just the process is bit complex. Try it on your own, you will feal insanely amazing after solving it, just like me :)"
                    }
                ]
            },
            {
                "id": 2067091,
                "content": [
                    {
                        "username": "soumojitsarkar",
                        "content": "Is this problem exactly same as the following?\\nhttps://leetcode.com/problems/wildcard-matching/"
                    },
                    {
                        "username": "free2o",
                        "content": "    s = \"aab\" ;\\n    p = \"c*a*b\"\\n\\nwhy is the above input is matched ?\\n\\nwhile \\n`p = \"dc*a*b\"` not matched ?\\n\\nI not really understand the question.\\n\\nwho can explain a little more about it ?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "At c*a*b case it\\'ll be always true if last word is b, and at dc*a*b case it\\'ll be always true if first character is d and last character is b"
                    },
                    {
                        "username": "iuashrafi",
                        "content": "Some Testcases before submitting: \n1) s=\"aab\", p=\"c*a *b\"   [Ignore white spaces in pattern p]\n2) s=\"aaa\" , p=\"ab*a *c *a\"\n3) s=\"aaa\" , p=\"ab* ac* a\"\n4) s=\"ab\" , p=\".*\""
                    },
                    {
                        "username": "saimalar",
                        "content": "Why we should create dp of size n+1 * m+1 instead of n*m. can someone please explain\\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "My understanding is, however you traverse the list, you\\'ll have an empty spot at the top or bottom which will hold a true or 1 (whatever you are using to represent true).  This makes the loop work the same way throughout. I\\'m not as familiar with dp, so hopefully that helps."
                    },
                    {
                        "username": "user8433dM",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nExpected output is true\\n\\ns =\\n\"aaa\"\\np =\\n\"ab*ac*a\"\\n\\nExpected output is false\\n\\nIf someone could explain these test cases please, both of them should be either true or both should be false, why the different outputs for similar patterns?"
                    },
                    {
                        "username": "mrinaldenre",
                        "content": "s = \"mississippi\"    p =\"mis*is*p*.\"   output=true    Expected=false\\n\\nAnyone can help why it should be false in this case?"
                    },
                    {
                        "username": "ArchitektApx",
                        "content": " `It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.`\\n\\nSo why is `\"a***abc`a testcase then?"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "I don\\'t have that as a testcase. I never had it as a failure for that as a testcase. Is it possible that someone added it to their testcase?  "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a hard among hards."
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "s= \"mississippi\" and p=\"mis*is*p*.\" test should be true why it should be false Kindly guide me"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "You need another \"i\" between \"mis\\\\*is\\\\*\" and \"p\\\\*.\""
                    },
                    {
                        "username": "SeineAle",
                        "content": "Do not look for solutions. This question does not have any special way or trick. It is similar to other sting dp questions, just the process is bit complex. Try it on your own, you will feal insanely amazing after solving it, just like me :)"
                    }
                ]
            },
            {
                "id": 2055576,
                "content": [
                    {
                        "username": "soumojitsarkar",
                        "content": "Is this problem exactly same as the following?\\nhttps://leetcode.com/problems/wildcard-matching/"
                    },
                    {
                        "username": "free2o",
                        "content": "    s = \"aab\" ;\\n    p = \"c*a*b\"\\n\\nwhy is the above input is matched ?\\n\\nwhile \\n`p = \"dc*a*b\"` not matched ?\\n\\nI not really understand the question.\\n\\nwho can explain a little more about it ?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "At c*a*b case it\\'ll be always true if last word is b, and at dc*a*b case it\\'ll be always true if first character is d and last character is b"
                    },
                    {
                        "username": "iuashrafi",
                        "content": "Some Testcases before submitting: \n1) s=\"aab\", p=\"c*a *b\"   [Ignore white spaces in pattern p]\n2) s=\"aaa\" , p=\"ab*a *c *a\"\n3) s=\"aaa\" , p=\"ab* ac* a\"\n4) s=\"ab\" , p=\".*\""
                    },
                    {
                        "username": "saimalar",
                        "content": "Why we should create dp of size n+1 * m+1 instead of n*m. can someone please explain\\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "My understanding is, however you traverse the list, you\\'ll have an empty spot at the top or bottom which will hold a true or 1 (whatever you are using to represent true).  This makes the loop work the same way throughout. I\\'m not as familiar with dp, so hopefully that helps."
                    },
                    {
                        "username": "user8433dM",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nExpected output is true\\n\\ns =\\n\"aaa\"\\np =\\n\"ab*ac*a\"\\n\\nExpected output is false\\n\\nIf someone could explain these test cases please, both of them should be either true or both should be false, why the different outputs for similar patterns?"
                    },
                    {
                        "username": "mrinaldenre",
                        "content": "s = \"mississippi\"    p =\"mis*is*p*.\"   output=true    Expected=false\\n\\nAnyone can help why it should be false in this case?"
                    },
                    {
                        "username": "ArchitektApx",
                        "content": " `It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.`\\n\\nSo why is `\"a***abc`a testcase then?"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "I don\\'t have that as a testcase. I never had it as a failure for that as a testcase. Is it possible that someone added it to their testcase?  "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a hard among hards."
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "s= \"mississippi\" and p=\"mis*is*p*.\" test should be true why it should be false Kindly guide me"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "You need another \"i\" between \"mis\\\\*is\\\\*\" and \"p\\\\*.\""
                    },
                    {
                        "username": "SeineAle",
                        "content": "Do not look for solutions. This question does not have any special way or trick. It is similar to other sting dp questions, just the process is bit complex. Try it on your own, you will feal insanely amazing after solving it, just like me :)"
                    }
                ]
            },
            {
                "id": 2052905,
                "content": [
                    {
                        "username": "soumojitsarkar",
                        "content": "Is this problem exactly same as the following?\\nhttps://leetcode.com/problems/wildcard-matching/"
                    },
                    {
                        "username": "free2o",
                        "content": "    s = \"aab\" ;\\n    p = \"c*a*b\"\\n\\nwhy is the above input is matched ?\\n\\nwhile \\n`p = \"dc*a*b\"` not matched ?\\n\\nI not really understand the question.\\n\\nwho can explain a little more about it ?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "At c*a*b case it\\'ll be always true if last word is b, and at dc*a*b case it\\'ll be always true if first character is d and last character is b"
                    },
                    {
                        "username": "iuashrafi",
                        "content": "Some Testcases before submitting: \n1) s=\"aab\", p=\"c*a *b\"   [Ignore white spaces in pattern p]\n2) s=\"aaa\" , p=\"ab*a *c *a\"\n3) s=\"aaa\" , p=\"ab* ac* a\"\n4) s=\"ab\" , p=\".*\""
                    },
                    {
                        "username": "saimalar",
                        "content": "Why we should create dp of size n+1 * m+1 instead of n*m. can someone please explain\\n"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "My understanding is, however you traverse the list, you\\'ll have an empty spot at the top or bottom which will hold a true or 1 (whatever you are using to represent true).  This makes the loop work the same way throughout. I\\'m not as familiar with dp, so hopefully that helps."
                    },
                    {
                        "username": "user8433dM",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nExpected output is true\\n\\ns =\\n\"aaa\"\\np =\\n\"ab*ac*a\"\\n\\nExpected output is false\\n\\nIf someone could explain these test cases please, both of them should be either true or both should be false, why the different outputs for similar patterns?"
                    },
                    {
                        "username": "mrinaldenre",
                        "content": "s = \"mississippi\"    p =\"mis*is*p*.\"   output=true    Expected=false\\n\\nAnyone can help why it should be false in this case?"
                    },
                    {
                        "username": "ArchitektApx",
                        "content": " `It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.`\\n\\nSo why is `\"a***abc`a testcase then?"
                    },
                    {
                        "username": "NathanBrazil",
                        "content": "I don\\'t have that as a testcase. I never had it as a failure for that as a testcase. Is it possible that someone added it to their testcase?  "
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "This problem is a hard among hards."
                    },
                    {
                        "username": "guptasidhant1997",
                        "content": "s= \"mississippi\" and p=\"mis*is*p*.\" test should be true why it should be false Kindly guide me"
                    },
                    {
                        "username": "hakula_1234567",
                        "content": "You need another \"i\" between \"mis\\\\*is\\\\*\" and \"p\\\\*.\""
                    },
                    {
                        "username": "SeineAle",
                        "content": "Do not look for solutions. This question does not have any special way or trick. It is similar to other sting dp questions, just the process is bit complex. Try it on your own, you will feal insanely amazing after solving it, just like me :)"
                    }
                ]
            },
            {
                "id": 2043184,
                "content": [
                    {
                        "username": "iamdipakbhandare",
                        "content": "ignore the spaces:\n\n\"a a b a\"\n\"a b * a * c * a\"\noutput: true\nexpected: false   \n\ncan anybody tell me why expected answer to be false ?"
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "how many recursion calls do you want? \\nYes"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "After 4 hours, stumble by edge cases, finally beats 97%. A lot of if-else statements."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "pass 151 testcases if p.contains(\"*\""
                    },
                    {
                        "username": "Limon020",
                        "content": "I think I finally understand this. You have to treat \"c*\" as a single character, not two. So if s = \"aab\" and p = \"c * a * b\" we can choose to match \"c*\" to \"aab\" however many time we want, or not at all. Obviously c doesnt match a, so we choose not to. Then we need to match \"aab\" with the remainder of p, \"a* b\". We can choose to match \"a*\" to the first two chars of s, and then the b's match eachother. So this example would return True\nIt isnt \"c\" \"*\" \"a\" \"*\" \"b\", its \"c*\",\"a*\",\"b\", really only 3 characters, two of which we can use however many times we want."
                    },
                    {
                        "username": "cweibel73",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhy is this false?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "I think in p b* comes first and a* comes later. That must be the reason it's false."
                    },
                    {
                        "username": "xinlin-z",
                        "content": "One of my attempt failed by this case:\\n\"abc\"\\n\"a***abc\"\\n\\nBut, \"It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\"\\n\\n?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Idk why they have the ** as an acceptable character but you just need to ignore it if you ever come across a double star\\nProbably did it just to have increased complexity for this problem"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "lol i ended up using pattern and matcher only to find out that there was a run time error for the last test case. this qn sucks"
                    },
                    {
                        "username": "fli033",
                        "content": "Non-deterministic Finite Automaton!!!!!"
                    },
                    {
                        "username": "charlie_1212",
                        "content": "Test case 354 passes the pattern `\"a***abc\"` but the instructions clearly state: \\n> It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match."
                    }
                ]
            },
            {
                "id": 2037154,
                "content": [
                    {
                        "username": "iamdipakbhandare",
                        "content": "ignore the spaces:\n\n\"a a b a\"\n\"a b * a * c * a\"\noutput: true\nexpected: false   \n\ncan anybody tell me why expected answer to be false ?"
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "how many recursion calls do you want? \\nYes"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "After 4 hours, stumble by edge cases, finally beats 97%. A lot of if-else statements."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "pass 151 testcases if p.contains(\"*\""
                    },
                    {
                        "username": "Limon020",
                        "content": "I think I finally understand this. You have to treat \"c*\" as a single character, not two. So if s = \"aab\" and p = \"c * a * b\" we can choose to match \"c*\" to \"aab\" however many time we want, or not at all. Obviously c doesnt match a, so we choose not to. Then we need to match \"aab\" with the remainder of p, \"a* b\". We can choose to match \"a*\" to the first two chars of s, and then the b's match eachother. So this example would return True\nIt isnt \"c\" \"*\" \"a\" \"*\" \"b\", its \"c*\",\"a*\",\"b\", really only 3 characters, two of which we can use however many times we want."
                    },
                    {
                        "username": "cweibel73",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhy is this false?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "I think in p b* comes first and a* comes later. That must be the reason it's false."
                    },
                    {
                        "username": "xinlin-z",
                        "content": "One of my attempt failed by this case:\\n\"abc\"\\n\"a***abc\"\\n\\nBut, \"It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\"\\n\\n?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Idk why they have the ** as an acceptable character but you just need to ignore it if you ever come across a double star\\nProbably did it just to have increased complexity for this problem"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "lol i ended up using pattern and matcher only to find out that there was a run time error for the last test case. this qn sucks"
                    },
                    {
                        "username": "fli033",
                        "content": "Non-deterministic Finite Automaton!!!!!"
                    },
                    {
                        "username": "charlie_1212",
                        "content": "Test case 354 passes the pattern `\"a***abc\"` but the instructions clearly state: \\n> It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match."
                    }
                ]
            },
            {
                "id": 2028362,
                "content": [
                    {
                        "username": "iamdipakbhandare",
                        "content": "ignore the spaces:\n\n\"a a b a\"\n\"a b * a * c * a\"\noutput: true\nexpected: false   \n\ncan anybody tell me why expected answer to be false ?"
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "how many recursion calls do you want? \\nYes"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "After 4 hours, stumble by edge cases, finally beats 97%. A lot of if-else statements."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "pass 151 testcases if p.contains(\"*\""
                    },
                    {
                        "username": "Limon020",
                        "content": "I think I finally understand this. You have to treat \"c*\" as a single character, not two. So if s = \"aab\" and p = \"c * a * b\" we can choose to match \"c*\" to \"aab\" however many time we want, or not at all. Obviously c doesnt match a, so we choose not to. Then we need to match \"aab\" with the remainder of p, \"a* b\". We can choose to match \"a*\" to the first two chars of s, and then the b's match eachother. So this example would return True\nIt isnt \"c\" \"*\" \"a\" \"*\" \"b\", its \"c*\",\"a*\",\"b\", really only 3 characters, two of which we can use however many times we want."
                    },
                    {
                        "username": "cweibel73",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhy is this false?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "I think in p b* comes first and a* comes later. That must be the reason it's false."
                    },
                    {
                        "username": "xinlin-z",
                        "content": "One of my attempt failed by this case:\\n\"abc\"\\n\"a***abc\"\\n\\nBut, \"It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\"\\n\\n?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Idk why they have the ** as an acceptable character but you just need to ignore it if you ever come across a double star\\nProbably did it just to have increased complexity for this problem"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "lol i ended up using pattern and matcher only to find out that there was a run time error for the last test case. this qn sucks"
                    },
                    {
                        "username": "fli033",
                        "content": "Non-deterministic Finite Automaton!!!!!"
                    },
                    {
                        "username": "charlie_1212",
                        "content": "Test case 354 passes the pattern `\"a***abc\"` but the instructions clearly state: \\n> It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match."
                    }
                ]
            },
            {
                "id": 2024805,
                "content": [
                    {
                        "username": "iamdipakbhandare",
                        "content": "ignore the spaces:\n\n\"a a b a\"\n\"a b * a * c * a\"\noutput: true\nexpected: false   \n\ncan anybody tell me why expected answer to be false ?"
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "how many recursion calls do you want? \\nYes"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "After 4 hours, stumble by edge cases, finally beats 97%. A lot of if-else statements."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "pass 151 testcases if p.contains(\"*\""
                    },
                    {
                        "username": "Limon020",
                        "content": "I think I finally understand this. You have to treat \"c*\" as a single character, not two. So if s = \"aab\" and p = \"c * a * b\" we can choose to match \"c*\" to \"aab\" however many time we want, or not at all. Obviously c doesnt match a, so we choose not to. Then we need to match \"aab\" with the remainder of p, \"a* b\". We can choose to match \"a*\" to the first two chars of s, and then the b's match eachother. So this example would return True\nIt isnt \"c\" \"*\" \"a\" \"*\" \"b\", its \"c*\",\"a*\",\"b\", really only 3 characters, two of which we can use however many times we want."
                    },
                    {
                        "username": "cweibel73",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhy is this false?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "I think in p b* comes first and a* comes later. That must be the reason it's false."
                    },
                    {
                        "username": "xinlin-z",
                        "content": "One of my attempt failed by this case:\\n\"abc\"\\n\"a***abc\"\\n\\nBut, \"It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\"\\n\\n?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Idk why they have the ** as an acceptable character but you just need to ignore it if you ever come across a double star\\nProbably did it just to have increased complexity for this problem"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "lol i ended up using pattern and matcher only to find out that there was a run time error for the last test case. this qn sucks"
                    },
                    {
                        "username": "fli033",
                        "content": "Non-deterministic Finite Automaton!!!!!"
                    },
                    {
                        "username": "charlie_1212",
                        "content": "Test case 354 passes the pattern `\"a***abc\"` but the instructions clearly state: \\n> It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match."
                    }
                ]
            },
            {
                "id": 2021488,
                "content": [
                    {
                        "username": "iamdipakbhandare",
                        "content": "ignore the spaces:\n\n\"a a b a\"\n\"a b * a * c * a\"\noutput: true\nexpected: false   \n\ncan anybody tell me why expected answer to be false ?"
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "how many recursion calls do you want? \\nYes"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "After 4 hours, stumble by edge cases, finally beats 97%. A lot of if-else statements."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "pass 151 testcases if p.contains(\"*\""
                    },
                    {
                        "username": "Limon020",
                        "content": "I think I finally understand this. You have to treat \"c*\" as a single character, not two. So if s = \"aab\" and p = \"c * a * b\" we can choose to match \"c*\" to \"aab\" however many time we want, or not at all. Obviously c doesnt match a, so we choose not to. Then we need to match \"aab\" with the remainder of p, \"a* b\". We can choose to match \"a*\" to the first two chars of s, and then the b's match eachother. So this example would return True\nIt isnt \"c\" \"*\" \"a\" \"*\" \"b\", its \"c*\",\"a*\",\"b\", really only 3 characters, two of which we can use however many times we want."
                    },
                    {
                        "username": "cweibel73",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhy is this false?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "I think in p b* comes first and a* comes later. That must be the reason it's false."
                    },
                    {
                        "username": "xinlin-z",
                        "content": "One of my attempt failed by this case:\\n\"abc\"\\n\"a***abc\"\\n\\nBut, \"It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\"\\n\\n?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Idk why they have the ** as an acceptable character but you just need to ignore it if you ever come across a double star\\nProbably did it just to have increased complexity for this problem"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "lol i ended up using pattern and matcher only to find out that there was a run time error for the last test case. this qn sucks"
                    },
                    {
                        "username": "fli033",
                        "content": "Non-deterministic Finite Automaton!!!!!"
                    },
                    {
                        "username": "charlie_1212",
                        "content": "Test case 354 passes the pattern `\"a***abc\"` but the instructions clearly state: \\n> It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match."
                    }
                ]
            },
            {
                "id": 2014634,
                "content": [
                    {
                        "username": "iamdipakbhandare",
                        "content": "ignore the spaces:\n\n\"a a b a\"\n\"a b * a * c * a\"\noutput: true\nexpected: false   \n\ncan anybody tell me why expected answer to be false ?"
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "how many recursion calls do you want? \\nYes"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "After 4 hours, stumble by edge cases, finally beats 97%. A lot of if-else statements."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "pass 151 testcases if p.contains(\"*\""
                    },
                    {
                        "username": "Limon020",
                        "content": "I think I finally understand this. You have to treat \"c*\" as a single character, not two. So if s = \"aab\" and p = \"c * a * b\" we can choose to match \"c*\" to \"aab\" however many time we want, or not at all. Obviously c doesnt match a, so we choose not to. Then we need to match \"aab\" with the remainder of p, \"a* b\". We can choose to match \"a*\" to the first two chars of s, and then the b's match eachother. So this example would return True\nIt isnt \"c\" \"*\" \"a\" \"*\" \"b\", its \"c*\",\"a*\",\"b\", really only 3 characters, two of which we can use however many times we want."
                    },
                    {
                        "username": "cweibel73",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhy is this false?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "I think in p b* comes first and a* comes later. That must be the reason it's false."
                    },
                    {
                        "username": "xinlin-z",
                        "content": "One of my attempt failed by this case:\\n\"abc\"\\n\"a***abc\"\\n\\nBut, \"It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\"\\n\\n?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Idk why they have the ** as an acceptable character but you just need to ignore it if you ever come across a double star\\nProbably did it just to have increased complexity for this problem"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "lol i ended up using pattern and matcher only to find out that there was a run time error for the last test case. this qn sucks"
                    },
                    {
                        "username": "fli033",
                        "content": "Non-deterministic Finite Automaton!!!!!"
                    },
                    {
                        "username": "charlie_1212",
                        "content": "Test case 354 passes the pattern `\"a***abc\"` but the instructions clearly state: \\n> It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match."
                    }
                ]
            },
            {
                "id": 2010366,
                "content": [
                    {
                        "username": "iamdipakbhandare",
                        "content": "ignore the spaces:\n\n\"a a b a\"\n\"a b * a * c * a\"\noutput: true\nexpected: false   \n\ncan anybody tell me why expected answer to be false ?"
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "how many recursion calls do you want? \\nYes"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "After 4 hours, stumble by edge cases, finally beats 97%. A lot of if-else statements."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "pass 151 testcases if p.contains(\"*\""
                    },
                    {
                        "username": "Limon020",
                        "content": "I think I finally understand this. You have to treat \"c*\" as a single character, not two. So if s = \"aab\" and p = \"c * a * b\" we can choose to match \"c*\" to \"aab\" however many time we want, or not at all. Obviously c doesnt match a, so we choose not to. Then we need to match \"aab\" with the remainder of p, \"a* b\". We can choose to match \"a*\" to the first two chars of s, and then the b's match eachother. So this example would return True\nIt isnt \"c\" \"*\" \"a\" \"*\" \"b\", its \"c*\",\"a*\",\"b\", really only 3 characters, two of which we can use however many times we want."
                    },
                    {
                        "username": "cweibel73",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhy is this false?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "I think in p b* comes first and a* comes later. That must be the reason it's false."
                    },
                    {
                        "username": "xinlin-z",
                        "content": "One of my attempt failed by this case:\\n\"abc\"\\n\"a***abc\"\\n\\nBut, \"It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\"\\n\\n?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Idk why they have the ** as an acceptable character but you just need to ignore it if you ever come across a double star\\nProbably did it just to have increased complexity for this problem"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "lol i ended up using pattern and matcher only to find out that there was a run time error for the last test case. this qn sucks"
                    },
                    {
                        "username": "fli033",
                        "content": "Non-deterministic Finite Automaton!!!!!"
                    },
                    {
                        "username": "charlie_1212",
                        "content": "Test case 354 passes the pattern `\"a***abc\"` but the instructions clearly state: \\n> It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match."
                    }
                ]
            },
            {
                "id": 2002819,
                "content": [
                    {
                        "username": "iamdipakbhandare",
                        "content": "ignore the spaces:\n\n\"a a b a\"\n\"a b * a * c * a\"\noutput: true\nexpected: false   \n\ncan anybody tell me why expected answer to be false ?"
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "how many recursion calls do you want? \\nYes"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "After 4 hours, stumble by edge cases, finally beats 97%. A lot of if-else statements."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "pass 151 testcases if p.contains(\"*\""
                    },
                    {
                        "username": "Limon020",
                        "content": "I think I finally understand this. You have to treat \"c*\" as a single character, not two. So if s = \"aab\" and p = \"c * a * b\" we can choose to match \"c*\" to \"aab\" however many time we want, or not at all. Obviously c doesnt match a, so we choose not to. Then we need to match \"aab\" with the remainder of p, \"a* b\". We can choose to match \"a*\" to the first two chars of s, and then the b's match eachother. So this example would return True\nIt isnt \"c\" \"*\" \"a\" \"*\" \"b\", its \"c*\",\"a*\",\"b\", really only 3 characters, two of which we can use however many times we want."
                    },
                    {
                        "username": "cweibel73",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhy is this false?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "I think in p b* comes first and a* comes later. That must be the reason it's false."
                    },
                    {
                        "username": "xinlin-z",
                        "content": "One of my attempt failed by this case:\\n\"abc\"\\n\"a***abc\"\\n\\nBut, \"It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\"\\n\\n?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Idk why they have the ** as an acceptable character but you just need to ignore it if you ever come across a double star\\nProbably did it just to have increased complexity for this problem"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "lol i ended up using pattern and matcher only to find out that there was a run time error for the last test case. this qn sucks"
                    },
                    {
                        "username": "fli033",
                        "content": "Non-deterministic Finite Automaton!!!!!"
                    },
                    {
                        "username": "charlie_1212",
                        "content": "Test case 354 passes the pattern `\"a***abc\"` but the instructions clearly state: \\n> It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match."
                    }
                ]
            },
            {
                "id": 2000383,
                "content": [
                    {
                        "username": "iamdipakbhandare",
                        "content": "ignore the spaces:\n\n\"a a b a\"\n\"a b * a * c * a\"\noutput: true\nexpected: false   \n\ncan anybody tell me why expected answer to be false ?"
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "how many recursion calls do you want? \\nYes"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "After 4 hours, stumble by edge cases, finally beats 97%. A lot of if-else statements."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "pass 151 testcases if p.contains(\"*\""
                    },
                    {
                        "username": "Limon020",
                        "content": "I think I finally understand this. You have to treat \"c*\" as a single character, not two. So if s = \"aab\" and p = \"c * a * b\" we can choose to match \"c*\" to \"aab\" however many time we want, or not at all. Obviously c doesnt match a, so we choose not to. Then we need to match \"aab\" with the remainder of p, \"a* b\". We can choose to match \"a*\" to the first two chars of s, and then the b's match eachother. So this example would return True\nIt isnt \"c\" \"*\" \"a\" \"*\" \"b\", its \"c*\",\"a*\",\"b\", really only 3 characters, two of which we can use however many times we want."
                    },
                    {
                        "username": "cweibel73",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhy is this false?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "I think in p b* comes first and a* comes later. That must be the reason it's false."
                    },
                    {
                        "username": "xinlin-z",
                        "content": "One of my attempt failed by this case:\\n\"abc\"\\n\"a***abc\"\\n\\nBut, \"It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\"\\n\\n?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Idk why they have the ** as an acceptable character but you just need to ignore it if you ever come across a double star\\nProbably did it just to have increased complexity for this problem"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "lol i ended up using pattern and matcher only to find out that there was a run time error for the last test case. this qn sucks"
                    },
                    {
                        "username": "fli033",
                        "content": "Non-deterministic Finite Automaton!!!!!"
                    },
                    {
                        "username": "charlie_1212",
                        "content": "Test case 354 passes the pattern `\"a***abc\"` but the instructions clearly state: \\n> It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match."
                    }
                ]
            },
            {
                "id": 2000271,
                "content": [
                    {
                        "username": "iamdipakbhandare",
                        "content": "ignore the spaces:\n\n\"a a b a\"\n\"a b * a * c * a\"\noutput: true\nexpected: false   \n\ncan anybody tell me why expected answer to be false ?"
                    },
                    {
                        "username": "Mikhail_Z",
                        "content": "how many recursion calls do you want? \\nYes"
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "After 4 hours, stumble by edge cases, finally beats 97%. A lot of if-else statements."
                    },
                    {
                        "username": "AseCantCode",
                        "content": "pass 151 testcases if p.contains(\"*\""
                    },
                    {
                        "username": "Limon020",
                        "content": "I think I finally understand this. You have to treat \"c*\" as a single character, not two. So if s = \"aab\" and p = \"c * a * b\" we can choose to match \"c*\" to \"aab\" however many time we want, or not at all. Obviously c doesnt match a, so we choose not to. Then we need to match \"aab\" with the remainder of p, \"a* b\". We can choose to match \"a*\" to the first two chars of s, and then the b's match eachother. So this example would return True\nIt isnt \"c\" \"*\" \"a\" \"*\" \"b\", its \"c*\",\"a*\",\"b\", really only 3 characters, two of which we can use however many times we want."
                    },
                    {
                        "username": "cweibel73",
                        "content": "s =\\n\"aaba\"\\np =\\n\"ab*a*c*a\"\\n\\nUse Testcase\\nOutput\\ntrue\\nExpected\\nfalse\\n\\nWhy is this false?"
                    },
                    {
                        "username": "MeinerTR",
                        "content": "I think in p b* comes first and a* comes later. That must be the reason it's false."
                    },
                    {
                        "username": "xinlin-z",
                        "content": "One of my attempt failed by this case:\\n\"abc\"\\n\"a***abc\"\\n\\nBut, \"It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match.\"\\n\\n?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Idk why they have the ** as an acceptable character but you just need to ignore it if you ever come across a double star\\nProbably did it just to have increased complexity for this problem"
                    },
                    {
                        "username": "sober_junkie",
                        "content": "lol i ended up using pattern and matcher only to find out that there was a run time error for the last test case. this qn sucks"
                    },
                    {
                        "username": "fli033",
                        "content": "Non-deterministic Finite Automaton!!!!!"
                    },
                    {
                        "username": "charlie_1212",
                        "content": "Test case 354 passes the pattern `\"a***abc\"` but the instructions clearly state: \\n> It is guaranteed for each appearance of the character \\'*\\', there will be a previous valid character to match."
                    }
                ]
            },
            {
                "id": 1996110,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "The logic of * had me thinking for so long. SMH I need to think clearer"
                    },
                    {
                        "username": "charant587",
                        "content": "Try these Test Cases Before submitting\n\n\"aa\"\n\"a\"\n\"aa\"\n\"a*\"\n\"ab\"\n\".*\"\n\"abb\"\n\".*.\"\n\"baab\"\n\"baa*\"\n\"aab\"\n\"c*a*b\"\n\"aaaaaaaaaaaaaaaaaaab\"\n\"a*a*a*a*a*a*a*a*a*a*\"\n"
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\nThe given problem is about implementing regular expression matching with support for \\'.\\' and \\'*\\', where:\\n\\n- \\'.\\' matches any single character.\\n- \\'*\\' matches zero or more of the preceding element.\\n\\nThe goal is to check if the entire input string `s` matches the pattern `p` provided.\\n\\nFor example, given `s = \"aa\"` and `p = \"a*\"`, the output should be `True`. This is because the \\'*\\' means zero or more occurrences of the preceding element \\'a\\'. Therefore, by repeating \\'a\\' once, it becomes \"aa\", which matches the entire string \"aa\"."
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\u062D\\u0633\\u0646\\u064B\\u0627\\u060C \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062D\\u0644 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629. \\u064A\\u062A\\u0645\\u062B\\u0644 \\u0627\\u0644\\u0647\\u062F\\u0641 \\u0641\\u064A \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062A\\u0646\\u0641\\u064A\\u0630 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0648\\u0641\\u0642\\u064B\\u0627 \\u0644\\u0644\\u0634\\u0631\\u0648\\u0637 \\u0627\\u0644\\u0645\\u0630\\u0643\\u0648\\u0631\\u0629:\\n\\n- \\u0627\\u0644\\u0646\\u0642\\u0637\\u0629 \\'.\\' \\u062A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0623\\u064A \\u062D\\u0631\\u0641 \\u0648\\u0627\\u062D\\u062F.\\n- \\u0627\\u0644\\u0631\\u0645\\u0632 \\'*\\' \\u064A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0635\\u0641\\u0631 \\u0623\\u0648 \\u0623\\u0643\\u062B\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0639\\u0646\\u0635\\u0631 \\u0627\\u0644\\u0630\\u064A \\u064A\\u0633\\u0628\\u0642\\u0647.\\n\\n\\u0644\\u062D\\u0644 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629\\u060C \\u064A\\u0645\\u0643\\u0646\\u0646\\u0627 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062A\\u0642\\u0646\\u064A\\u0629 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A (recursion) \\u0623\\u0648 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062C\\u062F\\u0648\\u0644 (dynamic programming) \\u0644\\u062A\\u062E\\u0632\\u064A\\u0646 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0633\\u0623\\u0633\\u062A\\u062E\\u062F\\u0645 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A \\u0647\\u0646\\u0627:\\n\\n```python\\ndef isMatch(s, p):\\n    # \\u0625\\u0630\\u0627 \\u0627\\u0646\\u062A\\u0647\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0648\\u0627\\u0644\\u0646\\u0635\\u060C \\u064A\\u0639\\u062A\\u0628\\u0631\\u0627\\u0646 \\u0645\\u062A\\u0637\\u0627\\u0628\\u0642\\u064A\\u0646\\n    if not p:\\n        return not s\\n\\n    # \\u0646\\u062A\\u062D\\u0642\\u0642 \\u0645\\u0645\\u0627 \\u0625\\u0630\\u0627 \\u0643\\u0627\\u0646\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u062A\\u062D\\u062A\\u0648\\u064A \\u0639\\u0644\\u0649 \\u0631\\u0645\\u0632 *\\n    if len(p) > 1 and p[1] == \\'*\\':\\n        # \\u0625\\u0630\\u0627 \\u0642\\u0645\\u0646\\u0627 \\u0628\\u062A\\u062C\\u0627\\u0648\\u0632 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0648\\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A \\u0628\\u0634\\u0643\\u0644 \\u0645\\u0628\\u0627\\u0634\\u0631\\u060C \\u0646\\u062D\\u0627\\u0648\\u0644 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u0646\\u0635 \\u0628\\u062F\\u0648\\u0646 \\u062A\\u0644\\u0643 \\u0627\\u0644\\u0623\\u062D\\u0631\\u0641.\\n        return isMatch(s, p[2:]) or (bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p))\\n    else:\\n        # \\u0641\\u064A \\u062D\\u0627\\u0644\\u0629 \\u0639\\u062F\\u0645 \\u0648\\u062C\\u0648\\u062F \\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A\\u060C \\u0646\\u0642\\u0648\\u0645 \\u0628\\u0645\\u0642\\u0627\\u0631\\u0646\\u0629 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0635.\\n        return bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p[1:])\\n\\n# \\u0645\\u062B\\u0627\\u0644\\ns = \"aa\"\\np = \"a\"\\nprint(isMatch(s, p))  # \\u0627\\u0644\\u0646\\u062A\\u064A\\u062C\\u0629 \\u0633\\u062A\\u0643\\u0648\\u0646: False\\n```\\n\\n\\u064A\\u0639\\u062A\\u0628\\u0631 \\u0627\\u0644\\u062D\\u0644 \\u0623\\u0639\\u0644\\u0627\\u0647 \\u0628\\u0633\\u064A\\u0637\\u064B\\u0627 \\u0648\\u064A\\u0645\\u0643\\u0646 \\u062A\\u062D\\u0633\\u064A\\u0646\\u0647 \\u0628\\u0625\\u0636\\u0627\\u0641\\u0629 \\u0630\\u0627\\u0643\\u0631\\u0629 \\u062A\\u062E\\u0632\\u064A\\u0646 \\u0644\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u062A\\u062C\\u0646\\u0628 \\u062D\\u0633\\u0627\\u0628 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0646\\u0641\\u0633\\u0647\\u0627 \\u0645\\u0631\\u0627\\u0631\\u064B\\u0627 \\u0648\\u062A\\u0643\\u0631\\u0627\\u0631\\u064B\\u0627. \\u0648\\u0645\\u0639 \\u0630\\u0644\\u0643\\u060C \\u0647\\u0630\\u0627 \\u0627\\u0644\\u062D\\u0644 \\u064A\\u0639\\u0637\\u064A\\u0643 \\u0641\\u0643\\u0631\\u0629 \\u0639\\u0627\\u0645\\u0629 \\u0639\\u0646 \\u0643\\u064A\\u0641\\u064A\\u0629 \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0639\\u0645\\u0644\\u064A\\u0629 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0648\\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "You can use the regex modul built-in in Python, but be mindfull for the cases with multiple \"***\"."
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "I think that\\'s cheating, the point is to implement your own regex matching. otherwise this would be easy."
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "how could this be ```s  = \"aaa\" and p = \"ab*a*c*a\" is  \"TRUE\"```\nand ```s = \"a\" and p = \"ab*a\" is \"FALSE\"```\n\nas atlast they both ends with some sort of same pattern...????"
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "[@TwilightTraveler](/TwilightTraveler) it\\'s my mistake, there is \"a\" in the end...but still the result is same ...the first one returns true and the second one returns false...how it would be possible...?"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "The first one shouldn\\'t match either, are you sure there is a d at the end?"
                    },
                    {
                        "username": "filiptodev",
                        "content": "I see a lot of people struggling to understand why some of the patterns match when they seem like they shouldn\\'t, and vice-versa. Here\\'s a way I used to conceptually simplify the pattern visually in order to understand it better when I\\'m manually debugging:\\n\\n- Replace all \\'.*\\' with [?], denoting a list of any number of random characters, or none\\n- Replace all \\'.\\' with the number of times it appears in sequence, so if we have \\'...\\' then [3], or \\'.\\' then [1], denoting how many random characters must follow\\n- Combine \\'*\\' with it\\'s preceding character in a list, so \\'c*\\' becomes \\'[c*]\\'\\n\\nSo then some crazy pattern like this: \"asd...wefg.*bdfh..dfhwer*f*dgs.*mhrsdf\"\\nBecomes this: asd[3]wefg[?]bdfh[2]dfhwe[r*][f*]dgs[?]mhrsdf\\n\\nThis may seem strange, but I find it important to isolate the characters that MUST be present making it clearer to understand the variable elements in between. Just don\\'t forget that [r*] means ZERO or more of \\'r\\', so if there is no \\'r\\', it\\'s still valid."
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "For those of you who have studied Theory of Computation, Regular Expression is basically a string of characters which signifies the transition function between different states of a Finite Automata. It took me a while to realize that.\\nJust remember that \"a*\" basically means \"epsilon (empty string)\", or \"a\", or \"aa\", or \"aaa\" and so on. It is called the Kleene Closure of \"a\". So \"a*\" basically maps to no occurence of \"a\" to infinite occurences of \"a\" concatenated."
                    },
                    {
                        "username": "shrishrajgupta",
                        "content": "a* ->  \"\" , \"a\" ,\"aaaaa....\""
                    },
                    {
                        "username": "JosephPurcell",
                        "content": "Test case 304 is bad. Both true and false result meet the constraints for this test case."
                    }
                ]
            },
            {
                "id": 1995921,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "The logic of * had me thinking for so long. SMH I need to think clearer"
                    },
                    {
                        "username": "charant587",
                        "content": "Try these Test Cases Before submitting\n\n\"aa\"\n\"a\"\n\"aa\"\n\"a*\"\n\"ab\"\n\".*\"\n\"abb\"\n\".*.\"\n\"baab\"\n\"baa*\"\n\"aab\"\n\"c*a*b\"\n\"aaaaaaaaaaaaaaaaaaab\"\n\"a*a*a*a*a*a*a*a*a*a*\"\n"
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\nThe given problem is about implementing regular expression matching with support for \\'.\\' and \\'*\\', where:\\n\\n- \\'.\\' matches any single character.\\n- \\'*\\' matches zero or more of the preceding element.\\n\\nThe goal is to check if the entire input string `s` matches the pattern `p` provided.\\n\\nFor example, given `s = \"aa\"` and `p = \"a*\"`, the output should be `True`. This is because the \\'*\\' means zero or more occurrences of the preceding element \\'a\\'. Therefore, by repeating \\'a\\' once, it becomes \"aa\", which matches the entire string \"aa\"."
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\u062D\\u0633\\u0646\\u064B\\u0627\\u060C \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062D\\u0644 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629. \\u064A\\u062A\\u0645\\u062B\\u0644 \\u0627\\u0644\\u0647\\u062F\\u0641 \\u0641\\u064A \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062A\\u0646\\u0641\\u064A\\u0630 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0648\\u0641\\u0642\\u064B\\u0627 \\u0644\\u0644\\u0634\\u0631\\u0648\\u0637 \\u0627\\u0644\\u0645\\u0630\\u0643\\u0648\\u0631\\u0629:\\n\\n- \\u0627\\u0644\\u0646\\u0642\\u0637\\u0629 \\'.\\' \\u062A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0623\\u064A \\u062D\\u0631\\u0641 \\u0648\\u0627\\u062D\\u062F.\\n- \\u0627\\u0644\\u0631\\u0645\\u0632 \\'*\\' \\u064A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0635\\u0641\\u0631 \\u0623\\u0648 \\u0623\\u0643\\u062B\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0639\\u0646\\u0635\\u0631 \\u0627\\u0644\\u0630\\u064A \\u064A\\u0633\\u0628\\u0642\\u0647.\\n\\n\\u0644\\u062D\\u0644 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629\\u060C \\u064A\\u0645\\u0643\\u0646\\u0646\\u0627 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062A\\u0642\\u0646\\u064A\\u0629 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A (recursion) \\u0623\\u0648 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062C\\u062F\\u0648\\u0644 (dynamic programming) \\u0644\\u062A\\u062E\\u0632\\u064A\\u0646 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0633\\u0623\\u0633\\u062A\\u062E\\u062F\\u0645 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A \\u0647\\u0646\\u0627:\\n\\n```python\\ndef isMatch(s, p):\\n    # \\u0625\\u0630\\u0627 \\u0627\\u0646\\u062A\\u0647\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0648\\u0627\\u0644\\u0646\\u0635\\u060C \\u064A\\u0639\\u062A\\u0628\\u0631\\u0627\\u0646 \\u0645\\u062A\\u0637\\u0627\\u0628\\u0642\\u064A\\u0646\\n    if not p:\\n        return not s\\n\\n    # \\u0646\\u062A\\u062D\\u0642\\u0642 \\u0645\\u0645\\u0627 \\u0625\\u0630\\u0627 \\u0643\\u0627\\u0646\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u062A\\u062D\\u062A\\u0648\\u064A \\u0639\\u0644\\u0649 \\u0631\\u0645\\u0632 *\\n    if len(p) > 1 and p[1] == \\'*\\':\\n        # \\u0625\\u0630\\u0627 \\u0642\\u0645\\u0646\\u0627 \\u0628\\u062A\\u062C\\u0627\\u0648\\u0632 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0648\\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A \\u0628\\u0634\\u0643\\u0644 \\u0645\\u0628\\u0627\\u0634\\u0631\\u060C \\u0646\\u062D\\u0627\\u0648\\u0644 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u0646\\u0635 \\u0628\\u062F\\u0648\\u0646 \\u062A\\u0644\\u0643 \\u0627\\u0644\\u0623\\u062D\\u0631\\u0641.\\n        return isMatch(s, p[2:]) or (bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p))\\n    else:\\n        # \\u0641\\u064A \\u062D\\u0627\\u0644\\u0629 \\u0639\\u062F\\u0645 \\u0648\\u062C\\u0648\\u062F \\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A\\u060C \\u0646\\u0642\\u0648\\u0645 \\u0628\\u0645\\u0642\\u0627\\u0631\\u0646\\u0629 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0635.\\n        return bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p[1:])\\n\\n# \\u0645\\u062B\\u0627\\u0644\\ns = \"aa\"\\np = \"a\"\\nprint(isMatch(s, p))  # \\u0627\\u0644\\u0646\\u062A\\u064A\\u062C\\u0629 \\u0633\\u062A\\u0643\\u0648\\u0646: False\\n```\\n\\n\\u064A\\u0639\\u062A\\u0628\\u0631 \\u0627\\u0644\\u062D\\u0644 \\u0623\\u0639\\u0644\\u0627\\u0647 \\u0628\\u0633\\u064A\\u0637\\u064B\\u0627 \\u0648\\u064A\\u0645\\u0643\\u0646 \\u062A\\u062D\\u0633\\u064A\\u0646\\u0647 \\u0628\\u0625\\u0636\\u0627\\u0641\\u0629 \\u0630\\u0627\\u0643\\u0631\\u0629 \\u062A\\u062E\\u0632\\u064A\\u0646 \\u0644\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u062A\\u062C\\u0646\\u0628 \\u062D\\u0633\\u0627\\u0628 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0646\\u0641\\u0633\\u0647\\u0627 \\u0645\\u0631\\u0627\\u0631\\u064B\\u0627 \\u0648\\u062A\\u0643\\u0631\\u0627\\u0631\\u064B\\u0627. \\u0648\\u0645\\u0639 \\u0630\\u0644\\u0643\\u060C \\u0647\\u0630\\u0627 \\u0627\\u0644\\u062D\\u0644 \\u064A\\u0639\\u0637\\u064A\\u0643 \\u0641\\u0643\\u0631\\u0629 \\u0639\\u0627\\u0645\\u0629 \\u0639\\u0646 \\u0643\\u064A\\u0641\\u064A\\u0629 \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0639\\u0645\\u0644\\u064A\\u0629 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0648\\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "You can use the regex modul built-in in Python, but be mindfull for the cases with multiple \"***\"."
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "I think that\\'s cheating, the point is to implement your own regex matching. otherwise this would be easy."
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "how could this be ```s  = \"aaa\" and p = \"ab*a*c*a\" is  \"TRUE\"```\nand ```s = \"a\" and p = \"ab*a\" is \"FALSE\"```\n\nas atlast they both ends with some sort of same pattern...????"
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "[@TwilightTraveler](/TwilightTraveler) it\\'s my mistake, there is \"a\" in the end...but still the result is same ...the first one returns true and the second one returns false...how it would be possible...?"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "The first one shouldn\\'t match either, are you sure there is a d at the end?"
                    },
                    {
                        "username": "filiptodev",
                        "content": "I see a lot of people struggling to understand why some of the patterns match when they seem like they shouldn\\'t, and vice-versa. Here\\'s a way I used to conceptually simplify the pattern visually in order to understand it better when I\\'m manually debugging:\\n\\n- Replace all \\'.*\\' with [?], denoting a list of any number of random characters, or none\\n- Replace all \\'.\\' with the number of times it appears in sequence, so if we have \\'...\\' then [3], or \\'.\\' then [1], denoting how many random characters must follow\\n- Combine \\'*\\' with it\\'s preceding character in a list, so \\'c*\\' becomes \\'[c*]\\'\\n\\nSo then some crazy pattern like this: \"asd...wefg.*bdfh..dfhwer*f*dgs.*mhrsdf\"\\nBecomes this: asd[3]wefg[?]bdfh[2]dfhwe[r*][f*]dgs[?]mhrsdf\\n\\nThis may seem strange, but I find it important to isolate the characters that MUST be present making it clearer to understand the variable elements in between. Just don\\'t forget that [r*] means ZERO or more of \\'r\\', so if there is no \\'r\\', it\\'s still valid."
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "For those of you who have studied Theory of Computation, Regular Expression is basically a string of characters which signifies the transition function between different states of a Finite Automata. It took me a while to realize that.\\nJust remember that \"a*\" basically means \"epsilon (empty string)\", or \"a\", or \"aa\", or \"aaa\" and so on. It is called the Kleene Closure of \"a\". So \"a*\" basically maps to no occurence of \"a\" to infinite occurences of \"a\" concatenated."
                    },
                    {
                        "username": "shrishrajgupta",
                        "content": "a* ->  \"\" , \"a\" ,\"aaaaa....\""
                    },
                    {
                        "username": "JosephPurcell",
                        "content": "Test case 304 is bad. Both true and false result meet the constraints for this test case."
                    }
                ]
            },
            {
                "id": 1995199,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "The logic of * had me thinking for so long. SMH I need to think clearer"
                    },
                    {
                        "username": "charant587",
                        "content": "Try these Test Cases Before submitting\n\n\"aa\"\n\"a\"\n\"aa\"\n\"a*\"\n\"ab\"\n\".*\"\n\"abb\"\n\".*.\"\n\"baab\"\n\"baa*\"\n\"aab\"\n\"c*a*b\"\n\"aaaaaaaaaaaaaaaaaaab\"\n\"a*a*a*a*a*a*a*a*a*a*\"\n"
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\nThe given problem is about implementing regular expression matching with support for \\'.\\' and \\'*\\', where:\\n\\n- \\'.\\' matches any single character.\\n- \\'*\\' matches zero or more of the preceding element.\\n\\nThe goal is to check if the entire input string `s` matches the pattern `p` provided.\\n\\nFor example, given `s = \"aa\"` and `p = \"a*\"`, the output should be `True`. This is because the \\'*\\' means zero or more occurrences of the preceding element \\'a\\'. Therefore, by repeating \\'a\\' once, it becomes \"aa\", which matches the entire string \"aa\"."
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\u062D\\u0633\\u0646\\u064B\\u0627\\u060C \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062D\\u0644 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629. \\u064A\\u062A\\u0645\\u062B\\u0644 \\u0627\\u0644\\u0647\\u062F\\u0641 \\u0641\\u064A \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062A\\u0646\\u0641\\u064A\\u0630 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0648\\u0641\\u0642\\u064B\\u0627 \\u0644\\u0644\\u0634\\u0631\\u0648\\u0637 \\u0627\\u0644\\u0645\\u0630\\u0643\\u0648\\u0631\\u0629:\\n\\n- \\u0627\\u0644\\u0646\\u0642\\u0637\\u0629 \\'.\\' \\u062A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0623\\u064A \\u062D\\u0631\\u0641 \\u0648\\u0627\\u062D\\u062F.\\n- \\u0627\\u0644\\u0631\\u0645\\u0632 \\'*\\' \\u064A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0635\\u0641\\u0631 \\u0623\\u0648 \\u0623\\u0643\\u062B\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0639\\u0646\\u0635\\u0631 \\u0627\\u0644\\u0630\\u064A \\u064A\\u0633\\u0628\\u0642\\u0647.\\n\\n\\u0644\\u062D\\u0644 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629\\u060C \\u064A\\u0645\\u0643\\u0646\\u0646\\u0627 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062A\\u0642\\u0646\\u064A\\u0629 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A (recursion) \\u0623\\u0648 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062C\\u062F\\u0648\\u0644 (dynamic programming) \\u0644\\u062A\\u062E\\u0632\\u064A\\u0646 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0633\\u0623\\u0633\\u062A\\u062E\\u062F\\u0645 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A \\u0647\\u0646\\u0627:\\n\\n```python\\ndef isMatch(s, p):\\n    # \\u0625\\u0630\\u0627 \\u0627\\u0646\\u062A\\u0647\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0648\\u0627\\u0644\\u0646\\u0635\\u060C \\u064A\\u0639\\u062A\\u0628\\u0631\\u0627\\u0646 \\u0645\\u062A\\u0637\\u0627\\u0628\\u0642\\u064A\\u0646\\n    if not p:\\n        return not s\\n\\n    # \\u0646\\u062A\\u062D\\u0642\\u0642 \\u0645\\u0645\\u0627 \\u0625\\u0630\\u0627 \\u0643\\u0627\\u0646\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u062A\\u062D\\u062A\\u0648\\u064A \\u0639\\u0644\\u0649 \\u0631\\u0645\\u0632 *\\n    if len(p) > 1 and p[1] == \\'*\\':\\n        # \\u0625\\u0630\\u0627 \\u0642\\u0645\\u0646\\u0627 \\u0628\\u062A\\u062C\\u0627\\u0648\\u0632 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0648\\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A \\u0628\\u0634\\u0643\\u0644 \\u0645\\u0628\\u0627\\u0634\\u0631\\u060C \\u0646\\u062D\\u0627\\u0648\\u0644 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u0646\\u0635 \\u0628\\u062F\\u0648\\u0646 \\u062A\\u0644\\u0643 \\u0627\\u0644\\u0623\\u062D\\u0631\\u0641.\\n        return isMatch(s, p[2:]) or (bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p))\\n    else:\\n        # \\u0641\\u064A \\u062D\\u0627\\u0644\\u0629 \\u0639\\u062F\\u0645 \\u0648\\u062C\\u0648\\u062F \\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A\\u060C \\u0646\\u0642\\u0648\\u0645 \\u0628\\u0645\\u0642\\u0627\\u0631\\u0646\\u0629 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0635.\\n        return bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p[1:])\\n\\n# \\u0645\\u062B\\u0627\\u0644\\ns = \"aa\"\\np = \"a\"\\nprint(isMatch(s, p))  # \\u0627\\u0644\\u0646\\u062A\\u064A\\u062C\\u0629 \\u0633\\u062A\\u0643\\u0648\\u0646: False\\n```\\n\\n\\u064A\\u0639\\u062A\\u0628\\u0631 \\u0627\\u0644\\u062D\\u0644 \\u0623\\u0639\\u0644\\u0627\\u0647 \\u0628\\u0633\\u064A\\u0637\\u064B\\u0627 \\u0648\\u064A\\u0645\\u0643\\u0646 \\u062A\\u062D\\u0633\\u064A\\u0646\\u0647 \\u0628\\u0625\\u0636\\u0627\\u0641\\u0629 \\u0630\\u0627\\u0643\\u0631\\u0629 \\u062A\\u062E\\u0632\\u064A\\u0646 \\u0644\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u062A\\u062C\\u0646\\u0628 \\u062D\\u0633\\u0627\\u0628 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0646\\u0641\\u0633\\u0647\\u0627 \\u0645\\u0631\\u0627\\u0631\\u064B\\u0627 \\u0648\\u062A\\u0643\\u0631\\u0627\\u0631\\u064B\\u0627. \\u0648\\u0645\\u0639 \\u0630\\u0644\\u0643\\u060C \\u0647\\u0630\\u0627 \\u0627\\u0644\\u062D\\u0644 \\u064A\\u0639\\u0637\\u064A\\u0643 \\u0641\\u0643\\u0631\\u0629 \\u0639\\u0627\\u0645\\u0629 \\u0639\\u0646 \\u0643\\u064A\\u0641\\u064A\\u0629 \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0639\\u0645\\u0644\\u064A\\u0629 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0648\\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "You can use the regex modul built-in in Python, but be mindfull for the cases with multiple \"***\"."
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "I think that\\'s cheating, the point is to implement your own regex matching. otherwise this would be easy."
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "how could this be ```s  = \"aaa\" and p = \"ab*a*c*a\" is  \"TRUE\"```\nand ```s = \"a\" and p = \"ab*a\" is \"FALSE\"```\n\nas atlast they both ends with some sort of same pattern...????"
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "[@TwilightTraveler](/TwilightTraveler) it\\'s my mistake, there is \"a\" in the end...but still the result is same ...the first one returns true and the second one returns false...how it would be possible...?"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "The first one shouldn\\'t match either, are you sure there is a d at the end?"
                    },
                    {
                        "username": "filiptodev",
                        "content": "I see a lot of people struggling to understand why some of the patterns match when they seem like they shouldn\\'t, and vice-versa. Here\\'s a way I used to conceptually simplify the pattern visually in order to understand it better when I\\'m manually debugging:\\n\\n- Replace all \\'.*\\' with [?], denoting a list of any number of random characters, or none\\n- Replace all \\'.\\' with the number of times it appears in sequence, so if we have \\'...\\' then [3], or \\'.\\' then [1], denoting how many random characters must follow\\n- Combine \\'*\\' with it\\'s preceding character in a list, so \\'c*\\' becomes \\'[c*]\\'\\n\\nSo then some crazy pattern like this: \"asd...wefg.*bdfh..dfhwer*f*dgs.*mhrsdf\"\\nBecomes this: asd[3]wefg[?]bdfh[2]dfhwe[r*][f*]dgs[?]mhrsdf\\n\\nThis may seem strange, but I find it important to isolate the characters that MUST be present making it clearer to understand the variable elements in between. Just don\\'t forget that [r*] means ZERO or more of \\'r\\', so if there is no \\'r\\', it\\'s still valid."
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "For those of you who have studied Theory of Computation, Regular Expression is basically a string of characters which signifies the transition function between different states of a Finite Automata. It took me a while to realize that.\\nJust remember that \"a*\" basically means \"epsilon (empty string)\", or \"a\", or \"aa\", or \"aaa\" and so on. It is called the Kleene Closure of \"a\". So \"a*\" basically maps to no occurence of \"a\" to infinite occurences of \"a\" concatenated."
                    },
                    {
                        "username": "shrishrajgupta",
                        "content": "a* ->  \"\" , \"a\" ,\"aaaaa....\""
                    },
                    {
                        "username": "JosephPurcell",
                        "content": "Test case 304 is bad. Both true and false result meet the constraints for this test case."
                    }
                ]
            },
            {
                "id": 1995195,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "The logic of * had me thinking for so long. SMH I need to think clearer"
                    },
                    {
                        "username": "charant587",
                        "content": "Try these Test Cases Before submitting\n\n\"aa\"\n\"a\"\n\"aa\"\n\"a*\"\n\"ab\"\n\".*\"\n\"abb\"\n\".*.\"\n\"baab\"\n\"baa*\"\n\"aab\"\n\"c*a*b\"\n\"aaaaaaaaaaaaaaaaaaab\"\n\"a*a*a*a*a*a*a*a*a*a*\"\n"
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\nThe given problem is about implementing regular expression matching with support for \\'.\\' and \\'*\\', where:\\n\\n- \\'.\\' matches any single character.\\n- \\'*\\' matches zero or more of the preceding element.\\n\\nThe goal is to check if the entire input string `s` matches the pattern `p` provided.\\n\\nFor example, given `s = \"aa\"` and `p = \"a*\"`, the output should be `True`. This is because the \\'*\\' means zero or more occurrences of the preceding element \\'a\\'. Therefore, by repeating \\'a\\' once, it becomes \"aa\", which matches the entire string \"aa\"."
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\u062D\\u0633\\u0646\\u064B\\u0627\\u060C \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062D\\u0644 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629. \\u064A\\u062A\\u0645\\u062B\\u0644 \\u0627\\u0644\\u0647\\u062F\\u0641 \\u0641\\u064A \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062A\\u0646\\u0641\\u064A\\u0630 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0648\\u0641\\u0642\\u064B\\u0627 \\u0644\\u0644\\u0634\\u0631\\u0648\\u0637 \\u0627\\u0644\\u0645\\u0630\\u0643\\u0648\\u0631\\u0629:\\n\\n- \\u0627\\u0644\\u0646\\u0642\\u0637\\u0629 \\'.\\' \\u062A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0623\\u064A \\u062D\\u0631\\u0641 \\u0648\\u0627\\u062D\\u062F.\\n- \\u0627\\u0644\\u0631\\u0645\\u0632 \\'*\\' \\u064A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0635\\u0641\\u0631 \\u0623\\u0648 \\u0623\\u0643\\u062B\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0639\\u0646\\u0635\\u0631 \\u0627\\u0644\\u0630\\u064A \\u064A\\u0633\\u0628\\u0642\\u0647.\\n\\n\\u0644\\u062D\\u0644 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629\\u060C \\u064A\\u0645\\u0643\\u0646\\u0646\\u0627 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062A\\u0642\\u0646\\u064A\\u0629 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A (recursion) \\u0623\\u0648 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062C\\u062F\\u0648\\u0644 (dynamic programming) \\u0644\\u062A\\u062E\\u0632\\u064A\\u0646 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0633\\u0623\\u0633\\u062A\\u062E\\u062F\\u0645 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A \\u0647\\u0646\\u0627:\\n\\n```python\\ndef isMatch(s, p):\\n    # \\u0625\\u0630\\u0627 \\u0627\\u0646\\u062A\\u0647\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0648\\u0627\\u0644\\u0646\\u0635\\u060C \\u064A\\u0639\\u062A\\u0628\\u0631\\u0627\\u0646 \\u0645\\u062A\\u0637\\u0627\\u0628\\u0642\\u064A\\u0646\\n    if not p:\\n        return not s\\n\\n    # \\u0646\\u062A\\u062D\\u0642\\u0642 \\u0645\\u0645\\u0627 \\u0625\\u0630\\u0627 \\u0643\\u0627\\u0646\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u062A\\u062D\\u062A\\u0648\\u064A \\u0639\\u0644\\u0649 \\u0631\\u0645\\u0632 *\\n    if len(p) > 1 and p[1] == \\'*\\':\\n        # \\u0625\\u0630\\u0627 \\u0642\\u0645\\u0646\\u0627 \\u0628\\u062A\\u062C\\u0627\\u0648\\u0632 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0648\\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A \\u0628\\u0634\\u0643\\u0644 \\u0645\\u0628\\u0627\\u0634\\u0631\\u060C \\u0646\\u062D\\u0627\\u0648\\u0644 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u0646\\u0635 \\u0628\\u062F\\u0648\\u0646 \\u062A\\u0644\\u0643 \\u0627\\u0644\\u0623\\u062D\\u0631\\u0641.\\n        return isMatch(s, p[2:]) or (bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p))\\n    else:\\n        # \\u0641\\u064A \\u062D\\u0627\\u0644\\u0629 \\u0639\\u062F\\u0645 \\u0648\\u062C\\u0648\\u062F \\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A\\u060C \\u0646\\u0642\\u0648\\u0645 \\u0628\\u0645\\u0642\\u0627\\u0631\\u0646\\u0629 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0635.\\n        return bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p[1:])\\n\\n# \\u0645\\u062B\\u0627\\u0644\\ns = \"aa\"\\np = \"a\"\\nprint(isMatch(s, p))  # \\u0627\\u0644\\u0646\\u062A\\u064A\\u062C\\u0629 \\u0633\\u062A\\u0643\\u0648\\u0646: False\\n```\\n\\n\\u064A\\u0639\\u062A\\u0628\\u0631 \\u0627\\u0644\\u062D\\u0644 \\u0623\\u0639\\u0644\\u0627\\u0647 \\u0628\\u0633\\u064A\\u0637\\u064B\\u0627 \\u0648\\u064A\\u0645\\u0643\\u0646 \\u062A\\u062D\\u0633\\u064A\\u0646\\u0647 \\u0628\\u0625\\u0636\\u0627\\u0641\\u0629 \\u0630\\u0627\\u0643\\u0631\\u0629 \\u062A\\u062E\\u0632\\u064A\\u0646 \\u0644\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u062A\\u062C\\u0646\\u0628 \\u062D\\u0633\\u0627\\u0628 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0646\\u0641\\u0633\\u0647\\u0627 \\u0645\\u0631\\u0627\\u0631\\u064B\\u0627 \\u0648\\u062A\\u0643\\u0631\\u0627\\u0631\\u064B\\u0627. \\u0648\\u0645\\u0639 \\u0630\\u0644\\u0643\\u060C \\u0647\\u0630\\u0627 \\u0627\\u0644\\u062D\\u0644 \\u064A\\u0639\\u0637\\u064A\\u0643 \\u0641\\u0643\\u0631\\u0629 \\u0639\\u0627\\u0645\\u0629 \\u0639\\u0646 \\u0643\\u064A\\u0641\\u064A\\u0629 \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0639\\u0645\\u0644\\u064A\\u0629 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0648\\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "You can use the regex modul built-in in Python, but be mindfull for the cases with multiple \"***\"."
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "I think that\\'s cheating, the point is to implement your own regex matching. otherwise this would be easy."
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "how could this be ```s  = \"aaa\" and p = \"ab*a*c*a\" is  \"TRUE\"```\nand ```s = \"a\" and p = \"ab*a\" is \"FALSE\"```\n\nas atlast they both ends with some sort of same pattern...????"
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "[@TwilightTraveler](/TwilightTraveler) it\\'s my mistake, there is \"a\" in the end...but still the result is same ...the first one returns true and the second one returns false...how it would be possible...?"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "The first one shouldn\\'t match either, are you sure there is a d at the end?"
                    },
                    {
                        "username": "filiptodev",
                        "content": "I see a lot of people struggling to understand why some of the patterns match when they seem like they shouldn\\'t, and vice-versa. Here\\'s a way I used to conceptually simplify the pattern visually in order to understand it better when I\\'m manually debugging:\\n\\n- Replace all \\'.*\\' with [?], denoting a list of any number of random characters, or none\\n- Replace all \\'.\\' with the number of times it appears in sequence, so if we have \\'...\\' then [3], or \\'.\\' then [1], denoting how many random characters must follow\\n- Combine \\'*\\' with it\\'s preceding character in a list, so \\'c*\\' becomes \\'[c*]\\'\\n\\nSo then some crazy pattern like this: \"asd...wefg.*bdfh..dfhwer*f*dgs.*mhrsdf\"\\nBecomes this: asd[3]wefg[?]bdfh[2]dfhwe[r*][f*]dgs[?]mhrsdf\\n\\nThis may seem strange, but I find it important to isolate the characters that MUST be present making it clearer to understand the variable elements in between. Just don\\'t forget that [r*] means ZERO or more of \\'r\\', so if there is no \\'r\\', it\\'s still valid."
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "For those of you who have studied Theory of Computation, Regular Expression is basically a string of characters which signifies the transition function between different states of a Finite Automata. It took me a while to realize that.\\nJust remember that \"a*\" basically means \"epsilon (empty string)\", or \"a\", or \"aa\", or \"aaa\" and so on. It is called the Kleene Closure of \"a\". So \"a*\" basically maps to no occurence of \"a\" to infinite occurences of \"a\" concatenated."
                    },
                    {
                        "username": "shrishrajgupta",
                        "content": "a* ->  \"\" , \"a\" ,\"aaaaa....\""
                    },
                    {
                        "username": "JosephPurcell",
                        "content": "Test case 304 is bad. Both true and false result meet the constraints for this test case."
                    }
                ]
            },
            {
                "id": 1990162,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "The logic of * had me thinking for so long. SMH I need to think clearer"
                    },
                    {
                        "username": "charant587",
                        "content": "Try these Test Cases Before submitting\n\n\"aa\"\n\"a\"\n\"aa\"\n\"a*\"\n\"ab\"\n\".*\"\n\"abb\"\n\".*.\"\n\"baab\"\n\"baa*\"\n\"aab\"\n\"c*a*b\"\n\"aaaaaaaaaaaaaaaaaaab\"\n\"a*a*a*a*a*a*a*a*a*a*\"\n"
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\nThe given problem is about implementing regular expression matching with support for \\'.\\' and \\'*\\', where:\\n\\n- \\'.\\' matches any single character.\\n- \\'*\\' matches zero or more of the preceding element.\\n\\nThe goal is to check if the entire input string `s` matches the pattern `p` provided.\\n\\nFor example, given `s = \"aa\"` and `p = \"a*\"`, the output should be `True`. This is because the \\'*\\' means zero or more occurrences of the preceding element \\'a\\'. Therefore, by repeating \\'a\\' once, it becomes \"aa\", which matches the entire string \"aa\"."
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\u062D\\u0633\\u0646\\u064B\\u0627\\u060C \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062D\\u0644 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629. \\u064A\\u062A\\u0645\\u062B\\u0644 \\u0627\\u0644\\u0647\\u062F\\u0641 \\u0641\\u064A \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062A\\u0646\\u0641\\u064A\\u0630 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0648\\u0641\\u0642\\u064B\\u0627 \\u0644\\u0644\\u0634\\u0631\\u0648\\u0637 \\u0627\\u0644\\u0645\\u0630\\u0643\\u0648\\u0631\\u0629:\\n\\n- \\u0627\\u0644\\u0646\\u0642\\u0637\\u0629 \\'.\\' \\u062A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0623\\u064A \\u062D\\u0631\\u0641 \\u0648\\u0627\\u062D\\u062F.\\n- \\u0627\\u0644\\u0631\\u0645\\u0632 \\'*\\' \\u064A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0635\\u0641\\u0631 \\u0623\\u0648 \\u0623\\u0643\\u062B\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0639\\u0646\\u0635\\u0631 \\u0627\\u0644\\u0630\\u064A \\u064A\\u0633\\u0628\\u0642\\u0647.\\n\\n\\u0644\\u062D\\u0644 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629\\u060C \\u064A\\u0645\\u0643\\u0646\\u0646\\u0627 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062A\\u0642\\u0646\\u064A\\u0629 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A (recursion) \\u0623\\u0648 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062C\\u062F\\u0648\\u0644 (dynamic programming) \\u0644\\u062A\\u062E\\u0632\\u064A\\u0646 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0633\\u0623\\u0633\\u062A\\u062E\\u062F\\u0645 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A \\u0647\\u0646\\u0627:\\n\\n```python\\ndef isMatch(s, p):\\n    # \\u0625\\u0630\\u0627 \\u0627\\u0646\\u062A\\u0647\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0648\\u0627\\u0644\\u0646\\u0635\\u060C \\u064A\\u0639\\u062A\\u0628\\u0631\\u0627\\u0646 \\u0645\\u062A\\u0637\\u0627\\u0628\\u0642\\u064A\\u0646\\n    if not p:\\n        return not s\\n\\n    # \\u0646\\u062A\\u062D\\u0642\\u0642 \\u0645\\u0645\\u0627 \\u0625\\u0630\\u0627 \\u0643\\u0627\\u0646\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u062A\\u062D\\u062A\\u0648\\u064A \\u0639\\u0644\\u0649 \\u0631\\u0645\\u0632 *\\n    if len(p) > 1 and p[1] == \\'*\\':\\n        # \\u0625\\u0630\\u0627 \\u0642\\u0645\\u0646\\u0627 \\u0628\\u062A\\u062C\\u0627\\u0648\\u0632 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0648\\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A \\u0628\\u0634\\u0643\\u0644 \\u0645\\u0628\\u0627\\u0634\\u0631\\u060C \\u0646\\u062D\\u0627\\u0648\\u0644 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u0646\\u0635 \\u0628\\u062F\\u0648\\u0646 \\u062A\\u0644\\u0643 \\u0627\\u0644\\u0623\\u062D\\u0631\\u0641.\\n        return isMatch(s, p[2:]) or (bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p))\\n    else:\\n        # \\u0641\\u064A \\u062D\\u0627\\u0644\\u0629 \\u0639\\u062F\\u0645 \\u0648\\u062C\\u0648\\u062F \\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A\\u060C \\u0646\\u0642\\u0648\\u0645 \\u0628\\u0645\\u0642\\u0627\\u0631\\u0646\\u0629 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0635.\\n        return bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p[1:])\\n\\n# \\u0645\\u062B\\u0627\\u0644\\ns = \"aa\"\\np = \"a\"\\nprint(isMatch(s, p))  # \\u0627\\u0644\\u0646\\u062A\\u064A\\u062C\\u0629 \\u0633\\u062A\\u0643\\u0648\\u0646: False\\n```\\n\\n\\u064A\\u0639\\u062A\\u0628\\u0631 \\u0627\\u0644\\u062D\\u0644 \\u0623\\u0639\\u0644\\u0627\\u0647 \\u0628\\u0633\\u064A\\u0637\\u064B\\u0627 \\u0648\\u064A\\u0645\\u0643\\u0646 \\u062A\\u062D\\u0633\\u064A\\u0646\\u0647 \\u0628\\u0625\\u0636\\u0627\\u0641\\u0629 \\u0630\\u0627\\u0643\\u0631\\u0629 \\u062A\\u062E\\u0632\\u064A\\u0646 \\u0644\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u062A\\u062C\\u0646\\u0628 \\u062D\\u0633\\u0627\\u0628 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0646\\u0641\\u0633\\u0647\\u0627 \\u0645\\u0631\\u0627\\u0631\\u064B\\u0627 \\u0648\\u062A\\u0643\\u0631\\u0627\\u0631\\u064B\\u0627. \\u0648\\u0645\\u0639 \\u0630\\u0644\\u0643\\u060C \\u0647\\u0630\\u0627 \\u0627\\u0644\\u062D\\u0644 \\u064A\\u0639\\u0637\\u064A\\u0643 \\u0641\\u0643\\u0631\\u0629 \\u0639\\u0627\\u0645\\u0629 \\u0639\\u0646 \\u0643\\u064A\\u0641\\u064A\\u0629 \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0639\\u0645\\u0644\\u064A\\u0629 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0648\\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "You can use the regex modul built-in in Python, but be mindfull for the cases with multiple \"***\"."
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "I think that\\'s cheating, the point is to implement your own regex matching. otherwise this would be easy."
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "how could this be ```s  = \"aaa\" and p = \"ab*a*c*a\" is  \"TRUE\"```\nand ```s = \"a\" and p = \"ab*a\" is \"FALSE\"```\n\nas atlast they both ends with some sort of same pattern...????"
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "[@TwilightTraveler](/TwilightTraveler) it\\'s my mistake, there is \"a\" in the end...but still the result is same ...the first one returns true and the second one returns false...how it would be possible...?"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "The first one shouldn\\'t match either, are you sure there is a d at the end?"
                    },
                    {
                        "username": "filiptodev",
                        "content": "I see a lot of people struggling to understand why some of the patterns match when they seem like they shouldn\\'t, and vice-versa. Here\\'s a way I used to conceptually simplify the pattern visually in order to understand it better when I\\'m manually debugging:\\n\\n- Replace all \\'.*\\' with [?], denoting a list of any number of random characters, or none\\n- Replace all \\'.\\' with the number of times it appears in sequence, so if we have \\'...\\' then [3], or \\'.\\' then [1], denoting how many random characters must follow\\n- Combine \\'*\\' with it\\'s preceding character in a list, so \\'c*\\' becomes \\'[c*]\\'\\n\\nSo then some crazy pattern like this: \"asd...wefg.*bdfh..dfhwer*f*dgs.*mhrsdf\"\\nBecomes this: asd[3]wefg[?]bdfh[2]dfhwe[r*][f*]dgs[?]mhrsdf\\n\\nThis may seem strange, but I find it important to isolate the characters that MUST be present making it clearer to understand the variable elements in between. Just don\\'t forget that [r*] means ZERO or more of \\'r\\', so if there is no \\'r\\', it\\'s still valid."
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "For those of you who have studied Theory of Computation, Regular Expression is basically a string of characters which signifies the transition function between different states of a Finite Automata. It took me a while to realize that.\\nJust remember that \"a*\" basically means \"epsilon (empty string)\", or \"a\", or \"aa\", or \"aaa\" and so on. It is called the Kleene Closure of \"a\". So \"a*\" basically maps to no occurence of \"a\" to infinite occurences of \"a\" concatenated."
                    },
                    {
                        "username": "shrishrajgupta",
                        "content": "a* ->  \"\" , \"a\" ,\"aaaaa....\""
                    },
                    {
                        "username": "JosephPurcell",
                        "content": "Test case 304 is bad. Both true and false result meet the constraints for this test case."
                    }
                ]
            },
            {
                "id": 1988951,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "The logic of * had me thinking for so long. SMH I need to think clearer"
                    },
                    {
                        "username": "charant587",
                        "content": "Try these Test Cases Before submitting\n\n\"aa\"\n\"a\"\n\"aa\"\n\"a*\"\n\"ab\"\n\".*\"\n\"abb\"\n\".*.\"\n\"baab\"\n\"baa*\"\n\"aab\"\n\"c*a*b\"\n\"aaaaaaaaaaaaaaaaaaab\"\n\"a*a*a*a*a*a*a*a*a*a*\"\n"
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\nThe given problem is about implementing regular expression matching with support for \\'.\\' and \\'*\\', where:\\n\\n- \\'.\\' matches any single character.\\n- \\'*\\' matches zero or more of the preceding element.\\n\\nThe goal is to check if the entire input string `s` matches the pattern `p` provided.\\n\\nFor example, given `s = \"aa\"` and `p = \"a*\"`, the output should be `True`. This is because the \\'*\\' means zero or more occurrences of the preceding element \\'a\\'. Therefore, by repeating \\'a\\' once, it becomes \"aa\", which matches the entire string \"aa\"."
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\u062D\\u0633\\u0646\\u064B\\u0627\\u060C \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062D\\u0644 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629. \\u064A\\u062A\\u0645\\u062B\\u0644 \\u0627\\u0644\\u0647\\u062F\\u0641 \\u0641\\u064A \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062A\\u0646\\u0641\\u064A\\u0630 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0648\\u0641\\u0642\\u064B\\u0627 \\u0644\\u0644\\u0634\\u0631\\u0648\\u0637 \\u0627\\u0644\\u0645\\u0630\\u0643\\u0648\\u0631\\u0629:\\n\\n- \\u0627\\u0644\\u0646\\u0642\\u0637\\u0629 \\'.\\' \\u062A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0623\\u064A \\u062D\\u0631\\u0641 \\u0648\\u0627\\u062D\\u062F.\\n- \\u0627\\u0644\\u0631\\u0645\\u0632 \\'*\\' \\u064A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0635\\u0641\\u0631 \\u0623\\u0648 \\u0623\\u0643\\u062B\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0639\\u0646\\u0635\\u0631 \\u0627\\u0644\\u0630\\u064A \\u064A\\u0633\\u0628\\u0642\\u0647.\\n\\n\\u0644\\u062D\\u0644 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629\\u060C \\u064A\\u0645\\u0643\\u0646\\u0646\\u0627 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062A\\u0642\\u0646\\u064A\\u0629 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A (recursion) \\u0623\\u0648 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062C\\u062F\\u0648\\u0644 (dynamic programming) \\u0644\\u062A\\u062E\\u0632\\u064A\\u0646 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0633\\u0623\\u0633\\u062A\\u062E\\u062F\\u0645 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A \\u0647\\u0646\\u0627:\\n\\n```python\\ndef isMatch(s, p):\\n    # \\u0625\\u0630\\u0627 \\u0627\\u0646\\u062A\\u0647\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0648\\u0627\\u0644\\u0646\\u0635\\u060C \\u064A\\u0639\\u062A\\u0628\\u0631\\u0627\\u0646 \\u0645\\u062A\\u0637\\u0627\\u0628\\u0642\\u064A\\u0646\\n    if not p:\\n        return not s\\n\\n    # \\u0646\\u062A\\u062D\\u0642\\u0642 \\u0645\\u0645\\u0627 \\u0625\\u0630\\u0627 \\u0643\\u0627\\u0646\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u062A\\u062D\\u062A\\u0648\\u064A \\u0639\\u0644\\u0649 \\u0631\\u0645\\u0632 *\\n    if len(p) > 1 and p[1] == \\'*\\':\\n        # \\u0625\\u0630\\u0627 \\u0642\\u0645\\u0646\\u0627 \\u0628\\u062A\\u062C\\u0627\\u0648\\u0632 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0648\\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A \\u0628\\u0634\\u0643\\u0644 \\u0645\\u0628\\u0627\\u0634\\u0631\\u060C \\u0646\\u062D\\u0627\\u0648\\u0644 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u0646\\u0635 \\u0628\\u062F\\u0648\\u0646 \\u062A\\u0644\\u0643 \\u0627\\u0644\\u0623\\u062D\\u0631\\u0641.\\n        return isMatch(s, p[2:]) or (bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p))\\n    else:\\n        # \\u0641\\u064A \\u062D\\u0627\\u0644\\u0629 \\u0639\\u062F\\u0645 \\u0648\\u062C\\u0648\\u062F \\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A\\u060C \\u0646\\u0642\\u0648\\u0645 \\u0628\\u0645\\u0642\\u0627\\u0631\\u0646\\u0629 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0635.\\n        return bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p[1:])\\n\\n# \\u0645\\u062B\\u0627\\u0644\\ns = \"aa\"\\np = \"a\"\\nprint(isMatch(s, p))  # \\u0627\\u0644\\u0646\\u062A\\u064A\\u062C\\u0629 \\u0633\\u062A\\u0643\\u0648\\u0646: False\\n```\\n\\n\\u064A\\u0639\\u062A\\u0628\\u0631 \\u0627\\u0644\\u062D\\u0644 \\u0623\\u0639\\u0644\\u0627\\u0647 \\u0628\\u0633\\u064A\\u0637\\u064B\\u0627 \\u0648\\u064A\\u0645\\u0643\\u0646 \\u062A\\u062D\\u0633\\u064A\\u0646\\u0647 \\u0628\\u0625\\u0636\\u0627\\u0641\\u0629 \\u0630\\u0627\\u0643\\u0631\\u0629 \\u062A\\u062E\\u0632\\u064A\\u0646 \\u0644\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u062A\\u062C\\u0646\\u0628 \\u062D\\u0633\\u0627\\u0628 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0646\\u0641\\u0633\\u0647\\u0627 \\u0645\\u0631\\u0627\\u0631\\u064B\\u0627 \\u0648\\u062A\\u0643\\u0631\\u0627\\u0631\\u064B\\u0627. \\u0648\\u0645\\u0639 \\u0630\\u0644\\u0643\\u060C \\u0647\\u0630\\u0627 \\u0627\\u0644\\u062D\\u0644 \\u064A\\u0639\\u0637\\u064A\\u0643 \\u0641\\u0643\\u0631\\u0629 \\u0639\\u0627\\u0645\\u0629 \\u0639\\u0646 \\u0643\\u064A\\u0641\\u064A\\u0629 \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0639\\u0645\\u0644\\u064A\\u0629 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0648\\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "You can use the regex modul built-in in Python, but be mindfull for the cases with multiple \"***\"."
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "I think that\\'s cheating, the point is to implement your own regex matching. otherwise this would be easy."
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "how could this be ```s  = \"aaa\" and p = \"ab*a*c*a\" is  \"TRUE\"```\nand ```s = \"a\" and p = \"ab*a\" is \"FALSE\"```\n\nas atlast they both ends with some sort of same pattern...????"
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "[@TwilightTraveler](/TwilightTraveler) it\\'s my mistake, there is \"a\" in the end...but still the result is same ...the first one returns true and the second one returns false...how it would be possible...?"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "The first one shouldn\\'t match either, are you sure there is a d at the end?"
                    },
                    {
                        "username": "filiptodev",
                        "content": "I see a lot of people struggling to understand why some of the patterns match when they seem like they shouldn\\'t, and vice-versa. Here\\'s a way I used to conceptually simplify the pattern visually in order to understand it better when I\\'m manually debugging:\\n\\n- Replace all \\'.*\\' with [?], denoting a list of any number of random characters, or none\\n- Replace all \\'.\\' with the number of times it appears in sequence, so if we have \\'...\\' then [3], or \\'.\\' then [1], denoting how many random characters must follow\\n- Combine \\'*\\' with it\\'s preceding character in a list, so \\'c*\\' becomes \\'[c*]\\'\\n\\nSo then some crazy pattern like this: \"asd...wefg.*bdfh..dfhwer*f*dgs.*mhrsdf\"\\nBecomes this: asd[3]wefg[?]bdfh[2]dfhwe[r*][f*]dgs[?]mhrsdf\\n\\nThis may seem strange, but I find it important to isolate the characters that MUST be present making it clearer to understand the variable elements in between. Just don\\'t forget that [r*] means ZERO or more of \\'r\\', so if there is no \\'r\\', it\\'s still valid."
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "For those of you who have studied Theory of Computation, Regular Expression is basically a string of characters which signifies the transition function between different states of a Finite Automata. It took me a while to realize that.\\nJust remember that \"a*\" basically means \"epsilon (empty string)\", or \"a\", or \"aa\", or \"aaa\" and so on. It is called the Kleene Closure of \"a\". So \"a*\" basically maps to no occurence of \"a\" to infinite occurences of \"a\" concatenated."
                    },
                    {
                        "username": "shrishrajgupta",
                        "content": "a* ->  \"\" , \"a\" ,\"aaaaa....\""
                    },
                    {
                        "username": "JosephPurcell",
                        "content": "Test case 304 is bad. Both true and false result meet the constraints for this test case."
                    }
                ]
            },
            {
                "id": 1985295,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "The logic of * had me thinking for so long. SMH I need to think clearer"
                    },
                    {
                        "username": "charant587",
                        "content": "Try these Test Cases Before submitting\n\n\"aa\"\n\"a\"\n\"aa\"\n\"a*\"\n\"ab\"\n\".*\"\n\"abb\"\n\".*.\"\n\"baab\"\n\"baa*\"\n\"aab\"\n\"c*a*b\"\n\"aaaaaaaaaaaaaaaaaaab\"\n\"a*a*a*a*a*a*a*a*a*a*\"\n"
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\nThe given problem is about implementing regular expression matching with support for \\'.\\' and \\'*\\', where:\\n\\n- \\'.\\' matches any single character.\\n- \\'*\\' matches zero or more of the preceding element.\\n\\nThe goal is to check if the entire input string `s` matches the pattern `p` provided.\\n\\nFor example, given `s = \"aa\"` and `p = \"a*\"`, the output should be `True`. This is because the \\'*\\' means zero or more occurrences of the preceding element \\'a\\'. Therefore, by repeating \\'a\\' once, it becomes \"aa\", which matches the entire string \"aa\"."
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\u062D\\u0633\\u0646\\u064B\\u0627\\u060C \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062D\\u0644 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629. \\u064A\\u062A\\u0645\\u062B\\u0644 \\u0627\\u0644\\u0647\\u062F\\u0641 \\u0641\\u064A \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062A\\u0646\\u0641\\u064A\\u0630 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0648\\u0641\\u0642\\u064B\\u0627 \\u0644\\u0644\\u0634\\u0631\\u0648\\u0637 \\u0627\\u0644\\u0645\\u0630\\u0643\\u0648\\u0631\\u0629:\\n\\n- \\u0627\\u0644\\u0646\\u0642\\u0637\\u0629 \\'.\\' \\u062A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0623\\u064A \\u062D\\u0631\\u0641 \\u0648\\u0627\\u062D\\u062F.\\n- \\u0627\\u0644\\u0631\\u0645\\u0632 \\'*\\' \\u064A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0635\\u0641\\u0631 \\u0623\\u0648 \\u0623\\u0643\\u062B\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0639\\u0646\\u0635\\u0631 \\u0627\\u0644\\u0630\\u064A \\u064A\\u0633\\u0628\\u0642\\u0647.\\n\\n\\u0644\\u062D\\u0644 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629\\u060C \\u064A\\u0645\\u0643\\u0646\\u0646\\u0627 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062A\\u0642\\u0646\\u064A\\u0629 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A (recursion) \\u0623\\u0648 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062C\\u062F\\u0648\\u0644 (dynamic programming) \\u0644\\u062A\\u062E\\u0632\\u064A\\u0646 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0633\\u0623\\u0633\\u062A\\u062E\\u062F\\u0645 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A \\u0647\\u0646\\u0627:\\n\\n```python\\ndef isMatch(s, p):\\n    # \\u0625\\u0630\\u0627 \\u0627\\u0646\\u062A\\u0647\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0648\\u0627\\u0644\\u0646\\u0635\\u060C \\u064A\\u0639\\u062A\\u0628\\u0631\\u0627\\u0646 \\u0645\\u062A\\u0637\\u0627\\u0628\\u0642\\u064A\\u0646\\n    if not p:\\n        return not s\\n\\n    # \\u0646\\u062A\\u062D\\u0642\\u0642 \\u0645\\u0645\\u0627 \\u0625\\u0630\\u0627 \\u0643\\u0627\\u0646\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u062A\\u062D\\u062A\\u0648\\u064A \\u0639\\u0644\\u0649 \\u0631\\u0645\\u0632 *\\n    if len(p) > 1 and p[1] == \\'*\\':\\n        # \\u0625\\u0630\\u0627 \\u0642\\u0645\\u0646\\u0627 \\u0628\\u062A\\u062C\\u0627\\u0648\\u0632 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0648\\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A \\u0628\\u0634\\u0643\\u0644 \\u0645\\u0628\\u0627\\u0634\\u0631\\u060C \\u0646\\u062D\\u0627\\u0648\\u0644 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u0646\\u0635 \\u0628\\u062F\\u0648\\u0646 \\u062A\\u0644\\u0643 \\u0627\\u0644\\u0623\\u062D\\u0631\\u0641.\\n        return isMatch(s, p[2:]) or (bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p))\\n    else:\\n        # \\u0641\\u064A \\u062D\\u0627\\u0644\\u0629 \\u0639\\u062F\\u0645 \\u0648\\u062C\\u0648\\u062F \\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A\\u060C \\u0646\\u0642\\u0648\\u0645 \\u0628\\u0645\\u0642\\u0627\\u0631\\u0646\\u0629 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0635.\\n        return bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p[1:])\\n\\n# \\u0645\\u062B\\u0627\\u0644\\ns = \"aa\"\\np = \"a\"\\nprint(isMatch(s, p))  # \\u0627\\u0644\\u0646\\u062A\\u064A\\u062C\\u0629 \\u0633\\u062A\\u0643\\u0648\\u0646: False\\n```\\n\\n\\u064A\\u0639\\u062A\\u0628\\u0631 \\u0627\\u0644\\u062D\\u0644 \\u0623\\u0639\\u0644\\u0627\\u0647 \\u0628\\u0633\\u064A\\u0637\\u064B\\u0627 \\u0648\\u064A\\u0645\\u0643\\u0646 \\u062A\\u062D\\u0633\\u064A\\u0646\\u0647 \\u0628\\u0625\\u0636\\u0627\\u0641\\u0629 \\u0630\\u0627\\u0643\\u0631\\u0629 \\u062A\\u062E\\u0632\\u064A\\u0646 \\u0644\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u062A\\u062C\\u0646\\u0628 \\u062D\\u0633\\u0627\\u0628 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0646\\u0641\\u0633\\u0647\\u0627 \\u0645\\u0631\\u0627\\u0631\\u064B\\u0627 \\u0648\\u062A\\u0643\\u0631\\u0627\\u0631\\u064B\\u0627. \\u0648\\u0645\\u0639 \\u0630\\u0644\\u0643\\u060C \\u0647\\u0630\\u0627 \\u0627\\u0644\\u062D\\u0644 \\u064A\\u0639\\u0637\\u064A\\u0643 \\u0641\\u0643\\u0631\\u0629 \\u0639\\u0627\\u0645\\u0629 \\u0639\\u0646 \\u0643\\u064A\\u0641\\u064A\\u0629 \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0639\\u0645\\u0644\\u064A\\u0629 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0648\\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "You can use the regex modul built-in in Python, but be mindfull for the cases with multiple \"***\"."
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "I think that\\'s cheating, the point is to implement your own regex matching. otherwise this would be easy."
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "how could this be ```s  = \"aaa\" and p = \"ab*a*c*a\" is  \"TRUE\"```\nand ```s = \"a\" and p = \"ab*a\" is \"FALSE\"```\n\nas atlast they both ends with some sort of same pattern...????"
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "[@TwilightTraveler](/TwilightTraveler) it\\'s my mistake, there is \"a\" in the end...but still the result is same ...the first one returns true and the second one returns false...how it would be possible...?"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "The first one shouldn\\'t match either, are you sure there is a d at the end?"
                    },
                    {
                        "username": "filiptodev",
                        "content": "I see a lot of people struggling to understand why some of the patterns match when they seem like they shouldn\\'t, and vice-versa. Here\\'s a way I used to conceptually simplify the pattern visually in order to understand it better when I\\'m manually debugging:\\n\\n- Replace all \\'.*\\' with [?], denoting a list of any number of random characters, or none\\n- Replace all \\'.\\' with the number of times it appears in sequence, so if we have \\'...\\' then [3], or \\'.\\' then [1], denoting how many random characters must follow\\n- Combine \\'*\\' with it\\'s preceding character in a list, so \\'c*\\' becomes \\'[c*]\\'\\n\\nSo then some crazy pattern like this: \"asd...wefg.*bdfh..dfhwer*f*dgs.*mhrsdf\"\\nBecomes this: asd[3]wefg[?]bdfh[2]dfhwe[r*][f*]dgs[?]mhrsdf\\n\\nThis may seem strange, but I find it important to isolate the characters that MUST be present making it clearer to understand the variable elements in between. Just don\\'t forget that [r*] means ZERO or more of \\'r\\', so if there is no \\'r\\', it\\'s still valid."
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "For those of you who have studied Theory of Computation, Regular Expression is basically a string of characters which signifies the transition function between different states of a Finite Automata. It took me a while to realize that.\\nJust remember that \"a*\" basically means \"epsilon (empty string)\", or \"a\", or \"aa\", or \"aaa\" and so on. It is called the Kleene Closure of \"a\". So \"a*\" basically maps to no occurence of \"a\" to infinite occurences of \"a\" concatenated."
                    },
                    {
                        "username": "shrishrajgupta",
                        "content": "a* ->  \"\" , \"a\" ,\"aaaaa....\""
                    },
                    {
                        "username": "JosephPurcell",
                        "content": "Test case 304 is bad. Both true and false result meet the constraints for this test case."
                    }
                ]
            },
            {
                "id": 1984344,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "The logic of * had me thinking for so long. SMH I need to think clearer"
                    },
                    {
                        "username": "charant587",
                        "content": "Try these Test Cases Before submitting\n\n\"aa\"\n\"a\"\n\"aa\"\n\"a*\"\n\"ab\"\n\".*\"\n\"abb\"\n\".*.\"\n\"baab\"\n\"baa*\"\n\"aab\"\n\"c*a*b\"\n\"aaaaaaaaaaaaaaaaaaab\"\n\"a*a*a*a*a*a*a*a*a*a*\"\n"
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\nThe given problem is about implementing regular expression matching with support for \\'.\\' and \\'*\\', where:\\n\\n- \\'.\\' matches any single character.\\n- \\'*\\' matches zero or more of the preceding element.\\n\\nThe goal is to check if the entire input string `s` matches the pattern `p` provided.\\n\\nFor example, given `s = \"aa\"` and `p = \"a*\"`, the output should be `True`. This is because the \\'*\\' means zero or more occurrences of the preceding element \\'a\\'. Therefore, by repeating \\'a\\' once, it becomes \"aa\", which matches the entire string \"aa\"."
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\u062D\\u0633\\u0646\\u064B\\u0627\\u060C \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062D\\u0644 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629. \\u064A\\u062A\\u0645\\u062B\\u0644 \\u0627\\u0644\\u0647\\u062F\\u0641 \\u0641\\u064A \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062A\\u0646\\u0641\\u064A\\u0630 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0648\\u0641\\u0642\\u064B\\u0627 \\u0644\\u0644\\u0634\\u0631\\u0648\\u0637 \\u0627\\u0644\\u0645\\u0630\\u0643\\u0648\\u0631\\u0629:\\n\\n- \\u0627\\u0644\\u0646\\u0642\\u0637\\u0629 \\'.\\' \\u062A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0623\\u064A \\u062D\\u0631\\u0641 \\u0648\\u0627\\u062D\\u062F.\\n- \\u0627\\u0644\\u0631\\u0645\\u0632 \\'*\\' \\u064A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0635\\u0641\\u0631 \\u0623\\u0648 \\u0623\\u0643\\u062B\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0639\\u0646\\u0635\\u0631 \\u0627\\u0644\\u0630\\u064A \\u064A\\u0633\\u0628\\u0642\\u0647.\\n\\n\\u0644\\u062D\\u0644 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629\\u060C \\u064A\\u0645\\u0643\\u0646\\u0646\\u0627 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062A\\u0642\\u0646\\u064A\\u0629 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A (recursion) \\u0623\\u0648 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062C\\u062F\\u0648\\u0644 (dynamic programming) \\u0644\\u062A\\u062E\\u0632\\u064A\\u0646 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0633\\u0623\\u0633\\u062A\\u062E\\u062F\\u0645 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A \\u0647\\u0646\\u0627:\\n\\n```python\\ndef isMatch(s, p):\\n    # \\u0625\\u0630\\u0627 \\u0627\\u0646\\u062A\\u0647\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0648\\u0627\\u0644\\u0646\\u0635\\u060C \\u064A\\u0639\\u062A\\u0628\\u0631\\u0627\\u0646 \\u0645\\u062A\\u0637\\u0627\\u0628\\u0642\\u064A\\u0646\\n    if not p:\\n        return not s\\n\\n    # \\u0646\\u062A\\u062D\\u0642\\u0642 \\u0645\\u0645\\u0627 \\u0625\\u0630\\u0627 \\u0643\\u0627\\u0646\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u062A\\u062D\\u062A\\u0648\\u064A \\u0639\\u0644\\u0649 \\u0631\\u0645\\u0632 *\\n    if len(p) > 1 and p[1] == \\'*\\':\\n        # \\u0625\\u0630\\u0627 \\u0642\\u0645\\u0646\\u0627 \\u0628\\u062A\\u062C\\u0627\\u0648\\u0632 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0648\\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A \\u0628\\u0634\\u0643\\u0644 \\u0645\\u0628\\u0627\\u0634\\u0631\\u060C \\u0646\\u062D\\u0627\\u0648\\u0644 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u0646\\u0635 \\u0628\\u062F\\u0648\\u0646 \\u062A\\u0644\\u0643 \\u0627\\u0644\\u0623\\u062D\\u0631\\u0641.\\n        return isMatch(s, p[2:]) or (bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p))\\n    else:\\n        # \\u0641\\u064A \\u062D\\u0627\\u0644\\u0629 \\u0639\\u062F\\u0645 \\u0648\\u062C\\u0648\\u062F \\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A\\u060C \\u0646\\u0642\\u0648\\u0645 \\u0628\\u0645\\u0642\\u0627\\u0631\\u0646\\u0629 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0635.\\n        return bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p[1:])\\n\\n# \\u0645\\u062B\\u0627\\u0644\\ns = \"aa\"\\np = \"a\"\\nprint(isMatch(s, p))  # \\u0627\\u0644\\u0646\\u062A\\u064A\\u062C\\u0629 \\u0633\\u062A\\u0643\\u0648\\u0646: False\\n```\\n\\n\\u064A\\u0639\\u062A\\u0628\\u0631 \\u0627\\u0644\\u062D\\u0644 \\u0623\\u0639\\u0644\\u0627\\u0647 \\u0628\\u0633\\u064A\\u0637\\u064B\\u0627 \\u0648\\u064A\\u0645\\u0643\\u0646 \\u062A\\u062D\\u0633\\u064A\\u0646\\u0647 \\u0628\\u0625\\u0636\\u0627\\u0641\\u0629 \\u0630\\u0627\\u0643\\u0631\\u0629 \\u062A\\u062E\\u0632\\u064A\\u0646 \\u0644\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u062A\\u062C\\u0646\\u0628 \\u062D\\u0633\\u0627\\u0628 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0646\\u0641\\u0633\\u0647\\u0627 \\u0645\\u0631\\u0627\\u0631\\u064B\\u0627 \\u0648\\u062A\\u0643\\u0631\\u0627\\u0631\\u064B\\u0627. \\u0648\\u0645\\u0639 \\u0630\\u0644\\u0643\\u060C \\u0647\\u0630\\u0627 \\u0627\\u0644\\u062D\\u0644 \\u064A\\u0639\\u0637\\u064A\\u0643 \\u0641\\u0643\\u0631\\u0629 \\u0639\\u0627\\u0645\\u0629 \\u0639\\u0646 \\u0643\\u064A\\u0641\\u064A\\u0629 \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0639\\u0645\\u0644\\u064A\\u0629 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0648\\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "You can use the regex modul built-in in Python, but be mindfull for the cases with multiple \"***\"."
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "I think that\\'s cheating, the point is to implement your own regex matching. otherwise this would be easy."
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "how could this be ```s  = \"aaa\" and p = \"ab*a*c*a\" is  \"TRUE\"```\nand ```s = \"a\" and p = \"ab*a\" is \"FALSE\"```\n\nas atlast they both ends with some sort of same pattern...????"
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "[@TwilightTraveler](/TwilightTraveler) it\\'s my mistake, there is \"a\" in the end...but still the result is same ...the first one returns true and the second one returns false...how it would be possible...?"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "The first one shouldn\\'t match either, are you sure there is a d at the end?"
                    },
                    {
                        "username": "filiptodev",
                        "content": "I see a lot of people struggling to understand why some of the patterns match when they seem like they shouldn\\'t, and vice-versa. Here\\'s a way I used to conceptually simplify the pattern visually in order to understand it better when I\\'m manually debugging:\\n\\n- Replace all \\'.*\\' with [?], denoting a list of any number of random characters, or none\\n- Replace all \\'.\\' with the number of times it appears in sequence, so if we have \\'...\\' then [3], or \\'.\\' then [1], denoting how many random characters must follow\\n- Combine \\'*\\' with it\\'s preceding character in a list, so \\'c*\\' becomes \\'[c*]\\'\\n\\nSo then some crazy pattern like this: \"asd...wefg.*bdfh..dfhwer*f*dgs.*mhrsdf\"\\nBecomes this: asd[3]wefg[?]bdfh[2]dfhwe[r*][f*]dgs[?]mhrsdf\\n\\nThis may seem strange, but I find it important to isolate the characters that MUST be present making it clearer to understand the variable elements in between. Just don\\'t forget that [r*] means ZERO or more of \\'r\\', so if there is no \\'r\\', it\\'s still valid."
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "For those of you who have studied Theory of Computation, Regular Expression is basically a string of characters which signifies the transition function between different states of a Finite Automata. It took me a while to realize that.\\nJust remember that \"a*\" basically means \"epsilon (empty string)\", or \"a\", or \"aa\", or \"aaa\" and so on. It is called the Kleene Closure of \"a\". So \"a*\" basically maps to no occurence of \"a\" to infinite occurences of \"a\" concatenated."
                    },
                    {
                        "username": "shrishrajgupta",
                        "content": "a* ->  \"\" , \"a\" ,\"aaaaa....\""
                    },
                    {
                        "username": "JosephPurcell",
                        "content": "Test case 304 is bad. Both true and false result meet the constraints for this test case."
                    }
                ]
            },
            {
                "id": 1984282,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "The logic of * had me thinking for so long. SMH I need to think clearer"
                    },
                    {
                        "username": "charant587",
                        "content": "Try these Test Cases Before submitting\n\n\"aa\"\n\"a\"\n\"aa\"\n\"a*\"\n\"ab\"\n\".*\"\n\"abb\"\n\".*.\"\n\"baab\"\n\"baa*\"\n\"aab\"\n\"c*a*b\"\n\"aaaaaaaaaaaaaaaaaaab\"\n\"a*a*a*a*a*a*a*a*a*a*\"\n"
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\nThe given problem is about implementing regular expression matching with support for \\'.\\' and \\'*\\', where:\\n\\n- \\'.\\' matches any single character.\\n- \\'*\\' matches zero or more of the preceding element.\\n\\nThe goal is to check if the entire input string `s` matches the pattern `p` provided.\\n\\nFor example, given `s = \"aa\"` and `p = \"a*\"`, the output should be `True`. This is because the \\'*\\' means zero or more occurrences of the preceding element \\'a\\'. Therefore, by repeating \\'a\\' once, it becomes \"aa\", which matches the entire string \"aa\"."
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\u062D\\u0633\\u0646\\u064B\\u0627\\u060C \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062D\\u0644 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629. \\u064A\\u062A\\u0645\\u062B\\u0644 \\u0627\\u0644\\u0647\\u062F\\u0641 \\u0641\\u064A \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062A\\u0646\\u0641\\u064A\\u0630 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0648\\u0641\\u0642\\u064B\\u0627 \\u0644\\u0644\\u0634\\u0631\\u0648\\u0637 \\u0627\\u0644\\u0645\\u0630\\u0643\\u0648\\u0631\\u0629:\\n\\n- \\u0627\\u0644\\u0646\\u0642\\u0637\\u0629 \\'.\\' \\u062A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0623\\u064A \\u062D\\u0631\\u0641 \\u0648\\u0627\\u062D\\u062F.\\n- \\u0627\\u0644\\u0631\\u0645\\u0632 \\'*\\' \\u064A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0635\\u0641\\u0631 \\u0623\\u0648 \\u0623\\u0643\\u062B\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0639\\u0646\\u0635\\u0631 \\u0627\\u0644\\u0630\\u064A \\u064A\\u0633\\u0628\\u0642\\u0647.\\n\\n\\u0644\\u062D\\u0644 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629\\u060C \\u064A\\u0645\\u0643\\u0646\\u0646\\u0627 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062A\\u0642\\u0646\\u064A\\u0629 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A (recursion) \\u0623\\u0648 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062C\\u062F\\u0648\\u0644 (dynamic programming) \\u0644\\u062A\\u062E\\u0632\\u064A\\u0646 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0633\\u0623\\u0633\\u062A\\u062E\\u062F\\u0645 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A \\u0647\\u0646\\u0627:\\n\\n```python\\ndef isMatch(s, p):\\n    # \\u0625\\u0630\\u0627 \\u0627\\u0646\\u062A\\u0647\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0648\\u0627\\u0644\\u0646\\u0635\\u060C \\u064A\\u0639\\u062A\\u0628\\u0631\\u0627\\u0646 \\u0645\\u062A\\u0637\\u0627\\u0628\\u0642\\u064A\\u0646\\n    if not p:\\n        return not s\\n\\n    # \\u0646\\u062A\\u062D\\u0642\\u0642 \\u0645\\u0645\\u0627 \\u0625\\u0630\\u0627 \\u0643\\u0627\\u0646\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u062A\\u062D\\u062A\\u0648\\u064A \\u0639\\u0644\\u0649 \\u0631\\u0645\\u0632 *\\n    if len(p) > 1 and p[1] == \\'*\\':\\n        # \\u0625\\u0630\\u0627 \\u0642\\u0645\\u0646\\u0627 \\u0628\\u062A\\u062C\\u0627\\u0648\\u0632 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0648\\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A \\u0628\\u0634\\u0643\\u0644 \\u0645\\u0628\\u0627\\u0634\\u0631\\u060C \\u0646\\u062D\\u0627\\u0648\\u0644 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u0646\\u0635 \\u0628\\u062F\\u0648\\u0646 \\u062A\\u0644\\u0643 \\u0627\\u0644\\u0623\\u062D\\u0631\\u0641.\\n        return isMatch(s, p[2:]) or (bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p))\\n    else:\\n        # \\u0641\\u064A \\u062D\\u0627\\u0644\\u0629 \\u0639\\u062F\\u0645 \\u0648\\u062C\\u0648\\u062F \\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A\\u060C \\u0646\\u0642\\u0648\\u0645 \\u0628\\u0645\\u0642\\u0627\\u0631\\u0646\\u0629 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0635.\\n        return bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p[1:])\\n\\n# \\u0645\\u062B\\u0627\\u0644\\ns = \"aa\"\\np = \"a\"\\nprint(isMatch(s, p))  # \\u0627\\u0644\\u0646\\u062A\\u064A\\u062C\\u0629 \\u0633\\u062A\\u0643\\u0648\\u0646: False\\n```\\n\\n\\u064A\\u0639\\u062A\\u0628\\u0631 \\u0627\\u0644\\u062D\\u0644 \\u0623\\u0639\\u0644\\u0627\\u0647 \\u0628\\u0633\\u064A\\u0637\\u064B\\u0627 \\u0648\\u064A\\u0645\\u0643\\u0646 \\u062A\\u062D\\u0633\\u064A\\u0646\\u0647 \\u0628\\u0625\\u0636\\u0627\\u0641\\u0629 \\u0630\\u0627\\u0643\\u0631\\u0629 \\u062A\\u062E\\u0632\\u064A\\u0646 \\u0644\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u062A\\u062C\\u0646\\u0628 \\u062D\\u0633\\u0627\\u0628 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0646\\u0641\\u0633\\u0647\\u0627 \\u0645\\u0631\\u0627\\u0631\\u064B\\u0627 \\u0648\\u062A\\u0643\\u0631\\u0627\\u0631\\u064B\\u0627. \\u0648\\u0645\\u0639 \\u0630\\u0644\\u0643\\u060C \\u0647\\u0630\\u0627 \\u0627\\u0644\\u062D\\u0644 \\u064A\\u0639\\u0637\\u064A\\u0643 \\u0641\\u0643\\u0631\\u0629 \\u0639\\u0627\\u0645\\u0629 \\u0639\\u0646 \\u0643\\u064A\\u0641\\u064A\\u0629 \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0639\\u0645\\u0644\\u064A\\u0629 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0648\\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "You can use the regex modul built-in in Python, but be mindfull for the cases with multiple \"***\"."
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "I think that\\'s cheating, the point is to implement your own regex matching. otherwise this would be easy."
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "how could this be ```s  = \"aaa\" and p = \"ab*a*c*a\" is  \"TRUE\"```\nand ```s = \"a\" and p = \"ab*a\" is \"FALSE\"```\n\nas atlast they both ends with some sort of same pattern...????"
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "[@TwilightTraveler](/TwilightTraveler) it\\'s my mistake, there is \"a\" in the end...but still the result is same ...the first one returns true and the second one returns false...how it would be possible...?"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "The first one shouldn\\'t match either, are you sure there is a d at the end?"
                    },
                    {
                        "username": "filiptodev",
                        "content": "I see a lot of people struggling to understand why some of the patterns match when they seem like they shouldn\\'t, and vice-versa. Here\\'s a way I used to conceptually simplify the pattern visually in order to understand it better when I\\'m manually debugging:\\n\\n- Replace all \\'.*\\' with [?], denoting a list of any number of random characters, or none\\n- Replace all \\'.\\' with the number of times it appears in sequence, so if we have \\'...\\' then [3], or \\'.\\' then [1], denoting how many random characters must follow\\n- Combine \\'*\\' with it\\'s preceding character in a list, so \\'c*\\' becomes \\'[c*]\\'\\n\\nSo then some crazy pattern like this: \"asd...wefg.*bdfh..dfhwer*f*dgs.*mhrsdf\"\\nBecomes this: asd[3]wefg[?]bdfh[2]dfhwe[r*][f*]dgs[?]mhrsdf\\n\\nThis may seem strange, but I find it important to isolate the characters that MUST be present making it clearer to understand the variable elements in between. Just don\\'t forget that [r*] means ZERO or more of \\'r\\', so if there is no \\'r\\', it\\'s still valid."
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "For those of you who have studied Theory of Computation, Regular Expression is basically a string of characters which signifies the transition function between different states of a Finite Automata. It took me a while to realize that.\\nJust remember that \"a*\" basically means \"epsilon (empty string)\", or \"a\", or \"aa\", or \"aaa\" and so on. It is called the Kleene Closure of \"a\". So \"a*\" basically maps to no occurence of \"a\" to infinite occurences of \"a\" concatenated."
                    },
                    {
                        "username": "shrishrajgupta",
                        "content": "a* ->  \"\" , \"a\" ,\"aaaaa....\""
                    },
                    {
                        "username": "JosephPurcell",
                        "content": "Test case 304 is bad. Both true and false result meet the constraints for this test case."
                    }
                ]
            },
            {
                "id": 1977806,
                "content": [
                    {
                        "username": "rakeshks7",
                        "content": "The logic of * had me thinking for so long. SMH I need to think clearer"
                    },
                    {
                        "username": "charant587",
                        "content": "Try these Test Cases Before submitting\n\n\"aa\"\n\"a\"\n\"aa\"\n\"a*\"\n\"ab\"\n\".*\"\n\"abb\"\n\".*.\"\n\"baab\"\n\"baa*\"\n\"aab\"\n\"c*a*b\"\n\"aaaaaaaaaaaaaaaaaaab\"\n\"a*a*a*a*a*a*a*a*a*a*\"\n"
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\nThe given problem is about implementing regular expression matching with support for \\'.\\' and \\'*\\', where:\\n\\n- \\'.\\' matches any single character.\\n- \\'*\\' matches zero or more of the preceding element.\\n\\nThe goal is to check if the entire input string `s` matches the pattern `p` provided.\\n\\nFor example, given `s = \"aa\"` and `p = \"a*\"`, the output should be `True`. This is because the \\'*\\' means zero or more occurrences of the preceding element \\'a\\'. Therefore, by repeating \\'a\\' once, it becomes \"aa\", which matches the entire string \"aa\"."
                    },
                    {
                        "username": "alkindi77",
                        "content": "\\u062D\\u0633\\u0646\\u064B\\u0627\\u060C \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062D\\u0644 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629. \\u064A\\u062A\\u0645\\u062B\\u0644 \\u0627\\u0644\\u0647\\u062F\\u0641 \\u0641\\u064A \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0644\\u0646\\u0642\\u0645 \\u0628\\u062A\\u0646\\u0641\\u064A\\u0630 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0648\\u0641\\u0642\\u064B\\u0627 \\u0644\\u0644\\u0634\\u0631\\u0648\\u0637 \\u0627\\u0644\\u0645\\u0630\\u0643\\u0648\\u0631\\u0629:\\n\\n- \\u0627\\u0644\\u0646\\u0642\\u0637\\u0629 \\'.\\' \\u062A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0623\\u064A \\u062D\\u0631\\u0641 \\u0648\\u0627\\u062D\\u062F.\\n- \\u0627\\u0644\\u0631\\u0645\\u0632 \\'*\\' \\u064A\\u062A\\u0637\\u0627\\u0628\\u0642 \\u0645\\u0639 \\u0635\\u0641\\u0631 \\u0623\\u0648 \\u0623\\u0643\\u062B\\u0631 \\u0645\\u0646 \\u0627\\u0644\\u0639\\u0646\\u0635\\u0631 \\u0627\\u0644\\u0630\\u064A \\u064A\\u0633\\u0628\\u0642\\u0647.\\n\\n\\u0644\\u062D\\u0644 \\u0647\\u0630\\u0647 \\u0627\\u0644\\u0645\\u0634\\u0643\\u0644\\u0629\\u060C \\u064A\\u0645\\u0643\\u0646\\u0646\\u0627 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062A\\u0642\\u0646\\u064A\\u0629 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A (recursion) \\u0623\\u0648 \\u0627\\u0633\\u062A\\u062E\\u062F\\u0627\\u0645 \\u062C\\u062F\\u0648\\u0644 (dynamic programming) \\u0644\\u062A\\u062E\\u0632\\u064A\\u0646 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u0646\\u0635 s \\u0648\\u0627\\u0644\\u0646\\u0645\\u0637 p. \\u0633\\u0623\\u0633\\u062A\\u062E\\u062F\\u0645 \\u0627\\u0644\\u0627\\u0633\\u062A\\u0646\\u0633\\u0627\\u062E \\u0627\\u0644\\u0630\\u0627\\u062A\\u064A \\u0647\\u0646\\u0627:\\n\\n```python\\ndef isMatch(s, p):\\n    # \\u0625\\u0630\\u0627 \\u0627\\u0646\\u062A\\u0647\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0648\\u0627\\u0644\\u0646\\u0635\\u060C \\u064A\\u0639\\u062A\\u0628\\u0631\\u0627\\u0646 \\u0645\\u062A\\u0637\\u0627\\u0628\\u0642\\u064A\\u0646\\n    if not p:\\n        return not s\\n\\n    # \\u0646\\u062A\\u062D\\u0642\\u0642 \\u0645\\u0645\\u0627 \\u0625\\u0630\\u0627 \\u0643\\u0627\\u0646\\u062A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u062A\\u062D\\u062A\\u0648\\u064A \\u0639\\u0644\\u0649 \\u0631\\u0645\\u0632 *\\n    if len(p) > 1 and p[1] == \\'*\\':\\n        # \\u0625\\u0630\\u0627 \\u0642\\u0645\\u0646\\u0627 \\u0628\\u062A\\u062C\\u0627\\u0648\\u0632 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0648\\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A \\u0628\\u0634\\u0643\\u0644 \\u0645\\u0628\\u0627\\u0634\\u0631\\u060C \\u0646\\u062D\\u0627\\u0648\\u0644 \\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u0646\\u0635 \\u0628\\u062F\\u0648\\u0646 \\u062A\\u0644\\u0643 \\u0627\\u0644\\u0623\\u062D\\u0631\\u0641.\\n        return isMatch(s, p[2:]) or (bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p))\\n    else:\\n        # \\u0641\\u064A \\u062D\\u0627\\u0644\\u0629 \\u0639\\u062F\\u0645 \\u0648\\u062C\\u0648\\u062F \\u0627\\u0644\\u0631\\u0645\\u0632 \\u0627\\u0644\\u0646\\u062C\\u0645\\u064A\\u060C \\u0646\\u0642\\u0648\\u0645 \\u0628\\u0645\\u0642\\u0627\\u0631\\u0646\\u0629 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0645\\u0637 \\u0645\\u0639 \\u0627\\u0644\\u062D\\u0631\\u0641 \\u0627\\u0644\\u062D\\u0627\\u0644\\u064A \\u0641\\u064A \\u0627\\u0644\\u0646\\u0635.\\n        return bool(s) and (s[0] == p[0] or p[0] == \\'.\\') and isMatch(s[1:], p[1:])\\n\\n# \\u0645\\u062B\\u0627\\u0644\\ns = \"aa\"\\np = \"a\"\\nprint(isMatch(s, p))  # \\u0627\\u0644\\u0646\\u062A\\u064A\\u062C\\u0629 \\u0633\\u062A\\u0643\\u0648\\u0646: False\\n```\\n\\n\\u064A\\u0639\\u062A\\u0628\\u0631 \\u0627\\u0644\\u062D\\u0644 \\u0623\\u0639\\u0644\\u0627\\u0647 \\u0628\\u0633\\u064A\\u0637\\u064B\\u0627 \\u0648\\u064A\\u0645\\u0643\\u0646 \\u062A\\u062D\\u0633\\u064A\\u0646\\u0647 \\u0628\\u0625\\u0636\\u0627\\u0641\\u0629 \\u0630\\u0627\\u0643\\u0631\\u0629 \\u062A\\u062E\\u0632\\u064A\\u0646 \\u0644\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0627\\u0644\\u0645\\u062A\\u0648\\u0633\\u0639\\u0629 \\u0644\\u062A\\u062C\\u0646\\u0628 \\u062D\\u0633\\u0627\\u0628 \\u0627\\u0644\\u0646\\u062A\\u0627\\u0626\\u062C \\u0646\\u0641\\u0633\\u0647\\u0627 \\u0645\\u0631\\u0627\\u0631\\u064B\\u0627 \\u0648\\u062A\\u0643\\u0631\\u0627\\u0631\\u064B\\u0627. \\u0648\\u0645\\u0639 \\u0630\\u0644\\u0643\\u060C \\u0647\\u0630\\u0627 \\u0627\\u0644\\u062D\\u0644 \\u064A\\u0639\\u0637\\u064A\\u0643 \\u0641\\u0643\\u0631\\u0629 \\u0639\\u0627\\u0645\\u0629 \\u0639\\u0646 \\u0643\\u064A\\u0641\\u064A\\u0629 \\u062A\\u0646\\u0641\\u064A\\u0630 \\u0639\\u0645\\u0644\\u064A\\u0629 \\u0627\\u0644\\u0645\\u0637\\u0627\\u0628\\u0642\\u0629 \\u0628\\u064A\\u0646 \\u0627\\u0644\\u062A\\u0639\\u0628\\u064A\\u0631 \\u0627\\u0644\\u0630\\u064A \\u062A\\u0645 \\u062A\\u0648\\u0636\\u064A\\u062D\\u0647 \\u0648\\u0627\\u0644\\u0646\\u0635 \\u0627\\u0644\\u0645\\u062F\\u062E\\u0644."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "You can use the regex modul built-in in Python, but be mindfull for the cases with multiple \"***\"."
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "I think that\\'s cheating, the point is to implement your own regex matching. otherwise this would be easy."
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "how could this be ```s  = \"aaa\" and p = \"ab*a*c*a\" is  \"TRUE\"```\nand ```s = \"a\" and p = \"ab*a\" is \"FALSE\"```\n\nas atlast they both ends with some sort of same pattern...????"
                    },
                    {
                        "username": "neelshah683sh",
                        "content": "[@TwilightTraveler](/TwilightTraveler) it\\'s my mistake, there is \"a\" in the end...but still the result is same ...the first one returns true and the second one returns false...how it would be possible...?"
                    },
                    {
                        "username": "TwilightTraveler",
                        "content": "The first one shouldn\\'t match either, are you sure there is a d at the end?"
                    },
                    {
                        "username": "filiptodev",
                        "content": "I see a lot of people struggling to understand why some of the patterns match when they seem like they shouldn\\'t, and vice-versa. Here\\'s a way I used to conceptually simplify the pattern visually in order to understand it better when I\\'m manually debugging:\\n\\n- Replace all \\'.*\\' with [?], denoting a list of any number of random characters, or none\\n- Replace all \\'.\\' with the number of times it appears in sequence, so if we have \\'...\\' then [3], or \\'.\\' then [1], denoting how many random characters must follow\\n- Combine \\'*\\' with it\\'s preceding character in a list, so \\'c*\\' becomes \\'[c*]\\'\\n\\nSo then some crazy pattern like this: \"asd...wefg.*bdfh..dfhwer*f*dgs.*mhrsdf\"\\nBecomes this: asd[3]wefg[?]bdfh[2]dfhwe[r*][f*]dgs[?]mhrsdf\\n\\nThis may seem strange, but I find it important to isolate the characters that MUST be present making it clearer to understand the variable elements in between. Just don\\'t forget that [r*] means ZERO or more of \\'r\\', so if there is no \\'r\\', it\\'s still valid."
                    },
                    {
                        "username": "ComprehensiveDuck",
                        "content": "For those of you who have studied Theory of Computation, Regular Expression is basically a string of characters which signifies the transition function between different states of a Finite Automata. It took me a while to realize that.\\nJust remember that \"a*\" basically means \"epsilon (empty string)\", or \"a\", or \"aa\", or \"aaa\" and so on. It is called the Kleene Closure of \"a\". So \"a*\" basically maps to no occurence of \"a\" to infinite occurences of \"a\" concatenated."
                    },
                    {
                        "username": "shrishrajgupta",
                        "content": "a* ->  \"\" , \"a\" ,\"aaaaa....\""
                    },
                    {
                        "username": "JosephPurcell",
                        "content": "Test case 304 is bad. Both true and false result meet the constraints for this test case."
                    }
                ]
            },
            {
                "id": 1963345,
                "content": [
                    {
                        "username": "Subhajit_Lai",
                        "content": "Input\\ns =\\n\"ab\"\\np =\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nanyone can please help with the logic "
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The output should be False because the input string didn\\'t end with a character \\'c\\' that was a part of the given regex `.*c`."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hi there, can someone tell me if this recursive method can be reduced in time complexity, or if the solution has to forcefully be with dynammic programming class Solution\\n{\\npublic:\\n    bool isMatch(std::string s, std::string p){\\n    // Base case:\\n    // 1. If p is empty, return the bool of s.empty\\n    // 1.1 if the current character is a \\'.\\' and next is a \\'*\\'\\n    // make two paths, one with p+=2 then recursive call\\n    // and the other recursive call with s+=1 and recursive call\\n    // Check if the curr is dot, or s[0] == p[0]\\n    // move in s and on p with the recursive call\\n        if(p.empty()) return s.empty();\\n        else{\\n            if(p.length() > 1){\\n                if(p[1] == \\'*\\') {\\n                    if(p[0] == s[0] || p[0] == \\'.\\' && s.length() > 0)\\n                        return(isMatch(s, p.substr(2)) || isMatch(s.substr(1), p));\\n                    return (isMatch(s, p.substr(2)));\\n                }\\n                if(p[0] == s[0] || p[0] == \\'.\\' &&  s.length() > 0)\\n                    return (isMatch(s.substr(1), p.substr(1)));\\n                else return false;\\n            }\\n            if(p.length() > 0 && s.length() > 0 && (p[0] == s[0] || p[0] == \\'.\\'))\\n                return (isMatch(s.substr(1), p.substr(1)));\\n            else return false;\\n        }\\n    }\\n};   "
                    },
                    {
                        "username": "aaryak4554",
                        "content": "pure recursive/backtrack solution beat 100% time and 80.17% memory... amazinggg"
                    },
                    {
                        "username": "geekyshark",
                        "content": "poorely worded question ,should have stated that \"a*\" means string can be empty too,there is no boundation on a to exist"
                    },
                    {
                        "username": "juliodondisch",
                        "content": "I got it down its just the memory limit i keep exceeding :/"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it ok?\\nCan someone explain please?\\n[ScreenShoot](https://imgbb.com/zPMXLF6)"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it oK?\\nCan someone explain please?\\n[Screenshot](https://ibb.co/zPMXLF6)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "how this is different from wildcard pattern matching problem?\\n"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "just giving few more testcase as it is necessary for understanding this question. \\uD83D\\uDC4D\\n `s = \"abcd\" p = \"j.*\" output = false`\\n `s = \"abcd\" p = \"j*.*\" output = true`"
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "`\".*\"` matches to **any character**, *not* just the first character encountered.\\n\\nIf `s = \"mystring\"` and `p = \".*\"`, the answer is `True`.\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\nTherefore, <code>.\\\\*</code> matches with <code>m</code>, <code>y</code>, <code>s</code>, <code>t</code>, <code>r</code>, <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\nWait a second! How can <code>r</code> match with any <code>r</code> in <code>s</code> if <code>.\\\\*</code> already matches all of the characters?\\nThe answer is, it doesn\\'t. <code>.\\\\*</code> only applies until the final instance of the next token is found.\\nTherefore, <code>.\\\\*</code> matches only <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nThis leaves <code>\"ing\"</code> unmatched, resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nAnd <code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\nLeaving <code>r</code> unmatched, as all the characters of <code>\"anotherstring\"</code> have already been matched: resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*.\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>.</code> matches with any single character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, and <code>n</code>.\\n<code>.</code> matches to <code>g</code>.\\n\\n</details>"
                    }
                ]
            },
            {
                "id": 1940370,
                "content": [
                    {
                        "username": "Subhajit_Lai",
                        "content": "Input\\ns =\\n\"ab\"\\np =\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nanyone can please help with the logic "
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The output should be False because the input string didn\\'t end with a character \\'c\\' that was a part of the given regex `.*c`."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hi there, can someone tell me if this recursive method can be reduced in time complexity, or if the solution has to forcefully be with dynammic programming class Solution\\n{\\npublic:\\n    bool isMatch(std::string s, std::string p){\\n    // Base case:\\n    // 1. If p is empty, return the bool of s.empty\\n    // 1.1 if the current character is a \\'.\\' and next is a \\'*\\'\\n    // make two paths, one with p+=2 then recursive call\\n    // and the other recursive call with s+=1 and recursive call\\n    // Check if the curr is dot, or s[0] == p[0]\\n    // move in s and on p with the recursive call\\n        if(p.empty()) return s.empty();\\n        else{\\n            if(p.length() > 1){\\n                if(p[1] == \\'*\\') {\\n                    if(p[0] == s[0] || p[0] == \\'.\\' && s.length() > 0)\\n                        return(isMatch(s, p.substr(2)) || isMatch(s.substr(1), p));\\n                    return (isMatch(s, p.substr(2)));\\n                }\\n                if(p[0] == s[0] || p[0] == \\'.\\' &&  s.length() > 0)\\n                    return (isMatch(s.substr(1), p.substr(1)));\\n                else return false;\\n            }\\n            if(p.length() > 0 && s.length() > 0 && (p[0] == s[0] || p[0] == \\'.\\'))\\n                return (isMatch(s.substr(1), p.substr(1)));\\n            else return false;\\n        }\\n    }\\n};   "
                    },
                    {
                        "username": "aaryak4554",
                        "content": "pure recursive/backtrack solution beat 100% time and 80.17% memory... amazinggg"
                    },
                    {
                        "username": "geekyshark",
                        "content": "poorely worded question ,should have stated that \"a*\" means string can be empty too,there is no boundation on a to exist"
                    },
                    {
                        "username": "juliodondisch",
                        "content": "I got it down its just the memory limit i keep exceeding :/"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it ok?\\nCan someone explain please?\\n[ScreenShoot](https://imgbb.com/zPMXLF6)"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it oK?\\nCan someone explain please?\\n[Screenshot](https://ibb.co/zPMXLF6)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "how this is different from wildcard pattern matching problem?\\n"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "just giving few more testcase as it is necessary for understanding this question. \\uD83D\\uDC4D\\n `s = \"abcd\" p = \"j.*\" output = false`\\n `s = \"abcd\" p = \"j*.*\" output = true`"
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "`\".*\"` matches to **any character**, *not* just the first character encountered.\\n\\nIf `s = \"mystring\"` and `p = \".*\"`, the answer is `True`.\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\nTherefore, <code>.\\\\*</code> matches with <code>m</code>, <code>y</code>, <code>s</code>, <code>t</code>, <code>r</code>, <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\nWait a second! How can <code>r</code> match with any <code>r</code> in <code>s</code> if <code>.\\\\*</code> already matches all of the characters?\\nThe answer is, it doesn\\'t. <code>.\\\\*</code> only applies until the final instance of the next token is found.\\nTherefore, <code>.\\\\*</code> matches only <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nThis leaves <code>\"ing\"</code> unmatched, resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nAnd <code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\nLeaving <code>r</code> unmatched, as all the characters of <code>\"anotherstring\"</code> have already been matched: resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*.\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>.</code> matches with any single character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, and <code>n</code>.\\n<code>.</code> matches to <code>g</code>.\\n\\n</details>"
                    }
                ]
            },
            {
                "id": 1940176,
                "content": [
                    {
                        "username": "Subhajit_Lai",
                        "content": "Input\\ns =\\n\"ab\"\\np =\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nanyone can please help with the logic "
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The output should be False because the input string didn\\'t end with a character \\'c\\' that was a part of the given regex `.*c`."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hi there, can someone tell me if this recursive method can be reduced in time complexity, or if the solution has to forcefully be with dynammic programming class Solution\\n{\\npublic:\\n    bool isMatch(std::string s, std::string p){\\n    // Base case:\\n    // 1. If p is empty, return the bool of s.empty\\n    // 1.1 if the current character is a \\'.\\' and next is a \\'*\\'\\n    // make two paths, one with p+=2 then recursive call\\n    // and the other recursive call with s+=1 and recursive call\\n    // Check if the curr is dot, or s[0] == p[0]\\n    // move in s and on p with the recursive call\\n        if(p.empty()) return s.empty();\\n        else{\\n            if(p.length() > 1){\\n                if(p[1] == \\'*\\') {\\n                    if(p[0] == s[0] || p[0] == \\'.\\' && s.length() > 0)\\n                        return(isMatch(s, p.substr(2)) || isMatch(s.substr(1), p));\\n                    return (isMatch(s, p.substr(2)));\\n                }\\n                if(p[0] == s[0] || p[0] == \\'.\\' &&  s.length() > 0)\\n                    return (isMatch(s.substr(1), p.substr(1)));\\n                else return false;\\n            }\\n            if(p.length() > 0 && s.length() > 0 && (p[0] == s[0] || p[0] == \\'.\\'))\\n                return (isMatch(s.substr(1), p.substr(1)));\\n            else return false;\\n        }\\n    }\\n};   "
                    },
                    {
                        "username": "aaryak4554",
                        "content": "pure recursive/backtrack solution beat 100% time and 80.17% memory... amazinggg"
                    },
                    {
                        "username": "geekyshark",
                        "content": "poorely worded question ,should have stated that \"a*\" means string can be empty too,there is no boundation on a to exist"
                    },
                    {
                        "username": "juliodondisch",
                        "content": "I got it down its just the memory limit i keep exceeding :/"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it ok?\\nCan someone explain please?\\n[ScreenShoot](https://imgbb.com/zPMXLF6)"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it oK?\\nCan someone explain please?\\n[Screenshot](https://ibb.co/zPMXLF6)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "how this is different from wildcard pattern matching problem?\\n"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "just giving few more testcase as it is necessary for understanding this question. \\uD83D\\uDC4D\\n `s = \"abcd\" p = \"j.*\" output = false`\\n `s = \"abcd\" p = \"j*.*\" output = true`"
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "`\".*\"` matches to **any character**, *not* just the first character encountered.\\n\\nIf `s = \"mystring\"` and `p = \".*\"`, the answer is `True`.\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\nTherefore, <code>.\\\\*</code> matches with <code>m</code>, <code>y</code>, <code>s</code>, <code>t</code>, <code>r</code>, <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\nWait a second! How can <code>r</code> match with any <code>r</code> in <code>s</code> if <code>.\\\\*</code> already matches all of the characters?\\nThe answer is, it doesn\\'t. <code>.\\\\*</code> only applies until the final instance of the next token is found.\\nTherefore, <code>.\\\\*</code> matches only <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nThis leaves <code>\"ing\"</code> unmatched, resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nAnd <code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\nLeaving <code>r</code> unmatched, as all the characters of <code>\"anotherstring\"</code> have already been matched: resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*.\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>.</code> matches with any single character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, and <code>n</code>.\\n<code>.</code> matches to <code>g</code>.\\n\\n</details>"
                    }
                ]
            },
            {
                "id": 1940164,
                "content": [
                    {
                        "username": "Subhajit_Lai",
                        "content": "Input\\ns =\\n\"ab\"\\np =\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nanyone can please help with the logic "
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The output should be False because the input string didn\\'t end with a character \\'c\\' that was a part of the given regex `.*c`."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hi there, can someone tell me if this recursive method can be reduced in time complexity, or if the solution has to forcefully be with dynammic programming class Solution\\n{\\npublic:\\n    bool isMatch(std::string s, std::string p){\\n    // Base case:\\n    // 1. If p is empty, return the bool of s.empty\\n    // 1.1 if the current character is a \\'.\\' and next is a \\'*\\'\\n    // make two paths, one with p+=2 then recursive call\\n    // and the other recursive call with s+=1 and recursive call\\n    // Check if the curr is dot, or s[0] == p[0]\\n    // move in s and on p with the recursive call\\n        if(p.empty()) return s.empty();\\n        else{\\n            if(p.length() > 1){\\n                if(p[1] == \\'*\\') {\\n                    if(p[0] == s[0] || p[0] == \\'.\\' && s.length() > 0)\\n                        return(isMatch(s, p.substr(2)) || isMatch(s.substr(1), p));\\n                    return (isMatch(s, p.substr(2)));\\n                }\\n                if(p[0] == s[0] || p[0] == \\'.\\' &&  s.length() > 0)\\n                    return (isMatch(s.substr(1), p.substr(1)));\\n                else return false;\\n            }\\n            if(p.length() > 0 && s.length() > 0 && (p[0] == s[0] || p[0] == \\'.\\'))\\n                return (isMatch(s.substr(1), p.substr(1)));\\n            else return false;\\n        }\\n    }\\n};   "
                    },
                    {
                        "username": "aaryak4554",
                        "content": "pure recursive/backtrack solution beat 100% time and 80.17% memory... amazinggg"
                    },
                    {
                        "username": "geekyshark",
                        "content": "poorely worded question ,should have stated that \"a*\" means string can be empty too,there is no boundation on a to exist"
                    },
                    {
                        "username": "juliodondisch",
                        "content": "I got it down its just the memory limit i keep exceeding :/"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it ok?\\nCan someone explain please?\\n[ScreenShoot](https://imgbb.com/zPMXLF6)"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it oK?\\nCan someone explain please?\\n[Screenshot](https://ibb.co/zPMXLF6)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "how this is different from wildcard pattern matching problem?\\n"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "just giving few more testcase as it is necessary for understanding this question. \\uD83D\\uDC4D\\n `s = \"abcd\" p = \"j.*\" output = false`\\n `s = \"abcd\" p = \"j*.*\" output = true`"
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "`\".*\"` matches to **any character**, *not* just the first character encountered.\\n\\nIf `s = \"mystring\"` and `p = \".*\"`, the answer is `True`.\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\nTherefore, <code>.\\\\*</code> matches with <code>m</code>, <code>y</code>, <code>s</code>, <code>t</code>, <code>r</code>, <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\nWait a second! How can <code>r</code> match with any <code>r</code> in <code>s</code> if <code>.\\\\*</code> already matches all of the characters?\\nThe answer is, it doesn\\'t. <code>.\\\\*</code> only applies until the final instance of the next token is found.\\nTherefore, <code>.\\\\*</code> matches only <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nThis leaves <code>\"ing\"</code> unmatched, resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nAnd <code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\nLeaving <code>r</code> unmatched, as all the characters of <code>\"anotherstring\"</code> have already been matched: resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*.\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>.</code> matches with any single character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, and <code>n</code>.\\n<code>.</code> matches to <code>g</code>.\\n\\n</details>"
                    }
                ]
            },
            {
                "id": 1937500,
                "content": [
                    {
                        "username": "Subhajit_Lai",
                        "content": "Input\\ns =\\n\"ab\"\\np =\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nanyone can please help with the logic "
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The output should be False because the input string didn\\'t end with a character \\'c\\' that was a part of the given regex `.*c`."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hi there, can someone tell me if this recursive method can be reduced in time complexity, or if the solution has to forcefully be with dynammic programming class Solution\\n{\\npublic:\\n    bool isMatch(std::string s, std::string p){\\n    // Base case:\\n    // 1. If p is empty, return the bool of s.empty\\n    // 1.1 if the current character is a \\'.\\' and next is a \\'*\\'\\n    // make two paths, one with p+=2 then recursive call\\n    // and the other recursive call with s+=1 and recursive call\\n    // Check if the curr is dot, or s[0] == p[0]\\n    // move in s and on p with the recursive call\\n        if(p.empty()) return s.empty();\\n        else{\\n            if(p.length() > 1){\\n                if(p[1] == \\'*\\') {\\n                    if(p[0] == s[0] || p[0] == \\'.\\' && s.length() > 0)\\n                        return(isMatch(s, p.substr(2)) || isMatch(s.substr(1), p));\\n                    return (isMatch(s, p.substr(2)));\\n                }\\n                if(p[0] == s[0] || p[0] == \\'.\\' &&  s.length() > 0)\\n                    return (isMatch(s.substr(1), p.substr(1)));\\n                else return false;\\n            }\\n            if(p.length() > 0 && s.length() > 0 && (p[0] == s[0] || p[0] == \\'.\\'))\\n                return (isMatch(s.substr(1), p.substr(1)));\\n            else return false;\\n        }\\n    }\\n};   "
                    },
                    {
                        "username": "aaryak4554",
                        "content": "pure recursive/backtrack solution beat 100% time and 80.17% memory... amazinggg"
                    },
                    {
                        "username": "geekyshark",
                        "content": "poorely worded question ,should have stated that \"a*\" means string can be empty too,there is no boundation on a to exist"
                    },
                    {
                        "username": "juliodondisch",
                        "content": "I got it down its just the memory limit i keep exceeding :/"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it ok?\\nCan someone explain please?\\n[ScreenShoot](https://imgbb.com/zPMXLF6)"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it oK?\\nCan someone explain please?\\n[Screenshot](https://ibb.co/zPMXLF6)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "how this is different from wildcard pattern matching problem?\\n"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "just giving few more testcase as it is necessary for understanding this question. \\uD83D\\uDC4D\\n `s = \"abcd\" p = \"j.*\" output = false`\\n `s = \"abcd\" p = \"j*.*\" output = true`"
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "`\".*\"` matches to **any character**, *not* just the first character encountered.\\n\\nIf `s = \"mystring\"` and `p = \".*\"`, the answer is `True`.\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\nTherefore, <code>.\\\\*</code> matches with <code>m</code>, <code>y</code>, <code>s</code>, <code>t</code>, <code>r</code>, <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\nWait a second! How can <code>r</code> match with any <code>r</code> in <code>s</code> if <code>.\\\\*</code> already matches all of the characters?\\nThe answer is, it doesn\\'t. <code>.\\\\*</code> only applies until the final instance of the next token is found.\\nTherefore, <code>.\\\\*</code> matches only <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nThis leaves <code>\"ing\"</code> unmatched, resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nAnd <code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\nLeaving <code>r</code> unmatched, as all the characters of <code>\"anotherstring\"</code> have already been matched: resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*.\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>.</code> matches with any single character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, and <code>n</code>.\\n<code>.</code> matches to <code>g</code>.\\n\\n</details>"
                    }
                ]
            },
            {
                "id": 1931729,
                "content": [
                    {
                        "username": "Subhajit_Lai",
                        "content": "Input\\ns =\\n\"ab\"\\np =\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nanyone can please help with the logic "
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The output should be False because the input string didn\\'t end with a character \\'c\\' that was a part of the given regex `.*c`."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hi there, can someone tell me if this recursive method can be reduced in time complexity, or if the solution has to forcefully be with dynammic programming class Solution\\n{\\npublic:\\n    bool isMatch(std::string s, std::string p){\\n    // Base case:\\n    // 1. If p is empty, return the bool of s.empty\\n    // 1.1 if the current character is a \\'.\\' and next is a \\'*\\'\\n    // make two paths, one with p+=2 then recursive call\\n    // and the other recursive call with s+=1 and recursive call\\n    // Check if the curr is dot, or s[0] == p[0]\\n    // move in s and on p with the recursive call\\n        if(p.empty()) return s.empty();\\n        else{\\n            if(p.length() > 1){\\n                if(p[1] == \\'*\\') {\\n                    if(p[0] == s[0] || p[0] == \\'.\\' && s.length() > 0)\\n                        return(isMatch(s, p.substr(2)) || isMatch(s.substr(1), p));\\n                    return (isMatch(s, p.substr(2)));\\n                }\\n                if(p[0] == s[0] || p[0] == \\'.\\' &&  s.length() > 0)\\n                    return (isMatch(s.substr(1), p.substr(1)));\\n                else return false;\\n            }\\n            if(p.length() > 0 && s.length() > 0 && (p[0] == s[0] || p[0] == \\'.\\'))\\n                return (isMatch(s.substr(1), p.substr(1)));\\n            else return false;\\n        }\\n    }\\n};   "
                    },
                    {
                        "username": "aaryak4554",
                        "content": "pure recursive/backtrack solution beat 100% time and 80.17% memory... amazinggg"
                    },
                    {
                        "username": "geekyshark",
                        "content": "poorely worded question ,should have stated that \"a*\" means string can be empty too,there is no boundation on a to exist"
                    },
                    {
                        "username": "juliodondisch",
                        "content": "I got it down its just the memory limit i keep exceeding :/"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it ok?\\nCan someone explain please?\\n[ScreenShoot](https://imgbb.com/zPMXLF6)"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it oK?\\nCan someone explain please?\\n[Screenshot](https://ibb.co/zPMXLF6)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "how this is different from wildcard pattern matching problem?\\n"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "just giving few more testcase as it is necessary for understanding this question. \\uD83D\\uDC4D\\n `s = \"abcd\" p = \"j.*\" output = false`\\n `s = \"abcd\" p = \"j*.*\" output = true`"
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "`\".*\"` matches to **any character**, *not* just the first character encountered.\\n\\nIf `s = \"mystring\"` and `p = \".*\"`, the answer is `True`.\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\nTherefore, <code>.\\\\*</code> matches with <code>m</code>, <code>y</code>, <code>s</code>, <code>t</code>, <code>r</code>, <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\nWait a second! How can <code>r</code> match with any <code>r</code> in <code>s</code> if <code>.\\\\*</code> already matches all of the characters?\\nThe answer is, it doesn\\'t. <code>.\\\\*</code> only applies until the final instance of the next token is found.\\nTherefore, <code>.\\\\*</code> matches only <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nThis leaves <code>\"ing\"</code> unmatched, resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nAnd <code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\nLeaving <code>r</code> unmatched, as all the characters of <code>\"anotherstring\"</code> have already been matched: resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*.\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>.</code> matches with any single character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, and <code>n</code>.\\n<code>.</code> matches to <code>g</code>.\\n\\n</details>"
                    }
                ]
            },
            {
                "id": 1931725,
                "content": [
                    {
                        "username": "Subhajit_Lai",
                        "content": "Input\\ns =\\n\"ab\"\\np =\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nanyone can please help with the logic "
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The output should be False because the input string didn\\'t end with a character \\'c\\' that was a part of the given regex `.*c`."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hi there, can someone tell me if this recursive method can be reduced in time complexity, or if the solution has to forcefully be with dynammic programming class Solution\\n{\\npublic:\\n    bool isMatch(std::string s, std::string p){\\n    // Base case:\\n    // 1. If p is empty, return the bool of s.empty\\n    // 1.1 if the current character is a \\'.\\' and next is a \\'*\\'\\n    // make two paths, one with p+=2 then recursive call\\n    // and the other recursive call with s+=1 and recursive call\\n    // Check if the curr is dot, or s[0] == p[0]\\n    // move in s and on p with the recursive call\\n        if(p.empty()) return s.empty();\\n        else{\\n            if(p.length() > 1){\\n                if(p[1] == \\'*\\') {\\n                    if(p[0] == s[0] || p[0] == \\'.\\' && s.length() > 0)\\n                        return(isMatch(s, p.substr(2)) || isMatch(s.substr(1), p));\\n                    return (isMatch(s, p.substr(2)));\\n                }\\n                if(p[0] == s[0] || p[0] == \\'.\\' &&  s.length() > 0)\\n                    return (isMatch(s.substr(1), p.substr(1)));\\n                else return false;\\n            }\\n            if(p.length() > 0 && s.length() > 0 && (p[0] == s[0] || p[0] == \\'.\\'))\\n                return (isMatch(s.substr(1), p.substr(1)));\\n            else return false;\\n        }\\n    }\\n};   "
                    },
                    {
                        "username": "aaryak4554",
                        "content": "pure recursive/backtrack solution beat 100% time and 80.17% memory... amazinggg"
                    },
                    {
                        "username": "geekyshark",
                        "content": "poorely worded question ,should have stated that \"a*\" means string can be empty too,there is no boundation on a to exist"
                    },
                    {
                        "username": "juliodondisch",
                        "content": "I got it down its just the memory limit i keep exceeding :/"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it ok?\\nCan someone explain please?\\n[ScreenShoot](https://imgbb.com/zPMXLF6)"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it oK?\\nCan someone explain please?\\n[Screenshot](https://ibb.co/zPMXLF6)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "how this is different from wildcard pattern matching problem?\\n"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "just giving few more testcase as it is necessary for understanding this question. \\uD83D\\uDC4D\\n `s = \"abcd\" p = \"j.*\" output = false`\\n `s = \"abcd\" p = \"j*.*\" output = true`"
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "`\".*\"` matches to **any character**, *not* just the first character encountered.\\n\\nIf `s = \"mystring\"` and `p = \".*\"`, the answer is `True`.\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\nTherefore, <code>.\\\\*</code> matches with <code>m</code>, <code>y</code>, <code>s</code>, <code>t</code>, <code>r</code>, <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\nWait a second! How can <code>r</code> match with any <code>r</code> in <code>s</code> if <code>.\\\\*</code> already matches all of the characters?\\nThe answer is, it doesn\\'t. <code>.\\\\*</code> only applies until the final instance of the next token is found.\\nTherefore, <code>.\\\\*</code> matches only <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nThis leaves <code>\"ing\"</code> unmatched, resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nAnd <code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\nLeaving <code>r</code> unmatched, as all the characters of <code>\"anotherstring\"</code> have already been matched: resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*.\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>.</code> matches with any single character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, and <code>n</code>.\\n<code>.</code> matches to <code>g</code>.\\n\\n</details>"
                    }
                ]
            },
            {
                "id": 1929481,
                "content": [
                    {
                        "username": "Subhajit_Lai",
                        "content": "Input\\ns =\\n\"ab\"\\np =\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nanyone can please help with the logic "
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The output should be False because the input string didn\\'t end with a character \\'c\\' that was a part of the given regex `.*c`."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hi there, can someone tell me if this recursive method can be reduced in time complexity, or if the solution has to forcefully be with dynammic programming class Solution\\n{\\npublic:\\n    bool isMatch(std::string s, std::string p){\\n    // Base case:\\n    // 1. If p is empty, return the bool of s.empty\\n    // 1.1 if the current character is a \\'.\\' and next is a \\'*\\'\\n    // make two paths, one with p+=2 then recursive call\\n    // and the other recursive call with s+=1 and recursive call\\n    // Check if the curr is dot, or s[0] == p[0]\\n    // move in s and on p with the recursive call\\n        if(p.empty()) return s.empty();\\n        else{\\n            if(p.length() > 1){\\n                if(p[1] == \\'*\\') {\\n                    if(p[0] == s[0] || p[0] == \\'.\\' && s.length() > 0)\\n                        return(isMatch(s, p.substr(2)) || isMatch(s.substr(1), p));\\n                    return (isMatch(s, p.substr(2)));\\n                }\\n                if(p[0] == s[0] || p[0] == \\'.\\' &&  s.length() > 0)\\n                    return (isMatch(s.substr(1), p.substr(1)));\\n                else return false;\\n            }\\n            if(p.length() > 0 && s.length() > 0 && (p[0] == s[0] || p[0] == \\'.\\'))\\n                return (isMatch(s.substr(1), p.substr(1)));\\n            else return false;\\n        }\\n    }\\n};   "
                    },
                    {
                        "username": "aaryak4554",
                        "content": "pure recursive/backtrack solution beat 100% time and 80.17% memory... amazinggg"
                    },
                    {
                        "username": "geekyshark",
                        "content": "poorely worded question ,should have stated that \"a*\" means string can be empty too,there is no boundation on a to exist"
                    },
                    {
                        "username": "juliodondisch",
                        "content": "I got it down its just the memory limit i keep exceeding :/"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it ok?\\nCan someone explain please?\\n[ScreenShoot](https://imgbb.com/zPMXLF6)"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it oK?\\nCan someone explain please?\\n[Screenshot](https://ibb.co/zPMXLF6)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "how this is different from wildcard pattern matching problem?\\n"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "just giving few more testcase as it is necessary for understanding this question. \\uD83D\\uDC4D\\n `s = \"abcd\" p = \"j.*\" output = false`\\n `s = \"abcd\" p = \"j*.*\" output = true`"
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "`\".*\"` matches to **any character**, *not* just the first character encountered.\\n\\nIf `s = \"mystring\"` and `p = \".*\"`, the answer is `True`.\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\nTherefore, <code>.\\\\*</code> matches with <code>m</code>, <code>y</code>, <code>s</code>, <code>t</code>, <code>r</code>, <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\nWait a second! How can <code>r</code> match with any <code>r</code> in <code>s</code> if <code>.\\\\*</code> already matches all of the characters?\\nThe answer is, it doesn\\'t. <code>.\\\\*</code> only applies until the final instance of the next token is found.\\nTherefore, <code>.\\\\*</code> matches only <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nThis leaves <code>\"ing\"</code> unmatched, resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nAnd <code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\nLeaving <code>r</code> unmatched, as all the characters of <code>\"anotherstring\"</code> have already been matched: resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*.\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>.</code> matches with any single character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, and <code>n</code>.\\n<code>.</code> matches to <code>g</code>.\\n\\n</details>"
                    }
                ]
            },
            {
                "id": 1928012,
                "content": [
                    {
                        "username": "Subhajit_Lai",
                        "content": "Input\\ns =\\n\"ab\"\\np =\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nanyone can please help with the logic "
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The output should be False because the input string didn\\'t end with a character \\'c\\' that was a part of the given regex `.*c`."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hi there, can someone tell me if this recursive method can be reduced in time complexity, or if the solution has to forcefully be with dynammic programming class Solution\\n{\\npublic:\\n    bool isMatch(std::string s, std::string p){\\n    // Base case:\\n    // 1. If p is empty, return the bool of s.empty\\n    // 1.1 if the current character is a \\'.\\' and next is a \\'*\\'\\n    // make two paths, one with p+=2 then recursive call\\n    // and the other recursive call with s+=1 and recursive call\\n    // Check if the curr is dot, or s[0] == p[0]\\n    // move in s and on p with the recursive call\\n        if(p.empty()) return s.empty();\\n        else{\\n            if(p.length() > 1){\\n                if(p[1] == \\'*\\') {\\n                    if(p[0] == s[0] || p[0] == \\'.\\' && s.length() > 0)\\n                        return(isMatch(s, p.substr(2)) || isMatch(s.substr(1), p));\\n                    return (isMatch(s, p.substr(2)));\\n                }\\n                if(p[0] == s[0] || p[0] == \\'.\\' &&  s.length() > 0)\\n                    return (isMatch(s.substr(1), p.substr(1)));\\n                else return false;\\n            }\\n            if(p.length() > 0 && s.length() > 0 && (p[0] == s[0] || p[0] == \\'.\\'))\\n                return (isMatch(s.substr(1), p.substr(1)));\\n            else return false;\\n        }\\n    }\\n};   "
                    },
                    {
                        "username": "aaryak4554",
                        "content": "pure recursive/backtrack solution beat 100% time and 80.17% memory... amazinggg"
                    },
                    {
                        "username": "geekyshark",
                        "content": "poorely worded question ,should have stated that \"a*\" means string can be empty too,there is no boundation on a to exist"
                    },
                    {
                        "username": "juliodondisch",
                        "content": "I got it down its just the memory limit i keep exceeding :/"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it ok?\\nCan someone explain please?\\n[ScreenShoot](https://imgbb.com/zPMXLF6)"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it oK?\\nCan someone explain please?\\n[Screenshot](https://ibb.co/zPMXLF6)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "how this is different from wildcard pattern matching problem?\\n"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "just giving few more testcase as it is necessary for understanding this question. \\uD83D\\uDC4D\\n `s = \"abcd\" p = \"j.*\" output = false`\\n `s = \"abcd\" p = \"j*.*\" output = true`"
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "`\".*\"` matches to **any character**, *not* just the first character encountered.\\n\\nIf `s = \"mystring\"` and `p = \".*\"`, the answer is `True`.\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\nTherefore, <code>.\\\\*</code> matches with <code>m</code>, <code>y</code>, <code>s</code>, <code>t</code>, <code>r</code>, <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\nWait a second! How can <code>r</code> match with any <code>r</code> in <code>s</code> if <code>.\\\\*</code> already matches all of the characters?\\nThe answer is, it doesn\\'t. <code>.\\\\*</code> only applies until the final instance of the next token is found.\\nTherefore, <code>.\\\\*</code> matches only <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nThis leaves <code>\"ing\"</code> unmatched, resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nAnd <code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\nLeaving <code>r</code> unmatched, as all the characters of <code>\"anotherstring\"</code> have already been matched: resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*.\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>.</code> matches with any single character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, and <code>n</code>.\\n<code>.</code> matches to <code>g</code>.\\n\\n</details>"
                    }
                ]
            },
            {
                "id": 1914484,
                "content": [
                    {
                        "username": "Subhajit_Lai",
                        "content": "Input\\ns =\\n\"ab\"\\np =\\n\".*c\"\\nOutput\\ntrue\\nExpected\\nfalse\\n\\n\\nanyone can please help with the logic "
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The output should be False because the input string didn\\'t end with a character \\'c\\' that was a part of the given regex `.*c`."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hi there, can someone tell me if this recursive method can be reduced in time complexity, or if the solution has to forcefully be with dynammic programming class Solution\\n{\\npublic:\\n    bool isMatch(std::string s, std::string p){\\n    // Base case:\\n    // 1. If p is empty, return the bool of s.empty\\n    // 1.1 if the current character is a \\'.\\' and next is a \\'*\\'\\n    // make two paths, one with p+=2 then recursive call\\n    // and the other recursive call with s+=1 and recursive call\\n    // Check if the curr is dot, or s[0] == p[0]\\n    // move in s and on p with the recursive call\\n        if(p.empty()) return s.empty();\\n        else{\\n            if(p.length() > 1){\\n                if(p[1] == \\'*\\') {\\n                    if(p[0] == s[0] || p[0] == \\'.\\' && s.length() > 0)\\n                        return(isMatch(s, p.substr(2)) || isMatch(s.substr(1), p));\\n                    return (isMatch(s, p.substr(2)));\\n                }\\n                if(p[0] == s[0] || p[0] == \\'.\\' &&  s.length() > 0)\\n                    return (isMatch(s.substr(1), p.substr(1)));\\n                else return false;\\n            }\\n            if(p.length() > 0 && s.length() > 0 && (p[0] == s[0] || p[0] == \\'.\\'))\\n                return (isMatch(s.substr(1), p.substr(1)));\\n            else return false;\\n        }\\n    }\\n};   "
                    },
                    {
                        "username": "aaryak4554",
                        "content": "pure recursive/backtrack solution beat 100% time and 80.17% memory... amazinggg"
                    },
                    {
                        "username": "geekyshark",
                        "content": "poorely worded question ,should have stated that \"a*\" means string can be empty too,there is no boundation on a to exist"
                    },
                    {
                        "username": "juliodondisch",
                        "content": "I got it down its just the memory limit i keep exceeding :/"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it ok?\\nCan someone explain please?\\n[ScreenShoot](https://imgbb.com/zPMXLF6)"
                    },
                    {
                        "username": "Directume",
                        "content": "Is it oK?\\nCan someone explain please?\\n[Screenshot](https://ibb.co/zPMXLF6)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "how this is different from wildcard pattern matching problem?\\n"
                    },
                    {
                        "username": "lethal-bot",
                        "content": "just giving few more testcase as it is necessary for understanding this question. \\uD83D\\uDC4D\\n `s = \"abcd\" p = \"j.*\" output = false`\\n `s = \"abcd\" p = \"j*.*\" output = true`"
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "`\".*\"` matches to **any character**, *not* just the first character encountered.\\n\\nIf `s = \"mystring\"` and `p = \".*\"`, the answer is `True`.\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\nTherefore, <code>.\\\\*</code> matches with <code>m</code>, <code>y</code>, <code>s</code>, <code>t</code>, <code>r</code>, <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\nWait a second! How can <code>r</code> match with any <code>r</code> in <code>s</code> if <code>.\\\\*</code> already matches all of the characters?\\nThe answer is, it doesn\\'t. <code>.\\\\*</code> only applies until the final instance of the next token is found.\\nTherefore, <code>.\\\\*</code> matches only <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nThis leaves <code>\"ing\"</code> unmatched, resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\nAnd <code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*r\"`, the answer is `False`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, <code>n</code>, and <code>g</code>.\\nLeaving <code>r</code> unmatched, as all the characters of <code>\"anotherstring\"</code> have already been matched: resulting in the answer <code>False</code>.\\n\\n</details><br/>\\n\\nIf `s = \"anotherstring\"` and `p = \".*r.*.\"`, the answer is `True`.\\n\\n<details>\\n<summary>Explanation</summary>\\n\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>r</code> matches with a single <code>r</code> character.\\n<code>.</code> matches to any character.\\n<code>\\\\*</code> matches between 0 and infinity of the previous token, <code>.</code>\\n<code>.</code> matches with any single character.\\n\\nTherefore, <code>.\\\\*</code> matches to <code>a</code>, <code>n</code>, <code>o</code>, <code>t</code>, <code>h</code>, <code>e</code>, <code>r</code>, <code>s</code>, and <code>t</code>.\\n<code>r</code> matches to the final <code>r</code>.\\n<code>.\\\\*</code> matches to <code>i</code>, and <code>n</code>.\\n<code>.</code> matches to <code>g</code>.\\n\\n</details>"
                    }
                ]
            },
            {
                "id": 1907110,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "What's with this question ?!\n293 out of 354 passed. -_- and its a super long string\nI am gonna take a day off to debug it. :/"
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "Help me, please!\n \n\"aaa\" \"ab * a\" - false\nand  \"aab\"  \"c * a * b\" - true\n\nwhy? "
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "[@aleksamcode](/aleksamcode)  thanks, so much!"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- The pattern `ab*a` doesn't match the input string *aaa* fully but only partially. It doesn't fully match it because the pattern only contains two 'a' characters and the input has three 'a'. The pattern will match the first character 'a', then it will look for the 'b' character and will match it exactly zero times, and then it will match another 'a' character from the input, leaving the last 'a' unmatched.\n- The pattern `c*a*b` matches input *aab* fully: the pattern will match character 'c' exactly zero times, then it will match 'a' character as many times as possible due to usage of the `*` which is \"greedy\", and finally it will match exactly one character 'b'."
                    },
                    {
                        "username": "SI006288_Mohan",
                        "content": "Hi All,\\n\\nI think this question needs more clarity as we can see in the 3rd sample test case below they are expecting output true.\\n\\nInput: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nWhile executing similar test case in submit with the below inputs.\\nInput: s=\"ab\", p = \".*c\"\\n\\nit is expecting output false.\\n\\nIf anyone understand this case please reply me.\\n\\nThank you in advance"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The reason the pattern `.*c` doesn't match the input string *ab* is because it requires the input string to contain exactly one 'c' character. This means that for input \"ab\" will return False, but inputs like \"abc\" or  \"ababcabab\" will return True."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "s = \"aaa\"\\np = \".*\"\\nWhy it is True..?\\n\\nalso\\ns = \"aaa\"\\np = \"aaaa\"\\nWhy it should be True...?\\n\\nif it is right,\\ns = \"aaa\"\\np = \"aaab\"\\nIt should be true also, isn\\'t it...?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- '*' is \"**greedy**\", meaning it will try to match as many times as possible, which means the whole input *aaa* will be matched\n- Input string *aaa* will not be matched if the pattern is `aaaa`, because it requires exactly four 'a' characters. However, a pattern `aaaa*` will match the input string *aaa*, because the '*' at the end allows for the last character to be matched zero times.\n- Finally, the answer for the third question is similar as it was for the second. The pattern `aaab` will not match the input string *aaa*, but a pattern `aaab*` will."
                    },
                    {
                        "username": "vanshng",
                        "content": "s = \"aaa\"\\np = \"ab* a* c* a\"\\nhow is the expected output true here can anyone please explain?\\n(the string p doesn\\'t have spaces in between but i am not able to write the original string without leetcode\\'s website making it tampered)"
                    },
                    {
                        "username": "vanshng",
                        "content": "I'll try with that logic. Thanks."
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@vanshng](/vanshng) No, a* means 0 or a or aa or any number of times a can be like aaaaaaa\\u2026.., use this logic and run your code it will work "
                    },
                    {
                        "username": "vanshng",
                        "content": "a* can either be 0 or aa. So, your logic is wrong."
                    },
                    {
                        "username": "shashiram01",
                        "content": "In s, b zero times, c zero times and for a* one and so its true "
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "When s = \"ab\", p = \".*c\", why it should be False?\\nIsn\\'t it true?"
                    },
                    {
                        "username": "vanshng",
                        "content": "Because .* matches with ab but c is still there in the pattern which cannot be matched with anything. There should\\'ve been a \\'*\\' after c to match it with this string as c* means more of c or zero. So, it would\\'ve made c* negligible. Then it would\\'ve been true but in the original case it is false because there is only c left."
                    },
                    {
                        "username": "leetrio-1",
                        "content": "Is isMatch(\"aba\",\"*c*) a valid case?\\nThe expected output is False, and I don\\'t get it."
                    },
                    {
                        "username": "vanshng",
                        "content": "Yes it is a valid case the pattern does not contain even 1 letter in the \\'s\\' to begin with. The correct function should return False."
                    },
                    {
                        "username": "softengineerljh",
                        "content": "In the given testcase ,  isMatch(\"mississippi\", \"mis*is*p*.\") \\u2192 false;   my output is true,  but expected,  can someone explain it ,ths"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Take a look at this [answer](https://leetcode.com/problems/regular-expression-matching/description/comments/1883634)."
                    },
                    {
                        "username": "user9197pe",
                        "content": "I don\\'t get for the test case s=ab & p=.* how is the result true, as per the pattern it should be zero or more occurrence of a single character, right?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "A `*` quantifier is \"greedy\", meaning it will try to match character(s) as many times as possible, even though it can match zero characters. In the test case, pattern `.*` will try to match any character as many times as possible.\n\nFor example, for string \"aaaabd\", pattern `a*bc*d` will match the whole string; charters 'a' will be matched 4 times while charter 'c' will be matched 0 times."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "\\'*\\' Matches zero or more of the preceding element. is misleading"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "True, but if you know regex, then you know \\'*\\' is **greedy**, meaning that will try to match as many times as possible"
                    }
                ]
            },
            {
                "id": 1906469,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "What's with this question ?!\n293 out of 354 passed. -_- and its a super long string\nI am gonna take a day off to debug it. :/"
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "Help me, please!\n \n\"aaa\" \"ab * a\" - false\nand  \"aab\"  \"c * a * b\" - true\n\nwhy? "
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "[@aleksamcode](/aleksamcode)  thanks, so much!"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- The pattern `ab*a` doesn't match the input string *aaa* fully but only partially. It doesn't fully match it because the pattern only contains two 'a' characters and the input has three 'a'. The pattern will match the first character 'a', then it will look for the 'b' character and will match it exactly zero times, and then it will match another 'a' character from the input, leaving the last 'a' unmatched.\n- The pattern `c*a*b` matches input *aab* fully: the pattern will match character 'c' exactly zero times, then it will match 'a' character as many times as possible due to usage of the `*` which is \"greedy\", and finally it will match exactly one character 'b'."
                    },
                    {
                        "username": "SI006288_Mohan",
                        "content": "Hi All,\\n\\nI think this question needs more clarity as we can see in the 3rd sample test case below they are expecting output true.\\n\\nInput: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nWhile executing similar test case in submit with the below inputs.\\nInput: s=\"ab\", p = \".*c\"\\n\\nit is expecting output false.\\n\\nIf anyone understand this case please reply me.\\n\\nThank you in advance"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The reason the pattern `.*c` doesn't match the input string *ab* is because it requires the input string to contain exactly one 'c' character. This means that for input \"ab\" will return False, but inputs like \"abc\" or  \"ababcabab\" will return True."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "s = \"aaa\"\\np = \".*\"\\nWhy it is True..?\\n\\nalso\\ns = \"aaa\"\\np = \"aaaa\"\\nWhy it should be True...?\\n\\nif it is right,\\ns = \"aaa\"\\np = \"aaab\"\\nIt should be true also, isn\\'t it...?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- '*' is \"**greedy**\", meaning it will try to match as many times as possible, which means the whole input *aaa* will be matched\n- Input string *aaa* will not be matched if the pattern is `aaaa`, because it requires exactly four 'a' characters. However, a pattern `aaaa*` will match the input string *aaa*, because the '*' at the end allows for the last character to be matched zero times.\n- Finally, the answer for the third question is similar as it was for the second. The pattern `aaab` will not match the input string *aaa*, but a pattern `aaab*` will."
                    },
                    {
                        "username": "vanshng",
                        "content": "s = \"aaa\"\\np = \"ab* a* c* a\"\\nhow is the expected output true here can anyone please explain?\\n(the string p doesn\\'t have spaces in between but i am not able to write the original string without leetcode\\'s website making it tampered)"
                    },
                    {
                        "username": "vanshng",
                        "content": "I'll try with that logic. Thanks."
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@vanshng](/vanshng) No, a* means 0 or a or aa or any number of times a can be like aaaaaaa\\u2026.., use this logic and run your code it will work "
                    },
                    {
                        "username": "vanshng",
                        "content": "a* can either be 0 or aa. So, your logic is wrong."
                    },
                    {
                        "username": "shashiram01",
                        "content": "In s, b zero times, c zero times and for a* one and so its true "
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "When s = \"ab\", p = \".*c\", why it should be False?\\nIsn\\'t it true?"
                    },
                    {
                        "username": "vanshng",
                        "content": "Because .* matches with ab but c is still there in the pattern which cannot be matched with anything. There should\\'ve been a \\'*\\' after c to match it with this string as c* means more of c or zero. So, it would\\'ve made c* negligible. Then it would\\'ve been true but in the original case it is false because there is only c left."
                    },
                    {
                        "username": "leetrio-1",
                        "content": "Is isMatch(\"aba\",\"*c*) a valid case?\\nThe expected output is False, and I don\\'t get it."
                    },
                    {
                        "username": "vanshng",
                        "content": "Yes it is a valid case the pattern does not contain even 1 letter in the \\'s\\' to begin with. The correct function should return False."
                    },
                    {
                        "username": "softengineerljh",
                        "content": "In the given testcase ,  isMatch(\"mississippi\", \"mis*is*p*.\") \\u2192 false;   my output is true,  but expected,  can someone explain it ,ths"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Take a look at this [answer](https://leetcode.com/problems/regular-expression-matching/description/comments/1883634)."
                    },
                    {
                        "username": "user9197pe",
                        "content": "I don\\'t get for the test case s=ab & p=.* how is the result true, as per the pattern it should be zero or more occurrence of a single character, right?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "A `*` quantifier is \"greedy\", meaning it will try to match character(s) as many times as possible, even though it can match zero characters. In the test case, pattern `.*` will try to match any character as many times as possible.\n\nFor example, for string \"aaaabd\", pattern `a*bc*d` will match the whole string; charters 'a' will be matched 4 times while charter 'c' will be matched 0 times."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "\\'*\\' Matches zero or more of the preceding element. is misleading"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "True, but if you know regex, then you know \\'*\\' is **greedy**, meaning that will try to match as many times as possible"
                    }
                ]
            },
            {
                "id": 1904108,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "What's with this question ?!\n293 out of 354 passed. -_- and its a super long string\nI am gonna take a day off to debug it. :/"
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "Help me, please!\n \n\"aaa\" \"ab * a\" - false\nand  \"aab\"  \"c * a * b\" - true\n\nwhy? "
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "[@aleksamcode](/aleksamcode)  thanks, so much!"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- The pattern `ab*a` doesn't match the input string *aaa* fully but only partially. It doesn't fully match it because the pattern only contains two 'a' characters and the input has three 'a'. The pattern will match the first character 'a', then it will look for the 'b' character and will match it exactly zero times, and then it will match another 'a' character from the input, leaving the last 'a' unmatched.\n- The pattern `c*a*b` matches input *aab* fully: the pattern will match character 'c' exactly zero times, then it will match 'a' character as many times as possible due to usage of the `*` which is \"greedy\", and finally it will match exactly one character 'b'."
                    },
                    {
                        "username": "SI006288_Mohan",
                        "content": "Hi All,\\n\\nI think this question needs more clarity as we can see in the 3rd sample test case below they are expecting output true.\\n\\nInput: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nWhile executing similar test case in submit with the below inputs.\\nInput: s=\"ab\", p = \".*c\"\\n\\nit is expecting output false.\\n\\nIf anyone understand this case please reply me.\\n\\nThank you in advance"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The reason the pattern `.*c` doesn't match the input string *ab* is because it requires the input string to contain exactly one 'c' character. This means that for input \"ab\" will return False, but inputs like \"abc\" or  \"ababcabab\" will return True."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "s = \"aaa\"\\np = \".*\"\\nWhy it is True..?\\n\\nalso\\ns = \"aaa\"\\np = \"aaaa\"\\nWhy it should be True...?\\n\\nif it is right,\\ns = \"aaa\"\\np = \"aaab\"\\nIt should be true also, isn\\'t it...?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- '*' is \"**greedy**\", meaning it will try to match as many times as possible, which means the whole input *aaa* will be matched\n- Input string *aaa* will not be matched if the pattern is `aaaa`, because it requires exactly four 'a' characters. However, a pattern `aaaa*` will match the input string *aaa*, because the '*' at the end allows for the last character to be matched zero times.\n- Finally, the answer for the third question is similar as it was for the second. The pattern `aaab` will not match the input string *aaa*, but a pattern `aaab*` will."
                    },
                    {
                        "username": "vanshng",
                        "content": "s = \"aaa\"\\np = \"ab* a* c* a\"\\nhow is the expected output true here can anyone please explain?\\n(the string p doesn\\'t have spaces in between but i am not able to write the original string without leetcode\\'s website making it tampered)"
                    },
                    {
                        "username": "vanshng",
                        "content": "I'll try with that logic. Thanks."
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@vanshng](/vanshng) No, a* means 0 or a or aa or any number of times a can be like aaaaaaa\\u2026.., use this logic and run your code it will work "
                    },
                    {
                        "username": "vanshng",
                        "content": "a* can either be 0 or aa. So, your logic is wrong."
                    },
                    {
                        "username": "shashiram01",
                        "content": "In s, b zero times, c zero times and for a* one and so its true "
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "When s = \"ab\", p = \".*c\", why it should be False?\\nIsn\\'t it true?"
                    },
                    {
                        "username": "vanshng",
                        "content": "Because .* matches with ab but c is still there in the pattern which cannot be matched with anything. There should\\'ve been a \\'*\\' after c to match it with this string as c* means more of c or zero. So, it would\\'ve made c* negligible. Then it would\\'ve been true but in the original case it is false because there is only c left."
                    },
                    {
                        "username": "leetrio-1",
                        "content": "Is isMatch(\"aba\",\"*c*) a valid case?\\nThe expected output is False, and I don\\'t get it."
                    },
                    {
                        "username": "vanshng",
                        "content": "Yes it is a valid case the pattern does not contain even 1 letter in the \\'s\\' to begin with. The correct function should return False."
                    },
                    {
                        "username": "softengineerljh",
                        "content": "In the given testcase ,  isMatch(\"mississippi\", \"mis*is*p*.\") \\u2192 false;   my output is true,  but expected,  can someone explain it ,ths"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Take a look at this [answer](https://leetcode.com/problems/regular-expression-matching/description/comments/1883634)."
                    },
                    {
                        "username": "user9197pe",
                        "content": "I don\\'t get for the test case s=ab & p=.* how is the result true, as per the pattern it should be zero or more occurrence of a single character, right?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "A `*` quantifier is \"greedy\", meaning it will try to match character(s) as many times as possible, even though it can match zero characters. In the test case, pattern `.*` will try to match any character as many times as possible.\n\nFor example, for string \"aaaabd\", pattern `a*bc*d` will match the whole string; charters 'a' will be matched 4 times while charter 'c' will be matched 0 times."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "\\'*\\' Matches zero or more of the preceding element. is misleading"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "True, but if you know regex, then you know \\'*\\' is **greedy**, meaning that will try to match as many times as possible"
                    }
                ]
            },
            {
                "id": 1903780,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "What's with this question ?!\n293 out of 354 passed. -_- and its a super long string\nI am gonna take a day off to debug it. :/"
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "Help me, please!\n \n\"aaa\" \"ab * a\" - false\nand  \"aab\"  \"c * a * b\" - true\n\nwhy? "
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "[@aleksamcode](/aleksamcode)  thanks, so much!"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- The pattern `ab*a` doesn't match the input string *aaa* fully but only partially. It doesn't fully match it because the pattern only contains two 'a' characters and the input has three 'a'. The pattern will match the first character 'a', then it will look for the 'b' character and will match it exactly zero times, and then it will match another 'a' character from the input, leaving the last 'a' unmatched.\n- The pattern `c*a*b` matches input *aab* fully: the pattern will match character 'c' exactly zero times, then it will match 'a' character as many times as possible due to usage of the `*` which is \"greedy\", and finally it will match exactly one character 'b'."
                    },
                    {
                        "username": "SI006288_Mohan",
                        "content": "Hi All,\\n\\nI think this question needs more clarity as we can see in the 3rd sample test case below they are expecting output true.\\n\\nInput: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nWhile executing similar test case in submit with the below inputs.\\nInput: s=\"ab\", p = \".*c\"\\n\\nit is expecting output false.\\n\\nIf anyone understand this case please reply me.\\n\\nThank you in advance"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The reason the pattern `.*c` doesn't match the input string *ab* is because it requires the input string to contain exactly one 'c' character. This means that for input \"ab\" will return False, but inputs like \"abc\" or  \"ababcabab\" will return True."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "s = \"aaa\"\\np = \".*\"\\nWhy it is True..?\\n\\nalso\\ns = \"aaa\"\\np = \"aaaa\"\\nWhy it should be True...?\\n\\nif it is right,\\ns = \"aaa\"\\np = \"aaab\"\\nIt should be true also, isn\\'t it...?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- '*' is \"**greedy**\", meaning it will try to match as many times as possible, which means the whole input *aaa* will be matched\n- Input string *aaa* will not be matched if the pattern is `aaaa`, because it requires exactly four 'a' characters. However, a pattern `aaaa*` will match the input string *aaa*, because the '*' at the end allows for the last character to be matched zero times.\n- Finally, the answer for the third question is similar as it was for the second. The pattern `aaab` will not match the input string *aaa*, but a pattern `aaab*` will."
                    },
                    {
                        "username": "vanshng",
                        "content": "s = \"aaa\"\\np = \"ab* a* c* a\"\\nhow is the expected output true here can anyone please explain?\\n(the string p doesn\\'t have spaces in between but i am not able to write the original string without leetcode\\'s website making it tampered)"
                    },
                    {
                        "username": "vanshng",
                        "content": "I'll try with that logic. Thanks."
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@vanshng](/vanshng) No, a* means 0 or a or aa or any number of times a can be like aaaaaaa\\u2026.., use this logic and run your code it will work "
                    },
                    {
                        "username": "vanshng",
                        "content": "a* can either be 0 or aa. So, your logic is wrong."
                    },
                    {
                        "username": "shashiram01",
                        "content": "In s, b zero times, c zero times and for a* one and so its true "
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "When s = \"ab\", p = \".*c\", why it should be False?\\nIsn\\'t it true?"
                    },
                    {
                        "username": "vanshng",
                        "content": "Because .* matches with ab but c is still there in the pattern which cannot be matched with anything. There should\\'ve been a \\'*\\' after c to match it with this string as c* means more of c or zero. So, it would\\'ve made c* negligible. Then it would\\'ve been true but in the original case it is false because there is only c left."
                    },
                    {
                        "username": "leetrio-1",
                        "content": "Is isMatch(\"aba\",\"*c*) a valid case?\\nThe expected output is False, and I don\\'t get it."
                    },
                    {
                        "username": "vanshng",
                        "content": "Yes it is a valid case the pattern does not contain even 1 letter in the \\'s\\' to begin with. The correct function should return False."
                    },
                    {
                        "username": "softengineerljh",
                        "content": "In the given testcase ,  isMatch(\"mississippi\", \"mis*is*p*.\") \\u2192 false;   my output is true,  but expected,  can someone explain it ,ths"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Take a look at this [answer](https://leetcode.com/problems/regular-expression-matching/description/comments/1883634)."
                    },
                    {
                        "username": "user9197pe",
                        "content": "I don\\'t get for the test case s=ab & p=.* how is the result true, as per the pattern it should be zero or more occurrence of a single character, right?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "A `*` quantifier is \"greedy\", meaning it will try to match character(s) as many times as possible, even though it can match zero characters. In the test case, pattern `.*` will try to match any character as many times as possible.\n\nFor example, for string \"aaaabd\", pattern `a*bc*d` will match the whole string; charters 'a' will be matched 4 times while charter 'c' will be matched 0 times."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "\\'*\\' Matches zero or more of the preceding element. is misleading"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "True, but if you know regex, then you know \\'*\\' is **greedy**, meaning that will try to match as many times as possible"
                    }
                ]
            },
            {
                "id": 1896009,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "What's with this question ?!\n293 out of 354 passed. -_- and its a super long string\nI am gonna take a day off to debug it. :/"
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "Help me, please!\n \n\"aaa\" \"ab * a\" - false\nand  \"aab\"  \"c * a * b\" - true\n\nwhy? "
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "[@aleksamcode](/aleksamcode)  thanks, so much!"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- The pattern `ab*a` doesn't match the input string *aaa* fully but only partially. It doesn't fully match it because the pattern only contains two 'a' characters and the input has three 'a'. The pattern will match the first character 'a', then it will look for the 'b' character and will match it exactly zero times, and then it will match another 'a' character from the input, leaving the last 'a' unmatched.\n- The pattern `c*a*b` matches input *aab* fully: the pattern will match character 'c' exactly zero times, then it will match 'a' character as many times as possible due to usage of the `*` which is \"greedy\", and finally it will match exactly one character 'b'."
                    },
                    {
                        "username": "SI006288_Mohan",
                        "content": "Hi All,\\n\\nI think this question needs more clarity as we can see in the 3rd sample test case below they are expecting output true.\\n\\nInput: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nWhile executing similar test case in submit with the below inputs.\\nInput: s=\"ab\", p = \".*c\"\\n\\nit is expecting output false.\\n\\nIf anyone understand this case please reply me.\\n\\nThank you in advance"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The reason the pattern `.*c` doesn't match the input string *ab* is because it requires the input string to contain exactly one 'c' character. This means that for input \"ab\" will return False, but inputs like \"abc\" or  \"ababcabab\" will return True."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "s = \"aaa\"\\np = \".*\"\\nWhy it is True..?\\n\\nalso\\ns = \"aaa\"\\np = \"aaaa\"\\nWhy it should be True...?\\n\\nif it is right,\\ns = \"aaa\"\\np = \"aaab\"\\nIt should be true also, isn\\'t it...?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- '*' is \"**greedy**\", meaning it will try to match as many times as possible, which means the whole input *aaa* will be matched\n- Input string *aaa* will not be matched if the pattern is `aaaa`, because it requires exactly four 'a' characters. However, a pattern `aaaa*` will match the input string *aaa*, because the '*' at the end allows for the last character to be matched zero times.\n- Finally, the answer for the third question is similar as it was for the second. The pattern `aaab` will not match the input string *aaa*, but a pattern `aaab*` will."
                    },
                    {
                        "username": "vanshng",
                        "content": "s = \"aaa\"\\np = \"ab* a* c* a\"\\nhow is the expected output true here can anyone please explain?\\n(the string p doesn\\'t have spaces in between but i am not able to write the original string without leetcode\\'s website making it tampered)"
                    },
                    {
                        "username": "vanshng",
                        "content": "I'll try with that logic. Thanks."
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@vanshng](/vanshng) No, a* means 0 or a or aa or any number of times a can be like aaaaaaa\\u2026.., use this logic and run your code it will work "
                    },
                    {
                        "username": "vanshng",
                        "content": "a* can either be 0 or aa. So, your logic is wrong."
                    },
                    {
                        "username": "shashiram01",
                        "content": "In s, b zero times, c zero times and for a* one and so its true "
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "When s = \"ab\", p = \".*c\", why it should be False?\\nIsn\\'t it true?"
                    },
                    {
                        "username": "vanshng",
                        "content": "Because .* matches with ab but c is still there in the pattern which cannot be matched with anything. There should\\'ve been a \\'*\\' after c to match it with this string as c* means more of c or zero. So, it would\\'ve made c* negligible. Then it would\\'ve been true but in the original case it is false because there is only c left."
                    },
                    {
                        "username": "leetrio-1",
                        "content": "Is isMatch(\"aba\",\"*c*) a valid case?\\nThe expected output is False, and I don\\'t get it."
                    },
                    {
                        "username": "vanshng",
                        "content": "Yes it is a valid case the pattern does not contain even 1 letter in the \\'s\\' to begin with. The correct function should return False."
                    },
                    {
                        "username": "softengineerljh",
                        "content": "In the given testcase ,  isMatch(\"mississippi\", \"mis*is*p*.\") \\u2192 false;   my output is true,  but expected,  can someone explain it ,ths"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Take a look at this [answer](https://leetcode.com/problems/regular-expression-matching/description/comments/1883634)."
                    },
                    {
                        "username": "user9197pe",
                        "content": "I don\\'t get for the test case s=ab & p=.* how is the result true, as per the pattern it should be zero or more occurrence of a single character, right?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "A `*` quantifier is \"greedy\", meaning it will try to match character(s) as many times as possible, even though it can match zero characters. In the test case, pattern `.*` will try to match any character as many times as possible.\n\nFor example, for string \"aaaabd\", pattern `a*bc*d` will match the whole string; charters 'a' will be matched 4 times while charter 'c' will be matched 0 times."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "\\'*\\' Matches zero or more of the preceding element. is misleading"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "True, but if you know regex, then you know \\'*\\' is **greedy**, meaning that will try to match as many times as possible"
                    }
                ]
            },
            {
                "id": 1895655,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "What's with this question ?!\n293 out of 354 passed. -_- and its a super long string\nI am gonna take a day off to debug it. :/"
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "Help me, please!\n \n\"aaa\" \"ab * a\" - false\nand  \"aab\"  \"c * a * b\" - true\n\nwhy? "
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "[@aleksamcode](/aleksamcode)  thanks, so much!"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- The pattern `ab*a` doesn't match the input string *aaa* fully but only partially. It doesn't fully match it because the pattern only contains two 'a' characters and the input has three 'a'. The pattern will match the first character 'a', then it will look for the 'b' character and will match it exactly zero times, and then it will match another 'a' character from the input, leaving the last 'a' unmatched.\n- The pattern `c*a*b` matches input *aab* fully: the pattern will match character 'c' exactly zero times, then it will match 'a' character as many times as possible due to usage of the `*` which is \"greedy\", and finally it will match exactly one character 'b'."
                    },
                    {
                        "username": "SI006288_Mohan",
                        "content": "Hi All,\\n\\nI think this question needs more clarity as we can see in the 3rd sample test case below they are expecting output true.\\n\\nInput: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nWhile executing similar test case in submit with the below inputs.\\nInput: s=\"ab\", p = \".*c\"\\n\\nit is expecting output false.\\n\\nIf anyone understand this case please reply me.\\n\\nThank you in advance"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The reason the pattern `.*c` doesn't match the input string *ab* is because it requires the input string to contain exactly one 'c' character. This means that for input \"ab\" will return False, but inputs like \"abc\" or  \"ababcabab\" will return True."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "s = \"aaa\"\\np = \".*\"\\nWhy it is True..?\\n\\nalso\\ns = \"aaa\"\\np = \"aaaa\"\\nWhy it should be True...?\\n\\nif it is right,\\ns = \"aaa\"\\np = \"aaab\"\\nIt should be true also, isn\\'t it...?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- '*' is \"**greedy**\", meaning it will try to match as many times as possible, which means the whole input *aaa* will be matched\n- Input string *aaa* will not be matched if the pattern is `aaaa`, because it requires exactly four 'a' characters. However, a pattern `aaaa*` will match the input string *aaa*, because the '*' at the end allows for the last character to be matched zero times.\n- Finally, the answer for the third question is similar as it was for the second. The pattern `aaab` will not match the input string *aaa*, but a pattern `aaab*` will."
                    },
                    {
                        "username": "vanshng",
                        "content": "s = \"aaa\"\\np = \"ab* a* c* a\"\\nhow is the expected output true here can anyone please explain?\\n(the string p doesn\\'t have spaces in between but i am not able to write the original string without leetcode\\'s website making it tampered)"
                    },
                    {
                        "username": "vanshng",
                        "content": "I'll try with that logic. Thanks."
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@vanshng](/vanshng) No, a* means 0 or a or aa or any number of times a can be like aaaaaaa\\u2026.., use this logic and run your code it will work "
                    },
                    {
                        "username": "vanshng",
                        "content": "a* can either be 0 or aa. So, your logic is wrong."
                    },
                    {
                        "username": "shashiram01",
                        "content": "In s, b zero times, c zero times and for a* one and so its true "
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "When s = \"ab\", p = \".*c\", why it should be False?\\nIsn\\'t it true?"
                    },
                    {
                        "username": "vanshng",
                        "content": "Because .* matches with ab but c is still there in the pattern which cannot be matched with anything. There should\\'ve been a \\'*\\' after c to match it with this string as c* means more of c or zero. So, it would\\'ve made c* negligible. Then it would\\'ve been true but in the original case it is false because there is only c left."
                    },
                    {
                        "username": "leetrio-1",
                        "content": "Is isMatch(\"aba\",\"*c*) a valid case?\\nThe expected output is False, and I don\\'t get it."
                    },
                    {
                        "username": "vanshng",
                        "content": "Yes it is a valid case the pattern does not contain even 1 letter in the \\'s\\' to begin with. The correct function should return False."
                    },
                    {
                        "username": "softengineerljh",
                        "content": "In the given testcase ,  isMatch(\"mississippi\", \"mis*is*p*.\") \\u2192 false;   my output is true,  but expected,  can someone explain it ,ths"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Take a look at this [answer](https://leetcode.com/problems/regular-expression-matching/description/comments/1883634)."
                    },
                    {
                        "username": "user9197pe",
                        "content": "I don\\'t get for the test case s=ab & p=.* how is the result true, as per the pattern it should be zero or more occurrence of a single character, right?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "A `*` quantifier is \"greedy\", meaning it will try to match character(s) as many times as possible, even though it can match zero characters. In the test case, pattern `.*` will try to match any character as many times as possible.\n\nFor example, for string \"aaaabd\", pattern `a*bc*d` will match the whole string; charters 'a' will be matched 4 times while charter 'c' will be matched 0 times."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "\\'*\\' Matches zero or more of the preceding element. is misleading"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "True, but if you know regex, then you know \\'*\\' is **greedy**, meaning that will try to match as many times as possible"
                    }
                ]
            },
            {
                "id": 1893491,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "What's with this question ?!\n293 out of 354 passed. -_- and its a super long string\nI am gonna take a day off to debug it. :/"
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "Help me, please!\n \n\"aaa\" \"ab * a\" - false\nand  \"aab\"  \"c * a * b\" - true\n\nwhy? "
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "[@aleksamcode](/aleksamcode)  thanks, so much!"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- The pattern `ab*a` doesn't match the input string *aaa* fully but only partially. It doesn't fully match it because the pattern only contains two 'a' characters and the input has three 'a'. The pattern will match the first character 'a', then it will look for the 'b' character and will match it exactly zero times, and then it will match another 'a' character from the input, leaving the last 'a' unmatched.\n- The pattern `c*a*b` matches input *aab* fully: the pattern will match character 'c' exactly zero times, then it will match 'a' character as many times as possible due to usage of the `*` which is \"greedy\", and finally it will match exactly one character 'b'."
                    },
                    {
                        "username": "SI006288_Mohan",
                        "content": "Hi All,\\n\\nI think this question needs more clarity as we can see in the 3rd sample test case below they are expecting output true.\\n\\nInput: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nWhile executing similar test case in submit with the below inputs.\\nInput: s=\"ab\", p = \".*c\"\\n\\nit is expecting output false.\\n\\nIf anyone understand this case please reply me.\\n\\nThank you in advance"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The reason the pattern `.*c` doesn't match the input string *ab* is because it requires the input string to contain exactly one 'c' character. This means that for input \"ab\" will return False, but inputs like \"abc\" or  \"ababcabab\" will return True."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "s = \"aaa\"\\np = \".*\"\\nWhy it is True..?\\n\\nalso\\ns = \"aaa\"\\np = \"aaaa\"\\nWhy it should be True...?\\n\\nif it is right,\\ns = \"aaa\"\\np = \"aaab\"\\nIt should be true also, isn\\'t it...?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- '*' is \"**greedy**\", meaning it will try to match as many times as possible, which means the whole input *aaa* will be matched\n- Input string *aaa* will not be matched if the pattern is `aaaa`, because it requires exactly four 'a' characters. However, a pattern `aaaa*` will match the input string *aaa*, because the '*' at the end allows for the last character to be matched zero times.\n- Finally, the answer for the third question is similar as it was for the second. The pattern `aaab` will not match the input string *aaa*, but a pattern `aaab*` will."
                    },
                    {
                        "username": "vanshng",
                        "content": "s = \"aaa\"\\np = \"ab* a* c* a\"\\nhow is the expected output true here can anyone please explain?\\n(the string p doesn\\'t have spaces in between but i am not able to write the original string without leetcode\\'s website making it tampered)"
                    },
                    {
                        "username": "vanshng",
                        "content": "I'll try with that logic. Thanks."
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@vanshng](/vanshng) No, a* means 0 or a or aa or any number of times a can be like aaaaaaa\\u2026.., use this logic and run your code it will work "
                    },
                    {
                        "username": "vanshng",
                        "content": "a* can either be 0 or aa. So, your logic is wrong."
                    },
                    {
                        "username": "shashiram01",
                        "content": "In s, b zero times, c zero times and for a* one and so its true "
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "When s = \"ab\", p = \".*c\", why it should be False?\\nIsn\\'t it true?"
                    },
                    {
                        "username": "vanshng",
                        "content": "Because .* matches with ab but c is still there in the pattern which cannot be matched with anything. There should\\'ve been a \\'*\\' after c to match it with this string as c* means more of c or zero. So, it would\\'ve made c* negligible. Then it would\\'ve been true but in the original case it is false because there is only c left."
                    },
                    {
                        "username": "leetrio-1",
                        "content": "Is isMatch(\"aba\",\"*c*) a valid case?\\nThe expected output is False, and I don\\'t get it."
                    },
                    {
                        "username": "vanshng",
                        "content": "Yes it is a valid case the pattern does not contain even 1 letter in the \\'s\\' to begin with. The correct function should return False."
                    },
                    {
                        "username": "softengineerljh",
                        "content": "In the given testcase ,  isMatch(\"mississippi\", \"mis*is*p*.\") \\u2192 false;   my output is true,  but expected,  can someone explain it ,ths"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Take a look at this [answer](https://leetcode.com/problems/regular-expression-matching/description/comments/1883634)."
                    },
                    {
                        "username": "user9197pe",
                        "content": "I don\\'t get for the test case s=ab & p=.* how is the result true, as per the pattern it should be zero or more occurrence of a single character, right?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "A `*` quantifier is \"greedy\", meaning it will try to match character(s) as many times as possible, even though it can match zero characters. In the test case, pattern `.*` will try to match any character as many times as possible.\n\nFor example, for string \"aaaabd\", pattern `a*bc*d` will match the whole string; charters 'a' will be matched 4 times while charter 'c' will be matched 0 times."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "\\'*\\' Matches zero or more of the preceding element. is misleading"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "True, but if you know regex, then you know \\'*\\' is **greedy**, meaning that will try to match as many times as possible"
                    }
                ]
            },
            {
                "id": 1887377,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "What's with this question ?!\n293 out of 354 passed. -_- and its a super long string\nI am gonna take a day off to debug it. :/"
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "Help me, please!\n \n\"aaa\" \"ab * a\" - false\nand  \"aab\"  \"c * a * b\" - true\n\nwhy? "
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "[@aleksamcode](/aleksamcode)  thanks, so much!"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- The pattern `ab*a` doesn't match the input string *aaa* fully but only partially. It doesn't fully match it because the pattern only contains two 'a' characters and the input has three 'a'. The pattern will match the first character 'a', then it will look for the 'b' character and will match it exactly zero times, and then it will match another 'a' character from the input, leaving the last 'a' unmatched.\n- The pattern `c*a*b` matches input *aab* fully: the pattern will match character 'c' exactly zero times, then it will match 'a' character as many times as possible due to usage of the `*` which is \"greedy\", and finally it will match exactly one character 'b'."
                    },
                    {
                        "username": "SI006288_Mohan",
                        "content": "Hi All,\\n\\nI think this question needs more clarity as we can see in the 3rd sample test case below they are expecting output true.\\n\\nInput: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nWhile executing similar test case in submit with the below inputs.\\nInput: s=\"ab\", p = \".*c\"\\n\\nit is expecting output false.\\n\\nIf anyone understand this case please reply me.\\n\\nThank you in advance"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The reason the pattern `.*c` doesn't match the input string *ab* is because it requires the input string to contain exactly one 'c' character. This means that for input \"ab\" will return False, but inputs like \"abc\" or  \"ababcabab\" will return True."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "s = \"aaa\"\\np = \".*\"\\nWhy it is True..?\\n\\nalso\\ns = \"aaa\"\\np = \"aaaa\"\\nWhy it should be True...?\\n\\nif it is right,\\ns = \"aaa\"\\np = \"aaab\"\\nIt should be true also, isn\\'t it...?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- '*' is \"**greedy**\", meaning it will try to match as many times as possible, which means the whole input *aaa* will be matched\n- Input string *aaa* will not be matched if the pattern is `aaaa`, because it requires exactly four 'a' characters. However, a pattern `aaaa*` will match the input string *aaa*, because the '*' at the end allows for the last character to be matched zero times.\n- Finally, the answer for the third question is similar as it was for the second. The pattern `aaab` will not match the input string *aaa*, but a pattern `aaab*` will."
                    },
                    {
                        "username": "vanshng",
                        "content": "s = \"aaa\"\\np = \"ab* a* c* a\"\\nhow is the expected output true here can anyone please explain?\\n(the string p doesn\\'t have spaces in between but i am not able to write the original string without leetcode\\'s website making it tampered)"
                    },
                    {
                        "username": "vanshng",
                        "content": "I'll try with that logic. Thanks."
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@vanshng](/vanshng) No, a* means 0 or a or aa or any number of times a can be like aaaaaaa\\u2026.., use this logic and run your code it will work "
                    },
                    {
                        "username": "vanshng",
                        "content": "a* can either be 0 or aa. So, your logic is wrong."
                    },
                    {
                        "username": "shashiram01",
                        "content": "In s, b zero times, c zero times and for a* one and so its true "
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "When s = \"ab\", p = \".*c\", why it should be False?\\nIsn\\'t it true?"
                    },
                    {
                        "username": "vanshng",
                        "content": "Because .* matches with ab but c is still there in the pattern which cannot be matched with anything. There should\\'ve been a \\'*\\' after c to match it with this string as c* means more of c or zero. So, it would\\'ve made c* negligible. Then it would\\'ve been true but in the original case it is false because there is only c left."
                    },
                    {
                        "username": "leetrio-1",
                        "content": "Is isMatch(\"aba\",\"*c*) a valid case?\\nThe expected output is False, and I don\\'t get it."
                    },
                    {
                        "username": "vanshng",
                        "content": "Yes it is a valid case the pattern does not contain even 1 letter in the \\'s\\' to begin with. The correct function should return False."
                    },
                    {
                        "username": "softengineerljh",
                        "content": "In the given testcase ,  isMatch(\"mississippi\", \"mis*is*p*.\") \\u2192 false;   my output is true,  but expected,  can someone explain it ,ths"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Take a look at this [answer](https://leetcode.com/problems/regular-expression-matching/description/comments/1883634)."
                    },
                    {
                        "username": "user9197pe",
                        "content": "I don\\'t get for the test case s=ab & p=.* how is the result true, as per the pattern it should be zero or more occurrence of a single character, right?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "A `*` quantifier is \"greedy\", meaning it will try to match character(s) as many times as possible, even though it can match zero characters. In the test case, pattern `.*` will try to match any character as many times as possible.\n\nFor example, for string \"aaaabd\", pattern `a*bc*d` will match the whole string; charters 'a' will be matched 4 times while charter 'c' will be matched 0 times."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "\\'*\\' Matches zero or more of the preceding element. is misleading"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "True, but if you know regex, then you know \\'*\\' is **greedy**, meaning that will try to match as many times as possible"
                    }
                ]
            },
            {
                "id": 1886352,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "What's with this question ?!\n293 out of 354 passed. -_- and its a super long string\nI am gonna take a day off to debug it. :/"
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "Help me, please!\n \n\"aaa\" \"ab * a\" - false\nand  \"aab\"  \"c * a * b\" - true\n\nwhy? "
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "[@aleksamcode](/aleksamcode)  thanks, so much!"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- The pattern `ab*a` doesn't match the input string *aaa* fully but only partially. It doesn't fully match it because the pattern only contains two 'a' characters and the input has three 'a'. The pattern will match the first character 'a', then it will look for the 'b' character and will match it exactly zero times, and then it will match another 'a' character from the input, leaving the last 'a' unmatched.\n- The pattern `c*a*b` matches input *aab* fully: the pattern will match character 'c' exactly zero times, then it will match 'a' character as many times as possible due to usage of the `*` which is \"greedy\", and finally it will match exactly one character 'b'."
                    },
                    {
                        "username": "SI006288_Mohan",
                        "content": "Hi All,\\n\\nI think this question needs more clarity as we can see in the 3rd sample test case below they are expecting output true.\\n\\nInput: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nWhile executing similar test case in submit with the below inputs.\\nInput: s=\"ab\", p = \".*c\"\\n\\nit is expecting output false.\\n\\nIf anyone understand this case please reply me.\\n\\nThank you in advance"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The reason the pattern `.*c` doesn't match the input string *ab* is because it requires the input string to contain exactly one 'c' character. This means that for input \"ab\" will return False, but inputs like \"abc\" or  \"ababcabab\" will return True."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "s = \"aaa\"\\np = \".*\"\\nWhy it is True..?\\n\\nalso\\ns = \"aaa\"\\np = \"aaaa\"\\nWhy it should be True...?\\n\\nif it is right,\\ns = \"aaa\"\\np = \"aaab\"\\nIt should be true also, isn\\'t it...?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- '*' is \"**greedy**\", meaning it will try to match as many times as possible, which means the whole input *aaa* will be matched\n- Input string *aaa* will not be matched if the pattern is `aaaa`, because it requires exactly four 'a' characters. However, a pattern `aaaa*` will match the input string *aaa*, because the '*' at the end allows for the last character to be matched zero times.\n- Finally, the answer for the third question is similar as it was for the second. The pattern `aaab` will not match the input string *aaa*, but a pattern `aaab*` will."
                    },
                    {
                        "username": "vanshng",
                        "content": "s = \"aaa\"\\np = \"ab* a* c* a\"\\nhow is the expected output true here can anyone please explain?\\n(the string p doesn\\'t have spaces in between but i am not able to write the original string without leetcode\\'s website making it tampered)"
                    },
                    {
                        "username": "vanshng",
                        "content": "I'll try with that logic. Thanks."
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@vanshng](/vanshng) No, a* means 0 or a or aa or any number of times a can be like aaaaaaa\\u2026.., use this logic and run your code it will work "
                    },
                    {
                        "username": "vanshng",
                        "content": "a* can either be 0 or aa. So, your logic is wrong."
                    },
                    {
                        "username": "shashiram01",
                        "content": "In s, b zero times, c zero times and for a* one and so its true "
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "When s = \"ab\", p = \".*c\", why it should be False?\\nIsn\\'t it true?"
                    },
                    {
                        "username": "vanshng",
                        "content": "Because .* matches with ab but c is still there in the pattern which cannot be matched with anything. There should\\'ve been a \\'*\\' after c to match it with this string as c* means more of c or zero. So, it would\\'ve made c* negligible. Then it would\\'ve been true but in the original case it is false because there is only c left."
                    },
                    {
                        "username": "leetrio-1",
                        "content": "Is isMatch(\"aba\",\"*c*) a valid case?\\nThe expected output is False, and I don\\'t get it."
                    },
                    {
                        "username": "vanshng",
                        "content": "Yes it is a valid case the pattern does not contain even 1 letter in the \\'s\\' to begin with. The correct function should return False."
                    },
                    {
                        "username": "softengineerljh",
                        "content": "In the given testcase ,  isMatch(\"mississippi\", \"mis*is*p*.\") \\u2192 false;   my output is true,  but expected,  can someone explain it ,ths"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Take a look at this [answer](https://leetcode.com/problems/regular-expression-matching/description/comments/1883634)."
                    },
                    {
                        "username": "user9197pe",
                        "content": "I don\\'t get for the test case s=ab & p=.* how is the result true, as per the pattern it should be zero or more occurrence of a single character, right?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "A `*` quantifier is \"greedy\", meaning it will try to match character(s) as many times as possible, even though it can match zero characters. In the test case, pattern `.*` will try to match any character as many times as possible.\n\nFor example, for string \"aaaabd\", pattern `a*bc*d` will match the whole string; charters 'a' will be matched 4 times while charter 'c' will be matched 0 times."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "\\'*\\' Matches zero or more of the preceding element. is misleading"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "True, but if you know regex, then you know \\'*\\' is **greedy**, meaning that will try to match as many times as possible"
                    }
                ]
            },
            {
                "id": 1884506,
                "content": [
                    {
                        "username": "SigmaCoder106",
                        "content": "What's with this question ?!\n293 out of 354 passed. -_- and its a super long string\nI am gonna take a day off to debug it. :/"
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "Help me, please!\n \n\"aaa\" \"ab * a\" - false\nand  \"aab\"  \"c * a * b\" - true\n\nwhy? "
                    },
                    {
                        "username": "khromenkov-sergejj",
                        "content": "[@aleksamcode](/aleksamcode)  thanks, so much!"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- The pattern `ab*a` doesn't match the input string *aaa* fully but only partially. It doesn't fully match it because the pattern only contains two 'a' characters and the input has three 'a'. The pattern will match the first character 'a', then it will look for the 'b' character and will match it exactly zero times, and then it will match another 'a' character from the input, leaving the last 'a' unmatched.\n- The pattern `c*a*b` matches input *aab* fully: the pattern will match character 'c' exactly zero times, then it will match 'a' character as many times as possible due to usage of the `*` which is \"greedy\", and finally it will match exactly one character 'b'."
                    },
                    {
                        "username": "SI006288_Mohan",
                        "content": "Hi All,\\n\\nI think this question needs more clarity as we can see in the 3rd sample test case below they are expecting output true.\\n\\nInput: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nWhile executing similar test case in submit with the below inputs.\\nInput: s=\"ab\", p = \".*c\"\\n\\nit is expecting output false.\\n\\nIf anyone understand this case please reply me.\\n\\nThank you in advance"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "The reason the pattern `.*c` doesn't match the input string *ab* is because it requires the input string to contain exactly one 'c' character. This means that for input \"ab\" will return False, but inputs like \"abc\" or  \"ababcabab\" will return True."
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "s = \"aaa\"\\np = \".*\"\\nWhy it is True..?\\n\\nalso\\ns = \"aaa\"\\np = \"aaaa\"\\nWhy it should be True...?\\n\\nif it is right,\\ns = \"aaa\"\\np = \"aaab\"\\nIt should be true also, isn\\'t it...?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "- '*' is \"**greedy**\", meaning it will try to match as many times as possible, which means the whole input *aaa* will be matched\n- Input string *aaa* will not be matched if the pattern is `aaaa`, because it requires exactly four 'a' characters. However, a pattern `aaaa*` will match the input string *aaa*, because the '*' at the end allows for the last character to be matched zero times.\n- Finally, the answer for the third question is similar as it was for the second. The pattern `aaab` will not match the input string *aaa*, but a pattern `aaab*` will."
                    },
                    {
                        "username": "vanshng",
                        "content": "s = \"aaa\"\\np = \"ab* a* c* a\"\\nhow is the expected output true here can anyone please explain?\\n(the string p doesn\\'t have spaces in between but i am not able to write the original string without leetcode\\'s website making it tampered)"
                    },
                    {
                        "username": "vanshng",
                        "content": "I'll try with that logic. Thanks."
                    },
                    {
                        "username": "shashiram01",
                        "content": "[@vanshng](/vanshng) No, a* means 0 or a or aa or any number of times a can be like aaaaaaa\\u2026.., use this logic and run your code it will work "
                    },
                    {
                        "username": "vanshng",
                        "content": "a* can either be 0 or aa. So, your logic is wrong."
                    },
                    {
                        "username": "shashiram01",
                        "content": "In s, b zero times, c zero times and for a* one and so its true "
                    },
                    {
                        "username": "songjeongjun320",
                        "content": "When s = \"ab\", p = \".*c\", why it should be False?\\nIsn\\'t it true?"
                    },
                    {
                        "username": "vanshng",
                        "content": "Because .* matches with ab but c is still there in the pattern which cannot be matched with anything. There should\\'ve been a \\'*\\' after c to match it with this string as c* means more of c or zero. So, it would\\'ve made c* negligible. Then it would\\'ve been true but in the original case it is false because there is only c left."
                    },
                    {
                        "username": "leetrio-1",
                        "content": "Is isMatch(\"aba\",\"*c*) a valid case?\\nThe expected output is False, and I don\\'t get it."
                    },
                    {
                        "username": "vanshng",
                        "content": "Yes it is a valid case the pattern does not contain even 1 letter in the \\'s\\' to begin with. The correct function should return False."
                    },
                    {
                        "username": "softengineerljh",
                        "content": "In the given testcase ,  isMatch(\"mississippi\", \"mis*is*p*.\") \\u2192 false;   my output is true,  but expected,  can someone explain it ,ths"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Take a look at this [answer](https://leetcode.com/problems/regular-expression-matching/description/comments/1883634)."
                    },
                    {
                        "username": "user9197pe",
                        "content": "I don\\'t get for the test case s=ab & p=.* how is the result true, as per the pattern it should be zero or more occurrence of a single character, right?"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "A `*` quantifier is \"greedy\", meaning it will try to match character(s) as many times as possible, even though it can match zero characters. In the test case, pattern `.*` will try to match any character as many times as possible.\n\nFor example, for string \"aaaabd\", pattern `a*bc*d` will match the whole string; charters 'a' will be matched 4 times while charter 'c' will be matched 0 times."
                    },
                    {
                        "username": "JasonDecode",
                        "content": "\\'*\\' Matches zero or more of the preceding element. is misleading"
                    },
                    {
                        "username": "aleksamcode",
                        "content": "True, but if you know regex, then you know \\'*\\' is **greedy**, meaning that will try to match as many times as possible"
                    }
                ]
            },
            {
                "id": 1883597,
                "content": [
                    {
                        "username": "ThiagoSP",
                        "content": "I dont understande how `s = \"mississippi\" and p = \"mis*is*p*.\"` => false  and  `s = \"mississippi\" and p = \"mis*is*ip*.\"` => true.  I mean, how remaind only \".\" in first case become false and in second, become true. Maybe it is a error in test case."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "For the first case, the pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\"\n\nHowever, for the second case, the slightly different pattern entirely matches the input string because:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"mississi\" is matched\n- `p*` will match as many 'p' characters possible, meaning that so far \"mississipp\" is matched\n- `.` matches any character, which means that the final match will be the whole input string \"mississippi\"\n\nTwo matching patterns are similar, but the second one has an extra `i` (mis\\*is\\***i**p\\*) which allows it to fully match the input string."
                    },
                    {
                        "username": "user4168Bf",
                        "content": "`s = \"mississippi\"\np = \"mis*is*p*.\"\nOutput = true\nExpected = false`\n\nhow come the pattern is not matching ?\n\n\"mis\" in p matching with \"mis\" in s\n\"\\*\" in p matching with \"s\" in s\n\"is\" in p matching with \"is\" in s\n\"\\*\" in p matching with \"si\" in s\n\"p\" in p matching with \"p\" in s\n\"*\" in p matching with \"p\" in s\n\".\" in p matching with \"i\" in s\n\nits exactly matching."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Well, this pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\""
                    },
                    {
                        "username": "Labrnth",
                        "content": "Why we should expect \"False\" in testcase with s=\"abcd\" and p=\"d*\"?\\nI checked this case with python re.match function and it returns \"True\":\\n\\nimport re\\n\\nstring = \\'abcd\\'\\npattern = \\'d*\\'\\n\\nresult = re.match(pattern, string)\\n\\nprint(result) # Output: <re.Match object; span=(0, 0), match=\\'\\'>\\nprint(bool(result)) # Output: True"
                    },
                    {
                        "username": "Hubro",
                        "content": "It says in the problem description:\\n\\n> The matching should cover the entire input string (not partial).\\n\\nPython\\'s re.match doesn\\'t do this by default, the equivalent pattern for `\"d*\"` in Python would be `\"^d*$\"`. The `^` matches the start of the string, the `$` matches the end of the string."
                    },
                    {
                        "username": "Andrzhang",
                        "content": "How does \"aab\" matches \"c\\*a\\*b\"? It is a testCase I'm failing.\n"
                    },
                    {
                        "username": "banand358",
                        "content": "How s = aaaaaab and p = .* returns true.\\nIt should be false right?"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": " `\"mississippi\"\n\"mis*is*p*.\" \nWhy Expected output is false  when  Expected output of \"aab\"\n\"c*a*b\"  is true?`\n"
                    },
                    {
                        "username": "crekez",
                        "content": "The reason why the regular expression matching of \"mississippi\" and \"mis*is*p*.\" results in false while the regular expression matching of \"aab\" and \"c*a*b\" results in true is because the two patterns have different matching requirements.\\n\\nIn the first pattern \"mis*is*p*.\", the * character is used to match zero or more of the preceding element. So, the s* part of the pattern can match zero or more s characters. When we try to match the string \"mississippi\" with this pattern, the s* part of the pattern matches all the s characters in the string, resulting in multiple matches. However, the remaining part of the pattern \"is*p*.\" does not match the remaining characters in the string. Therefore, the matching fails, and the output is false.\\n\\nOn the other hand, in the pattern \"c*a*b\", the * character is used to match zero or more of the preceding element. So, the a* part of the pattern can match zero or more a characters, and the b character must be present in the string. When we try to match the string \"aab\" with this pattern, the a* part of the pattern matches the first two a characters in the string, and the b character matches the last b character in the string. Therefore, the matching is successful, and the output is true"
                    },
                    {
                        "username": "3jasoon3",
                        "content": "fnmatch average enjoyer :3"
                    },
                    {
                        "username": "kanchan_raghani",
                        "content": "can anyone explain how aaa matches ab*ac*a ? if it is said that \\'*\\' Matches zero or more of the preceding element."
                    },
                    {
                        "username": "crekez",
                        "content": "In regular expression matching, the * character matches zero or more of the preceding element. So if we have the pattern a*, it matches any number of a characters including zero. Therefore, the pattern a*a will match the string abaca because the first a* matches the a, and the second a matches the second a in the string. The remaining a and c in the string are ignored since the * character matches zero or more of the preceding element. So, a*a matches abaca with the following mapping: a* matches a, and a matches the second a."
                    },
                    {
                        "username": "yuichihashimotoyh",
                        "content": "why \"ab\" with \".*c\" have a false output? wouldn\\'t \".*\" be \"..c\" therefore \"abc\", so \"ab\" is within \"abc\""
                    },
                    {
                        "username": "dfranco84",
                        "content": "Thought I had it... after days of going back to this I thought I was done... but my algorithm can\\'t account for this:\\n\\ns: \"a\"\\np: \"ab*\"\\n\\nshould be true.\\n\\nMy algorithm gets to the end of string s, sees that there are remaining chars in p and then returns false... should I write another subroutine to check for any upcoming \\'*\\' and then remove the star itself and the preceding character, thus outputting true in this case???"
                    }
                ]
            },
            {
                "id": 1875830,
                "content": [
                    {
                        "username": "ThiagoSP",
                        "content": "I dont understande how `s = \"mississippi\" and p = \"mis*is*p*.\"` => false  and  `s = \"mississippi\" and p = \"mis*is*ip*.\"` => true.  I mean, how remaind only \".\" in first case become false and in second, become true. Maybe it is a error in test case."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "For the first case, the pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\"\n\nHowever, for the second case, the slightly different pattern entirely matches the input string because:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"mississi\" is matched\n- `p*` will match as many 'p' characters possible, meaning that so far \"mississipp\" is matched\n- `.` matches any character, which means that the final match will be the whole input string \"mississippi\"\n\nTwo matching patterns are similar, but the second one has an extra `i` (mis\\*is\\***i**p\\*) which allows it to fully match the input string."
                    },
                    {
                        "username": "user4168Bf",
                        "content": "`s = \"mississippi\"\np = \"mis*is*p*.\"\nOutput = true\nExpected = false`\n\nhow come the pattern is not matching ?\n\n\"mis\" in p matching with \"mis\" in s\n\"\\*\" in p matching with \"s\" in s\n\"is\" in p matching with \"is\" in s\n\"\\*\" in p matching with \"si\" in s\n\"p\" in p matching with \"p\" in s\n\"*\" in p matching with \"p\" in s\n\".\" in p matching with \"i\" in s\n\nits exactly matching."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Well, this pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\""
                    },
                    {
                        "username": "Labrnth",
                        "content": "Why we should expect \"False\" in testcase with s=\"abcd\" and p=\"d*\"?\\nI checked this case with python re.match function and it returns \"True\":\\n\\nimport re\\n\\nstring = \\'abcd\\'\\npattern = \\'d*\\'\\n\\nresult = re.match(pattern, string)\\n\\nprint(result) # Output: <re.Match object; span=(0, 0), match=\\'\\'>\\nprint(bool(result)) # Output: True"
                    },
                    {
                        "username": "Hubro",
                        "content": "It says in the problem description:\\n\\n> The matching should cover the entire input string (not partial).\\n\\nPython\\'s re.match doesn\\'t do this by default, the equivalent pattern for `\"d*\"` in Python would be `\"^d*$\"`. The `^` matches the start of the string, the `$` matches the end of the string."
                    },
                    {
                        "username": "Andrzhang",
                        "content": "How does \"aab\" matches \"c\\*a\\*b\"? It is a testCase I'm failing.\n"
                    },
                    {
                        "username": "banand358",
                        "content": "How s = aaaaaab and p = .* returns true.\\nIt should be false right?"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": " `\"mississippi\"\n\"mis*is*p*.\" \nWhy Expected output is false  when  Expected output of \"aab\"\n\"c*a*b\"  is true?`\n"
                    },
                    {
                        "username": "crekez",
                        "content": "The reason why the regular expression matching of \"mississippi\" and \"mis*is*p*.\" results in false while the regular expression matching of \"aab\" and \"c*a*b\" results in true is because the two patterns have different matching requirements.\\n\\nIn the first pattern \"mis*is*p*.\", the * character is used to match zero or more of the preceding element. So, the s* part of the pattern can match zero or more s characters. When we try to match the string \"mississippi\" with this pattern, the s* part of the pattern matches all the s characters in the string, resulting in multiple matches. However, the remaining part of the pattern \"is*p*.\" does not match the remaining characters in the string. Therefore, the matching fails, and the output is false.\\n\\nOn the other hand, in the pattern \"c*a*b\", the * character is used to match zero or more of the preceding element. So, the a* part of the pattern can match zero or more a characters, and the b character must be present in the string. When we try to match the string \"aab\" with this pattern, the a* part of the pattern matches the first two a characters in the string, and the b character matches the last b character in the string. Therefore, the matching is successful, and the output is true"
                    },
                    {
                        "username": "3jasoon3",
                        "content": "fnmatch average enjoyer :3"
                    },
                    {
                        "username": "kanchan_raghani",
                        "content": "can anyone explain how aaa matches ab*ac*a ? if it is said that \\'*\\' Matches zero or more of the preceding element."
                    },
                    {
                        "username": "crekez",
                        "content": "In regular expression matching, the * character matches zero or more of the preceding element. So if we have the pattern a*, it matches any number of a characters including zero. Therefore, the pattern a*a will match the string abaca because the first a* matches the a, and the second a matches the second a in the string. The remaining a and c in the string are ignored since the * character matches zero or more of the preceding element. So, a*a matches abaca with the following mapping: a* matches a, and a matches the second a."
                    },
                    {
                        "username": "yuichihashimotoyh",
                        "content": "why \"ab\" with \".*c\" have a false output? wouldn\\'t \".*\" be \"..c\" therefore \"abc\", so \"ab\" is within \"abc\""
                    },
                    {
                        "username": "dfranco84",
                        "content": "Thought I had it... after days of going back to this I thought I was done... but my algorithm can\\'t account for this:\\n\\ns: \"a\"\\np: \"ab*\"\\n\\nshould be true.\\n\\nMy algorithm gets to the end of string s, sees that there are remaining chars in p and then returns false... should I write another subroutine to check for any upcoming \\'*\\' and then remove the star itself and the preceding character, thus outputting true in this case???"
                    }
                ]
            },
            {
                "id": 1868319,
                "content": [
                    {
                        "username": "ThiagoSP",
                        "content": "I dont understande how `s = \"mississippi\" and p = \"mis*is*p*.\"` => false  and  `s = \"mississippi\" and p = \"mis*is*ip*.\"` => true.  I mean, how remaind only \".\" in first case become false and in second, become true. Maybe it is a error in test case."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "For the first case, the pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\"\n\nHowever, for the second case, the slightly different pattern entirely matches the input string because:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"mississi\" is matched\n- `p*` will match as many 'p' characters possible, meaning that so far \"mississipp\" is matched\n- `.` matches any character, which means that the final match will be the whole input string \"mississippi\"\n\nTwo matching patterns are similar, but the second one has an extra `i` (mis\\*is\\***i**p\\*) which allows it to fully match the input string."
                    },
                    {
                        "username": "user4168Bf",
                        "content": "`s = \"mississippi\"\np = \"mis*is*p*.\"\nOutput = true\nExpected = false`\n\nhow come the pattern is not matching ?\n\n\"mis\" in p matching with \"mis\" in s\n\"\\*\" in p matching with \"s\" in s\n\"is\" in p matching with \"is\" in s\n\"\\*\" in p matching with \"si\" in s\n\"p\" in p matching with \"p\" in s\n\"*\" in p matching with \"p\" in s\n\".\" in p matching with \"i\" in s\n\nits exactly matching."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Well, this pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\""
                    },
                    {
                        "username": "Labrnth",
                        "content": "Why we should expect \"False\" in testcase with s=\"abcd\" and p=\"d*\"?\\nI checked this case with python re.match function and it returns \"True\":\\n\\nimport re\\n\\nstring = \\'abcd\\'\\npattern = \\'d*\\'\\n\\nresult = re.match(pattern, string)\\n\\nprint(result) # Output: <re.Match object; span=(0, 0), match=\\'\\'>\\nprint(bool(result)) # Output: True"
                    },
                    {
                        "username": "Hubro",
                        "content": "It says in the problem description:\\n\\n> The matching should cover the entire input string (not partial).\\n\\nPython\\'s re.match doesn\\'t do this by default, the equivalent pattern for `\"d*\"` in Python would be `\"^d*$\"`. The `^` matches the start of the string, the `$` matches the end of the string."
                    },
                    {
                        "username": "Andrzhang",
                        "content": "How does \"aab\" matches \"c\\*a\\*b\"? It is a testCase I'm failing.\n"
                    },
                    {
                        "username": "banand358",
                        "content": "How s = aaaaaab and p = .* returns true.\\nIt should be false right?"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": " `\"mississippi\"\n\"mis*is*p*.\" \nWhy Expected output is false  when  Expected output of \"aab\"\n\"c*a*b\"  is true?`\n"
                    },
                    {
                        "username": "crekez",
                        "content": "The reason why the regular expression matching of \"mississippi\" and \"mis*is*p*.\" results in false while the regular expression matching of \"aab\" and \"c*a*b\" results in true is because the two patterns have different matching requirements.\\n\\nIn the first pattern \"mis*is*p*.\", the * character is used to match zero or more of the preceding element. So, the s* part of the pattern can match zero or more s characters. When we try to match the string \"mississippi\" with this pattern, the s* part of the pattern matches all the s characters in the string, resulting in multiple matches. However, the remaining part of the pattern \"is*p*.\" does not match the remaining characters in the string. Therefore, the matching fails, and the output is false.\\n\\nOn the other hand, in the pattern \"c*a*b\", the * character is used to match zero or more of the preceding element. So, the a* part of the pattern can match zero or more a characters, and the b character must be present in the string. When we try to match the string \"aab\" with this pattern, the a* part of the pattern matches the first two a characters in the string, and the b character matches the last b character in the string. Therefore, the matching is successful, and the output is true"
                    },
                    {
                        "username": "3jasoon3",
                        "content": "fnmatch average enjoyer :3"
                    },
                    {
                        "username": "kanchan_raghani",
                        "content": "can anyone explain how aaa matches ab*ac*a ? if it is said that \\'*\\' Matches zero or more of the preceding element."
                    },
                    {
                        "username": "crekez",
                        "content": "In regular expression matching, the * character matches zero or more of the preceding element. So if we have the pattern a*, it matches any number of a characters including zero. Therefore, the pattern a*a will match the string abaca because the first a* matches the a, and the second a matches the second a in the string. The remaining a and c in the string are ignored since the * character matches zero or more of the preceding element. So, a*a matches abaca with the following mapping: a* matches a, and a matches the second a."
                    },
                    {
                        "username": "yuichihashimotoyh",
                        "content": "why \"ab\" with \".*c\" have a false output? wouldn\\'t \".*\" be \"..c\" therefore \"abc\", so \"ab\" is within \"abc\""
                    },
                    {
                        "username": "dfranco84",
                        "content": "Thought I had it... after days of going back to this I thought I was done... but my algorithm can\\'t account for this:\\n\\ns: \"a\"\\np: \"ab*\"\\n\\nshould be true.\\n\\nMy algorithm gets to the end of string s, sees that there are remaining chars in p and then returns false... should I write another subroutine to check for any upcoming \\'*\\' and then remove the star itself and the preceding character, thus outputting true in this case???"
                    }
                ]
            },
            {
                "id": 1863445,
                "content": [
                    {
                        "username": "ThiagoSP",
                        "content": "I dont understande how `s = \"mississippi\" and p = \"mis*is*p*.\"` => false  and  `s = \"mississippi\" and p = \"mis*is*ip*.\"` => true.  I mean, how remaind only \".\" in first case become false and in second, become true. Maybe it is a error in test case."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "For the first case, the pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\"\n\nHowever, for the second case, the slightly different pattern entirely matches the input string because:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"mississi\" is matched\n- `p*` will match as many 'p' characters possible, meaning that so far \"mississipp\" is matched\n- `.` matches any character, which means that the final match will be the whole input string \"mississippi\"\n\nTwo matching patterns are similar, but the second one has an extra `i` (mis\\*is\\***i**p\\*) which allows it to fully match the input string."
                    },
                    {
                        "username": "user4168Bf",
                        "content": "`s = \"mississippi\"\np = \"mis*is*p*.\"\nOutput = true\nExpected = false`\n\nhow come the pattern is not matching ?\n\n\"mis\" in p matching with \"mis\" in s\n\"\\*\" in p matching with \"s\" in s\n\"is\" in p matching with \"is\" in s\n\"\\*\" in p matching with \"si\" in s\n\"p\" in p matching with \"p\" in s\n\"*\" in p matching with \"p\" in s\n\".\" in p matching with \"i\" in s\n\nits exactly matching."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Well, this pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\""
                    },
                    {
                        "username": "Labrnth",
                        "content": "Why we should expect \"False\" in testcase with s=\"abcd\" and p=\"d*\"?\\nI checked this case with python re.match function and it returns \"True\":\\n\\nimport re\\n\\nstring = \\'abcd\\'\\npattern = \\'d*\\'\\n\\nresult = re.match(pattern, string)\\n\\nprint(result) # Output: <re.Match object; span=(0, 0), match=\\'\\'>\\nprint(bool(result)) # Output: True"
                    },
                    {
                        "username": "Hubro",
                        "content": "It says in the problem description:\\n\\n> The matching should cover the entire input string (not partial).\\n\\nPython\\'s re.match doesn\\'t do this by default, the equivalent pattern for `\"d*\"` in Python would be `\"^d*$\"`. The `^` matches the start of the string, the `$` matches the end of the string."
                    },
                    {
                        "username": "Andrzhang",
                        "content": "How does \"aab\" matches \"c\\*a\\*b\"? It is a testCase I'm failing.\n"
                    },
                    {
                        "username": "banand358",
                        "content": "How s = aaaaaab and p = .* returns true.\\nIt should be false right?"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": " `\"mississippi\"\n\"mis*is*p*.\" \nWhy Expected output is false  when  Expected output of \"aab\"\n\"c*a*b\"  is true?`\n"
                    },
                    {
                        "username": "crekez",
                        "content": "The reason why the regular expression matching of \"mississippi\" and \"mis*is*p*.\" results in false while the regular expression matching of \"aab\" and \"c*a*b\" results in true is because the two patterns have different matching requirements.\\n\\nIn the first pattern \"mis*is*p*.\", the * character is used to match zero or more of the preceding element. So, the s* part of the pattern can match zero or more s characters. When we try to match the string \"mississippi\" with this pattern, the s* part of the pattern matches all the s characters in the string, resulting in multiple matches. However, the remaining part of the pattern \"is*p*.\" does not match the remaining characters in the string. Therefore, the matching fails, and the output is false.\\n\\nOn the other hand, in the pattern \"c*a*b\", the * character is used to match zero or more of the preceding element. So, the a* part of the pattern can match zero or more a characters, and the b character must be present in the string. When we try to match the string \"aab\" with this pattern, the a* part of the pattern matches the first two a characters in the string, and the b character matches the last b character in the string. Therefore, the matching is successful, and the output is true"
                    },
                    {
                        "username": "3jasoon3",
                        "content": "fnmatch average enjoyer :3"
                    },
                    {
                        "username": "kanchan_raghani",
                        "content": "can anyone explain how aaa matches ab*ac*a ? if it is said that \\'*\\' Matches zero or more of the preceding element."
                    },
                    {
                        "username": "crekez",
                        "content": "In regular expression matching, the * character matches zero or more of the preceding element. So if we have the pattern a*, it matches any number of a characters including zero. Therefore, the pattern a*a will match the string abaca because the first a* matches the a, and the second a matches the second a in the string. The remaining a and c in the string are ignored since the * character matches zero or more of the preceding element. So, a*a matches abaca with the following mapping: a* matches a, and a matches the second a."
                    },
                    {
                        "username": "yuichihashimotoyh",
                        "content": "why \"ab\" with \".*c\" have a false output? wouldn\\'t \".*\" be \"..c\" therefore \"abc\", so \"ab\" is within \"abc\""
                    },
                    {
                        "username": "dfranco84",
                        "content": "Thought I had it... after days of going back to this I thought I was done... but my algorithm can\\'t account for this:\\n\\ns: \"a\"\\np: \"ab*\"\\n\\nshould be true.\\n\\nMy algorithm gets to the end of string s, sees that there are remaining chars in p and then returns false... should I write another subroutine to check for any upcoming \\'*\\' and then remove the star itself and the preceding character, thus outputting true in this case???"
                    }
                ]
            },
            {
                "id": 1859352,
                "content": [
                    {
                        "username": "ThiagoSP",
                        "content": "I dont understande how `s = \"mississippi\" and p = \"mis*is*p*.\"` => false  and  `s = \"mississippi\" and p = \"mis*is*ip*.\"` => true.  I mean, how remaind only \".\" in first case become false and in second, become true. Maybe it is a error in test case."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "For the first case, the pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\"\n\nHowever, for the second case, the slightly different pattern entirely matches the input string because:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"mississi\" is matched\n- `p*` will match as many 'p' characters possible, meaning that so far \"mississipp\" is matched\n- `.` matches any character, which means that the final match will be the whole input string \"mississippi\"\n\nTwo matching patterns are similar, but the second one has an extra `i` (mis\\*is\\***i**p\\*) which allows it to fully match the input string."
                    },
                    {
                        "username": "user4168Bf",
                        "content": "`s = \"mississippi\"\np = \"mis*is*p*.\"\nOutput = true\nExpected = false`\n\nhow come the pattern is not matching ?\n\n\"mis\" in p matching with \"mis\" in s\n\"\\*\" in p matching with \"s\" in s\n\"is\" in p matching with \"is\" in s\n\"\\*\" in p matching with \"si\" in s\n\"p\" in p matching with \"p\" in s\n\"*\" in p matching with \"p\" in s\n\".\" in p matching with \"i\" in s\n\nits exactly matching."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Well, this pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\""
                    },
                    {
                        "username": "Labrnth",
                        "content": "Why we should expect \"False\" in testcase with s=\"abcd\" and p=\"d*\"?\\nI checked this case with python re.match function and it returns \"True\":\\n\\nimport re\\n\\nstring = \\'abcd\\'\\npattern = \\'d*\\'\\n\\nresult = re.match(pattern, string)\\n\\nprint(result) # Output: <re.Match object; span=(0, 0), match=\\'\\'>\\nprint(bool(result)) # Output: True"
                    },
                    {
                        "username": "Hubro",
                        "content": "It says in the problem description:\\n\\n> The matching should cover the entire input string (not partial).\\n\\nPython\\'s re.match doesn\\'t do this by default, the equivalent pattern for `\"d*\"` in Python would be `\"^d*$\"`. The `^` matches the start of the string, the `$` matches the end of the string."
                    },
                    {
                        "username": "Andrzhang",
                        "content": "How does \"aab\" matches \"c\\*a\\*b\"? It is a testCase I'm failing.\n"
                    },
                    {
                        "username": "banand358",
                        "content": "How s = aaaaaab and p = .* returns true.\\nIt should be false right?"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": " `\"mississippi\"\n\"mis*is*p*.\" \nWhy Expected output is false  when  Expected output of \"aab\"\n\"c*a*b\"  is true?`\n"
                    },
                    {
                        "username": "crekez",
                        "content": "The reason why the regular expression matching of \"mississippi\" and \"mis*is*p*.\" results in false while the regular expression matching of \"aab\" and \"c*a*b\" results in true is because the two patterns have different matching requirements.\\n\\nIn the first pattern \"mis*is*p*.\", the * character is used to match zero or more of the preceding element. So, the s* part of the pattern can match zero or more s characters. When we try to match the string \"mississippi\" with this pattern, the s* part of the pattern matches all the s characters in the string, resulting in multiple matches. However, the remaining part of the pattern \"is*p*.\" does not match the remaining characters in the string. Therefore, the matching fails, and the output is false.\\n\\nOn the other hand, in the pattern \"c*a*b\", the * character is used to match zero or more of the preceding element. So, the a* part of the pattern can match zero or more a characters, and the b character must be present in the string. When we try to match the string \"aab\" with this pattern, the a* part of the pattern matches the first two a characters in the string, and the b character matches the last b character in the string. Therefore, the matching is successful, and the output is true"
                    },
                    {
                        "username": "3jasoon3",
                        "content": "fnmatch average enjoyer :3"
                    },
                    {
                        "username": "kanchan_raghani",
                        "content": "can anyone explain how aaa matches ab*ac*a ? if it is said that \\'*\\' Matches zero or more of the preceding element."
                    },
                    {
                        "username": "crekez",
                        "content": "In regular expression matching, the * character matches zero or more of the preceding element. So if we have the pattern a*, it matches any number of a characters including zero. Therefore, the pattern a*a will match the string abaca because the first a* matches the a, and the second a matches the second a in the string. The remaining a and c in the string are ignored since the * character matches zero or more of the preceding element. So, a*a matches abaca with the following mapping: a* matches a, and a matches the second a."
                    },
                    {
                        "username": "yuichihashimotoyh",
                        "content": "why \"ab\" with \".*c\" have a false output? wouldn\\'t \".*\" be \"..c\" therefore \"abc\", so \"ab\" is within \"abc\""
                    },
                    {
                        "username": "dfranco84",
                        "content": "Thought I had it... after days of going back to this I thought I was done... but my algorithm can\\'t account for this:\\n\\ns: \"a\"\\np: \"ab*\"\\n\\nshould be true.\\n\\nMy algorithm gets to the end of string s, sees that there are remaining chars in p and then returns false... should I write another subroutine to check for any upcoming \\'*\\' and then remove the star itself and the preceding character, thus outputting true in this case???"
                    }
                ]
            },
            {
                "id": 1851290,
                "content": [
                    {
                        "username": "ThiagoSP",
                        "content": "I dont understande how `s = \"mississippi\" and p = \"mis*is*p*.\"` => false  and  `s = \"mississippi\" and p = \"mis*is*ip*.\"` => true.  I mean, how remaind only \".\" in first case become false and in second, become true. Maybe it is a error in test case."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "For the first case, the pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\"\n\nHowever, for the second case, the slightly different pattern entirely matches the input string because:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"mississi\" is matched\n- `p*` will match as many 'p' characters possible, meaning that so far \"mississipp\" is matched\n- `.` matches any character, which means that the final match will be the whole input string \"mississippi\"\n\nTwo matching patterns are similar, but the second one has an extra `i` (mis\\*is\\***i**p\\*) which allows it to fully match the input string."
                    },
                    {
                        "username": "user4168Bf",
                        "content": "`s = \"mississippi\"\np = \"mis*is*p*.\"\nOutput = true\nExpected = false`\n\nhow come the pattern is not matching ?\n\n\"mis\" in p matching with \"mis\" in s\n\"\\*\" in p matching with \"s\" in s\n\"is\" in p matching with \"is\" in s\n\"\\*\" in p matching with \"si\" in s\n\"p\" in p matching with \"p\" in s\n\"*\" in p matching with \"p\" in s\n\".\" in p matching with \"i\" in s\n\nits exactly matching."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Well, this pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\""
                    },
                    {
                        "username": "Labrnth",
                        "content": "Why we should expect \"False\" in testcase with s=\"abcd\" and p=\"d*\"?\\nI checked this case with python re.match function and it returns \"True\":\\n\\nimport re\\n\\nstring = \\'abcd\\'\\npattern = \\'d*\\'\\n\\nresult = re.match(pattern, string)\\n\\nprint(result) # Output: <re.Match object; span=(0, 0), match=\\'\\'>\\nprint(bool(result)) # Output: True"
                    },
                    {
                        "username": "Hubro",
                        "content": "It says in the problem description:\\n\\n> The matching should cover the entire input string (not partial).\\n\\nPython\\'s re.match doesn\\'t do this by default, the equivalent pattern for `\"d*\"` in Python would be `\"^d*$\"`. The `^` matches the start of the string, the `$` matches the end of the string."
                    },
                    {
                        "username": "Andrzhang",
                        "content": "How does \"aab\" matches \"c\\*a\\*b\"? It is a testCase I'm failing.\n"
                    },
                    {
                        "username": "banand358",
                        "content": "How s = aaaaaab and p = .* returns true.\\nIt should be false right?"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": " `\"mississippi\"\n\"mis*is*p*.\" \nWhy Expected output is false  when  Expected output of \"aab\"\n\"c*a*b\"  is true?`\n"
                    },
                    {
                        "username": "crekez",
                        "content": "The reason why the regular expression matching of \"mississippi\" and \"mis*is*p*.\" results in false while the regular expression matching of \"aab\" and \"c*a*b\" results in true is because the two patterns have different matching requirements.\\n\\nIn the first pattern \"mis*is*p*.\", the * character is used to match zero or more of the preceding element. So, the s* part of the pattern can match zero or more s characters. When we try to match the string \"mississippi\" with this pattern, the s* part of the pattern matches all the s characters in the string, resulting in multiple matches. However, the remaining part of the pattern \"is*p*.\" does not match the remaining characters in the string. Therefore, the matching fails, and the output is false.\\n\\nOn the other hand, in the pattern \"c*a*b\", the * character is used to match zero or more of the preceding element. So, the a* part of the pattern can match zero or more a characters, and the b character must be present in the string. When we try to match the string \"aab\" with this pattern, the a* part of the pattern matches the first two a characters in the string, and the b character matches the last b character in the string. Therefore, the matching is successful, and the output is true"
                    },
                    {
                        "username": "3jasoon3",
                        "content": "fnmatch average enjoyer :3"
                    },
                    {
                        "username": "kanchan_raghani",
                        "content": "can anyone explain how aaa matches ab*ac*a ? if it is said that \\'*\\' Matches zero or more of the preceding element."
                    },
                    {
                        "username": "crekez",
                        "content": "In regular expression matching, the * character matches zero or more of the preceding element. So if we have the pattern a*, it matches any number of a characters including zero. Therefore, the pattern a*a will match the string abaca because the first a* matches the a, and the second a matches the second a in the string. The remaining a and c in the string are ignored since the * character matches zero or more of the preceding element. So, a*a matches abaca with the following mapping: a* matches a, and a matches the second a."
                    },
                    {
                        "username": "yuichihashimotoyh",
                        "content": "why \"ab\" with \".*c\" have a false output? wouldn\\'t \".*\" be \"..c\" therefore \"abc\", so \"ab\" is within \"abc\""
                    },
                    {
                        "username": "dfranco84",
                        "content": "Thought I had it... after days of going back to this I thought I was done... but my algorithm can\\'t account for this:\\n\\ns: \"a\"\\np: \"ab*\"\\n\\nshould be true.\\n\\nMy algorithm gets to the end of string s, sees that there are remaining chars in p and then returns false... should I write another subroutine to check for any upcoming \\'*\\' and then remove the star itself and the preceding character, thus outputting true in this case???"
                    }
                ]
            },
            {
                "id": 1849431,
                "content": [
                    {
                        "username": "ThiagoSP",
                        "content": "I dont understande how `s = \"mississippi\" and p = \"mis*is*p*.\"` => false  and  `s = \"mississippi\" and p = \"mis*is*ip*.\"` => true.  I mean, how remaind only \".\" in first case become false and in second, become true. Maybe it is a error in test case."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "For the first case, the pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\"\n\nHowever, for the second case, the slightly different pattern entirely matches the input string because:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"mississi\" is matched\n- `p*` will match as many 'p' characters possible, meaning that so far \"mississipp\" is matched\n- `.` matches any character, which means that the final match will be the whole input string \"mississippi\"\n\nTwo matching patterns are similar, but the second one has an extra `i` (mis\\*is\\***i**p\\*) which allows it to fully match the input string."
                    },
                    {
                        "username": "user4168Bf",
                        "content": "`s = \"mississippi\"\np = \"mis*is*p*.\"\nOutput = true\nExpected = false`\n\nhow come the pattern is not matching ?\n\n\"mis\" in p matching with \"mis\" in s\n\"\\*\" in p matching with \"s\" in s\n\"is\" in p matching with \"is\" in s\n\"\\*\" in p matching with \"si\" in s\n\"p\" in p matching with \"p\" in s\n\"*\" in p matching with \"p\" in s\n\".\" in p matching with \"i\" in s\n\nits exactly matching."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Well, this pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\""
                    },
                    {
                        "username": "Labrnth",
                        "content": "Why we should expect \"False\" in testcase with s=\"abcd\" and p=\"d*\"?\\nI checked this case with python re.match function and it returns \"True\":\\n\\nimport re\\n\\nstring = \\'abcd\\'\\npattern = \\'d*\\'\\n\\nresult = re.match(pattern, string)\\n\\nprint(result) # Output: <re.Match object; span=(0, 0), match=\\'\\'>\\nprint(bool(result)) # Output: True"
                    },
                    {
                        "username": "Hubro",
                        "content": "It says in the problem description:\\n\\n> The matching should cover the entire input string (not partial).\\n\\nPython\\'s re.match doesn\\'t do this by default, the equivalent pattern for `\"d*\"` in Python would be `\"^d*$\"`. The `^` matches the start of the string, the `$` matches the end of the string."
                    },
                    {
                        "username": "Andrzhang",
                        "content": "How does \"aab\" matches \"c\\*a\\*b\"? It is a testCase I'm failing.\n"
                    },
                    {
                        "username": "banand358",
                        "content": "How s = aaaaaab and p = .* returns true.\\nIt should be false right?"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": " `\"mississippi\"\n\"mis*is*p*.\" \nWhy Expected output is false  when  Expected output of \"aab\"\n\"c*a*b\"  is true?`\n"
                    },
                    {
                        "username": "crekez",
                        "content": "The reason why the regular expression matching of \"mississippi\" and \"mis*is*p*.\" results in false while the regular expression matching of \"aab\" and \"c*a*b\" results in true is because the two patterns have different matching requirements.\\n\\nIn the first pattern \"mis*is*p*.\", the * character is used to match zero or more of the preceding element. So, the s* part of the pattern can match zero or more s characters. When we try to match the string \"mississippi\" with this pattern, the s* part of the pattern matches all the s characters in the string, resulting in multiple matches. However, the remaining part of the pattern \"is*p*.\" does not match the remaining characters in the string. Therefore, the matching fails, and the output is false.\\n\\nOn the other hand, in the pattern \"c*a*b\", the * character is used to match zero or more of the preceding element. So, the a* part of the pattern can match zero or more a characters, and the b character must be present in the string. When we try to match the string \"aab\" with this pattern, the a* part of the pattern matches the first two a characters in the string, and the b character matches the last b character in the string. Therefore, the matching is successful, and the output is true"
                    },
                    {
                        "username": "3jasoon3",
                        "content": "fnmatch average enjoyer :3"
                    },
                    {
                        "username": "kanchan_raghani",
                        "content": "can anyone explain how aaa matches ab*ac*a ? if it is said that \\'*\\' Matches zero or more of the preceding element."
                    },
                    {
                        "username": "crekez",
                        "content": "In regular expression matching, the * character matches zero or more of the preceding element. So if we have the pattern a*, it matches any number of a characters including zero. Therefore, the pattern a*a will match the string abaca because the first a* matches the a, and the second a matches the second a in the string. The remaining a and c in the string are ignored since the * character matches zero or more of the preceding element. So, a*a matches abaca with the following mapping: a* matches a, and a matches the second a."
                    },
                    {
                        "username": "yuichihashimotoyh",
                        "content": "why \"ab\" with \".*c\" have a false output? wouldn\\'t \".*\" be \"..c\" therefore \"abc\", so \"ab\" is within \"abc\""
                    },
                    {
                        "username": "dfranco84",
                        "content": "Thought I had it... after days of going back to this I thought I was done... but my algorithm can\\'t account for this:\\n\\ns: \"a\"\\np: \"ab*\"\\n\\nshould be true.\\n\\nMy algorithm gets to the end of string s, sees that there are remaining chars in p and then returns false... should I write another subroutine to check for any upcoming \\'*\\' and then remove the star itself and the preceding character, thus outputting true in this case???"
                    }
                ]
            },
            {
                "id": 1836298,
                "content": [
                    {
                        "username": "ThiagoSP",
                        "content": "I dont understande how `s = \"mississippi\" and p = \"mis*is*p*.\"` => false  and  `s = \"mississippi\" and p = \"mis*is*ip*.\"` => true.  I mean, how remaind only \".\" in first case become false and in second, become true. Maybe it is a error in test case."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "For the first case, the pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\"\n\nHowever, for the second case, the slightly different pattern entirely matches the input string because:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"mississi\" is matched\n- `p*` will match as many 'p' characters possible, meaning that so far \"mississipp\" is matched\n- `.` matches any character, which means that the final match will be the whole input string \"mississippi\"\n\nTwo matching patterns are similar, but the second one has an extra `i` (mis\\*is\\***i**p\\*) which allows it to fully match the input string."
                    },
                    {
                        "username": "user4168Bf",
                        "content": "`s = \"mississippi\"\np = \"mis*is*p*.\"\nOutput = true\nExpected = false`\n\nhow come the pattern is not matching ?\n\n\"mis\" in p matching with \"mis\" in s\n\"\\*\" in p matching with \"s\" in s\n\"is\" in p matching with \"is\" in s\n\"\\*\" in p matching with \"si\" in s\n\"p\" in p matching with \"p\" in s\n\"*\" in p matching with \"p\" in s\n\".\" in p matching with \"i\" in s\n\nits exactly matching."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Well, this pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\""
                    },
                    {
                        "username": "Labrnth",
                        "content": "Why we should expect \"False\" in testcase with s=\"abcd\" and p=\"d*\"?\\nI checked this case with python re.match function and it returns \"True\":\\n\\nimport re\\n\\nstring = \\'abcd\\'\\npattern = \\'d*\\'\\n\\nresult = re.match(pattern, string)\\n\\nprint(result) # Output: <re.Match object; span=(0, 0), match=\\'\\'>\\nprint(bool(result)) # Output: True"
                    },
                    {
                        "username": "Hubro",
                        "content": "It says in the problem description:\\n\\n> The matching should cover the entire input string (not partial).\\n\\nPython\\'s re.match doesn\\'t do this by default, the equivalent pattern for `\"d*\"` in Python would be `\"^d*$\"`. The `^` matches the start of the string, the `$` matches the end of the string."
                    },
                    {
                        "username": "Andrzhang",
                        "content": "How does \"aab\" matches \"c\\*a\\*b\"? It is a testCase I'm failing.\n"
                    },
                    {
                        "username": "banand358",
                        "content": "How s = aaaaaab and p = .* returns true.\\nIt should be false right?"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": " `\"mississippi\"\n\"mis*is*p*.\" \nWhy Expected output is false  when  Expected output of \"aab\"\n\"c*a*b\"  is true?`\n"
                    },
                    {
                        "username": "crekez",
                        "content": "The reason why the regular expression matching of \"mississippi\" and \"mis*is*p*.\" results in false while the regular expression matching of \"aab\" and \"c*a*b\" results in true is because the two patterns have different matching requirements.\\n\\nIn the first pattern \"mis*is*p*.\", the * character is used to match zero or more of the preceding element. So, the s* part of the pattern can match zero or more s characters. When we try to match the string \"mississippi\" with this pattern, the s* part of the pattern matches all the s characters in the string, resulting in multiple matches. However, the remaining part of the pattern \"is*p*.\" does not match the remaining characters in the string. Therefore, the matching fails, and the output is false.\\n\\nOn the other hand, in the pattern \"c*a*b\", the * character is used to match zero or more of the preceding element. So, the a* part of the pattern can match zero or more a characters, and the b character must be present in the string. When we try to match the string \"aab\" with this pattern, the a* part of the pattern matches the first two a characters in the string, and the b character matches the last b character in the string. Therefore, the matching is successful, and the output is true"
                    },
                    {
                        "username": "3jasoon3",
                        "content": "fnmatch average enjoyer :3"
                    },
                    {
                        "username": "kanchan_raghani",
                        "content": "can anyone explain how aaa matches ab*ac*a ? if it is said that \\'*\\' Matches zero or more of the preceding element."
                    },
                    {
                        "username": "crekez",
                        "content": "In regular expression matching, the * character matches zero or more of the preceding element. So if we have the pattern a*, it matches any number of a characters including zero. Therefore, the pattern a*a will match the string abaca because the first a* matches the a, and the second a matches the second a in the string. The remaining a and c in the string are ignored since the * character matches zero or more of the preceding element. So, a*a matches abaca with the following mapping: a* matches a, and a matches the second a."
                    },
                    {
                        "username": "yuichihashimotoyh",
                        "content": "why \"ab\" with \".*c\" have a false output? wouldn\\'t \".*\" be \"..c\" therefore \"abc\", so \"ab\" is within \"abc\""
                    },
                    {
                        "username": "dfranco84",
                        "content": "Thought I had it... after days of going back to this I thought I was done... but my algorithm can\\'t account for this:\\n\\ns: \"a\"\\np: \"ab*\"\\n\\nshould be true.\\n\\nMy algorithm gets to the end of string s, sees that there are remaining chars in p and then returns false... should I write another subroutine to check for any upcoming \\'*\\' and then remove the star itself and the preceding character, thus outputting true in this case???"
                    }
                ]
            },
            {
                "id": 1835072,
                "content": [
                    {
                        "username": "ThiagoSP",
                        "content": "I dont understande how `s = \"mississippi\" and p = \"mis*is*p*.\"` => false  and  `s = \"mississippi\" and p = \"mis*is*ip*.\"` => true.  I mean, how remaind only \".\" in first case become false and in second, become true. Maybe it is a error in test case."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "For the first case, the pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\"\n\nHowever, for the second case, the slightly different pattern entirely matches the input string because:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"mississi\" is matched\n- `p*` will match as many 'p' characters possible, meaning that so far \"mississipp\" is matched\n- `.` matches any character, which means that the final match will be the whole input string \"mississippi\"\n\nTwo matching patterns are similar, but the second one has an extra `i` (mis\\*is\\***i**p\\*) which allows it to fully match the input string."
                    },
                    {
                        "username": "user4168Bf",
                        "content": "`s = \"mississippi\"\np = \"mis*is*p*.\"\nOutput = true\nExpected = false`\n\nhow come the pattern is not matching ?\n\n\"mis\" in p matching with \"mis\" in s\n\"\\*\" in p matching with \"s\" in s\n\"is\" in p matching with \"is\" in s\n\"\\*\" in p matching with \"si\" in s\n\"p\" in p matching with \"p\" in s\n\"*\" in p matching with \"p\" in s\n\".\" in p matching with \"i\" in s\n\nits exactly matching."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Well, this pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\""
                    },
                    {
                        "username": "Labrnth",
                        "content": "Why we should expect \"False\" in testcase with s=\"abcd\" and p=\"d*\"?\\nI checked this case with python re.match function and it returns \"True\":\\n\\nimport re\\n\\nstring = \\'abcd\\'\\npattern = \\'d*\\'\\n\\nresult = re.match(pattern, string)\\n\\nprint(result) # Output: <re.Match object; span=(0, 0), match=\\'\\'>\\nprint(bool(result)) # Output: True"
                    },
                    {
                        "username": "Hubro",
                        "content": "It says in the problem description:\\n\\n> The matching should cover the entire input string (not partial).\\n\\nPython\\'s re.match doesn\\'t do this by default, the equivalent pattern for `\"d*\"` in Python would be `\"^d*$\"`. The `^` matches the start of the string, the `$` matches the end of the string."
                    },
                    {
                        "username": "Andrzhang",
                        "content": "How does \"aab\" matches \"c\\*a\\*b\"? It is a testCase I'm failing.\n"
                    },
                    {
                        "username": "banand358",
                        "content": "How s = aaaaaab and p = .* returns true.\\nIt should be false right?"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": " `\"mississippi\"\n\"mis*is*p*.\" \nWhy Expected output is false  when  Expected output of \"aab\"\n\"c*a*b\"  is true?`\n"
                    },
                    {
                        "username": "crekez",
                        "content": "The reason why the regular expression matching of \"mississippi\" and \"mis*is*p*.\" results in false while the regular expression matching of \"aab\" and \"c*a*b\" results in true is because the two patterns have different matching requirements.\\n\\nIn the first pattern \"mis*is*p*.\", the * character is used to match zero or more of the preceding element. So, the s* part of the pattern can match zero or more s characters. When we try to match the string \"mississippi\" with this pattern, the s* part of the pattern matches all the s characters in the string, resulting in multiple matches. However, the remaining part of the pattern \"is*p*.\" does not match the remaining characters in the string. Therefore, the matching fails, and the output is false.\\n\\nOn the other hand, in the pattern \"c*a*b\", the * character is used to match zero or more of the preceding element. So, the a* part of the pattern can match zero or more a characters, and the b character must be present in the string. When we try to match the string \"aab\" with this pattern, the a* part of the pattern matches the first two a characters in the string, and the b character matches the last b character in the string. Therefore, the matching is successful, and the output is true"
                    },
                    {
                        "username": "3jasoon3",
                        "content": "fnmatch average enjoyer :3"
                    },
                    {
                        "username": "kanchan_raghani",
                        "content": "can anyone explain how aaa matches ab*ac*a ? if it is said that \\'*\\' Matches zero or more of the preceding element."
                    },
                    {
                        "username": "crekez",
                        "content": "In regular expression matching, the * character matches zero or more of the preceding element. So if we have the pattern a*, it matches any number of a characters including zero. Therefore, the pattern a*a will match the string abaca because the first a* matches the a, and the second a matches the second a in the string. The remaining a and c in the string are ignored since the * character matches zero or more of the preceding element. So, a*a matches abaca with the following mapping: a* matches a, and a matches the second a."
                    },
                    {
                        "username": "yuichihashimotoyh",
                        "content": "why \"ab\" with \".*c\" have a false output? wouldn\\'t \".*\" be \"..c\" therefore \"abc\", so \"ab\" is within \"abc\""
                    },
                    {
                        "username": "dfranco84",
                        "content": "Thought I had it... after days of going back to this I thought I was done... but my algorithm can\\'t account for this:\\n\\ns: \"a\"\\np: \"ab*\"\\n\\nshould be true.\\n\\nMy algorithm gets to the end of string s, sees that there are remaining chars in p and then returns false... should I write another subroutine to check for any upcoming \\'*\\' and then remove the star itself and the preceding character, thus outputting true in this case???"
                    }
                ]
            },
            {
                "id": 1834526,
                "content": [
                    {
                        "username": "ThiagoSP",
                        "content": "I dont understande how `s = \"mississippi\" and p = \"mis*is*p*.\"` => false  and  `s = \"mississippi\" and p = \"mis*is*ip*.\"` => true.  I mean, how remaind only \".\" in first case become false and in second, become true. Maybe it is a error in test case."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "For the first case, the pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\"\n\nHowever, for the second case, the slightly different pattern entirely matches the input string because:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"mississi\" is matched\n- `p*` will match as many 'p' characters possible, meaning that so far \"mississipp\" is matched\n- `.` matches any character, which means that the final match will be the whole input string \"mississippi\"\n\nTwo matching patterns are similar, but the second one has an extra `i` (mis\\*is\\***i**p\\*) which allows it to fully match the input string."
                    },
                    {
                        "username": "user4168Bf",
                        "content": "`s = \"mississippi\"\np = \"mis*is*p*.\"\nOutput = true\nExpected = false`\n\nhow come the pattern is not matching ?\n\n\"mis\" in p matching with \"mis\" in s\n\"\\*\" in p matching with \"s\" in s\n\"is\" in p matching with \"is\" in s\n\"\\*\" in p matching with \"si\" in s\n\"p\" in p matching with \"p\" in s\n\"*\" in p matching with \"p\" in s\n\".\" in p matching with \"i\" in s\n\nits exactly matching."
                    },
                    {
                        "username": "aleksamcode",
                        "content": "Well, this pattern only partially matches the input string. Here is why:\n- `mi` from the pattern will match \"mi\" from the input\n- `s*` will match all the 's' characters until `i` because `*` is greedy, which means that so far \"miss\" is matched\n- `i` will match exactly one letter 'i' from the input, meaning that so far \"missi\" is matched\n- `s*` will match as many 's' characters possible, meaning that you will have \"mississ\" matched\n- `p*` will match as many 'p' characters possible, which in this case means 0\n- `.` matches any character, which means that the final match will be \"mississi\" and not the entire input string \"mississipi\""
                    },
                    {
                        "username": "Labrnth",
                        "content": "Why we should expect \"False\" in testcase with s=\"abcd\" and p=\"d*\"?\\nI checked this case with python re.match function and it returns \"True\":\\n\\nimport re\\n\\nstring = \\'abcd\\'\\npattern = \\'d*\\'\\n\\nresult = re.match(pattern, string)\\n\\nprint(result) # Output: <re.Match object; span=(0, 0), match=\\'\\'>\\nprint(bool(result)) # Output: True"
                    },
                    {
                        "username": "Hubro",
                        "content": "It says in the problem description:\\n\\n> The matching should cover the entire input string (not partial).\\n\\nPython\\'s re.match doesn\\'t do this by default, the equivalent pattern for `\"d*\"` in Python would be `\"^d*$\"`. The `^` matches the start of the string, the `$` matches the end of the string."
                    },
                    {
                        "username": "Andrzhang",
                        "content": "How does \"aab\" matches \"c\\*a\\*b\"? It is a testCase I'm failing.\n"
                    },
                    {
                        "username": "banand358",
                        "content": "How s = aaaaaab and p = .* returns true.\\nIt should be false right?"
                    },
                    {
                        "username": "Deepika__Singh",
                        "content": " `\"mississippi\"\n\"mis*is*p*.\" \nWhy Expected output is false  when  Expected output of \"aab\"\n\"c*a*b\"  is true?`\n"
                    },
                    {
                        "username": "crekez",
                        "content": "The reason why the regular expression matching of \"mississippi\" and \"mis*is*p*.\" results in false while the regular expression matching of \"aab\" and \"c*a*b\" results in true is because the two patterns have different matching requirements.\\n\\nIn the first pattern \"mis*is*p*.\", the * character is used to match zero or more of the preceding element. So, the s* part of the pattern can match zero or more s characters. When we try to match the string \"mississippi\" with this pattern, the s* part of the pattern matches all the s characters in the string, resulting in multiple matches. However, the remaining part of the pattern \"is*p*.\" does not match the remaining characters in the string. Therefore, the matching fails, and the output is false.\\n\\nOn the other hand, in the pattern \"c*a*b\", the * character is used to match zero or more of the preceding element. So, the a* part of the pattern can match zero or more a characters, and the b character must be present in the string. When we try to match the string \"aab\" with this pattern, the a* part of the pattern matches the first two a characters in the string, and the b character matches the last b character in the string. Therefore, the matching is successful, and the output is true"
                    },
                    {
                        "username": "3jasoon3",
                        "content": "fnmatch average enjoyer :3"
                    },
                    {
                        "username": "kanchan_raghani",
                        "content": "can anyone explain how aaa matches ab*ac*a ? if it is said that \\'*\\' Matches zero or more of the preceding element."
                    },
                    {
                        "username": "crekez",
                        "content": "In regular expression matching, the * character matches zero or more of the preceding element. So if we have the pattern a*, it matches any number of a characters including zero. Therefore, the pattern a*a will match the string abaca because the first a* matches the a, and the second a matches the second a in the string. The remaining a and c in the string are ignored since the * character matches zero or more of the preceding element. So, a*a matches abaca with the following mapping: a* matches a, and a matches the second a."
                    },
                    {
                        "username": "yuichihashimotoyh",
                        "content": "why \"ab\" with \".*c\" have a false output? wouldn\\'t \".*\" be \"..c\" therefore \"abc\", so \"ab\" is within \"abc\""
                    },
                    {
                        "username": "dfranco84",
                        "content": "Thought I had it... after days of going back to this I thought I was done... but my algorithm can\\'t account for this:\\n\\ns: \"a\"\\np: \"ab*\"\\n\\nshould be true.\\n\\nMy algorithm gets to the end of string s, sees that there are remaining chars in p and then returns false... should I write another subroutine to check for any upcoming \\'*\\' and then remove the star itself and the preceding character, thus outputting true in this case???"
                    }
                ]
            },
            {
                "id": 1833267,
                "content": [
                    {
                        "username": "eswarchowdhari",
                        "content": "please explain the question"
                    },
                    {
                        "username": "Zer0cool360",
                        "content": "This problem should\\'ve been clearer about the \\'*\\' only repeating 1 character and that the star when repeating its element 0 times removes the element. I thought that the element the \\'*\\' repeated was all the characters before it until you reached another \\'*\\' and that the character \\'*\\' was essentially replacing itself with that element and repeating itself.\\n\\nex. \\nif s = \\'mississippi\\', p = \\'mis*is*ip*.\\' return false because \\'mis\\'+\\'mis\\'*n cannot equal \"miss\"\\nand\\nif s = \"aab\", p = \"c*a*b\" return false because \\'c\\' + \\'c\\'*n cannot equal \\'a\\'"
                    },
                    {
                        "username": "Rohit_Bisht2003",
                        "content": "i have not understand the question\\n"
                    },
                    {
                        "username": "rohamghotbi",
                        "content": "VALIDATE != IMPLEMENT"
                    },
                    {
                        "username": "sgv558139",
                        "content": "Hello, not sure if anyone else is having great difficulty with this but I\\'ve tried at least 5 different ways to solve this problem, and have not had any success.\\nUsing C++, I\\'ve tried using simple pattern matching, std::maps, structs to store pattern metadata in the Solution object, using multi-passthroughs to scan each location that characters in pattern \"p\" appear in string \"s\", and now I\\'m stuck with where to use loops and recursion for parsing the asterisked elements.\\nAny advice on where to go next with this?\\nShould I skip this problem for now and return to the more difficult problems later?"
                    },
                    {
                        "username": "kaiken9101",
                        "content": "My Python3 algorithm for example number 3 in VS Code returns True, but here on the site the answer is False. Checked everything several times, no mistake.\n\n`if not p:`\nㅤㅤ`return not s`\n`first_match = bool(s) and p[0] in {s[0], '.'}`\n`if len(p) >= 2 and p[1] == '*':`\nㅤㅤ` return match(s, p[2:]) or (first_match and match(s[1:], p))`\n`else:`\nㅤㅤ` return first_match and match(s[1:], p[1:]) `"
                    },
                    {
                        "username": "lamialover6",
                        "content": "`s = \"a\"`\\n`p =  \".*..a*\"`\\n\\n`Output:`\\n`true`\\n`Expected:`\\n`false`\\n\\n\\ncan some please explain this?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "\\'*\\' Matches zero or more of the preceding element.\\nwhat does preceding element mean?\\nLast char or last char-chain?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "the description really needs an update!"
                    },
                    {
                        "username": "muddassirmomin2005",
                        "content": "# Initialize first row\\nfor j in range(2, m+1):\\n    dp[0][j] = dp[0][j-2] and p[j-1] == \\'*\\'\\n\\n# DP\\nfor i in range(1, n+1):\\n    for j in range(1, m+1):\\n        if p[j-1] != \\'*\\':\\n            dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == \\'.\\')\\n        else:\\n            dp[i][j `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "user8134AU",
                        "content": "s = \"bbbba\" , p=\" .* a* a \"  => Expected =true...  how is that a valid....I mean .* goes all the way to a, then a* will consume remaining a, and finally p has a left....If a* is expected to be zero match or real match...How is it valid If there is nothing then zero match is fine...This opens two possibilites"
                    }
                ]
            },
            {
                "id": 1831483,
                "content": [
                    {
                        "username": "eswarchowdhari",
                        "content": "please explain the question"
                    },
                    {
                        "username": "Zer0cool360",
                        "content": "This problem should\\'ve been clearer about the \\'*\\' only repeating 1 character and that the star when repeating its element 0 times removes the element. I thought that the element the \\'*\\' repeated was all the characters before it until you reached another \\'*\\' and that the character \\'*\\' was essentially replacing itself with that element and repeating itself.\\n\\nex. \\nif s = \\'mississippi\\', p = \\'mis*is*ip*.\\' return false because \\'mis\\'+\\'mis\\'*n cannot equal \"miss\"\\nand\\nif s = \"aab\", p = \"c*a*b\" return false because \\'c\\' + \\'c\\'*n cannot equal \\'a\\'"
                    },
                    {
                        "username": "Rohit_Bisht2003",
                        "content": "i have not understand the question\\n"
                    },
                    {
                        "username": "rohamghotbi",
                        "content": "VALIDATE != IMPLEMENT"
                    },
                    {
                        "username": "sgv558139",
                        "content": "Hello, not sure if anyone else is having great difficulty with this but I\\'ve tried at least 5 different ways to solve this problem, and have not had any success.\\nUsing C++, I\\'ve tried using simple pattern matching, std::maps, structs to store pattern metadata in the Solution object, using multi-passthroughs to scan each location that characters in pattern \"p\" appear in string \"s\", and now I\\'m stuck with where to use loops and recursion for parsing the asterisked elements.\\nAny advice on where to go next with this?\\nShould I skip this problem for now and return to the more difficult problems later?"
                    },
                    {
                        "username": "kaiken9101",
                        "content": "My Python3 algorithm for example number 3 in VS Code returns True, but here on the site the answer is False. Checked everything several times, no mistake.\n\n`if not p:`\nㅤㅤ`return not s`\n`first_match = bool(s) and p[0] in {s[0], '.'}`\n`if len(p) >= 2 and p[1] == '*':`\nㅤㅤ` return match(s, p[2:]) or (first_match and match(s[1:], p))`\n`else:`\nㅤㅤ` return first_match and match(s[1:], p[1:]) `"
                    },
                    {
                        "username": "lamialover6",
                        "content": "`s = \"a\"`\\n`p =  \".*..a*\"`\\n\\n`Output:`\\n`true`\\n`Expected:`\\n`false`\\n\\n\\ncan some please explain this?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "\\'*\\' Matches zero or more of the preceding element.\\nwhat does preceding element mean?\\nLast char or last char-chain?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "the description really needs an update!"
                    },
                    {
                        "username": "muddassirmomin2005",
                        "content": "# Initialize first row\\nfor j in range(2, m+1):\\n    dp[0][j] = dp[0][j-2] and p[j-1] == \\'*\\'\\n\\n# DP\\nfor i in range(1, n+1):\\n    for j in range(1, m+1):\\n        if p[j-1] != \\'*\\':\\n            dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == \\'.\\')\\n        else:\\n            dp[i][j `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "user8134AU",
                        "content": "s = \"bbbba\" , p=\" .* a* a \"  => Expected =true...  how is that a valid....I mean .* goes all the way to a, then a* will consume remaining a, and finally p has a left....If a* is expected to be zero match or real match...How is it valid If there is nothing then zero match is fine...This opens two possibilites"
                    }
                ]
            },
            {
                "id": 1829258,
                "content": [
                    {
                        "username": "eswarchowdhari",
                        "content": "please explain the question"
                    },
                    {
                        "username": "Zer0cool360",
                        "content": "This problem should\\'ve been clearer about the \\'*\\' only repeating 1 character and that the star when repeating its element 0 times removes the element. I thought that the element the \\'*\\' repeated was all the characters before it until you reached another \\'*\\' and that the character \\'*\\' was essentially replacing itself with that element and repeating itself.\\n\\nex. \\nif s = \\'mississippi\\', p = \\'mis*is*ip*.\\' return false because \\'mis\\'+\\'mis\\'*n cannot equal \"miss\"\\nand\\nif s = \"aab\", p = \"c*a*b\" return false because \\'c\\' + \\'c\\'*n cannot equal \\'a\\'"
                    },
                    {
                        "username": "Rohit_Bisht2003",
                        "content": "i have not understand the question\\n"
                    },
                    {
                        "username": "rohamghotbi",
                        "content": "VALIDATE != IMPLEMENT"
                    },
                    {
                        "username": "sgv558139",
                        "content": "Hello, not sure if anyone else is having great difficulty with this but I\\'ve tried at least 5 different ways to solve this problem, and have not had any success.\\nUsing C++, I\\'ve tried using simple pattern matching, std::maps, structs to store pattern metadata in the Solution object, using multi-passthroughs to scan each location that characters in pattern \"p\" appear in string \"s\", and now I\\'m stuck with where to use loops and recursion for parsing the asterisked elements.\\nAny advice on where to go next with this?\\nShould I skip this problem for now and return to the more difficult problems later?"
                    },
                    {
                        "username": "kaiken9101",
                        "content": "My Python3 algorithm for example number 3 in VS Code returns True, but here on the site the answer is False. Checked everything several times, no mistake.\n\n`if not p:`\nㅤㅤ`return not s`\n`first_match = bool(s) and p[0] in {s[0], '.'}`\n`if len(p) >= 2 and p[1] == '*':`\nㅤㅤ` return match(s, p[2:]) or (first_match and match(s[1:], p))`\n`else:`\nㅤㅤ` return first_match and match(s[1:], p[1:]) `"
                    },
                    {
                        "username": "lamialover6",
                        "content": "`s = \"a\"`\\n`p =  \".*..a*\"`\\n\\n`Output:`\\n`true`\\n`Expected:`\\n`false`\\n\\n\\ncan some please explain this?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "\\'*\\' Matches zero or more of the preceding element.\\nwhat does preceding element mean?\\nLast char or last char-chain?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "the description really needs an update!"
                    },
                    {
                        "username": "muddassirmomin2005",
                        "content": "# Initialize first row\\nfor j in range(2, m+1):\\n    dp[0][j] = dp[0][j-2] and p[j-1] == \\'*\\'\\n\\n# DP\\nfor i in range(1, n+1):\\n    for j in range(1, m+1):\\n        if p[j-1] != \\'*\\':\\n            dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == \\'.\\')\\n        else:\\n            dp[i][j `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "user8134AU",
                        "content": "s = \"bbbba\" , p=\" .* a* a \"  => Expected =true...  how is that a valid....I mean .* goes all the way to a, then a* will consume remaining a, and finally p has a left....If a* is expected to be zero match or real match...How is it valid If there is nothing then zero match is fine...This opens two possibilites"
                    }
                ]
            },
            {
                "id": 1828533,
                "content": [
                    {
                        "username": "eswarchowdhari",
                        "content": "please explain the question"
                    },
                    {
                        "username": "Zer0cool360",
                        "content": "This problem should\\'ve been clearer about the \\'*\\' only repeating 1 character and that the star when repeating its element 0 times removes the element. I thought that the element the \\'*\\' repeated was all the characters before it until you reached another \\'*\\' and that the character \\'*\\' was essentially replacing itself with that element and repeating itself.\\n\\nex. \\nif s = \\'mississippi\\', p = \\'mis*is*ip*.\\' return false because \\'mis\\'+\\'mis\\'*n cannot equal \"miss\"\\nand\\nif s = \"aab\", p = \"c*a*b\" return false because \\'c\\' + \\'c\\'*n cannot equal \\'a\\'"
                    },
                    {
                        "username": "Rohit_Bisht2003",
                        "content": "i have not understand the question\\n"
                    },
                    {
                        "username": "rohamghotbi",
                        "content": "VALIDATE != IMPLEMENT"
                    },
                    {
                        "username": "sgv558139",
                        "content": "Hello, not sure if anyone else is having great difficulty with this but I\\'ve tried at least 5 different ways to solve this problem, and have not had any success.\\nUsing C++, I\\'ve tried using simple pattern matching, std::maps, structs to store pattern metadata in the Solution object, using multi-passthroughs to scan each location that characters in pattern \"p\" appear in string \"s\", and now I\\'m stuck with where to use loops and recursion for parsing the asterisked elements.\\nAny advice on where to go next with this?\\nShould I skip this problem for now and return to the more difficult problems later?"
                    },
                    {
                        "username": "kaiken9101",
                        "content": "My Python3 algorithm for example number 3 in VS Code returns True, but here on the site the answer is False. Checked everything several times, no mistake.\n\n`if not p:`\nㅤㅤ`return not s`\n`first_match = bool(s) and p[0] in {s[0], '.'}`\n`if len(p) >= 2 and p[1] == '*':`\nㅤㅤ` return match(s, p[2:]) or (first_match and match(s[1:], p))`\n`else:`\nㅤㅤ` return first_match and match(s[1:], p[1:]) `"
                    },
                    {
                        "username": "lamialover6",
                        "content": "`s = \"a\"`\\n`p =  \".*..a*\"`\\n\\n`Output:`\\n`true`\\n`Expected:`\\n`false`\\n\\n\\ncan some please explain this?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "\\'*\\' Matches zero or more of the preceding element.\\nwhat does preceding element mean?\\nLast char or last char-chain?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "the description really needs an update!"
                    },
                    {
                        "username": "muddassirmomin2005",
                        "content": "# Initialize first row\\nfor j in range(2, m+1):\\n    dp[0][j] = dp[0][j-2] and p[j-1] == \\'*\\'\\n\\n# DP\\nfor i in range(1, n+1):\\n    for j in range(1, m+1):\\n        if p[j-1] != \\'*\\':\\n            dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == \\'.\\')\\n        else:\\n            dp[i][j `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "user8134AU",
                        "content": "s = \"bbbba\" , p=\" .* a* a \"  => Expected =true...  how is that a valid....I mean .* goes all the way to a, then a* will consume remaining a, and finally p has a left....If a* is expected to be zero match or real match...How is it valid If there is nothing then zero match is fine...This opens two possibilites"
                    }
                ]
            },
            {
                "id": 1826087,
                "content": [
                    {
                        "username": "eswarchowdhari",
                        "content": "please explain the question"
                    },
                    {
                        "username": "Zer0cool360",
                        "content": "This problem should\\'ve been clearer about the \\'*\\' only repeating 1 character and that the star when repeating its element 0 times removes the element. I thought that the element the \\'*\\' repeated was all the characters before it until you reached another \\'*\\' and that the character \\'*\\' was essentially replacing itself with that element and repeating itself.\\n\\nex. \\nif s = \\'mississippi\\', p = \\'mis*is*ip*.\\' return false because \\'mis\\'+\\'mis\\'*n cannot equal \"miss\"\\nand\\nif s = \"aab\", p = \"c*a*b\" return false because \\'c\\' + \\'c\\'*n cannot equal \\'a\\'"
                    },
                    {
                        "username": "Rohit_Bisht2003",
                        "content": "i have not understand the question\\n"
                    },
                    {
                        "username": "rohamghotbi",
                        "content": "VALIDATE != IMPLEMENT"
                    },
                    {
                        "username": "sgv558139",
                        "content": "Hello, not sure if anyone else is having great difficulty with this but I\\'ve tried at least 5 different ways to solve this problem, and have not had any success.\\nUsing C++, I\\'ve tried using simple pattern matching, std::maps, structs to store pattern metadata in the Solution object, using multi-passthroughs to scan each location that characters in pattern \"p\" appear in string \"s\", and now I\\'m stuck with where to use loops and recursion for parsing the asterisked elements.\\nAny advice on where to go next with this?\\nShould I skip this problem for now and return to the more difficult problems later?"
                    },
                    {
                        "username": "kaiken9101",
                        "content": "My Python3 algorithm for example number 3 in VS Code returns True, but here on the site the answer is False. Checked everything several times, no mistake.\n\n`if not p:`\nㅤㅤ`return not s`\n`first_match = bool(s) and p[0] in {s[0], '.'}`\n`if len(p) >= 2 and p[1] == '*':`\nㅤㅤ` return match(s, p[2:]) or (first_match and match(s[1:], p))`\n`else:`\nㅤㅤ` return first_match and match(s[1:], p[1:]) `"
                    },
                    {
                        "username": "lamialover6",
                        "content": "`s = \"a\"`\\n`p =  \".*..a*\"`\\n\\n`Output:`\\n`true`\\n`Expected:`\\n`false`\\n\\n\\ncan some please explain this?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "\\'*\\' Matches zero or more of the preceding element.\\nwhat does preceding element mean?\\nLast char or last char-chain?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "the description really needs an update!"
                    },
                    {
                        "username": "muddassirmomin2005",
                        "content": "# Initialize first row\\nfor j in range(2, m+1):\\n    dp[0][j] = dp[0][j-2] and p[j-1] == \\'*\\'\\n\\n# DP\\nfor i in range(1, n+1):\\n    for j in range(1, m+1):\\n        if p[j-1] != \\'*\\':\\n            dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == \\'.\\')\\n        else:\\n            dp[i][j `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "user8134AU",
                        "content": "s = \"bbbba\" , p=\" .* a* a \"  => Expected =true...  how is that a valid....I mean .* goes all the way to a, then a* will consume remaining a, and finally p has a left....If a* is expected to be zero match or real match...How is it valid If there is nothing then zero match is fine...This opens two possibilites"
                    }
                ]
            },
            {
                "id": 1825379,
                "content": [
                    {
                        "username": "eswarchowdhari",
                        "content": "please explain the question"
                    },
                    {
                        "username": "Zer0cool360",
                        "content": "This problem should\\'ve been clearer about the \\'*\\' only repeating 1 character and that the star when repeating its element 0 times removes the element. I thought that the element the \\'*\\' repeated was all the characters before it until you reached another \\'*\\' and that the character \\'*\\' was essentially replacing itself with that element and repeating itself.\\n\\nex. \\nif s = \\'mississippi\\', p = \\'mis*is*ip*.\\' return false because \\'mis\\'+\\'mis\\'*n cannot equal \"miss\"\\nand\\nif s = \"aab\", p = \"c*a*b\" return false because \\'c\\' + \\'c\\'*n cannot equal \\'a\\'"
                    },
                    {
                        "username": "Rohit_Bisht2003",
                        "content": "i have not understand the question\\n"
                    },
                    {
                        "username": "rohamghotbi",
                        "content": "VALIDATE != IMPLEMENT"
                    },
                    {
                        "username": "sgv558139",
                        "content": "Hello, not sure if anyone else is having great difficulty with this but I\\'ve tried at least 5 different ways to solve this problem, and have not had any success.\\nUsing C++, I\\'ve tried using simple pattern matching, std::maps, structs to store pattern metadata in the Solution object, using multi-passthroughs to scan each location that characters in pattern \"p\" appear in string \"s\", and now I\\'m stuck with where to use loops and recursion for parsing the asterisked elements.\\nAny advice on where to go next with this?\\nShould I skip this problem for now and return to the more difficult problems later?"
                    },
                    {
                        "username": "kaiken9101",
                        "content": "My Python3 algorithm for example number 3 in VS Code returns True, but here on the site the answer is False. Checked everything several times, no mistake.\n\n`if not p:`\nㅤㅤ`return not s`\n`first_match = bool(s) and p[0] in {s[0], '.'}`\n`if len(p) >= 2 and p[1] == '*':`\nㅤㅤ` return match(s, p[2:]) or (first_match and match(s[1:], p))`\n`else:`\nㅤㅤ` return first_match and match(s[1:], p[1:]) `"
                    },
                    {
                        "username": "lamialover6",
                        "content": "`s = \"a\"`\\n`p =  \".*..a*\"`\\n\\n`Output:`\\n`true`\\n`Expected:`\\n`false`\\n\\n\\ncan some please explain this?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "\\'*\\' Matches zero or more of the preceding element.\\nwhat does preceding element mean?\\nLast char or last char-chain?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "the description really needs an update!"
                    },
                    {
                        "username": "muddassirmomin2005",
                        "content": "# Initialize first row\\nfor j in range(2, m+1):\\n    dp[0][j] = dp[0][j-2] and p[j-1] == \\'*\\'\\n\\n# DP\\nfor i in range(1, n+1):\\n    for j in range(1, m+1):\\n        if p[j-1] != \\'*\\':\\n            dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == \\'.\\')\\n        else:\\n            dp[i][j `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "user8134AU",
                        "content": "s = \"bbbba\" , p=\" .* a* a \"  => Expected =true...  how is that a valid....I mean .* goes all the way to a, then a* will consume remaining a, and finally p has a left....If a* is expected to be zero match or real match...How is it valid If there is nothing then zero match is fine...This opens two possibilites"
                    }
                ]
            },
            {
                "id": 1821815,
                "content": [
                    {
                        "username": "eswarchowdhari",
                        "content": "please explain the question"
                    },
                    {
                        "username": "Zer0cool360",
                        "content": "This problem should\\'ve been clearer about the \\'*\\' only repeating 1 character and that the star when repeating its element 0 times removes the element. I thought that the element the \\'*\\' repeated was all the characters before it until you reached another \\'*\\' and that the character \\'*\\' was essentially replacing itself with that element and repeating itself.\\n\\nex. \\nif s = \\'mississippi\\', p = \\'mis*is*ip*.\\' return false because \\'mis\\'+\\'mis\\'*n cannot equal \"miss\"\\nand\\nif s = \"aab\", p = \"c*a*b\" return false because \\'c\\' + \\'c\\'*n cannot equal \\'a\\'"
                    },
                    {
                        "username": "Rohit_Bisht2003",
                        "content": "i have not understand the question\\n"
                    },
                    {
                        "username": "rohamghotbi",
                        "content": "VALIDATE != IMPLEMENT"
                    },
                    {
                        "username": "sgv558139",
                        "content": "Hello, not sure if anyone else is having great difficulty with this but I\\'ve tried at least 5 different ways to solve this problem, and have not had any success.\\nUsing C++, I\\'ve tried using simple pattern matching, std::maps, structs to store pattern metadata in the Solution object, using multi-passthroughs to scan each location that characters in pattern \"p\" appear in string \"s\", and now I\\'m stuck with where to use loops and recursion for parsing the asterisked elements.\\nAny advice on where to go next with this?\\nShould I skip this problem for now and return to the more difficult problems later?"
                    },
                    {
                        "username": "kaiken9101",
                        "content": "My Python3 algorithm for example number 3 in VS Code returns True, but here on the site the answer is False. Checked everything several times, no mistake.\n\n`if not p:`\nㅤㅤ`return not s`\n`first_match = bool(s) and p[0] in {s[0], '.'}`\n`if len(p) >= 2 and p[1] == '*':`\nㅤㅤ` return match(s, p[2:]) or (first_match and match(s[1:], p))`\n`else:`\nㅤㅤ` return first_match and match(s[1:], p[1:]) `"
                    },
                    {
                        "username": "lamialover6",
                        "content": "`s = \"a\"`\\n`p =  \".*..a*\"`\\n\\n`Output:`\\n`true`\\n`Expected:`\\n`false`\\n\\n\\ncan some please explain this?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "\\'*\\' Matches zero or more of the preceding element.\\nwhat does preceding element mean?\\nLast char or last char-chain?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "the description really needs an update!"
                    },
                    {
                        "username": "muddassirmomin2005",
                        "content": "# Initialize first row\\nfor j in range(2, m+1):\\n    dp[0][j] = dp[0][j-2] and p[j-1] == \\'*\\'\\n\\n# DP\\nfor i in range(1, n+1):\\n    for j in range(1, m+1):\\n        if p[j-1] != \\'*\\':\\n            dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == \\'.\\')\\n        else:\\n            dp[i][j `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "user8134AU",
                        "content": "s = \"bbbba\" , p=\" .* a* a \"  => Expected =true...  how is that a valid....I mean .* goes all the way to a, then a* will consume remaining a, and finally p has a left....If a* is expected to be zero match or real match...How is it valid If there is nothing then zero match is fine...This opens two possibilites"
                    }
                ]
            },
            {
                "id": 1821424,
                "content": [
                    {
                        "username": "eswarchowdhari",
                        "content": "please explain the question"
                    },
                    {
                        "username": "Zer0cool360",
                        "content": "This problem should\\'ve been clearer about the \\'*\\' only repeating 1 character and that the star when repeating its element 0 times removes the element. I thought that the element the \\'*\\' repeated was all the characters before it until you reached another \\'*\\' and that the character \\'*\\' was essentially replacing itself with that element and repeating itself.\\n\\nex. \\nif s = \\'mississippi\\', p = \\'mis*is*ip*.\\' return false because \\'mis\\'+\\'mis\\'*n cannot equal \"miss\"\\nand\\nif s = \"aab\", p = \"c*a*b\" return false because \\'c\\' + \\'c\\'*n cannot equal \\'a\\'"
                    },
                    {
                        "username": "Rohit_Bisht2003",
                        "content": "i have not understand the question\\n"
                    },
                    {
                        "username": "rohamghotbi",
                        "content": "VALIDATE != IMPLEMENT"
                    },
                    {
                        "username": "sgv558139",
                        "content": "Hello, not sure if anyone else is having great difficulty with this but I\\'ve tried at least 5 different ways to solve this problem, and have not had any success.\\nUsing C++, I\\'ve tried using simple pattern matching, std::maps, structs to store pattern metadata in the Solution object, using multi-passthroughs to scan each location that characters in pattern \"p\" appear in string \"s\", and now I\\'m stuck with where to use loops and recursion for parsing the asterisked elements.\\nAny advice on where to go next with this?\\nShould I skip this problem for now and return to the more difficult problems later?"
                    },
                    {
                        "username": "kaiken9101",
                        "content": "My Python3 algorithm for example number 3 in VS Code returns True, but here on the site the answer is False. Checked everything several times, no mistake.\n\n`if not p:`\nㅤㅤ`return not s`\n`first_match = bool(s) and p[0] in {s[0], '.'}`\n`if len(p) >= 2 and p[1] == '*':`\nㅤㅤ` return match(s, p[2:]) or (first_match and match(s[1:], p))`\n`else:`\nㅤㅤ` return first_match and match(s[1:], p[1:]) `"
                    },
                    {
                        "username": "lamialover6",
                        "content": "`s = \"a\"`\\n`p =  \".*..a*\"`\\n\\n`Output:`\\n`true`\\n`Expected:`\\n`false`\\n\\n\\ncan some please explain this?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "\\'*\\' Matches zero or more of the preceding element.\\nwhat does preceding element mean?\\nLast char or last char-chain?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "the description really needs an update!"
                    },
                    {
                        "username": "muddassirmomin2005",
                        "content": "# Initialize first row\\nfor j in range(2, m+1):\\n    dp[0][j] = dp[0][j-2] and p[j-1] == \\'*\\'\\n\\n# DP\\nfor i in range(1, n+1):\\n    for j in range(1, m+1):\\n        if p[j-1] != \\'*\\':\\n            dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == \\'.\\')\\n        else:\\n            dp[i][j `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "user8134AU",
                        "content": "s = \"bbbba\" , p=\" .* a* a \"  => Expected =true...  how is that a valid....I mean .* goes all the way to a, then a* will consume remaining a, and finally p has a left....If a* is expected to be zero match or real match...How is it valid If there is nothing then zero match is fine...This opens two possibilites"
                    }
                ]
            },
            {
                "id": 1821032,
                "content": [
                    {
                        "username": "eswarchowdhari",
                        "content": "please explain the question"
                    },
                    {
                        "username": "Zer0cool360",
                        "content": "This problem should\\'ve been clearer about the \\'*\\' only repeating 1 character and that the star when repeating its element 0 times removes the element. I thought that the element the \\'*\\' repeated was all the characters before it until you reached another \\'*\\' and that the character \\'*\\' was essentially replacing itself with that element and repeating itself.\\n\\nex. \\nif s = \\'mississippi\\', p = \\'mis*is*ip*.\\' return false because \\'mis\\'+\\'mis\\'*n cannot equal \"miss\"\\nand\\nif s = \"aab\", p = \"c*a*b\" return false because \\'c\\' + \\'c\\'*n cannot equal \\'a\\'"
                    },
                    {
                        "username": "Rohit_Bisht2003",
                        "content": "i have not understand the question\\n"
                    },
                    {
                        "username": "rohamghotbi",
                        "content": "VALIDATE != IMPLEMENT"
                    },
                    {
                        "username": "sgv558139",
                        "content": "Hello, not sure if anyone else is having great difficulty with this but I\\'ve tried at least 5 different ways to solve this problem, and have not had any success.\\nUsing C++, I\\'ve tried using simple pattern matching, std::maps, structs to store pattern metadata in the Solution object, using multi-passthroughs to scan each location that characters in pattern \"p\" appear in string \"s\", and now I\\'m stuck with where to use loops and recursion for parsing the asterisked elements.\\nAny advice on where to go next with this?\\nShould I skip this problem for now and return to the more difficult problems later?"
                    },
                    {
                        "username": "kaiken9101",
                        "content": "My Python3 algorithm for example number 3 in VS Code returns True, but here on the site the answer is False. Checked everything several times, no mistake.\n\n`if not p:`\nㅤㅤ`return not s`\n`first_match = bool(s) and p[0] in {s[0], '.'}`\n`if len(p) >= 2 and p[1] == '*':`\nㅤㅤ` return match(s, p[2:]) or (first_match and match(s[1:], p))`\n`else:`\nㅤㅤ` return first_match and match(s[1:], p[1:]) `"
                    },
                    {
                        "username": "lamialover6",
                        "content": "`s = \"a\"`\\n`p =  \".*..a*\"`\\n\\n`Output:`\\n`true`\\n`Expected:`\\n`false`\\n\\n\\ncan some please explain this?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "\\'*\\' Matches zero or more of the preceding element.\\nwhat does preceding element mean?\\nLast char or last char-chain?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "the description really needs an update!"
                    },
                    {
                        "username": "muddassirmomin2005",
                        "content": "# Initialize first row\\nfor j in range(2, m+1):\\n    dp[0][j] = dp[0][j-2] and p[j-1] == \\'*\\'\\n\\n# DP\\nfor i in range(1, n+1):\\n    for j in range(1, m+1):\\n        if p[j-1] != \\'*\\':\\n            dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == \\'.\\')\\n        else:\\n            dp[i][j `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "user8134AU",
                        "content": "s = \"bbbba\" , p=\" .* a* a \"  => Expected =true...  how is that a valid....I mean .* goes all the way to a, then a* will consume remaining a, and finally p has a left....If a* is expected to be zero match or real match...How is it valid If there is nothing then zero match is fine...This opens two possibilites"
                    }
                ]
            },
            {
                "id": 1818628,
                "content": [
                    {
                        "username": "eswarchowdhari",
                        "content": "please explain the question"
                    },
                    {
                        "username": "Zer0cool360",
                        "content": "This problem should\\'ve been clearer about the \\'*\\' only repeating 1 character and that the star when repeating its element 0 times removes the element. I thought that the element the \\'*\\' repeated was all the characters before it until you reached another \\'*\\' and that the character \\'*\\' was essentially replacing itself with that element and repeating itself.\\n\\nex. \\nif s = \\'mississippi\\', p = \\'mis*is*ip*.\\' return false because \\'mis\\'+\\'mis\\'*n cannot equal \"miss\"\\nand\\nif s = \"aab\", p = \"c*a*b\" return false because \\'c\\' + \\'c\\'*n cannot equal \\'a\\'"
                    },
                    {
                        "username": "Rohit_Bisht2003",
                        "content": "i have not understand the question\\n"
                    },
                    {
                        "username": "rohamghotbi",
                        "content": "VALIDATE != IMPLEMENT"
                    },
                    {
                        "username": "sgv558139",
                        "content": "Hello, not sure if anyone else is having great difficulty with this but I\\'ve tried at least 5 different ways to solve this problem, and have not had any success.\\nUsing C++, I\\'ve tried using simple pattern matching, std::maps, structs to store pattern metadata in the Solution object, using multi-passthroughs to scan each location that characters in pattern \"p\" appear in string \"s\", and now I\\'m stuck with where to use loops and recursion for parsing the asterisked elements.\\nAny advice on where to go next with this?\\nShould I skip this problem for now and return to the more difficult problems later?"
                    },
                    {
                        "username": "kaiken9101",
                        "content": "My Python3 algorithm for example number 3 in VS Code returns True, but here on the site the answer is False. Checked everything several times, no mistake.\n\n`if not p:`\nㅤㅤ`return not s`\n`first_match = bool(s) and p[0] in {s[0], '.'}`\n`if len(p) >= 2 and p[1] == '*':`\nㅤㅤ` return match(s, p[2:]) or (first_match and match(s[1:], p))`\n`else:`\nㅤㅤ` return first_match and match(s[1:], p[1:]) `"
                    },
                    {
                        "username": "lamialover6",
                        "content": "`s = \"a\"`\\n`p =  \".*..a*\"`\\n\\n`Output:`\\n`true`\\n`Expected:`\\n`false`\\n\\n\\ncan some please explain this?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "\\'*\\' Matches zero or more of the preceding element.\\nwhat does preceding element mean?\\nLast char or last char-chain?"
                    },
                    {
                        "username": "Q1CHENL",
                        "content": "the description really needs an update!"
                    },
                    {
                        "username": "muddassirmomin2005",
                        "content": "# Initialize first row\\nfor j in range(2, m+1):\\n    dp[0][j] = dp[0][j-2] and p[j-1] == \\'*\\'\\n\\n# DP\\nfor i in range(1, n+1):\\n    for j in range(1, m+1):\\n        if p[j-1] != \\'*\\':\\n            dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == \\'.\\')\\n        else:\\n            dp[i][j `your inline code...your inline code...` `your inline code...your inline code...`"
                    },
                    {
                        "username": "user8134AU",
                        "content": "s = \"bbbba\" , p=\" .* a* a \"  => Expected =true...  how is that a valid....I mean .* goes all the way to a, then a* will consume remaining a, and finally p has a left....If a* is expected to be zero match or real match...How is it valid If there is nothing then zero match is fine...This opens two possibilites"
                    }
                ]
            },
            {
                "id": 1809604,
                "content": [
                    {
                        "username": "vimleshy9",
                        "content": "Don\\'t get it why isMatch(\"aab\", \"c*a*b\") \\u2192 true, for this code is getting failed "
                    },
                    {
                        "username": "trishanan",
                        "content": "class Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\\n        dp[0][0] = True\\n        for j in range(1, m + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 2]\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'.\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \\'.\\'))\\n        return dp[n][m]"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Dp is not necessary for this question. Recursive works fine for some reason? Why havent they included larger  test cases?"
                    },
                    {
                        "username": "katie_fed",
                        "content": "Don't understand why:\n `s=\"aab\" and p=\"c*a*b\" = true` but  `s=\"ab\" and p=\".*c\" = false`\n \nIf we're just checking that the pattern includes the string, then \".*c\" should include `ab` since `.` = `a` and `*` = `b`, and `c` gets discounted, like in the first example. Could someone explain?"
                    },
                    {
                        "username": "user4773KJ",
                        "content": "In the first example, \"c\" can appear 0 times because it is followed by a \"*\". In the second example, s must end with a \"c\"."
                    },
                    {
                        "username": "MPCLaika",
                        "content": "the test case isMatch(\"ab\", \".*c\") has the expected output of false instead of true "
                    },
                    {
                        "username": "parniansh",
                        "content": "it has to end with \\'c\\' which is not, so the output should be false."
                    },
                    {
                        "username": "abdullahh_khann",
                        "content": "I don\\'t understand the question, what is the purpose of the \\'.\\' and the \\'*\\', I do not understand what they are supposed to do?"
                    },
                    {
                        "username": "parniansh",
                        "content": "For example if you want a regex with an 'a' in the beginning and a 'b' at the end and any character in the middle you go like this : \"a.b\" \n'.' means any character is ok.\nAnd the 'Asterisk' means any number of a specific character works. So if you want an 'a' in the beginning following with any number of 'b' (including zero) and a 'c' at the end you write it like this : \"ab'Asterisk'c\".\nI'm using the 'Asterisk' instead of the actual symbol because it gets removed from the text after I submit my answer. I don't know why."
                    },
                    {
                        "username": "anshulgarg904",
                        "content": "While trying multiple test cases like:\\naa\\n**\\nAbove one is a valid input, while below one is not:\\naa\\n***\\n\\nCan someone please help me understand the constraints in this problem?\\n\\nAt some places they are allowing multiple \\'*\\' consecutively while not in some test cases."
                    },
                    {
                        "username": "AlexandraN",
                        "content": "Can somebody explain why this decision gets Time Limit Exceeded code, even though all test cases pass? I've been studying Java for 2,5 months , so official LeetCode solution is kinda hard for me to fully understand.\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n    public boolean isMatch(String s, String p) {\n       Pattern a=Pattern.compile(p);\n       Matcher matcher= a.matcher(s);\n       return matcher.matches();\n    }\n}"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "why here we can't use one of the java method matches ? it showing TLE why for last testcase why?"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "\"aaaaaaaaaaaaaaaaaaab\"\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nGets TLE on Run, but gets accepted on Submission? Why so?"
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    }
                ]
            },
            {
                "id": 1809306,
                "content": [
                    {
                        "username": "vimleshy9",
                        "content": "Don\\'t get it why isMatch(\"aab\", \"c*a*b\") \\u2192 true, for this code is getting failed "
                    },
                    {
                        "username": "trishanan",
                        "content": "class Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\\n        dp[0][0] = True\\n        for j in range(1, m + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 2]\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'.\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \\'.\\'))\\n        return dp[n][m]"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Dp is not necessary for this question. Recursive works fine for some reason? Why havent they included larger  test cases?"
                    },
                    {
                        "username": "katie_fed",
                        "content": "Don't understand why:\n `s=\"aab\" and p=\"c*a*b\" = true` but  `s=\"ab\" and p=\".*c\" = false`\n \nIf we're just checking that the pattern includes the string, then \".*c\" should include `ab` since `.` = `a` and `*` = `b`, and `c` gets discounted, like in the first example. Could someone explain?"
                    },
                    {
                        "username": "user4773KJ",
                        "content": "In the first example, \"c\" can appear 0 times because it is followed by a \"*\". In the second example, s must end with a \"c\"."
                    },
                    {
                        "username": "MPCLaika",
                        "content": "the test case isMatch(\"ab\", \".*c\") has the expected output of false instead of true "
                    },
                    {
                        "username": "parniansh",
                        "content": "it has to end with \\'c\\' which is not, so the output should be false."
                    },
                    {
                        "username": "abdullahh_khann",
                        "content": "I don\\'t understand the question, what is the purpose of the \\'.\\' and the \\'*\\', I do not understand what they are supposed to do?"
                    },
                    {
                        "username": "parniansh",
                        "content": "For example if you want a regex with an 'a' in the beginning and a 'b' at the end and any character in the middle you go like this : \"a.b\" \n'.' means any character is ok.\nAnd the 'Asterisk' means any number of a specific character works. So if you want an 'a' in the beginning following with any number of 'b' (including zero) and a 'c' at the end you write it like this : \"ab'Asterisk'c\".\nI'm using the 'Asterisk' instead of the actual symbol because it gets removed from the text after I submit my answer. I don't know why."
                    },
                    {
                        "username": "anshulgarg904",
                        "content": "While trying multiple test cases like:\\naa\\n**\\nAbove one is a valid input, while below one is not:\\naa\\n***\\n\\nCan someone please help me understand the constraints in this problem?\\n\\nAt some places they are allowing multiple \\'*\\' consecutively while not in some test cases."
                    },
                    {
                        "username": "AlexandraN",
                        "content": "Can somebody explain why this decision gets Time Limit Exceeded code, even though all test cases pass? I've been studying Java for 2,5 months , so official LeetCode solution is kinda hard for me to fully understand.\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n    public boolean isMatch(String s, String p) {\n       Pattern a=Pattern.compile(p);\n       Matcher matcher= a.matcher(s);\n       return matcher.matches();\n    }\n}"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "why here we can't use one of the java method matches ? it showing TLE why for last testcase why?"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "\"aaaaaaaaaaaaaaaaaaab\"\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nGets TLE on Run, but gets accepted on Submission? Why so?"
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    }
                ]
            },
            {
                "id": 1807469,
                "content": [
                    {
                        "username": "vimleshy9",
                        "content": "Don\\'t get it why isMatch(\"aab\", \"c*a*b\") \\u2192 true, for this code is getting failed "
                    },
                    {
                        "username": "trishanan",
                        "content": "class Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\\n        dp[0][0] = True\\n        for j in range(1, m + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 2]\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'.\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \\'.\\'))\\n        return dp[n][m]"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Dp is not necessary for this question. Recursive works fine for some reason? Why havent they included larger  test cases?"
                    },
                    {
                        "username": "katie_fed",
                        "content": "Don't understand why:\n `s=\"aab\" and p=\"c*a*b\" = true` but  `s=\"ab\" and p=\".*c\" = false`\n \nIf we're just checking that the pattern includes the string, then \".*c\" should include `ab` since `.` = `a` and `*` = `b`, and `c` gets discounted, like in the first example. Could someone explain?"
                    },
                    {
                        "username": "user4773KJ",
                        "content": "In the first example, \"c\" can appear 0 times because it is followed by a \"*\". In the second example, s must end with a \"c\"."
                    },
                    {
                        "username": "MPCLaika",
                        "content": "the test case isMatch(\"ab\", \".*c\") has the expected output of false instead of true "
                    },
                    {
                        "username": "parniansh",
                        "content": "it has to end with \\'c\\' which is not, so the output should be false."
                    },
                    {
                        "username": "abdullahh_khann",
                        "content": "I don\\'t understand the question, what is the purpose of the \\'.\\' and the \\'*\\', I do not understand what they are supposed to do?"
                    },
                    {
                        "username": "parniansh",
                        "content": "For example if you want a regex with an 'a' in the beginning and a 'b' at the end and any character in the middle you go like this : \"a.b\" \n'.' means any character is ok.\nAnd the 'Asterisk' means any number of a specific character works. So if you want an 'a' in the beginning following with any number of 'b' (including zero) and a 'c' at the end you write it like this : \"ab'Asterisk'c\".\nI'm using the 'Asterisk' instead of the actual symbol because it gets removed from the text after I submit my answer. I don't know why."
                    },
                    {
                        "username": "anshulgarg904",
                        "content": "While trying multiple test cases like:\\naa\\n**\\nAbove one is a valid input, while below one is not:\\naa\\n***\\n\\nCan someone please help me understand the constraints in this problem?\\n\\nAt some places they are allowing multiple \\'*\\' consecutively while not in some test cases."
                    },
                    {
                        "username": "AlexandraN",
                        "content": "Can somebody explain why this decision gets Time Limit Exceeded code, even though all test cases pass? I've been studying Java for 2,5 months , so official LeetCode solution is kinda hard for me to fully understand.\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n    public boolean isMatch(String s, String p) {\n       Pattern a=Pattern.compile(p);\n       Matcher matcher= a.matcher(s);\n       return matcher.matches();\n    }\n}"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "why here we can't use one of the java method matches ? it showing TLE why for last testcase why?"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "\"aaaaaaaaaaaaaaaaaaab\"\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nGets TLE on Run, but gets accepted on Submission? Why so?"
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    }
                ]
            },
            {
                "id": 1802853,
                "content": [
                    {
                        "username": "vimleshy9",
                        "content": "Don\\'t get it why isMatch(\"aab\", \"c*a*b\") \\u2192 true, for this code is getting failed "
                    },
                    {
                        "username": "trishanan",
                        "content": "class Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\\n        dp[0][0] = True\\n        for j in range(1, m + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 2]\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'.\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \\'.\\'))\\n        return dp[n][m]"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Dp is not necessary for this question. Recursive works fine for some reason? Why havent they included larger  test cases?"
                    },
                    {
                        "username": "katie_fed",
                        "content": "Don't understand why:\n `s=\"aab\" and p=\"c*a*b\" = true` but  `s=\"ab\" and p=\".*c\" = false`\n \nIf we're just checking that the pattern includes the string, then \".*c\" should include `ab` since `.` = `a` and `*` = `b`, and `c` gets discounted, like in the first example. Could someone explain?"
                    },
                    {
                        "username": "user4773KJ",
                        "content": "In the first example, \"c\" can appear 0 times because it is followed by a \"*\". In the second example, s must end with a \"c\"."
                    },
                    {
                        "username": "MPCLaika",
                        "content": "the test case isMatch(\"ab\", \".*c\") has the expected output of false instead of true "
                    },
                    {
                        "username": "parniansh",
                        "content": "it has to end with \\'c\\' which is not, so the output should be false."
                    },
                    {
                        "username": "abdullahh_khann",
                        "content": "I don\\'t understand the question, what is the purpose of the \\'.\\' and the \\'*\\', I do not understand what they are supposed to do?"
                    },
                    {
                        "username": "parniansh",
                        "content": "For example if you want a regex with an 'a' in the beginning and a 'b' at the end and any character in the middle you go like this : \"a.b\" \n'.' means any character is ok.\nAnd the 'Asterisk' means any number of a specific character works. So if you want an 'a' in the beginning following with any number of 'b' (including zero) and a 'c' at the end you write it like this : \"ab'Asterisk'c\".\nI'm using the 'Asterisk' instead of the actual symbol because it gets removed from the text after I submit my answer. I don't know why."
                    },
                    {
                        "username": "anshulgarg904",
                        "content": "While trying multiple test cases like:\\naa\\n**\\nAbove one is a valid input, while below one is not:\\naa\\n***\\n\\nCan someone please help me understand the constraints in this problem?\\n\\nAt some places they are allowing multiple \\'*\\' consecutively while not in some test cases."
                    },
                    {
                        "username": "AlexandraN",
                        "content": "Can somebody explain why this decision gets Time Limit Exceeded code, even though all test cases pass? I've been studying Java for 2,5 months , so official LeetCode solution is kinda hard for me to fully understand.\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n    public boolean isMatch(String s, String p) {\n       Pattern a=Pattern.compile(p);\n       Matcher matcher= a.matcher(s);\n       return matcher.matches();\n    }\n}"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "why here we can't use one of the java method matches ? it showing TLE why for last testcase why?"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "\"aaaaaaaaaaaaaaaaaaab\"\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nGets TLE on Run, but gets accepted on Submission? Why so?"
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    }
                ]
            },
            {
                "id": 1793738,
                "content": [
                    {
                        "username": "vimleshy9",
                        "content": "Don\\'t get it why isMatch(\"aab\", \"c*a*b\") \\u2192 true, for this code is getting failed "
                    },
                    {
                        "username": "trishanan",
                        "content": "class Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\\n        dp[0][0] = True\\n        for j in range(1, m + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 2]\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'.\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \\'.\\'))\\n        return dp[n][m]"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Dp is not necessary for this question. Recursive works fine for some reason? Why havent they included larger  test cases?"
                    },
                    {
                        "username": "katie_fed",
                        "content": "Don't understand why:\n `s=\"aab\" and p=\"c*a*b\" = true` but  `s=\"ab\" and p=\".*c\" = false`\n \nIf we're just checking that the pattern includes the string, then \".*c\" should include `ab` since `.` = `a` and `*` = `b`, and `c` gets discounted, like in the first example. Could someone explain?"
                    },
                    {
                        "username": "user4773KJ",
                        "content": "In the first example, \"c\" can appear 0 times because it is followed by a \"*\". In the second example, s must end with a \"c\"."
                    },
                    {
                        "username": "MPCLaika",
                        "content": "the test case isMatch(\"ab\", \".*c\") has the expected output of false instead of true "
                    },
                    {
                        "username": "parniansh",
                        "content": "it has to end with \\'c\\' which is not, so the output should be false."
                    },
                    {
                        "username": "abdullahh_khann",
                        "content": "I don\\'t understand the question, what is the purpose of the \\'.\\' and the \\'*\\', I do not understand what they are supposed to do?"
                    },
                    {
                        "username": "parniansh",
                        "content": "For example if you want a regex with an 'a' in the beginning and a 'b' at the end and any character in the middle you go like this : \"a.b\" \n'.' means any character is ok.\nAnd the 'Asterisk' means any number of a specific character works. So if you want an 'a' in the beginning following with any number of 'b' (including zero) and a 'c' at the end you write it like this : \"ab'Asterisk'c\".\nI'm using the 'Asterisk' instead of the actual symbol because it gets removed from the text after I submit my answer. I don't know why."
                    },
                    {
                        "username": "anshulgarg904",
                        "content": "While trying multiple test cases like:\\naa\\n**\\nAbove one is a valid input, while below one is not:\\naa\\n***\\n\\nCan someone please help me understand the constraints in this problem?\\n\\nAt some places they are allowing multiple \\'*\\' consecutively while not in some test cases."
                    },
                    {
                        "username": "AlexandraN",
                        "content": "Can somebody explain why this decision gets Time Limit Exceeded code, even though all test cases pass? I've been studying Java for 2,5 months , so official LeetCode solution is kinda hard for me to fully understand.\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n    public boolean isMatch(String s, String p) {\n       Pattern a=Pattern.compile(p);\n       Matcher matcher= a.matcher(s);\n       return matcher.matches();\n    }\n}"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "why here we can't use one of the java method matches ? it showing TLE why for last testcase why?"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "\"aaaaaaaaaaaaaaaaaaab\"\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nGets TLE on Run, but gets accepted on Submission? Why so?"
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    }
                ]
            },
            {
                "id": 1793612,
                "content": [
                    {
                        "username": "vimleshy9",
                        "content": "Don\\'t get it why isMatch(\"aab\", \"c*a*b\") \\u2192 true, for this code is getting failed "
                    },
                    {
                        "username": "trishanan",
                        "content": "class Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\\n        dp[0][0] = True\\n        for j in range(1, m + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 2]\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'.\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \\'.\\'))\\n        return dp[n][m]"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Dp is not necessary for this question. Recursive works fine for some reason? Why havent they included larger  test cases?"
                    },
                    {
                        "username": "katie_fed",
                        "content": "Don't understand why:\n `s=\"aab\" and p=\"c*a*b\" = true` but  `s=\"ab\" and p=\".*c\" = false`\n \nIf we're just checking that the pattern includes the string, then \".*c\" should include `ab` since `.` = `a` and `*` = `b`, and `c` gets discounted, like in the first example. Could someone explain?"
                    },
                    {
                        "username": "user4773KJ",
                        "content": "In the first example, \"c\" can appear 0 times because it is followed by a \"*\". In the second example, s must end with a \"c\"."
                    },
                    {
                        "username": "MPCLaika",
                        "content": "the test case isMatch(\"ab\", \".*c\") has the expected output of false instead of true "
                    },
                    {
                        "username": "parniansh",
                        "content": "it has to end with \\'c\\' which is not, so the output should be false."
                    },
                    {
                        "username": "abdullahh_khann",
                        "content": "I don\\'t understand the question, what is the purpose of the \\'.\\' and the \\'*\\', I do not understand what they are supposed to do?"
                    },
                    {
                        "username": "parniansh",
                        "content": "For example if you want a regex with an 'a' in the beginning and a 'b' at the end and any character in the middle you go like this : \"a.b\" \n'.' means any character is ok.\nAnd the 'Asterisk' means any number of a specific character works. So if you want an 'a' in the beginning following with any number of 'b' (including zero) and a 'c' at the end you write it like this : \"ab'Asterisk'c\".\nI'm using the 'Asterisk' instead of the actual symbol because it gets removed from the text after I submit my answer. I don't know why."
                    },
                    {
                        "username": "anshulgarg904",
                        "content": "While trying multiple test cases like:\\naa\\n**\\nAbove one is a valid input, while below one is not:\\naa\\n***\\n\\nCan someone please help me understand the constraints in this problem?\\n\\nAt some places they are allowing multiple \\'*\\' consecutively while not in some test cases."
                    },
                    {
                        "username": "AlexandraN",
                        "content": "Can somebody explain why this decision gets Time Limit Exceeded code, even though all test cases pass? I've been studying Java for 2,5 months , so official LeetCode solution is kinda hard for me to fully understand.\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n    public boolean isMatch(String s, String p) {\n       Pattern a=Pattern.compile(p);\n       Matcher matcher= a.matcher(s);\n       return matcher.matches();\n    }\n}"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "why here we can't use one of the java method matches ? it showing TLE why for last testcase why?"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "\"aaaaaaaaaaaaaaaaaaab\"\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nGets TLE on Run, but gets accepted on Submission? Why so?"
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    }
                ]
            },
            {
                "id": 1783381,
                "content": [
                    {
                        "username": "vimleshy9",
                        "content": "Don\\'t get it why isMatch(\"aab\", \"c*a*b\") \\u2192 true, for this code is getting failed "
                    },
                    {
                        "username": "trishanan",
                        "content": "class Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\\n        dp[0][0] = True\\n        for j in range(1, m + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 2]\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'.\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \\'.\\'))\\n        return dp[n][m]"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Dp is not necessary for this question. Recursive works fine for some reason? Why havent they included larger  test cases?"
                    },
                    {
                        "username": "katie_fed",
                        "content": "Don't understand why:\n `s=\"aab\" and p=\"c*a*b\" = true` but  `s=\"ab\" and p=\".*c\" = false`\n \nIf we're just checking that the pattern includes the string, then \".*c\" should include `ab` since `.` = `a` and `*` = `b`, and `c` gets discounted, like in the first example. Could someone explain?"
                    },
                    {
                        "username": "user4773KJ",
                        "content": "In the first example, \"c\" can appear 0 times because it is followed by a \"*\". In the second example, s must end with a \"c\"."
                    },
                    {
                        "username": "MPCLaika",
                        "content": "the test case isMatch(\"ab\", \".*c\") has the expected output of false instead of true "
                    },
                    {
                        "username": "parniansh",
                        "content": "it has to end with \\'c\\' which is not, so the output should be false."
                    },
                    {
                        "username": "abdullahh_khann",
                        "content": "I don\\'t understand the question, what is the purpose of the \\'.\\' and the \\'*\\', I do not understand what they are supposed to do?"
                    },
                    {
                        "username": "parniansh",
                        "content": "For example if you want a regex with an 'a' in the beginning and a 'b' at the end and any character in the middle you go like this : \"a.b\" \n'.' means any character is ok.\nAnd the 'Asterisk' means any number of a specific character works. So if you want an 'a' in the beginning following with any number of 'b' (including zero) and a 'c' at the end you write it like this : \"ab'Asterisk'c\".\nI'm using the 'Asterisk' instead of the actual symbol because it gets removed from the text after I submit my answer. I don't know why."
                    },
                    {
                        "username": "anshulgarg904",
                        "content": "While trying multiple test cases like:\\naa\\n**\\nAbove one is a valid input, while below one is not:\\naa\\n***\\n\\nCan someone please help me understand the constraints in this problem?\\n\\nAt some places they are allowing multiple \\'*\\' consecutively while not in some test cases."
                    },
                    {
                        "username": "AlexandraN",
                        "content": "Can somebody explain why this decision gets Time Limit Exceeded code, even though all test cases pass? I've been studying Java for 2,5 months , so official LeetCode solution is kinda hard for me to fully understand.\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n    public boolean isMatch(String s, String p) {\n       Pattern a=Pattern.compile(p);\n       Matcher matcher= a.matcher(s);\n       return matcher.matches();\n    }\n}"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "why here we can't use one of the java method matches ? it showing TLE why for last testcase why?"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "\"aaaaaaaaaaaaaaaaaaab\"\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nGets TLE on Run, but gets accepted on Submission? Why so?"
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    }
                ]
            },
            {
                "id": 1782507,
                "content": [
                    {
                        "username": "vimleshy9",
                        "content": "Don\\'t get it why isMatch(\"aab\", \"c*a*b\") \\u2192 true, for this code is getting failed "
                    },
                    {
                        "username": "trishanan",
                        "content": "class Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\\n        dp[0][0] = True\\n        for j in range(1, m + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 2]\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'.\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \\'.\\'))\\n        return dp[n][m]"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Dp is not necessary for this question. Recursive works fine for some reason? Why havent they included larger  test cases?"
                    },
                    {
                        "username": "katie_fed",
                        "content": "Don't understand why:\n `s=\"aab\" and p=\"c*a*b\" = true` but  `s=\"ab\" and p=\".*c\" = false`\n \nIf we're just checking that the pattern includes the string, then \".*c\" should include `ab` since `.` = `a` and `*` = `b`, and `c` gets discounted, like in the first example. Could someone explain?"
                    },
                    {
                        "username": "user4773KJ",
                        "content": "In the first example, \"c\" can appear 0 times because it is followed by a \"*\". In the second example, s must end with a \"c\"."
                    },
                    {
                        "username": "MPCLaika",
                        "content": "the test case isMatch(\"ab\", \".*c\") has the expected output of false instead of true "
                    },
                    {
                        "username": "parniansh",
                        "content": "it has to end with \\'c\\' which is not, so the output should be false."
                    },
                    {
                        "username": "abdullahh_khann",
                        "content": "I don\\'t understand the question, what is the purpose of the \\'.\\' and the \\'*\\', I do not understand what they are supposed to do?"
                    },
                    {
                        "username": "parniansh",
                        "content": "For example if you want a regex with an 'a' in the beginning and a 'b' at the end and any character in the middle you go like this : \"a.b\" \n'.' means any character is ok.\nAnd the 'Asterisk' means any number of a specific character works. So if you want an 'a' in the beginning following with any number of 'b' (including zero) and a 'c' at the end you write it like this : \"ab'Asterisk'c\".\nI'm using the 'Asterisk' instead of the actual symbol because it gets removed from the text after I submit my answer. I don't know why."
                    },
                    {
                        "username": "anshulgarg904",
                        "content": "While trying multiple test cases like:\\naa\\n**\\nAbove one is a valid input, while below one is not:\\naa\\n***\\n\\nCan someone please help me understand the constraints in this problem?\\n\\nAt some places they are allowing multiple \\'*\\' consecutively while not in some test cases."
                    },
                    {
                        "username": "AlexandraN",
                        "content": "Can somebody explain why this decision gets Time Limit Exceeded code, even though all test cases pass? I've been studying Java for 2,5 months , so official LeetCode solution is kinda hard for me to fully understand.\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n    public boolean isMatch(String s, String p) {\n       Pattern a=Pattern.compile(p);\n       Matcher matcher= a.matcher(s);\n       return matcher.matches();\n    }\n}"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "why here we can't use one of the java method matches ? it showing TLE why for last testcase why?"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "\"aaaaaaaaaaaaaaaaaaab\"\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nGets TLE on Run, but gets accepted on Submission? Why so?"
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    }
                ]
            },
            {
                "id": 1782283,
                "content": [
                    {
                        "username": "vimleshy9",
                        "content": "Don\\'t get it why isMatch(\"aab\", \"c*a*b\") \\u2192 true, for this code is getting failed "
                    },
                    {
                        "username": "trishanan",
                        "content": "class Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\\n        dp[0][0] = True\\n        for j in range(1, m + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 2]\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'.\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \\'.\\'))\\n        return dp[n][m]"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Dp is not necessary for this question. Recursive works fine for some reason? Why havent they included larger  test cases?"
                    },
                    {
                        "username": "katie_fed",
                        "content": "Don't understand why:\n `s=\"aab\" and p=\"c*a*b\" = true` but  `s=\"ab\" and p=\".*c\" = false`\n \nIf we're just checking that the pattern includes the string, then \".*c\" should include `ab` since `.` = `a` and `*` = `b`, and `c` gets discounted, like in the first example. Could someone explain?"
                    },
                    {
                        "username": "user4773KJ",
                        "content": "In the first example, \"c\" can appear 0 times because it is followed by a \"*\". In the second example, s must end with a \"c\"."
                    },
                    {
                        "username": "MPCLaika",
                        "content": "the test case isMatch(\"ab\", \".*c\") has the expected output of false instead of true "
                    },
                    {
                        "username": "parniansh",
                        "content": "it has to end with \\'c\\' which is not, so the output should be false."
                    },
                    {
                        "username": "abdullahh_khann",
                        "content": "I don\\'t understand the question, what is the purpose of the \\'.\\' and the \\'*\\', I do not understand what they are supposed to do?"
                    },
                    {
                        "username": "parniansh",
                        "content": "For example if you want a regex with an 'a' in the beginning and a 'b' at the end and any character in the middle you go like this : \"a.b\" \n'.' means any character is ok.\nAnd the 'Asterisk' means any number of a specific character works. So if you want an 'a' in the beginning following with any number of 'b' (including zero) and a 'c' at the end you write it like this : \"ab'Asterisk'c\".\nI'm using the 'Asterisk' instead of the actual symbol because it gets removed from the text after I submit my answer. I don't know why."
                    },
                    {
                        "username": "anshulgarg904",
                        "content": "While trying multiple test cases like:\\naa\\n**\\nAbove one is a valid input, while below one is not:\\naa\\n***\\n\\nCan someone please help me understand the constraints in this problem?\\n\\nAt some places they are allowing multiple \\'*\\' consecutively while not in some test cases."
                    },
                    {
                        "username": "AlexandraN",
                        "content": "Can somebody explain why this decision gets Time Limit Exceeded code, even though all test cases pass? I've been studying Java for 2,5 months , so official LeetCode solution is kinda hard for me to fully understand.\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n    public boolean isMatch(String s, String p) {\n       Pattern a=Pattern.compile(p);\n       Matcher matcher= a.matcher(s);\n       return matcher.matches();\n    }\n}"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "why here we can't use one of the java method matches ? it showing TLE why for last testcase why?"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "\"aaaaaaaaaaaaaaaaaaab\"\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nGets TLE on Run, but gets accepted on Submission? Why so?"
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    }
                ]
            },
            {
                "id": 1773765,
                "content": [
                    {
                        "username": "vimleshy9",
                        "content": "Don\\'t get it why isMatch(\"aab\", \"c*a*b\") \\u2192 true, for this code is getting failed "
                    },
                    {
                        "username": "trishanan",
                        "content": "class Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n        dp = [[False] * (m + 1) for _ in range(n + 1)]\\n        dp[0][0] = True\\n        for j in range(1, m + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 2]\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'.\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == \\'.\\'))\\n        return dp[n][m]"
                    },
                    {
                        "username": "mayank_pant",
                        "content": "Dp is not necessary for this question. Recursive works fine for some reason? Why havent they included larger  test cases?"
                    },
                    {
                        "username": "katie_fed",
                        "content": "Don't understand why:\n `s=\"aab\" and p=\"c*a*b\" = true` but  `s=\"ab\" and p=\".*c\" = false`\n \nIf we're just checking that the pattern includes the string, then \".*c\" should include `ab` since `.` = `a` and `*` = `b`, and `c` gets discounted, like in the first example. Could someone explain?"
                    },
                    {
                        "username": "user4773KJ",
                        "content": "In the first example, \"c\" can appear 0 times because it is followed by a \"*\". In the second example, s must end with a \"c\"."
                    },
                    {
                        "username": "MPCLaika",
                        "content": "the test case isMatch(\"ab\", \".*c\") has the expected output of false instead of true "
                    },
                    {
                        "username": "parniansh",
                        "content": "it has to end with \\'c\\' which is not, so the output should be false."
                    },
                    {
                        "username": "abdullahh_khann",
                        "content": "I don\\'t understand the question, what is the purpose of the \\'.\\' and the \\'*\\', I do not understand what they are supposed to do?"
                    },
                    {
                        "username": "parniansh",
                        "content": "For example if you want a regex with an 'a' in the beginning and a 'b' at the end and any character in the middle you go like this : \"a.b\" \n'.' means any character is ok.\nAnd the 'Asterisk' means any number of a specific character works. So if you want an 'a' in the beginning following with any number of 'b' (including zero) and a 'c' at the end you write it like this : \"ab'Asterisk'c\".\nI'm using the 'Asterisk' instead of the actual symbol because it gets removed from the text after I submit my answer. I don't know why."
                    },
                    {
                        "username": "anshulgarg904",
                        "content": "While trying multiple test cases like:\\naa\\n**\\nAbove one is a valid input, while below one is not:\\naa\\n***\\n\\nCan someone please help me understand the constraints in this problem?\\n\\nAt some places they are allowing multiple \\'*\\' consecutively while not in some test cases."
                    },
                    {
                        "username": "AlexandraN",
                        "content": "Can somebody explain why this decision gets Time Limit Exceeded code, even though all test cases pass? I've been studying Java for 2,5 months , so official LeetCode solution is kinda hard for me to fully understand.\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n    public boolean isMatch(String s, String p) {\n       Pattern a=Pattern.compile(p);\n       Matcher matcher= a.matcher(s);\n       return matcher.matches();\n    }\n}"
                    },
                    {
                        "username": "vrajeshrs",
                        "content": "why here we can't use one of the java method matches ? it showing TLE why for last testcase why?"
                    },
                    {
                        "username": "RedWayfarer",
                        "content": "\"aaaaaaaaaaaaaaaaaaab\"\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nGets TLE on Run, but gets accepted on Submission? Why so?"
                    },
                    {
                        "username": "jsender",
                        "content": "I had the same problem. There is an optimization you can do to get it to run within the allotted amount of time."
                    }
                ]
            },
            {
                "id": 1773530,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "sh*t hard af"
                    },
                    {
                        "username": "anjali_kholiya",
                        "content": "please tell what is the problem in this solution?\\n\\nbool match(int i,int j , string s , string p,vector<vector<bool>>&memo)\\n   {\\n       if(j==p.size()) return i==s.size();\\n        if(memo[i][j]!=NULL) return memo[i][j];\\n\\n        bool firstmatch = i<s.size() && (s[i]==p[j] || p[j]==\\'.\\');\\n\\n       bool ans=false;\\n      if(j+1<p.size() && p[j+1]==\\'*\\')\\n      {\\n          ans=(firstmatch && match(i+1,j,s,p,memo))||(match(i,j+2,s,p,memo));\\n\\n      } \\n      else{\\n          ans=firstmatch && match(i+1,j+1,s,p,memo);\\n      }\\n\\n      memo[i][j]=ans;\\n  return ans;\\n   }\\n\\n    bool isMatch(string s, string p) {\\n        int n=s.size();\\n        int m=p.size();\\n    vector<vector<bool>> memo(n+1,vector<bool>(m+1,NULL));\\n    return match(0,0,s,p,memo);    \\n    }"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Why is this wrong.. I faced issue in \"mississippi\" and \"mis*is*p*.\".. This is match ... I don\\'t understand why this is not a match.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool rec(string s, string p, int si, int pi, vector<vector<int>>& dp)\\n    {\\n        cout<<si<<\" \"<<pi<<endl;\\n        if(si==-1) return true;\\n        if(pi==-1) return false;\\n        if(dp[si][pi]!=INT_MIN) return dp[si][pi];\\n        if(s[si]==p[pi] || p[pi]==\\'.\\') return dp[si][pi]=rec(s,p,si-1,pi-1,dp);\\n        if(p[pi]==\\'*\\') return dp[si][pi]=rec(s,p,si,pi-1,dp) || rec(s,p,si-1,pi,dp) || rec(s,p,si-1,pi-1,dp);\\n        return dp[si][pi]=false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.size(),vector<int>(p.size(),INT_MIN));\\n        return rec(s,p,s.size()-1,p.size()-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "manu69876",
                        "content": "input: \"mississippi\", \"mis*is*p*.\"\noutput: true\nexpected: false\nWHY??"
                    },
                    {
                        "username": "Digvijay_missionFang",
                        "content": "Editor has converted *i to italic i, please give white space between like \"m i s * i s * p * .\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "TBH I have no idea how I was able to solve this"
                    },
                    {
                        "username": "Shobana_M_C",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n353 / 353 testcases passed\\ns =\\n\"aaaaaaaaaaaaaaaaaaab\"\\np =\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nPlease help with this edgecase not passing thru"
                    },
                    {
                        "username": "jsender",
                        "content": "I\\'m not sure if [@Siegen](/siegen1192) is hinting at the same solution that I used (it doesn\\'t seem like it), but I came up against the same problem. There is a scalable optimization you can use to overcome this issue. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@Shobana M C](/Shobana_M_C) The \"b\" at the end of the string is causing recursive problem, you need to think of a way to deal with it\\nA hint for you is take a look at string p, it doesn\\'t contain \"b\""
                    },
                    {
                        "username": "vizzy205",
                        "content": "I got pissed off so in the last case I just did and used regex:\\n        if p==\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\":\\n            return False"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Does anybody knows why the output of the following input is \"False\"???? Instead of asterisk, I will use: '^'... please help I'm loosing my mind know\ns =\"a\"\np =\".^..a^\""
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: RunTime - 82ms\\n\\nimport re\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        x = re.findall(p, s)\\n        lenX = len(x)\\n        if lenX > 0 and x[0] == s:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Can I use regex to solve it? lol"
                    },
                    {
                        "username": "vizzy205",
                        "content": "gives time out to me lol"
                    }
                ]
            },
            {
                "id": 1772290,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "sh*t hard af"
                    },
                    {
                        "username": "anjali_kholiya",
                        "content": "please tell what is the problem in this solution?\\n\\nbool match(int i,int j , string s , string p,vector<vector<bool>>&memo)\\n   {\\n       if(j==p.size()) return i==s.size();\\n        if(memo[i][j]!=NULL) return memo[i][j];\\n\\n        bool firstmatch = i<s.size() && (s[i]==p[j] || p[j]==\\'.\\');\\n\\n       bool ans=false;\\n      if(j+1<p.size() && p[j+1]==\\'*\\')\\n      {\\n          ans=(firstmatch && match(i+1,j,s,p,memo))||(match(i,j+2,s,p,memo));\\n\\n      } \\n      else{\\n          ans=firstmatch && match(i+1,j+1,s,p,memo);\\n      }\\n\\n      memo[i][j]=ans;\\n  return ans;\\n   }\\n\\n    bool isMatch(string s, string p) {\\n        int n=s.size();\\n        int m=p.size();\\n    vector<vector<bool>> memo(n+1,vector<bool>(m+1,NULL));\\n    return match(0,0,s,p,memo);    \\n    }"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Why is this wrong.. I faced issue in \"mississippi\" and \"mis*is*p*.\".. This is match ... I don\\'t understand why this is not a match.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool rec(string s, string p, int si, int pi, vector<vector<int>>& dp)\\n    {\\n        cout<<si<<\" \"<<pi<<endl;\\n        if(si==-1) return true;\\n        if(pi==-1) return false;\\n        if(dp[si][pi]!=INT_MIN) return dp[si][pi];\\n        if(s[si]==p[pi] || p[pi]==\\'.\\') return dp[si][pi]=rec(s,p,si-1,pi-1,dp);\\n        if(p[pi]==\\'*\\') return dp[si][pi]=rec(s,p,si,pi-1,dp) || rec(s,p,si-1,pi,dp) || rec(s,p,si-1,pi-1,dp);\\n        return dp[si][pi]=false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.size(),vector<int>(p.size(),INT_MIN));\\n        return rec(s,p,s.size()-1,p.size()-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "manu69876",
                        "content": "input: \"mississippi\", \"mis*is*p*.\"\noutput: true\nexpected: false\nWHY??"
                    },
                    {
                        "username": "Digvijay_missionFang",
                        "content": "Editor has converted *i to italic i, please give white space between like \"m i s * i s * p * .\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "TBH I have no idea how I was able to solve this"
                    },
                    {
                        "username": "Shobana_M_C",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n353 / 353 testcases passed\\ns =\\n\"aaaaaaaaaaaaaaaaaaab\"\\np =\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nPlease help with this edgecase not passing thru"
                    },
                    {
                        "username": "jsender",
                        "content": "I\\'m not sure if [@Siegen](/siegen1192) is hinting at the same solution that I used (it doesn\\'t seem like it), but I came up against the same problem. There is a scalable optimization you can use to overcome this issue. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@Shobana M C](/Shobana_M_C) The \"b\" at the end of the string is causing recursive problem, you need to think of a way to deal with it\\nA hint for you is take a look at string p, it doesn\\'t contain \"b\""
                    },
                    {
                        "username": "vizzy205",
                        "content": "I got pissed off so in the last case I just did and used regex:\\n        if p==\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\":\\n            return False"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Does anybody knows why the output of the following input is \"False\"???? Instead of asterisk, I will use: '^'... please help I'm loosing my mind know\ns =\"a\"\np =\".^..a^\""
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: RunTime - 82ms\\n\\nimport re\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        x = re.findall(p, s)\\n        lenX = len(x)\\n        if lenX > 0 and x[0] == s:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Can I use regex to solve it? lol"
                    },
                    {
                        "username": "vizzy205",
                        "content": "gives time out to me lol"
                    }
                ]
            },
            {
                "id": 1767861,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "sh*t hard af"
                    },
                    {
                        "username": "anjali_kholiya",
                        "content": "please tell what is the problem in this solution?\\n\\nbool match(int i,int j , string s , string p,vector<vector<bool>>&memo)\\n   {\\n       if(j==p.size()) return i==s.size();\\n        if(memo[i][j]!=NULL) return memo[i][j];\\n\\n        bool firstmatch = i<s.size() && (s[i]==p[j] || p[j]==\\'.\\');\\n\\n       bool ans=false;\\n      if(j+1<p.size() && p[j+1]==\\'*\\')\\n      {\\n          ans=(firstmatch && match(i+1,j,s,p,memo))||(match(i,j+2,s,p,memo));\\n\\n      } \\n      else{\\n          ans=firstmatch && match(i+1,j+1,s,p,memo);\\n      }\\n\\n      memo[i][j]=ans;\\n  return ans;\\n   }\\n\\n    bool isMatch(string s, string p) {\\n        int n=s.size();\\n        int m=p.size();\\n    vector<vector<bool>> memo(n+1,vector<bool>(m+1,NULL));\\n    return match(0,0,s,p,memo);    \\n    }"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Why is this wrong.. I faced issue in \"mississippi\" and \"mis*is*p*.\".. This is match ... I don\\'t understand why this is not a match.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool rec(string s, string p, int si, int pi, vector<vector<int>>& dp)\\n    {\\n        cout<<si<<\" \"<<pi<<endl;\\n        if(si==-1) return true;\\n        if(pi==-1) return false;\\n        if(dp[si][pi]!=INT_MIN) return dp[si][pi];\\n        if(s[si]==p[pi] || p[pi]==\\'.\\') return dp[si][pi]=rec(s,p,si-1,pi-1,dp);\\n        if(p[pi]==\\'*\\') return dp[si][pi]=rec(s,p,si,pi-1,dp) || rec(s,p,si-1,pi,dp) || rec(s,p,si-1,pi-1,dp);\\n        return dp[si][pi]=false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.size(),vector<int>(p.size(),INT_MIN));\\n        return rec(s,p,s.size()-1,p.size()-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "manu69876",
                        "content": "input: \"mississippi\", \"mis*is*p*.\"\noutput: true\nexpected: false\nWHY??"
                    },
                    {
                        "username": "Digvijay_missionFang",
                        "content": "Editor has converted *i to italic i, please give white space between like \"m i s * i s * p * .\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "TBH I have no idea how I was able to solve this"
                    },
                    {
                        "username": "Shobana_M_C",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n353 / 353 testcases passed\\ns =\\n\"aaaaaaaaaaaaaaaaaaab\"\\np =\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nPlease help with this edgecase not passing thru"
                    },
                    {
                        "username": "jsender",
                        "content": "I\\'m not sure if [@Siegen](/siegen1192) is hinting at the same solution that I used (it doesn\\'t seem like it), but I came up against the same problem. There is a scalable optimization you can use to overcome this issue. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@Shobana M C](/Shobana_M_C) The \"b\" at the end of the string is causing recursive problem, you need to think of a way to deal with it\\nA hint for you is take a look at string p, it doesn\\'t contain \"b\""
                    },
                    {
                        "username": "vizzy205",
                        "content": "I got pissed off so in the last case I just did and used regex:\\n        if p==\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\":\\n            return False"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Does anybody knows why the output of the following input is \"False\"???? Instead of asterisk, I will use: '^'... please help I'm loosing my mind know\ns =\"a\"\np =\".^..a^\""
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: RunTime - 82ms\\n\\nimport re\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        x = re.findall(p, s)\\n        lenX = len(x)\\n        if lenX > 0 and x[0] == s:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Can I use regex to solve it? lol"
                    },
                    {
                        "username": "vizzy205",
                        "content": "gives time out to me lol"
                    }
                ]
            },
            {
                "id": 1762086,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "sh*t hard af"
                    },
                    {
                        "username": "anjali_kholiya",
                        "content": "please tell what is the problem in this solution?\\n\\nbool match(int i,int j , string s , string p,vector<vector<bool>>&memo)\\n   {\\n       if(j==p.size()) return i==s.size();\\n        if(memo[i][j]!=NULL) return memo[i][j];\\n\\n        bool firstmatch = i<s.size() && (s[i]==p[j] || p[j]==\\'.\\');\\n\\n       bool ans=false;\\n      if(j+1<p.size() && p[j+1]==\\'*\\')\\n      {\\n          ans=(firstmatch && match(i+1,j,s,p,memo))||(match(i,j+2,s,p,memo));\\n\\n      } \\n      else{\\n          ans=firstmatch && match(i+1,j+1,s,p,memo);\\n      }\\n\\n      memo[i][j]=ans;\\n  return ans;\\n   }\\n\\n    bool isMatch(string s, string p) {\\n        int n=s.size();\\n        int m=p.size();\\n    vector<vector<bool>> memo(n+1,vector<bool>(m+1,NULL));\\n    return match(0,0,s,p,memo);    \\n    }"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Why is this wrong.. I faced issue in \"mississippi\" and \"mis*is*p*.\".. This is match ... I don\\'t understand why this is not a match.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool rec(string s, string p, int si, int pi, vector<vector<int>>& dp)\\n    {\\n        cout<<si<<\" \"<<pi<<endl;\\n        if(si==-1) return true;\\n        if(pi==-1) return false;\\n        if(dp[si][pi]!=INT_MIN) return dp[si][pi];\\n        if(s[si]==p[pi] || p[pi]==\\'.\\') return dp[si][pi]=rec(s,p,si-1,pi-1,dp);\\n        if(p[pi]==\\'*\\') return dp[si][pi]=rec(s,p,si,pi-1,dp) || rec(s,p,si-1,pi,dp) || rec(s,p,si-1,pi-1,dp);\\n        return dp[si][pi]=false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.size(),vector<int>(p.size(),INT_MIN));\\n        return rec(s,p,s.size()-1,p.size()-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "manu69876",
                        "content": "input: \"mississippi\", \"mis*is*p*.\"\noutput: true\nexpected: false\nWHY??"
                    },
                    {
                        "username": "Digvijay_missionFang",
                        "content": "Editor has converted *i to italic i, please give white space between like \"m i s * i s * p * .\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "TBH I have no idea how I was able to solve this"
                    },
                    {
                        "username": "Shobana_M_C",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n353 / 353 testcases passed\\ns =\\n\"aaaaaaaaaaaaaaaaaaab\"\\np =\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nPlease help with this edgecase not passing thru"
                    },
                    {
                        "username": "jsender",
                        "content": "I\\'m not sure if [@Siegen](/siegen1192) is hinting at the same solution that I used (it doesn\\'t seem like it), but I came up against the same problem. There is a scalable optimization you can use to overcome this issue. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@Shobana M C](/Shobana_M_C) The \"b\" at the end of the string is causing recursive problem, you need to think of a way to deal with it\\nA hint for you is take a look at string p, it doesn\\'t contain \"b\""
                    },
                    {
                        "username": "vizzy205",
                        "content": "I got pissed off so in the last case I just did and used regex:\\n        if p==\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\":\\n            return False"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Does anybody knows why the output of the following input is \"False\"???? Instead of asterisk, I will use: '^'... please help I'm loosing my mind know\ns =\"a\"\np =\".^..a^\""
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: RunTime - 82ms\\n\\nimport re\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        x = re.findall(p, s)\\n        lenX = len(x)\\n        if lenX > 0 and x[0] == s:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Can I use regex to solve it? lol"
                    },
                    {
                        "username": "vizzy205",
                        "content": "gives time out to me lol"
                    }
                ]
            },
            {
                "id": 1761498,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "sh*t hard af"
                    },
                    {
                        "username": "anjali_kholiya",
                        "content": "please tell what is the problem in this solution?\\n\\nbool match(int i,int j , string s , string p,vector<vector<bool>>&memo)\\n   {\\n       if(j==p.size()) return i==s.size();\\n        if(memo[i][j]!=NULL) return memo[i][j];\\n\\n        bool firstmatch = i<s.size() && (s[i]==p[j] || p[j]==\\'.\\');\\n\\n       bool ans=false;\\n      if(j+1<p.size() && p[j+1]==\\'*\\')\\n      {\\n          ans=(firstmatch && match(i+1,j,s,p,memo))||(match(i,j+2,s,p,memo));\\n\\n      } \\n      else{\\n          ans=firstmatch && match(i+1,j+1,s,p,memo);\\n      }\\n\\n      memo[i][j]=ans;\\n  return ans;\\n   }\\n\\n    bool isMatch(string s, string p) {\\n        int n=s.size();\\n        int m=p.size();\\n    vector<vector<bool>> memo(n+1,vector<bool>(m+1,NULL));\\n    return match(0,0,s,p,memo);    \\n    }"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Why is this wrong.. I faced issue in \"mississippi\" and \"mis*is*p*.\".. This is match ... I don\\'t understand why this is not a match.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool rec(string s, string p, int si, int pi, vector<vector<int>>& dp)\\n    {\\n        cout<<si<<\" \"<<pi<<endl;\\n        if(si==-1) return true;\\n        if(pi==-1) return false;\\n        if(dp[si][pi]!=INT_MIN) return dp[si][pi];\\n        if(s[si]==p[pi] || p[pi]==\\'.\\') return dp[si][pi]=rec(s,p,si-1,pi-1,dp);\\n        if(p[pi]==\\'*\\') return dp[si][pi]=rec(s,p,si,pi-1,dp) || rec(s,p,si-1,pi,dp) || rec(s,p,si-1,pi-1,dp);\\n        return dp[si][pi]=false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.size(),vector<int>(p.size(),INT_MIN));\\n        return rec(s,p,s.size()-1,p.size()-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "manu69876",
                        "content": "input: \"mississippi\", \"mis*is*p*.\"\noutput: true\nexpected: false\nWHY??"
                    },
                    {
                        "username": "Digvijay_missionFang",
                        "content": "Editor has converted *i to italic i, please give white space between like \"m i s * i s * p * .\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "TBH I have no idea how I was able to solve this"
                    },
                    {
                        "username": "Shobana_M_C",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n353 / 353 testcases passed\\ns =\\n\"aaaaaaaaaaaaaaaaaaab\"\\np =\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nPlease help with this edgecase not passing thru"
                    },
                    {
                        "username": "jsender",
                        "content": "I\\'m not sure if [@Siegen](/siegen1192) is hinting at the same solution that I used (it doesn\\'t seem like it), but I came up against the same problem. There is a scalable optimization you can use to overcome this issue. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@Shobana M C](/Shobana_M_C) The \"b\" at the end of the string is causing recursive problem, you need to think of a way to deal with it\\nA hint for you is take a look at string p, it doesn\\'t contain \"b\""
                    },
                    {
                        "username": "vizzy205",
                        "content": "I got pissed off so in the last case I just did and used regex:\\n        if p==\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\":\\n            return False"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Does anybody knows why the output of the following input is \"False\"???? Instead of asterisk, I will use: '^'... please help I'm loosing my mind know\ns =\"a\"\np =\".^..a^\""
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: RunTime - 82ms\\n\\nimport re\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        x = re.findall(p, s)\\n        lenX = len(x)\\n        if lenX > 0 and x[0] == s:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Can I use regex to solve it? lol"
                    },
                    {
                        "username": "vizzy205",
                        "content": "gives time out to me lol"
                    }
                ]
            },
            {
                "id": 1760337,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "sh*t hard af"
                    },
                    {
                        "username": "anjali_kholiya",
                        "content": "please tell what is the problem in this solution?\\n\\nbool match(int i,int j , string s , string p,vector<vector<bool>>&memo)\\n   {\\n       if(j==p.size()) return i==s.size();\\n        if(memo[i][j]!=NULL) return memo[i][j];\\n\\n        bool firstmatch = i<s.size() && (s[i]==p[j] || p[j]==\\'.\\');\\n\\n       bool ans=false;\\n      if(j+1<p.size() && p[j+1]==\\'*\\')\\n      {\\n          ans=(firstmatch && match(i+1,j,s,p,memo))||(match(i,j+2,s,p,memo));\\n\\n      } \\n      else{\\n          ans=firstmatch && match(i+1,j+1,s,p,memo);\\n      }\\n\\n      memo[i][j]=ans;\\n  return ans;\\n   }\\n\\n    bool isMatch(string s, string p) {\\n        int n=s.size();\\n        int m=p.size();\\n    vector<vector<bool>> memo(n+1,vector<bool>(m+1,NULL));\\n    return match(0,0,s,p,memo);    \\n    }"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Why is this wrong.. I faced issue in \"mississippi\" and \"mis*is*p*.\".. This is match ... I don\\'t understand why this is not a match.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool rec(string s, string p, int si, int pi, vector<vector<int>>& dp)\\n    {\\n        cout<<si<<\" \"<<pi<<endl;\\n        if(si==-1) return true;\\n        if(pi==-1) return false;\\n        if(dp[si][pi]!=INT_MIN) return dp[si][pi];\\n        if(s[si]==p[pi] || p[pi]==\\'.\\') return dp[si][pi]=rec(s,p,si-1,pi-1,dp);\\n        if(p[pi]==\\'*\\') return dp[si][pi]=rec(s,p,si,pi-1,dp) || rec(s,p,si-1,pi,dp) || rec(s,p,si-1,pi-1,dp);\\n        return dp[si][pi]=false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.size(),vector<int>(p.size(),INT_MIN));\\n        return rec(s,p,s.size()-1,p.size()-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "manu69876",
                        "content": "input: \"mississippi\", \"mis*is*p*.\"\noutput: true\nexpected: false\nWHY??"
                    },
                    {
                        "username": "Digvijay_missionFang",
                        "content": "Editor has converted *i to italic i, please give white space between like \"m i s * i s * p * .\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "TBH I have no idea how I was able to solve this"
                    },
                    {
                        "username": "Shobana_M_C",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n353 / 353 testcases passed\\ns =\\n\"aaaaaaaaaaaaaaaaaaab\"\\np =\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nPlease help with this edgecase not passing thru"
                    },
                    {
                        "username": "jsender",
                        "content": "I\\'m not sure if [@Siegen](/siegen1192) is hinting at the same solution that I used (it doesn\\'t seem like it), but I came up against the same problem. There is a scalable optimization you can use to overcome this issue. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@Shobana M C](/Shobana_M_C) The \"b\" at the end of the string is causing recursive problem, you need to think of a way to deal with it\\nA hint for you is take a look at string p, it doesn\\'t contain \"b\""
                    },
                    {
                        "username": "vizzy205",
                        "content": "I got pissed off so in the last case I just did and used regex:\\n        if p==\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\":\\n            return False"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Does anybody knows why the output of the following input is \"False\"???? Instead of asterisk, I will use: '^'... please help I'm loosing my mind know\ns =\"a\"\np =\".^..a^\""
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: RunTime - 82ms\\n\\nimport re\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        x = re.findall(p, s)\\n        lenX = len(x)\\n        if lenX > 0 and x[0] == s:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Can I use regex to solve it? lol"
                    },
                    {
                        "username": "vizzy205",
                        "content": "gives time out to me lol"
                    }
                ]
            },
            {
                "id": 1757140,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "sh*t hard af"
                    },
                    {
                        "username": "anjali_kholiya",
                        "content": "please tell what is the problem in this solution?\\n\\nbool match(int i,int j , string s , string p,vector<vector<bool>>&memo)\\n   {\\n       if(j==p.size()) return i==s.size();\\n        if(memo[i][j]!=NULL) return memo[i][j];\\n\\n        bool firstmatch = i<s.size() && (s[i]==p[j] || p[j]==\\'.\\');\\n\\n       bool ans=false;\\n      if(j+1<p.size() && p[j+1]==\\'*\\')\\n      {\\n          ans=(firstmatch && match(i+1,j,s,p,memo))||(match(i,j+2,s,p,memo));\\n\\n      } \\n      else{\\n          ans=firstmatch && match(i+1,j+1,s,p,memo);\\n      }\\n\\n      memo[i][j]=ans;\\n  return ans;\\n   }\\n\\n    bool isMatch(string s, string p) {\\n        int n=s.size();\\n        int m=p.size();\\n    vector<vector<bool>> memo(n+1,vector<bool>(m+1,NULL));\\n    return match(0,0,s,p,memo);    \\n    }"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Why is this wrong.. I faced issue in \"mississippi\" and \"mis*is*p*.\".. This is match ... I don\\'t understand why this is not a match.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool rec(string s, string p, int si, int pi, vector<vector<int>>& dp)\\n    {\\n        cout<<si<<\" \"<<pi<<endl;\\n        if(si==-1) return true;\\n        if(pi==-1) return false;\\n        if(dp[si][pi]!=INT_MIN) return dp[si][pi];\\n        if(s[si]==p[pi] || p[pi]==\\'.\\') return dp[si][pi]=rec(s,p,si-1,pi-1,dp);\\n        if(p[pi]==\\'*\\') return dp[si][pi]=rec(s,p,si,pi-1,dp) || rec(s,p,si-1,pi,dp) || rec(s,p,si-1,pi-1,dp);\\n        return dp[si][pi]=false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.size(),vector<int>(p.size(),INT_MIN));\\n        return rec(s,p,s.size()-1,p.size()-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "manu69876",
                        "content": "input: \"mississippi\", \"mis*is*p*.\"\noutput: true\nexpected: false\nWHY??"
                    },
                    {
                        "username": "Digvijay_missionFang",
                        "content": "Editor has converted *i to italic i, please give white space between like \"m i s * i s * p * .\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "TBH I have no idea how I was able to solve this"
                    },
                    {
                        "username": "Shobana_M_C",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n353 / 353 testcases passed\\ns =\\n\"aaaaaaaaaaaaaaaaaaab\"\\np =\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nPlease help with this edgecase not passing thru"
                    },
                    {
                        "username": "jsender",
                        "content": "I\\'m not sure if [@Siegen](/siegen1192) is hinting at the same solution that I used (it doesn\\'t seem like it), but I came up against the same problem. There is a scalable optimization you can use to overcome this issue. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@Shobana M C](/Shobana_M_C) The \"b\" at the end of the string is causing recursive problem, you need to think of a way to deal with it\\nA hint for you is take a look at string p, it doesn\\'t contain \"b\""
                    },
                    {
                        "username": "vizzy205",
                        "content": "I got pissed off so in the last case I just did and used regex:\\n        if p==\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\":\\n            return False"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Does anybody knows why the output of the following input is \"False\"???? Instead of asterisk, I will use: '^'... please help I'm loosing my mind know\ns =\"a\"\np =\".^..a^\""
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: RunTime - 82ms\\n\\nimport re\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        x = re.findall(p, s)\\n        lenX = len(x)\\n        if lenX > 0 and x[0] == s:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Can I use regex to solve it? lol"
                    },
                    {
                        "username": "vizzy205",
                        "content": "gives time out to me lol"
                    }
                ]
            },
            {
                "id": 1756145,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "sh*t hard af"
                    },
                    {
                        "username": "anjali_kholiya",
                        "content": "please tell what is the problem in this solution?\\n\\nbool match(int i,int j , string s , string p,vector<vector<bool>>&memo)\\n   {\\n       if(j==p.size()) return i==s.size();\\n        if(memo[i][j]!=NULL) return memo[i][j];\\n\\n        bool firstmatch = i<s.size() && (s[i]==p[j] || p[j]==\\'.\\');\\n\\n       bool ans=false;\\n      if(j+1<p.size() && p[j+1]==\\'*\\')\\n      {\\n          ans=(firstmatch && match(i+1,j,s,p,memo))||(match(i,j+2,s,p,memo));\\n\\n      } \\n      else{\\n          ans=firstmatch && match(i+1,j+1,s,p,memo);\\n      }\\n\\n      memo[i][j]=ans;\\n  return ans;\\n   }\\n\\n    bool isMatch(string s, string p) {\\n        int n=s.size();\\n        int m=p.size();\\n    vector<vector<bool>> memo(n+1,vector<bool>(m+1,NULL));\\n    return match(0,0,s,p,memo);    \\n    }"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Why is this wrong.. I faced issue in \"mississippi\" and \"mis*is*p*.\".. This is match ... I don\\'t understand why this is not a match.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool rec(string s, string p, int si, int pi, vector<vector<int>>& dp)\\n    {\\n        cout<<si<<\" \"<<pi<<endl;\\n        if(si==-1) return true;\\n        if(pi==-1) return false;\\n        if(dp[si][pi]!=INT_MIN) return dp[si][pi];\\n        if(s[si]==p[pi] || p[pi]==\\'.\\') return dp[si][pi]=rec(s,p,si-1,pi-1,dp);\\n        if(p[pi]==\\'*\\') return dp[si][pi]=rec(s,p,si,pi-1,dp) || rec(s,p,si-1,pi,dp) || rec(s,p,si-1,pi-1,dp);\\n        return dp[si][pi]=false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.size(),vector<int>(p.size(),INT_MIN));\\n        return rec(s,p,s.size()-1,p.size()-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "manu69876",
                        "content": "input: \"mississippi\", \"mis*is*p*.\"\noutput: true\nexpected: false\nWHY??"
                    },
                    {
                        "username": "Digvijay_missionFang",
                        "content": "Editor has converted *i to italic i, please give white space between like \"m i s * i s * p * .\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "TBH I have no idea how I was able to solve this"
                    },
                    {
                        "username": "Shobana_M_C",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n353 / 353 testcases passed\\ns =\\n\"aaaaaaaaaaaaaaaaaaab\"\\np =\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nPlease help with this edgecase not passing thru"
                    },
                    {
                        "username": "jsender",
                        "content": "I\\'m not sure if [@Siegen](/siegen1192) is hinting at the same solution that I used (it doesn\\'t seem like it), but I came up against the same problem. There is a scalable optimization you can use to overcome this issue. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@Shobana M C](/Shobana_M_C) The \"b\" at the end of the string is causing recursive problem, you need to think of a way to deal with it\\nA hint for you is take a look at string p, it doesn\\'t contain \"b\""
                    },
                    {
                        "username": "vizzy205",
                        "content": "I got pissed off so in the last case I just did and used regex:\\n        if p==\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\":\\n            return False"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Does anybody knows why the output of the following input is \"False\"???? Instead of asterisk, I will use: '^'... please help I'm loosing my mind know\ns =\"a\"\np =\".^..a^\""
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: RunTime - 82ms\\n\\nimport re\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        x = re.findall(p, s)\\n        lenX = len(x)\\n        if lenX > 0 and x[0] == s:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Can I use regex to solve it? lol"
                    },
                    {
                        "username": "vizzy205",
                        "content": "gives time out to me lol"
                    }
                ]
            },
            {
                "id": 1755227,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "sh*t hard af"
                    },
                    {
                        "username": "anjali_kholiya",
                        "content": "please tell what is the problem in this solution?\\n\\nbool match(int i,int j , string s , string p,vector<vector<bool>>&memo)\\n   {\\n       if(j==p.size()) return i==s.size();\\n        if(memo[i][j]!=NULL) return memo[i][j];\\n\\n        bool firstmatch = i<s.size() && (s[i]==p[j] || p[j]==\\'.\\');\\n\\n       bool ans=false;\\n      if(j+1<p.size() && p[j+1]==\\'*\\')\\n      {\\n          ans=(firstmatch && match(i+1,j,s,p,memo))||(match(i,j+2,s,p,memo));\\n\\n      } \\n      else{\\n          ans=firstmatch && match(i+1,j+1,s,p,memo);\\n      }\\n\\n      memo[i][j]=ans;\\n  return ans;\\n   }\\n\\n    bool isMatch(string s, string p) {\\n        int n=s.size();\\n        int m=p.size();\\n    vector<vector<bool>> memo(n+1,vector<bool>(m+1,NULL));\\n    return match(0,0,s,p,memo);    \\n    }"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Why is this wrong.. I faced issue in \"mississippi\" and \"mis*is*p*.\".. This is match ... I don\\'t understand why this is not a match.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool rec(string s, string p, int si, int pi, vector<vector<int>>& dp)\\n    {\\n        cout<<si<<\" \"<<pi<<endl;\\n        if(si==-1) return true;\\n        if(pi==-1) return false;\\n        if(dp[si][pi]!=INT_MIN) return dp[si][pi];\\n        if(s[si]==p[pi] || p[pi]==\\'.\\') return dp[si][pi]=rec(s,p,si-1,pi-1,dp);\\n        if(p[pi]==\\'*\\') return dp[si][pi]=rec(s,p,si,pi-1,dp) || rec(s,p,si-1,pi,dp) || rec(s,p,si-1,pi-1,dp);\\n        return dp[si][pi]=false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.size(),vector<int>(p.size(),INT_MIN));\\n        return rec(s,p,s.size()-1,p.size()-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "manu69876",
                        "content": "input: \"mississippi\", \"mis*is*p*.\"\noutput: true\nexpected: false\nWHY??"
                    },
                    {
                        "username": "Digvijay_missionFang",
                        "content": "Editor has converted *i to italic i, please give white space between like \"m i s * i s * p * .\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "TBH I have no idea how I was able to solve this"
                    },
                    {
                        "username": "Shobana_M_C",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n353 / 353 testcases passed\\ns =\\n\"aaaaaaaaaaaaaaaaaaab\"\\np =\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nPlease help with this edgecase not passing thru"
                    },
                    {
                        "username": "jsender",
                        "content": "I\\'m not sure if [@Siegen](/siegen1192) is hinting at the same solution that I used (it doesn\\'t seem like it), but I came up against the same problem. There is a scalable optimization you can use to overcome this issue. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@Shobana M C](/Shobana_M_C) The \"b\" at the end of the string is causing recursive problem, you need to think of a way to deal with it\\nA hint for you is take a look at string p, it doesn\\'t contain \"b\""
                    },
                    {
                        "username": "vizzy205",
                        "content": "I got pissed off so in the last case I just did and used regex:\\n        if p==\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\":\\n            return False"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Does anybody knows why the output of the following input is \"False\"???? Instead of asterisk, I will use: '^'... please help I'm loosing my mind know\ns =\"a\"\np =\".^..a^\""
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: RunTime - 82ms\\n\\nimport re\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        x = re.findall(p, s)\\n        lenX = len(x)\\n        if lenX > 0 and x[0] == s:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Can I use regex to solve it? lol"
                    },
                    {
                        "username": "vizzy205",
                        "content": "gives time out to me lol"
                    }
                ]
            },
            {
                "id": 1754863,
                "content": [
                    {
                        "username": "easy_problems_hunter",
                        "content": "sh*t hard af"
                    },
                    {
                        "username": "anjali_kholiya",
                        "content": "please tell what is the problem in this solution?\\n\\nbool match(int i,int j , string s , string p,vector<vector<bool>>&memo)\\n   {\\n       if(j==p.size()) return i==s.size();\\n        if(memo[i][j]!=NULL) return memo[i][j];\\n\\n        bool firstmatch = i<s.size() && (s[i]==p[j] || p[j]==\\'.\\');\\n\\n       bool ans=false;\\n      if(j+1<p.size() && p[j+1]==\\'*\\')\\n      {\\n          ans=(firstmatch && match(i+1,j,s,p,memo))||(match(i,j+2,s,p,memo));\\n\\n      } \\n      else{\\n          ans=firstmatch && match(i+1,j+1,s,p,memo);\\n      }\\n\\n      memo[i][j]=ans;\\n  return ans;\\n   }\\n\\n    bool isMatch(string s, string p) {\\n        int n=s.size();\\n        int m=p.size();\\n    vector<vector<bool>> memo(n+1,vector<bool>(m+1,NULL));\\n    return match(0,0,s,p,memo);    \\n    }"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Why is this wrong.. I faced issue in \"mississippi\" and \"mis*is*p*.\".. This is match ... I don\\'t understand why this is not a match.\\n\\n\\n\\nclass Solution {\\npublic:\\n    bool rec(string s, string p, int si, int pi, vector<vector<int>>& dp)\\n    {\\n        cout<<si<<\" \"<<pi<<endl;\\n        if(si==-1) return true;\\n        if(pi==-1) return false;\\n        if(dp[si][pi]!=INT_MIN) return dp[si][pi];\\n        if(s[si]==p[pi] || p[pi]==\\'.\\') return dp[si][pi]=rec(s,p,si-1,pi-1,dp);\\n        if(p[pi]==\\'*\\') return dp[si][pi]=rec(s,p,si,pi-1,dp) || rec(s,p,si-1,pi,dp) || rec(s,p,si-1,pi-1,dp);\\n        return dp[si][pi]=false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.size(),vector<int>(p.size(),INT_MIN));\\n        return rec(s,p,s.size()-1,p.size()-1,dp);\\n    }\\n};"
                    },
                    {
                        "username": "manu69876",
                        "content": "input: \"mississippi\", \"mis*is*p*.\"\noutput: true\nexpected: false\nWHY??"
                    },
                    {
                        "username": "Digvijay_missionFang",
                        "content": "Editor has converted *i to italic i, please give white space between like \"m i s * i s * p * .\""
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "TBH I have no idea how I was able to solve this"
                    },
                    {
                        "username": "Shobana_M_C",
                        "content": "Time Limit Exceeded\\nLast Executed Input\\n353 / 353 testcases passed\\ns =\\n\"aaaaaaaaaaaaaaaaaaab\"\\np =\\n\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\"\\n\\nPlease help with this edgecase not passing thru"
                    },
                    {
                        "username": "jsender",
                        "content": "I\\'m not sure if [@Siegen](/siegen1192) is hinting at the same solution that I used (it doesn\\'t seem like it), but I came up against the same problem. There is a scalable optimization you can use to overcome this issue. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@Shobana M C](/Shobana_M_C) The \"b\" at the end of the string is causing recursive problem, you need to think of a way to deal with it\\nA hint for you is take a look at string p, it doesn\\'t contain \"b\""
                    },
                    {
                        "username": "vizzy205",
                        "content": "I got pissed off so in the last case I just did and used regex:\\n        if p==\"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*\":\\n            return False"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Does anybody knows why the output of the following input is \"False\"???? Instead of asterisk, I will use: '^'... please help I'm loosing my mind know\ns =\"a\"\np =\".^..a^\""
                    },
                    {
                        "username": "user9407T",
                        "content": "Python Solution: RunTime - 82ms\\n\\nimport re\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        x = re.findall(p, s)\\n        lenX = len(x)\\n        if lenX > 0 and x[0] == s:\\n            return True\\n        else:\\n            return False"
                    },
                    {
                        "username": "ptk_trindade",
                        "content": "Can I use regex to solve it? lol"
                    },
                    {
                        "username": "vizzy205",
                        "content": "gives time out to me lol"
                    }
                ]
            },
            {
                "id": 1750920,
                "content": [
                    {
                        "username": "pulkitgoel28",
                        "content": "The implementation uses a 2D Boolean array, dp[i, j] represents whether the substring of the input string s up to index i matches the substring of the pattern string p up to index j.\nIt checks every sub-string of the input string and matches them with the pattern.\n\nNote that in C# arrays are 0-based, so when you want to access to i-th element you need to use i-1 index.\n\nThe time and space complexity of this solution also the same as previous one O(m*n). \n\nclass Solution {\n    public bool IsMatch(string s, string p) {\n        int m = s.Length, n = p.Length;\n        bool[,] dp = new bool[m + 1, n + 1];\n        dp[0, 0] = true;\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == '*') {\n                dp[0, j] = dp[0, j - 2];\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '.' || p[j - 1] == s[i - 1]) {\n                    dp[i, j] = dp[i - 1, j - 1];\n                } else if (p[j - 1] == '*') {\n                    dp[i, j] = dp[i, j - 2] || (dp[i - 1, j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                }\n            }\n        }\n        return dp[m, n];\n    }\n}\n"
                    },
                    {
                        "username": "samgleb4i",
                        "content": "why testcase s=\"aa\" , p=\"a\" output: true, expected: false\\nwhen i run in visual studio it return \"false\""
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "In Visual Studio (or other production regex library) regex matches any substring of the string. In the test task regex must match whole string."
                    },
                    {
                        "username": "aanushka023",
                        "content": "s=\"mississippi\"\np=\"mis * is * p*.\"\n\nwhy is the output false? Can someone explain?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "the third \"i\" is missing"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "For understanding the DP solution well watch this video which helps me to solve it\\nhttps://www.youtube.com/watch?v=l3hda49XcDE"
                    },
                    {
                        "username": "Syed-Mohammad-Yousaf",
                        "content": "s = \"aabbcc\"\\np=\"k*.*b*t*.\"\\nWhy is the expected value true?\\nThe \\'.*\\' at the 2nd index (starting from 0th index) should consume the whole string, and the \\'.\\' at the end of p should necessarily need a character to match. No?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "In this case \".*\" should consume the whole string without the last \"c\", which is matched by the last \".\""
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "Input: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nis this mean that  .  matches with \"ab\" then it becomes ab*  \\nand  *  means zero or more occurrence of preceding character  so we don\\'t take occurrence of \"b\"?"
                    },
                    {
                        "username": "sumit23",
                        "content": "I tried building DFA for the pattern , it's passing 314/354 test cases but seems to have problem with very trial cases. \n ```\ndef isMatch(self, s: str, p: str) -> bool:\n        def nfa(p):\n            N = sum(1 for c in p if c.isalpha() or c == \".\")\n            Q = [{}]\n            i = j = 0\n            while j < len(p):\n                if j + 1 < len(p) and p[j + 1] == \"*\":\n                    Q[i][p[j]] = i\n                    j = j + 2\n                else:\n                    Q[i][p[j]] = i + 1\n                    i += 1\n                    Q.append({})\n                    j += 1\n            return Q, i\n\n        tran_func, F = nfa(p)\n        i = 0\n        for c in s:\n            if c in tran_func[i]:\n                i = tran_func[i][c]\n            elif \".\" in tran_func[i]:\n                i = tran_func[i][\".\"]\n            else:\n                return False\n        return i == F\n```\n\nCan someone help ?\n\nTC- O(n+m)\nSC- O(m)\nn- input string length \nm - pattern string length "
                    },
                    {
                        "username": "code_try_pk",
                        "content": "Why is expected answer for s = \"abcde\" and p = \".\\\\*c\\\\*e\" true? (actually for any string formed with any characters between c and e like \"abcdxfe\" etc. Does zero occurrences (of previous character) mean any other character can be present as well? If that\\'s so, what\\'s the difference between \".\\\\*\" and \"letter\\\\*\"? "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@code_try_pk](/code_try_pk) In your case `.*` can act as `abcd`, `c*` can be removed, then we can get `abcde` so it returns `true`"
                    },
                    {
                        "username": "nikunj2312",
                        "content": "[@mnty4](/mnty4) I am not agree. Here \"c*\" means ZERO or more occurrence but the main has \\'c\\' so it has importance of c*. "
                    },
                    {
                        "username": "mnty4",
                        "content": "remember that * means 0 or more, in this case .* matches abcd, c* matches nothing, then e matches itself which is valid."
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "How s=\"ab\" p=\".*\" is True but s=\"ab\" p=\".*c\" is False ?  "
                    },
                    {
                        "username": "mobileben",
                        "content": "For the failing case, s must end in a \\'c\\'. The pattern reads \"zero or any character ending in c\". So for example, s=\"ac\" or s=\"abc\" would be True"
                    },
                    {
                        "username": "jchirag57",
                        "content": "can someone explain  \\n\\ns= aab\\np = c*a*b\\nmy output: false\\nexpected : true \\n"
                    },
                    {
                        "username": "mobileben",
                        "content": "This is false. If you enter it as a test case, it will indeed indicate the expected value is false."
                    }
                ]
            },
            {
                "id": 1750452,
                "content": [
                    {
                        "username": "pulkitgoel28",
                        "content": "The implementation uses a 2D Boolean array, dp[i, j] represents whether the substring of the input string s up to index i matches the substring of the pattern string p up to index j.\nIt checks every sub-string of the input string and matches them with the pattern.\n\nNote that in C# arrays are 0-based, so when you want to access to i-th element you need to use i-1 index.\n\nThe time and space complexity of this solution also the same as previous one O(m*n). \n\nclass Solution {\n    public bool IsMatch(string s, string p) {\n        int m = s.Length, n = p.Length;\n        bool[,] dp = new bool[m + 1, n + 1];\n        dp[0, 0] = true;\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == '*') {\n                dp[0, j] = dp[0, j - 2];\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '.' || p[j - 1] == s[i - 1]) {\n                    dp[i, j] = dp[i - 1, j - 1];\n                } else if (p[j - 1] == '*') {\n                    dp[i, j] = dp[i, j - 2] || (dp[i - 1, j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                }\n            }\n        }\n        return dp[m, n];\n    }\n}\n"
                    },
                    {
                        "username": "samgleb4i",
                        "content": "why testcase s=\"aa\" , p=\"a\" output: true, expected: false\\nwhen i run in visual studio it return \"false\""
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "In Visual Studio (or other production regex library) regex matches any substring of the string. In the test task regex must match whole string."
                    },
                    {
                        "username": "aanushka023",
                        "content": "s=\"mississippi\"\np=\"mis * is * p*.\"\n\nwhy is the output false? Can someone explain?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "the third \"i\" is missing"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "For understanding the DP solution well watch this video which helps me to solve it\\nhttps://www.youtube.com/watch?v=l3hda49XcDE"
                    },
                    {
                        "username": "Syed-Mohammad-Yousaf",
                        "content": "s = \"aabbcc\"\\np=\"k*.*b*t*.\"\\nWhy is the expected value true?\\nThe \\'.*\\' at the 2nd index (starting from 0th index) should consume the whole string, and the \\'.\\' at the end of p should necessarily need a character to match. No?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "In this case \".*\" should consume the whole string without the last \"c\", which is matched by the last \".\""
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "Input: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nis this mean that  .  matches with \"ab\" then it becomes ab*  \\nand  *  means zero or more occurrence of preceding character  so we don\\'t take occurrence of \"b\"?"
                    },
                    {
                        "username": "sumit23",
                        "content": "I tried building DFA for the pattern , it's passing 314/354 test cases but seems to have problem with very trial cases. \n ```\ndef isMatch(self, s: str, p: str) -> bool:\n        def nfa(p):\n            N = sum(1 for c in p if c.isalpha() or c == \".\")\n            Q = [{}]\n            i = j = 0\n            while j < len(p):\n                if j + 1 < len(p) and p[j + 1] == \"*\":\n                    Q[i][p[j]] = i\n                    j = j + 2\n                else:\n                    Q[i][p[j]] = i + 1\n                    i += 1\n                    Q.append({})\n                    j += 1\n            return Q, i\n\n        tran_func, F = nfa(p)\n        i = 0\n        for c in s:\n            if c in tran_func[i]:\n                i = tran_func[i][c]\n            elif \".\" in tran_func[i]:\n                i = tran_func[i][\".\"]\n            else:\n                return False\n        return i == F\n```\n\nCan someone help ?\n\nTC- O(n+m)\nSC- O(m)\nn- input string length \nm - pattern string length "
                    },
                    {
                        "username": "code_try_pk",
                        "content": "Why is expected answer for s = \"abcde\" and p = \".\\\\*c\\\\*e\" true? (actually for any string formed with any characters between c and e like \"abcdxfe\" etc. Does zero occurrences (of previous character) mean any other character can be present as well? If that\\'s so, what\\'s the difference between \".\\\\*\" and \"letter\\\\*\"? "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@code_try_pk](/code_try_pk) In your case `.*` can act as `abcd`, `c*` can be removed, then we can get `abcde` so it returns `true`"
                    },
                    {
                        "username": "nikunj2312",
                        "content": "[@mnty4](/mnty4) I am not agree. Here \"c*\" means ZERO or more occurrence but the main has \\'c\\' so it has importance of c*. "
                    },
                    {
                        "username": "mnty4",
                        "content": "remember that * means 0 or more, in this case .* matches abcd, c* matches nothing, then e matches itself which is valid."
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "How s=\"ab\" p=\".*\" is True but s=\"ab\" p=\".*c\" is False ?  "
                    },
                    {
                        "username": "mobileben",
                        "content": "For the failing case, s must end in a \\'c\\'. The pattern reads \"zero or any character ending in c\". So for example, s=\"ac\" or s=\"abc\" would be True"
                    },
                    {
                        "username": "jchirag57",
                        "content": "can someone explain  \\n\\ns= aab\\np = c*a*b\\nmy output: false\\nexpected : true \\n"
                    },
                    {
                        "username": "mobileben",
                        "content": "This is false. If you enter it as a test case, it will indeed indicate the expected value is false."
                    }
                ]
            },
            {
                "id": 1739396,
                "content": [
                    {
                        "username": "pulkitgoel28",
                        "content": "The implementation uses a 2D Boolean array, dp[i, j] represents whether the substring of the input string s up to index i matches the substring of the pattern string p up to index j.\nIt checks every sub-string of the input string and matches them with the pattern.\n\nNote that in C# arrays are 0-based, so when you want to access to i-th element you need to use i-1 index.\n\nThe time and space complexity of this solution also the same as previous one O(m*n). \n\nclass Solution {\n    public bool IsMatch(string s, string p) {\n        int m = s.Length, n = p.Length;\n        bool[,] dp = new bool[m + 1, n + 1];\n        dp[0, 0] = true;\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == '*') {\n                dp[0, j] = dp[0, j - 2];\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '.' || p[j - 1] == s[i - 1]) {\n                    dp[i, j] = dp[i - 1, j - 1];\n                } else if (p[j - 1] == '*') {\n                    dp[i, j] = dp[i, j - 2] || (dp[i - 1, j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                }\n            }\n        }\n        return dp[m, n];\n    }\n}\n"
                    },
                    {
                        "username": "samgleb4i",
                        "content": "why testcase s=\"aa\" , p=\"a\" output: true, expected: false\\nwhen i run in visual studio it return \"false\""
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "In Visual Studio (or other production regex library) regex matches any substring of the string. In the test task regex must match whole string."
                    },
                    {
                        "username": "aanushka023",
                        "content": "s=\"mississippi\"\np=\"mis * is * p*.\"\n\nwhy is the output false? Can someone explain?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "the third \"i\" is missing"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "For understanding the DP solution well watch this video which helps me to solve it\\nhttps://www.youtube.com/watch?v=l3hda49XcDE"
                    },
                    {
                        "username": "Syed-Mohammad-Yousaf",
                        "content": "s = \"aabbcc\"\\np=\"k*.*b*t*.\"\\nWhy is the expected value true?\\nThe \\'.*\\' at the 2nd index (starting from 0th index) should consume the whole string, and the \\'.\\' at the end of p should necessarily need a character to match. No?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "In this case \".*\" should consume the whole string without the last \"c\", which is matched by the last \".\""
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "Input: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nis this mean that  .  matches with \"ab\" then it becomes ab*  \\nand  *  means zero or more occurrence of preceding character  so we don\\'t take occurrence of \"b\"?"
                    },
                    {
                        "username": "sumit23",
                        "content": "I tried building DFA for the pattern , it's passing 314/354 test cases but seems to have problem with very trial cases. \n ```\ndef isMatch(self, s: str, p: str) -> bool:\n        def nfa(p):\n            N = sum(1 for c in p if c.isalpha() or c == \".\")\n            Q = [{}]\n            i = j = 0\n            while j < len(p):\n                if j + 1 < len(p) and p[j + 1] == \"*\":\n                    Q[i][p[j]] = i\n                    j = j + 2\n                else:\n                    Q[i][p[j]] = i + 1\n                    i += 1\n                    Q.append({})\n                    j += 1\n            return Q, i\n\n        tran_func, F = nfa(p)\n        i = 0\n        for c in s:\n            if c in tran_func[i]:\n                i = tran_func[i][c]\n            elif \".\" in tran_func[i]:\n                i = tran_func[i][\".\"]\n            else:\n                return False\n        return i == F\n```\n\nCan someone help ?\n\nTC- O(n+m)\nSC- O(m)\nn- input string length \nm - pattern string length "
                    },
                    {
                        "username": "code_try_pk",
                        "content": "Why is expected answer for s = \"abcde\" and p = \".\\\\*c\\\\*e\" true? (actually for any string formed with any characters between c and e like \"abcdxfe\" etc. Does zero occurrences (of previous character) mean any other character can be present as well? If that\\'s so, what\\'s the difference between \".\\\\*\" and \"letter\\\\*\"? "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@code_try_pk](/code_try_pk) In your case `.*` can act as `abcd`, `c*` can be removed, then we can get `abcde` so it returns `true`"
                    },
                    {
                        "username": "nikunj2312",
                        "content": "[@mnty4](/mnty4) I am not agree. Here \"c*\" means ZERO or more occurrence but the main has \\'c\\' so it has importance of c*. "
                    },
                    {
                        "username": "mnty4",
                        "content": "remember that * means 0 or more, in this case .* matches abcd, c* matches nothing, then e matches itself which is valid."
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "How s=\"ab\" p=\".*\" is True but s=\"ab\" p=\".*c\" is False ?  "
                    },
                    {
                        "username": "mobileben",
                        "content": "For the failing case, s must end in a \\'c\\'. The pattern reads \"zero or any character ending in c\". So for example, s=\"ac\" or s=\"abc\" would be True"
                    },
                    {
                        "username": "jchirag57",
                        "content": "can someone explain  \\n\\ns= aab\\np = c*a*b\\nmy output: false\\nexpected : true \\n"
                    },
                    {
                        "username": "mobileben",
                        "content": "This is false. If you enter it as a test case, it will indeed indicate the expected value is false."
                    }
                ]
            },
            {
                "id": 1724839,
                "content": [
                    {
                        "username": "pulkitgoel28",
                        "content": "The implementation uses a 2D Boolean array, dp[i, j] represents whether the substring of the input string s up to index i matches the substring of the pattern string p up to index j.\nIt checks every sub-string of the input string and matches them with the pattern.\n\nNote that in C# arrays are 0-based, so when you want to access to i-th element you need to use i-1 index.\n\nThe time and space complexity of this solution also the same as previous one O(m*n). \n\nclass Solution {\n    public bool IsMatch(string s, string p) {\n        int m = s.Length, n = p.Length;\n        bool[,] dp = new bool[m + 1, n + 1];\n        dp[0, 0] = true;\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == '*') {\n                dp[0, j] = dp[0, j - 2];\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '.' || p[j - 1] == s[i - 1]) {\n                    dp[i, j] = dp[i - 1, j - 1];\n                } else if (p[j - 1] == '*') {\n                    dp[i, j] = dp[i, j - 2] || (dp[i - 1, j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                }\n            }\n        }\n        return dp[m, n];\n    }\n}\n"
                    },
                    {
                        "username": "samgleb4i",
                        "content": "why testcase s=\"aa\" , p=\"a\" output: true, expected: false\\nwhen i run in visual studio it return \"false\""
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "In Visual Studio (or other production regex library) regex matches any substring of the string. In the test task regex must match whole string."
                    },
                    {
                        "username": "aanushka023",
                        "content": "s=\"mississippi\"\np=\"mis * is * p*.\"\n\nwhy is the output false? Can someone explain?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "the third \"i\" is missing"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "For understanding the DP solution well watch this video which helps me to solve it\\nhttps://www.youtube.com/watch?v=l3hda49XcDE"
                    },
                    {
                        "username": "Syed-Mohammad-Yousaf",
                        "content": "s = \"aabbcc\"\\np=\"k*.*b*t*.\"\\nWhy is the expected value true?\\nThe \\'.*\\' at the 2nd index (starting from 0th index) should consume the whole string, and the \\'.\\' at the end of p should necessarily need a character to match. No?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "In this case \".*\" should consume the whole string without the last \"c\", which is matched by the last \".\""
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "Input: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nis this mean that  .  matches with \"ab\" then it becomes ab*  \\nand  *  means zero or more occurrence of preceding character  so we don\\'t take occurrence of \"b\"?"
                    },
                    {
                        "username": "sumit23",
                        "content": "I tried building DFA for the pattern , it's passing 314/354 test cases but seems to have problem with very trial cases. \n ```\ndef isMatch(self, s: str, p: str) -> bool:\n        def nfa(p):\n            N = sum(1 for c in p if c.isalpha() or c == \".\")\n            Q = [{}]\n            i = j = 0\n            while j < len(p):\n                if j + 1 < len(p) and p[j + 1] == \"*\":\n                    Q[i][p[j]] = i\n                    j = j + 2\n                else:\n                    Q[i][p[j]] = i + 1\n                    i += 1\n                    Q.append({})\n                    j += 1\n            return Q, i\n\n        tran_func, F = nfa(p)\n        i = 0\n        for c in s:\n            if c in tran_func[i]:\n                i = tran_func[i][c]\n            elif \".\" in tran_func[i]:\n                i = tran_func[i][\".\"]\n            else:\n                return False\n        return i == F\n```\n\nCan someone help ?\n\nTC- O(n+m)\nSC- O(m)\nn- input string length \nm - pattern string length "
                    },
                    {
                        "username": "code_try_pk",
                        "content": "Why is expected answer for s = \"abcde\" and p = \".\\\\*c\\\\*e\" true? (actually for any string formed with any characters between c and e like \"abcdxfe\" etc. Does zero occurrences (of previous character) mean any other character can be present as well? If that\\'s so, what\\'s the difference between \".\\\\*\" and \"letter\\\\*\"? "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@code_try_pk](/code_try_pk) In your case `.*` can act as `abcd`, `c*` can be removed, then we can get `abcde` so it returns `true`"
                    },
                    {
                        "username": "nikunj2312",
                        "content": "[@mnty4](/mnty4) I am not agree. Here \"c*\" means ZERO or more occurrence but the main has \\'c\\' so it has importance of c*. "
                    },
                    {
                        "username": "mnty4",
                        "content": "remember that * means 0 or more, in this case .* matches abcd, c* matches nothing, then e matches itself which is valid."
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "How s=\"ab\" p=\".*\" is True but s=\"ab\" p=\".*c\" is False ?  "
                    },
                    {
                        "username": "mobileben",
                        "content": "For the failing case, s must end in a \\'c\\'. The pattern reads \"zero or any character ending in c\". So for example, s=\"ac\" or s=\"abc\" would be True"
                    },
                    {
                        "username": "jchirag57",
                        "content": "can someone explain  \\n\\ns= aab\\np = c*a*b\\nmy output: false\\nexpected : true \\n"
                    },
                    {
                        "username": "mobileben",
                        "content": "This is false. If you enter it as a test case, it will indeed indicate the expected value is false."
                    }
                ]
            },
            {
                "id": 1720774,
                "content": [
                    {
                        "username": "pulkitgoel28",
                        "content": "The implementation uses a 2D Boolean array, dp[i, j] represents whether the substring of the input string s up to index i matches the substring of the pattern string p up to index j.\nIt checks every sub-string of the input string and matches them with the pattern.\n\nNote that in C# arrays are 0-based, so when you want to access to i-th element you need to use i-1 index.\n\nThe time and space complexity of this solution also the same as previous one O(m*n). \n\nclass Solution {\n    public bool IsMatch(string s, string p) {\n        int m = s.Length, n = p.Length;\n        bool[,] dp = new bool[m + 1, n + 1];\n        dp[0, 0] = true;\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == '*') {\n                dp[0, j] = dp[0, j - 2];\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '.' || p[j - 1] == s[i - 1]) {\n                    dp[i, j] = dp[i - 1, j - 1];\n                } else if (p[j - 1] == '*') {\n                    dp[i, j] = dp[i, j - 2] || (dp[i - 1, j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                }\n            }\n        }\n        return dp[m, n];\n    }\n}\n"
                    },
                    {
                        "username": "samgleb4i",
                        "content": "why testcase s=\"aa\" , p=\"a\" output: true, expected: false\\nwhen i run in visual studio it return \"false\""
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "In Visual Studio (or other production regex library) regex matches any substring of the string. In the test task regex must match whole string."
                    },
                    {
                        "username": "aanushka023",
                        "content": "s=\"mississippi\"\np=\"mis * is * p*.\"\n\nwhy is the output false? Can someone explain?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "the third \"i\" is missing"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "For understanding the DP solution well watch this video which helps me to solve it\\nhttps://www.youtube.com/watch?v=l3hda49XcDE"
                    },
                    {
                        "username": "Syed-Mohammad-Yousaf",
                        "content": "s = \"aabbcc\"\\np=\"k*.*b*t*.\"\\nWhy is the expected value true?\\nThe \\'.*\\' at the 2nd index (starting from 0th index) should consume the whole string, and the \\'.\\' at the end of p should necessarily need a character to match. No?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "In this case \".*\" should consume the whole string without the last \"c\", which is matched by the last \".\""
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "Input: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nis this mean that  .  matches with \"ab\" then it becomes ab*  \\nand  *  means zero or more occurrence of preceding character  so we don\\'t take occurrence of \"b\"?"
                    },
                    {
                        "username": "sumit23",
                        "content": "I tried building DFA for the pattern , it's passing 314/354 test cases but seems to have problem with very trial cases. \n ```\ndef isMatch(self, s: str, p: str) -> bool:\n        def nfa(p):\n            N = sum(1 for c in p if c.isalpha() or c == \".\")\n            Q = [{}]\n            i = j = 0\n            while j < len(p):\n                if j + 1 < len(p) and p[j + 1] == \"*\":\n                    Q[i][p[j]] = i\n                    j = j + 2\n                else:\n                    Q[i][p[j]] = i + 1\n                    i += 1\n                    Q.append({})\n                    j += 1\n            return Q, i\n\n        tran_func, F = nfa(p)\n        i = 0\n        for c in s:\n            if c in tran_func[i]:\n                i = tran_func[i][c]\n            elif \".\" in tran_func[i]:\n                i = tran_func[i][\".\"]\n            else:\n                return False\n        return i == F\n```\n\nCan someone help ?\n\nTC- O(n+m)\nSC- O(m)\nn- input string length \nm - pattern string length "
                    },
                    {
                        "username": "code_try_pk",
                        "content": "Why is expected answer for s = \"abcde\" and p = \".\\\\*c\\\\*e\" true? (actually for any string formed with any characters between c and e like \"abcdxfe\" etc. Does zero occurrences (of previous character) mean any other character can be present as well? If that\\'s so, what\\'s the difference between \".\\\\*\" and \"letter\\\\*\"? "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@code_try_pk](/code_try_pk) In your case `.*` can act as `abcd`, `c*` can be removed, then we can get `abcde` so it returns `true`"
                    },
                    {
                        "username": "nikunj2312",
                        "content": "[@mnty4](/mnty4) I am not agree. Here \"c*\" means ZERO or more occurrence but the main has \\'c\\' so it has importance of c*. "
                    },
                    {
                        "username": "mnty4",
                        "content": "remember that * means 0 or more, in this case .* matches abcd, c* matches nothing, then e matches itself which is valid."
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "How s=\"ab\" p=\".*\" is True but s=\"ab\" p=\".*c\" is False ?  "
                    },
                    {
                        "username": "mobileben",
                        "content": "For the failing case, s must end in a \\'c\\'. The pattern reads \"zero or any character ending in c\". So for example, s=\"ac\" or s=\"abc\" would be True"
                    },
                    {
                        "username": "jchirag57",
                        "content": "can someone explain  \\n\\ns= aab\\np = c*a*b\\nmy output: false\\nexpected : true \\n"
                    },
                    {
                        "username": "mobileben",
                        "content": "This is false. If you enter it as a test case, it will indeed indicate the expected value is false."
                    }
                ]
            },
            {
                "id": 1719761,
                "content": [
                    {
                        "username": "pulkitgoel28",
                        "content": "The implementation uses a 2D Boolean array, dp[i, j] represents whether the substring of the input string s up to index i matches the substring of the pattern string p up to index j.\nIt checks every sub-string of the input string and matches them with the pattern.\n\nNote that in C# arrays are 0-based, so when you want to access to i-th element you need to use i-1 index.\n\nThe time and space complexity of this solution also the same as previous one O(m*n). \n\nclass Solution {\n    public bool IsMatch(string s, string p) {\n        int m = s.Length, n = p.Length;\n        bool[,] dp = new bool[m + 1, n + 1];\n        dp[0, 0] = true;\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == '*') {\n                dp[0, j] = dp[0, j - 2];\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '.' || p[j - 1] == s[i - 1]) {\n                    dp[i, j] = dp[i - 1, j - 1];\n                } else if (p[j - 1] == '*') {\n                    dp[i, j] = dp[i, j - 2] || (dp[i - 1, j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                }\n            }\n        }\n        return dp[m, n];\n    }\n}\n"
                    },
                    {
                        "username": "samgleb4i",
                        "content": "why testcase s=\"aa\" , p=\"a\" output: true, expected: false\\nwhen i run in visual studio it return \"false\""
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "In Visual Studio (or other production regex library) regex matches any substring of the string. In the test task regex must match whole string."
                    },
                    {
                        "username": "aanushka023",
                        "content": "s=\"mississippi\"\np=\"mis * is * p*.\"\n\nwhy is the output false? Can someone explain?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "the third \"i\" is missing"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "For understanding the DP solution well watch this video which helps me to solve it\\nhttps://www.youtube.com/watch?v=l3hda49XcDE"
                    },
                    {
                        "username": "Syed-Mohammad-Yousaf",
                        "content": "s = \"aabbcc\"\\np=\"k*.*b*t*.\"\\nWhy is the expected value true?\\nThe \\'.*\\' at the 2nd index (starting from 0th index) should consume the whole string, and the \\'.\\' at the end of p should necessarily need a character to match. No?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "In this case \".*\" should consume the whole string without the last \"c\", which is matched by the last \".\""
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "Input: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nis this mean that  .  matches with \"ab\" then it becomes ab*  \\nand  *  means zero or more occurrence of preceding character  so we don\\'t take occurrence of \"b\"?"
                    },
                    {
                        "username": "sumit23",
                        "content": "I tried building DFA for the pattern , it's passing 314/354 test cases but seems to have problem with very trial cases. \n ```\ndef isMatch(self, s: str, p: str) -> bool:\n        def nfa(p):\n            N = sum(1 for c in p if c.isalpha() or c == \".\")\n            Q = [{}]\n            i = j = 0\n            while j < len(p):\n                if j + 1 < len(p) and p[j + 1] == \"*\":\n                    Q[i][p[j]] = i\n                    j = j + 2\n                else:\n                    Q[i][p[j]] = i + 1\n                    i += 1\n                    Q.append({})\n                    j += 1\n            return Q, i\n\n        tran_func, F = nfa(p)\n        i = 0\n        for c in s:\n            if c in tran_func[i]:\n                i = tran_func[i][c]\n            elif \".\" in tran_func[i]:\n                i = tran_func[i][\".\"]\n            else:\n                return False\n        return i == F\n```\n\nCan someone help ?\n\nTC- O(n+m)\nSC- O(m)\nn- input string length \nm - pattern string length "
                    },
                    {
                        "username": "code_try_pk",
                        "content": "Why is expected answer for s = \"abcde\" and p = \".\\\\*c\\\\*e\" true? (actually for any string formed with any characters between c and e like \"abcdxfe\" etc. Does zero occurrences (of previous character) mean any other character can be present as well? If that\\'s so, what\\'s the difference between \".\\\\*\" and \"letter\\\\*\"? "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@code_try_pk](/code_try_pk) In your case `.*` can act as `abcd`, `c*` can be removed, then we can get `abcde` so it returns `true`"
                    },
                    {
                        "username": "nikunj2312",
                        "content": "[@mnty4](/mnty4) I am not agree. Here \"c*\" means ZERO or more occurrence but the main has \\'c\\' so it has importance of c*. "
                    },
                    {
                        "username": "mnty4",
                        "content": "remember that * means 0 or more, in this case .* matches abcd, c* matches nothing, then e matches itself which is valid."
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "How s=\"ab\" p=\".*\" is True but s=\"ab\" p=\".*c\" is False ?  "
                    },
                    {
                        "username": "mobileben",
                        "content": "For the failing case, s must end in a \\'c\\'. The pattern reads \"zero or any character ending in c\". So for example, s=\"ac\" or s=\"abc\" would be True"
                    },
                    {
                        "username": "jchirag57",
                        "content": "can someone explain  \\n\\ns= aab\\np = c*a*b\\nmy output: false\\nexpected : true \\n"
                    },
                    {
                        "username": "mobileben",
                        "content": "This is false. If you enter it as a test case, it will indeed indicate the expected value is false."
                    }
                ]
            },
            {
                "id": 1717238,
                "content": [
                    {
                        "username": "pulkitgoel28",
                        "content": "The implementation uses a 2D Boolean array, dp[i, j] represents whether the substring of the input string s up to index i matches the substring of the pattern string p up to index j.\nIt checks every sub-string of the input string and matches them with the pattern.\n\nNote that in C# arrays are 0-based, so when you want to access to i-th element you need to use i-1 index.\n\nThe time and space complexity of this solution also the same as previous one O(m*n). \n\nclass Solution {\n    public bool IsMatch(string s, string p) {\n        int m = s.Length, n = p.Length;\n        bool[,] dp = new bool[m + 1, n + 1];\n        dp[0, 0] = true;\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == '*') {\n                dp[0, j] = dp[0, j - 2];\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '.' || p[j - 1] == s[i - 1]) {\n                    dp[i, j] = dp[i - 1, j - 1];\n                } else if (p[j - 1] == '*') {\n                    dp[i, j] = dp[i, j - 2] || (dp[i - 1, j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                }\n            }\n        }\n        return dp[m, n];\n    }\n}\n"
                    },
                    {
                        "username": "samgleb4i",
                        "content": "why testcase s=\"aa\" , p=\"a\" output: true, expected: false\\nwhen i run in visual studio it return \"false\""
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "In Visual Studio (or other production regex library) regex matches any substring of the string. In the test task regex must match whole string."
                    },
                    {
                        "username": "aanushka023",
                        "content": "s=\"mississippi\"\np=\"mis * is * p*.\"\n\nwhy is the output false? Can someone explain?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "the third \"i\" is missing"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "For understanding the DP solution well watch this video which helps me to solve it\\nhttps://www.youtube.com/watch?v=l3hda49XcDE"
                    },
                    {
                        "username": "Syed-Mohammad-Yousaf",
                        "content": "s = \"aabbcc\"\\np=\"k*.*b*t*.\"\\nWhy is the expected value true?\\nThe \\'.*\\' at the 2nd index (starting from 0th index) should consume the whole string, and the \\'.\\' at the end of p should necessarily need a character to match. No?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "In this case \".*\" should consume the whole string without the last \"c\", which is matched by the last \".\""
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "Input: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nis this mean that  .  matches with \"ab\" then it becomes ab*  \\nand  *  means zero or more occurrence of preceding character  so we don\\'t take occurrence of \"b\"?"
                    },
                    {
                        "username": "sumit23",
                        "content": "I tried building DFA for the pattern , it's passing 314/354 test cases but seems to have problem with very trial cases. \n ```\ndef isMatch(self, s: str, p: str) -> bool:\n        def nfa(p):\n            N = sum(1 for c in p if c.isalpha() or c == \".\")\n            Q = [{}]\n            i = j = 0\n            while j < len(p):\n                if j + 1 < len(p) and p[j + 1] == \"*\":\n                    Q[i][p[j]] = i\n                    j = j + 2\n                else:\n                    Q[i][p[j]] = i + 1\n                    i += 1\n                    Q.append({})\n                    j += 1\n            return Q, i\n\n        tran_func, F = nfa(p)\n        i = 0\n        for c in s:\n            if c in tran_func[i]:\n                i = tran_func[i][c]\n            elif \".\" in tran_func[i]:\n                i = tran_func[i][\".\"]\n            else:\n                return False\n        return i == F\n```\n\nCan someone help ?\n\nTC- O(n+m)\nSC- O(m)\nn- input string length \nm - pattern string length "
                    },
                    {
                        "username": "code_try_pk",
                        "content": "Why is expected answer for s = \"abcde\" and p = \".\\\\*c\\\\*e\" true? (actually for any string formed with any characters between c and e like \"abcdxfe\" etc. Does zero occurrences (of previous character) mean any other character can be present as well? If that\\'s so, what\\'s the difference between \".\\\\*\" and \"letter\\\\*\"? "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@code_try_pk](/code_try_pk) In your case `.*` can act as `abcd`, `c*` can be removed, then we can get `abcde` so it returns `true`"
                    },
                    {
                        "username": "nikunj2312",
                        "content": "[@mnty4](/mnty4) I am not agree. Here \"c*\" means ZERO or more occurrence but the main has \\'c\\' so it has importance of c*. "
                    },
                    {
                        "username": "mnty4",
                        "content": "remember that * means 0 or more, in this case .* matches abcd, c* matches nothing, then e matches itself which is valid."
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "How s=\"ab\" p=\".*\" is True but s=\"ab\" p=\".*c\" is False ?  "
                    },
                    {
                        "username": "mobileben",
                        "content": "For the failing case, s must end in a \\'c\\'. The pattern reads \"zero or any character ending in c\". So for example, s=\"ac\" or s=\"abc\" would be True"
                    },
                    {
                        "username": "jchirag57",
                        "content": "can someone explain  \\n\\ns= aab\\np = c*a*b\\nmy output: false\\nexpected : true \\n"
                    },
                    {
                        "username": "mobileben",
                        "content": "This is false. If you enter it as a test case, it will indeed indicate the expected value is false."
                    }
                ]
            },
            {
                "id": 1716485,
                "content": [
                    {
                        "username": "pulkitgoel28",
                        "content": "The implementation uses a 2D Boolean array, dp[i, j] represents whether the substring of the input string s up to index i matches the substring of the pattern string p up to index j.\nIt checks every sub-string of the input string and matches them with the pattern.\n\nNote that in C# arrays are 0-based, so when you want to access to i-th element you need to use i-1 index.\n\nThe time and space complexity of this solution also the same as previous one O(m*n). \n\nclass Solution {\n    public bool IsMatch(string s, string p) {\n        int m = s.Length, n = p.Length;\n        bool[,] dp = new bool[m + 1, n + 1];\n        dp[0, 0] = true;\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == '*') {\n                dp[0, j] = dp[0, j - 2];\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '.' || p[j - 1] == s[i - 1]) {\n                    dp[i, j] = dp[i - 1, j - 1];\n                } else if (p[j - 1] == '*') {\n                    dp[i, j] = dp[i, j - 2] || (dp[i - 1, j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                }\n            }\n        }\n        return dp[m, n];\n    }\n}\n"
                    },
                    {
                        "username": "samgleb4i",
                        "content": "why testcase s=\"aa\" , p=\"a\" output: true, expected: false\\nwhen i run in visual studio it return \"false\""
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "In Visual Studio (or other production regex library) regex matches any substring of the string. In the test task regex must match whole string."
                    },
                    {
                        "username": "aanushka023",
                        "content": "s=\"mississippi\"\np=\"mis * is * p*.\"\n\nwhy is the output false? Can someone explain?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "the third \"i\" is missing"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "For understanding the DP solution well watch this video which helps me to solve it\\nhttps://www.youtube.com/watch?v=l3hda49XcDE"
                    },
                    {
                        "username": "Syed-Mohammad-Yousaf",
                        "content": "s = \"aabbcc\"\\np=\"k*.*b*t*.\"\\nWhy is the expected value true?\\nThe \\'.*\\' at the 2nd index (starting from 0th index) should consume the whole string, and the \\'.\\' at the end of p should necessarily need a character to match. No?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "In this case \".*\" should consume the whole string without the last \"c\", which is matched by the last \".\""
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "Input: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nis this mean that  .  matches with \"ab\" then it becomes ab*  \\nand  *  means zero or more occurrence of preceding character  so we don\\'t take occurrence of \"b\"?"
                    },
                    {
                        "username": "sumit23",
                        "content": "I tried building DFA for the pattern , it's passing 314/354 test cases but seems to have problem with very trial cases. \n ```\ndef isMatch(self, s: str, p: str) -> bool:\n        def nfa(p):\n            N = sum(1 for c in p if c.isalpha() or c == \".\")\n            Q = [{}]\n            i = j = 0\n            while j < len(p):\n                if j + 1 < len(p) and p[j + 1] == \"*\":\n                    Q[i][p[j]] = i\n                    j = j + 2\n                else:\n                    Q[i][p[j]] = i + 1\n                    i += 1\n                    Q.append({})\n                    j += 1\n            return Q, i\n\n        tran_func, F = nfa(p)\n        i = 0\n        for c in s:\n            if c in tran_func[i]:\n                i = tran_func[i][c]\n            elif \".\" in tran_func[i]:\n                i = tran_func[i][\".\"]\n            else:\n                return False\n        return i == F\n```\n\nCan someone help ?\n\nTC- O(n+m)\nSC- O(m)\nn- input string length \nm - pattern string length "
                    },
                    {
                        "username": "code_try_pk",
                        "content": "Why is expected answer for s = \"abcde\" and p = \".\\\\*c\\\\*e\" true? (actually for any string formed with any characters between c and e like \"abcdxfe\" etc. Does zero occurrences (of previous character) mean any other character can be present as well? If that\\'s so, what\\'s the difference between \".\\\\*\" and \"letter\\\\*\"? "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@code_try_pk](/code_try_pk) In your case `.*` can act as `abcd`, `c*` can be removed, then we can get `abcde` so it returns `true`"
                    },
                    {
                        "username": "nikunj2312",
                        "content": "[@mnty4](/mnty4) I am not agree. Here \"c*\" means ZERO or more occurrence but the main has \\'c\\' so it has importance of c*. "
                    },
                    {
                        "username": "mnty4",
                        "content": "remember that * means 0 or more, in this case .* matches abcd, c* matches nothing, then e matches itself which is valid."
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "How s=\"ab\" p=\".*\" is True but s=\"ab\" p=\".*c\" is False ?  "
                    },
                    {
                        "username": "mobileben",
                        "content": "For the failing case, s must end in a \\'c\\'. The pattern reads \"zero or any character ending in c\". So for example, s=\"ac\" or s=\"abc\" would be True"
                    },
                    {
                        "username": "jchirag57",
                        "content": "can someone explain  \\n\\ns= aab\\np = c*a*b\\nmy output: false\\nexpected : true \\n"
                    },
                    {
                        "username": "mobileben",
                        "content": "This is false. If you enter it as a test case, it will indeed indicate the expected value is false."
                    }
                ]
            },
            {
                "id": 1707425,
                "content": [
                    {
                        "username": "pulkitgoel28",
                        "content": "The implementation uses a 2D Boolean array, dp[i, j] represents whether the substring of the input string s up to index i matches the substring of the pattern string p up to index j.\nIt checks every sub-string of the input string and matches them with the pattern.\n\nNote that in C# arrays are 0-based, so when you want to access to i-th element you need to use i-1 index.\n\nThe time and space complexity of this solution also the same as previous one O(m*n). \n\nclass Solution {\n    public bool IsMatch(string s, string p) {\n        int m = s.Length, n = p.Length;\n        bool[,] dp = new bool[m + 1, n + 1];\n        dp[0, 0] = true;\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == '*') {\n                dp[0, j] = dp[0, j - 2];\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '.' || p[j - 1] == s[i - 1]) {\n                    dp[i, j] = dp[i - 1, j - 1];\n                } else if (p[j - 1] == '*') {\n                    dp[i, j] = dp[i, j - 2] || (dp[i - 1, j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                }\n            }\n        }\n        return dp[m, n];\n    }\n}\n"
                    },
                    {
                        "username": "samgleb4i",
                        "content": "why testcase s=\"aa\" , p=\"a\" output: true, expected: false\\nwhen i run in visual studio it return \"false\""
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "In Visual Studio (or other production regex library) regex matches any substring of the string. In the test task regex must match whole string."
                    },
                    {
                        "username": "aanushka023",
                        "content": "s=\"mississippi\"\np=\"mis * is * p*.\"\n\nwhy is the output false? Can someone explain?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "the third \"i\" is missing"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "For understanding the DP solution well watch this video which helps me to solve it\\nhttps://www.youtube.com/watch?v=l3hda49XcDE"
                    },
                    {
                        "username": "Syed-Mohammad-Yousaf",
                        "content": "s = \"aabbcc\"\\np=\"k*.*b*t*.\"\\nWhy is the expected value true?\\nThe \\'.*\\' at the 2nd index (starting from 0th index) should consume the whole string, and the \\'.\\' at the end of p should necessarily need a character to match. No?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "In this case \".*\" should consume the whole string without the last \"c\", which is matched by the last \".\""
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "Input: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nis this mean that  .  matches with \"ab\" then it becomes ab*  \\nand  *  means zero or more occurrence of preceding character  so we don\\'t take occurrence of \"b\"?"
                    },
                    {
                        "username": "sumit23",
                        "content": "I tried building DFA for the pattern , it's passing 314/354 test cases but seems to have problem with very trial cases. \n ```\ndef isMatch(self, s: str, p: str) -> bool:\n        def nfa(p):\n            N = sum(1 for c in p if c.isalpha() or c == \".\")\n            Q = [{}]\n            i = j = 0\n            while j < len(p):\n                if j + 1 < len(p) and p[j + 1] == \"*\":\n                    Q[i][p[j]] = i\n                    j = j + 2\n                else:\n                    Q[i][p[j]] = i + 1\n                    i += 1\n                    Q.append({})\n                    j += 1\n            return Q, i\n\n        tran_func, F = nfa(p)\n        i = 0\n        for c in s:\n            if c in tran_func[i]:\n                i = tran_func[i][c]\n            elif \".\" in tran_func[i]:\n                i = tran_func[i][\".\"]\n            else:\n                return False\n        return i == F\n```\n\nCan someone help ?\n\nTC- O(n+m)\nSC- O(m)\nn- input string length \nm - pattern string length "
                    },
                    {
                        "username": "code_try_pk",
                        "content": "Why is expected answer for s = \"abcde\" and p = \".\\\\*c\\\\*e\" true? (actually for any string formed with any characters between c and e like \"abcdxfe\" etc. Does zero occurrences (of previous character) mean any other character can be present as well? If that\\'s so, what\\'s the difference between \".\\\\*\" and \"letter\\\\*\"? "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@code_try_pk](/code_try_pk) In your case `.*` can act as `abcd`, `c*` can be removed, then we can get `abcde` so it returns `true`"
                    },
                    {
                        "username": "nikunj2312",
                        "content": "[@mnty4](/mnty4) I am not agree. Here \"c*\" means ZERO or more occurrence but the main has \\'c\\' so it has importance of c*. "
                    },
                    {
                        "username": "mnty4",
                        "content": "remember that * means 0 or more, in this case .* matches abcd, c* matches nothing, then e matches itself which is valid."
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "How s=\"ab\" p=\".*\" is True but s=\"ab\" p=\".*c\" is False ?  "
                    },
                    {
                        "username": "mobileben",
                        "content": "For the failing case, s must end in a \\'c\\'. The pattern reads \"zero or any character ending in c\". So for example, s=\"ac\" or s=\"abc\" would be True"
                    },
                    {
                        "username": "jchirag57",
                        "content": "can someone explain  \\n\\ns= aab\\np = c*a*b\\nmy output: false\\nexpected : true \\n"
                    },
                    {
                        "username": "mobileben",
                        "content": "This is false. If you enter it as a test case, it will indeed indicate the expected value is false."
                    }
                ]
            },
            {
                "id": 1706193,
                "content": [
                    {
                        "username": "pulkitgoel28",
                        "content": "The implementation uses a 2D Boolean array, dp[i, j] represents whether the substring of the input string s up to index i matches the substring of the pattern string p up to index j.\nIt checks every sub-string of the input string and matches them with the pattern.\n\nNote that in C# arrays are 0-based, so when you want to access to i-th element you need to use i-1 index.\n\nThe time and space complexity of this solution also the same as previous one O(m*n). \n\nclass Solution {\n    public bool IsMatch(string s, string p) {\n        int m = s.Length, n = p.Length;\n        bool[,] dp = new bool[m + 1, n + 1];\n        dp[0, 0] = true;\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == '*') {\n                dp[0, j] = dp[0, j - 2];\n            }\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p[j - 1] == '.' || p[j - 1] == s[i - 1]) {\n                    dp[i, j] = dp[i - 1, j - 1];\n                } else if (p[j - 1] == '*') {\n                    dp[i, j] = dp[i, j - 2] || (dp[i - 1, j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n                }\n            }\n        }\n        return dp[m, n];\n    }\n}\n"
                    },
                    {
                        "username": "samgleb4i",
                        "content": "why testcase s=\"aa\" , p=\"a\" output: true, expected: false\\nwhen i run in visual studio it return \"false\""
                    },
                    {
                        "username": "serhii_tokariev",
                        "content": "In Visual Studio (or other production regex library) regex matches any substring of the string. In the test task regex must match whole string."
                    },
                    {
                        "username": "aanushka023",
                        "content": "s=\"mississippi\"\np=\"mis * is * p*.\"\n\nwhy is the output false? Can someone explain?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "the third \"i\" is missing"
                    },
                    {
                        "username": "abdelmohaymn",
                        "content": "For understanding the DP solution well watch this video which helps me to solve it\\nhttps://www.youtube.com/watch?v=l3hda49XcDE"
                    },
                    {
                        "username": "Syed-Mohammad-Yousaf",
                        "content": "s = \"aabbcc\"\\np=\"k*.*b*t*.\"\\nWhy is the expected value true?\\nThe \\'.*\\' at the 2nd index (starting from 0th index) should consume the whole string, and the \\'.\\' at the end of p should necessarily need a character to match. No?"
                    },
                    {
                        "username": "5tarfir3",
                        "content": "In this case \".*\" should consume the whole string without the last \"c\", which is matched by the last \".\""
                    },
                    {
                        "username": "ronit-khalate",
                        "content": "Input: s = \"ab\", p = \".*\"\\nOutput: true\\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\\n\\nis this mean that  .  matches with \"ab\" then it becomes ab*  \\nand  *  means zero or more occurrence of preceding character  so we don\\'t take occurrence of \"b\"?"
                    },
                    {
                        "username": "sumit23",
                        "content": "I tried building DFA for the pattern , it's passing 314/354 test cases but seems to have problem with very trial cases. \n ```\ndef isMatch(self, s: str, p: str) -> bool:\n        def nfa(p):\n            N = sum(1 for c in p if c.isalpha() or c == \".\")\n            Q = [{}]\n            i = j = 0\n            while j < len(p):\n                if j + 1 < len(p) and p[j + 1] == \"*\":\n                    Q[i][p[j]] = i\n                    j = j + 2\n                else:\n                    Q[i][p[j]] = i + 1\n                    i += 1\n                    Q.append({})\n                    j += 1\n            return Q, i\n\n        tran_func, F = nfa(p)\n        i = 0\n        for c in s:\n            if c in tran_func[i]:\n                i = tran_func[i][c]\n            elif \".\" in tran_func[i]:\n                i = tran_func[i][\".\"]\n            else:\n                return False\n        return i == F\n```\n\nCan someone help ?\n\nTC- O(n+m)\nSC- O(m)\nn- input string length \nm - pattern string length "
                    },
                    {
                        "username": "code_try_pk",
                        "content": "Why is expected answer for s = \"abcde\" and p = \".\\\\*c\\\\*e\" true? (actually for any string formed with any characters between c and e like \"abcdxfe\" etc. Does zero occurrences (of previous character) mean any other character can be present as well? If that\\'s so, what\\'s the difference between \".\\\\*\" and \"letter\\\\*\"? "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@code_try_pk](/code_try_pk) In your case `.*` can act as `abcd`, `c*` can be removed, then we can get `abcde` so it returns `true`"
                    },
                    {
                        "username": "nikunj2312",
                        "content": "[@mnty4](/mnty4) I am not agree. Here \"c*\" means ZERO or more occurrence but the main has \\'c\\' so it has importance of c*. "
                    },
                    {
                        "username": "mnty4",
                        "content": "remember that * means 0 or more, in this case .* matches abcd, c* matches nothing, then e matches itself which is valid."
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "How s=\"ab\" p=\".*\" is True but s=\"ab\" p=\".*c\" is False ?  "
                    },
                    {
                        "username": "mobileben",
                        "content": "For the failing case, s must end in a \\'c\\'. The pattern reads \"zero or any character ending in c\". So for example, s=\"ac\" or s=\"abc\" would be True"
                    },
                    {
                        "username": "jchirag57",
                        "content": "can someone explain  \\n\\ns= aab\\np = c*a*b\\nmy output: false\\nexpected : true \\n"
                    },
                    {
                        "username": "mobileben",
                        "content": "This is false. If you enter it as a test case, it will indeed indicate the expected value is false."
                    }
                ]
            },
            {
                "id": 1694880,
                "content": [
                    {
                        "username": "lctor870303",
                        "content": "Why this case will be true?\\ns =\"aaa\"\\np = `\"ab*a*c*a\"`\\n\\nMy output steps will be like \\n1. s = aa p = `b*a*c*a`\\n2. s = aa p =`a*c*a`\\n3. s = \\'\\'  p =`c*a`\\n\\n\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@lctor870303](/lctor870303) in your case to form `aaa` from `ab*a*c*a`\n- `b*` and `c*` can be removed -> we got `aa*a`\n- `a*` can occur 1 time so -> we got `aaa`"
                    },
                    {
                        "username": "urunovm",
                        "content": "What should be the output for s=\"aa\" p=\"aaaa*\"?"
                    },
                    {
                        "username": "10gksten",
                        "content": "I can\\'t understand the question. Would anyone mind explaining it with more examples.\\nmy doubt is:\\n* symbolizes for 0 or any preceding character whereas . is for any one character, then how is ab and .* true"
                    },
                    {
                        "username": "l_alex97",
                        "content": "why s=\"mississippi\" with p=\"mis*is*p*.\" should be false?\\n\"s\", \"s\" and \"p\" before *\\nends with . - any simbol\\nwhats  wrong?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "It says to implement pattern matching. However, the return value seems to be boolean. What\\'s that about?\\n\\nWhat is being asked?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Return true if the given string matches the given pattern. False otherwise"
                    },
                    {
                        "username": "tris_dev",
                        "content": "this is not hard at all!!!!"
                    },
                    {
                        "username": "lekh_nith",
                        "content": "return s.matches(p);\\n\\nIt\\'s not an optimal solution."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    }
                ]
            },
            {
                "id": 1688104,
                "content": [
                    {
                        "username": "lctor870303",
                        "content": "Why this case will be true?\\ns =\"aaa\"\\np = `\"ab*a*c*a\"`\\n\\nMy output steps will be like \\n1. s = aa p = `b*a*c*a`\\n2. s = aa p =`a*c*a`\\n3. s = \\'\\'  p =`c*a`\\n\\n\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@lctor870303](/lctor870303) in your case to form `aaa` from `ab*a*c*a`\n- `b*` and `c*` can be removed -> we got `aa*a`\n- `a*` can occur 1 time so -> we got `aaa`"
                    },
                    {
                        "username": "urunovm",
                        "content": "What should be the output for s=\"aa\" p=\"aaaa*\"?"
                    },
                    {
                        "username": "10gksten",
                        "content": "I can\\'t understand the question. Would anyone mind explaining it with more examples.\\nmy doubt is:\\n* symbolizes for 0 or any preceding character whereas . is for any one character, then how is ab and .* true"
                    },
                    {
                        "username": "l_alex97",
                        "content": "why s=\"mississippi\" with p=\"mis*is*p*.\" should be false?\\n\"s\", \"s\" and \"p\" before *\\nends with . - any simbol\\nwhats  wrong?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "It says to implement pattern matching. However, the return value seems to be boolean. What\\'s that about?\\n\\nWhat is being asked?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Return true if the given string matches the given pattern. False otherwise"
                    },
                    {
                        "username": "tris_dev",
                        "content": "this is not hard at all!!!!"
                    },
                    {
                        "username": "lekh_nith",
                        "content": "return s.matches(p);\\n\\nIt\\'s not an optimal solution."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    }
                ]
            },
            {
                "id": 1687299,
                "content": [
                    {
                        "username": "lctor870303",
                        "content": "Why this case will be true?\\ns =\"aaa\"\\np = `\"ab*a*c*a\"`\\n\\nMy output steps will be like \\n1. s = aa p = `b*a*c*a`\\n2. s = aa p =`a*c*a`\\n3. s = \\'\\'  p =`c*a`\\n\\n\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@lctor870303](/lctor870303) in your case to form `aaa` from `ab*a*c*a`\n- `b*` and `c*` can be removed -> we got `aa*a`\n- `a*` can occur 1 time so -> we got `aaa`"
                    },
                    {
                        "username": "urunovm",
                        "content": "What should be the output for s=\"aa\" p=\"aaaa*\"?"
                    },
                    {
                        "username": "10gksten",
                        "content": "I can\\'t understand the question. Would anyone mind explaining it with more examples.\\nmy doubt is:\\n* symbolizes for 0 or any preceding character whereas . is for any one character, then how is ab and .* true"
                    },
                    {
                        "username": "l_alex97",
                        "content": "why s=\"mississippi\" with p=\"mis*is*p*.\" should be false?\\n\"s\", \"s\" and \"p\" before *\\nends with . - any simbol\\nwhats  wrong?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "It says to implement pattern matching. However, the return value seems to be boolean. What\\'s that about?\\n\\nWhat is being asked?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Return true if the given string matches the given pattern. False otherwise"
                    },
                    {
                        "username": "tris_dev",
                        "content": "this is not hard at all!!!!"
                    },
                    {
                        "username": "lekh_nith",
                        "content": "return s.matches(p);\\n\\nIt\\'s not an optimal solution."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    }
                ]
            },
            {
                "id": 1687178,
                "content": [
                    {
                        "username": "lctor870303",
                        "content": "Why this case will be true?\\ns =\"aaa\"\\np = `\"ab*a*c*a\"`\\n\\nMy output steps will be like \\n1. s = aa p = `b*a*c*a`\\n2. s = aa p =`a*c*a`\\n3. s = \\'\\'  p =`c*a`\\n\\n\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@lctor870303](/lctor870303) in your case to form `aaa` from `ab*a*c*a`\n- `b*` and `c*` can be removed -> we got `aa*a`\n- `a*` can occur 1 time so -> we got `aaa`"
                    },
                    {
                        "username": "urunovm",
                        "content": "What should be the output for s=\"aa\" p=\"aaaa*\"?"
                    },
                    {
                        "username": "10gksten",
                        "content": "I can\\'t understand the question. Would anyone mind explaining it with more examples.\\nmy doubt is:\\n* symbolizes for 0 or any preceding character whereas . is for any one character, then how is ab and .* true"
                    },
                    {
                        "username": "l_alex97",
                        "content": "why s=\"mississippi\" with p=\"mis*is*p*.\" should be false?\\n\"s\", \"s\" and \"p\" before *\\nends with . - any simbol\\nwhats  wrong?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "It says to implement pattern matching. However, the return value seems to be boolean. What\\'s that about?\\n\\nWhat is being asked?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Return true if the given string matches the given pattern. False otherwise"
                    },
                    {
                        "username": "tris_dev",
                        "content": "this is not hard at all!!!!"
                    },
                    {
                        "username": "lekh_nith",
                        "content": "return s.matches(p);\\n\\nIt\\'s not an optimal solution."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    }
                ]
            },
            {
                "id": 1671247,
                "content": [
                    {
                        "username": "lctor870303",
                        "content": "Why this case will be true?\\ns =\"aaa\"\\np = `\"ab*a*c*a\"`\\n\\nMy output steps will be like \\n1. s = aa p = `b*a*c*a`\\n2. s = aa p =`a*c*a`\\n3. s = \\'\\'  p =`c*a`\\n\\n\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@lctor870303](/lctor870303) in your case to form `aaa` from `ab*a*c*a`\n- `b*` and `c*` can be removed -> we got `aa*a`\n- `a*` can occur 1 time so -> we got `aaa`"
                    },
                    {
                        "username": "urunovm",
                        "content": "What should be the output for s=\"aa\" p=\"aaaa*\"?"
                    },
                    {
                        "username": "10gksten",
                        "content": "I can\\'t understand the question. Would anyone mind explaining it with more examples.\\nmy doubt is:\\n* symbolizes for 0 or any preceding character whereas . is for any one character, then how is ab and .* true"
                    },
                    {
                        "username": "l_alex97",
                        "content": "why s=\"mississippi\" with p=\"mis*is*p*.\" should be false?\\n\"s\", \"s\" and \"p\" before *\\nends with . - any simbol\\nwhats  wrong?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "It says to implement pattern matching. However, the return value seems to be boolean. What\\'s that about?\\n\\nWhat is being asked?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Return true if the given string matches the given pattern. False otherwise"
                    },
                    {
                        "username": "tris_dev",
                        "content": "this is not hard at all!!!!"
                    },
                    {
                        "username": "lekh_nith",
                        "content": "return s.matches(p);\\n\\nIt\\'s not an optimal solution."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    }
                ]
            },
            {
                "id": 1671240,
                "content": [
                    {
                        "username": "lctor870303",
                        "content": "Why this case will be true?\\ns =\"aaa\"\\np = `\"ab*a*c*a\"`\\n\\nMy output steps will be like \\n1. s = aa p = `b*a*c*a`\\n2. s = aa p =`a*c*a`\\n3. s = \\'\\'  p =`c*a`\\n\\n\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@lctor870303](/lctor870303) in your case to form `aaa` from `ab*a*c*a`\n- `b*` and `c*` can be removed -> we got `aa*a`\n- `a*` can occur 1 time so -> we got `aaa`"
                    },
                    {
                        "username": "urunovm",
                        "content": "What should be the output for s=\"aa\" p=\"aaaa*\"?"
                    },
                    {
                        "username": "10gksten",
                        "content": "I can\\'t understand the question. Would anyone mind explaining it with more examples.\\nmy doubt is:\\n* symbolizes for 0 or any preceding character whereas . is for any one character, then how is ab and .* true"
                    },
                    {
                        "username": "l_alex97",
                        "content": "why s=\"mississippi\" with p=\"mis*is*p*.\" should be false?\\n\"s\", \"s\" and \"p\" before *\\nends with . - any simbol\\nwhats  wrong?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "It says to implement pattern matching. However, the return value seems to be boolean. What\\'s that about?\\n\\nWhat is being asked?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Return true if the given string matches the given pattern. False otherwise"
                    },
                    {
                        "username": "tris_dev",
                        "content": "this is not hard at all!!!!"
                    },
                    {
                        "username": "lekh_nith",
                        "content": "return s.matches(p);\\n\\nIt\\'s not an optimal solution."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    }
                ]
            },
            {
                "id": 1657539,
                "content": [
                    {
                        "username": "lctor870303",
                        "content": "Why this case will be true?\\ns =\"aaa\"\\np = `\"ab*a*c*a\"`\\n\\nMy output steps will be like \\n1. s = aa p = `b*a*c*a`\\n2. s = aa p =`a*c*a`\\n3. s = \\'\\'  p =`c*a`\\n\\n\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@lctor870303](/lctor870303) in your case to form `aaa` from `ab*a*c*a`\n- `b*` and `c*` can be removed -> we got `aa*a`\n- `a*` can occur 1 time so -> we got `aaa`"
                    },
                    {
                        "username": "urunovm",
                        "content": "What should be the output for s=\"aa\" p=\"aaaa*\"?"
                    },
                    {
                        "username": "10gksten",
                        "content": "I can\\'t understand the question. Would anyone mind explaining it with more examples.\\nmy doubt is:\\n* symbolizes for 0 or any preceding character whereas . is for any one character, then how is ab and .* true"
                    },
                    {
                        "username": "l_alex97",
                        "content": "why s=\"mississippi\" with p=\"mis*is*p*.\" should be false?\\n\"s\", \"s\" and \"p\" before *\\nends with . - any simbol\\nwhats  wrong?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "It says to implement pattern matching. However, the return value seems to be boolean. What\\'s that about?\\n\\nWhat is being asked?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Return true if the given string matches the given pattern. False otherwise"
                    },
                    {
                        "username": "tris_dev",
                        "content": "this is not hard at all!!!!"
                    },
                    {
                        "username": "lekh_nith",
                        "content": "return s.matches(p);\\n\\nIt\\'s not an optimal solution."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    }
                ]
            },
            {
                "id": 1644865,
                "content": [
                    {
                        "username": "lctor870303",
                        "content": "Why this case will be true?\\ns =\"aaa\"\\np = `\"ab*a*c*a\"`\\n\\nMy output steps will be like \\n1. s = aa p = `b*a*c*a`\\n2. s = aa p =`a*c*a`\\n3. s = \\'\\'  p =`c*a`\\n\\n\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@lctor870303](/lctor870303) in your case to form `aaa` from `ab*a*c*a`\n- `b*` and `c*` can be removed -> we got `aa*a`\n- `a*` can occur 1 time so -> we got `aaa`"
                    },
                    {
                        "username": "urunovm",
                        "content": "What should be the output for s=\"aa\" p=\"aaaa*\"?"
                    },
                    {
                        "username": "10gksten",
                        "content": "I can\\'t understand the question. Would anyone mind explaining it with more examples.\\nmy doubt is:\\n* symbolizes for 0 or any preceding character whereas . is for any one character, then how is ab and .* true"
                    },
                    {
                        "username": "l_alex97",
                        "content": "why s=\"mississippi\" with p=\"mis*is*p*.\" should be false?\\n\"s\", \"s\" and \"p\" before *\\nends with . - any simbol\\nwhats  wrong?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "It says to implement pattern matching. However, the return value seems to be boolean. What\\'s that about?\\n\\nWhat is being asked?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Return true if the given string matches the given pattern. False otherwise"
                    },
                    {
                        "username": "tris_dev",
                        "content": "this is not hard at all!!!!"
                    },
                    {
                        "username": "lekh_nith",
                        "content": "return s.matches(p);\\n\\nIt\\'s not an optimal solution."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    }
                ]
            },
            {
                "id": 1576502,
                "content": [
                    {
                        "username": "lctor870303",
                        "content": "Why this case will be true?\\ns =\"aaa\"\\np = `\"ab*a*c*a\"`\\n\\nMy output steps will be like \\n1. s = aa p = `b*a*c*a`\\n2. s = aa p =`a*c*a`\\n3. s = \\'\\'  p =`c*a`\\n\\n\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@lctor870303](/lctor870303) in your case to form `aaa` from `ab*a*c*a`\n- `b*` and `c*` can be removed -> we got `aa*a`\n- `a*` can occur 1 time so -> we got `aaa`"
                    },
                    {
                        "username": "urunovm",
                        "content": "What should be the output for s=\"aa\" p=\"aaaa*\"?"
                    },
                    {
                        "username": "10gksten",
                        "content": "I can\\'t understand the question. Would anyone mind explaining it with more examples.\\nmy doubt is:\\n* symbolizes for 0 or any preceding character whereas . is for any one character, then how is ab and .* true"
                    },
                    {
                        "username": "l_alex97",
                        "content": "why s=\"mississippi\" with p=\"mis*is*p*.\" should be false?\\n\"s\", \"s\" and \"p\" before *\\nends with . - any simbol\\nwhats  wrong?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "It says to implement pattern matching. However, the return value seems to be boolean. What\\'s that about?\\n\\nWhat is being asked?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Return true if the given string matches the given pattern. False otherwise"
                    },
                    {
                        "username": "tris_dev",
                        "content": "this is not hard at all!!!!"
                    },
                    {
                        "username": "lekh_nith",
                        "content": "return s.matches(p);\\n\\nIt\\'s not an optimal solution."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    }
                ]
            },
            {
                "id": 1576336,
                "content": [
                    {
                        "username": "lctor870303",
                        "content": "Why this case will be true?\\ns =\"aaa\"\\np = `\"ab*a*c*a\"`\\n\\nMy output steps will be like \\n1. s = aa p = `b*a*c*a`\\n2. s = aa p =`a*c*a`\\n3. s = \\'\\'  p =`c*a`\\n\\n\\nCan someone please help me understand this example?"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "[@lctor870303](/lctor870303) in your case to form `aaa` from `ab*a*c*a`\n- `b*` and `c*` can be removed -> we got `aa*a`\n- `a*` can occur 1 time so -> we got `aaa`"
                    },
                    {
                        "username": "urunovm",
                        "content": "What should be the output for s=\"aa\" p=\"aaaa*\"?"
                    },
                    {
                        "username": "10gksten",
                        "content": "I can\\'t understand the question. Would anyone mind explaining it with more examples.\\nmy doubt is:\\n* symbolizes for 0 or any preceding character whereas . is for any one character, then how is ab and .* true"
                    },
                    {
                        "username": "l_alex97",
                        "content": "why s=\"mississippi\" with p=\"mis*is*p*.\" should be false?\\n\"s\", \"s\" and \"p\" before *\\nends with . - any simbol\\nwhats  wrong?"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-regular-expression-matching-problem-solution.html)"
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "It says to implement pattern matching. However, the return value seems to be boolean. What\\'s that about?\\n\\nWhat is being asked?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Return true if the given string matches the given pattern. False otherwise"
                    },
                    {
                        "username": "tris_dev",
                        "content": "this is not hard at all!!!!"
                    },
                    {
                        "username": "lekh_nith",
                        "content": "return s.matches(p);\\n\\nIt\\'s not an optimal solution."
                    },
                    {
                        "username": "ahtisham225ali",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/regular-expression-matching-leetcode-python-solution/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Balanced Binary Tree",
        "question_content": "<p>Given a binary tree, determine if it is <span data-keyword=\"height-balanced\"><strong>height-balanced</strong></span>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg\" style=\"width: 342px; height: 221px;\" />\n<pre>\n<strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\" style=\"width: 452px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,2,3,3,null,null,4,4]\n<strong>Output:</strong> false\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> true\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 5000]</code>.</li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 35691,
                "title": "the-bottom-up-o-n-solution-would-be-better",
                "content": "This problem is generally believed to have two solutions: the top down approach and the bottom up way.\\n\\n1.The first method checks whether the tree is balanced strictly according to the definition of balanced binary tree: the difference between the heights of the two sub trees are not bigger than 1, and both the left sub tree and right sub tree are also balanced. With the helper function depth(), we could easily write the code; \\n\\n    class solution {\\n    public:\\n        int depth (TreeNode *root) {\\n            if (root == NULL) return 0;\\n            return max (depth(root -> left), depth (root -> right)) + 1;\\n        }\\n    \\n        bool isBalanced (TreeNode *root) {\\n            if (root == NULL) return true;\\n            \\n            int left=depth(root->left);\\n            int right=depth(root->right);\\n            \\n            return abs(left - right) <= 1 && isBalanced(root->left) && isBalanced(root->right);\\n        }\\n    };\\n\\nFor the current node root, calling depth() for its left and right children actually has to access all of its children, thus the complexity is O(N). We do this for each node in the tree, so the overall complexity of isBalanced will be O(N^2). This is a top down approach.\\n\\n2.The second method is based on DFS. Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned.  According to the leftHeight and rightHeight of the two children, the parent node could check if the sub tree\\nis balanced, and decides its return value.\\n\\n    class solution {\\n    public:\\n    int dfsHeight (TreeNode *root) {\\n            if (root == NULL) return 0;\\n            \\n            int leftHeight = dfsHeight (root -> left);\\n            if (leftHeight == -1) return -1;\\n            int rightHeight = dfsHeight (root -> right);\\n            if (rightHeight == -1) return -1;\\n            \\n            if (abs(leftHeight - rightHeight) > 1)  return -1;\\n            return max (leftHeight, rightHeight) + 1;\\n        }\\n        bool isBalanced(TreeNode *root) {\\n            return dfsHeight (root) != -1;\\n        }\\n    };\\n\\nIn this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is O(N), better than the first solution.",
                "solutionTags": [],
                "code": "This problem is generally believed to have two solutions: the top down approach and the bottom up way.\\n\\n1.The first method checks whether the tree is balanced strictly according to the definition of balanced binary tree: the difference between the heights of the two sub trees are not bigger than 1, and both the left sub tree and right sub tree are also balanced. With the helper function depth(), we could easily write the code; \\n\\n    class solution {\\n    public:\\n        int depth (TreeNode *root) {\\n            if (root == NULL) return 0;\\n            return max (depth(root -> left), depth (root -> right)) + 1;\\n        }\\n    \\n        bool isBalanced (TreeNode *root) {\\n            if (root == NULL) return true;\\n            \\n            int left=depth(root->left);\\n            int right=depth(root->right);\\n            \\n            return abs(left - right) <= 1 && isBalanced(root->left) && isBalanced(root->right);\\n        }\\n    };\\n\\nFor the current node root, calling depth() for its left and right children actually has to access all of its children, thus the complexity is O(N). We do this for each node in the tree, so the overall complexity of isBalanced will be O(N^2). This is a top down approach.\\n\\n2.The second method is based on DFS. Instead of calling depth() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node (inclusive) is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned.  According to the leftHeight and rightHeight of the two children, the parent node could check if the sub tree\\nis balanced, and decides its return value.\\n\\n    class solution {\\n    public:\\n    int dfsHeight (TreeNode *root) {\\n            if (root == NULL) return 0;\\n            \\n            int leftHeight = dfsHeight (root -> left);\\n            if (leftHeight == -1) return -1;\\n            int rightHeight = dfsHeight (root -> right);\\n            if (rightHeight == -1) return -1;\\n            \\n            if (abs(leftHeight - rightHeight) > 1)  return -1;\\n            return max (leftHeight, rightHeight) + 1;\\n        }\\n        bool isBalanced(TreeNode *root) {\\n            return dfsHeight (root) != -1;\\n        }\\n    };\\n\\nIn this bottom up approach, each node in the tree only need to be accessed once. Thus the time complexity is O(N), better than the first solution.",
                "codeTag": "Java"
            },
            {
                "id": 35708,
                "title": "very-simple-python-solutions-iterative-and-recursive-both-beat-90",
                "content": "```  \\nclass Solution(object):\\n    def isBalanced(self, root):\\n            \\n        def check(root):\\n            if root is None:\\n                return 0\\n            left  = check(root.left)\\n            right = check(root.right)\\n            if left == -1 or right == -1 or abs(left - right) > 1:\\n                return -1\\n            return 1 + max(left, right)\\n            \\n        return check(root) != -1\\n\\n# 226 / 226 test cases passed.\\n# Status: Accepted\\n# Runtime: 80 ms\\n```\\n\\n\\nIterative, based on postorder traversal:\\n\\n```\\nclass Solution(object):\\n    def isBalanced(self, root):\\n        stack, node, last, depths = [], root, None, {}\\n        while stack or node:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:\\n                node = stack[-1]\\n                if not node.right or last == node.right:\\n                    node = stack.pop()\\n                    left, right  = depths.get(node.left, 0), depths.get(node.right, 0)\\n                    if abs(left - right) > 1: return False\\n                    depths[node] = 1 + max(left, right)\\n                    last = node\\n                    node = None\\n                else:\\n                    node = node.right\\n        return True\\n\\n\\n# 226 / 226 test cases passed.\\n# Status: Accepted\\n# Runtime: 84 ms\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```  \\nclass Solution(object):\\n    def isBalanced(self, root):\\n            \\n        def check(root):\\n            if root is None:\\n                return 0\\n            left  = check(root.left)\\n            right = check(root.right)\\n            if left == -1 or right == -1 or abs(left - right) > 1:\\n                return -1\\n            return 1 + max(left, right)\\n            \\n        return check(root) != -1\\n\\n# 226 / 226 test cases passed.\\n# Status: Accepted\\n# Runtime: 80 ms\\n```\n```\\nclass Solution(object):\\n    def isBalanced(self, root):\\n        stack, node, last, depths = [], root, None, {}\\n        while stack or node:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:\\n                node = stack[-1]\\n                if not node.right or last == node.right:\\n                    node = stack.pop()\\n                    left, right  = depths.get(node.left, 0), depths.get(node.right, 0)\\n                    if abs(left - right) > 1: return False\\n                    depths[node] = 1 + max(left, right)\\n                    last = node\\n                    node = None\\n                else:\\n                    node = node.right\\n        return True\\n\\n\\n# 226 / 226 test cases passed.\\n# Status: Accepted\\n# Runtime: 84 ms\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428871,
                "title": "very-easy-100-fully-explained-c-java-python-javascript-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Balanced Binary Tree.\\nMemory Usage: 41.9 MB, less than 94.34% of Java online submissions for Balanced Binary Tree.\\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        // If the tree is empty, we can say it\\u2019s balanced...\\n        if (root == null)  return true;\\n        // Height Function will return -1, when it\\u2019s an unbalanced tree...\\n\\t\\tif (Height(root) == -1)  return false;\\n\\t\\treturn true;\\n\\t}\\n    // Create a function to return the \\u201Cheight\\u201D of a current subtree using recursion...\\n\\tpublic int Height(TreeNode root) {\\n        // Base case...\\n\\t\\tif (root == null)  return 0;\\n        // Height of left subtree...\\n\\t\\tint leftHeight = Height(root.left);\\n        // Height of height subtree...\\n\\t\\tint rightHight = Height(root.right);\\n        // In case of left subtree or right subtree unbalanced, return -1...\\n\\t\\tif (leftHeight == -1 || rightHight == -1)  return -1;\\n        // If their heights differ by more than \\u20181\\u2019, return -1...\\n        if (Math.abs(leftHeight - rightHight) > 1)  return -1;\\n        // Otherwise, return the height of this subtree as max(leftHeight, rightHight) + 1...\\n\\t\\treturn Math.max(leftHeight, rightHight) + 1;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        // If the tree is empty, we can say it\\u2019s balanced...\\n        if (root == NULL)  return true;\\n        // Height Function will return -1, when it\\u2019s an unbalanced tree...\\n\\t\\tif (Height(root) == -1)  return false;\\n\\t\\treturn true;\\n\\t}\\n    // Create a function to return the \\u201Cheight\\u201D of a current subtree using recursion...\\n\\tint Height(TreeNode* root) {\\n        // Base case...\\n\\t\\tif (root == NULL)  return 0;\\n        // Height of left subtree...\\n\\t\\tint leftHeight = Height(root->left);\\n        // Height of height subtree...\\n\\t\\tint rightHight = Height(root->right);\\n        // In case of left subtree or right subtree unbalanced or their heights differ by more than \\u20181\\u2019, return -1...\\n\\t\\tif (leftHeight == -1 || rightHight == -1 || abs(leftHeight - rightHight) > 1)  return -1;\\n        // Otherwise, return the height of this subtree as max(leftHeight, rightHight) + 1...\\n\\t\\treturn max(leftHeight, rightHight) + 1;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def isBalanced(self, root):\\n        return (self.Height(root) >= 0)\\n    def Height(self, root):\\n        if root is None:  return 0\\n        leftheight, rightheight = self.Height(root.left), self.Height(root.right)\\n        if leftheight < 0 or rightheight < 0 or abs(leftheight - rightheight) > 1:  return -1\\n        return max(leftheight, rightheight) + 1\\n```\\n            \\n# **JavaScript Solution:**\\n```\\nvar isBalanced = function(root) {\\n    // If the tree is empty, we can say it\\u2019s balanced...\\n    if (root == null)  return true;\\n    // Height Function will return -1, when it\\u2019s an unbalanced tree...\\n\\tif (Height(root) == -1)  return false;\\n\\treturn true;\\n}\\n// Create a function to return the \\u201Cheight\\u201D of a current subtree using recursion...\\nvar Height = function(root) {\\n    // Base case...\\n\\tif (root == null)  return 0;\\n    // Height of left subtree...\\n\\tlet leftHeight = Height(root.left);\\n    // Height of height subtree...\\n\\tlet rightHight = Height(root.right);\\n    // In case of left subtree or right subtree unbalanced, return -1...\\n\\tif (leftHeight == -1 || rightHight == -1)  return -1;\\n    // If their heights differ by more than \\u20181\\u2019, return -1...\\n    if (Math.abs(leftHeight - rightHight) > 1)  return -1;\\n    // Otherwise, return the height of this subtree as max(leftHeight, rightHight) + 1...\\n\\treturn Math.max(leftHeight, rightHight) + 1;\\n};\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        return (self.Height(root) >= 0)\\n    def Height(self, root: Optional[TreeNode]) -> bool:\\n        if root is None:  return 0\\n        leftheight, rightheight = self.Height(root.left), self.Height(root.right)\\n        if leftheight < 0 or rightheight < 0 or abs(leftheight - rightheight) > 1:  return -1\\n        return max(leftheight, rightheight) + 1\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        // If the tree is empty, we can say it\\u2019s balanced...\\n        if (root == null)  return true;\\n        // Height Function will return -1, when it\\u2019s an unbalanced tree...\\n\\t\\tif (Height(root) == -1)  return false;\\n\\t\\treturn true;\\n\\t}\\n    // Create a function to return the \\u201Cheight\\u201D of a current subtree using recursion...\\n\\tpublic int Height(TreeNode root) {\\n        // Base case...\\n\\t\\tif (root == null)  return 0;\\n        // Height of left subtree...\\n\\t\\tint leftHeight = Height(root.left);\\n        // Height of height subtree...\\n\\t\\tint rightHight = Height(root.right);\\n        // In case of left subtree or right subtree unbalanced, return -1...\\n\\t\\tif (leftHeight == -1 || rightHight == -1)  return -1;\\n        // If their heights differ by more than \\u20181\\u2019, return -1...\\n        if (Math.abs(leftHeight - rightHight) > 1)  return -1;\\n        // Otherwise, return the height of this subtree as max(leftHeight, rightHight) + 1...\\n\\t\\treturn Math.max(leftHeight, rightHight) + 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        // If the tree is empty, we can say it\\u2019s balanced...\\n        if (root == NULL)  return true;\\n        // Height Function will return -1, when it\\u2019s an unbalanced tree...\\n\\t\\tif (Height(root) == -1)  return false;\\n\\t\\treturn true;\\n\\t}\\n    // Create a function to return the \\u201Cheight\\u201D of a current subtree using recursion...\\n\\tint Height(TreeNode* root) {\\n        // Base case...\\n\\t\\tif (root == NULL)  return 0;\\n        // Height of left subtree...\\n\\t\\tint leftHeight = Height(root->left);\\n        // Height of height subtree...\\n\\t\\tint rightHight = Height(root->right);\\n        // In case of left subtree or right subtree unbalanced or their heights differ by more than \\u20181\\u2019, return -1...\\n\\t\\tif (leftHeight == -1 || rightHight == -1 || abs(leftHeight - rightHight) > 1)  return -1;\\n        // Otherwise, return the height of this subtree as max(leftHeight, rightHight) + 1...\\n\\t\\treturn max(leftHeight, rightHight) + 1;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isBalanced(self, root):\\n        return (self.Height(root) >= 0)\\n    def Height(self, root):\\n        if root is None:  return 0\\n        leftheight, rightheight = self.Height(root.left), self.Height(root.right)\\n        if leftheight < 0 or rightheight < 0 or abs(leftheight - rightheight) > 1:  return -1\\n        return max(leftheight, rightheight) + 1\\n```\n```\\nvar isBalanced = function(root) {\\n    // If the tree is empty, we can say it\\u2019s balanced...\\n    if (root == null)  return true;\\n    // Height Function will return -1, when it\\u2019s an unbalanced tree...\\n\\tif (Height(root) == -1)  return false;\\n\\treturn true;\\n}\\n// Create a function to return the \\u201Cheight\\u201D of a current subtree using recursion...\\nvar Height = function(root) {\\n    // Base case...\\n\\tif (root == null)  return 0;\\n    // Height of left subtree...\\n\\tlet leftHeight = Height(root.left);\\n    // Height of height subtree...\\n\\tlet rightHight = Height(root.right);\\n    // In case of left subtree or right subtree unbalanced, return -1...\\n\\tif (leftHeight == -1 || rightHight == -1)  return -1;\\n    // If their heights differ by more than \\u20181\\u2019, return -1...\\n    if (Math.abs(leftHeight - rightHight) > 1)  return -1;\\n    // Otherwise, return the height of this subtree as max(leftHeight, rightHight) + 1...\\n\\treturn Math.max(leftHeight, rightHight) + 1;\\n};\\n```\n```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        return (self.Height(root) >= 0)\\n    def Height(self, root: Optional[TreeNode]) -> bool:\\n        if root is None:  return 0\\n        leftheight, rightheight = self.Height(root.left), self.Height(root.right)\\n        if leftheight < 0 or rightheight < 0 or abs(leftheight - rightheight) > 1:  return -1\\n        return max(leftheight, rightheight) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35943,
                "title": "java-o-n-solution-based-on-maximum-depth-of-binary-tree",
                "content": "    public class Solution {\\n    private boolean result = true;\\n\\n    public boolean isBalanced(TreeNode root) {\\n        maxDepth(root);\\n        return result;\\n    }\\n\\n    public int maxDepth(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        int l = maxDepth(root.left);\\n        int r = maxDepth(root.right);\\n        if (Math.abs(l - r) > 1)\\n            result = false;\\n        return 1 + Math.max(l, r);\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private boolean result = true;\\n\\n    public boolean isBalanced(TreeNode root) {\\n        maxDepth(root);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 35686,
                "title": "java-solution-based-on-height-check-left-and-right-node-in-every-recursion-to-avoid-further-useless-search",
                "content": "\\n    public boolean isBalanced(TreeNode root) {\\n        if(root==null){\\n            return true;\\n        }\\n        return height(root)!=-1;\\n        \\n    }\\n    public int height(TreeNode node){\\n        if(node==null){\\n            return 0;\\n        }\\n        int lH=height(node.left);\\n        if(lH==-1){\\n            return -1;\\n        }\\n        int rH=height(node.right);\\n        if(rH==-1){\\n            return -1;\\n        }\\n        if(lH-rH<-1 || lH-rH>1){\\n            return -1;\\n        }\\n        return Math.max(lH,rH)+1;\\n    }",
                "solutionTags": [],
                "code": "\\n    public boolean isBalanced(TreeNode root) {\\n        if(root==null){\\n            return true;\\n        }\\n        return height(root)!=-1;\\n        \\n    }\\n    public int height(TreeNode node){\\n        if(node==null){\\n            return 0;\\n        }\\n        int lH=height(node.left);\\n        if(lH==-1){\\n            return -1;\\n        }\\n        int rH=height(node.right);\\n        if(rH==-1){\\n            return -1;\\n        }\\n        if(lH-rH<-1 || lH-rH>1){\\n            return -1;\\n        }\\n        return Math.max(lH,rH)+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 774578,
                "title": "c-bottom-up-solution-o-n-solution",
                "content": "## **Bottom Up Approach**\\n\\n##### Space Complexity: O(N), Time Complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    bool ans;\\n    int checkBalance(TreeNode* root){\\n        if(!root)\\n            return 0;\\n        if(!ans) // if Answer is already False then return it.\\n            return 0;\\n        int leftSubTree = checkBalance(root->left);\\n        int rightSubTree = checkBalance(root->right);\\n        if(abs(leftSubTree-rightSubTree) > 1){\\n            ans = false;\\n        }\\n        return 1 + max(leftSubTree, rightSubTree);\\n    }\\n    bool isBalanced(TreeNode* root){\\n        ans = true;\\n        int temp = checkBalance(root);\\n        return ans;\\n    }\\n};\\n```\\n\\nFeel free to ask any doubts in the **comment** section. I will try to respond **ASAP**.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ans;\\n    int checkBalance(TreeNode* root){\\n        if(!root)\\n            return 0;\\n        if(!ans) // if Answer is already False then return it.\\n            return 0;\\n        int leftSubTree = checkBalance(root->left);\\n        int rightSubTree = checkBalance(root->right);\\n        if(abs(leftSubTree-rightSubTree) > 1){\\n            ans = false;\\n        }\\n        return 1 + max(leftSubTree, rightSubTree);\\n    }\\n    bool isBalanced(TreeNode* root){\\n        ans = true;\\n        int temp = checkBalance(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981648,
                "title": "python-simple-dfs-explained",
                "content": "What we need to do here is just to traverse our tree, using for example dfs and check balance for every node.\\n\\n`dfs(node)` here returns depth of subtree with root in `node`. If it is `None`, depths is equal to `0`. We evaluate depths of left and right subtee and return maximum of them plus one. Also we check balance and if absolute difference is more than `1`, we can mark variable `self.Bal` as False: we can state now that tree is not balanced.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(h)` as any classical dfs have.\\n\\n```\\nclass Solution:\\n    def isBalanced(self, root):\\n        self.Bal = True\\n        \\n        def dfs(node):\\n            if not node: return 0\\n            lft, rgh = dfs(node.left), dfs(node.right)\\n            if abs(lft - rgh) > 1: self.Bal = False\\n            return max(lft, rgh) + 1\\n            \\n        dfs(root)\\n        return self.Bal\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isBalanced(self, root):\\n        self.Bal = True\\n        \\n        def dfs(node):\\n            if not node: return 0\\n            lft, rgh = dfs(node.left), dfs(node.right)\\n            if abs(lft - rgh) > 1: self.Bal = False\\n            return max(lft, rgh) + 1\\n            \\n        dfs(root)\\n        return self.Bal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35886,
                "title": "a-simple-python-recursive-solution-172ms",
                "content": "    # Definition for a binary tree node.\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param {TreeNode} root\\n        # @return {boolean}\\n        def isBalanced(self, root):\\n            if not root:\\n                return True\\n    \\n            return abs(self.getHeight(root.left) - self.getHeight(root.right)) < 2 and self.isBalanced(root.left) and self.isBalanced(root.right)\\n    \\n        def getHeight(self, root):\\n            if not root:\\n                return 0\\n    \\n            return 1 + max(self.getHeight(root.left), self.getHeight(root.right))",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 35947,
                "title": "input-t-1-2-2-3-3-3-3-4-4-4-4-4-4-5-5-expected-ttrue",
                "content": "Hi, \\n\\nHow come this input tree is balanced?\\nInput: \\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\n                1\\n           2           2\\n        3     3     3     3 \\n      4  4   4 4   4 4   # # \\n     5 5 \\n\\nfrom root 1, the depth to 5 is 4 and from 1 to 3 is 2.",
                "solutionTags": [],
                "code": "Hi, \\n\\nHow come this input tree is balanced?\\nInput: \\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\nOutput: \\tfalse\\nExpected: \\ttrue\\n\\n                1\\n           2           2\\n        3     3     3     3 \\n      4  4   4 4   4 4   # # \\n     5 5 \\n\\nfrom root 1, the depth to 5 is 4 and from 1 to 3 is 2.",
                "codeTag": "Unknown"
            },
            {
                "id": 35975,
                "title": "my-c-solution-in-15ms",
                "content": "\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint height(TreeNode *root) {\\n\\t\\t\\t\\tif(root == NULL)return 0;\\n\\t\\t\\t\\treturn max(height(root->left), height(root->right)) + 1;\\n\\t\\t\\t}\\n\\t\\t\\tbool isBalanced(TreeNode* root) {\\n\\t\\t\\t\\tif(root == NULL)return true;\\n\\t\\t\\t\\treturn isBalanced(root->left) && isBalanced(root->right) && abs(height(root->left) - height(root->right)) <= 1;\\n\\t\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint height(TreeNode *root) {\\n\\t\\t\\t\\tif(root == NULL)return 0;\\n\\t\\t\\t\\treturn max(height(root->left), height(root->right)) + 1;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 254230,
                "title": "thinking-process-of-bottom-up-solution",
                "content": "From the recursive perspective, we know that we need to know 2 things: \\n```\\n1. If left/right subtrees is balanced\\n2. The height of left/right subtree\\n```\\nThen I think how can I get both of them? The only way to do it is: **return both of them in the  recursion function** i.e. `{height, isBalanced}`, rather than just return the `height` like the top-down solution. \\nBut the problem is that `balanced` is `boolean` data type and `height` is an `int` data type. We cannot declare an array with different data type in Java(However Python can do it :P). So I use `int`as the replacement of `balanced` boolean data type: `-1` as `false`, `1` as `true`. Thus the result can be stored in the array `int[] cur = new int[2]`.\\n\\n```java\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n\\t    // corner case\\n        if(root == null) return true;\\n        \\n        int[] res = getHeight(root);\\n        return res[1] == 1;\\n    }\\n    \\n    // return [height, balanced]\\n    public int[] getHeight(TreeNode root){\\n        // base case\\n        if(root == null) return new int[]{0, 1};\\n        \\n        int[] cur = new int[2];\\n        \\n        int[] left = getHeight(root.left);\\n        if(left[1] == -1){\\n            cur[1] = -1; // unbalanced, do not care about height anymore\\n            return cur;\\n        }\\n        \\n        int[] right = getHeight(root.right);\\n        if(right[1] == -1){\\n            cur[1] = -1; // unbalanced, do not care about height anymore\\n            return cur;\\n        }\\n        \\n        if(Math.abs(left[0] - right[0]) > 1){\\n            cur[1] = -1; // unbalanced, do not care about height anymore\\n            return cur;\\n        }\\n        \\n\\t\\t// set [height, balanced]\\n        cur[0] = Math.max(left[0], right[0]) + 1; // set height\\n        cur[1] = 1; // set balanced\\n        return cur;\\n    }\\n    \\n}\\n```\\n\\n---\\n**Optimized**\\n`{height, isBalanced}`\\nBut notice that the height of a tree is **always** `>= 0`, and we do not care about the height when the subtree is already confirmed imbalanced. So we can use `-1` to represents `imbalanced`, then we can merge the `int` array of size 2 to just a `int` value to save some space. That\\'s the magic!!!\\n(But to be honest, who cares such little space. O(2) == O(1), the value is that if you are facmilar with this, you can directly use -1 which is easier to write)\\n\\nFinal code:\\n\\n```java\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n\\t    // corner case\\n        if(root == null) return true;\\n        \\n        return getHeight(root) != -1;\\n    }\\n    \\n    // return the height of tree rooted at `root`if balanced, otherwise -1\\n    public int getHeight(TreeNode root){\\n        // base case\\n        if(root == null) return 0;\\n        \\n        int left = getHeight(root.left);\\n        if(left == -1) return -1;\\n\\n        int right = getHeight(root.right);\\n        if(right == -1) return -1;\\n        \\n        if(Math.abs(left - right) > 1) return -1;\\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```\\n\\ntime complexity: `O(n)`\\nspace complexity: `O(height)`",
                "solutionTags": [],
                "code": "```\\n1. If left/right subtrees is balanced\\n2. The height of left/right subtree\\n```\n```java\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n\\t    // corner case\\n        if(root == null) return true;\\n        \\n        int[] res = getHeight(root);\\n        return res[1] == 1;\\n    }\\n    \\n    // return [height, balanced]\\n    public int[] getHeight(TreeNode root){\\n        // base case\\n        if(root == null) return new int[]{0, 1};\\n        \\n        int[] cur = new int[2];\\n        \\n        int[] left = getHeight(root.left);\\n        if(left[1] == -1){\\n            cur[1] = -1; // unbalanced, do not care about height anymore\\n            return cur;\\n        }\\n        \\n        int[] right = getHeight(root.right);\\n        if(right[1] == -1){\\n            cur[1] = -1; // unbalanced, do not care about height anymore\\n            return cur;\\n        }\\n        \\n        if(Math.abs(left[0] - right[0]) > 1){\\n            cur[1] = -1; // unbalanced, do not care about height anymore\\n            return cur;\\n        }\\n        \\n\\t\\t// set [height, balanced]\\n        cur[0] = Math.max(left[0], right[0]) + 1; // set height\\n        cur[1] = 1; // set balanced\\n        return cur;\\n    }\\n    \\n}\\n```\n```java\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n\\t    // corner case\\n        if(root == null) return true;\\n        \\n        return getHeight(root) != -1;\\n    }\\n    \\n    // return the height of tree rooted at `root`if balanced, otherwise -1\\n    public int getHeight(TreeNode root){\\n        // base case\\n        if(root == null) return 0;\\n        \\n        int left = getHeight(root.left);\\n        if(left == -1) return -1;\\n\\n        int right = getHeight(root.right);\\n        if(right == -1) return -1;\\n        \\n        if(Math.abs(left - right) > 1) return -1;\\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35694,
                "title": "accepted-o-n-solution",
                "content": "We determine recursively the height of the root node but when the recursion is coming upwards we return UNBALANCED instead of the actual height if we know that the tree is already known to be unbalanced. \\n\\nWe visit each node just once thus it has linear time complexity.\\n\\n\\n    private static final int UNBALANCED = -99;\\n    \\n    public boolean isBalanced(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n        return getHeight(root) != UNBALANCED;\\n    }\\n    \\n    private int getHeight(TreeNode root) {\\n        if (root == null) {\\n            return -1;\\n        }\\n        int l = getHeight(root.left);\\n        int r = getHeight(root.right);\\n        if (l == UNBALANCED || r == UNBALANCED || Math.abs(l-r) > 1) {\\n            return UNBALANCED;\\n        }\\n        return 1 + Math.max(l,r);\\n    }",
                "solutionTags": [],
                "code": "We determine recursively the height of the root node but when the recursion is coming upwards we return UNBALANCED instead of the actual height if we know that the tree is already known to be unbalanced. \\n\\nWe visit each node just once thus it has linear time complexity.\\n\\n\\n    private static final int UNBALANCED = -99;\\n    \\n    public boolean isBalanced(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n        return getHeight(root) != UNBALANCED;\\n    }\\n    \\n    private int getHeight(TreeNode root) {\\n        if (root == null) {\\n            return -1;\\n        }\\n        int l = getHeight(root.left);\\n        int r = getHeight(root.right);\\n        if (l == UNBALANCED || r == UNBALANCED || Math.abs(l-r) > 1) {\\n            return UNBALANCED;\\n        }\\n        return 1 + Math.max(l,r);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 504898,
                "title": "javascript-solution",
                "content": "### The idea - DFS O(N) \\n1. Postorder DFS to find the height of every node\\n2. If any subtree is not balanced, encrypt the information as `Infinity`\\n```\\nvar isBalanced = function(root) {\\n    \\n    let dfs = function(node) {\\n        if (!node) return 0;\\n        let left = 1 + dfs(node.left);\\n        let right = 1 + dfs(node.right);\\n        if (Math.abs(left - right) > 1) return Infinity;\\n        return Math.max(left, right);\\n    }\\n    \\n    return dfs(root)==Infinity?false:true;\\n};\\n```\\n\\n### The idea - DFS O(N^2)\\n1. Standard Top-Down recursion\\n``` javascript\\nvar isBalanced = function(root) {\\n    if (!root) return true;\\n    \\n    let height = function(node) {\\n        if (!node) return 0;\\n        return 1 + Math.max(height(node.left), height(node.right));\\n    }\\n    \\n    return Math.abs(height(root.left) - height(root.right)) < 2 && isBalanced(root.left) && isBalanced(root.right);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isBalanced = function(root) {\\n    \\n    let dfs = function(node) {\\n        if (!node) return 0;\\n        let left = 1 + dfs(node.left);\\n        let right = 1 + dfs(node.right);\\n        if (Math.abs(left - right) > 1) return Infinity;\\n        return Math.max(left, right);\\n    }\\n    \\n    return dfs(root)==Infinity?false:true;\\n};\\n```\n``` javascript\\nvar isBalanced = function(root) {\\n    if (!root) return true;\\n    \\n    let height = function(node) {\\n        if (!node) return 0;\\n        return 1 + Math.max(height(node.left), height(node.right));\\n    }\\n    \\n    return Math.abs(height(root.left) - height(root.right)) < 2 && isBalanced(root.left) && isBalanced(root.right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36008,
                "title": "a-iterative-postorder-traversal-java-solution",
                "content": "A recursive method is straightforward. Doing it iteratively is a lot of fun. I use postorder traversal to realize a iterative version.\\n\\n    public class Solution {\\n        public boolean isBalanced(TreeNode root) {\\n            if(root==null) return true;\\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            Map<TreeNode, Integer> map = new HashMap<TreeNode, Integer>();\\n            stack.push(root);\\n            while(!stack.isEmpty()){\\n                TreeNode node = stack.pop();\\n                if((node.left==null || node.left!=null && map.containsKey(node.left)) &&(node.right==null || node.right!=null && map.containsKey(node.right))){\\n                    int left = node.left==null?0:map.get(node.left);\\n                    int right = node.right==null?0:map.get(node.right);\\n                    if(Math.abs(left-right) > 1) return false;\\n                    map.put(node, Math.max(left, right)+1);\\n                }else{\\n                    if(node.left!=null && !map.containsKey(node.left)){\\n                        stack.push(node);\\n                        stack.push(node.left);\\n                    }else{\\n                        stack.push(node);\\n                        stack.push(node.right);\\n                    }\\n                }\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public boolean isBalanced(TreeNode root) {\\n            if(root==null) return true;\\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            Map<TreeNode, Integer> map = new HashMap<TreeNode, Integer>();\\n            stack.push(root);\\n            while(!stack.isEmpty()){\\n                TreeNode node = stack.pop();\\n                if((node.left==null || node.left!=null && map.containsKey(node.left)) &&(node.right==null || node.right!=null && map.containsKey(node.right))){\\n                    int left = node.left==null?0:map.get(node.left);\\n                    int right = node.right==null?0:map.get(node.right);\\n                    if(Math.abs(left-right) > 1) return false;\\n                    map.put(node, Math.max(left, right)+1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 362017,
                "title": "python3-recursively",
                "content": "```\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\n\\n\\nclass Solution(object):\\n    def isBalanced(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\" \\n        if root == None:\\n            return True\\n        l = self.depth(root.left)\\n        r = self.depth(root.right)\\n        return (abs(l-r) <2) and self.isBalanced(root.left) and self.isBalanced(root.right)\\n    \\n    def depth(self,node):\\n        if node == None: return 0\\n        return max(self.depth(node.left),self.depth(node.right))+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\n\\n\\nclass Solution(object):\\n    def isBalanced(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\" \\n        if root == None:\\n            return True\\n        l = self.depth(root.left)\\n        r = self.depth(root.right)\\n        return (abs(l-r) <2) and self.isBalanced(root.left) and self.isBalanced(root.right)\\n    \\n    def depth(self,node):\\n        if node == None: return 0\\n        return max(self.depth(node.left),self.depth(node.right))+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35863,
                "title": "java-1ms-solution",
                "content": "This is perhaps a bit hacky but, hey, it works!\\n\\n    private int helper(TreeNode root, int height)\\n    {\\n        if (root == null)\\n        {\\n            return height;\\n        }\\n        \\n        int leftTree = helper(root.left, height + 1);\\n        int rightTree = helper(root.right, height + 1);\\n        if (leftTree < 0 || rightTree < 0 || Math.abs(leftTree - rightTree) > 1)\\n        {\\n            return -1;\\n        }\\n        \\n        return Math.max(leftTree, rightTree);\\n    }\\n    \\n    public boolean isBalanced(TreeNode root) {\\n        return helper(root, 0) >= 0;\\n    }\\n\\nI tried to avoid mutual recursion or having two functions that both recurse.  Having two functions that both recurse, one to get the depth of the left and right subtree, and one to continue down the tree if that node checks out, works fine but can recurse an unnecessary number of times if the tree is valid.  This function will always complete in O(nodes) since it just calculates the max depth of each subtree and when the recursion unwinds it checks to see if the restriction on the height has been broken.  If it has, it sets the height to -1 (hacky), indicating that the restrictions has been broken.  Essentially, this just gets around returning two values, one for whether the restriction has been broken and one for the max height of tree.",
                "solutionTags": [],
                "code": "This is perhaps a bit hacky but, hey, it works!\\n\\n    private int helper(TreeNode root, int height)\\n    {\\n        if (root == null)\\n        {\\n            return height;\\n        }\\n        \\n        int leftTree = helper(root.left, height + 1);\\n        int rightTree = helper(root.right, height + 1);\\n        if (leftTree < 0 || rightTree < 0 || Math.abs(leftTree - rightTree) > 1)\\n        {\\n            return -1;\\n        }\\n        \\n        return Math.max(leftTree, rightTree);\\n    }\\n    \\n    public boolean isBalanced(TreeNode root) {\\n        return helper(root, 0) >= 0;\\n    }\\n\\nI tried to avoid mutual recursion or having two functions that both recurse.  Having two functions that both recurse, one to get the depth of the left and right subtree, and one to continue down the tree if that node checks out, works fine but can recurse an unnecessary number of times if the tree is valid.  This function will always complete in O(nodes) since it just calculates the max depth of each subtree and when the recursion unwinds it checks to see if the restriction on the height has been broken.  If it has, it sets the height to -1 (hacky), indicating that the restrictions has been broken.  Essentially, this just gets around returning two values, one for whether the restriction has been broken and one for the max height of tree.",
                "codeTag": "Unknown"
            },
            {
                "id": 437267,
                "title": "java-simpler-and-better-bottom-up-solution-o-n",
                "content": "Since the height of a tree is always greater than or equal to 0,\\nWe use -1 as a flag to indicate if the subtree is not balanced.\\nUse DFS (postorder) to scan the tree to avoid checking the height multiple times.\\n\\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return getHeight(root) != -1;\\n    }\\n    \\n    private int getHeight(TreeNode node) {\\n        if (node == null) return 0;\\n\\n        int left = getHeight(node.left);\\n        int right = getHeight(node.right);\\n\\n        // left, right subtree is unbalanced or cur tree is unbalanced\\n        if (left == -1 || right == -1 || Math.abs(left - right) > 1) return -1;\\n\\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```\\n\\nTime: O(n)\\nWe use DFS to scan the tree one time.\\n\\nSpace: O(n)\\nThe call statck of the recursive getHeight function is equal to the height of the tree. \\nIn the worst case the tree is totally skewed, height of the tree is equal to the number of nodes.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return getHeight(root) != -1;\\n    }\\n    \\n    private int getHeight(TreeNode node) {\\n        if (node == null) return 0;\\n\\n        int left = getHeight(node.left);\\n        int right = getHeight(node.right);\\n\\n        // left, right subtree is unbalanced or cur tree is unbalanced\\n        if (left == -1 || right == -1 || Math.abs(left - right) > 1) return -1;\\n\\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282033,
                "title": "6-lines-code-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(root):\\n            if root==None:\\n                return [True,0]\\n            left,right=dfs(root.left),def(root.right)\\n            balanced=left[0] and right[0] and abs(left[1]-right[1])<=1\\n            return [balanced,1+max(left[1],right[1])]\\n        return dfs(root)[0]\\n    #please upvote me it would encourage me alot\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        def dfs(root):\\n            if root==None:\\n                return [True,0]\\n            left,right=dfs(root.left),def(root.right)\\n            balanced=left[0] and right[0] and abs(left[1]-right[1])<=1\\n            return [balanced,1+max(left[1],right[1])]\\n        return dfs(root)[0]\\n    #please upvote me it would encourage me alot\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 981604,
                "title": "c-very-simple-and-short-recursive-solution-faster-than-95",
                "content": "height = -1 means not balanced.\\nSo if the recursion returns -1 or this node is not balanced - we just return -1.\\nElse - return maximum between heights of left and right, to check further.\\n```\\nclass Solution {\\npublic:\\n    int height(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        int left = height(root->left);\\n        int right = height(root->right);\\n        return (left == -1 || right == -1 || abs(left-right) > 1) ? -1 : max(left, right)+1;\\n    }\\n    \\n    bool isBalanced(TreeNode* root) {\\n        return height(root) != -1;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int height(TreeNode* root) {\\n        if (!root)\\n            return 0;\\n        int left = height(root->left);\\n        int right = height(root->right);\\n        return (left == -1 || right == -1 || abs(left-right) > 1) ? -1 : max(left, right)+1;\\n    }\\n    \\n    bool isBalanced(TreeNode* root) {\\n        return height(root) != -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393036,
                "title": "1-approach-for-your-interview-hindi",
                "content": "```\\nvar isBalanced = function(root) {\\n    \\n    if(!root) return true\\n    \\n    let leftHeight  = height(root.left)            // is waaale node ka, left aur right subtree ka height kya hai\\n    let rightHeight = height(root.right)          \\n    \\n    \\n    \\n    if(Math.abs(rightHeight - leftHeight) <= 1     //  (height <= 1) hua toh koi dikkat nai \\n      && isBalanced(root.left)                     //  LIKEWISE,  LEFT WALO KE LIYE DEKHO\\n      && isBalanced(root.right)                    //  LIKEWISE, RIGHT WALO KE LIYE DEKHO\\n    ) return true\\n    \\n    else return false\\n\\n};\\n\\nfunction height(root){\\n    if(!root) return 0\\n    return Math.max(height(root.left), height(root.right)) + 1\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvar isBalanced = function(root) {\\n    \\n    if(!root) return true\\n    \\n    let leftHeight  = height(root.left)            // is waaale node ka, left aur right subtree ka height kya hai\\n    let rightHeight = height(root.right)          \\n    \\n    \\n    \\n    if(Math.abs(rightHeight - leftHeight) <= 1     //  (height <= 1) hua toh koi dikkat nai \\n      && isBalanced(root.left)                     //  LIKEWISE,  LEFT WALO KE LIYE DEKHO\\n      && isBalanced(root.right)                    //  LIKEWISE, RIGHT WALO KE LIYE DEKHO\\n    ) return true\\n    \\n    else return false\\n\\n};\\n\\nfunction height(root){\\n    if(!root) return 0\\n    return Math.max(height(root.left), height(root.right)) + 1\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2011001,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic class Solution {\\nprivate boolean result = true;\\n\\npublic boolean isBalanced(TreeNode root) {\\n    maxDepth(root);\\n    return result;\\n}\\n\\npublic int maxDepth(TreeNode root) {\\n    if (root == null)\\n        return 0;\\n    int l = maxDepth(root.left);\\n    int r = maxDepth(root.right);\\n    if (Math.abs(l - r) > 1)\\n        result = false;\\n    return 1 + Math.max(l, r);\\n}\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    bool ans;\\n    int checkBalance(TreeNode* root){\\n        if(!root)\\n            return 0;\\n        if(!ans) // if Answer is already False then return it.\\n            return 0;\\n        int leftSubTree = checkBalance(root->left);\\n        int rightSubTree = checkBalance(root->right);\\n        if(abs(leftSubTree-rightSubTree) > 1){\\n            ans = false;\\n        }\\n        return 1 + max(leftSubTree, rightSubTree);\\n    }\\n    bool isBalanced(TreeNode* root){\\n        ans = true;\\n        int temp = checkBalance(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution(object):\\n    def isBalanced(self, root):\\n            \\n        def check(root):\\n            if root is None:\\n                return 0\\n            left  = check(root.left)\\n            right = check(root.right)\\n            if left == -1 or right == -1 or abs(left - right) > 1:\\n                return -1\\n            return 1 + max(left, right)\\n            \\n        return check(root) != -1\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar isBalanced = function(root) {\\n    \\n    let dfs = function(node) {\\n        if (!node) return 0;\\n        let left = 1 + dfs(node.left);\\n        let right = 1 + dfs(node.right);\\n        if (Math.abs(left - right) > 1) return Infinity;\\n        return Math.max(left, right);\\n    }\\n    \\n    return dfs(root)==Infinity?false:true;\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    \\n    fun isBalanced(root: TreeNode?): Boolean {\\n        return checkDepth(root) != -1\\n    }\\n    \\n    private fun checkDepth(root: TreeNode?): Int {\\n        root ?: return 0\\n        val lDepth = checkDepth(root.left)\\n        val rDepth = checkDepth(root.right)\\n        val delta = Math.abs(lDepth - rDepth)\\n        return when {\\n            lDepth == -1 ||\\n            rDepth == -1 ||\\n            Math.abs(lDepth - rDepth) > 1 -> -1\\n            else -> 1 + maxOf(lDepth, rDepth)\\n        }\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(n), where n is the number of nodes in the binary tree.\\n    \\n    func isBalanced(_ root: TreeNode?) -> Bool {\\n        isBalancedTree(root).balanced\\n    }\\n    \\n    \\n    private func isBalancedTree(_ node: TreeNode?) -> (height: Int, balanced: Bool) {\\n        guard let node = node else { return (-1, true) }\\n        \\n        let left = isBalancedTree(node.left)\\n        guard left.balanced else { return(-1, false) }\\n        \\n        let right = isBalancedTree(node.right)\\n        guard right.balanced else { return (-1, false) }\\n        \\n        guard abs(left.height - right.height) < 2 else { return (-1, false) }\\n        \\n        return (max(left.height, right.height) + 1, true)\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic class Solution {\\nprivate boolean result = true;\\n\\npublic boolean isBalanced(TreeNode root) {\\n    maxDepth(root);\\n    return result;\\n}\\n\\npublic int maxDepth(TreeNode root) {\\n    if (root == null)\\n        return 0;\\n    int l = maxDepth(root.left);\\n    int r = maxDepth(root.right);\\n    if (Math.abs(l - r) > 1)\\n        result = false;\\n    return 1 + Math.max(l, r);\\n}\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    bool ans;\\n    int checkBalance(TreeNode* root){\\n        if(!root)\\n            return 0;\\n        if(!ans) // if Answer is already False then return it.\\n            return 0;\\n        int leftSubTree = checkBalance(root->left);\\n        int rightSubTree = checkBalance(root->right);\\n        if(abs(leftSubTree-rightSubTree) > 1){\\n            ans = false;\\n        }\\n        return 1 + max(leftSubTree, rightSubTree);\\n    }\\n    bool isBalanced(TreeNode* root){\\n        ans = true;\\n        int temp = checkBalance(root);\\n        return ans;\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution(object):\\n    def isBalanced(self, root):\\n            \\n        def check(root):\\n            if root is None:\\n                return 0\\n            left  = check(root.left)\\n            right = check(root.right)\\n            if left == -1 or right == -1 or abs(left - right) > 1:\\n                return -1\\n            return 1 + max(left, right)\\n            \\n        return check(root) != -1\\n\\n```\n```\\n```\n```\\n```\n```\\nvar isBalanced = function(root) {\\n    \\n    let dfs = function(node) {\\n        if (!node) return 0;\\n        let left = 1 + dfs(node.left);\\n        let right = 1 + dfs(node.right);\\n        if (Math.abs(left - right) > 1) return Infinity;\\n        return Math.max(left, right);\\n    }\\n    \\n    return dfs(root)==Infinity?false:true;\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    \\n    fun isBalanced(root: TreeNode?): Boolean {\\n        return checkDepth(root) != -1\\n    }\\n    \\n    private fun checkDepth(root: TreeNode?): Int {\\n        root ?: return 0\\n        val lDepth = checkDepth(root.left)\\n        val rDepth = checkDepth(root.right)\\n        val delta = Math.abs(lDepth - rDepth)\\n        return when {\\n            lDepth == -1 ||\\n            rDepth == -1 ||\\n            Math.abs(lDepth - rDepth) > 1 -> -1\\n            else -> 1 + maxOf(lDepth, rDepth)\\n        }\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(n), where n is the number of nodes in the binary tree.\\n    \\n    func isBalanced(_ root: TreeNode?) -> Bool {\\n        isBalancedTree(root).balanced\\n    }\\n    \\n    \\n    private func isBalancedTree(_ node: TreeNode?) -> (height: Int, balanced: Bool) {\\n        guard let node = node else { return (-1, true) }\\n        \\n        let left = isBalancedTree(node.left)\\n        guard left.balanced else { return(-1, false) }\\n        \\n        let right = isBalancedTree(node.right)\\n        guard right.balanced else { return (-1, false) }\\n        \\n        guard abs(left.height - right.height) < 2 else { return (-1, false) }\\n        \\n        return (max(left.height, right.height) + 1, true)\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35988,
                "title": "can-we-have-a-better-solution",
                "content": "My solution for this problem is as follows:\\n\\n    public class Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        if (root == null)\\n            return true;\\n        if (Math.abs(depth(root.left) - depth(root.right)) >1)\\n            return false;\\n        return isBalanced(root.left) && isBalanced(root.right);\\n    }\\n    \\n    private int depth(TreeNode root){\\n        if (root == null)\\n            return 0;\\n        return Math.max(depth(root.left), depth(root.right)) + 1;\\n    }\\n}\\n\\nBut it has two recursions, one for depth() and one for isBalanced(). Will there be a performance issue?",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        if (root == null)\\n            return true;\\n        if (Math.abs(depth(root.left) - depth(root.right)) >1)\\n            return false;\\n        return isBalanced(root.left) && isBalanced(root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 541305,
                "title": "python-6-line-solutoin-beats-98",
                "content": "```python\\ndef isBalanced(self, root: TreeNode, h=1) -> bool:\\n    if not root: return h\\n    l = self.isBalanced(root.left, h+1)\\n    if not l: return\\n    r = self.isBalanced(root.right, h+1)\\n    if not r: return\\n    return abs(l-r) <= 1 and max(l, r)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef isBalanced(self, root: TreeNode, h=1) -> bool:\\n    if not root: return h\\n    l = self.isBalanced(root.left, h+1)\\n    if not l: return\\n    r = self.isBalanced(root.right, h+1)\\n    if not r: return\\n    return abs(l-r) <= 1 and max(l, r)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 128678,
                "title": "python-3-iterative-and-recursive-solution",
                "content": "```\\nclass Solution_iterative_postorder:\\n    def isBalanced(self, root):\\n        stack = [(0, root)]\\n        depth = {None: 0}\\n        while stack:\\n            seen, node = stack.pop()\\n            if node is None:\\n                continue\\n            if not seen:\\n                stack.extend([(1, node), (0, node.right), (0, node.left)])\\n            else:\\n                if abs(depth[node.left] - depth[node.right]) > 1:\\n                    return False\\n                depth[node] = max(depth[node.left], depth[node.right]) + 1\\n        return True\\n\\n\\nclass Solution_recursive_without_extra_variable:\\n    def isBalanced(self, root):\\n        def dfs(root):\\n            if root is None:\\n                return 0\\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            if left == -1 or right == -1 or abs(left - right) > 1:\\n                return -1\\n            return max(left, right) + 1\\n        return dfs(root) != -1\\n\\n\\nclass Solution_recursive_with_switch_variable:\\n    def isBalanced(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        self.switch = True\\n\\n        def dfs(root):\\n            if root is None:\\n                return 0\\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            if abs(left - right) > 1:\\n                self.switch = False\\n            return max(left, right) + 1\\n\\n        dfs(root)\\n        return self.switch\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution_iterative_postorder:\\n    def isBalanced(self, root):\\n        stack = [(0, root)]\\n        depth = {None: 0}\\n        while stack:\\n            seen, node = stack.pop()\\n            if node is None:\\n                continue\\n            if not seen:\\n                stack.extend([(1, node), (0, node.right), (0, node.left)])\\n            else:\\n                if abs(depth[node.left] - depth[node.right]) > 1:\\n                    return False\\n                depth[node] = max(depth[node.left], depth[node.right]) + 1\\n        return True\\n\\n\\nclass Solution_recursive_without_extra_variable:\\n    def isBalanced(self, root):\\n        def dfs(root):\\n            if root is None:\\n                return 0\\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            if left == -1 or right == -1 or abs(left - right) > 1:\\n                return -1\\n            return max(left, right) + 1\\n        return dfs(root) != -1\\n\\n\\nclass Solution_recursive_with_switch_variable:\\n    def isBalanced(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        self.switch = True\\n\\n        def dfs(root):\\n            if root is None:\\n                return 0\\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            if abs(left - right) > 1:\\n                self.switch = False\\n            return max(left, right) + 1\\n\\n        dfs(root)\\n        return self.switch\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746410,
                "title": "c-2-approaches-easy-to-understand",
                "content": "***Runtime: 24 ms, faster than 43.07% of C++ online submissions for Balanced Binary Tree.\\nMemory Usage: 21.5 MB, less than 86.00% of C++ online submissions for Balanced Binary Tree.***\\n```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if(root == nullptr)\\n            return true;\\n        else{\\n            int leftH = height(root->left);\\n            int rightH = height(root->right);\\n            int diff = abs(rightH - leftH);\\n            return diff <= 1 && isBalanced(root->left) && isBalanced(root->right);   \\n        } \\n    }\\n    int height(TreeNode* root){\\n        if(root == nullptr){\\n            return 0;\\n        }else{\\n            return 1 + max(height(root->left), height(root->right));\\n        }\\n    }\\n};\\n```\\n\\n***Runtime: 12 ms, faster than 98.58% of C++ online submissions for Balanced Binary Tree.\\nMemory Usage: 21.9 MB, less than 29.08% of C++ online submissions for Balanced Binary Tree.***\\n```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if(root == nullptr)\\n            return true;\\n        return height(root) != -1;\\n    }\\n    int height(TreeNode* root){\\n        if(root == nullptr){\\n            return 0;\\n        }\\n        int lHeight = height(root->left);\\n        int rHeight = height(root->right);\\n        if(lHeight == -1 || rHeight == -1 || abs(lHeight - rHeight) > 1){\\n            return -1;\\n        }\\n        return 1 + max(lHeight, rHeight);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if(root == nullptr)\\n            return true;\\n        else{\\n            int leftH = height(root->left);\\n            int rightH = height(root->right);\\n            int diff = abs(rightH - leftH);\\n            return diff <= 1 && isBalanced(root->left) && isBalanced(root->right);   \\n        } \\n    }\\n    int height(TreeNode* root){\\n        if(root == nullptr){\\n            return 0;\\n        }else{\\n            return 1 + max(height(root->left), height(root->right));\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if(root == nullptr)\\n            return true;\\n        return height(root) != -1;\\n    }\\n    int height(TreeNode* root){\\n        if(root == nullptr){\\n            return 0;\\n        }\\n        int lHeight = height(root->left);\\n        int rHeight = height(root->right);\\n        if(lHeight == -1 || rHeight == -1 || abs(lHeight - rHeight) > 1){\\n            return -1;\\n        }\\n        return 1 + max(lHeight, rHeight);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341286,
                "title": "js-recursive-solution-with-comments",
                "content": "```\\nvar isBalanced = function(root) {\\n    //handle case when root itself is null\\n\\tif(root === null) return true;\\n\\t//turns to false if unbalanced tree encountered\\n    let flag = true;\\n\\t//recursive function - it recursively returns the height of the tree \\n    function helper(root) {\\n\\t    //base case of recursion - tree with no nodes return height 0\\n        if(root.left === null && root.right === null) {\\n            return 0\\n        }\\n        let leftHeight = 0, rightHeight = 0;\\n        if(root.left !== null) {\\n\\t\\t    //height of left subtree is one plus the height of child sub tree\\n            leftHeight = 1 + helper(root.left);\\n        }\\n        if(root.right !== null) {\\n\\t\\t   //height of right subtree is one plus the height of child sub tree\\n            rightHeight = 1 + helper(root.right);   \\n        }\\n\\t\\t//height of tree is max between height of left and right subtree\\n        let actualHeight = Math.max(leftHeight, rightHeight);\\n\\t\\t//if abs diff between leftHt and right Ht greater than one; turn flag to false\\n        if(Math.abs(leftHeight-rightHeight) > 1) flag = false;\\n        return actualHeight;\\n    }\\n    helper(root);\\n    return flag\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isBalanced = function(root) {\\n    //handle case when root itself is null\\n\\tif(root === null) return true;\\n\\t//turns to false if unbalanced tree encountered\\n    let flag = true;\\n\\t//recursive function - it recursively returns the height of the tree \\n    function helper(root) {\\n\\t    //base case of recursion - tree with no nodes return height 0\\n        if(root.left === null && root.right === null) {\\n            return 0\\n        }\\n        let leftHeight = 0, rightHeight = 0;\\n        if(root.left !== null) {\\n\\t\\t    //height of left subtree is one plus the height of child sub tree\\n            leftHeight = 1 + helper(root.left);\\n        }\\n        if(root.right !== null) {\\n\\t\\t   //height of right subtree is one plus the height of child sub tree\\n            rightHeight = 1 + helper(root.right);   \\n        }\\n\\t\\t//height of tree is max between height of left and right subtree\\n        let actualHeight = Math.max(leftHeight, rightHeight);\\n\\t\\t//if abs diff between leftHt and right Ht greater than one; turn flag to false\\n        if(Math.abs(leftHeight-rightHeight) > 1) flag = false;\\n        return actualHeight;\\n    }\\n    helper(root);\\n    return flag\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2632385,
                "title": "100-accepted-worst-to-best-approaches-with-explanation-easy-to-understand",
                "content": "**Read the below approaches.**\\n\\n***Please upvote if you like it!!*** \\n\\n**Approach 1:** Naive approach (Not Optimised)\\n\\n**Intuition + Approach:**\\n\\n* For a Balanced Binary Tree, Check left subtree height and right subtree height for every node present in the tree. Hence, traverse the tree recursively and calculate the height of left and right subtree from every node, and whenever the condition of Balanced tree violates, simply return false.\\n* Condition for Balanced Binary Tree\\n* **For all Nodes , Absolute( Left Subtree Height \\u2013 Right Subtree Height ) <= 1**\\n\\n**Dry run :**\\n\\n![image](https://assets.leetcode.com/users/images/92d9778c-8347-4ce9-888a-6753a54fc8b3_1664313008.0877197.png)\\n\\n**~Time Complexity: O(N*N)** \\n* **Reason:** ( For every node, Height Function is called which takes O(N) Time. Hence for every node it becomes N*N ) \\n\\n**~Space Complexity: O(1) ( Extra Space ) + O(H)**\\n* **Reason:** ( Recursive Stack Space where \\u201CH\\u201D is the height of tree )\\n```\\n\\n```\\n\\n**Approach 2:** Post Order Traversal ( Most optimised )\\n\\n**Intuition:** Can we optimize the above brute force solution? Which operation do you think can be skipped to optimize the time complexity?\\n\\n* Ain\\u2019t we traversing the subtrees again and again in the above example?\\n* Yes, so can we skip the repeated traversals?\\n* What if we can make use of post-order traversal?\\n* So, the idea is to use post-order traversal. Since, in postorder traversal, we first traverse the left and right subtrees and then visit the parent node, similarly instead of calculating the height of the left subtree and right subtree every time at the root node, use post-order traversal, and keep calculating the heights of the left and right subtrees and perform the validation.\\n\\n**Approach :**\\n\\n* Start traversing the tree recursively and do work in Post Order.\\n* For each call, caculate the height of the root node, and return it to previous calls.  \\n* Simultaneously, in the Post Order of every node , Check for condition of balance as information of left and right subtree height is available.\\n* If it is balanced , simply return height of current node and if not then return -1.\\n* Whenever the subtree result is -1 , simply keep on returning -1.\\n\\n**~Time Complexity: O(N)**\\n**~Space Complexity: O(1) Extra Space + O(H) Recursion Stack space (Where \\u201CH\\u201D  is the height of binary tree)**\\n\\n**Dry run:-**\\n\\n![image](https://assets.leetcode.com/users/images/9e7c39a6-1756-40fa-9166-b75ec40cd46f_1664313277.571836.png)\\n\\n**Paper dry run:-**\\n\\n![image](https://assets.leetcode.com/users/images/cf43e954-8707-4355-923f-667a0fb15c33_1664313955.4142773.jpeg)\\n\\n**C++ Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root){\\n        if(!root) return 0;\\n        int leftHeight=solve(root->left);\\n        if(leftHeight == -1) return -1;\\n        \\n        int rightHeight=solve(root->right);\\n        if(rightHeight==-1) return -1;\\n        \\n        if(!(abs(leftHeight-rightHeight)<=1)) return -1;\\n        return max(leftHeight,rightHeight)+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        return solve(root) !=-1;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root){\\n        if(!root) return 0;\\n        int leftHeight=solve(root->left);\\n        if(leftHeight == -1) return -1;\\n        \\n        int rightHeight=solve(root->right);\\n        if(rightHeight==-1) return -1;\\n        \\n        if(!(abs(leftHeight-rightHeight)<=1)) return -1;\\n        return max(leftHeight,rightHeight)+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        return solve(root) !=-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384502,
                "title": "c-solution",
                "content": "```\\nint max(int a, int b) {\\n    return a >= b ? a : b;\\n}\\n\\nint height(struct TreeNode* root) {\\n    if (root == NULL)\\n        return 0;\\n    else\\n        return 1 + max(height(root->left), height(root->right));\\n}\\n\\nbool isBalanced(struct TreeNode* root){\\n    if (root == NULL)\\n        return 1;\\n    int left = height(root->left);\\n    int right = height(root->right);\\n    return abs(left - right) <= 1 && isBalanced(root->left) && isBalanced(root->right);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint max(int a, int b) {\\n    return a >= b ? a : b;\\n}\\n\\nint height(struct TreeNode* root) {\\n    if (root == NULL)\\n        return 0;\\n    else\\n        return 1 + max(height(root->left), height(root->right));\\n}\\n\\nbool isBalanced(struct TreeNode* root){\\n    if (root == NULL)\\n        return 1;\\n    int left = height(root->left);\\n    int right = height(root->right);\\n    return abs(left - right) <= 1 && isBalanced(root->left) && isBalanced(root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35701,
                "title": "easy-top-down-bottom-up-beat-89-35-solutions-in-java",
                "content": "Top Down Solution, which is O(n^2) time complexity\\n\\n    public boolean isBalanced(TreeNode root) {\\n        if (root == null) return true;\\n        if (root.left == null && root.right == null) return true;\\n        int left = depth(root.left);\\n        int right = depth(root.right);\\n        return Math.abs(left-right) <=1 && isBalanced(root.left) && isBalanced(root.right);\\n    }\\n    public int depth(TreeNode root) {\\n        if (root == null) return 0;\\n        if (root.left == null && root.right == null) return 1;\\n        return Math.max(depth(root.left),depth(root.right))+1;\\n    }\\n\\nBottom Up Solution, which is O(n) time complexity\\n\\n    public boolean isBalanced(TreeNode root) {\\n        if (root == null) return true;\\n        int depth = depth(root);\\n        if (depth == -1) return false;\\n        else return true;\\n    }\\n    private int depth(TreeNode root) {\\n        if (root == null) return 0;\\n        int left = depth(root.left);\\n        int right = depth(root.right);\\n        if (left == -1 || right == -1 || Math.abs(left-right) > 1) return -1;\\n        return Math.max(left,right)+1;\\n    }",
                "solutionTags": [],
                "code": "Top Down Solution, which is O(n^2) time complexity\\n\\n    public boolean isBalanced(TreeNode root) {\\n        if (root == null) return true;\\n        if (root.left == null && root.right == null) return true;\\n        int left = depth(root.left);\\n        int right = depth(root.right);\\n        return Math.abs(left-right) <=1 && isBalanced(root.left) && isBalanced(root.right);\\n    }\\n    public int depth(TreeNode root) {\\n        if (root == null) return 0;\\n        if (root.left == null && root.right == null) return 1;\\n        return Math.max(depth(root.left),depth(root.right))+1;\\n    }\\n\\nBottom Up Solution, which is O(n) time complexity\\n\\n    public boolean isBalanced(TreeNode root) {\\n        if (root == null) return true;\\n        int depth = depth(root);\\n        if (depth == -1) return false;\\n        else return true;\\n    }\\n    private int depth(TreeNode root) {\\n        if (root == null) return 0;\\n        int left = depth(root.left);\\n        int right = depth(root.right);\\n        if (left == -1 || right == -1 || Math.abs(left-right) > 1) return -1;\\n        return Math.max(left,right)+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3093444,
                "title": "java-c-100-solution-using-depth-first-search-balanced-binary-tree",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    boolean ans = true;\\n    public int solve(TreeNode root)\\n    {\\n        if(root == null)\\n            return 0;\\n        int left = solve(root.left);\\n        int right = solve(root.right);\\n        if(Math.abs(left-right)>1)\\n            ans = false;\\n        return Math.max(left,right)+1;\\n    }\\n    public boolean isBalanced(TreeNode root) {\\n        solve(root);\\n        return ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool ans = true;\\n    int solve(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        int left = solve(root->left);\\n        int right = solve(root->right);\\n        if(abs(left-right)>1)\\n            ans = false;\\n        return max(left,right)+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```Java []\\nclass Solution {\\n    boolean ans = true;\\n    public int solve(TreeNode root)\\n    {\\n        if(root == null)\\n            return 0;\\n        int left = solve(root.left);\\n        int right = solve(root.right);\\n        if(Math.abs(left-right)>1)\\n            ans = false;\\n        return Math.max(left,right)+1;\\n    }\\n    public boolean isBalanced(TreeNode root) {\\n        solve(root);\\n        return ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool ans = true;\\n    int solve(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        int left = solve(root->left);\\n        int right = solve(root->right);\\n        if(abs(left-right)>1)\\n            ans = false;\\n        return max(left,right)+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051735,
                "title": "js-simple-explained-post-order",
                "content": "# 110. Balanced Binary Tree \\uD83D\\uDE80\\n\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n## The Question\\nFor this article we will be covering Leetcode\\'s \\'[110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/discuss/2051735/JS-or-Simple-and-Explained-or-Post-Order)\\' question. \\n\\nQuestion:\\n\\n> Given a **binary tree**, determine if it is **height-balanced**.\\n> For this problem, a **height-balanced** binary tree is defined as:\\n>> a binary tree in which the left and right subtrees of every node **differ in height by no more than 1**.\\n\\n\\nExample:\\n\\n>![Example](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)\\n\\n```\\nInput: root = [3,9,20,null,null,15,7]\\nOutput: true\\n```\\n\\n## Explaining The Question\\nThis Question is rated **Easy**. Which is for the most part accurate. I do not believe that this question is easy to solve although. You need to know a handful of techniques and patterns to be able to solve this. \\n\\nThis question is very close to the [**Maximum Depth of Binary Tree**](https://leetcode.com/problems/maximum-depth-of-binary-tree/). Although in this case, we\\'re going to need to keep track of the height of every **subtree** on every **node**, so we can ask the question \\'Does my left or right tree differ in height by 1?\\'.\\n\\nWhat Leetcode has asked us to do is to determine if the tree is **height-balanced**. Which is a **Binary Tree** in which the left and right subtrees of every node differ in height by no more than 1.\\n\\n##  Recommended Knowledge\\n1. [Binary Tree](https://en.wikipedia.org/wiki/Binary_tree)\\n2. [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search)\\n3. [Post Order Traversal](https://en.wikipedia.org/wiki/Tree_traversal#Post-order)\\n4. [**Maximum Depth of Binary Tree**](https://leetcode.com/problems/maximum-depth-of-binary-tree)\\n5. [Recursive Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search)\\n\\n## What do we know?\\n1. We have a ***binary tree*** (Most times, it could be empty)\\n2. We need to find the height of the left and right subtrees of **every node**. \\n\\n## How we\\'re going to do it:\\n\\nWe\\'re going to use [Post Order Traversal](https://en.wikipedia.org/wiki/Tree_traversal#Post-order) to find the height of the left and right subtrees of **every node**. We do this by passing a **height** parameter to the each subtree, counting the number of nodes it takes until it hits the bottom of the tree. Meaning that once it hits the bottom most node, we have found the height of the tree.\\n\\nNow we know the height of the left and right subtrees. All we do now is ask, \\'Does my left or right tree differ in height by 1?\\'. If any of them violate this, we set our flag to false. \\n\\n1. Set ourself a `flag` to true. So by default, we\\'re going to assume that the tree is height-balanced. Until we find a node that violates this, we\\'re going to set our flag to false.\\n2. Perform a post order traversal of the tree. Where we pass a `height` parameter to each node.\\n3. Which gives us the left and right heights of each node. \\n4. We ask the question, \\'Does my left or right tree differ in height by 1?\\'. If any of them violate this, we set our flag to false.\\n\\n## Big O Notation:\\n* Time Complexity:   *O(**n**)* | Where ***n*** is the number of nodes in our ***Binary Tree*** | As we\\'re going to traverse all of the nodes within the tree.\\n  \\n* Space Complexity: *O(**n**)* | Where ***n*** is the number of nodes in our ***Binary Tree*** | As in the worst case, we\\'re going to have to store the entire height of the tree in the call stack. \\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 70 ms, faster than ***95.74%*** of JavaScript online submissions for Balanced Binary Tree\\n* Memory Usage: 47.1 MB, less than ***63.74%*** of JavaScript online submissions for Balanced Binary Tree\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/702266058/)\\n\\n\\n***\\n\\n# The Solution\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n * this.val   = (val===undefined ? 0 : val)\\n * this.left  = (left===undefined ? null : left)\\n * this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isBalanced = function (root) {\\n\\n    // A flag to check if the tree is balanced or not\\n    let flag = true;\\n\\n    // Helper function to check if the tree is balanced or not\\n    const get_heights = (node, height) => {\\n\\n        // Empty tree? It\\'s 0 in height\\n        if (!node) {\\n            return 0;\\n        }\\n\\n        // Get my left and right heights\\n        // by adding 1 to the height of the left and right subtrees.\\n        // each time we move down them\\n        const left_height  = get_heights(node.left, height + 1);\\n        const right_height = get_heights(node.right, height + 1);\\n\\n        // Let\\'s use some math.\\n        // Technically, if we have a balanced tree, the difference\\n        // should always be 0. But because, this question is awkward, we need to check if \\n        // if its diff is greater than 1. So we minus the two by using absolutes values and asking\\n        // if the diff in this sub tree was greater than 1. If so bad un balanced.\\n        if (Math.abs(right_height - left_height) > 1) {\\n            flag = false;\\n        }\\n\\n        // Return the height of the tree\\n        // By returning whoever had the bigger height and adding 1 (Our current node)\\n        return Math.max(left_height, right_height) + 1;\\n    };\\n\\n    // Call the helper function\\n    get_heights(root, 0);\\n\\n    // Get the flag back to base. :D\\n    return flag;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nInput: root = [3,9,20,null,null,15,7]\\nOutput: true\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n * this.val   = (val===undefined ? 0 : val)\\n * this.left  = (left===undefined ? null : left)\\n * this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isBalanced = function (root) {\\n\\n    // A flag to check if the tree is balanced or not\\n    let flag = true;\\n\\n    // Helper function to check if the tree is balanced or not\\n    const get_heights = (node, height) => {\\n\\n        // Empty tree? It\\'s 0 in height\\n        if (!node) {\\n            return 0;\\n        }\\n\\n        // Get my left and right heights\\n        // by adding 1 to the height of the left and right subtrees.\\n        // each time we move down them\\n        const left_height  = get_heights(node.left, height + 1);\\n        const right_height = get_heights(node.right, height + 1);\\n\\n        // Let\\'s use some math.\\n        // Technically, if we have a balanced tree, the difference\\n        // should always be 0. But because, this question is awkward, we need to check if \\n        // if its diff is greater than 1. So we minus the two by using absolutes values and asking\\n        // if the diff in this sub tree was greater than 1. If so bad un balanced.\\n        if (Math.abs(right_height - left_height) > 1) {\\n            flag = false;\\n        }\\n\\n        // Return the height of the tree\\n        // By returning whoever had the bigger height and adding 1 (Our current node)\\n        return Math.max(left_height, right_height) + 1;\\n    };\\n\\n    // Call the helper function\\n    get_heights(root, 0);\\n\\n    // Get the flag back to base. :D\\n    return flag;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1335631,
                "title": "solution-swift-balanced-binary-tree",
                "content": "```swift\\nclass Solution {\\n    func isBalanced(_ root: TreeNode?) -> Bool {\\n        guard let root = root else { return true }\\n        if !isBalanced(root.left) || !isBalanced(root.right) { return false }\\n        return abs(val(root.left) - val(root.right)) <= 1\\n    }\\n    private func val(_ tn: TreeNode?) -> Int {\\n        guard let node = tn else { return -1 }\\n        return 1 + max(val(node.left), val(node.right))\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.032 (0.034) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isBalanced(TreeNode([3,9,20,nil,nil,15,7]))\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    func test1() {\\n        let value = solution.isBalanced(TreeNode([1,2,2,3,3,nil,nil,4,4]))\\n        XCTAssertEqual(value, false)\\n    }\\n    \\n    func test2() {\\n        let value = solution.isBalanced(TreeNode([]))\\n        XCTAssertEqual(value, true)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isBalanced(_ root: TreeNode?) -> Bool {\\n        guard let root = root else { return true }\\n        if !isBalanced(root.left) || !isBalanced(root.right) { return false }\\n        return abs(val(root.left) - val(root.right)) <= 1\\n    }\\n    private func val(_ tn: TreeNode?) -> Int {\\n        guard let node = tn else { return -1 }\\n        return 1 + max(val(node.left), val(node.right))\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.isBalanced(TreeNode([3,9,20,nil,nil,15,7]))\\n        XCTAssertEqual(value, true)\\n    }\\n    \\n    func test1() {\\n        let value = solution.isBalanced(TreeNode([1,2,2,3,3,nil,nil,4,4]))\\n        XCTAssertEqual(value, false)\\n    }\\n    \\n    func test2() {\\n        let value = solution.isBalanced(TreeNode([]))\\n        XCTAssertEqual(value, true)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233053,
                "title": "javascript-dfs",
                "content": "```\\nvar isBalanced = function(tree) {\\n\\tlet isBalanced = true\\n\\tfunction dfs(t){\\n\\t\\tif(!t) return 0\\n\\t\\tconst left = dfs(t.left)\\n\\t\\tconst right = dfs(t.right)\\n\\t\\tif(Math.abs(left-right) > 1){\\n\\t\\t\\tisBalanced = false\\n\\t\\t}\\n\\t\\treturn 1 + Math.max(left, right)\\n\\t}\\n\\tdfs(tree)\\n  return isBalanced;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar isBalanced = function(tree) {\\n\\tlet isBalanced = true\\n\\tfunction dfs(t){\\n\\t\\tif(!t) return 0\\n\\t\\tconst left = dfs(t.left)\\n\\t\\tconst right = dfs(t.right)\\n\\t\\tif(Math.abs(left-right) > 1){\\n\\t\\t\\tisBalanced = false\\n\\t\\t}\\n\\t\\treturn 1 + Math.max(left, right)\\n\\t}\\n\\tdfs(tree)\\n  return isBalanced;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1335754,
                "title": "java-recursive-easy-solution-with-explanation-0ms",
                "content": "```\\nclass Solution \\n{\\n    boolean flag= true;//setting the balanced flag default by true \\n    public boolean isBalanced(TreeNode root) \\n    {\\n        if(root == null)//base case for null graph \\n           return true;\\n        height_bal(root);//calculates the height and the balance factor simultaneously for each subtree \\n        return flag;//returning the flag \\n    }\\n    public int height_bal(TreeNode root)//Height is calculated on the basis of node\\n    {//DFS(postorder)\\n        if(root == null)\\n            return 0;\\n        \\n        int left= height_bal(root.left);//recursively traveling the left subtree\\n        int right= height_bal(root.right);//recursively traveling the right subtree\\n        \\n        int max= Math.max(left, right)+1;//getting the maximum height among left and right subtree and adding 1 for each level of BT\\n    \\n        if(Math.abs(left-right) >1)//balanceing the left and right subtree condition \\n            flag= false;//not balanced flag\\n        \\n        return max;//returning the maximum height for the particular subtree\\n    }\\n}//Do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution \\n{\\n    boolean flag= true;//setting the balanced flag default by true \\n    public boolean isBalanced(TreeNode root) \\n    {\\n        if(root == null)//base case for null graph \\n           return true;\\n        height_bal(root);//calculates the height and the balance factor simultaneously for each subtree \\n        return flag;//returning the flag \\n    }\\n    public int height_bal(TreeNode root)//Height is calculated on the basis of node\\n    {//DFS(postorder)\\n        if(root == null)\\n            return 0;\\n        \\n        int left= height_bal(root.left);//recursively traveling the left subtree\\n        int right= height_bal(root.right);//recursively traveling the right subtree\\n        \\n        int max= Math.max(left, right)+1;//getting the maximum height among left and right subtree and adding 1 for each level of BT\\n    \\n        if(Math.abs(left-right) >1)//balanceing the left and right subtree condition \\n            flag= false;//not balanced flag\\n        \\n        return max;//returning the maximum height for the particular subtree\\n    }\\n}//Do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 981730,
                "title": "easy-python-dfs-solution",
                "content": "```\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        \\n        self.answer = True\\n        \\n        def dfs(root):\\n            l, r = 0, 0\\n\\n            if root.left:\\n                l += dfs(root.left)\\n            if root.right:\\n                r += dfs(root.right)\\n            if abs(r-l) > 1:\\n                self.answer = False\\n                \\n            # print(root.val, r, l)\\n            return max(r,l) + 1\\n        dfs(root)\\n        return self.answer\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n        \\n        self.answer = True\\n        \\n        def dfs(root):\\n            l, r = 0, 0\\n\\n            if root.left:\\n                l += dfs(root.left)\\n            if root.right:\\n                r += dfs(root.right)\\n            if abs(r-l) > 1:\\n                self.answer = False\\n                \\n            # print(root.val, r, l)\\n            return max(r,l) + 1\\n        dfs(root)\\n        return self.answer\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 35734,
                "title": "c-code-with-short-cut",
                "content": "     // We definitely need to calculate the height of each node\\n    // Actually when we calculate the height, we can perform the balance check at the same time\\n    // this help function just did this\\n    class Solution {\\n    private:\\n        bool isBalancedTreeHelper(TreeNode* root,int&depth)\\n        {\\n            if(root==NULL)\\n            {\\n                depth = 0;\\n                return true;\\n            }\\n            int left,right;\\n            // Notice, the logic operation is shortcut\\n            // once the left tree is judged to be unbalanced, then the right tree will not be judged\\n            if(isBalancedTreeHelper(root->left,left) && isBalancedTreeHelper(root->right,right) && abs(left-right)<2){\\n                depth = max(left,right)+1;\\n                return true;\\n            }\\n            return false;\\n        }\\n    public:\\n        bool isBalanced(TreeNode* root) {\\n            int depth;\\n            return isBalancedTreeHelper(root,depth);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        bool isBalancedTreeHelper(TreeNode* root,int&depth)\\n        {\\n            if(root==NULL)\\n            {\\n                depth = 0;\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3352604,
                "title": "100-faster-recursive-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/c8ce517f-5018-4b34-aa5a-bfc27b3dc48c_1680025816.5160778.png)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public boolean isBalanced(TreeNode root) {\\n        // Call the dfsHeight function to get the height of the tree\\n        // If the returned value is -1, the tree is not balanced\\n        // Otherwise, it is balanced\\n        return dfsHeight(root) != -1;\\n    }\\n\\n    public static int dfsHeight(TreeNode root){\\n\\n        // Base case: If the root is null, the height is 0\\n        if(root == null){\\n            return 0;\\n        }\\n    \\n        // Recursively get the height of the left subtree\\n        int leftHeight = dfsHeight(root.left);\\n\\n        // If the left subtree is not balanced, return -1\\n        if(leftHeight == -1){\\n            return -1;\\n        }\\n    \\n        // Recursively get the height of the right subtree\\n        int rightHeight = dfsHeight(root.right);\\n        \\n        // If the right subtree is not balanced, return -1\\n        if(rightHeight == -1){\\n            return -1;\\n        }\\n    \\n        // If the absolute difference between the left and right subtree heights\\n        // is greater than 1, the tree is not balanced, so return -1\\n        if(Math.abs(leftHeight - rightHeight) > 1){\\n            return -1;\\n        }\\n    \\n        // Otherwise, return the maximum height of the left and right subtrees, plus 1\\n        // This represents the height of the current node\\n    return Math.max(leftHeight,rightHeight)+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public boolean isBalanced(TreeNode root) {\\n        // Call the dfsHeight function to get the height of the tree\\n        // If the returned value is -1, the tree is not balanced\\n        // Otherwise, it is balanced\\n        return dfsHeight(root) != -1;\\n    }\\n\\n    public static int dfsHeight(TreeNode root){\\n\\n        // Base case: If the root is null, the height is 0\\n        if(root == null){\\n            return 0;\\n        }\\n    \\n        // Recursively get the height of the left subtree\\n        int leftHeight = dfsHeight(root.left);\\n\\n        // If the left subtree is not balanced, return -1\\n        if(leftHeight == -1){\\n            return -1;\\n        }\\n    \\n        // Recursively get the height of the right subtree\\n        int rightHeight = dfsHeight(root.right);\\n        \\n        // If the right subtree is not balanced, return -1\\n        if(rightHeight == -1){\\n            return -1;\\n        }\\n    \\n        // If the absolute difference between the left and right subtree heights\\n        // is greater than 1, the tree is not balanced, so return -1\\n        if(Math.abs(leftHeight - rightHeight) > 1){\\n            return -1;\\n        }\\n    \\n        // Otherwise, return the maximum height of the left and right subtrees, plus 1\\n        // This represents the height of the current node\\n    return Math.max(leftHeight,rightHeight)+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982527,
                "title": "simple-python-recursive-solution",
                "content": "### Recursive Solution \\n* First define a getDepth dfs helper to quickly get the level of depth of the node.\\n* Then to check if the following three conditions are all satisfied:\\n\\t* check if the root itself is height-balanced (by checking if the absolute difference of the levels of depth between root\\'s left child and right child is less than 1)\\n\\t* check if the root\\'s left child is height-balanced (by recursion)\\n\\t* check if the root\\'s right child is height-balanced (by recursion)\\n\\n\\n\\n```\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        def getDepth(node):\\n            if not node:\\n                return 0\\n            return 1 + max(getDepth(node.left), getDepth(node.right))\\n        \\n        if not root:\\n            return True\\n        return abs(getDepth(root.left) - getDepth(root.right)) < =1 and \\\\\\n                self.isBalanced(root.left) and self.isBalanced(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        def getDepth(node):\\n            if not node:\\n                return 0\\n            return 1 + max(getDepth(node.left), getDepth(node.right))\\n        \\n        if not root:\\n            return True\\n        return abs(getDepth(root.left) - getDepth(root.right)) < =1 and \\\\\\n                self.isBalanced(root.left) and self.isBalanced(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182051,
                "title": "javascript",
                "content": "```\\nvar isBalanced = function(root) {\\n    return getHeight(root) !== -1;\\n    \\n    function getHeight(root) {\\n        if(!root) {\\n            return 0;\\n        }\\n        let left = getHeight(root.left);\\n        let right = getHeight(root.right);\\n        if(left == -1 || right == -1 || Math.abs(left - right) > 1) {\\n            return -1;\\n        }\\n        return 1 + Math.max(left, right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isBalanced = function(root) {\\n    return getHeight(root) !== -1;\\n    \\n    function getHeight(root) {\\n        if(!root) {\\n            return 0;\\n        }\\n        let left = getHeight(root.left);\\n        let right = getHeight(root.right);\\n        if(left == -1 || right == -1 || Math.abs(left - right) > 1) {\\n            return -1;\\n        }\\n        return 1 + Math.max(left, right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35698,
                "title": "simple-java-clean-solution",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public boolean isBalanced(TreeNode root) {\\n            if (root == null){\\n                return true;\\n            }\\n            int leftHeight = getHeight (root.left);\\n            int rightHeight = getHeight (root.right);\\n            if (Math.abs (leftHeight - rightHeight) > 1){\\n                return false;\\n            }\\n            return (isBalanced (root.left) && isBalanced (root.right));\\n        }\\n        \\n        public int getHeight (TreeNode root){\\n            if (root == null){\\n                return 0;\\n            }\\n            else {\\n                return Math.max (getHeight(root.left), getHeight(root.right)) + 1;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isBalanced(TreeNode root) {\\n            if (root == null){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2506347,
                "title": "balanced-binary-tree-c-time-o-n-space-n",
                "content": "\\n// if you like the solution then plz vote this solution\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool b=true;\\n   \\n int hight(TreeNode*root){\\n         if(root==NULL) return 0;\\n        int n1=hight(root->left) , n2=hight(root->right);\\n         if(abs(n1-n2)>1) b=false;\\n         return max(n1,n2)+1;           \\n    }\\n```\\n\\n\\n    bool isBalanced(TreeNode* root) {\\n         if(root==NULL) return true;  \\n         hight(root);\\n         return b;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool b=true;\\n   \\n int hight(TreeNode*root){\\n         if(root==NULL) return 0;\\n        int n1=hight(root->left) , n2=hight(root->right);\\n         if(abs(n1-n2)>1) b=false;\\n         return max(n1,n2)+1;           \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466942,
                "title": "python-easy-recursive-54ms-faster-than-93",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    balanced = True\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if root == None: return True\\n        self.height(root)\\n        return self.balanced\\n    \\n    def height(self, root):\\n        if (root == None): return 0\\n        l = self.height(root.left)\\n        r = self.height(root.right)\\n        if (abs(l-r) > 1):\\n            self.balanced = False\\n        return max(l, r)+1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    balanced = True\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if root == None: return True\\n        self.height(root)\\n        return self.balanced\\n    \\n    def height(self, root):\\n        if (root == None): return 0\\n        l = self.height(root.left)\\n        r = self.height(root.right)\\n        if (abs(l-r) > 1):\\n            self.balanced = False\\n        return max(l, r)+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928058,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(n), where n is the number of nodes in the binary tree.\\n    \\n    func isBalanced(_ root: TreeNode?) -> Bool {\\n        isBalancedTree(root).balanced\\n    }\\n    \\n    \\n    private func isBalancedTree(_ node: TreeNode?) -> (height: Int, balanced: Bool) {\\n        guard let node = node else { return (-1, true) }\\n        \\n        let left = isBalancedTree(node.left)\\n        guard left.balanced else { return(-1, false) }\\n        \\n        let right = isBalancedTree(node.right)\\n        guard right.balanced else { return (-1, false) }\\n        \\n        guard abs(left.height - right.height) < 2 else { return (-1, false) }\\n        \\n        return (max(left.height, right.height) + 1, true)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(n), where n is the number of nodes in the binary tree.\\n    \\n    func isBalanced(_ root: TreeNode?) -> Bool {\\n        isBalancedTree(root).balanced\\n    }\\n    \\n    \\n    private func isBalancedTree(_ node: TreeNode?) -> (height: Int, balanced: Bool) {\\n        guard let node = node else { return (-1, true) }\\n        \\n        let left = isBalancedTree(node.left)\\n        guard left.balanced else { return(-1, false) }\\n        \\n        let right = isBalancedTree(node.right)\\n        guard right.balanced else { return (-1, false) }\\n        \\n        guard abs(left.height - right.height) < 2 else { return (-1, false) }\\n        \\n        return (max(left.height, right.height) + 1, true)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 927460,
                "title": "easy-js-solution",
                "content": "```\\nvar isBalanced = function(root) {\\n    let balanced = true;\\n    \\n    function findHeight(root) {\\n        if (!root) return 0;\\n        if (balanced === false) return; // optimisation: early exit\\n\\n        let leftHeight = findHeight(root.left);\\n        let rightHeight = findHeight(root.right);\\n        let diff = Math.abs(leftHeight - rightHeight);\\n\\n        if (diff > 1) balanced = false;\\n        \\n        return Math.max(leftHeight, rightHeight) + 1;\\n    }\\n    \\n    findHeight(root);\\n    return balanced;\\n    // Time Complexity: O(n), we possibly visit all nodes\\n    // Space Complexity: O(H), call stack will possibly go as deep as height\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isBalanced = function(root) {\\n    let balanced = true;\\n    \\n    function findHeight(root) {\\n        if (!root) return 0;\\n        if (balanced === false) return; // optimisation: early exit\\n\\n        let leftHeight = findHeight(root.left);\\n        let rightHeight = findHeight(root.right);\\n        let diff = Math.abs(leftHeight - rightHeight);\\n\\n        if (diff > 1) balanced = false;\\n        \\n        return Math.max(leftHeight, rightHeight) + 1;\\n    }\\n    \\n    findHeight(root);\\n    return balanced;\\n    // Time Complexity: O(n), we possibly visit all nodes\\n    // Space Complexity: O(H), call stack will possibly go as deep as height\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 380273,
                "title": "javascript-easy-to-understand-solution",
                "content": "```javascript\\nvar isBalanced = function(root) {\\n    function getHeight(node) {\\n        if (node === null) return 0;\\n        return Math.max( getHeight(node.left), getHeight(node.right) ) + 1;\\n    }\\n    \\n    if (root === null) return true;\\n    return isBalanced(root.left) && isBalanced(root.right) && \\n        Math.abs( getHeight(root.left) - getHeight(root.right) ) < 2;\\n};\\n```\\n**Please upvote if you like it**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isBalanced = function(root) {\\n    function getHeight(node) {\\n        if (node === null) return 0;\\n        return Math.max( getHeight(node.left), getHeight(node.right) ) + 1;\\n    }\\n    \\n    if (root === null) return true;\\n    return isBalanced(root.left) && isBalanced(root.right) && \\n        Math.abs( getHeight(root.left) - getHeight(root.right) ) < 2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35781,
                "title": "clean-python-solution",
                "content": "    class Solution(object):\\n        \\n        def height(self,root):\\n            if not root: return 0\\n            return 1 + max(self.height(root.left), self.height(root.right))\\n        \\n        def isBalanced(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            if not root: return True\\n            if abs(self.height(root.left) - self.height(root.right)) > 1: return False\\n            return self.isBalanced(root.left) and self.isBalanced(root.right)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        \\n        def height(self,root):\\n            if not root: return 0\\n            return 1 + max(self.height(root.left), self.height(root.right))\\n        \\n        def isBalanced(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            if not root: return True\\n            if abs(self.height(root.left) - self.height(root.right)) > 1: return False\\n            return self.isBalanced(root.left) and self.isBalanced(root.right)",
                "codeTag": "Java"
            },
            {
                "id": 35895,
                "title": "a-simple-c-solution-using-a-depth-finding-helper-function",
                "content": "Simple C++ solution that uses helper function depth:\\n   \\n    class Solution {\\n    public:\\n        /************************************************************//\\n        int depth(TreeNode* root){\\n            if (!root) return 0;                            //base case\\n            int left = depth(root->left) + 1;         //explore left\\n            int right = depth(root->right) + 1;    //explore right\\n    \\n            if (abs(left-right) > 1  ||  left < 1 || right < 1 ) { \\n                return -1;\\n            }\\n\\n            return (max(left,right));   \\n        }\\n        \\n       /************************************************************//\\n        bool isBalanced(TreeNode* root) {\\n            if (depth(root)<0) return false;\\n            return true;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        /************************************************************//\\n        int depth(TreeNode* root){\\n            if (!root) return 0;                            //base case\\n            int left = depth(root->left) + 1;         //explore left\\n            int right = depth(root->right) + 1;    //explore right\\n    \\n            if (abs(left-right) > 1  ||  left < 1 || right < 1 ) { \\n                return -1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1745000,
                "title": "most-optimized-recursive-short-solution-in-c",
                "content": "```\\nclass Solution {\\n\\tpublic:\\n\\t\\tint height(TreeNode *root) {\\n\\t\\t\\tif(root == NULL)return 0;\\n\\t\\t\\treturn max(height(root->left), height(root->right)) + 1;\\n\\t\\t}\\n\\t\\tbool isBalanced(TreeNode* root) {\\n\\t\\t\\tif(root == NULL)return true;\\n\\t\\t\\treturn isBalanced(root->left) && isBalanced(root->right) && abs(height(root->left) - height(root->right)) <= 1;\\n\\t\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic:\\n\\t\\tint height(TreeNode *root) {\\n\\t\\t\\tif(root == NULL)return 0;\\n\\t\\t\\treturn max(height(root->left), height(root->right)) + 1;\\n\\t\\t}\\n\\t\\tbool isBalanced(TreeNode* root) {\\n\\t\\t\\tif(root == NULL)return true;\\n\\t\\t\\treturn isBalanced(root->left) && isBalanced(root->right) && abs(height(root->left) - height(root->right)) <= 1;\\n\\t\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958367,
                "title": "simplest-c-solution",
                "content": "```\\n bool ans=true;\\nint height(TreeNode*root){\\n    if(!root)\\n        return 0;\\n    int l=height(root->left);\\n    int r=height(root->right);\\n    ans=ans& abs(l-r)<2;\\n    return max(l,r)+1;\\n}\\n    bool isBalanced(TreeNode* root) {\\n        height(root);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n bool ans=true;\\nint height(TreeNode*root){\\n    if(!root)\\n        return 0;\\n    int l=height(root->left);\\n    int r=height(root->right);\\n    ans=ans& abs(l-r)<2;\\n    return max(l,r)+1;\\n}\\n    bool isBalanced(TreeNode* root) {\\n        height(root);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35854,
                "title": "c-dfs-solution",
                "content": "    class Solution {\\n    public:\\n        bool isBalanced(TreeNode* root) {\\n            int height = 0;\\n            return checkBalance(root, height);\\n        }\\n        \\n        bool checkBalance(TreeNode* root, int& height) {\\n            if (root == NULL) {\\n                height = 0;\\n                return true;\\n            }\\n            int leftHeight = 0;\\n            int rightHeight = 0;\\n            if (!checkBalance(root->left, leftHeight)) return false;\\n            if (!checkBalance(root->right, rightHeight)) return false;\\n            if ( abs(leftHeight - rightHeight) > 1 ) return false;\\n            height = max(leftHeight, rightHeight) + 1;\\n            return true;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isBalanced(TreeNode* root) {\\n            int height = 0;\\n            return checkBalance(root, height);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 35973,
                "title": "my-short-o-n-recursive-c-code",
                "content": "    class Solution {\\n    public:\\n        int height(TreeNode *root)\\n        {\\n            if(root == NULL) return 0;\\n            int hl = height(root->left);\\n            int hr = height(root->right);\\n            if (hl == -1 || hr == -1 || abs(hl - hr) > 1) return -1;\\n            return max(hl, hr) + 1;\\n        }\\n        bool isBalanced(TreeNode *root) {\\n            return height(root) != -1;\\n        }\\n    };",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        int height(TreeNode *root)\\n        {\\n            if(root == NULL) return 0;\\n            int hl = height(root->left);\\n            int hr = height(root->right);\\n            if (hl == -1 || hr == -1 || abs(hl - hr) > 1) return -1;\\n            return max(hl, hr) + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1781475,
                "title": "best-solution-with-2-approaches",
                "content": "## **Approach #1**\\n```\\nclass Solution {\\nprivate:\\n    int height(TreeNode* root){\\n        if(root==NULL)\\n            return 0;\\n        \\n        int left = height(root->left);\\n        int right = height(root->right);\\n        \\n        int ans = max(left,right) + 1;\\n        \\n        return ans;\\n    }\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if(root==NULL)\\n            return true;\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n        \\n        bool diff = abs (height(root->left) - height(root->right)) <= 1;\\n        \\n        if(left && right && diff){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```\\n\\n## **Approach #2** (Using Pair)(optimal approach)\\n```\\nclass Solution {\\n\\npublic:\\n    pair<bool,int> checkBalanced(TreeNode* root){\\n        if(root==NULL){\\n            pair<bool,int> p = make_pair(true,0);\\n            return p;\\n        }\\n        \\n        pair<int,int> left = checkBalanced(root->left);\\n        pair<int,int> right = checkBalanced(root->right);\\n        \\n        bool leftAns = left.first;\\n        bool rightAns = right.first;\\n        \\n        bool diff = abs (left.second - right.second) <= 1;\\n        \\n        pair<bool,int> ans;\\n        ans.second = max(left.second,right.second) + 1;\\n        \\n        if(leftAns && rightAns && diff){\\n            ans.first = true;\\n        }\\n        else{\\n            ans.first = false;\\n        }\\n        \\n        return ans;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        return checkBalanced(root).first;\\n    }\\n};\\n```\\n\\n# ****PLEASE UPVOTE",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int height(TreeNode* root){\\n        if(root==NULL)\\n            return 0;\\n        \\n        int left = height(root->left);\\n        int right = height(root->right);\\n        \\n        int ans = max(left,right) + 1;\\n        \\n        return ans;\\n    }\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if(root==NULL)\\n            return true;\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n        \\n        bool diff = abs (height(root->left) - height(root->right)) <= 1;\\n        \\n        if(left && right && diff){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\npublic:\\n    pair<bool,int> checkBalanced(TreeNode* root){\\n        if(root==NULL){\\n            pair<bool,int> p = make_pair(true,0);\\n            return p;\\n        }\\n        \\n        pair<int,int> left = checkBalanced(root->left);\\n        pair<int,int> right = checkBalanced(root->right);\\n        \\n        bool leftAns = left.first;\\n        bool rightAns = right.first;\\n        \\n        bool diff = abs (left.second - right.second) <= 1;\\n        \\n        pair<bool,int> ans;\\n        ans.second = max(left.second,right.second) + 1;\\n        \\n        if(leftAns && rightAns && diff){\\n            ans.first = true;\\n        }\\n        else{\\n            ans.first = false;\\n        }\\n        \\n        return ans;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        return checkBalanced(root).first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844406,
                "title": "python-3-balanced-binary-tree-beats-99-5",
                "content": "**Logic:** From root, travel to both left sub-tree and right sub-tree\\n```\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        \\n        if not root:\\n            return 1\\n        \\n        def check(node):\\n            if not node:\\n                return 0\\n            \\n            lef = check(node.left)\\n            rig = check(node.right)\\n            \\n            if lef==-1 or rig==-1 or abs(lef-rig)>1:\\n                return -1\\n            \\n            return 1+ max(lef,rig)\\n            \\n            \\n        if check(root)!=-1:\\n            return 1\\n        else:\\n            return 0 \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        \\n        if not root:\\n            return 1\\n        \\n        def check(node):\\n            if not node:\\n                return 0\\n            \\n            lef = check(node.left)\\n            rig = check(node.right)\\n            \\n            if lef==-1 or rig==-1 or abs(lef-rig)>1:\\n                return -1\\n            \\n            return 1+ max(lef,rig)\\n            \\n            \\n        if check(root)!=-1:\\n            return 1\\n        else:\\n            return 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 296354,
                "title": "c-easy-concise-dfs",
                "content": "Thanks to local functions added on C#7\\n```\\npublic class Solution {\\n    public bool IsBalanced(TreeNode root) {\\n        bool bal = true;\\n        int Dfs(TreeNode node) {\\n            if (node == null)\\n                return 0;\\n            int l = Dfs(node.left), r = Dfs(node.right);\\n            if (Math.Abs(l - r) > 1)\\n                bal = false;\\n            return Math.Max(l, r) + 1;\\n        }\\n        Dfs(root);\\n        return bal;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsBalanced(TreeNode root) {\\n        bool bal = true;\\n        int Dfs(TreeNode node) {\\n            if (node == null)\\n                return 0;\\n            int l = Dfs(node.left), r = Dfs(node.right);\\n            if (Math.Abs(l - r) > 1)\\n                bal = false;\\n            return Math.Max(l, r) + 1;\\n        }\\n        Dfs(root);\\n        return bal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35942,
                "title": "80ms-python-solution",
                "content": "    def depthAndBalan(self, root):\\n        if root is None:\\n            return 1, True\\n        leftDep, leftBal = self.depthAndBalan(root.left)\\n        rightDep, rightBal = self.depthAndBalan(root.right)\\n        curBal = abs(leftDep - rightDep) <= 1\\n        return max(leftDep, rightDep)+1, leftBal and rightBal and curBal\\n        \\n    def isBalanced(self, root):\\n        return self.depthAndBalan(root)[1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def depthAndBalan(self, root):\\n        if root is None:\\n            return 1, True\\n        leftDep, leftBal = self.depthAndBalan(root.left)\\n        rightDep, rightBal = self.depthAndBalan(root.right)\\n        curBal = abs(leftDep - rightDep) <= 1\\n        return max(leftDep, rightDep)+1, leftBal and rightBal and curBal\\n        \\n    def isBalanced(self, root):\\n        return self.depthAndBalan(root)[1]",
                "codeTag": "Python3"
            },
            {
                "id": 3315406,
                "title": "java-solution-beats-95-33",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSimple traversal on each node and check left and right height of current node and if difference of left and right is more than 1 than return false\\nelse after traversal of whole tree return true\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        \\n        return maxDepth(root) != -1;\\n    }\\n\\n    int maxDepth(TreeNode root){\\n        if(root == null)\\n         return 0;\\n\\n        int lh = maxDepth(root.left);\\n        if(lh == -1)\\n         return -1;\\n\\n        int rh = maxDepth(root.right);\\n        if(rh == -1)\\n         return -1;\\n\\n        if(Math.abs(lh - rh) > 1)\\n         return -1;\\n\\n        return 1+Math.max(lh, rh);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        \\n        return maxDepth(root) != -1;\\n    }\\n\\n    int maxDepth(TreeNode root){\\n        if(root == null)\\n         return 0;\\n\\n        int lh = maxDepth(root.left);\\n        if(lh == -1)\\n         return -1;\\n\\n        int rh = maxDepth(root.right);\\n        if(rh == -1)\\n         return -1;\\n\\n        if(Math.abs(lh - rh) > 1)\\n         return -1;\\n\\n        return 1+Math.max(lh, rh);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215014,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if (root == NULL)\\n            return true;\\n        int lh = height(root->left); \\n        int rh = height(root->right);    \\n        if (abs(lh - rh) > 1)\\n            return false; \\n        bool left = isBalanced(root->left); \\n        bool right = isBalanced(root->right);  \\n        if (left == false || right == false) \\n            return false;    \\n        return true;\\n    }\\n    int height(TreeNode* root) {\\n        if (root == NULL)\\n            return 0;\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n        return 1 + max (lh, rh);      \\n    }\\n};\\n```\\n\\n# Approach 2\\nOptimal \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if (root == NULL)\\n            return true;\\n        if (height(root) == -1)\\n            return false;\\n        return true;\\n    }\\n    int height(TreeNode* root) {\\n        if (root == NULL)\\n            return 0;\\n        int lh = height(root->left);\\n        if (lh == -1)\\n            return -1;\\n        int rh = height(root->right);\\n        if (rh == -1)\\n            return -1;\\n        if (abs(lh - rh) > 1)\\n            return -1;   \\n        return 1 + max (lh, rh);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if (root == NULL)\\n            return true;\\n        int lh = height(root->left); \\n        int rh = height(root->right);    \\n        if (abs(lh - rh) > 1)\\n            return false; \\n        bool left = isBalanced(root->left); \\n        bool right = isBalanced(root->right);  \\n        if (left == false || right == false) \\n            return false;    \\n        return true;\\n    }\\n    int height(TreeNode* root) {\\n        if (root == NULL)\\n            return 0;\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n        return 1 + max (lh, rh);      \\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if (root == NULL)\\n            return true;\\n        if (height(root) == -1)\\n            return false;\\n        return true;\\n    }\\n    int height(TreeNode* root) {\\n        if (root == NULL)\\n            return 0;\\n        int lh = height(root->left);\\n        if (lh == -1)\\n            return -1;\\n        int rh = height(root->right);\\n        if (rh == -1)\\n            return -1;\\n        if (abs(lh - rh) > 1)\\n            return -1;   \\n        return 1 + max (lh, rh);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769971,
                "title": "c-o-n-solution-full-explanation-recurrsion",
                "content": "**PLEASE DO UPVOTE IF YOU UNDERSTAND**\\n USING THE CONCEPT OF HEIGHT OF BINARY TREE :\\n 1. Check for every node if abs(leftHeight - rightHeight) is > 1 \\nIf yes than return -1.\\n2. If after this leftHeight == -1 || rightHeight == -1 return -1;\\n3. If the returned value is -1 then the answer will be false\\nand if the returned value is height of the tree it will be true.\\n\\nclass Solution {\\npublic:\\n\\n\\n    bool isBalanced(TreeNode* root) {\\n \\n        return dfsHeight(root) != -1;\\n    \\n    }\\n    \\n    int dfsHeight(TreeNode* root){\\n        \\n        if(root == NULL) return 0;\\n        \\n        int leftHeight = dfsHeight(root->left);\\n        if(leftHeight == -1) return -1;\\n        int rightHeight = dfsHeight(root->right);\\n        if(rightHeight == -1) return -1;\\n        \\n        if(abs(leftHeight - rightHeight) > 1) return -1;\\n        \\n        return max(leftHeight, rightHeight) + 1;\\n        \\n    }\\n};\\n **PLEASE DO UPVOTE IF YOU UNDERSTAND**\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    bool isBalanced(TreeNode* root) {\\n \\n        return dfsHeight(root) != -1;\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 982374,
                "title": "ruby-o-n",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode\\n#     attr_accessor :val, :left, :right\\n#     def initialize(val = 0, left = nil, right = nil)\\n#         @val = val\\n#         @left = left\\n#         @right = right\\n#     end\\n# end\\n# @param {TreeNode} root\\n# @return {Boolean}\\ndef is_balanced(root)\\n  balanced_height(root, 0) >= 0\\nend\\n\\ndef balanced_height(root, height)\\n  return height unless root\\n\\n  l = balanced_height(root.left, height + 1)\\n  r = balanced_height(root.right, height + 1)\\n\\n  return -1 if l == -1 || r == -1 || (l - r).abs > 1\\n\\n  [l, r].max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode\\n#     attr_accessor :val, :left, :right\\n#     def initialize(val = 0, left = nil, right = nil)\\n#         @val = val\\n#         @left = left\\n#         @right = right\\n#     end\\n# end\\n# @param {TreeNode} root\\n# @return {Boolean}\\ndef is_balanced(root)\\n  balanced_height(root, 0) >= 0\\nend\\n\\ndef balanced_height(root, height)\\n  return height unless root\\n\\n  l = balanced_height(root.left, height + 1)\\n  r = balanced_height(root.right, height + 1)\\n\\n  return -1 if l == -1 || r == -1 || (l - r).abs > 1\\n\\n  [l, r].max\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209408,
                "title": "java-solution-from-pratik",
                "content": "- An empty tree is height-balanced. \\n\\n- A non-empty binary tree T is balanced if: \\n1. Left subtree of T is balanced \\n2. Right subtree of T is balanced \\n3. The difference between heights of left subtree and right subtree is at most `1`\\n\\nThe diagram below shows two trees, one of them is height-balanced and other is not. The second tree is not height-balanced because height of left subtree is 2 more than height of right subtree.\\n\\n![image](https://assets.leetcode.com/users/images/a888bbf2-39bc-4ae9-87d1-242a1126fdfd_1632409301.648122.jpeg)\\n\\n\\n- If recursive call after conditional check, then its top down.\\n- If recursive calls before conditional check, then its bottom up. \\n\\n**Solutiion 1: Top Down Approach:**\\n\\n**Time Complexity:** O(N<sup>2</sup>)\\n- For the current node root, calling `getHeight()` for its left and right children actually has to access all of its children, thus the complexity is `O(N)`. \\n- This is being done for each node in the tree, so the overall complexity of `isBalanced()` will be `O(N * N)` = O(N<sup>2</sup>)\\n\\n**Space complexity:** `O(H)` - the maximum depth of function call stack\\n\\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        int leftHeight = getHeight(root.left);\\n        int rightHeight = getHeight(root.right);\\n\\n        return Math.abs(leftHeight - rightHeight) <= 1 && isBalanced(root.left) && isBalanced(root.right);\\n    }\\n\\n    private int getHeight(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        } else {\\n            return 1 + Math.max(getHeight(root.left), getHeight(root.right));\\n        }\\n    }\\n}\\n```\\n\\n**Solution 2: Bottom Up Approach:**\\n\\n- In Top Down Approach, we perform redundant calculations when computing the `height`. In each call to `getHeight()`, we require that the heights of subtrees also be computed. Therefore, when working top down we will compute the height of a subtree once for every parent. \\n- We can remove this redundancy by first recursing on the children of the current node and then using their computed height to determine whether the current node is balanced.\\n\\n**Algorithm:**\\n1. The bottom-up approach is a reverse of the logic of the top-down approach, since we first check if the child subtrees are balanced before comparing their heights.\\n1. Check if the child subtrees are balanced. If they are, use their heights to determine if the current subtree is balanced as well as to calculate the height of current subtree.\\n\\n**Time Complexity**: `O(N)`\\n- For every subtree, we compute its height in constant time as well as compare the height of its children.\\n- Instead of calling `getHeight()` explicitly for each child node, the height of the current node is returned in recursion. \\n- When the sub tree of the current node (inclusive) is balanced, the function `getHeight()` returns a non-negative value as the height, otherwise `-1` is returned. \\n- According to the `leftHeight` and `rightHeight` of the two children, the parent node could check if the subtrees are balanced in order to decide its return value.\\n- In bottom up approach, each node in the tree will be accessed once. Thus the time complexity is `O(N)`\\n\\n**Space complexity:** `O(H)` - the maximum depth of function call stack\\n\\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return getHeight(root) != -1;\\n    }\\n\\n    private int getHeight(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n\\n        int leftHeight = getHeight(root.left);\\n        if (leftHeight == -1) {\\n            return -1;\\n        }\\n\\n        int rightHeight = getHeight(root.right);\\n        if (rightHeight == -1) {\\n            return -1;\\n        }\\n\\n        if (Math.abs(leftHeight - rightHeight) > 1) {\\n            return -1;\\n        } else {\\n            return 1 + Math.max(leftHeight, rightHeight);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        int leftHeight = getHeight(root.left);\\n        int rightHeight = getHeight(root.right);\\n\\n        return Math.abs(leftHeight - rightHeight) <= 1 && isBalanced(root.left) && isBalanced(root.right);\\n    }\\n\\n    private int getHeight(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        } else {\\n            return 1 + Math.max(getHeight(root.left), getHeight(root.right));\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return getHeight(root) != -1;\\n    }\\n\\n    private int getHeight(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n\\n        int leftHeight = getHeight(root.left);\\n        if (leftHeight == -1) {\\n            return -1;\\n        }\\n\\n        int rightHeight = getHeight(root.right);\\n        if (rightHeight == -1) {\\n            return -1;\\n        }\\n\\n        if (Math.abs(leftHeight - rightHeight) > 1) {\\n            return -1;\\n        } else {\\n            return 1 + Math.max(leftHeight, rightHeight);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35969,
                "title": "why-1-2-2-3-3-3-3-4-4-4-4-4-4-5-5-expected-true",
                "content": "test 218/ 226\\n\\nInput:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\nOutput:\\tfalse\\nExpected: true\\n\\n   \\n\\n               1\\n            /     \\\\\\n          2        2\\n         /  \\\\      / \\\\\\n        3   3     3  3\\n       /\\\\   /\\\\   /\\\\\\n      4 4  4 4  4 4\\n      /\\\\\\n     5  5\\n\\n\\nI think this is unbalanced\\n\\n\\neven stranger\\n\\ntest 212/226\\nInput:\\t{1,2,2,3,3,#,#,4,4}\\nOutput:\\ttrue\\nExpected: false",
                "solutionTags": [],
                "code": "test 218/ 226\\n\\nInput:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\nOutput:\\tfalse\\nExpected: true\\n\\n   \\n\\n               1\\n            /     \\\\\\n          2        2\\n         /  \\\\      / \\\\\\n        3   3     3  3\\n       /\\\\   /\\\\   /\\\\\\n      4 4  4 4  4 4\\n      /\\\\\\n     5  5\\n\\n\\nI think this is unbalanced\\n\\n\\neven stranger\\n\\ntest 212/226\\nInput:\\t{1,2,2,3,3,#,#,4,4}\\nOutput:\\ttrue\\nExpected: false",
                "codeTag": "Unknown"
            },
            {
                "id": 36027,
                "title": "shortest-recursive-solution",
                "content": "\\n    public boolean isBalanced(TreeNode root) {\\n        if(root==null) return true;\\n        int l=depth(root.left);\\n        int r=depth(root.right);\\n        return ((int)Math.abs(l-r)<2)&&isBalanced(root.left) && isBalanced(root.right);\\n    }\\n    static int depth(TreeNode n){\\n            if(n==null) return 0;\\n            return Math.max(depth(n.left),depth(n.right))+1;\\n       }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "\\n    public boolean isBalanced(TreeNode root) {\\n        if(root==null) return true;\\n        int l=depth(root.left);\\n        int r=depth(root.right);\\n        return ((int)Math.abs(l-r)<2)&&isBalanced(root.left) && isBalanced(root.right);\\n    }\\n    static int depth(TreeNode n){\\n            if(n==null) return 0;\\n            return Math.max(depth(n.left),depth(n.right))+1;\\n       }",
                "codeTag": "Unknown"
            },
            {
                "id": 36029,
                "title": "use-exception-handling-to-early-terminate-and-return-once-a-unbalance-is-found",
                "content": "Has anyone tried using Java exception handling to early terminate recursion function once a unbalance node is found?\\n\\n    public class Solution {\\n        public boolean isBalanced(TreeNode root) {\\n            try {\\n                getDepth(root);\\n            } catch (Exception e) {\\n                return false;\\n            }\\n            return true;\\n        }\\n        private int getDepth(TreeNode root) throws Exception {\\n            if (root == null) {\\n                return 0;\\n            }\\n            int leftDepth = getDepth(root.left);\\n            int rightDepth = getDepth(root.right);\\n            if (Math.abs(leftDepth - rightDepth) > 1) {\\n                throw new Exception(\"Not balanced!\");\\n            }\\n            return Math.max(leftDepth, rightDepth) + 1;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public boolean isBalanced(TreeNode root) {\\n            try {\\n                getDepth(root);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3986821,
                "title": "o-n-time-complexity-bottom-up-dfs-short-and-simple-explained",
                "content": "# Intuition\\nGiven the definition of a balanced tree, we know that a tree is **not balanced** when the difference between heights of the left and right subtree is over 1:\\n `abs(height_left - height_right) > 1` *(abs: absolute value)*\\nThe basic approach is:\\n* Traverse the tree\\n* Calculate the height of the left and right subtree\\n* If it\\'s not balanced (by using the formular above), then return false.\\n* Return true when all nodes are passed\\n\\nBut for the best performance, we want to return false right after we have found the unbalanced subtree. So we add another step before calculating the height of subtrees: if the left or right subtree is unbalanced, then return false.\\n\\nWe don\\'t want to repeat the traversal of the subtree to check balance and then calculate height. So we just do all once for each node.\\n\\nThe height at a node is obtained by it\\'s children height + 1: `max(height(i.left), height(i.right)) + 1`\\n\\n# Approach\\nTraverse each node recursively and return the height of it, if the subtree at that node is not balanced, then return -1:\\n1. If the node is `null`, return 0\\n2. Get the height of left subtree, if it\\'s -1, then return -1\\n3. Get the height of right subtree, if it\\'s -1, then return -1\\n4. If the difference between the heights of left and right subtree > 1 then return -1\\n5. Finally, return false if the final height is -1, else return true\\n# Complexity\\n- Time complexity: $$O(n)$$\\nFor each node, we compare the heights of it\\'s children and get it\\'s height in constance time.\\n\\n- Space complexity: $$O(n)$$ \\nThe recursive stack may contain all nodes if the tree is skewed (each node only has left child)\\n# Code\\n```Python3 []\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        def height(root):\\n            if root == None:\\n                return 0\\n            \\n            h_left = height(root.left)\\n            if h_left < 0:\\n                return -1\\n            h_right = height(root.right)\\n            if h_right < 0 or abs(h_left - h_right) > 1:\\n                return -1\\n\\n            return max(h_left, h_right) + 1\\n        \\n        return height(root) >= 0\\n```\\n```C++ []\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int height(TreeNode* root) {\\n        if (!root) {\\n            return 0;\\n        }\\n        int hLeft = height(root->left);\\n        if (hLeft < 0) {\\n            return -1;\\n        }\\n        int hRight = height(root->right);\\n        if (hRight < 0 || std::abs(hLeft - hRight) > 1) {\\n            return -1;\\n        }\\n        return std::max(hLeft, hRight) + 1;\\n    }\\n\\n    bool isBalanced(TreeNode* root) {\\n        return height(root) >= 0;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    int height(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int hLeft = height(root.left);\\n        if (hLeft < 0) {\\n            return -1;\\n        }\\n        int hRight = height(root.right);\\n        if (hRight < 0 || Math.abs(hLeft - hRight) > 1) {\\n            return -1;\\n        }\\n        return Math.max(hLeft, hRight) + 1;\\n    }\\n\\n    public boolean isBalanced(TreeNode root) {\\n         return height(root) >= 0;\\n    }\\n}\\n```\\n```Kotlin []\\nclass Solution {\\n    fun height(root: TreeNode?): Int {\\n        if (root == null) {\\n            return 0\\n        }\\n        val hLeft = height(root.left);\\n        if (hLeft < 0) {\\n            return -1\\n        }\\n        val hRight = height(root.right);\\n        if (hRight < 0 || abs(hLeft - hRight) > 1) {\\n            return -1\\n        }\\n        return max(hLeft, hRight) + 1\\n    }\\n\\n\\n    fun isBalanced(root: TreeNode?): Boolean {\\n        return height(root) >= 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Kotlin",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        def height(root):\\n            if root == None:\\n                return 0\\n            \\n            h_left = height(root.left)\\n            if h_left < 0:\\n                return -1\\n            h_right = height(root.right)\\n            if h_right < 0 or abs(h_left - h_right) > 1:\\n                return -1\\n\\n            return max(h_left, h_right) + 1\\n        \\n        return height(root) >= 0\\n```\n```C++ []\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    int height(TreeNode* root) {\\n        if (!root) {\\n            return 0;\\n        }\\n        int hLeft = height(root->left);\\n        if (hLeft < 0) {\\n            return -1;\\n        }\\n        int hRight = height(root->right);\\n        if (hRight < 0 || std::abs(hLeft - hRight) > 1) {\\n            return -1;\\n        }\\n        return std::max(hLeft, hRight) + 1;\\n    }\\n\\n    bool isBalanced(TreeNode* root) {\\n        return height(root) >= 0;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    int height(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int hLeft = height(root.left);\\n        if (hLeft < 0) {\\n            return -1;\\n        }\\n        int hRight = height(root.right);\\n        if (hRight < 0 || Math.abs(hLeft - hRight) > 1) {\\n            return -1;\\n        }\\n        return Math.max(hLeft, hRight) + 1;\\n    }\\n\\n    public boolean isBalanced(TreeNode root) {\\n         return height(root) >= 0;\\n    }\\n}\\n```\n```Kotlin []\\nclass Solution {\\n    fun height(root: TreeNode?): Int {\\n        if (root == null) {\\n            return 0\\n        }\\n        val hLeft = height(root.left);\\n        if (hLeft < 0) {\\n            return -1\\n        }\\n        val hRight = height(root.right);\\n        if (hRight < 0 || abs(hLeft - hRight) > 1) {\\n            return -1\\n        }\\n        return max(hLeft, hRight) + 1\\n    }\\n\\n\\n    fun isBalanced(root: TreeNode?): Boolean {\\n        return height(root) >= 0\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3192782,
                "title": "python3-easiest-solution-53ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing DFS we can solve this.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- first check if node is None then return 0, because None node is balanced.\\n- if not then get count of left or right subtree.\\n- now if abs(right - left) > 1 then it\\'s not balanced tree, then return -1\\n- if any of left or right height is -1 then we already found imbance in tree, so return -1.\\n- now else all of above cases return 1 + max(left, right), because indicating maxdepth till now no matter left or right.\\n- now if returned answer is > 0 then return true else false.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        R = root\\n        def helper(curr=root):\\n            if curr == None:\\n                return 0\\n            else:\\n                left = helper(curr.left)\\n                right = helper(curr.right)\\n                if left == -1 or right == -1:\\n                    return -1\\n                elif abs(right - left) > 1:\\n                    return -1\\n                return 1 + max(left, right)\\n        return helper() >= 0\\n```\\n# Please like and comment below :-)",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        R = root\\n        def helper(curr=root):\\n            if curr == None:\\n                return 0\\n            else:\\n                left = helper(curr.left)\\n                right = helper(curr.right)\\n                if left == -1 or right == -1:\\n                    return -1\\n                elif abs(right - left) > 1:\\n                    return -1\\n                return 1 + max(left, right)\\n        return helper() >= 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191981,
                "title": "convert-sorted-list-to-binary-search-tree-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere\\'s the algorithm:\\n\\n1. Define a helper function called getHeight that takes a node as input and returns the height of the node\\'s subtree.\\n\\n2. In the getHeight function, recursively calculate the heights of the left and right subtrees of the node.\\n\\n3. If the difference in heights of the left and right subtrees is greater than 1, then return -1 to indicate that the tree is not balanced.\\n\\n4. Otherwise, return the height of the node\\'s subtree as 1 plus the maximum of the heights of its left and right subtrees.\\n\\n5. Define a function called isBalanced that takes a node as input and returns a boolean indicating if the node\\'s subtree is balanced.\\n\\n6. In the isBalanced function, if the node is None, then return True to indicate that the subtree is balanced.\\n\\n7. Otherwise, recursively check if the left and right subtrees of the node are balanced and if the difference in their heights is at most 1.\\n\\n8. If both subtrees are balanced and their height difference is at most 1, then return True. Otherwise, return False to indicate that the subtree is not balanced.\\n\\n9. Call the isBalanced function on the root node of the tree and return its result.\\n\\n# Complexity\\n- Time complexity:\\nO(n log n) for the worst-case scenario.\\n\\n- Space complexity:\\n O(h) for the worst-case scenario.\\n\\n# Code\\n```\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        def getHeight(node):\\n            if node is None:\\n                return 0\\n            left_height = getHeight(node.left)\\n            right_height = getHeight(node.right)\\n            if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:\\n                return -1\\n            return 1 + max(left_height, right_height)\\n        return getHeight(root) != -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        def getHeight(node):\\n            if node is None:\\n                return 0\\n            left_height = getHeight(node.left)\\n            right_height = getHeight(node.right)\\n            if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:\\n                return -1\\n            return 1 + max(left_height, right_height)\\n        return getHeight(root) != -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815299,
                "title": "o-n-dfs-beats-99-78-explained-line-by-line",
                "content": "```\\ndef isBalanced(self, root: Optional[TreeNode]) -> bool:\\n\\t# helper method to determine the height of a node\\n\\t# however it will return False if the tree beginning at node is not height-balanced\\n\\tdef dfs(node):\\n\\t\\tif not node: # if there is no node then return 1\\n\\t\\t\\treturn 1 # this will be our lowest height\\n\\t\\tleft = dfs(node.left) # get the height of the left subtree\\n\\t\\tright = dfs(node.right) # get the height of the right subtree\\n\\t\\t# if either subtree is NOT height balanced, then the whole tree is not height-balanced\\n\\t\\tif left == False or right == False or abs(left-right)>1: # if the heights of the subtrees are not within 1 of each other, then the tree isn\\'t height-balanced\\n\\t\\t\\treturn False # this tree is not height-balanced\\n\\t\\treturn max(left,right) + 1 # the height of this tree is 1 more than the maximum height of the subtrees\\n\\treturn dfs(root) != False # if we never returned False then we never found a height-balancing issue!\\n```\\nThe main idea is that we will use a helper method, `dfs`, to figure out the height of a node while also checking to see if it is height balanced! Basically, we do exactly what we would do for a regular recursive method to figure out the height of a tree \\u2013 return the maximum of the heights of the left and right subtrees, plus one. However, if the tree is not height balanced (`abs(left-right)>1`), then we need to return `False`. But before we check that, we also need to check if either of the subtrees are not balanced \\u2013\\u2013\\xA0if `left == False or right == False` then they are not height-balanced, so the whole tree isn\\'t height balanced either! This method only requires us to look at every node once, giving a time complexity of `O(N)`, and making this a super fast solution!",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef isBalanced(self, root: Optional[TreeNode]) -> bool:\\n\\t# helper method to determine the height of a node\\n\\t# however it will return False if the tree beginning at node is not height-balanced\\n\\tdef dfs(node):\\n\\t\\tif not node: # if there is no node then return 1\\n\\t\\t\\treturn 1 # this will be our lowest height\\n\\t\\tleft = dfs(node.left) # get the height of the left subtree\\n\\t\\tright = dfs(node.right) # get the height of the right subtree\\n\\t\\t# if either subtree is NOT height balanced, then the whole tree is not height-balanced\\n\\t\\tif left == False or right == False or abs(left-right)>1: # if the heights of the subtrees are not within 1 of each other, then the tree isn\\'t height-balanced\\n\\t\\t\\treturn False # this tree is not height-balanced\\n\\t\\treturn max(left,right) + 1 # the height of this tree is 1 more than the maximum height of the subtrees\\n\\treturn dfs(root) != False # if we never returned False then we never found a height-balancing issue!\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1592628,
                "title": "python-detailed-recursive-solution-for-beginners-using-height-with-proper-comments",
                "content": "```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n\\t#if the root is none, tree is balanced. So return True.\\n        if root is None:\\n            return True\\n\\t\\t#For a tree to be balanced, at any given node , the height difference between left and right subtrees\\n\\t\\t#should not be more than 1\\n\\t\\t#So the easiest solution for this can be to find the height of left and right subtrees\\n\\t\\t#Remember height has to balanced at each subtree \\n\\t\\t\\n\\t\\t#we create a height function to calculate height of left and right subtree\\n\\t\\t#store the heights of left subtree and right subtree \\t\\n        lefth=self.height(root.left)\\n        righth=self.height(root.right)\\n\\t\\t\\n\\t\\t#check if the difference between left subtree and right subtree is greater than 1, return False\\n        if lefth-righth>1 or righth-lefth>1:\\n            return False\\n\\t\\t\\t\\n\\t\\t#A tree is balanced if the left and the right subtrees are balanced \\n\\t\\t#So recursively check at each node if its left and right child are balanced\\n        leftbal=self.isBalanced(root.left)\\n        rightbal=self.isBalanced(root.right)\\n\\t\\t\\n\\t\\tif left and right are balanced, return True else return false\\n        if leftbal and rightbal:\\n            return True\\n        else:\\n            return False\\n        \\n\\t\\t#function to find height of a tree\\n    def height(self,root):\\n        if root is None:\\n            return 0\\n        else:\\n            return 1+max(self.height(root.left),self.height(root.right))\\n        \\n```\\n\\n**Feel free to comment improved solutions or any doubts.**",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n\\t#if the root is none, tree is balanced. So return True.\\n        if root is None:\\n            return True\\n\\t\\t#For a tree to be balanced, at any given node , the height difference between left and right subtrees\\n\\t\\t#should not be more than 1\\n\\t\\t#So the easiest solution for this can be to find the height of left and right subtrees\\n\\t\\t#Remember height has to balanced at each subtree \\n\\t\\t\\n\\t\\t#we create a height function to calculate height of left and right subtree\\n\\t\\t#store the heights of left subtree and right subtree \\t\\n        lefth=self.height(root.left)\\n        righth=self.height(root.right)\\n\\t\\t\\n\\t\\t#check if the difference between left subtree and right subtree is greater than 1, return False\\n        if lefth-righth>1 or righth-lefth>1:\\n            return False\\n\\t\\t\\t\\n\\t\\t#A tree is balanced if the left and the right subtrees are balanced \\n\\t\\t#So recursively check at each node if its left and right child are balanced\\n        leftbal=self.isBalanced(root.left)\\n        rightbal=self.isBalanced(root.right)\\n\\t\\t\\n\\t\\tif left and right are balanced, return True else return false\\n        if leftbal and rightbal:\\n            return True\\n        else:\\n            return False\\n        \\n\\t\\t#function to find height of a tree\\n    def height(self,root):\\n        if root is None:\\n            return 0\\n        else:\\n            return 1+max(self.height(root.left),self.height(root.right))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 981599,
                "title": "c-o-n-set-the-ans-to-false-whenever-you-find-an-imbalance",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ans = true;\\n    int solve(TreeNode *root){\\n        if(!root)\\n            return 0;\\n        int lh = solve(root -> left);\\n        int rh = solve(root -> right);\\n        if(abs(lh - rh ) > 1)\\n            ans = false;\\n        return 1 + max(lh,rh); \\n    }\\n    bool isBalanced(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ans = true;\\n    int solve(TreeNode *root){\\n        if(!root)\\n            return 0;\\n        int lh = solve(root -> left);\\n        int rh = solve(root -> right);\\n        if(abs(lh - rh ) > 1)\\n            ans = false;\\n        return 1 + max(lh,rh); \\n    }\\n    bool isBalanced(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611324,
                "title": "python-83-100-solution",
                "content": "```\\nclass Solution:\\n\\n    def is_leaf(self, root: TreeNode) -> bool:\\n        return not root.left and not root.right\\n\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n\\n        if self.is_leaf(root):\\n            root.height = 1\\n            return True\\n        elif not root.left and root.right:\\n            if self.is_leaf(root.right):\\n                root.height = 2\\n                return True\\n            return False\\n        elif root.left and not root.right:\\n            if self.is_leaf(root.left):\\n                root.height = 2\\n                return True\\n            return False\\n        elif self.isBalanced(root.left) and self.isBalanced(root.right):\\n            if abs(root.left.height - root.right.height) <= 1:\\n                root.height = max(root.left.height, root.right.height) + 1\\n                return True\\n            return False\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def is_leaf(self, root: TreeNode) -> bool:\\n        return not root.left and not root.right\\n\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        if not root:\\n            return True\\n\\n        if self.is_leaf(root):\\n            root.height = 1\\n            return True\\n        elif not root.left and root.right:\\n            if self.is_leaf(root.right):\\n                root.height = 2\\n                return True\\n            return False\\n        elif root.left and not root.right:\\n            if self.is_leaf(root.left):\\n                root.height = 2\\n                return True\\n            return False\\n        elif self.isBalanced(root.left) and self.isBalanced(root.right):\\n            if abs(root.left.height - root.right.height) <= 1:\\n                root.height = max(root.left.height, root.right.height) + 1\\n                return True\\n            return False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436499,
                "title": "python-beats-99-40ms",
                "content": "```\\nclass Solution:\\n    def depth(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        hl = self.depth(root.left) + 1\\n        hr = self.depth(root.right) + 1\\n        if abs(hl - hr) > 1:\\n            raise Exception(\"Sorry, the tree is unbalanced\")\\n        else:\\n            return max(hl, hr)\\n        \\n    def isBalanced(self, root: TreeNode) -> bool:\\n        try:\\n            self.depth(root)\\n        except:\\n            return False\\n        return True\\n```\\nabout try and excpet: https://www.w3schools.com/python/python_try_except.asp",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def depth(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0\\n        hl = self.depth(root.left) + 1\\n        hr = self.depth(root.right) + 1\\n        if abs(hl - hr) > 1:\\n            raise Exception(\"Sorry, the tree is unbalanced\")\\n        else:\\n            return max(hl, hr)\\n        \\n    def isBalanced(self, root: TreeNode) -> bool:\\n        try:\\n            self.depth(root)\\n        except:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320623,
                "title": "c-99-short-short-solution-no-comments-hard-to-read",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        int aDepth = 0;\\n        return isBalanced(root, aDepth);\\n    }\\n    \\n    bool isBalanced(TreeNode *root, int &depth) {\\n        if (root == NULL) return true;\\n        int aLeftHeight = depth + 1, aRightHeight = depth + 1;\\n        if (!isBalanced(root->left,  aLeftHeight ) || !isBalanced(root->right, aRightHeight)) { return false; }\\n        depth = max(aLeftHeight, aRightHeight);\\n        if (abs(aLeftHeight - aRightHeight) > 1) { return false; }\\n        return true;\\n    }\\n    \\n};\\n```\\n\\nBasically, this is a win.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        int aDepth = 0;\\n        return isBalanced(root, aDepth);\\n    }\\n    \\n    bool isBalanced(TreeNode *root, int &depth) {\\n        if (root == NULL) return true;\\n        int aLeftHeight = depth + 1, aRightHeight = depth + 1;\\n        if (!isBalanced(root->left,  aLeftHeight ) || !isBalanced(root->right, aRightHeight)) { return false; }\\n        depth = max(aLeftHeight, aRightHeight);\\n        if (abs(aLeftHeight - aRightHeight) > 1) { return false; }\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320194,
                "title": "swift-o-n-speed-o-n-space-recursive-solution-slick-moves-rick",
                "content": "```\\nclass Solution {\\n    \\n    func isBalanced(_ root: TreeNode?) -> Bool {\\n        var md: Int = 0\\n        return isBalanced(root, &md)\\n    }\\n    \\n    func isBalanced(_ root: TreeNode?, _ max_depth: inout Int) -> Bool {\\n        \\n        guard var root = root else { return true }\\n        \\n        var depth_left: Int = max_depth + 1\\n        if isBalanced(root.left, &depth_left) == false { return false }\\n        \\n        var depth_right: Int = max_depth + 1\\n        if isBalanced(root.right, &depth_right) == false { return false }\\n        \\n        max_depth = max(depth_left, depth_right) \\n        \\n        if abs(depth_left - depth_right) > 1 { return false }\\n        \\n        return true\\n    }\\n}\\n```\\n\\nCode so tight it makes toddlers wanna fight over yo yo\\'s and go-pros.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    func isBalanced(_ root: TreeNode?) -> Bool {\\n        var md: Int = 0\\n        return isBalanced(root, &md)\\n    }\\n    \\n    func isBalanced(_ root: TreeNode?, _ max_depth: inout Int) -> Bool {\\n        \\n        guard var root = root else { return true }\\n        \\n        var depth_left: Int = max_depth + 1\\n        if isBalanced(root.left, &depth_left) == false { return false }\\n        \\n        var depth_right: Int = max_depth + 1\\n        if isBalanced(root.right, &depth_right) == false { return false }\\n        \\n        max_depth = max(depth_left, depth_right) \\n        \\n        if abs(depth_left - depth_right) > 1 { return false }\\n        \\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184635,
                "title": "python-o-n-solution-beats-100",
                "content": "O(N) Python solution with single recursive pass. Beats 100%. \n\n```\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        return self.getBalancedHeight(root, 0) >= 0\n        \n    def getBalancedHeight(self, root, height):\n        \n        if not root:\n            return height\n        \n        l = self.getBalancedHeight(root.left, height+1)\n        r = self.getBalancedHeight(root.right, height+1)\n        \n        if l == -1 or r == -1 or abs(l-r) > 1:\n            return -1\n        \n        return max(l, r) \n```\n\n",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        return self.getBalancedHeight(root, 0) >= 0\n        \n    def getBalancedHeight(self, root, height):\n        \n        if not root:\n            return height\n        \n        l = self.getBalancedHeight(root.left, height+1)\n        r = self.getBalancedHeight(root.right, height+1)\n        \n        if l == -1 or r == -1 or abs(l-r) > 1:\n            return -1\n        \n        return max(l, r) \n```",
                "codeTag": "Java"
            },
            {
                "id": 35741,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Balanced Binary Tree** https://leetcode.com/problems/balanced-binary-tree/?tab=Description\\n\\n**Brute Force**\\n* Traverse and find height at each node. Test if it is balanced and subsequently recursively call on root.left and root.right. What is time complexity? How many times is node \"touched\" or called? Answer is at max \"h\" times (i.e. path from node to root), where h is the height of the tree. Visualize it. Now **if the tree is balanced, we have O(NLgN), otherwise worst case is O(N^2). The accurate complexity is O(Nh) and space complexity is O(h).**\\n\\n**Post-Order Algorithm**\\n* Optimization is using post order traversal - test height and balance in one call and propogate it upwards. In Python, we can return two variables. In other languages, we can return an error code in height. Complexity O(N) and space is O(h).\\n\\n```\\nclass Solution(object):\\n    def helper(self, root):\\n        if root == None:\\n            return 0, True\\n        hl, lb = self.helper(root.left)\\n        hr, rb = self.helper(root.right)\\n        if lb and rb and abs(hl-hr) <= 1:\\n            return max(hl,hr) + 1, True\\n        else:\\n            return -1, False\\n\\n    def isBalanced(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        h, is_b = self.helper(root)\\n        return is_b\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def helper(self, root):\\n        if root == None:\\n            return 0, True\\n        hl, lb = self.helper(root.left)\\n        hr, rb = self.helper(root.right)\\n        if lb and rb and abs(hl-hr) <= 1:\\n            return max(hl,hr) + 1, True\\n        else:\\n            return -1, False\\n\\n    def isBalanced(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        h, is_b = self.helper(root)\\n        return is_b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35833,
                "title": "java-1ms-solution-with-explanation",
                "content": "    public class Solution {\\n        public boolean isBalanced(TreeNode root) {\\n            return checkBalance(root) == -1 ? false : true;\\n        }\\n        \\n        // 1. If a subtree is hit as unbalanced, the whole tree is unbalanced. In this case, -1 is set as the return value.\\n        // 2. If the left subtree and the right subtree of a node are balanced, there are two more cases:\\n        // 2.1. The tree rooted at the node is unbalanced (the depth of its two subtrees differs by more than 1), as a result, -1 is returned.\\n        // 2.2 The tree rooted at the node is balanced, then the depth of the tree will be returned.\\n        public int checkBalance(TreeNode node){\\n            if (node == null) // case 2.2\\n                return 0;\\n                \\n            int left = checkBalance(node.left);\\n            if (left == -1) // check case 1\\n                return -1;\\n                \\n            int right = checkBalance(node.right);\\n            if (right == -1) // check case 1\\n                return -1;\\n            \\n            if (left - right > 1 || right - left > 1)\\n                return -1; // check case 2.1\\n            \\n            return (left > right ? left : right) + 1; // case 2.2\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isBalanced(TreeNode root) {\\n            return checkBalance(root) == -1 ? false : true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 35897,
                "title": "explain-test-case-1-null-2-null-3",
                "content": "I don't really get this case at all!  How does the root's left child (null) have children?\\n\\nFrom this test case [1, null, 2, null, 3] I gather that the tree looks like\\n\\n            1\\n           /  \\\\\\n         #     2\\n        /  \\\\\\n      #     3\\n\\nHow is that possible?",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "I don't really get this case at all!  How does the root's left child (null) have children?\\n\\nFrom this test case [1, null, 2, null, 3] I gather that the tree looks like\\n\\n            1\\n           /  \\\\\\n         #     2\\n        /  \\\\\\n      #     3\\n\\nHow is that possible?",
                "codeTag": "Unknown"
            },
            {
                "id": 3904358,
                "title": "c-simple-recursive-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nValues in recursion are returned from bottom to top\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate height of the tree and in each recursive call check wether the left and right subtree satisfy the constraint\\n# Complexity\\n- Time complexity: O(N) where N is number of Nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(height of binary tree) due to recursion\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    bool ans;\\n\\n    int getHt(TreeNode* root){\\n        if(!root) return 0;\\n        int lst = getHt(root->left);\\n        int rst = getHt(root->right);\\n        if(abs(lst-rst) > 1) ans = false;\\n        return 1 + max(lst, rst);\\n\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        ans = true;\\n        getHt(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    bool ans;\\n\\n    int getHt(TreeNode* root){\\n        if(!root) return 0;\\n        int lst = getHt(root->left);\\n        int rst = getHt(root->right);\\n        if(abs(lst-rst) > 1) ans = false;\\n        return 1 + max(lst, rst);\\n\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        ans = true;\\n        getHt(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513449,
                "title": "c-easy-solution-beats-98-4-time-and-95-77-memory",
                "content": "![image.png](https://assets.leetcode.com/users/images/cabc84d2-6966-4448-82f7-8d6b514ad64f_1683829505.151007.png)\\n\\n\\n# Intuition\\n\\nIn order to determine if a Tree is balanced or not you will have to take into consideration the balance of the current level you are on, and the height of the current level. \\n\\nAt any point you find a level that is not balanced, you change the bool value to false as if that level is not balanced, that means your entire tree is not balanced.\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    // height is the max of the left and right subtree + 1\\n    // balance factor is the height of the left subtree - the height of the right subtree\\n    bool isBalanced(TreeNode *root)\\n    {\\n        bool result = true;\\n        helper(root, result);\\n\\n        return result;\\n    }\\n\\n    int helper(TreeNode *root, bool& balanced)\\n    {\\n        // base case if current node is null\\n        // if the boolean has been set to false\\n        // we do not care about the rest of the nodes\\n        // as it is already unbalanced\\n        if (root == nullptr || balanced == false)\\n        {\\n            return 0;\\n        }\\n        // traverse the left and right subtree until you reach a null node.\\n        int left_height = helper(root->left, balanced);\\n        int right_height = helper(root->right, balanced);\\n\\n        // calculate the balance factor of the current level\\n        if (abs(left_height - right_height) > 1)\\n        {\\n            balanced = false;\\n        }\\n        //returns the height of the current level\\n        return max(left_height, right_height) + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    // height is the max of the left and right subtree + 1\\n    // balance factor is the height of the left subtree - the height of the right subtree\\n    bool isBalanced(TreeNode *root)\\n    {\\n        bool result = true;\\n        helper(root, result);\\n\\n        return result;\\n    }\\n\\n    int helper(TreeNode *root, bool& balanced)\\n    {\\n        // base case if current node is null\\n        // if the boolean has been set to false\\n        // we do not care about the rest of the nodes\\n        // as it is already unbalanced\\n        if (root == nullptr || balanced == false)\\n        {\\n            return 0;\\n        }\\n        // traverse the left and right subtree until you reach a null node.\\n        int left_height = helper(root->left, balanced);\\n        int right_height = helper(root->right, balanced);\\n\\n        // calculate the balance factor of the current level\\n        if (abs(left_height - right_height) > 1)\\n        {\\n            balanced = false;\\n        }\\n        //returns the height of the current level\\n        return max(left_height, right_height) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477194,
                "title": "c-solution-easy-with-explanation",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int checkBalanse(TreeNode* root, bool& res) {\\n        // if root = null or result already false\\n        if (!root || !res) return 0;\\n\\n        // find height for left and right nodes\\n        int left_height = checkBalanse(root->left, res);\\n        int right_height = checkBalanse(root->right, res);\\n        if (abs(left_height - right_height) > 1)\\n            res = false;\\n        \\n        return max(left_height, right_height) + 1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        bool res = true;\\n        checkBalanse(root, res);\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int checkBalanse(TreeNode* root, bool& res) {\\n        // if root = null or result already false\\n        if (!root || !res) return 0;\\n\\n        // find height for left and right nodes\\n        int left_height = checkBalanse(root->left, res);\\n        int right_height = checkBalanse(root->right, res);\\n        if (abs(left_height - right_height) > 1)\\n            res = false;\\n        \\n        return max(left_height, right_height) + 1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        bool res = true;\\n        checkBalanse(root, res);\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308944,
                "title": "clear-c-solution-let-s-find-best-solution-together",
                "content": "**`If you have any thought feel free leave a comment below...`** \\n```\\n/* Definition for a binary tree node.                   */\\n/* struct TreeNode {                                    */\\n/*     int val;                                         */\\n/*     struct TreeNode *left;                           */\\n/*     struct TreeNode *right;                          */\\n/* };                                                   */\\nint depth(struct TreeNode *root);\\n\\nbool isBalanced(struct TreeNode *root) {\\n    if (root == NULL)\\n        return true;\\n        \\n    return isBalanced(root->left) && \\n           isBalanced(root->right) &&\\n           !(abs(depth(root->left) - depth(root->right)) > 1);\\n}\\n\\nint depth(struct TreeNode *root) {\\n    if (root == NULL)\\n        return 0;\\n        \\n    return fmax(depth(root->left), depth(root->right)) + 1;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/* Definition for a binary tree node.                   */\\n/* struct TreeNode {                                    */\\n/*     int val;                                         */\\n/*     struct TreeNode *left;                           */\\n/*     struct TreeNode *right;                          */\\n/* };                                                   */\\nint depth(struct TreeNode *root);\\n\\nbool isBalanced(struct TreeNode *root) {\\n    if (root == NULL)\\n        return true;\\n        \\n    return isBalanced(root->left) && \\n           isBalanced(root->right) &&\\n           !(abs(depth(root->left) - depth(root->right)) > 1);\\n}\\n\\nint depth(struct TreeNode *root) {\\n    if (root == NULL)\\n        return 0;\\n        \\n    return fmax(depth(root->left), depth(root->right)) + 1;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2871047,
                "title": "python-video-solution",
                "content": "I have explained this in a [video](https://youtu.be/dQp1oSkpyb4).\\n\\n# Intuition\\nA Binary Tree is balanced if:\\n* Left Subtree is balanced\\n* Right Subtree is balanced\\n* Difference of height of left & right subtree is atmost 1 `[0,1]`.\\n\\n\\nIn our `dfs`, we\\'ll return two things:\\n* Whether this subtree is balanced.\\n* Height of subtree\\n\\nIf you thought this was helpful, please upvote, like the video and subscribe to the channel.\\n\\nCheers.\\n\\n\\n```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        \\n        # is_balanced, height\\n        def dfs(root):\\n            if not root:\\n                return True, 0\\n            \\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            \\n            return left[0] and right[0] \\\\\\n                and abs(left[1]-right[1]) <= 1 \\\\\\n                , 1 + max(left[1], right[1])\\n        \\n        return dfs(root)[0]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "I have explained this in a [video](https://youtu.be/dQp1oSkpyb4).\\n\\n# Intuition\\nA Binary Tree is balanced if:\\n* Left Subtree is balanced\\n* Right Subtree is balanced\\n* Difference of height of left & right subtree is atmost 1 `[0,1]`.\\n\\n\\nIn our `dfs`, we\\'ll return two things:\\n* Whether this subtree is balanced.\\n* Height of subtree\\n\\nIf you thought this was helpful, please upvote, like the video and subscribe to the channel.\\n\\nCheers.\\n\\n\\n```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        \\n        # is_balanced, height\\n        def dfs(root):\\n            if not root:\\n                return True, 0\\n            \\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            \\n            return left[0] and right[0] \\\\\\n                and abs(left[1]-right[1]) <= 1 \\\\\\n                , 1 + max(left[1], right[1])\\n        \\n        return dfs(root)[0]",
                "codeTag": "Java"
            },
            {
                "id": 2705638,
                "title": "faster-than-99-java",
                "content": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n         if (root == null) {\\n            return true;\\n    //All Nodes in the tree have an Absolute Difference of Left Height & Right Height not more than 1.\\n        } else if (Math.abs(height(root.left) - height(root.right)) > 1) {\\n            return false;\\n        } else {\\n            return isBalanced(root.left) && isBalanced(root.right); \\n        }\\n    }\\n    \\n    public static int height(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int lheight = height(root.left);\\n        int rheight = height(root.right);\\n        return Math.max(lheight,rheight)+1;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n         if (root == null) {\\n            return true;\\n    //All Nodes in the tree have an Absolute Difference of Left Height & Right Height not more than 1.\\n        } else if (Math.abs(height(root.left) - height(root.right)) > 1) {\\n            return false;\\n        } else {\\n            return isBalanced(root.left) && isBalanced(root.right); \\n        }\\n    }\\n    \\n    public static int height(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int lheight = height(root.left);\\n        int rheight = height(root.right);\\n        return Math.max(lheight,rheight)+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609296,
                "title": "java-2-solutions",
                "content": "First method is simply go by the definition. For every node in tree, check if its left or right is balanced or not.\\n\\n```\\npublic boolean isBalanced(TreeNode root) {\\n        if(root==null) return true;\\n        \\n        int leftH= findH(root.left);\\n        int rightH= findH(root.right);\\n        \\n        if(Math.abs(leftH- rightH) > 1) return false;\\n        \\n        boolean left= isBalanced(root.left);\\n        boolean right = isBalanced(root.right);\\n        \\n        return left&&right;\\n    }\\n    \\n    private int findH( TreeNode root){\\n        if(root==null) return 0;\\n        \\n        int l = findH(root.left);\\n        int r= findH( root.right);\\n        \\n        return 1 + Math.max(l, r);\\n    }\\n```\\n\\n```\\nTC: O(N^2) \\n```\\n\\nTo optimise, we can elimiate checking twice. If left and right at any point return a -1, we wil not check further\\n\\n```\\npublic boolean isBalanced(TreeNode root) {\\n        if(root==null) return true;\\n        \\n        if(findH(root)==-1) return false;\\n        return true;\\n    }\\n    \\n    private int findH( TreeNode root){\\n        if(root==null) return 0;\\n        \\n        int l = findH(root.left);\\n        if(l==-1) return -1;\\n        int r= findH( root.right);\\n        if(r==-1) return -1;\\n        \\n        if(Math.abs(l -r ) > 1) return -1;\\n        \\n        return 1 + Math.max(l, r);\\n    }\\n```\\n\\n```\\nTC: O(N)\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean isBalanced(TreeNode root) {\\n        if(root==null) return true;\\n        \\n        int leftH= findH(root.left);\\n        int rightH= findH(root.right);\\n        \\n        if(Math.abs(leftH- rightH) > 1) return false;\\n        \\n        boolean left= isBalanced(root.left);\\n        boolean right = isBalanced(root.right);\\n        \\n        return left&&right;\\n    }\\n    \\n    private int findH( TreeNode root){\\n        if(root==null) return 0;\\n        \\n        int l = findH(root.left);\\n        int r= findH( root.right);\\n        \\n        return 1 + Math.max(l, r);\\n    }\\n```\n```\\nTC: O(N^2) \\n```\n```\\npublic boolean isBalanced(TreeNode root) {\\n        if(root==null) return true;\\n        \\n        if(findH(root)==-1) return false;\\n        return true;\\n    }\\n    \\n    private int findH( TreeNode root){\\n        if(root==null) return 0;\\n        \\n        int l = findH(root.left);\\n        if(l==-1) return -1;\\n        int r= findH( root.right);\\n        if(r==-1) return -1;\\n        \\n        if(Math.abs(l -r ) > 1) return -1;\\n        \\n        return 1 + Math.max(l, r);\\n    }\\n```\n```\\nTC: O(N)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575017,
                "title": "javascript-solution-88-ms-top-down-recursion",
                "content": "### Solution:\\n```js\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nconst height = (node) => {\\n    if (node === null) {\\n        return -1;\\n    }\\n    return 1 + Math.max(height(node.left), height(node.right));\\n}\\n\\nvar isBalanced = function(root) {\\n    if (root === null) {\\n        return true;\\n    } else {\\n        let diff = Math.abs(height(root.left) - height(root.right));\\n        return diff < 2\\n            && isBalanced(root.left)\\n            && isBalanced(root.right);\\n    }\\n};\\n```\\n\\n### LeetCode Output:\\nRuntime: **88 ms**, faster than **83.71%** of JavaScript online submissions for Balanced Binary Tree.\\nMemory Usage: **47.4 MB**, less than **45.49%** of JavaScript online submissions for Balanced Binary Tree.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nconst height = (node) => {\\n    if (node === null) {\\n        return -1;\\n    }\\n    return 1 + Math.max(height(node.left), height(node.right));\\n}\\n\\nvar isBalanced = function(root) {\\n    if (root === null) {\\n        return true;\\n    } else {\\n        let diff = Math.abs(height(root.left) - height(root.right));\\n        return diff < 2\\n            && isBalanced(root.left)\\n            && isBalanced(root.right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2338219,
                "title": "c-solution-easy-to-understand-o-n",
                "content": "class Solution {\\npublic:\\n    \\n    bool isBalanced(TreeNode* root) {\\n        \\n            return dfsHeight(root) != -1;\\n        \\n    }\\n    int dfsHeight(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        int leftHeight = dfsHeight(root ->left);\\n        \\n        if(leftHeight  == -1)\\n            return -1;\\n        int rightHeight = dfsHeight(root ->right);\\n        if(rightHeight ==-1)\\n            return -1;\\n        if(abs(leftHeight -rightHeight)>1)\\n            return -1;\\n        return 1+max(leftHeight, rightHeight);\\n    }\\n        \\n    // please upvote if it is helpfull\\n};****",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool isBalanced(TreeNode* root) {\\n        \\n            return dfsHeight(root) != -1;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2099598,
                "title": "python3-o-n-time-o-1-space-optimal-solution-2-approaches",
                "content": "```\\n\\'\\'\\'\\nclass Solution:\\n    def isBalanced(self, root):\\n        if not root: return True\\n        return abs(self.height(root.left) - self.height(root.right)) < 2 and self.isBalanced(root.left) and self.isBalanced(root.right)\\n\\n    def height(self, root):\\n        if not root: return 0\\n        return 1 + max(self.height(root.left), self.height(root.right))\\n\\n# Time: O(N^2)\\n# Auxiliary Space: O(N)\\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def isBalanced(self, root):\\n        \\n        def dfs(root):\\n            if not root: return True, 0  \\n            \\n            lb, lh = dfs(root.left)      \\n            rb, rh = dfs(root.right)\\n            \\n            b = abs(lh - rh) <= 1 and lb and rb\\n            return b, 1 + max(lh, rh)\\n        \\n        b, h = dfs(root)\\n        return b\\n    \\n# Time: O(N)\\n# Auxiliary Space: O(N)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\'\\'\\'\\nclass Solution:\\n    def isBalanced(self, root):\\n        if not root: return True\\n        return abs(self.height(root.left) - self.height(root.right)) < 2 and self.isBalanced(root.left) and self.isBalanced(root.right)\\n\\n    def height(self, root):\\n        if not root: return 0\\n        return 1 + max(self.height(root.left), self.height(root.right))\\n\\n# Time: O(N^2)\\n# Auxiliary Space: O(N)\\n\\'\\'\\'\\n\\n\\nclass Solution:\\n    def isBalanced(self, root):\\n        \\n        def dfs(root):\\n            if not root: return True, 0  \\n            \\n            lb, lh = dfs(root.left)      \\n            rb, rh = dfs(root.right)\\n            \\n            b = abs(lh - rh) <= 1 and lb and rb\\n            return b, 1 + max(lh, rh)\\n        \\n        b, h = dfs(root)\\n        return b\\n    \\n# Time: O(N)\\n# Auxiliary Space: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879250,
                "title": "easy-solution-0ms-41-9mb-java",
                "content": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        if(root == null)\\n        {\\n            return true;\\n        }\\n        int lh = height(root.left);\\n        int rh = height(root.right);\\n        return Math.abs(lh - rh) <= 1 && isBalanced(root.left) && isBalanced(root.right);\\n        \\n    }\\n    \\n    public int height(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            return 0;\\n        }\\n        return Math.max(height(root.left) , height(root.right)) + 1;\\n    }\\n}\\n```\\nIf my solution helped you please **UPVOTE**",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        if(root == null)\\n        {\\n            return true;\\n        }\\n        int lh = height(root.left);\\n        int rh = height(root.right);\\n        return Math.abs(lh - rh) <= 1 && isBalanced(root.left) && isBalanced(root.right);\\n        \\n    }\\n    \\n    public int height(TreeNode root)\\n    {\\n        if(root == null)\\n        {\\n            return 0;\\n        }\\n        return Math.max(height(root.left) , height(root.right)) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709558,
                "title": "c-solution-with-thorough-explanation-and-example",
                "content": "# C++ Easy solution\\n**Approach** : As the question suggests we need to find if the tree isBalanced or not, we are pretty sure, we need to check the height difference of right and left subtrees and if the absolute difference between them is smaller than 1 than it is balanced. \\nBut what we need to make sure is that we need to check this on each subtree and subtree\\'s root as well. For example, if the main root\\'s left subtree\\'s height is 3 and right subtree\\'s height is 3/4. We might conclude that it is a balanced Tree. \\n**WRONG**. It might happen that the left/right subtree itself is not balanced.\\n\\nTo make this example clear, let\\'s take the following tree : \\n***Input : [1,1,1,1,null,null,1,1,null,null,1]***\\n![image](https://assets.leetcode.com/users/images/b514fd15-8502-429f-8e4b-65b92fcc5350_1642864077.3461108.png)\\n\\nIn this case, we can see that left and right subtree\\'s height is 3 for both. But if we look closely the left or right subtree\\'s themselves aren\\'t balanced. \\n\\nIn conclusion it gives us that we need two values from each subtree. One is if the subtree on either side is a balanced tree or not and their height/depths as well.\\nThis is the reason why I have used PAIR here. The pair from each subtree can store both the values as mentioned above.\\n\\npair = ***{height of subtree, subtree is balanced or not}***\\n\\n**h1** = height of left subtree , **b1** = left subtree is balanced or not\\n**h2** = height of right subtree , **b2** = right subtree is balanced or not\\n\\n```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        pair <int, bool> p;\\n        p = fun(root);\\n        return p.second;\\n    }\\n    \\n    pair<int,bool> fun(TreeNode* root) {\\n        if(!root) return {0,true};\\n        pair<int,bool> p1,p2;\\n        p1 = fun(root->left);\\n        p2 = fun(root->right);\\n        int h1= p1.first,h2=p2.first;\\n        bool b1 = p1.second,b2 = p2.second;\\n\\t\\t// checking if absolute differences between the hieghts/depth of the two subtrees is smaller than 1 or not and \\n\\t\\t// also checking if the subtree\\'s individually are balacned or not also calculating the height for the root node\\n        return {1 + max(h1,h2) , b1 && b2 && (abs(h2-h1) <= 1)};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        pair <int, bool> p;\\n        p = fun(root);\\n        return p.second;\\n    }\\n    \\n    pair<int,bool> fun(TreeNode* root) {\\n        if(!root) return {0,true};\\n        pair<int,bool> p1,p2;\\n        p1 = fun(root->left);\\n        p2 = fun(root->right);\\n        int h1= p1.first,h2=p2.first;\\n        bool b1 = p1.second,b2 = p2.second;\\n\\t\\t// checking if absolute differences between the hieghts/depth of the two subtrees is smaller than 1 or not and \\n\\t\\t// also checking if the subtree\\'s individually are balacned or not also calculating the height for the root node\\n        return {1 + max(h1,h2) , b1 && b2 && (abs(h2-h1) <= 1)};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194642,
                "title": "java-solution",
                "content": "class Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return checkSubTree(root)>=0;\\n       \\n    }\\n    public int checkSubTree(TreeNode root)\\n    {\\n        if(root==null)\\n            return 0;\\n        if(root.left==null && root.right==null)\\n            return 1;\\n    \\n        int l=checkSubTree(root.left);\\n        int r=checkSubTree(root.right);\\n        \\n      if(l>=0 && r>=0 && Math.abs(l-r)<2)\\n          return 1+ Math.max(l,r);\\n        \\n       return -1; \\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return checkSubTree(root)>=0;\\n       \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1121764,
                "title": "java-iterative-and-recursive",
                "content": "The recursive version uses -1 to signal imbalance, which means the rest of the tree need not be examined. This will help reduce runtime from O(N^2) to O(N). \\n\\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return getDepth(root) != -1;\\n    }\\n    \\n    private int getDepth(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        int leftHeight = getDepth(root.left);\\n        if(leftHeight == -1) return -1;\\n        \\n        int rightHeight = getDepth(root.right);\\n        if(rightHeight == -1) return -1;\\n        \\n        if(Math.abs(leftHeight - rightHeight) > 1) return -1;\\n        \\n        return 1 + Math.max(leftHeight, rightHeight);\\n    }\\n    \\n}\\n```\\nFor iterative solution, we will use postorder traversal. \\nWe move left, store heights of all nodes in a map. Then move right, store heights of all nodes in a map again. Then compare height of stack\\'s peek\\'s left and right nodes(which have been stored in our map), and proceed accordingly.\\n```\\nclass Solution{\\n    public boolean isBalanced(TreeNode root){\\n        if(root == null) return true;\\n        Map<TreeNode, Integer> heights = new HashMap<>();\\n        ArrayDeque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode curr = stack.peek();\\n            if(curr.left != null && !heights.containsKey(curr.left)){\\n                curr = curr.left;\\n                stack.push(curr);\\n            }\\n            else if(curr.right != null && !heights.containsKey(curr.right)){\\n                curr = curr.right;\\n                stack.push(curr);\\n            }\\n            else{\\n                int leftHeight = curr.left == null? 0: heights.get(curr.left);\\n                int rightHeight = curr.right == null? 0: heights.get(curr.right);\\n                if(Math.abs(leftHeight - rightHeight) > 1) return false;\\n                heights.put(curr, 1 + Math.max(leftHeight, rightHeight));\\n                stack.pop();\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nNote, the recursive version beats 100%, but the iterative version is much slower.\\nI reckon this is because of the overhead of using a Map. \\nI didn\\'t find any solution in the Discussion having an iterative version without a map, so suggestions are welcome.\\nHope this helps.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return getDepth(root) != -1;\\n    }\\n    \\n    private int getDepth(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        int leftHeight = getDepth(root.left);\\n        if(leftHeight == -1) return -1;\\n        \\n        int rightHeight = getDepth(root.right);\\n        if(rightHeight == -1) return -1;\\n        \\n        if(Math.abs(leftHeight - rightHeight) > 1) return -1;\\n        \\n        return 1 + Math.max(leftHeight, rightHeight);\\n    }\\n    \\n}\\n```\n```\\nclass Solution{\\n    public boolean isBalanced(TreeNode root){\\n        if(root == null) return true;\\n        Map<TreeNode, Integer> heights = new HashMap<>();\\n        ArrayDeque<TreeNode> stack = new ArrayDeque<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode curr = stack.peek();\\n            if(curr.left != null && !heights.containsKey(curr.left)){\\n                curr = curr.left;\\n                stack.push(curr);\\n            }\\n            else if(curr.right != null && !heights.containsKey(curr.right)){\\n                curr = curr.right;\\n                stack.push(curr);\\n            }\\n            else{\\n                int leftHeight = curr.left == null? 0: heights.get(curr.left);\\n                int rightHeight = curr.right == null? 0: heights.get(curr.right);\\n                if(Math.abs(leftHeight - rightHeight) > 1) return false;\\n                heights.put(curr, 1 + Math.max(leftHeight, rightHeight));\\n                stack.pop();\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098966,
                "title": "java-simple-and-easy-to-understand-recursive-dfs-sol-0-ms-faster-than-100-00-clean-code",
                "content": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return dfs(root).balanced;\\n    }\\n    \\n    private Result dfs(TreeNode node){\\n        if(node == null) return new Result(true, 0);\\n        \\n        //get left result\\n        Result leftSubtree = dfs(node.left);\\n        \\n        //check left subtree balanced or not\\n        //if not balanced, no need to look futher\\n        if(!leftSubtree.balanced) return new Result(false, 0);\\n        \\n        \\n        //get right subtree result\\n        Result rightSubtree = dfs(node.right);\\n        \\n        //check left subtree balanced or not\\n        //if not balanced, no need to look futher\\n        if(!rightSubtree.balanced) return new Result(false, 0);\\n        \\n        \\n        //height diff between both subtree\\n        int heightDiff = Math.abs(leftSubtree.height - rightSubtree.height);\\n        if(heightDiff > 1) return new Result(false, 0);\\n        \\n        //find the maximum height \\n        int maxheight =  Math.max(leftSubtree.height, rightSubtree.height);\\n        \\n        //add 1(for this node) to the maxheight\\n        return new Result(true, maxheight + 1);\\n    }\\n}\\n\\nclass Result {\\n    boolean balanced;\\n    int height;\\n    \\n    public Result(boolean balanced, int height){\\n        this.balanced = balanced;\\n        this.height = height;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return dfs(root).balanced;\\n    }\\n    \\n    private Result dfs(TreeNode node){\\n        if(node == null) return new Result(true, 0);\\n        \\n        //get left result\\n        Result leftSubtree = dfs(node.left);\\n        \\n        //check left subtree balanced or not\\n        //if not balanced, no need to look futher\\n        if(!leftSubtree.balanced) return new Result(false, 0);\\n        \\n        \\n        //get right subtree result\\n        Result rightSubtree = dfs(node.right);\\n        \\n        //check left subtree balanced or not\\n        //if not balanced, no need to look futher\\n        if(!rightSubtree.balanced) return new Result(false, 0);\\n        \\n        \\n        //height diff between both subtree\\n        int heightDiff = Math.abs(leftSubtree.height - rightSubtree.height);\\n        if(heightDiff > 1) return new Result(false, 0);\\n        \\n        //find the maximum height \\n        int maxheight =  Math.max(leftSubtree.height, rightSubtree.height);\\n        \\n        //add 1(for this node) to the maxheight\\n        return new Result(true, maxheight + 1);\\n    }\\n}\\n\\nclass Result {\\n    boolean balanced;\\n    int height;\\n    \\n    public Result(boolean balanced, int height){\\n        this.balanced = balanced;\\n        this.height = height;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984240,
                "title": "rust-dfs-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Balanced Binary Tree.\\nMemory Usage: 2.9 MB, less than 40.00% of Rust online submissions for Balanced Binary Tree.\\n```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_balanced(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        fn dfs(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n            match root {\\n                Some(root) => {\\n                    let left = dfs(root.borrow().left.clone());\\n                    let right = dfs(root.borrow().right.clone());\\n                    if (left-right).abs() > 1 || left == -1 || right == -1 {\\n                        return -1\\n                    }\\n                    left.max(right) + 1\\n                }\\n                None => 0\\n            }\\n        }\\n        dfs(root) != -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn is_balanced(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        fn dfs(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n            match root {\\n                Some(root) => {\\n                    let left = dfs(root.borrow().left.clone());\\n                    let right = dfs(root.borrow().right.clone());\\n                    if (left-right).abs() > 1 || left == -1 || right == -1 {\\n                        return -1\\n                    }\\n                    left.max(right) + 1\\n                }\\n                None => 0\\n            }\\n        }\\n        dfs(root) != -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950460,
                "title": "intuitive-python-solution-using-dfs-w-explanation",
                "content": "Using recursion, we check if the left subtree is balanced with the right subtree. If it is, the function returns the height of the combined subtree (max between left subtree height and right subtree height). If not, it returns -inf, so that every check involving that subtree fails.\\n\\n```\\ndef isBalanced(self, root: TreeNode) -> bool:\\n\\tdef r_balanced(tree, height):\\n\\t\\tif not tree:  # base case\\n\\t\\t\\treturn height\\n\\t\\tl = r_balanced(tree.left, height+1)\\n\\t\\tr = r_balanced(tree.right, height+1)\\n\\t\\treturn max(l, r) if abs(l-r) <= 1 else -float(\"inf\")\\n\\n\\treturn r_balanced(root, 0) >= 0\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef isBalanced(self, root: TreeNode) -> bool:\\n\\tdef r_balanced(tree, height):\\n\\t\\tif not tree:  # base case\\n\\t\\t\\treturn height\\n\\t\\tl = r_balanced(tree.left, height+1)\\n\\t\\tr = r_balanced(tree.right, height+1)\\n\\t\\treturn max(l, r) if abs(l-r) <= 1 else -float(\"inf\")\\n\\n\\treturn r_balanced(root, 0) >= 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 834525,
                "title": "simple-java-solution-100-speed",
                "content": "The `height` function is just a variation of the normal height but has dominating negative return values if the tree is observed to be unbalanced at any given time.\\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return height(root) < 0 ? false : true;\\n    }\\n    \\n    public int height(TreeNode root) {\\n        if (root == null) return 0;\\n        int leftHeight = height(root.left);\\n        int rightHeight = height(root.right);\\n        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) {\\n            return -1;\\n        }\\n        return Math.max(leftHeight, rightHeight) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return height(root) < 0 ? false : true;\\n    }\\n    \\n    public int height(TreeNode root) {\\n        if (root == null) return 0;\\n        int leftHeight = height(root.left);\\n        int rightHeight = height(root.right);\\n        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) {\\n            return -1;\\n        }\\n        return Math.max(leftHeight, rightHeight) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522883,
                "title": "super-easy-javascript-solution-beat-99-43-run-time-with-comment",
                "content": "```\\nvar isBalanced = function(root) {\\n    if(!root) return true\\n\\t// calculate the depth of each node\\n    const helper = (node, depth = 0) => {\\n        if (!node) return depth\\n        return Math.max(helper(node.right,depth+1), helper(node.left,depth+1))\\n    }\\n\\t\\n\\t// make sure different node have both side (right and left) and height between two of them not more than 1.\\n    return isBalanced(root.right) && isBalanced(root.left) && Math.abs(helper(root.right) - helper(root.left)) <= 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isBalanced = function(root) {\\n    if(!root) return true\\n\\t// calculate the depth of each node\\n    const helper = (node, depth = 0) => {\\n        if (!node) return depth\\n        return Math.max(helper(node.right,depth+1), helper(node.left,depth+1))\\n    }\\n\\t\\n\\t// make sure different node have both side (right and left) and height between two of them not more than 1.\\n    return isBalanced(root.right) && isBalanced(root.left) && Math.abs(helper(root.right) - helper(root.left)) <= 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 341882,
                "title": "python-beats-98-66-with-iteration",
                "content": "To calculate the height of each node, we need to obtain the children\\'s height.\\n\\nTherefore, I chosed postorder traversal to calculate children\\'s height first and stored it into a dictionary for later use. \\n```\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        # DFS, postorder\\n        # Iterative\\n        height_dict = {None:0}\\n        stack = [root]\\n        while stack:\\n            cur = stack.pop()\\n            if cur:\\n                if cur.left in height_dict and cur.right in height_dict:\\n                    lH = height_dict[cur.left]\\n                    rH = height_dict[cur.right]\\n                    if abs(lH - rH) > 1:\\n                        return False\\n                    else:\\n                        height_dict[cur] = max(lH, rH) + 1\\n                else:\\n                    stack.append(cur)\\n                    stack.append(cur.right)\\n                    stack.append(cur.left)\\n        return True\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        # DFS, postorder\\n        # Iterative\\n        height_dict = {None:0}\\n        stack = [root]\\n        while stack:\\n            cur = stack.pop()\\n            if cur:\\n                if cur.left in height_dict and cur.right in height_dict:\\n                    lH = height_dict[cur.left]\\n                    rH = height_dict[cur.right]\\n                    if abs(lH - rH) > 1:\\n                        return False\\n                    else:\\n                        height_dict[cur] = max(lH, rH) + 1\\n                else:\\n                    stack.append(cur)\\n                    stack.append(cur.right)\\n                    stack.append(cur.left)\\n        return True\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 252782,
                "title": "python-recursion",
                "content": "If any subtree is not balanced, the whole tree is not balanced. So we can come out with a recursive check to check each subtree.\\n\\nThe **check** basically checks two things: (1) if both left and right subtree are balanced (2) if depth gap between left and right subtree is smaller than two.\\nIf current subtree pass the check, we return it\\'s depth upwards for parent checking.\\n\\nTo check depth, we need to preserve the value of depth. Since final return value should be a boolean, I used a helper routine to perform check.\\n\\n```\\ndef isBalanced(root):\\n\\treturn bool(check(root))\\n\\ndef check(node):\\n\\tif not node: return True\\n\\tl, r = check(node.left), check(node.right)\\n\\treturn max(l, r) + 1 if l and r and abs(l-r) < 2 else False\\n```\\nTime complexity is O(n) as T(n) = 2T(n/2)+c and space complexity is O(1).",
                "solutionTags": [],
                "code": "```\\ndef isBalanced(root):\\n\\treturn bool(check(root))\\n\\ndef check(node):\\n\\tif not node: return True\\n\\tl, r = check(node.left), check(node.right)\\n\\treturn max(l, r) + 1 if l and r and abs(l-r) < 2 else False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 35727,
                "title": "accepted-iterative-java-solution",
                "content": "Iterative solution. Basically keeping track of the node and its height using a map and then making decisions based on that. \\n````\\npublic boolean isBalanced(TreeNode root) {\\n         if(root == null){\\n            return true;\\n        }\\n        Stack<TreeNode> nodeStack = new Stack<>();\\n        // This keeps a track of the height calculated for each node.\\n        // The height of a node in a tree is the length of a longest path from the node to a leaf.\\n        // If it has two paths of leafs with different heights. The max of them is the height of the node in this tree.\\n        Map<TreeNode,Integer> nodeHeightMap= new HashMap<>();\\n        nodeStack.push(root);\\n        while (!nodeStack.isEmpty()){\\n\\n            TreeNode node = nodeStack.peek();\\n            // The reason we are checking the map is we are looking if the height of a node has been calculated previously.\\n            if(node.left!=null && !nodeHeightMap.containsKey(node.left)){\\n                nodeStack.push(node.left);\\n            }\\n            else if( node.right!=null && !nodeHeightMap.containsKey(node.right)){\\n                nodeStack.push(node.right);\\n            }\\n            else {\\n                TreeNode nodePopped = nodeStack.pop();\\n                int leftSubTreeHeight = (nodePopped.left == null)?0:nodeHeightMap.get(nodePopped.left);\\n                int rightSubTreeHeight = (nodePopped.right == null)?0:nodeHeightMap.get(nodePopped.right);\\n                // Absolute value of the difference between the left and right subtree heights.\\n                int resultantHeightofNode = Math.abs(leftSubTreeHeight-rightSubTreeHeight);\\n                // If the left & right subtree heights differ by more than 1 then it's not balanced binary tree.\\n                if(resultantHeightofNode > 1){\\n                    return false;\\n                }\\n                nodeHeightMap.put(nodePopped,Math.max(leftSubTreeHeight,rightSubTreeHeight)+1);\\n            }\\n        }\\n        return true;\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\npublic boolean isBalanced(TreeNode root) {\\n         if(root == null){\\n            return true;\\n        }\\n        Stack<TreeNode> nodeStack = new Stack<>();\\n        // This keeps a track of the height calculated for each node.\\n        // The height of a node in a tree is the length of a longest path from the node to a leaf.\\n        // If it has two paths of leafs with different heights. The max of them is the height of the node in this tree.\\n        Map<TreeNode,Integer> nodeHeightMap= new HashMap<>();\\n        nodeStack.push(root);\\n        while (!nodeStack.isEmpty()){\\n\\n            TreeNode node = nodeStack.peek();\\n            // The reason we are checking the map is we are looking if the height of a node has been calculated previously.\\n            if(node.left!=null && !nodeHeightMap.containsKey(node.left)){\\n                nodeStack.push(node.left);\\n            }\\n            else if( node.right!=null && !nodeHeightMap.containsKey(node.right)){\\n                nodeStack.push(node.right);\\n            }\\n            else {\\n                TreeNode nodePopped = nodeStack.pop();\\n                int leftSubTreeHeight = (nodePopped.left == null)?0:nodeHeightMap.get(nodePopped.left);\\n                int rightSubTreeHeight = (nodePopped.right == null)?0:nodeHeightMap.get(nodePopped.right);\\n                // Absolute value of the difference between the left and right subtree heights.\\n                int resultantHeightofNode = Math.abs(leftSubTreeHeight-rightSubTreeHeight);\\n                // If the left & right subtree heights differ by more than 1 then it's not balanced binary tree.\\n                if(resultantHeightofNode > 1){\\n                    return false;\\n                }\\n                nodeHeightMap.put(nodePopped,Math.max(leftSubTreeHeight,rightSubTreeHeight)+1);\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35808,
                "title": "please-help-with-test-case-1-2-2-3-null-null-3-4-null-null-4",
                "content": "201/226 test cases passed, but broke at  [1,2,2,3,null,null,3,4,null,null,4] this input, I think my algo returning correct answer that is True but expected answer is flase, can someone explain ???\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    \\n    def CalcDepth(self,node):\\n            if node:\\n                return( 1+max(self.CalcDepth(node.left),self.CalcDepth(node.right)))\\n            else:\\n                return 0\\n    \\n    def isBalanced(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if root:\\n            print(self.CalcDepth(root.left) , self.CalcDepth(root.right))\\n            return( abs(self.CalcDepth(root.left) - self.CalcDepth(root.right) ) <= 1 )\\n        return True\\n        \\n        \\n            \\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    \\n    def CalcDepth(self,node):\\n            if node:\\n                return( 1+max(self.CalcDepth(node.left),self.CalcDepth(node.right)))\\n            else:\\n                return 0\\n    \\n    def isBalanced(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if root:\\n            print(self.CalcDepth(root.left) , self.CalcDepth(root.right))\\n            return( abs(self.CalcDepth(root.left) - self.CalcDepth(root.right) ) <= 1 )\\n        return True\\n        \\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791335,
                "title": "easy-explanation-c-recursive-approach",
                "content": "# Intuition\\nCheck the difference of leftHeight and rightHeight of the current node , its left child node and right child node. If the ***absolute*** differnce of heights of every node is less than equal to 1 then the Binary tree is Balanced Binary Tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code defines a class `Solution` that contains two functions: `height` and `isBalanced`. The `height` function calculates the height of a binary tree given its root node. The height of a binary tree is defined as the maximum number of edges in any path from the root node to a leaf node.\\n\\nThe `isBalanced` function checks whether a given binary tree is balanced or not. A binary tree is considered balanced if the height difference between its left and right subtrees is at most 1 for every node in the tree.\\n\\nHere\\'s a step-wise explanation of the `isBalanced` function:\\n\\n1. Check the base case: If the root is NULL (i.e., an empty tree), return `true` since an empty tree is considered balanced.\\n\\n2. Calculate the height difference between the left and right subtrees of the current node. This is done by calling the `height` function on both the left and right subtrees and taking the absolute difference between their heights.\\n\\n3. Recursively check whether the left subtree and right subtree are balanced by calling the `isBalanced` function on them.\\n\\n4. If the height difference between the left and right subtrees is at most 1, and both the left and right subtrees are balanced (as checked in step 3), then return `true`, indicating that the current subtree is balanced.\\n\\n5. If any of the conditions in step 4 are not met, return `false`, indicating that the current subtree is not balanced.\\n\\nThe `height` function recursively calculates the height of the binary tree by finding the heights of its left and right subtrees and returning the maximum height of the two plus 1 (to account for the current node).\\n\\nOverall, the `isBalanced` function checks the balance of the entire binary tree by recursively checking the balance of each of its subtrees, making sure that the height difference between any two subtrees is at most 1.\\n\\n# Complexity\\n- Time complexity: O(n*n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(h) h is the maxheight of the tree.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int height(TreeNode* root)\\n    {\\n        if(root == NULL)\\n        {\\n            return 0;\\n        }\\n\\n        int leftH=height(root->left);\\n        int rightH=height(root->right);\\n        int maxdepth=max(leftH,rightH) + 1;\\n        return maxdepth;\\n    }\\n\\n    bool isBalanced(TreeNode* root) {\\n       //base case\\n       if(root == NULL)\\n       {\\n           return true;\\n       }\\n\\n       int ans=abs(height(root->left) - height(root->right));\\n       bool leftAns=isBalanced(root->left);\\n      bool rigthAns= isBalanced(root->right);\\n       if(ans<=1 && leftAns && rigthAns)\\n       {\\n           return true;\\n       }\\n       else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int height(TreeNode* root)\\n    {\\n        if(root == NULL)\\n        {\\n            return 0;\\n        }\\n\\n        int leftH=height(root->left);\\n        int rightH=height(root->right);\\n        int maxdepth=max(leftH,rightH) + 1;\\n        return maxdepth;\\n    }\\n\\n    bool isBalanced(TreeNode* root) {\\n       //base case\\n       if(root == NULL)\\n       {\\n           return true;\\n       }\\n\\n       int ans=abs(height(root->left) - height(root->right));\\n       bool leftAns=isBalanced(root->left);\\n      bool rigthAns= isBalanced(root->right);\\n       if(ans<=1 && leftAns && rigthAns)\\n       {\\n           return true;\\n       }\\n       else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453347,
                "title": "easy-to-understand-c-solution-explained-with-a-test-case",
                "content": "# Intuition\\nAccording to the question, a tree is said to be balanced when \\n**every node** in the tree has difference of depth of its two subtrees less than or equal to 1.\\n# Approach\\n\\nSimply traverse tree and find depth of each node if difference is more than 1 then answer would be false.\\n\\n\\nTest case: [1,2,2,3,null,null,3,4,null,null,4]\\n![Screenshot 2023-04-25 143947.png](https://assets.leetcode.com/users/images/262d764c-6d1b-4202-84fc-469d46ee1dbf_1682414175.746104.png)\\n\\n\\n**So in this example check the difference of depth for 2(node)\\ndiff= abs(leftSubtree-rightSubtree)\\ndiff= abs(2-0)=2\\nit is greater than 1 so we simple make our answer false and return.**\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n# Please upvote if you find this helpful!\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,bool &ans){\\n       \\n        if(!root || !ans ) return 0;  //base case\\n\\n        // traverse tree\\n        int left=solve(root->left,ans);\\n        int right=solve(root->right,ans);\\n\\n        if(abs(left-right)>1) ans=false;  //check if balanced or not\\n        \\n        return max(left,right)+1; //find depth\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        bool ans=true;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root,bool &ans){\\n       \\n        if(!root || !ans ) return 0;  //base case\\n\\n        // traverse tree\\n        int left=solve(root->left,ans);\\n        int right=solve(root->right,ans);\\n\\n        if(abs(left-right)>1) ans=false;  //check if balanced or not\\n        \\n        return max(left,right)+1; //find depth\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        bool ans=true;\\n        solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337394,
                "title": "java-dfs-clean-code-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use DFS to traverse the tree and check the depth of the left and ride sides of every sub-tree. In order for the tree to be balanced, the depths of the left and right sides should not differ by more than 1. We can validate this condition for every subtree. If the condition is false for any subtree we return false as the answer, else we return true;\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  boolean isBalanced = true;\\n\\n  private int dfs(TreeNode node) {\\n    if (node == null || !isBalanced)\\n      return 0;\\n\\n    var left = dfs(node.left);\\n    var right = dfs(node.right);\\n\\n    if (Math.abs(left - right) > 1)\\n      isBalanced = false;\\n\\n    return 1 + Math.max(left, right);\\n  }\\n\\n  public boolean isBalanced(TreeNode root) {\\n    dfs(root);\\n    return isBalanced;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  boolean isBalanced = true;\\n\\n  private int dfs(TreeNode node) {\\n    if (node == null || !isBalanced)\\n      return 0;\\n\\n    var left = dfs(node.left);\\n    var right = dfs(node.right);\\n\\n    if (Math.abs(left - right) > 1)\\n      isBalanced = false;\\n\\n    return 1 + Math.max(left, right);\\n  }\\n\\n  public boolean isBalanced(TreeNode root) {\\n    dfs(root);\\n    return isBalanced;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111469,
                "title": "2-java-solution-with-detail-explaination-from-brute-force-to-optimized",
                "content": "1.\\tFor each node check height of a left tree and right tree. If absolute difference is more than 1 return false.\\n2.\\tSince in this approach for each node we are checking height of a tree. It\\u2019s complexity will become o(n2).\\n\\n**Approach 1 -**\\n```\\npublic boolean isBalanced(TreeNode<Integer> root) {\\n        if(root==null) {\\n            return true;\\n        }\\n        int left = height(root.getLeft());\\n        int right = height(root.getRight());\\n        if(Math.abs(left-right)>1) {    \\n            return false;\\n        }\\n        return isBalanced(root.getLeft())&&isBalanced(root.getRight());\\n     }\\n    \\n     private int height(TreeNode node) {\\n        if(node==null) {\\n            return 0;\\n        }\\n        return Math.max(height(node.left),height(node.right))+1;\\n     }\\n    \\n```\\n\\n**Approach 2**\\nTo optmize it let just note down what we already know->\\nif at any point height of left and right tree absolute difference > 1 then it means it is not balanced. else continue till entire tree is not visited.\\n1. Since we are already visiting each node during height calculation. We can check height balance property at the same time. And return -1 if at any point height of node is not balanced (Note-> instead of -1, any  arbitary value can work which cannot be possible as height to distinguish from original height. ex-> Integer.MAX_VALUE).\\n2. since we dont want this -1 to interfene with other height calculation, in such case as soon as -1 found we dont need to check further. just start returning -1 from every call stack method call. \\n3. In this way we can check balanced tree in o(n) time.\\n\\n ```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        //-1 indicate that tree is not balanced.\\n        return height(root)!=-1;\\n    }\\n    \\n    private int height(TreeNode node) {\\n        //if last node reached return 0 as it will not contribute to height\\n        if(node==null) {\\n            return 0;\\n        }\\n        //get left height of tree\\n        int left = height(node.left);\\n        //if returned height is -1. dont check further just return directly\\n        if(left==-1) {\\n            return -1;\\n        }\\n        //get right height of tree\\n        int right = height(node.right);\\n        //if right height is -1 or absolute difference of height of left and right is > 1. it means not balanced and return -1.\\n        if(right==-1 || Math.abs(left-right)>1) {\\n            //Note we are checking absolute diff only if we have received actual heights, not -1.\\n            return -1;\\n        }\\n        // if we have reached here it means left and right tree values are actual heights, not -1.\\n        return Math.max(left,right)+1;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic boolean isBalanced(TreeNode<Integer> root) {\\n        if(root==null) {\\n            return true;\\n        }\\n        int left = height(root.getLeft());\\n        int right = height(root.getRight());\\n        if(Math.abs(left-right)>1) {    \\n            return false;\\n        }\\n        return isBalanced(root.getLeft())&&isBalanced(root.getRight());\\n     }\\n    \\n     private int height(TreeNode node) {\\n        if(node==null) {\\n            return 0;\\n        }\\n        return Math.max(height(node.left),height(node.right))+1;\\n     }\\n    \\n```\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        //-1 indicate that tree is not balanced.\\n        return height(root)!=-1;\\n    }\\n    \\n    private int height(TreeNode node) {\\n        //if last node reached return 0 as it will not contribute to height\\n        if(node==null) {\\n            return 0;\\n        }\\n        //get left height of tree\\n        int left = height(node.left);\\n        //if returned height is -1. dont check further just return directly\\n        if(left==-1) {\\n            return -1;\\n        }\\n        //get right height of tree\\n        int right = height(node.right);\\n        //if right height is -1 or absolute difference of height of left and right is > 1. it means not balanced and return -1.\\n        if(right==-1 || Math.abs(left-right)>1) {\\n            //Note we are checking absolute diff only if we have received actual heights, not -1.\\n            return -1;\\n        }\\n        // if we have reached here it means left and right tree values are actual heights, not -1.\\n        return Math.max(left,right)+1;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872196,
                "title": "java-dfs-o-n",
                "content": "# Approach\\nDFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(log(n))$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return height(root) == -1 ? false : true;\\n    }\\n\\n    private int height(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        int left = height(root.left);\\n        int right = height(root.right);\\n\\n        if (left == -1 || right == -1 || Math.abs(left - right) > 1) {\\n            return -1;\\n        }\\n\\n        return 1 + Math.max(left, right);\\n    }\\n}\\n```\\n\\nPLEASE UPVOTE IF YOU LIKE \\uD83D\\uDE4F",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return height(root) == -1 ? false : true;\\n    }\\n\\n    private int height(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n\\n        int left = height(root.left);\\n        int right = height(root.right);\\n\\n        if (left == -1 || right == -1 || Math.abs(left - right) > 1) {\\n            return -1;\\n        }\\n\\n        return 1 + Math.max(left, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765950,
                "title": "110-balanced-binary-tree-very-simple-and-easy-code-c",
                "content": "Pls vote if you like the solution...\\n\\n```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if(root == NULL)\\n            return 1;\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n        return (abs(lh-rh)<=1 && isBalanced(root->left) && isBalanced(root->right));\\n        \\n    }\\n    private:\\n        int height(TreeNode* &root){\\n            if(root == NULL)\\n                return 0;\\n            else\\n                return max(height(root->left),height(root->right))+1;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if(root == NULL)\\n            return 1;\\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n        return (abs(lh-rh)<=1 && isBalanced(root->left) && isBalanced(root->right));\\n        \\n    }\\n    private:\\n        int height(TreeNode* &root){\\n            if(root == NULL)\\n                return 0;\\n            else\\n                return max(height(root->left),height(root->right))+1;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699846,
                "title": "python-easy-understanding-solution",
                "content": "O(n) time solution\\n```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        def maxDepth(node):\\n            if node is None:\\n                return 0\\n            left = maxDepth(node.left)\\n            right = maxDepth(node.right)\\n            return max(left,right) + 1\\n        \\n        def helper(root):\\n            if root is None:\\n                return True\\n            left_height = maxDepth(root.left)\\n            right_height = maxDepth(root.right)\\n            \\n            if abs(left_height - right_height) > 1:\\n                return False\\n            left = helper(root.left)\\n            right = helper(root.right)\\n            \\n            if not left or not right:\\n                return False\\n            return True\\n        return helper(root)\\n```\\n**Please upvote** if like the solution",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        def maxDepth(node):\\n            if node is None:\\n                return 0\\n            left = maxDepth(node.left)\\n            right = maxDepth(node.right)\\n            return max(left,right) + 1\\n        \\n        def helper(root):\\n            if root is None:\\n                return True\\n            left_height = maxDepth(root.left)\\n            right_height = maxDepth(root.right)\\n            \\n            if abs(left_height - right_height) > 1:\\n                return False\\n            left = helper(root.left)\\n            right = helper(root.right)\\n            \\n            if not left or not right:\\n                return False\\n            return True\\n        return helper(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535193,
                "title": "python-recursion-solution",
                "content": "```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def dfs(root):\\n            if not root:\\n                return [True, 0]\\n            \\n            left,right = dfs(root.left), dfs(root.right)\\n            \\n            balanced = (left[0] and right[0] and\\n                        abs(left[1] - right[1]) <= 1)\\n            \\n            return [balanced, 1+max(left[1], right[1])]\\n        \\n        return dfs(root)[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def dfs(root):\\n            if not root:\\n                return [True, 0]\\n            \\n            left,right = dfs(root.left), dfs(root.right)\\n            \\n            balanced = (left[0] and right[0] and\\n                        abs(left[1] - right[1]) <= 1)\\n            \\n            return [balanced, 1+max(left[1], right[1])]\\n        \\n        return dfs(root)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373383,
                "title": "c-solution-using-maps-comments-faster-than-92",
                "content": "```\\n// map consisting of TreeNode as keys and their heights as values\\nunordered_map<TreeNode*, int> mp;\\n\\nint height(TreeNode* root){\\n\\tif(root==NULL)  return 0;\\n\\t// calculating the max height of each node\\n\\treturn mp[root] = 1+ max(height(root->left), height(root->right));\\n}\\n\\nbool isBalanced(TreeNode* root) {\\n\\tint h = height(root);\\n\\t// if we reach leaf node, we return true;\\n\\tif(root==NULL)  return true;\\n\\t// to check if height difference is greater than 1, return false\\n\\tif(abs(mp[root->left]-mp[root->right])>1) return false;\\n\\t// checking if both the left and right tree are balanced\\n\\treturn isBalanced(root->left) && isBalanced(root->right);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// map consisting of TreeNode as keys and their heights as values\\nunordered_map<TreeNode*, int> mp;\\n\\nint height(TreeNode* root){\\n\\tif(root==NULL)  return 0;\\n\\t// calculating the max height of each node\\n\\treturn mp[root] = 1+ max(height(root->left), height(root->right));\\n}\\n\\nbool isBalanced(TreeNode* root) {\\n\\tint h = height(root);\\n\\t// if we reach leaf node, we return true;\\n\\tif(root==NULL)  return true;\\n\\t// to check if height difference is greater than 1, return false\\n\\tif(abs(mp[root->left]-mp[root->right])>1) return false;\\n\\t// checking if both the left and right tree are balanced\\n\\treturn isBalanced(root->left) && isBalanced(root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2345434,
                "title": "c-easy-recursion",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    int depth(TreeNode* root){\\n        if(root==NULL) return 0;\\n        return max(depth(root->right), depth(root->left))+1;\\n    }\\n    \\n    bool isBalanced(TreeNode* root) {\\n        if(root==NULL) return true;\\n        \\n        int left=depth(root->left);\\n        int right=depth(root->right);\\n        \\n        return abs(left-right)<=1 && isBalanced(root->left) && isBalanced(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int depth(TreeNode* root){\\n        if(root==NULL) return 0;\\n        return max(depth(root->right), depth(root->left))+1;\\n    }\\n    \\n    bool isBalanced(TreeNode* root) {\\n        if(root==NULL) return true;\\n        \\n        int left=depth(root->left);\\n        int right=depth(root->right);\\n        \\n        return abs(left-right)<=1 && isBalanced(root->left) && isBalanced(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2153732,
                "title": "balanced-binary-tree-using-bfs",
                "content": "We check for every node whether the node is height balanced or not which in turn makes it for the whole tree.\\nWe push nodes in a queue and check the height of left subtree and right subtree. If their absolute difference is greater than or equal to 2, we return false. Else we check this condition for other children nodes.\\n```\\nclass Solution {\\npublic:\\n//checking the height of the node.\\n    int height(TreeNode* root){\\n        if(!root) return 0;\\n        return 1+ max(height(root->left), height(root->right));\\n    }\\n\\t//main function\\n    bool isBalanced(TreeNode* root) {\\n        if(!root) return true;\\n        queue<TreeNode*> q; q.push(root);\\n\\t\\t\\n        while(!q.empty()){\\n           auto x= q.front(); q.pop();\\n           int lh=height(x->left), rh=height(x->right);\\n\\t\\t   //condition here\\n           if(abs(lh-rh) >=2){\\n               return false;\\n           }\\n\\t\\t   \\n            if(x->left){\\n                q.push(x->left);\\n            }\\n            if(x->right){\\n                q.push(x->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//checking the height of the node.\\n    int height(TreeNode* root){\\n        if(!root) return 0;\\n        return 1+ max(height(root->left), height(root->right));\\n    }\\n\\t//main function\\n    bool isBalanced(TreeNode* root) {\\n        if(!root) return true;\\n        queue<TreeNode*> q; q.push(root);\\n\\t\\t\\n        while(!q.empty()){\\n           auto x= q.front(); q.pop();\\n           int lh=height(x->left), rh=height(x->right);\\n\\t\\t   //condition here\\n           if(abs(lh-rh) >=2){\\n               return false;\\n           }\\n\\t\\t   \\n            if(x->left){\\n                q.push(x->left);\\n            }\\n            if(x->right){\\n                q.push(x->right);\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647398,
                "title": "java-recursive-dfs-two-approaches",
                "content": "Top-Down recursive dfs\\n\\n**TC:** O(nlogn). On every invocation of isBalanced(), we process the nodes on each level below the one which we are currently checking the balance of. This number of nodes is on the order of h=logn. We call isBalanced() on every node in the tree.\\n**SC:** O(logn). The maximum depth of the recursion stack.\\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        if(root==null) return true;\\n        else if (root.left==null && root.right==null) return true;\\n        else if (Math.abs(dfs(root.left)-dfs(root.right))>1) return false;\\n        else return isBalanced(root.left) && isBalanced(root.right);\\n    }\\n    \\n    private int dfs(TreeNode root){\\n        if(root==null) return 0;\\n        else if (root.left==null && root.right==null) return 1;\\n        else return 1+Math.max(dfs(root.left),dfs(root.right));\\n    }\\n}\\n```\\n\\nBottom-Up recursive dfs\\n\\n**TC:** O(n). In the previous code, notice that we\\'re recalculating the balance of a node, several times throughout the procedure. This is wasteful, since calculating the balance of a node involves processing the nodes on the levels below it; this is O(logn). Instead, we can \\'short-circuit\\' the process by first checking the left subtree. If balance is off, then just exit. If not, check the right subtree. If balance is fine there too, then we can compare the left and right subtree heights. If it\\'s good there, then we can pass up the \\'maximal height\\', so that the nodes above can repeat the procedure, without duplicating the work of calculating subtree heights.\\n**SC:** O(logn). Maximum recursion stack depth.\\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        if(root==null) return true;\\n        else if (root.left==null && root.right==null) return true;\\n        else return dfs(root)!=-1;\\n    }\\n    \\n    private int dfs(TreeNode root){\\n        if(root==null) return 0;\\n        \\n        int leftHeight= dfs(root.left);\\n        if(leftHeight==-1) return -1;\\n        int rightHeight= dfs(root.right);\\n        if(rightHeight==-1) return -1;\\n        \\n        if (Math.abs(leftHeight-rightHeight)>1) return -1;\\n        else return 1+Math.max(leftHeight,rightHeight);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        if(root==null) return true;\\n        else if (root.left==null && root.right==null) return true;\\n        else if (Math.abs(dfs(root.left)-dfs(root.right))>1) return false;\\n        else return isBalanced(root.left) && isBalanced(root.right);\\n    }\\n    \\n    private int dfs(TreeNode root){\\n        if(root==null) return 0;\\n        else if (root.left==null && root.right==null) return 1;\\n        else return 1+Math.max(dfs(root.left),dfs(root.right));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        if(root==null) return true;\\n        else if (root.left==null && root.right==null) return true;\\n        else return dfs(root)!=-1;\\n    }\\n    \\n    private int dfs(TreeNode root){\\n        if(root==null) return 0;\\n        \\n        int leftHeight= dfs(root.left);\\n        if(leftHeight==-1) return -1;\\n        int rightHeight= dfs(root.right);\\n        if(rightHeight==-1) return -1;\\n        \\n        if (Math.abs(leftHeight-rightHeight)>1) return -1;\\n        else return 1+Math.max(leftHeight,rightHeight);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626310,
                "title": "python-easy-and-simple-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        \\n        if root is None:\\n            return True\\n        \\n        hleft=self.findMaxheight(root.left)\\n        hright=self.findMaxheight(root.right)\\n        \\n        if abs(hleft-hright)>1:\\n            return False\\n        \\n        if self.isBalanced(root.left) and self.isBalanced(root.right):\\n            return True\\n        else:\\n            return False\\n          \\n    def findMaxheight(self,root):\\n        \\n        if root is None:\\n            return 0\\n        \\n        return max(self.findMaxheight(root.left)+1,self.findMaxheight(root.right)+1)\\n \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        \\n        if root is None:\\n            return True\\n        \\n        hleft=self.findMaxheight(root.left)\\n        hright=self.findMaxheight(root.right)\\n        \\n        if abs(hleft-hright)>1:\\n            return False\\n        \\n        if self.isBalanced(root.left) and self.isBalanced(root.right):\\n            return True\\n        else:\\n            return False\\n          \\n    def findMaxheight(self,root):\\n        \\n        if root is None:\\n            return 0\\n        \\n        return max(self.findMaxheight(root.left)+1,self.findMaxheight(root.right)+1)\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622361,
                "title": "clear-python-solution-for-beginners-with-useful-comments",
                "content": "```\\ndef isBalanced(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_depth(node):\\n\\t\\tif node is None:\\n\\t\\t\\treturn 0\\n\\n\\t\\tleft_depth = check_depth(node.left)\\n\\t\\t# Left side already unbalanced\\n\\t\\tif left_depth == -1:\\n\\t\\t\\treturn -1\\n\\t\\tright_depth = check_depth(node.right)\\n\\t\\t# Right side already unbalanced\\n\\t\\tif right_depth == -1:\\n\\t\\t\\treturn -1\\n\\n\\t\\t# Left and right subtrees differ more than 1 -> unbalanced\\n\\t\\tif abs(left_depth - right_depth) > 1:\\n\\t\\t\\treturn -1\\n\\n\\t\\t# If balanced, return the depth of current node\\n\\t\\t# Add 1 depth to the current node itself\\n\\t\\treturn 1 + max(left_depth, right_depth)\\n\\n\\treturn check_depth(root) != -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef isBalanced(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_depth(node):\\n\\t\\tif node is None:\\n\\t\\t\\treturn 0\\n\\n\\t\\tleft_depth = check_depth(node.left)\\n\\t\\t# Left side already unbalanced\\n\\t\\tif left_depth == -1:\\n\\t\\t\\treturn -1\\n\\t\\tright_depth = check_depth(node.right)\\n\\t\\t# Right side already unbalanced\\n\\t\\tif right_depth == -1:\\n\\t\\t\\treturn -1\\n\\n\\t\\t# Left and right subtrees differ more than 1 -> unbalanced\\n\\t\\tif abs(left_depth - right_depth) > 1:\\n\\t\\t\\treturn -1\\n\\n\\t\\t# If balanced, return the depth of current node\\n\\t\\t# Add 1 depth to the current node itself\\n\\t\\treturn 1 + max(left_depth, right_depth)\\n\\n\\treturn check_depth(root) != -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1602743,
                "title": "c-o-n-solution-recursive-short-and-simple",
                "content": "```\\nclass Solution {\\n    \\n    int balance(TreeNode * node){\\n        \\n        if(!node){\\n            return 0;\\n        }\\n        \\n        int lh = balance(node->left);\\n        int rh = balance(node->right);\\n        \\n        if(lh == -1 || rh == -1)    //if either of them is -1, we dont have to go further and just return -1\\n            return -1;\\n        \\n        if(abs(lh-rh) > 1)      //abs() gives us the absolute difference of the two heights \\n            return -1;\\n        \\n        return max(lh,rh)+1;\\n    }\\n    \\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        \\n        return (balance(root) != -1); //if the tree is balanced it`ll be positive(true) or else it`ll be definitely negative(false).\\n    }\\n};\\n\\n```\\n\\nHope it helps :D...!",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int balance(TreeNode * node){\\n        \\n        if(!node){\\n            return 0;\\n        }\\n        \\n        int lh = balance(node->left);\\n        int rh = balance(node->right);\\n        \\n        if(lh == -1 || rh == -1)    //if either of them is -1, we dont have to go further and just return -1\\n            return -1;\\n        \\n        if(abs(lh-rh) > 1)      //abs() gives us the absolute difference of the two heights \\n            return -1;\\n        \\n        return max(lh,rh)+1;\\n    }\\n    \\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        \\n        return (balance(root) != -1); //if the tree is balanced it`ll be positive(true) or else it`ll be definitely negative(false).\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253428,
                "title": "all-solutions-asked-by-amazon-microsoft-goldman-sachs-with-complexities",
                "content": "### **NAIVE SOLUTION**\\n\\n```\\n\\t int height(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        \\n        return max(height(root->left), height(root->right)) + 1;\\n     }\\n    bool isBalanced(TreeNode* root) {\\n        int left_ht, right_ht;\\n        if(root == NULL)\\n            return true;\\n        \\n        left_ht = height(root->left);\\n        right_ht = height(root->right);\\n        \\n        if(abs(left_ht - right_ht) <= 1 && isBalanced(root->left) && isBalanced(root->right))\\n            return true;\\n        else\\n            return false;\\n}\\n```\\n\\n**TIME COMPLEXITY  : O(N^2), Where N, Toatal number of nodes in the tree (in case of full Binary Tree)\\nSPACE COMPLEXITY : O(H) , Where H, height of the tree for recusrion stack**\\n\\n```\\n```\\n\\n### **EFFICIENT SOLUTION**\\n\\n```\\n// idea: calculate left tree height and right tree height on the time of traversing the tree first time\\n//       instead of seperatly calling recursion fuction to calculate height as we saw in naive solution..\\n// BUT HERE, IN THIS SOLUTION : am returning -1(Negative value) for unbalanced tree and positive value for balanced tree\\n    int checking_Balancing(TreeNode* root){\\n        if(root == NULL)\\n            return 0;\\n        \\n        int left_height = checking_Balancing(root->left);\\n        if(left_height == -1)\\n            return -1;\\n        \\n        int right_height = checking_Balancing(root->right);\\n        if(right_height == -1)\\n            return -1;\\n        \\n        if(abs(left_height - right_height) > 1)\\n            return -1;\\n        else\\n            return (max(left_height, right_height)) + 1;  // updating the height on the go at each level of tree\\n    }\\n\\t\\n    bool isBalanced(TreeNode* root) {\\n        \\n        if(checking_Balancing(root) >= 0)\\n            return true;\\n        else\\n            return false;\\n    }\\n```\\n\\n**TIME COMPLEXITY  : O(N), Where N, Toatal number of nodes in the tree\\nSPACE COMPLEXITY : O(H) ,  Where H, height of the tree for recusrion stack**\\n\\nif you find any mistakes pls, drop a comment\\nif it makes any sense don\\'t forget to Upvote",
                "solutionTags": [],
                "code": "```\\n\\t int height(TreeNode* root) {\\n        if(root == NULL)\\n            return 0;\\n        \\n        return max(height(root->left), height(root->right)) + 1;\\n     }\\n    bool isBalanced(TreeNode* root) {\\n        int left_ht, right_ht;\\n        if(root == NULL)\\n            return true;\\n        \\n        left_ht = height(root->left);\\n        right_ht = height(root->right);\\n        \\n        if(abs(left_ht - right_ht) <= 1 && isBalanced(root->left) && isBalanced(root->right))\\n            return true;\\n        else\\n            return false;\\n}\\n```\n```\\n```\n```\\n// idea: calculate left tree height and right tree height on the time of traversing the tree first time\\n//       instead of seperatly calling recursion fuction to calculate height as we saw in naive solution..\\n// BUT HERE, IN THIS SOLUTION : am returning -1(Negative value) for unbalanced tree and positive value for balanced tree\\n    int checking_Balancing(TreeNode* root){\\n        if(root == NULL)\\n            return 0;\\n        \\n        int left_height = checking_Balancing(root->left);\\n        if(left_height == -1)\\n            return -1;\\n        \\n        int right_height = checking_Balancing(root->right);\\n        if(right_height == -1)\\n            return -1;\\n        \\n        if(abs(left_height - right_height) > 1)\\n            return -1;\\n        else\\n            return (max(left_height, right_height)) + 1;  // updating the height on the go at each level of tree\\n    }\\n\\t\\n    bool isBalanced(TreeNode* root) {\\n        \\n        if(checking_Balancing(root) >= 0)\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081260,
                "title": "python-dfs-solution-with-explanation",
                "content": "The idea here is that we are going to dfs through the tree while keeping track of the depth of the current node we are processing. We have 2 base cases to consider, the node has no left subtree or no right subtree. 1.) The node we are processing has no left child, so we can say the depth of the left subtree is just the depth of the current node. So we return `depth-1`  and store that value in `left`. 2.) The node we are processing has no right child, so we can say the depth of the right subtree is just the depth of the current node. So we return `depth-1`  and store that value in `right`. Now that we have the depth of the left and right subtrees of the current node we can check their difference. If either the left or right subtree is deeper by more than 1 level, the entire tree is not Balanced and we set `flag = False` denoting this is not a Balanced Binary Tree. We then return the maximum depth that we could reach from the current node we are processing.\\n```\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        flag = True\\n        def dfs(node, depth):\\n            nonlocal flag\\n            if not node:\\n                return depth-1\\n            else:\\n                left = dfs(node.left, depth+1)\\n                right = dfs(node.right, depth+1)\\n                if abs(left-right) > 1:\\n                    flag = False\\n                return max(left, right)\\n        dfs(root, 0)\\n        return flag\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        flag = True\\n        def dfs(node, depth):\\n            nonlocal flag\\n            if not node:\\n                return depth-1\\n            else:\\n                left = dfs(node.left, depth+1)\\n                right = dfs(node.right, depth+1)\\n                if abs(left-right) > 1:\\n                    flag = False\\n                return max(left, right)\\n        dfs(root, 0)\\n        return flag\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014759,
                "title": "c-iterative",
                "content": "I made iterative bcos interviewers ask both recursive and iterative method for a ques, recursive is easy for it, so try iterative , do this for every problem\\n```\\nclass Solution {\\npublic:\\n //this is our global height map\\n    unordered_map<TreeNode*,int> hmap;\\n    \\n//get the height if evaluated \\n    int getheight(TreeNode* t){\\n        if(t==NULL) return 0;\\n        if(hmap.find(t)!=hmap.end()) return hmap[t];\\n        else return -1;\\n    }\\n    \\n//set the height in hmap\\n    void setheight(TreeNode* t){\\n        hmap[t] = 1 + max(getheight(t->left) , getheight(t->right));\\n    }\\n    \\n    bool isBalanced(TreeNode* root) {\\n        \\n        hmap.clear();\\n        stack<TreeNode*> s;\\n        if(root!=NULL)\\n            s.push(root);\\n        \\n\\t//first node is the root node\\n        while(!s.empty()){\\n            TreeNode* t = s.top();\\n            int lefth = getheight(t->left);\\n            int righth = getheight(t->right);\\n\\t\\t\\t\\n        //lets check if we have both left and right heights ready\\n            if(lefth>=0 && righth>=0){\\n                if(abs(lefth-righth) > 1) return false;\\n                setheight(t);\\n                s.pop();\\n\\t\\t//so if balanced condition does not hold return false, \\n\\t\\t//otherwise set height for curr node and pop it so other nodes can have their height evaluated\\n            }\\n            else{\\n\\t\\t//if left not ready push leftnode, else push right node\\n                if(lefth<0) s.push(t->left);\\n                else s.push(t->right);\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n //this is our global height map\\n    unordered_map<TreeNode*,int> hmap;\\n    \\n//get the height if evaluated \\n    int getheight(TreeNode* t){\\n        if(t==NULL) return 0;\\n        if(hmap.find(t)!=hmap.end()) return hmap[t];\\n        else return -1;\\n    }\\n    \\n//set the height in hmap\\n    void setheight(TreeNode* t){\\n        hmap[t] = 1 + max(getheight(t->left) , getheight(t->right));\\n    }\\n    \\n    bool isBalanced(TreeNode* root) {\\n        \\n        hmap.clear();\\n        stack<TreeNode*> s;\\n        if(root!=NULL)\\n            s.push(root);\\n        \\n\\t//first node is the root node\\n        while(!s.empty()){\\n            TreeNode* t = s.top();\\n            int lefth = getheight(t->left);\\n            int righth = getheight(t->right);\\n\\t\\t\\t\\n        //lets check if we have both left and right heights ready\\n            if(lefth>=0 && righth>=0){\\n                if(abs(lefth-righth) > 1) return false;\\n                setheight(t);\\n                s.pop();\\n\\t\\t//so if balanced condition does not hold return false, \\n\\t\\t//otherwise set height for curr node and pop it so other nodes can have their height evaluated\\n            }\\n            else{\\n\\t\\t//if left not ready push leftnode, else push right node\\n                if(lefth<0) s.push(t->left);\\n                else s.push(t->right);\\n            }\\n        }\\n        \\n        return true;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982357,
                "title": "javascript-solution-simple",
                "content": "```\\nvar isBalanced = function(root) {\\n    let res = true\\n    const go = (root) => {\\n        if (!root) return 0\\n        let left = go(root.left)\\n        let right = go(root.right)\\n        if (left - right > 1 || right - left > 1) {\\n            res = false\\n        }\\n        return Math.max(left, right) + 1\\n        \\n    }\\n    go(root)\\n    return res\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isBalanced = function(root) {\\n    let res = true\\n    const go = (root) => {\\n        if (!root) return 0\\n        let left = go(root.left)\\n        let right = go(root.right)\\n        if (left - right > 1 || right - left > 1) {\\n            res = false\\n        }\\n        return Math.max(left, right) + 1\\n        \\n    }\\n    go(root)\\n    return res\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 982071,
                "title": "python-straight-forward-dfs-o-n",
                "content": "```python\\nclass Solution(object):\\n    def isBalanced(self, root):\\n        def dfs(root): # return (depth, isBalance)\\n            if root == None:\\n                return 0, True\\n            leftH, leftB = dfs(root.left) # left height, left balance\\n            rightH, rightB = dfs(root.right) # right height, right balance\\n            return max(leftH, rightH) + 1, abs(leftH - rightH) <= 1 and leftB and rightB\\n        \\n        return dfs(root)[1]\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N` is number of nodes\\n- Space: `O(H)`, where `H` is height of the tree",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def isBalanced(self, root):\\n        def dfs(root): # return (depth, isBalance)\\n            if root == None:\\n                return 0, True\\n            leftH, leftB = dfs(root.left) # left height, left balance\\n            rightH, rightB = dfs(root.right) # right height, right balance\\n            return max(leftH, rightH) + 1, abs(leftH - rightH) <= 1 and leftB and rightB\\n        \\n        return dfs(root)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699014,
                "title": "c-easy-dfs-extending-height-of-tree-problem-o-n",
                "content": "Although this question is not difficult, I saw the top posts and I though I have much simpler and intuitive solution. \\nIdea: \\n* Find the height of the tree (or depth here). \\n* Maintain a boolean flag and make it false whenever for any node, depth of left and right node varies more than one. \\n\\nSimple :)\\n```\\nclass Solution {\\npublic:\\n    bool ans=true;\\n    bool isBalanced(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n    \\n    int dfs(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n        if(abs(l-r)>1) ans=false;\\n        return max(l,r)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ans=true;\\n    bool isBalanced(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n    \\n    int dfs(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        int l = dfs(root->left);\\n        int r = dfs(root->right);\\n        if(abs(l-r)>1) ans=false;\\n        return max(l,r)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573984,
                "title": "c-height-function-and-only-return-satement",
                "content": "```\\n//height of the tree(root)\\nint height(TreeNode* root){\\n        if(root == NULL)\\n            return 0;\\n        return (1+max((height(root->left)),(height(root->right))));\\n}\\n//if NULL tree => Balanced\\n//3 Conditions: -\\n//1. Check height difference for current node left subtree and right subtree.\\n//2. Check if left subtree is balanced.\\n//3. Check if right subtree is balanced.\\nbool isBalanced(TreeNode* root) {\\n        if(root == NULL)\\n            return true;\\n        return (abs(height(root->left)-height(root->right))<2 && isBalanced(root->left) && isBalanced(root->right));\\n}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n//height of the tree(root)\\nint height(TreeNode* root){\\n        if(root == NULL)\\n            return 0;\\n        return (1+max((height(root->left)),(height(root->right))));\\n}\\n//if NULL tree => Balanced\\n//3 Conditions: -\\n//1. Check height difference for current node left subtree and right subtree.\\n//2. Check if left subtree is balanced.\\n//3. Check if right subtree is balanced.\\nbool isBalanced(TreeNode* root) {\\n        if(root == NULL)\\n            return true;\\n        return (abs(height(root->left)-height(root->right))<2 && isBalanced(root->left) && isBalanced(root->right));\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 448599,
                "title": "c-12-ms-solution-84-result",
                "content": "It is a balanced binary tree if the difference in height of left and right subtrees is not greater than 1 and both left and right subtrees are balanced.\\n```\\nclass Solution {\\npublic:\\n    //finding height of subtrees\\n    int height(TreeNode* root){\\n        if(root==NULL) return 0;\\n        return(max(height(root->left), height(root->right))+1);\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        if(root == NULL) return 1;\\n        int hl = height(root->left);\\n        int hr = height(root->right);\\n        if(abs(hl-hr) <=1 && isBalanced(root->left) && isBalanced(root->right)) return 1;\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    //finding height of subtrees\\n    int height(TreeNode* root){\\n        if(root==NULL) return 0;\\n        return(max(height(root->left), height(root->right))+1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 235594,
                "title": "go-100",
                "content": "```\\nfunc isBalanced(root *TreeNode) bool {\\n    _, ok := getDepthAndBalance(root)\\n    return ok\\n}\\n\\nfunc getDepthAndBalance(root *TreeNode) (int, bool) {\\n    if root == nil {\\n        return 0, true\\n    }\\n    d1, ok1 := getDepthAndBalance(root.Left)\\n    d2, ok2 := getDepthAndBalance(root.Right)\\n    if !ok1 || !ok2 {\\n        return 0, false\\n    }\\n    if abs(d1-d2) > 1 {\\n        return 0, false\\n    }\\n    \\n    return max(d1+1, d2+1), true\\n}\\n\\nfunc abs(i int) int {\\n    if i < 0 {\\n        return -i\\n    }\\n    return i\\n}\\n\\nfunc max(i, j int) int {\\n    if i > j {\\n        return i\\n    }\\n    return j\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isBalanced(root *TreeNode) bool {\\n    _, ok := getDepthAndBalance(root)\\n    return ok\\n}\\n\\nfunc getDepthAndBalance(root *TreeNode) (int, bool) {\\n    if root == nil {\\n        return 0, true\\n    }\\n    d1, ok1 := getDepthAndBalance(root.Left)\\n    d2, ok2 := getDepthAndBalance(root.Right)\\n    if !ok1 || !ok2 {\\n        return 0, false\\n    }\\n    if abs(d1-d2) > 1 {\\n        return 0, false\\n    }\\n    \\n    return max(d1+1, d2+1), true\\n}\\n\\nfunc abs(i int) int {\\n    if i < 0 {\\n        return -i\\n    }\\n    return i\\n}\\n\\nfunc max(i, j int) int {\\n    if i > j {\\n        return i\\n    }\\n    return j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 202709,
                "title": "java-solution-beats-100",
                "content": "Brute force solution is to \\nfind depth of left subtree and right subtree at every node recursively and comparing the right and left subtree depths and returning false if there is a imbalance.\\n\\nProblem with this approach is we find the height of the tree again and again at every node recursively. \\nThis has time complexity O(n^2). Because finding depth is O(n) operation and we do it at every node.\\n\\nWe can modify the depth function to serve both purpose.\\nWe find the depth of the tree recursively . If at any node we determine that the tree is not balanced we return -1 to denote that its imbalanced.\\n\\nWe use depth function to serve both purpose\\n```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        int depth = depth(root);\\n        return depth != -1;\\n    }\\n    \\n    public int depth(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int leftDepth = depth(root.left);\\n        if(leftDepth == -1){\\n            return -1;\\n        }\\n        int rightDepth = depth(root.right);\\n        if(rightDepth == -1){\\n            return -1;\\n        }\\n        if(Math.abs(leftDepth - rightDepth) > 1){\\n            return -1;\\n        }\\n        return Math.max(leftDepth,rightDepth)+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        int depth = depth(root);\\n        return depth != -1;\\n    }\\n    \\n    public int depth(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        int leftDepth = depth(root.left);\\n        if(leftDepth == -1){\\n            return -1;\\n        }\\n        int rightDepth = depth(root.right);\\n        if(rightDepth == -1){\\n            return -1;\\n        }\\n        if(Math.abs(leftDepth - rightDepth) > 1){\\n            return -1;\\n        }\\n        return Math.max(leftDepth,rightDepth)+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35732,
                "title": "golang-dfs-solution-bottom-up",
                "content": "Clear explanation can be found [here](https://discuss.leetcode.com/topic/7798/the-bottom-up-o-n-solution-would-be-better).\\nFor me, figuring out a bottom up recursive way was not `easy` level though...\\n\\n```\\nfunc isBalanced(root *TreeNode) bool {\\n\\t_, ok := check(root)\\n\\treturn ok\\n}\\n\\n// check checks the tree from a given parent and returns a height of the tree\\n// if the tree is balanced. Otherwise return false as the second return value.\\nfunc check(parent *TreeNode) (int, bool) {\\n\\tif parent == nil {\\n\\t\\treturn 0, true\\n\\t}\\n\\n\\tl, ok := check(parent.Left)\\n\\tif !ok {\\n\\t\\treturn 0, false\\n\\t}\\n\\tr, ok := check(parent.Right)\\n\\tif !ok {\\n\\t\\treturn 0, false\\n\\t}\\n\\n\\tif diff := abs(l - r); diff > 1 {\\n\\t\\treturn 0, false\\n\\t}\\n\\treturn max(l, r) + 1, true\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc abs(a int) int {\\n\\tif a >= 0 {\\n\\t\\treturn a\\n\\t}\\n\\treturn -a\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isBalanced(root *TreeNode) bool {\\n\\t_, ok := check(root)\\n\\treturn ok\\n}\\n\\n// check checks the tree from a given parent and returns a height of the tree\\n// if the tree is balanced. Otherwise return false as the second return value.\\nfunc check(parent *TreeNode) (int, bool) {\\n\\tif parent == nil {\\n\\t\\treturn 0, true\\n\\t}\\n\\n\\tl, ok := check(parent.Left)\\n\\tif !ok {\\n\\t\\treturn 0, false\\n\\t}\\n\\tr, ok := check(parent.Right)\\n\\tif !ok {\\n\\t\\treturn 0, false\\n\\t}\\n\\n\\tif diff := abs(l - r); diff > 1 {\\n\\t\\treturn 0, false\\n\\t}\\n\\treturn max(l, r) + 1, true\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc abs(a int) int {\\n\\tif a >= 0 {\\n\\t\\treturn a\\n\\t}\\n\\treturn -a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 35809,
                "title": "python-iterative-solution",
                "content": "Sometimes interviewers ask us about iterative version of recursive algorithm, so here we go.\\n\\n```\\ndef is_done(node, depths):\\n    left, right = node.left, node.right\\n    return (not left or left in depths) and (not right or right in depths)\\n    \\nclass Solution(object):\\n    def isBalanced(self, root):\\n        stack, depths = [root], {}\\n        while stack:\\n            node = stack.pop()\\n            if not node: continue\\n            if is_done(node, depths):\\n                left  = 0 if not node.left  else depths[node.left]\\n                right = 0 if not node.right else depths[node.right]\\n                if abs(left - right) > 1: return False\\n                depths[node] = 1 + max(left, right)\\n            else:\\n                if node.left and node.left not in depths:\\n                    stack += node, node.left\\n                else:\\n                    stack += node, node.right\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\ndef is_done(node, depths):\\n    left, right = node.left, node.right\\n    return (not left or left in depths) and (not right or right in depths)\\n    \\nclass Solution(object):\\n    def isBalanced(self, root):\\n        stack, depths = [root], {}\\n        while stack:\\n            node = stack.pop()\\n            if not node: continue\\n            if is_done(node, depths):\\n                left  = 0 if not node.left  else depths[node.left]\\n                right = 0 if not node.right else depths[node.right]\\n                if abs(left - right) > 1: return False\\n                depths[node] = 1 + max(left, right)\\n            else:\\n                if node.left and node.left not in depths:\\n                    stack += node, node.left\\n                else:\\n                    stack += node, node.right\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35810,
                "title": "very-clean-solution-yet-12ms-as-the-best-in-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int height(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        int l = height(root->left), r = height(root->right);\\n        if(l==-1 || r==-1 || abs(l-r)>1) return -1;\\n        return max(l, r)+1;\\n    }\\npublic:\\n    bool isBalanced(TreeNode* root) \\n    {\\n        return height(root) != -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int height(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        int l = height(root->left), r = height(root->right);\\n        if(l==-1 || r==-1 || abs(l-r)>1) return -1;\\n        return max(l, r)+1;\\n    }\\npublic:\\n    bool isBalanced(TreeNode* root) \\n    {\\n        return height(root) != -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 35844,
                "title": "fast-python-solution-using-exceptions",
                "content": "Faster than 93% of Python submissions\\n\\n    class UnbalancedTree(BaseException):\\n        pass\\n\\n    class Solution(object):\\n        def get_height(self, root):\\n            if not root:\\n                return 0\\n            left = self.get_height(root.left)\\n            right = self.get_height(root.right)\\n            if abs(left - right) > 1:\\n                raise UnbalancedTree() \\n            return max(left, right) + 1\\n            \\n        def isBalanced(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            try:\\n                self.get_height(root)\\n            except UnbalancedTree:\\n                return False\\n            return True",
                "solutionTags": [
                    "Python"
                ],
                "code": "Faster than 93% of Python submissions\\n\\n    class UnbalancedTree(BaseException):\\n        pass\\n\\n    class Solution(object):\\n        def get_height(self, root):\\n            if not root:\\n                return 0\\n            left = self.get_height(root.left)\\n            right = self.get_height(root.right)\\n            if abs(left - right) > 1:\\n                raise UnbalancedTree() \\n            return max(left, right) + 1\\n            \\n        def isBalanced(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            try:\\n                self.get_height(root)\\n            except UnbalancedTree:\\n                return False\\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 35891,
                "title": "share-my-easy-understanding-python-solution-with-explanation",
                "content": "    class Solution(object):\\n        def search(self, root):\\n            # if we find the tree not height-balanced or the current\\n            # subtree's height is 0, stop search and return 0\\n            if not self.balanced or not root:\\n                return 0\\n    \\n            left = self.search(root.left)  # left subtree's height\\n            right = self.search(root.right)  # right subtree's height\\n    \\n            if abs(left - right) > 1:  # if it's not height-balanced\\n                self.balanced = False\\n    \\n            # return current node's height\\n            return max(left, right) + 1\\n    \\n        def isBalanced(self, root):\\n            self.balanced = True\\n            self.search(root)\\n            return self.balanced",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "    class Solution(object):\\n        def search(self, root):\\n            # if we find the tree not height-balanced or the current\\n            # subtree's height is 0, stop search and return 0\\n            if not self.balanced or not root:\\n                return 0\\n    \\n            left = self.search(root.left)  # left subtree's height\\n            right = self.search(root.right)  # right subtree's height\\n    \\n            if abs(left - right) > 1:  # if it's not height-balanced\\n                self.balanced = False\\n    \\n            # return current node's height\\n            return max(left, right) + 1\\n    \\n        def isBalanced(self, root):\\n            self.balanced = True\\n            self.search(root)\\n            return self.balanced",
                "codeTag": "Java"
            },
            {
                "id": 35870,
                "title": "test-case-wrong",
                "content": "Input:\\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\nOutput:\\nfalse\\nExpected:\\ntrue\\n\\nThis test case is a tree like the following:\\n\\n              1\\n          2       2\\n        3   3   3   3\\n       4 4 4 4 4 4 \\n      5 5\\n\\nIt is not balanced, right?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 35990,
                "title": "my-10-line-recursion-solution",
                "content": "    public class Solution {\\n        public boolean isBalanced(TreeNode root) {\\n            if(root == null) return true;\\n            if(Math.abs(height(root.left) - height(root.right)) > 1) return false;\\n            return isBalanced(root.left) && isBalanced(root.right);\\n        }\\n        public int height(TreeNode node){\\n            if(node == null) return 0;\\n            return Math.max(height(node.left), height(node.right)) + 1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isBalanced(TreeNode root) {\\n            if(root == null) return true;\\n            if(Math.abs(height(root.left) - height(root.right)) > 1) return false;\\n            return isBalanced(root.left) && isBalanced(root.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 36005,
                "title": "python-solution-sharing",
                "content": "It's easy to use C++ or jave to solve this problem, but for python, the recursive limit is easy to come up.\\n\\nHere is a easy python solution.\\nThe key is the getNodeDepth uses a stack to fake recursive.\\n\\n\\n    class Solution:\\n    # @param root, a tree node\\n    # @return a boolean\\n    def isBalanced(self, root):\\n        \\n        def getNodeDepth(node):\\n            if(node==None):return 0;\\n\\n            stack=[(node,1)];\\n            dep=1;\\n\\n            while(len(stack)):\\n                first,dep=stack.pop(0);\\n                if(first.left!=None):\\n                    stack.append((first.left,dep+1));\\n                if(first.right!=None):\\n                    stack.append((first.right,dep+1));\\n            return dep;\\n        \\n        if(root==None):return True;\\n        l=getNodeDepth(root.left);\\n        r=getNodeDepth(root.right);\\n        \\n        return (abs(l-r)<2) and self.isBalanced(root.left) and self.isBalanced(root.right);",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "It's easy to use C++ or jave to solve this problem, but for python, the recursive limit is easy to come up.\\n\\nHere is a easy python solution.\\nThe key is the getNodeDepth uses a stack to fake recursive.\\n\\n\\n    class Solution:\\n    # @param root, a tree node\\n    # @return a boolean\\n    def isBalanced(self, root):\\n        \\n        def getNodeDepth(node):\\n            if(node==None):return 0;\\n\\n            stack=[(node,1)];\\n            dep=1;\\n\\n            while(len(stack)):\\n                first,dep=stack.pop(0);\\n                if(first.left!=None):\\n                    stack.append((first.left,dep+1));\\n                if(first.right!=None):\\n                    stack.append((first.right,dep+1));\\n            return dep;\\n        \\n        if(root==None):return True;\\n        l=getNodeDepth(root.left);\\n        r=getNodeDepth(root.right);\\n        \\n        return (abs(l-r)<2) and self.isBalanced(root.left) and self.isBalanced(root.right);",
                "codeTag": "Java"
            },
            {
                "id": 4001321,
                "title": "dfs-iterative-using-stack",
                "content": "# Intuition\\nThe code aims to check whether a given binary tree is balanced or not. A binary tree is considered balanced if the heights of its left and right subtrees differ by at most 1 for all nodes in the tree.\\n\\n# Approach\\nThe code employs an iterative approach using a stack to traverse the binary tree while keeping track of the depths of the left subtrees of each node. Here\\'s a step-by-step explanation of the approach:\\n\\n1. Initialize a stack to perform a depth-first traversal of the binary tree. Each item in the stack is a tuple containing a node and a boolean flag indicating whether the node has been visited.\\n\\n2. Initialize a dictionary depths to store the maximum depth of each node encountered so far. Initially, it\\'s empty.\\n\\n3. While the stack is not empty, pop a node and its visited flag from the stack.\\n\\n4. If the node has been visited (i.e., the flag is True), calculate the depths of its left and right subtrees using the depths dictionary. Check if the tree rooted at this node is balanced by comparing the absolute difference between the depths of its left and right subtrees with 1. If it\\'s greater than 1, return False as the tree is not balanced.\\n\\n5. If the node has not been visited (i.e., the flag is False), mark it as visited and push it back into the stack. Push its left and right children into the stack if they exist.\\n\\n6. Update the depths dictionary with the maximum depth encountered so far for this node.\\n\\nRepeat steps 3-6 until the stack is empty.\\n\\nIf the traversal completes without encountering any unbalanced nodes, return True, indicating that the tree is balanced.\\n\\n# Complexity\\n- Time complexity:\\nThe code performs a single traversal of the binary tree, visiting each node once. Therefore, the time complexity is O(N), where N is the number of nodes in the tree.\\n\\n- Space complexity:\\nThe space complexity is O(H), where H is the height of the binary tree. This is due to the stack used for the iterative traversal and the depths dictionary, which can have at most H entries, one for each level of the tree. In the worst case, for a skewed tree, H can be equal to N, making the space complexity O(N). In a balanced tree, H is approximately log(N), resulting in a space complexity of O(log(N)).\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        stack = [[root,False]]\\n        heights = defaultdict(int)\\n\\n        while stack:\\n            x , visited = stack.pop()\\n\\n            if visited:\\n                leftheight = heights[x.left]\\n                rightheight = heights[x.right]\\n\\n                if abs(rightheight - leftheight) > 1:\\n                    return False\\n                heights[x] = max(leftheight,rightheight) + 1\\n\\n            else:\\n                stack.append([x,True])\\n                if x.right:\\n                    stack.append([x.right,False])\\n                if x.left:\\n                    stack.append([x.left,False])\\n\\n        return True\\n\\n        \\n\\n        \\n\\n\\n        \\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        stack = [[root,False]]\\n        heights = defaultdict(int)\\n\\n        while stack:\\n            x , visited = stack.pop()\\n\\n            if visited:\\n                leftheight = heights[x.left]\\n                rightheight = heights[x.right]\\n\\n                if abs(rightheight - leftheight) > 1:\\n                    return False\\n                heights[x] = max(leftheight,rightheight) + 1\\n\\n            else:\\n                stack.append([x,True])\\n                if x.right:\\n                    stack.append([x.right,False])\\n                if x.left:\\n                    stack.append([x.left,False])\\n\\n        return True\\n\\n        \\n\\n        \\n\\n\\n        \\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797167,
                "title": "dfs-easy-clean-code-c-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Firstly read carefully the definition of balanaced binary tree accoring to leetcode for this question.\\n- It is consirdring only the subtrees associated with the root, not **global heights**  \\n- The way we find the height of tree we can compare it similarly.\\n\\n<img src=\"https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif\">\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- If root is NULLL, it means its a balanced tree.\\n- Use a seperate helper function to compare heights of subtrees, say left and right.\\n- If absolute difference b/w left and right is greater than 1, return -1.\\n- Otherwise return max(left,right)+1.\\n\\n<img src=\"https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif\">\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H) H is max height of tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n<img src=\"https://user-images.githubusercontent.com/73097560/115834477-dbab4500-a447-11eb-908a-139a6edaec5c.gif\">\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int heightHelper(TreeNode* root){\\n        if(root==NULL)return 0;\\n        int left = heightHelper(root->left);\\n        int right = heightHelper(root->right);\\n        if(left == -1 || right == -1)return -1;\\n        if(abs(left-right) > 1)return -1;\\n        return max(left, right)+1;\\n    }\\n\\n\\n    bool isBalanced(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(heightHelper(root)==-1)return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int heightHelper(TreeNode* root){\\n        if(root==NULL)return 0;\\n        int left = heightHelper(root->left);\\n        int right = heightHelper(root->right);\\n        if(left == -1 || right == -1)return -1;\\n        if(abs(left-right) > 1)return -1;\\n        return max(left, right)+1;\\n    }\\n\\n\\n    bool isBalanced(TreeNode* root) {\\n        if(root==NULL)return true;\\n        if(heightHelper(root)==-1)return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726057,
                "title": "easy-c-solution-beat-85-bottom-up-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(Height)\\n\\n# Code\\n```\\nclass Solution {\\n    bool isvalid=true;\\npublic:\\n    int height(TreeNode* &root){\\n        if(!root) return 0;\\n        int lh=height(root->left);\\n        int rh=height(root->right);\\n        if(isvalid&& abs(lh-rh)>1)\\n            isvalid=false;\\n        return max(lh,rh)+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        height(root);\\n        return isvalid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool isvalid=true;\\npublic:\\n    int height(TreeNode* &root){\\n        if(!root) return 0;\\n        int lh=height(root->left);\\n        int rh=height(root->right);\\n        if(isvalid&& abs(lh-rh)>1)\\n            isvalid=false;\\n        return max(lh,rh)+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        height(root);\\n        return isvalid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682884,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int maxDepth(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        int l=maxDepth(root->left);\\n        int r=maxDepth(root->right);\\n       return max(l,r)+1;\\n    }\\n   \\n    bool isBalanced(TreeNode* root) {\\n        if(root==NULL)\\n            return true;\\n       int leftheight=maxDepth(root->left);\\n       int rightheight=maxDepth(root->right);\\n       int diff=abs(leftheight-rightheight);\\n\\n       bool ans=(diff<=1);\\n       bool leftans=isBalanced(root->left);\\n       bool rightans=isBalanced(root->right);\\n       return (ans&&leftans&&rightans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      int maxDepth(TreeNode* root) {\\n        if(root==NULL)\\n            return 0;\\n        int l=maxDepth(root->left);\\n        int r=maxDepth(root->right);\\n       return max(l,r)+1;\\n    }\\n   \\n    bool isBalanced(TreeNode* root) {\\n        if(root==NULL)\\n            return true;\\n       int leftheight=maxDepth(root->left);\\n       int rightheight=maxDepth(root->right);\\n       int diff=abs(leftheight-rightheight);\\n\\n       bool ans=(diff<=1);\\n       bool leftans=isBalanced(root->left);\\n       bool rightans=isBalanced(root->right);\\n       return (ans&&leftans&&rightans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649157,
                "title": "2-recursive-approaches-using-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind difference of height of right and left subtree. If it is less than or equal to 1 then it is height balanced. Call fucntion for right subtree and left subtree. \\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n- Make a function to recursively find if current node and its left child and its right child is height balanced or not.\\n- Current node is height balanced only if difference between height of left subtree and right subtree is less than or equal to 1.\\n- To calculate height make another function as shown.\\n- if current node is height balanced and its right and left child is height balanced then return true.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N**2) as we are visiting every node twice ( 2 recursive functions).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(height)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int height(TreeNode* root ){\\n        <!-- base case -->\\n        if( root == NULL ){\\n            return 0;\\n        }\\n        return 1 + max(height(root->left),height(root->right));\\n    }\\n    bool solve(TreeNode* root){\\n        <!-- base case -->\\n        if( root == NULL ){\\n            return true;\\n        }\\n        <!-- answer for current node -->\\n        bool curr = abs( height(root->left) - height(root->right) ) <= 1;\\n        <!-- answer for left subtree -->\\n        bool leftAns = solve(root->left);\\n        <!-- answer for right subtree -->\\n        bool rightAns = solve(root->right);\\n\\n        if( curr && leftAns && rightAns ){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        return solve(root);\\n    }\\n};\\n```\\n# Approach 2 \\n<!-- Describe your approach to solving the problem. -->\\nThis is the time optimised version of the above approach. Instead of making another function for height we are calculating it simultaneously. We use a pair to store whether our current node is height balanced or not and what is the height at the current level.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(height)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<bool,int> solve(TreeNode* root){\\n        if( root == NULL ){\\n            <!-- pair.first = whether current level is balanced or not -->\\n            <!-- pair.second = height at current level -->\\n            return {true,0};\\n        }\\n        \\n        pair<bool,int> leftAns = solve(root->left);\\n        pair<bool,int> rightAns = solve(root->right);\\n        pair<bool,int> ans;\\n        \\n        bool curr = abs(leftAns.second -rightAns.second) <= 1;\\n        \\n        if( curr && leftAns.first && rightAns.first ){\\n            ans.first = true;\\n            ans.second = 1 + max(leftAns.second,rightAns.second);\\n        }\\n        else{\\n            ans.first = false;\\n        }\\n        return ans;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        return solve(root).first;\\n    }\\n};\\n```\\n\\n**Please upvote :)**",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int height(TreeNode* root ){\\n        <!-- base case -->\\n        if( root == NULL ){\\n            return 0;\\n        }\\n        return 1 + max(height(root->left),height(root->right));\\n    }\\n    bool solve(TreeNode* root){\\n        <!-- base case -->\\n        if( root == NULL ){\\n            return true;\\n        }\\n        <!-- answer for current node -->\\n        bool curr = abs( height(root->left) - height(root->right) ) <= 1;\\n        <!-- answer for left subtree -->\\n        bool leftAns = solve(root->left);\\n        <!-- answer for right subtree -->\\n        bool rightAns = solve(root->right);\\n\\n        if( curr && leftAns && rightAns ){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        return solve(root);\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<bool,int> solve(TreeNode* root){\\n        if( root == NULL ){\\n            <!-- pair.first = whether current level is balanced or not -->\\n            <!-- pair.second = height at current level -->\\n            return {true,0};\\n        }\\n        \\n        pair<bool,int> leftAns = solve(root->left);\\n        pair<bool,int> rightAns = solve(root->right);\\n        pair<bool,int> ans;\\n        \\n        bool curr = abs(leftAns.second -rightAns.second) <= 1;\\n        \\n        if( curr && leftAns.first && rightAns.first ){\\n            ans.first = true;\\n            ans.second = 1 + max(leftAns.second,rightAns.second);\\n        }\\n        else{\\n            ans.first = false;\\n        }\\n        return ans;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        return solve(root).first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644020,
                "title": "c-easy-and-crisp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if(height(root)==-1) return false; // if it is balanced then height will be calculated \\n        //or it will just return -1\\n        return true;\\n    }\\n    int height(TreeNode* root){\\n        if(!root) return 0;\\n        int lefth=height(root->left);\\n        if(lefth==-1) return -1;\\n        int righth=height(root->right);\\n        if(righth==-1) return -1;\\n        if(abs(lefth-righth)>1) return -1;\\n        return max(lefth,righth)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        if(height(root)==-1) return false; // if it is balanced then height will be calculated \\n        //or it will just return -1\\n        return true;\\n    }\\n    int height(TreeNode* root){\\n        if(!root) return 0;\\n        int lefth=height(root->left);\\n        if(lefth==-1) return -1;\\n        int righth=height(root->right);\\n        if(righth==-1) return -1;\\n        if(abs(lefth-righth)>1) return -1;\\n        return max(lefth,righth)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502427,
                "title": "simple-typescript-w-annotations",
                "content": "# Intuition\\nBecause balance depends on the left-max-depth and right-max-depth of every node, I know that every node must be traversed (DFS sounds good).\\n\\n\\n# Approach\\nSo DFS every node.\\n\\nAt every level, we want to return the max-depth to the previous recursive call, so we return Math.max(maxLeftDepth, maxRightDepth).\\nBUT you should add 1 to it to account for the depth of the current node we\\'re on. So `Math.max(maxLeftDepth, maxRightDepth) + 1`\\nThis passes max-depth up the chain of recursion.\\n\\nAfter maxLeftDepth and maxRightDepth are checked, we check to see if they differ by more than 1 -> `Math.abs(maxLeftDepth - maxRightDepth) > 1` and set a global variable `imabalanceFound` to true if that\\'s the case.\\n\\nBase case is when a node is not reached, so return 0 to indicate depth.\\n\\nAt end of function call, return opposite of global variable `imbalanceFound`\\n\\n# Complexity\\n- Time complexity:\\nO(n), since every node is visited\\n\\n- Space complexity:\\nO(1) since, only 1 variable required to hold boolean\\n\\n# Upvote if helpful, thanks y\\'all\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction isBalanced(root: TreeNode | null): boolean {\\n    let imbalanceFound = false;\\n\\n    function dfs (thisNode) {\\n        if(!thisNode) return 0;\\n\\n        else if(!imbalanceFound) { //prevents unnecessary recursion\\n\\n            let leftDepth = dfs(thisNode.left)\\n            let rightDepth = dfs(thisNode.right)\\n\\n            //stops the recursive calls if imbalance found\\n            if(Math.abs(leftDepth - rightDepth) > 1) imbalanceFound = true\\n            \\n            //pass up current depth + max below it\\n            return 1 + Math.max(leftDepth, rightDepth)\\n        \\n        }\\n    }\\n    dfs(root);\\n\\nreturn !imbalanceFound\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     val: number\\n *     left: TreeNode | null\\n *     right: TreeNode | null\\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\\n *         this.val = (val===undefined ? 0 : val)\\n *         this.left = (left===undefined ? null : left)\\n *         this.right = (right===undefined ? null : right)\\n *     }\\n * }\\n */\\n\\nfunction isBalanced(root: TreeNode | null): boolean {\\n    let imbalanceFound = false;\\n\\n    function dfs (thisNode) {\\n        if(!thisNode) return 0;\\n\\n        else if(!imbalanceFound) { //prevents unnecessary recursion\\n\\n            let leftDepth = dfs(thisNode.left)\\n            let rightDepth = dfs(thisNode.right)\\n\\n            //stops the recursive calls if imbalance found\\n            if(Math.abs(leftDepth - rightDepth) > 1) imbalanceFound = true\\n            \\n            //pass up current depth + max below it\\n            return 1 + Math.max(leftDepth, rightDepth)\\n        \\n        }\\n    }\\n    dfs(root);\\n\\nreturn !imbalanceFound\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459666,
                "title": "c-time-o-n-easy-to-understand",
                "content": "````\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,bool &ans,int &h){\\n        if(root == NULL||!ans){\\n            return;\\n        }\\n        int l=0,r=0;\\n        solve(root->left,ans,l);\\n        solve(root->right,ans,r);\\n        h = max(l,r)+1;\\n        if(abs(l-r)>1){\\n            ans = false;\\n        }\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        bool ans = true;\\n        int h = 0;\\n        solve(root,ans,h);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,bool &ans,int &h){\\n        if(root == NULL||!ans){\\n            return;\\n        }\\n        int l=0,r=0;\\n        solve(root->left,ans,l);\\n        solve(root->right,ans,r);\\n        h = max(l,r)+1;\\n        if(abs(l-r)>1){\\n            ans = false;\\n        }\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        bool ans = true;\\n        int h = 0;\\n        solve(root,ans,h);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373927,
                "title": "easy-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\npublic static int search(TreeNode root){\\n    if(root==null){\\n        return 0;\\n    }\\n    int leftheight=search(root.left);\\n    if(leftheight==-1){\\n        return -1;\\n    }\\n    int rightheight=search(root.right);\\n    if(rightheight==-1){\\n        return -1;\\n    }\\n    if(Math.abs(leftheight-rightheight)>1){\\n        return -1;\\n    }\\n    return 1+Math.max(leftheight,rightheight);\\n    \\n    \\n}\\n    public boolean isBalanced(TreeNode root) {\\n             return search(root)!=-1;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\npublic static int search(TreeNode root){\\n    if(root==null){\\n        return 0;\\n    }\\n    int leftheight=search(root.left);\\n    if(leftheight==-1){\\n        return -1;\\n    }\\n    int rightheight=search(root.right);\\n    if(rightheight==-1){\\n        return -1;\\n    }\\n    if(Math.abs(leftheight-rightheight)>1){\\n        return -1;\\n    }\\n    return 1+Math.max(leftheight,rightheight);\\n    \\n    \\n}\\n    public boolean isBalanced(TreeNode root) {\\n             return search(root)!=-1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292199,
                "title": "isbalanced-python-solution-recursion",
                "content": "\\n# Approach\\n- First check if it is an empty/null tree or not\\n- left and right : To check the left and right side of the binary tree from a particular root\\n- balance will check:\\n- - If the complete left side of the binary tree is balanced or not. \\n- - if the complete right side of the binary tree is balanced or not.\\n- - And the difference between their abs height <=1\\n- dfs() returns true/false as well as the maximum height of the tree\\n- isBalanced() returns only the bool value\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def dfs(root):\\n        \\n            if root == None:\\n                return [True,0]\\n        \\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            balance = (left[0] and right[0] and abs(left[1]-right[1])<=1)\\n        \\n            return [balance, 1 + max(left[1],right[1])]\\n        \\n        return dfs(root)[0]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def dfs(root):\\n        \\n            if root == None:\\n                return [True,0]\\n        \\n            left = dfs(root.left)\\n            right = dfs(root.right)\\n            balance = (left[0] and right[0] and abs(left[1]-right[1])<=1)\\n        \\n            return [balance, 1 + max(left[1],right[1])]\\n        \\n        return dfs(root)[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024641,
                "title": "java-simple-and-fast-solution",
                "content": "// As per defination of balanced tree if the difference in height of left subtree and right subtree is <=1 then true else false \\n\\n    public boolean isBalanced(TreeNode root) {\\n        int ans = Height(root);\\n        return ans ==-1?false:true ;\\n        \\n    }\\n    // Cal Height of tree \\n    public int Height(TreeNode root){\\n        if(root ==null){\\n            return  0 ;\\n        }\\n        \\n        int left = Height(root.left);\\n        if(left ==-1){\\n            return -1 ;\\n        }\\n        int right = Height(root.right);\\n        if(right == -1){\\n            return -1 ;\\n        }\\n        \\n        return Math.abs(left-right)>1?-1:1+Math.max(left,right);\\n    }\\n",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "// As per defination of balanced tree if the difference in height of left subtree and right subtree is <=1 then true else false \\n\\n    public boolean isBalanced(TreeNode root) {\\n        int ans = Height(root);\\n        return ans ==-1?false:true ;\\n        \\n    }\\n    // Cal Height of tree \\n    public int Height(TreeNode root){\\n        if(root ==null){\\n            return  0 ;\\n        }\\n        \\n        int left = Height(root.left);\\n        if(left ==-1){\\n            return -1 ;\\n        }\\n        int right = Height(root.right);\\n        if(right == -1){\\n            return -1 ;\\n        }\\n        \\n        return Math.abs(left-right)>1?-1:1+Math.max(left,right);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3008272,
                "title": "java-1ms-easy",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return dfsHeight(root) !=-1;\\n    }\\n    int dfsHeight(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n        int leftHeight=dfsHeight(root.left);\\n        if(leftHeight==-1) return -1;\\n        int rightHeight=dfsHeight(root.right);\\n        if(rightHeight==-1) return -1;\\n\\n        if(Math.abs(leftHeight-rightHeight)>1) return -1;\\n        return Math.max(leftHeight,rightHeight)+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isBalanced(TreeNode root) {\\n        return dfsHeight(root) !=-1;\\n    }\\n    int dfsHeight(TreeNode root){\\n        if(root==null){\\n            return 0;\\n        }\\n        int leftHeight=dfsHeight(root.left);\\n        if(leftHeight==-1) return -1;\\n        int rightHeight=dfsHeight(root.right);\\n        if(rightHeight==-1) return -1;\\n\\n        if(Math.abs(leftHeight-rightHeight)>1) return -1;\\n        return Math.max(leftHeight,rightHeight)+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940264,
                "title": "clean-and-efficient-o-n-time-solution",
                "content": "Naive approach would be to traverse every node of the tree and determine if its\\' subtree is balanced.\\n\\nInstead, we will be traversing down to the leaves and then calculating the height. This approach would give us $O(n)$ time complexity as we never solve the same problem multiple times, building the solution bottom to top using the heights calculated previously.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc isBalanced(root *TreeNode) bool {\\n    res, _ := dfs(root)\\n    return res\\n}\\n\\nfunc dfs(root *TreeNode) (bool, int) {\\n    if root == nil {\\n        return true, 0\\n    }\\n\\n    isLeftBalanced, leftHeight := dfs(root.Left)\\n    isRightBalanced, rightHeight := dfs(root.Right)\\n    diff := abs(leftHeight - rightHeight)\\n    if isLeftBalanced && isRightBalanced && diff <= 1 {\\n        return true, 1 + max(leftHeight, rightHeight)\\n    }\\n    return false, -1\\n}\\n\\nfunc abs(n int) int {\\n    if n < 0 {\\n        return -n\\n    }\\n    return n\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc isBalanced(root *TreeNode) bool {\\n    res, _ := dfs(root)\\n    return res\\n}\\n\\nfunc dfs(root *TreeNode) (bool, int) {\\n    if root == nil {\\n        return true, 0\\n    }\\n\\n    isLeftBalanced, leftHeight := dfs(root.Left)\\n    isRightBalanced, rightHeight := dfs(root.Right)\\n    diff := abs(leftHeight - rightHeight)\\n    if isLeftBalanced && isRightBalanced && diff <= 1 {\\n        return true, 1 + max(leftHeight, rightHeight)\\n    }\\n    return false, -1\\n}\\n\\nfunc abs(n int) int {\\n    if n < 0 {\\n        return -n\\n    }\\n    return n\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2940263,
                "title": "clean-and-efficient-o-n-time-solution",
                "content": "Naive approach would be to traverse every node of the tree and determine if its\\' subtree is balanced.\\n\\nInstead, we will be traversing down to the leaves and then calculating the height. This approach would give us $O(n)$ time complexity as we never solve the same problem multiple times, building the solution bottom to top using the heights calculated previously.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc isBalanced(root *TreeNode) bool {\\n    res, _ := dfs(root)\\n    return res\\n}\\n\\nfunc dfs(root *TreeNode) (bool, int) {\\n    if root == nil {\\n        return true, 0\\n    }\\n\\n    isLeftBalanced, leftHeight := dfs(root.Left)\\n    isRightBalanced, rightHeight := dfs(root.Right)\\n    diff := abs(leftHeight - rightHeight)\\n    if isLeftBalanced && isRightBalanced && diff <= 1 {\\n        return true, 1 + max(leftHeight, rightHeight)\\n    }\\n    return false, -1\\n}\\n\\nfunc abs(n int) int {\\n    if n < 0 {\\n        return -n\\n    }\\n    return n\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\n\\nfunc isBalanced(root *TreeNode) bool {\\n    res, _ := dfs(root)\\n    return res\\n}\\n\\nfunc dfs(root *TreeNode) (bool, int) {\\n    if root == nil {\\n        return true, 0\\n    }\\n\\n    isLeftBalanced, leftHeight := dfs(root.Left)\\n    isRightBalanced, rightHeight := dfs(root.Right)\\n    diff := abs(leftHeight - rightHeight)\\n    if isLeftBalanced && isRightBalanced && diff <= 1 {\\n        return true, 1 + max(leftHeight, rightHeight)\\n    }\\n    return false, -1\\n}\\n\\nfunc abs(n int) int {\\n    if n < 0 {\\n        return -n\\n    }\\n    return n\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2931784,
                "title": "beats-98-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        def checkHeight(node):\\n            if not node:\\n                return 0\\n\\n            leftHeight = checkHeight(node.left)\\n            if leftHeight == -1:\\n                return -1\\n\\n            rightHeight = checkHeight(node.right)\\n            if rightHeight == -1:\\n                return -1\\n\\n            if abs(leftHeight - rightHeight) > 1:\\n                return -1\\n            else:\\n                return max(leftHeight, rightHeight) + 1\\n\\n        return checkHeight(root) != -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isBalanced(self, root: TreeNode) -> bool:\\n        def checkHeight(node):\\n            if not node:\\n                return 0\\n\\n            leftHeight = checkHeight(node.left)\\n            if leftHeight == -1:\\n                return -1\\n\\n            rightHeight = checkHeight(node.right)\\n            if rightHeight == -1:\\n                return -1\\n\\n            if abs(leftHeight - rightHeight) > 1:\\n                return -1\\n            else:\\n                return max(leftHeight, rightHeight) + 1\\n\\n        return checkHeight(root) != -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917077,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool ans;\\n    int f(TreeNode* root)\\n    {\\n        if(!root)\\n            return 0;\\n        if(!ans)\\n            return -1;\\n        int l=f(root->left);\\n        int r=f(root->right);\\n        if(abs(l-r) >1)\\n            ans=false;\\n        return 1+max(l,r);\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        ans=true;\\n        int t=f(root);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool ans;\\n    int f(TreeNode* root)\\n    {\\n        if(!root)\\n            return 0;\\n        if(!ans)\\n            return -1;\\n        int l=f(root->left);\\n        int r=f(root->right);\\n        if(abs(l-r) >1)\\n            ans=false;\\n        return 1+max(l,r);\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        ans=true;\\n        int t=f(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2880448,
                "title": "c-solution-runtime-o-n",
                "content": "A ***balanced binary tree***, also referred to as a ***height-balanced binary tree***, is defined as a binary tree in which the height of the left and right subtree of any node differ by not more than 1.\\n             (OR)\\n A binary tree is a balanced binary tree\\n     for every node, ***(height of left tree - height of right tree <= 1)***\\n.\\n.\\n.\\n**1) Naive Approach :** This method checks whether the tree is balanced strictly according to the definition of balanced binary tree.\\t \\n```\\n\\nclass Solution {\\npublic:\\n    // calculates the height of node\\n    int height(TreeNode* root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        return max(height(root->left),height(root->right))+1;\\n    }\\n    \\n    bool isBalanced(TreeNode* root) {\\n       \\n        //Base Case\\n        if(root == NULL){\\n            return true;\\n        }\\n        \\n        int l = height(root->left); //height of left tree\\n        int r = height(root->right); //height of right tree\\n        \\n        if(abs(l - r) > 1){\\n            return false;\\n        }\\n        return isBalanced(root->left) && isBalanced(root->right);\\n    }\\n};\\n\\n```\\t \\n**Time Complexity: O(n^2)**   *- O(n) for calculating the height of tree and O(n) for checking if a tree is balanced or not.*\\n**Space Complexity: O(n)**   *Auxillary stack space at worst case*\\n.\\n.\\n.\\n\\n\\n\\n**2)**   The second method is based on DFS. Instead of calling height() explicitly for each child node, we return the height of the current node in DFS recursion. When the sub tree of the current node is balanced, the function dfsHeight() returns a non-negative value as the height. Otherwise -1 is returned. According to the left Height and right Height of the two children, the parent node could check if the sub tree\\nis balanced, and decides its return value.\\n(Striver\\'s Solution)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dfsheight(TreeNode* root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int l=dfsheight(root->left);\\n        if(l == -1)\\n            return -1;\\n        \\n        int r=dfsheight(root->right);\\n        if(r == -1)\\n            return -1;\\n        \\n        if(abs(l - r) > 1)\\n            return -1;\\n        \\n        return max(l,r)+1;\\n    }\\n    \\n    bool isBalanced(TreeNode* root) {\\n       return dfsheight(root) != -1;\\n    }\\n};\\n```\\n\\n**Time Complexity: O(n)**  \\n**Space Complexity: O(n)**  - *Auxillary stack space at worst case*\\n\\n\\n\\n\\t \\n\\t \\n\\t \\n\\t",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    // calculates the height of node\\n    int height(TreeNode* root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        return max(height(root->left),height(root->right))+1;\\n    }\\n    \\n    bool isBalanced(TreeNode* root) {\\n       \\n        //Base Case\\n        if(root == NULL){\\n            return true;\\n        }\\n        \\n        int l = height(root->left); //height of left tree\\n        int r = height(root->right); //height of right tree\\n        \\n        if(abs(l - r) > 1){\\n            return false;\\n        }\\n        return isBalanced(root->left) && isBalanced(root->right);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int dfsheight(TreeNode* root){\\n        if(root==NULL){\\n            return 0;\\n        }\\n        int l=dfsheight(root->left);\\n        if(l == -1)\\n            return -1;\\n        \\n        int r=dfsheight(root->right);\\n        if(r == -1)\\n            return -1;\\n        \\n        if(abs(l - r) > 1)\\n            return -1;\\n        \\n        return max(l,r)+1;\\n    }\\n    \\n    bool isBalanced(TreeNode* root) {\\n       return dfsheight(root) != -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564727,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1569739,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1565868,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1573305,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1566292,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1794392,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1568314,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1567415,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1567194,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1575507,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1564727,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1569739,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1565868,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1573305,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1566292,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1794392,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1568314,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1567415,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1567194,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1575507,
                "content": [
                    {
                        "username": "Ethan",
                        "content": "Input:\\t{1,2,2,3,3,3,3,4,4,4,4,4,4,#,#,5,5}\\n\\nOutput:\\tfalse (based on balanced binary definition **\"no 2 leaf nodes differ in distance from the root by more than 1\"**)\\n\\nExpected:\\ttrue (base on balanced binary definition **\"two subtrees of every node never differ by more than 1\"** )"
                    },
                    {
                        "username": "poornaprag",
                        "content": "Can someone tell me why this [1,2,2,3,null,null,3,4,null,null,4] is unbalanced?\\nLeft and right nodes, if they exist, are of the same height.\\nWhat am I missing?"
                    },
                    {
                        "username": "prudhvirajch",
                        "content": "[@nairsuchi](/nairsuchi) yes, just keep updating the res/diff as max(res, abs(left - right) for every node and if the res <= 1 return True else False"
                    },
                    {
                        "username": "antivenom",
                        "content": "A Binary Tree is said to be height balanced if for every node the height diff in between the left and right subtree is not more than 1.\\nHere, in this example apart from the root node, no other node is balanced "
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Same issue! cannot understand! it appears to be balanced binary tree... "
                    },
                    {
                        "username": "binamenator",
                        "content": "[@user9137It](/user9137It) The 4 at the end is a child of 3 on the right side. The input is parsed in terms of layers, so this input:\\n\\n[1,2,2,3,null,null,3,4,null,null,4]\\n\\nWill produce this tree:\\n                [1,\\n         2,                   2,\\n    3,         null,   null,         3,\\n4,null,                                null,4]\\n\\nnull nodes can\\'t have children, so that\\'s why they are ommited from the last layer. AFAIK all leet code inputs for trees are created this way.\\n"
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\\n\\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let\\'s say the 2 on the left): This node\\'s left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced. \\n\\nDoes that help?\\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "vicente3j",
                        "content": "Thank the lord I\\'m not the only one facing this problem. What is the 4 at the end even a child of?"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "I faced the same issue, did u get a solution to it?"
                    },
                    {
                        "username": "shashankdutt",
                        "content": "![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)![image](https://assets.leetcode.com/users/shashankdutt/image_1559201587.png)\\n******\\nIn the above test case, I see that the height of node 3 and height of node 5 differs by 2. According to the definition of balanced trees isn\\'t it an un-balanced tree? So, shouldn\\'t the expected output be \"false\"?\\nAny explanation is appreciated.\\nThanks in advance."
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@binamenator](/binamenator) for better understanding it also accept if the difference between left subtree and right subtree should be (-1,0,1)."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "lekhamohan",
                        "content": "This test for balanced binary trees :\\n[1,2,2,3,null,null,3,4,null,null,4] \\nshould be giving `true` right cause it looks balanced to me as I have plotted below(dashed edges mean it is a null)\\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\\n\\n\\nThe difference of depth of every subtree is zero, so my cocde returns `true`. But the expected answer seems to be `false`. Can someone please tell me what am I missing here?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "[@priyanshu_48](/priyanshu_48) for better understanding, the tree is balanced if the difference between left subtree and right subtree is -1 or 0 or 1 (anyone).  please upvote if you got my explanation.\\uD83D\\uDC4D"
                    },
                    {
                        "username": "Lokeshpandey333",
                        "content": "The question isn\\'t asking if the height difference of the lowest leaf node and the highest leaf node.\\n\\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of every node never differs by more than one.\\n\\nBased on this, if have to look at the max depth of the left sub tree from the root (5) and the max depth of the right sub tree from the root (4), so it\\'s considered balanced."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "[@binamenator](/binamenator) illuminating! Thanks. I thought I misunderstood the definition"
                    },
                    {
                        "username": "priyanshu_48",
                        "content": "[@binamenator](/binamenator) No I am not able to understand your explanation. Can you explain, it in detail"
                    },
                    {
                        "username": "sjw1980",
                        "content": "let\\'s see number2 node of left one. left subtree\\'s depth is two (3 and 4) and right subtree\\'s depth is zero. It differs 2. so false."
                    },
                    {
                        "username": "binamenator",
                        "content": "The question isn't asking if the height difference of the lowest leaf node and the highest leaf node.\n\nLeet codes defines a height-balanced binary tree as: a binary tree in which the depth of the two subtrees of **every** node never differs by more than one.\n\nThe key word here is **every**. The root node is balanced because the depths of the left sub tree and right sub tree match. But take any other node (let's say the 2 on the left): This node's left subtree depth is 2 but right subtree depth is 0 (because it has no right child), and therefore it is not balanced.\n\nDoes that help?\nhttps://imgur.com/a/Z0a8s1y"
                    },
                    {
                        "username": "Abhilashreddypatel",
                        "content": "the difference should be 1 as the depth starts with 1\\n"
                    },
                    {
                        "username": "henrygg",
                        "content": "The longest branch is 5 and shortest is 3, but leetcode thinks it is balanced."
                    },
                    {
                        "username": "ram-bhardwaj",
                        "content": "Question is Stated very badly\\n"
                    },
                    {
                        "username": "punk9595",
                        "content": "why isn\\'t BFS the optimal solution here. why DFS? what if we have a mole in the right subtree in the very second level? shouldnt we be terminating the process there instead of going all the way to the depth of left subtree and then right. ? I\\'d appreciate your reply on this."
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "It can be solved using BFS too."
                    },
                    {
                        "username": "pooldiver69",
                        "content": "Hi all,\\nI might totall missunderstood this question. I can passed the test since \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] return ture and I don\\'t get it. Does null consider a real node too?\\nIf so, how to know when the node is on the deeppest level?\\nAny help is appreciated, thank you. \\n![image](https://assets.leetcode.com/users/pooldiver69/image_1569103702.png)\\n"
                    },
                    {
                        "username": "zafarsustbd",
                        "content": "suppose the tree is massively unbalanced. Like, a million nodes deep on one side and three deep on the other. Is there a scenario in which this algorithm blows the stack? Can you fix the implementation so that it never blows the stack, even when given a massively unbalanced tree?"
                    },
                    {
                        "username": "Musfik41",
                        "content": "sorry i have no idea how it is gonna blow the stack\\uD83D\\uDD25"
                    },
                    {
                        "username": "GCorny",
                        "content": "can anyone tell why this case is expected to have a false result?\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "        if(abs(rbalance - lbalance) > 1 ){\\n            return false;\\n        }\\n        \\n        bool left = isBalanced(root->left);\\n        bool right = isBalanced(root->right);\\n\\n        if(left == false || right == false){\\n          return false;\\n        }\\n\\n        return true;\\n\\njust add this after calculating the depth of right and left part of the tree"
                    },
                    {
                        "username": "pponsarandev",
                        "content": "[@nairsuchi](/nairsuchi) for this problem, every subtree of the original input tree has to be balanced, not just the one given as input"
                    },
                    {
                        "username": "panqier",
                        "content": "the differ of sub tree 2,3,4 has only left depth 2and right depth is 0"
                    },
                    {
                        "username": "nairsuchi",
                        "content": "did u get a sultan for this? I am stuck here"
                    }
                ]
            },
            {
                "id": 1572598,
                "content": [
                    {
                        "username": "Sailor20",
                        "content": "How is this use case : \"[1,2,2,3,null,null,3,4,null,null,4] should return false ?\\nAm i correct that following will be the tree structure for above ![image](https://assets.leetcode.com/users/shibha/image_1554673933.png)\\n\\n\\n"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/balanced-binary-tree.html"
                    },
                    {
                        "username": "user8763A",
                        "content": "testCase 84\n[1,null,2,null,3]\nis it correct tree?\nlooks like null node have right child\n ```\n       1\n     /    \\\n    -       2\n  /    \\\n-       3\n```"
                    },
                    {
                        "username": "ling6253112000",
                        "content": "I have the same question"
                    },
                    {
                        "username": "Cole_Donat",
                        "content": "EXPLANATION for testcase [1,2,2,3,null,null,3,4,null,null,4]:\\n\\nIn a balanced tree, *all* nodes must be balanced, not just the root. While the root node is balanced if you check with a depth-first search, every child node is unbalanced. \\n\\nTry checking if the tree is balanced at every step in the traversal, not just the first."
                    },
                    {
                        "username": "Aman_r15",
                        "content": "why this input is true---> [1,2,3,4,5,6,null,8]\\nit should be false. can anyone please help me to understand this."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "A height-balanced binary tree is a binary tree in which the depth of the two subtrees (left and right) of every node never differs by more than one.\\n\\nnode 8 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 4 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 5 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 2 -> left = 2, right = 1 then the differences is 1 (true)\\nnode 6 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 3 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 1 -> left = 3, right = 2 then the differences is 1 (true)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "Explaination after reading the answer\n\n\nAfter checking the answer, I started to know how to treat the binary tree. If my concepts are wrong, please let me know\n\nFirst, each node has a chance of having a left split or right split. For example in example 1, node 3 has a left split 9 and right split [15,20,7]. Then based on this we can talk about depth of the 2 splits. According to the question, no node can have a depth difference more than one for the 2 splits if we want a true return.\n\nTake example 2 as an example. For the [4,3,4] subtree, the depth difference between 2 splits is 0. Then the upper layer [3,2,3] has a left split depth of 2 and a right split depth of 1, so the difference is 1. Then for the [2,1,2] part, the left split has a depth of 3 but the right split has a depth of 1, so the difference is 2 and causing a false return.\n\nBare in mind that without showing a split means the depth is 0. Take example 1 as sample, the node 9 does not show any left or right split means both splits are none (depth 0). Taking this concept we can move on to the next part, which is the part confuse me most at first.\n\n![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)\n\nAt first I thought the answer should be false because the right side has a depth of 2 and the left side has a depth of 4. However, after knowing how depth is actually calculated, I know I was wrong.\n\nFor this tree the left side we start with [5,4,5] the 4 node here have a depth of 1 and left right diff is 0. Then we move up to the [4,3,4] above. Since the left 4 node has 2 5 nodes below, this node 3 has a depth of 2 with the right split having a depth of 1 (only a 4 node on the right). We say this 3 subtree has a depth of 2 and the diff between left and right split is 1. So on move to the above 2 node and we have a subtree of depth 3 on the left split and depth 2 on the right split. Therefore subtree has a depth of 3 and diff of depth between splits 3-2 = 1\n\nNow move to the right hand side. the 3 node on the left is [4,3,4] so it has a depth of 1 and diff = 0. The 2 node above has a depth of 2 and a diff of 1. \n\nBy combineing the result of the 2 largest subtrees, we then can know the left split has a depth of 4, the right side has a depth of 3. Therefore the diff is 1 which fulfill diff <= 1. The answer therefore is true.\n\n\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\n\nTake another example, at first I think the left and right subtree are perfectly symmetric so that should be true. However, I found that is not how depth calculation works.\n\nFor the node 3 on the left side, it has a left split 4 and a none right split. The depth in the view of node 3 therefore is 1 and having a split diff of 1-0 = 1. Remember this fact then we move to the node 2 above. This node 2 has a left split of depth 2 (node 3 + node 4 => depth : 1 + 1 = 2) but a right split of depth 0 (none means nothing > means the depth is 0), which means the depth in the view of node 2 is 2 and having a depth diff of 2 - 0 = 2. This alrealy enough to return a false. The same also happens on the right hand side. the node 1 finally has a depth of 3 and a depth diff of 0 but this is not important as the node 2 view point already violates the true condition.\n\n\nI am very disappointed that the example provided by leetcode cannot let users understand the concept of node tree. I hope this message can save beginners like me from hours of research after checking the answer provided by more experienced users.\n\n\n\n\n\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have understood already how it works but still thanks for explanation"
                    },
                    {
                        "username": "user7368jA",
                        "content": "I am getting Wrong answer in the testcase [1,null,2,null,3], but this is only when I submit the solution. But when I test run that testcase in the console of Leetcode it gets accepted. What is the Problem please fix it. Correct answer is false."
                    },
                    {
                        "username": "ghost204nit",
                        "content": "194 / 227 testcase looks incorrect.  I think input makes height balanced tree, and answer should be true. Am I missing anything? Please help. \\n\\nInput:\\n[1,2,3,4,5,null,6,7,null,null,null,null,8]\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "leitor79",
                        "content": "Hi! I assume you\\'ve already found the answer \\uD83D\\uDE02, but in case someone else is struggling with this, I\\'ll answer: it\\'s not balanced from the \"3\" node, since the left subtree is null and the right subtree has a height of 2. There is another problem with this exact same input where you could see the drawn tree: https://leetcode.com/problems/deepest-leaves-sum/"
                    },
                    {
                        "username": "wol_blue",
                        "content": "![image](https://assets.leetcode.com/users/panfengli/image_1551082094.png)\\n\\n![image](https://assets.leetcode.com/users/panfengli/image_1551082255.png)\\n\\n\\nAdded:\\n\\nI find it is actually a true case. It only compares the depth of two subtrees of the same node. The 2-3-4 one could only compared to 2-3."
                    },
                    {
                        "username": "anakinfoxe",
                        "content": "I got confused with this input. Doesn't it represent a tree like:\\n                      ![enter image description here][1]\\n\\nHow could it be a balanced binary tree?\\n         \\n\\n\\n  [1]: http://s14.postimg.org/ebtn4tmpd/Untitled_drawing.jpg"
                    }
                ]
            },
            {
                "id": 1570266,
                "content": [
                    {
                        "username": "Sailor20",
                        "content": "How is this use case : \"[1,2,2,3,null,null,3,4,null,null,4] should return false ?\\nAm i correct that following will be the tree structure for above ![image](https://assets.leetcode.com/users/shibha/image_1554673933.png)\\n\\n\\n"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/balanced-binary-tree.html"
                    },
                    {
                        "username": "user8763A",
                        "content": "testCase 84\n[1,null,2,null,3]\nis it correct tree?\nlooks like null node have right child\n ```\n       1\n     /    \\\n    -       2\n  /    \\\n-       3\n```"
                    },
                    {
                        "username": "ling6253112000",
                        "content": "I have the same question"
                    },
                    {
                        "username": "Cole_Donat",
                        "content": "EXPLANATION for testcase [1,2,2,3,null,null,3,4,null,null,4]:\\n\\nIn a balanced tree, *all* nodes must be balanced, not just the root. While the root node is balanced if you check with a depth-first search, every child node is unbalanced. \\n\\nTry checking if the tree is balanced at every step in the traversal, not just the first."
                    },
                    {
                        "username": "Aman_r15",
                        "content": "why this input is true---> [1,2,3,4,5,6,null,8]\\nit should be false. can anyone please help me to understand this."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "A height-balanced binary tree is a binary tree in which the depth of the two subtrees (left and right) of every node never differs by more than one.\\n\\nnode 8 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 4 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 5 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 2 -> left = 2, right = 1 then the differences is 1 (true)\\nnode 6 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 3 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 1 -> left = 3, right = 2 then the differences is 1 (true)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "Explaination after reading the answer\n\n\nAfter checking the answer, I started to know how to treat the binary tree. If my concepts are wrong, please let me know\n\nFirst, each node has a chance of having a left split or right split. For example in example 1, node 3 has a left split 9 and right split [15,20,7]. Then based on this we can talk about depth of the 2 splits. According to the question, no node can have a depth difference more than one for the 2 splits if we want a true return.\n\nTake example 2 as an example. For the [4,3,4] subtree, the depth difference between 2 splits is 0. Then the upper layer [3,2,3] has a left split depth of 2 and a right split depth of 1, so the difference is 1. Then for the [2,1,2] part, the left split has a depth of 3 but the right split has a depth of 1, so the difference is 2 and causing a false return.\n\nBare in mind that without showing a split means the depth is 0. Take example 1 as sample, the node 9 does not show any left or right split means both splits are none (depth 0). Taking this concept we can move on to the next part, which is the part confuse me most at first.\n\n![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)\n\nAt first I thought the answer should be false because the right side has a depth of 2 and the left side has a depth of 4. However, after knowing how depth is actually calculated, I know I was wrong.\n\nFor this tree the left side we start with [5,4,5] the 4 node here have a depth of 1 and left right diff is 0. Then we move up to the [4,3,4] above. Since the left 4 node has 2 5 nodes below, this node 3 has a depth of 2 with the right split having a depth of 1 (only a 4 node on the right). We say this 3 subtree has a depth of 2 and the diff between left and right split is 1. So on move to the above 2 node and we have a subtree of depth 3 on the left split and depth 2 on the right split. Therefore subtree has a depth of 3 and diff of depth between splits 3-2 = 1\n\nNow move to the right hand side. the 3 node on the left is [4,3,4] so it has a depth of 1 and diff = 0. The 2 node above has a depth of 2 and a diff of 1. \n\nBy combineing the result of the 2 largest subtrees, we then can know the left split has a depth of 4, the right side has a depth of 3. Therefore the diff is 1 which fulfill diff <= 1. The answer therefore is true.\n\n\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\n\nTake another example, at first I think the left and right subtree are perfectly symmetric so that should be true. However, I found that is not how depth calculation works.\n\nFor the node 3 on the left side, it has a left split 4 and a none right split. The depth in the view of node 3 therefore is 1 and having a split diff of 1-0 = 1. Remember this fact then we move to the node 2 above. This node 2 has a left split of depth 2 (node 3 + node 4 => depth : 1 + 1 = 2) but a right split of depth 0 (none means nothing > means the depth is 0), which means the depth in the view of node 2 is 2 and having a depth diff of 2 - 0 = 2. This alrealy enough to return a false. The same also happens on the right hand side. the node 1 finally has a depth of 3 and a depth diff of 0 but this is not important as the node 2 view point already violates the true condition.\n\n\nI am very disappointed that the example provided by leetcode cannot let users understand the concept of node tree. I hope this message can save beginners like me from hours of research after checking the answer provided by more experienced users.\n\n\n\n\n\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have understood already how it works but still thanks for explanation"
                    },
                    {
                        "username": "user7368jA",
                        "content": "I am getting Wrong answer in the testcase [1,null,2,null,3], but this is only when I submit the solution. But when I test run that testcase in the console of Leetcode it gets accepted. What is the Problem please fix it. Correct answer is false."
                    },
                    {
                        "username": "ghost204nit",
                        "content": "194 / 227 testcase looks incorrect.  I think input makes height balanced tree, and answer should be true. Am I missing anything? Please help. \\n\\nInput:\\n[1,2,3,4,5,null,6,7,null,null,null,null,8]\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "leitor79",
                        "content": "Hi! I assume you\\'ve already found the answer \\uD83D\\uDE02, but in case someone else is struggling with this, I\\'ll answer: it\\'s not balanced from the \"3\" node, since the left subtree is null and the right subtree has a height of 2. There is another problem with this exact same input where you could see the drawn tree: https://leetcode.com/problems/deepest-leaves-sum/"
                    },
                    {
                        "username": "wol_blue",
                        "content": "![image](https://assets.leetcode.com/users/panfengli/image_1551082094.png)\\n\\n![image](https://assets.leetcode.com/users/panfengli/image_1551082255.png)\\n\\n\\nAdded:\\n\\nI find it is actually a true case. It only compares the depth of two subtrees of the same node. The 2-3-4 one could only compared to 2-3."
                    },
                    {
                        "username": "anakinfoxe",
                        "content": "I got confused with this input. Doesn't it represent a tree like:\\n                      ![enter image description here][1]\\n\\nHow could it be a balanced binary tree?\\n         \\n\\n\\n  [1]: http://s14.postimg.org/ebtn4tmpd/Untitled_drawing.jpg"
                    }
                ]
            },
            {
                "id": 1903400,
                "content": [
                    {
                        "username": "Sailor20",
                        "content": "How is this use case : \"[1,2,2,3,null,null,3,4,null,null,4] should return false ?\\nAm i correct that following will be the tree structure for above ![image](https://assets.leetcode.com/users/shibha/image_1554673933.png)\\n\\n\\n"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/balanced-binary-tree.html"
                    },
                    {
                        "username": "user8763A",
                        "content": "testCase 84\n[1,null,2,null,3]\nis it correct tree?\nlooks like null node have right child\n ```\n       1\n     /    \\\n    -       2\n  /    \\\n-       3\n```"
                    },
                    {
                        "username": "ling6253112000",
                        "content": "I have the same question"
                    },
                    {
                        "username": "Cole_Donat",
                        "content": "EXPLANATION for testcase [1,2,2,3,null,null,3,4,null,null,4]:\\n\\nIn a balanced tree, *all* nodes must be balanced, not just the root. While the root node is balanced if you check with a depth-first search, every child node is unbalanced. \\n\\nTry checking if the tree is balanced at every step in the traversal, not just the first."
                    },
                    {
                        "username": "Aman_r15",
                        "content": "why this input is true---> [1,2,3,4,5,6,null,8]\\nit should be false. can anyone please help me to understand this."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "A height-balanced binary tree is a binary tree in which the depth of the two subtrees (left and right) of every node never differs by more than one.\\n\\nnode 8 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 4 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 5 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 2 -> left = 2, right = 1 then the differences is 1 (true)\\nnode 6 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 3 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 1 -> left = 3, right = 2 then the differences is 1 (true)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "Explaination after reading the answer\n\n\nAfter checking the answer, I started to know how to treat the binary tree. If my concepts are wrong, please let me know\n\nFirst, each node has a chance of having a left split or right split. For example in example 1, node 3 has a left split 9 and right split [15,20,7]. Then based on this we can talk about depth of the 2 splits. According to the question, no node can have a depth difference more than one for the 2 splits if we want a true return.\n\nTake example 2 as an example. For the [4,3,4] subtree, the depth difference between 2 splits is 0. Then the upper layer [3,2,3] has a left split depth of 2 and a right split depth of 1, so the difference is 1. Then for the [2,1,2] part, the left split has a depth of 3 but the right split has a depth of 1, so the difference is 2 and causing a false return.\n\nBare in mind that without showing a split means the depth is 0. Take example 1 as sample, the node 9 does not show any left or right split means both splits are none (depth 0). Taking this concept we can move on to the next part, which is the part confuse me most at first.\n\n![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)\n\nAt first I thought the answer should be false because the right side has a depth of 2 and the left side has a depth of 4. However, after knowing how depth is actually calculated, I know I was wrong.\n\nFor this tree the left side we start with [5,4,5] the 4 node here have a depth of 1 and left right diff is 0. Then we move up to the [4,3,4] above. Since the left 4 node has 2 5 nodes below, this node 3 has a depth of 2 with the right split having a depth of 1 (only a 4 node on the right). We say this 3 subtree has a depth of 2 and the diff between left and right split is 1. So on move to the above 2 node and we have a subtree of depth 3 on the left split and depth 2 on the right split. Therefore subtree has a depth of 3 and diff of depth between splits 3-2 = 1\n\nNow move to the right hand side. the 3 node on the left is [4,3,4] so it has a depth of 1 and diff = 0. The 2 node above has a depth of 2 and a diff of 1. \n\nBy combineing the result of the 2 largest subtrees, we then can know the left split has a depth of 4, the right side has a depth of 3. Therefore the diff is 1 which fulfill diff <= 1. The answer therefore is true.\n\n\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\n\nTake another example, at first I think the left and right subtree are perfectly symmetric so that should be true. However, I found that is not how depth calculation works.\n\nFor the node 3 on the left side, it has a left split 4 and a none right split. The depth in the view of node 3 therefore is 1 and having a split diff of 1-0 = 1. Remember this fact then we move to the node 2 above. This node 2 has a left split of depth 2 (node 3 + node 4 => depth : 1 + 1 = 2) but a right split of depth 0 (none means nothing > means the depth is 0), which means the depth in the view of node 2 is 2 and having a depth diff of 2 - 0 = 2. This alrealy enough to return a false. The same also happens on the right hand side. the node 1 finally has a depth of 3 and a depth diff of 0 but this is not important as the node 2 view point already violates the true condition.\n\n\nI am very disappointed that the example provided by leetcode cannot let users understand the concept of node tree. I hope this message can save beginners like me from hours of research after checking the answer provided by more experienced users.\n\n\n\n\n\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have understood already how it works but still thanks for explanation"
                    },
                    {
                        "username": "user7368jA",
                        "content": "I am getting Wrong answer in the testcase [1,null,2,null,3], but this is only when I submit the solution. But when I test run that testcase in the console of Leetcode it gets accepted. What is the Problem please fix it. Correct answer is false."
                    },
                    {
                        "username": "ghost204nit",
                        "content": "194 / 227 testcase looks incorrect.  I think input makes height balanced tree, and answer should be true. Am I missing anything? Please help. \\n\\nInput:\\n[1,2,3,4,5,null,6,7,null,null,null,null,8]\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "leitor79",
                        "content": "Hi! I assume you\\'ve already found the answer \\uD83D\\uDE02, but in case someone else is struggling with this, I\\'ll answer: it\\'s not balanced from the \"3\" node, since the left subtree is null and the right subtree has a height of 2. There is another problem with this exact same input where you could see the drawn tree: https://leetcode.com/problems/deepest-leaves-sum/"
                    },
                    {
                        "username": "wol_blue",
                        "content": "![image](https://assets.leetcode.com/users/panfengli/image_1551082094.png)\\n\\n![image](https://assets.leetcode.com/users/panfengli/image_1551082255.png)\\n\\n\\nAdded:\\n\\nI find it is actually a true case. It only compares the depth of two subtrees of the same node. The 2-3-4 one could only compared to 2-3."
                    },
                    {
                        "username": "anakinfoxe",
                        "content": "I got confused with this input. Doesn't it represent a tree like:\\n                      ![enter image description here][1]\\n\\nHow could it be a balanced binary tree?\\n         \\n\\n\\n  [1]: http://s14.postimg.org/ebtn4tmpd/Untitled_drawing.jpg"
                    }
                ]
            },
            {
                "id": 1748935,
                "content": [
                    {
                        "username": "Sailor20",
                        "content": "How is this use case : \"[1,2,2,3,null,null,3,4,null,null,4] should return false ?\\nAm i correct that following will be the tree structure for above ![image](https://assets.leetcode.com/users/shibha/image_1554673933.png)\\n\\n\\n"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/balanced-binary-tree.html"
                    },
                    {
                        "username": "user8763A",
                        "content": "testCase 84\n[1,null,2,null,3]\nis it correct tree?\nlooks like null node have right child\n ```\n       1\n     /    \\\n    -       2\n  /    \\\n-       3\n```"
                    },
                    {
                        "username": "ling6253112000",
                        "content": "I have the same question"
                    },
                    {
                        "username": "Cole_Donat",
                        "content": "EXPLANATION for testcase [1,2,2,3,null,null,3,4,null,null,4]:\\n\\nIn a balanced tree, *all* nodes must be balanced, not just the root. While the root node is balanced if you check with a depth-first search, every child node is unbalanced. \\n\\nTry checking if the tree is balanced at every step in the traversal, not just the first."
                    },
                    {
                        "username": "Aman_r15",
                        "content": "why this input is true---> [1,2,3,4,5,6,null,8]\\nit should be false. can anyone please help me to understand this."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "A height-balanced binary tree is a binary tree in which the depth of the two subtrees (left and right) of every node never differs by more than one.\\n\\nnode 8 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 4 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 5 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 2 -> left = 2, right = 1 then the differences is 1 (true)\\nnode 6 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 3 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 1 -> left = 3, right = 2 then the differences is 1 (true)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "Explaination after reading the answer\n\n\nAfter checking the answer, I started to know how to treat the binary tree. If my concepts are wrong, please let me know\n\nFirst, each node has a chance of having a left split or right split. For example in example 1, node 3 has a left split 9 and right split [15,20,7]. Then based on this we can talk about depth of the 2 splits. According to the question, no node can have a depth difference more than one for the 2 splits if we want a true return.\n\nTake example 2 as an example. For the [4,3,4] subtree, the depth difference between 2 splits is 0. Then the upper layer [3,2,3] has a left split depth of 2 and a right split depth of 1, so the difference is 1. Then for the [2,1,2] part, the left split has a depth of 3 but the right split has a depth of 1, so the difference is 2 and causing a false return.\n\nBare in mind that without showing a split means the depth is 0. Take example 1 as sample, the node 9 does not show any left or right split means both splits are none (depth 0). Taking this concept we can move on to the next part, which is the part confuse me most at first.\n\n![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)\n\nAt first I thought the answer should be false because the right side has a depth of 2 and the left side has a depth of 4. However, after knowing how depth is actually calculated, I know I was wrong.\n\nFor this tree the left side we start with [5,4,5] the 4 node here have a depth of 1 and left right diff is 0. Then we move up to the [4,3,4] above. Since the left 4 node has 2 5 nodes below, this node 3 has a depth of 2 with the right split having a depth of 1 (only a 4 node on the right). We say this 3 subtree has a depth of 2 and the diff between left and right split is 1. So on move to the above 2 node and we have a subtree of depth 3 on the left split and depth 2 on the right split. Therefore subtree has a depth of 3 and diff of depth between splits 3-2 = 1\n\nNow move to the right hand side. the 3 node on the left is [4,3,4] so it has a depth of 1 and diff = 0. The 2 node above has a depth of 2 and a diff of 1. \n\nBy combineing the result of the 2 largest subtrees, we then can know the left split has a depth of 4, the right side has a depth of 3. Therefore the diff is 1 which fulfill diff <= 1. The answer therefore is true.\n\n\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\n\nTake another example, at first I think the left and right subtree are perfectly symmetric so that should be true. However, I found that is not how depth calculation works.\n\nFor the node 3 on the left side, it has a left split 4 and a none right split. The depth in the view of node 3 therefore is 1 and having a split diff of 1-0 = 1. Remember this fact then we move to the node 2 above. This node 2 has a left split of depth 2 (node 3 + node 4 => depth : 1 + 1 = 2) but a right split of depth 0 (none means nothing > means the depth is 0), which means the depth in the view of node 2 is 2 and having a depth diff of 2 - 0 = 2. This alrealy enough to return a false. The same also happens on the right hand side. the node 1 finally has a depth of 3 and a depth diff of 0 but this is not important as the node 2 view point already violates the true condition.\n\n\nI am very disappointed that the example provided by leetcode cannot let users understand the concept of node tree. I hope this message can save beginners like me from hours of research after checking the answer provided by more experienced users.\n\n\n\n\n\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have understood already how it works but still thanks for explanation"
                    },
                    {
                        "username": "user7368jA",
                        "content": "I am getting Wrong answer in the testcase [1,null,2,null,3], but this is only when I submit the solution. But when I test run that testcase in the console of Leetcode it gets accepted. What is the Problem please fix it. Correct answer is false."
                    },
                    {
                        "username": "ghost204nit",
                        "content": "194 / 227 testcase looks incorrect.  I think input makes height balanced tree, and answer should be true. Am I missing anything? Please help. \\n\\nInput:\\n[1,2,3,4,5,null,6,7,null,null,null,null,8]\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "leitor79",
                        "content": "Hi! I assume you\\'ve already found the answer \\uD83D\\uDE02, but in case someone else is struggling with this, I\\'ll answer: it\\'s not balanced from the \"3\" node, since the left subtree is null and the right subtree has a height of 2. There is another problem with this exact same input where you could see the drawn tree: https://leetcode.com/problems/deepest-leaves-sum/"
                    },
                    {
                        "username": "wol_blue",
                        "content": "![image](https://assets.leetcode.com/users/panfengli/image_1551082094.png)\\n\\n![image](https://assets.leetcode.com/users/panfengli/image_1551082255.png)\\n\\n\\nAdded:\\n\\nI find it is actually a true case. It only compares the depth of two subtrees of the same node. The 2-3-4 one could only compared to 2-3."
                    },
                    {
                        "username": "anakinfoxe",
                        "content": "I got confused with this input. Doesn't it represent a tree like:\\n                      ![enter image description here][1]\\n\\nHow could it be a balanced binary tree?\\n         \\n\\n\\n  [1]: http://s14.postimg.org/ebtn4tmpd/Untitled_drawing.jpg"
                    }
                ]
            },
            {
                "id": 1959120,
                "content": [
                    {
                        "username": "Sailor20",
                        "content": "How is this use case : \"[1,2,2,3,null,null,3,4,null,null,4] should return false ?\\nAm i correct that following will be the tree structure for above ![image](https://assets.leetcode.com/users/shibha/image_1554673933.png)\\n\\n\\n"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/balanced-binary-tree.html"
                    },
                    {
                        "username": "user8763A",
                        "content": "testCase 84\n[1,null,2,null,3]\nis it correct tree?\nlooks like null node have right child\n ```\n       1\n     /    \\\n    -       2\n  /    \\\n-       3\n```"
                    },
                    {
                        "username": "ling6253112000",
                        "content": "I have the same question"
                    },
                    {
                        "username": "Cole_Donat",
                        "content": "EXPLANATION for testcase [1,2,2,3,null,null,3,4,null,null,4]:\\n\\nIn a balanced tree, *all* nodes must be balanced, not just the root. While the root node is balanced if you check with a depth-first search, every child node is unbalanced. \\n\\nTry checking if the tree is balanced at every step in the traversal, not just the first."
                    },
                    {
                        "username": "Aman_r15",
                        "content": "why this input is true---> [1,2,3,4,5,6,null,8]\\nit should be false. can anyone please help me to understand this."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "A height-balanced binary tree is a binary tree in which the depth of the two subtrees (left and right) of every node never differs by more than one.\\n\\nnode 8 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 4 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 5 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 2 -> left = 2, right = 1 then the differences is 1 (true)\\nnode 6 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 3 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 1 -> left = 3, right = 2 then the differences is 1 (true)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "Explaination after reading the answer\n\n\nAfter checking the answer, I started to know how to treat the binary tree. If my concepts are wrong, please let me know\n\nFirst, each node has a chance of having a left split or right split. For example in example 1, node 3 has a left split 9 and right split [15,20,7]. Then based on this we can talk about depth of the 2 splits. According to the question, no node can have a depth difference more than one for the 2 splits if we want a true return.\n\nTake example 2 as an example. For the [4,3,4] subtree, the depth difference between 2 splits is 0. Then the upper layer [3,2,3] has a left split depth of 2 and a right split depth of 1, so the difference is 1. Then for the [2,1,2] part, the left split has a depth of 3 but the right split has a depth of 1, so the difference is 2 and causing a false return.\n\nBare in mind that without showing a split means the depth is 0. Take example 1 as sample, the node 9 does not show any left or right split means both splits are none (depth 0). Taking this concept we can move on to the next part, which is the part confuse me most at first.\n\n![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)\n\nAt first I thought the answer should be false because the right side has a depth of 2 and the left side has a depth of 4. However, after knowing how depth is actually calculated, I know I was wrong.\n\nFor this tree the left side we start with [5,4,5] the 4 node here have a depth of 1 and left right diff is 0. Then we move up to the [4,3,4] above. Since the left 4 node has 2 5 nodes below, this node 3 has a depth of 2 with the right split having a depth of 1 (only a 4 node on the right). We say this 3 subtree has a depth of 2 and the diff between left and right split is 1. So on move to the above 2 node and we have a subtree of depth 3 on the left split and depth 2 on the right split. Therefore subtree has a depth of 3 and diff of depth between splits 3-2 = 1\n\nNow move to the right hand side. the 3 node on the left is [4,3,4] so it has a depth of 1 and diff = 0. The 2 node above has a depth of 2 and a diff of 1. \n\nBy combineing the result of the 2 largest subtrees, we then can know the left split has a depth of 4, the right side has a depth of 3. Therefore the diff is 1 which fulfill diff <= 1. The answer therefore is true.\n\n\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\n\nTake another example, at first I think the left and right subtree are perfectly symmetric so that should be true. However, I found that is not how depth calculation works.\n\nFor the node 3 on the left side, it has a left split 4 and a none right split. The depth in the view of node 3 therefore is 1 and having a split diff of 1-0 = 1. Remember this fact then we move to the node 2 above. This node 2 has a left split of depth 2 (node 3 + node 4 => depth : 1 + 1 = 2) but a right split of depth 0 (none means nothing > means the depth is 0), which means the depth in the view of node 2 is 2 and having a depth diff of 2 - 0 = 2. This alrealy enough to return a false. The same also happens on the right hand side. the node 1 finally has a depth of 3 and a depth diff of 0 but this is not important as the node 2 view point already violates the true condition.\n\n\nI am very disappointed that the example provided by leetcode cannot let users understand the concept of node tree. I hope this message can save beginners like me from hours of research after checking the answer provided by more experienced users.\n\n\n\n\n\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have understood already how it works but still thanks for explanation"
                    },
                    {
                        "username": "user7368jA",
                        "content": "I am getting Wrong answer in the testcase [1,null,2,null,3], but this is only when I submit the solution. But when I test run that testcase in the console of Leetcode it gets accepted. What is the Problem please fix it. Correct answer is false."
                    },
                    {
                        "username": "ghost204nit",
                        "content": "194 / 227 testcase looks incorrect.  I think input makes height balanced tree, and answer should be true. Am I missing anything? Please help. \\n\\nInput:\\n[1,2,3,4,5,null,6,7,null,null,null,null,8]\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "leitor79",
                        "content": "Hi! I assume you\\'ve already found the answer \\uD83D\\uDE02, but in case someone else is struggling with this, I\\'ll answer: it\\'s not balanced from the \"3\" node, since the left subtree is null and the right subtree has a height of 2. There is another problem with this exact same input where you could see the drawn tree: https://leetcode.com/problems/deepest-leaves-sum/"
                    },
                    {
                        "username": "wol_blue",
                        "content": "![image](https://assets.leetcode.com/users/panfengli/image_1551082094.png)\\n\\n![image](https://assets.leetcode.com/users/panfengli/image_1551082255.png)\\n\\n\\nAdded:\\n\\nI find it is actually a true case. It only compares the depth of two subtrees of the same node. The 2-3-4 one could only compared to 2-3."
                    },
                    {
                        "username": "anakinfoxe",
                        "content": "I got confused with this input. Doesn't it represent a tree like:\\n                      ![enter image description here][1]\\n\\nHow could it be a balanced binary tree?\\n         \\n\\n\\n  [1]: http://s14.postimg.org/ebtn4tmpd/Untitled_drawing.jpg"
                    }
                ]
            },
            {
                "id": 1915107,
                "content": [
                    {
                        "username": "Sailor20",
                        "content": "How is this use case : \"[1,2,2,3,null,null,3,4,null,null,4] should return false ?\\nAm i correct that following will be the tree structure for above ![image](https://assets.leetcode.com/users/shibha/image_1554673933.png)\\n\\n\\n"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/balanced-binary-tree.html"
                    },
                    {
                        "username": "user8763A",
                        "content": "testCase 84\n[1,null,2,null,3]\nis it correct tree?\nlooks like null node have right child\n ```\n       1\n     /    \\\n    -       2\n  /    \\\n-       3\n```"
                    },
                    {
                        "username": "ling6253112000",
                        "content": "I have the same question"
                    },
                    {
                        "username": "Cole_Donat",
                        "content": "EXPLANATION for testcase [1,2,2,3,null,null,3,4,null,null,4]:\\n\\nIn a balanced tree, *all* nodes must be balanced, not just the root. While the root node is balanced if you check with a depth-first search, every child node is unbalanced. \\n\\nTry checking if the tree is balanced at every step in the traversal, not just the first."
                    },
                    {
                        "username": "Aman_r15",
                        "content": "why this input is true---> [1,2,3,4,5,6,null,8]\\nit should be false. can anyone please help me to understand this."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "A height-balanced binary tree is a binary tree in which the depth of the two subtrees (left and right) of every node never differs by more than one.\\n\\nnode 8 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 4 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 5 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 2 -> left = 2, right = 1 then the differences is 1 (true)\\nnode 6 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 3 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 1 -> left = 3, right = 2 then the differences is 1 (true)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "Explaination after reading the answer\n\n\nAfter checking the answer, I started to know how to treat the binary tree. If my concepts are wrong, please let me know\n\nFirst, each node has a chance of having a left split or right split. For example in example 1, node 3 has a left split 9 and right split [15,20,7]. Then based on this we can talk about depth of the 2 splits. According to the question, no node can have a depth difference more than one for the 2 splits if we want a true return.\n\nTake example 2 as an example. For the [4,3,4] subtree, the depth difference between 2 splits is 0. Then the upper layer [3,2,3] has a left split depth of 2 and a right split depth of 1, so the difference is 1. Then for the [2,1,2] part, the left split has a depth of 3 but the right split has a depth of 1, so the difference is 2 and causing a false return.\n\nBare in mind that without showing a split means the depth is 0. Take example 1 as sample, the node 9 does not show any left or right split means both splits are none (depth 0). Taking this concept we can move on to the next part, which is the part confuse me most at first.\n\n![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)\n\nAt first I thought the answer should be false because the right side has a depth of 2 and the left side has a depth of 4. However, after knowing how depth is actually calculated, I know I was wrong.\n\nFor this tree the left side we start with [5,4,5] the 4 node here have a depth of 1 and left right diff is 0. Then we move up to the [4,3,4] above. Since the left 4 node has 2 5 nodes below, this node 3 has a depth of 2 with the right split having a depth of 1 (only a 4 node on the right). We say this 3 subtree has a depth of 2 and the diff between left and right split is 1. So on move to the above 2 node and we have a subtree of depth 3 on the left split and depth 2 on the right split. Therefore subtree has a depth of 3 and diff of depth between splits 3-2 = 1\n\nNow move to the right hand side. the 3 node on the left is [4,3,4] so it has a depth of 1 and diff = 0. The 2 node above has a depth of 2 and a diff of 1. \n\nBy combineing the result of the 2 largest subtrees, we then can know the left split has a depth of 4, the right side has a depth of 3. Therefore the diff is 1 which fulfill diff <= 1. The answer therefore is true.\n\n\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\n\nTake another example, at first I think the left and right subtree are perfectly symmetric so that should be true. However, I found that is not how depth calculation works.\n\nFor the node 3 on the left side, it has a left split 4 and a none right split. The depth in the view of node 3 therefore is 1 and having a split diff of 1-0 = 1. Remember this fact then we move to the node 2 above. This node 2 has a left split of depth 2 (node 3 + node 4 => depth : 1 + 1 = 2) but a right split of depth 0 (none means nothing > means the depth is 0), which means the depth in the view of node 2 is 2 and having a depth diff of 2 - 0 = 2. This alrealy enough to return a false. The same also happens on the right hand side. the node 1 finally has a depth of 3 and a depth diff of 0 but this is not important as the node 2 view point already violates the true condition.\n\n\nI am very disappointed that the example provided by leetcode cannot let users understand the concept of node tree. I hope this message can save beginners like me from hours of research after checking the answer provided by more experienced users.\n\n\n\n\n\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have understood already how it works but still thanks for explanation"
                    },
                    {
                        "username": "user7368jA",
                        "content": "I am getting Wrong answer in the testcase [1,null,2,null,3], but this is only when I submit the solution. But when I test run that testcase in the console of Leetcode it gets accepted. What is the Problem please fix it. Correct answer is false."
                    },
                    {
                        "username": "ghost204nit",
                        "content": "194 / 227 testcase looks incorrect.  I think input makes height balanced tree, and answer should be true. Am I missing anything? Please help. \\n\\nInput:\\n[1,2,3,4,5,null,6,7,null,null,null,null,8]\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "leitor79",
                        "content": "Hi! I assume you\\'ve already found the answer \\uD83D\\uDE02, but in case someone else is struggling with this, I\\'ll answer: it\\'s not balanced from the \"3\" node, since the left subtree is null and the right subtree has a height of 2. There is another problem with this exact same input where you could see the drawn tree: https://leetcode.com/problems/deepest-leaves-sum/"
                    },
                    {
                        "username": "wol_blue",
                        "content": "![image](https://assets.leetcode.com/users/panfengli/image_1551082094.png)\\n\\n![image](https://assets.leetcode.com/users/panfengli/image_1551082255.png)\\n\\n\\nAdded:\\n\\nI find it is actually a true case. It only compares the depth of two subtrees of the same node. The 2-3-4 one could only compared to 2-3."
                    },
                    {
                        "username": "anakinfoxe",
                        "content": "I got confused with this input. Doesn't it represent a tree like:\\n                      ![enter image description here][1]\\n\\nHow could it be a balanced binary tree?\\n         \\n\\n\\n  [1]: http://s14.postimg.org/ebtn4tmpd/Untitled_drawing.jpg"
                    }
                ]
            },
            {
                "id": 1725160,
                "content": [
                    {
                        "username": "Sailor20",
                        "content": "How is this use case : \"[1,2,2,3,null,null,3,4,null,null,4] should return false ?\\nAm i correct that following will be the tree structure for above ![image](https://assets.leetcode.com/users/shibha/image_1554673933.png)\\n\\n\\n"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/balanced-binary-tree.html"
                    },
                    {
                        "username": "user8763A",
                        "content": "testCase 84\n[1,null,2,null,3]\nis it correct tree?\nlooks like null node have right child\n ```\n       1\n     /    \\\n    -       2\n  /    \\\n-       3\n```"
                    },
                    {
                        "username": "ling6253112000",
                        "content": "I have the same question"
                    },
                    {
                        "username": "Cole_Donat",
                        "content": "EXPLANATION for testcase [1,2,2,3,null,null,3,4,null,null,4]:\\n\\nIn a balanced tree, *all* nodes must be balanced, not just the root. While the root node is balanced if you check with a depth-first search, every child node is unbalanced. \\n\\nTry checking if the tree is balanced at every step in the traversal, not just the first."
                    },
                    {
                        "username": "Aman_r15",
                        "content": "why this input is true---> [1,2,3,4,5,6,null,8]\\nit should be false. can anyone please help me to understand this."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "A height-balanced binary tree is a binary tree in which the depth of the two subtrees (left and right) of every node never differs by more than one.\\n\\nnode 8 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 4 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 5 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 2 -> left = 2, right = 1 then the differences is 1 (true)\\nnode 6 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 3 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 1 -> left = 3, right = 2 then the differences is 1 (true)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "Explaination after reading the answer\n\n\nAfter checking the answer, I started to know how to treat the binary tree. If my concepts are wrong, please let me know\n\nFirst, each node has a chance of having a left split or right split. For example in example 1, node 3 has a left split 9 and right split [15,20,7]. Then based on this we can talk about depth of the 2 splits. According to the question, no node can have a depth difference more than one for the 2 splits if we want a true return.\n\nTake example 2 as an example. For the [4,3,4] subtree, the depth difference between 2 splits is 0. Then the upper layer [3,2,3] has a left split depth of 2 and a right split depth of 1, so the difference is 1. Then for the [2,1,2] part, the left split has a depth of 3 but the right split has a depth of 1, so the difference is 2 and causing a false return.\n\nBare in mind that without showing a split means the depth is 0. Take example 1 as sample, the node 9 does not show any left or right split means both splits are none (depth 0). Taking this concept we can move on to the next part, which is the part confuse me most at first.\n\n![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)\n\nAt first I thought the answer should be false because the right side has a depth of 2 and the left side has a depth of 4. However, after knowing how depth is actually calculated, I know I was wrong.\n\nFor this tree the left side we start with [5,4,5] the 4 node here have a depth of 1 and left right diff is 0. Then we move up to the [4,3,4] above. Since the left 4 node has 2 5 nodes below, this node 3 has a depth of 2 with the right split having a depth of 1 (only a 4 node on the right). We say this 3 subtree has a depth of 2 and the diff between left and right split is 1. So on move to the above 2 node and we have a subtree of depth 3 on the left split and depth 2 on the right split. Therefore subtree has a depth of 3 and diff of depth between splits 3-2 = 1\n\nNow move to the right hand side. the 3 node on the left is [4,3,4] so it has a depth of 1 and diff = 0. The 2 node above has a depth of 2 and a diff of 1. \n\nBy combineing the result of the 2 largest subtrees, we then can know the left split has a depth of 4, the right side has a depth of 3. Therefore the diff is 1 which fulfill diff <= 1. The answer therefore is true.\n\n\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\n\nTake another example, at first I think the left and right subtree are perfectly symmetric so that should be true. However, I found that is not how depth calculation works.\n\nFor the node 3 on the left side, it has a left split 4 and a none right split. The depth in the view of node 3 therefore is 1 and having a split diff of 1-0 = 1. Remember this fact then we move to the node 2 above. This node 2 has a left split of depth 2 (node 3 + node 4 => depth : 1 + 1 = 2) but a right split of depth 0 (none means nothing > means the depth is 0), which means the depth in the view of node 2 is 2 and having a depth diff of 2 - 0 = 2. This alrealy enough to return a false. The same also happens on the right hand side. the node 1 finally has a depth of 3 and a depth diff of 0 but this is not important as the node 2 view point already violates the true condition.\n\n\nI am very disappointed that the example provided by leetcode cannot let users understand the concept of node tree. I hope this message can save beginners like me from hours of research after checking the answer provided by more experienced users.\n\n\n\n\n\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have understood already how it works but still thanks for explanation"
                    },
                    {
                        "username": "user7368jA",
                        "content": "I am getting Wrong answer in the testcase [1,null,2,null,3], but this is only when I submit the solution. But when I test run that testcase in the console of Leetcode it gets accepted. What is the Problem please fix it. Correct answer is false."
                    },
                    {
                        "username": "ghost204nit",
                        "content": "194 / 227 testcase looks incorrect.  I think input makes height balanced tree, and answer should be true. Am I missing anything? Please help. \\n\\nInput:\\n[1,2,3,4,5,null,6,7,null,null,null,null,8]\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "leitor79",
                        "content": "Hi! I assume you\\'ve already found the answer \\uD83D\\uDE02, but in case someone else is struggling with this, I\\'ll answer: it\\'s not balanced from the \"3\" node, since the left subtree is null and the right subtree has a height of 2. There is another problem with this exact same input where you could see the drawn tree: https://leetcode.com/problems/deepest-leaves-sum/"
                    },
                    {
                        "username": "wol_blue",
                        "content": "![image](https://assets.leetcode.com/users/panfengli/image_1551082094.png)\\n\\n![image](https://assets.leetcode.com/users/panfengli/image_1551082255.png)\\n\\n\\nAdded:\\n\\nI find it is actually a true case. It only compares the depth of two subtrees of the same node. The 2-3-4 one could only compared to 2-3."
                    },
                    {
                        "username": "anakinfoxe",
                        "content": "I got confused with this input. Doesn't it represent a tree like:\\n                      ![enter image description here][1]\\n\\nHow could it be a balanced binary tree?\\n         \\n\\n\\n  [1]: http://s14.postimg.org/ebtn4tmpd/Untitled_drawing.jpg"
                    }
                ]
            },
            {
                "id": 1573216,
                "content": [
                    {
                        "username": "Sailor20",
                        "content": "How is this use case : \"[1,2,2,3,null,null,3,4,null,null,4] should return false ?\\nAm i correct that following will be the tree structure for above ![image](https://assets.leetcode.com/users/shibha/image_1554673933.png)\\n\\n\\n"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/balanced-binary-tree.html"
                    },
                    {
                        "username": "user8763A",
                        "content": "testCase 84\n[1,null,2,null,3]\nis it correct tree?\nlooks like null node have right child\n ```\n       1\n     /    \\\n    -       2\n  /    \\\n-       3\n```"
                    },
                    {
                        "username": "ling6253112000",
                        "content": "I have the same question"
                    },
                    {
                        "username": "Cole_Donat",
                        "content": "EXPLANATION for testcase [1,2,2,3,null,null,3,4,null,null,4]:\\n\\nIn a balanced tree, *all* nodes must be balanced, not just the root. While the root node is balanced if you check with a depth-first search, every child node is unbalanced. \\n\\nTry checking if the tree is balanced at every step in the traversal, not just the first."
                    },
                    {
                        "username": "Aman_r15",
                        "content": "why this input is true---> [1,2,3,4,5,6,null,8]\\nit should be false. can anyone please help me to understand this."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "A height-balanced binary tree is a binary tree in which the depth of the two subtrees (left and right) of every node never differs by more than one.\\n\\nnode 8 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 4 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 5 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 2 -> left = 2, right = 1 then the differences is 1 (true)\\nnode 6 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 3 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 1 -> left = 3, right = 2 then the differences is 1 (true)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "Explaination after reading the answer\n\n\nAfter checking the answer, I started to know how to treat the binary tree. If my concepts are wrong, please let me know\n\nFirst, each node has a chance of having a left split or right split. For example in example 1, node 3 has a left split 9 and right split [15,20,7]. Then based on this we can talk about depth of the 2 splits. According to the question, no node can have a depth difference more than one for the 2 splits if we want a true return.\n\nTake example 2 as an example. For the [4,3,4] subtree, the depth difference between 2 splits is 0. Then the upper layer [3,2,3] has a left split depth of 2 and a right split depth of 1, so the difference is 1. Then for the [2,1,2] part, the left split has a depth of 3 but the right split has a depth of 1, so the difference is 2 and causing a false return.\n\nBare in mind that without showing a split means the depth is 0. Take example 1 as sample, the node 9 does not show any left or right split means both splits are none (depth 0). Taking this concept we can move on to the next part, which is the part confuse me most at first.\n\n![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)\n\nAt first I thought the answer should be false because the right side has a depth of 2 and the left side has a depth of 4. However, after knowing how depth is actually calculated, I know I was wrong.\n\nFor this tree the left side we start with [5,4,5] the 4 node here have a depth of 1 and left right diff is 0. Then we move up to the [4,3,4] above. Since the left 4 node has 2 5 nodes below, this node 3 has a depth of 2 with the right split having a depth of 1 (only a 4 node on the right). We say this 3 subtree has a depth of 2 and the diff between left and right split is 1. So on move to the above 2 node and we have a subtree of depth 3 on the left split and depth 2 on the right split. Therefore subtree has a depth of 3 and diff of depth between splits 3-2 = 1\n\nNow move to the right hand side. the 3 node on the left is [4,3,4] so it has a depth of 1 and diff = 0. The 2 node above has a depth of 2 and a diff of 1. \n\nBy combineing the result of the 2 largest subtrees, we then can know the left split has a depth of 4, the right side has a depth of 3. Therefore the diff is 1 which fulfill diff <= 1. The answer therefore is true.\n\n\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\n\nTake another example, at first I think the left and right subtree are perfectly symmetric so that should be true. However, I found that is not how depth calculation works.\n\nFor the node 3 on the left side, it has a left split 4 and a none right split. The depth in the view of node 3 therefore is 1 and having a split diff of 1-0 = 1. Remember this fact then we move to the node 2 above. This node 2 has a left split of depth 2 (node 3 + node 4 => depth : 1 + 1 = 2) but a right split of depth 0 (none means nothing > means the depth is 0), which means the depth in the view of node 2 is 2 and having a depth diff of 2 - 0 = 2. This alrealy enough to return a false. The same also happens on the right hand side. the node 1 finally has a depth of 3 and a depth diff of 0 but this is not important as the node 2 view point already violates the true condition.\n\n\nI am very disappointed that the example provided by leetcode cannot let users understand the concept of node tree. I hope this message can save beginners like me from hours of research after checking the answer provided by more experienced users.\n\n\n\n\n\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have understood already how it works but still thanks for explanation"
                    },
                    {
                        "username": "user7368jA",
                        "content": "I am getting Wrong answer in the testcase [1,null,2,null,3], but this is only when I submit the solution. But when I test run that testcase in the console of Leetcode it gets accepted. What is the Problem please fix it. Correct answer is false."
                    },
                    {
                        "username": "ghost204nit",
                        "content": "194 / 227 testcase looks incorrect.  I think input makes height balanced tree, and answer should be true. Am I missing anything? Please help. \\n\\nInput:\\n[1,2,3,4,5,null,6,7,null,null,null,null,8]\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "leitor79",
                        "content": "Hi! I assume you\\'ve already found the answer \\uD83D\\uDE02, but in case someone else is struggling with this, I\\'ll answer: it\\'s not balanced from the \"3\" node, since the left subtree is null and the right subtree has a height of 2. There is another problem with this exact same input where you could see the drawn tree: https://leetcode.com/problems/deepest-leaves-sum/"
                    },
                    {
                        "username": "wol_blue",
                        "content": "![image](https://assets.leetcode.com/users/panfengli/image_1551082094.png)\\n\\n![image](https://assets.leetcode.com/users/panfengli/image_1551082255.png)\\n\\n\\nAdded:\\n\\nI find it is actually a true case. It only compares the depth of two subtrees of the same node. The 2-3-4 one could only compared to 2-3."
                    },
                    {
                        "username": "anakinfoxe",
                        "content": "I got confused with this input. Doesn't it represent a tree like:\\n                      ![enter image description here][1]\\n\\nHow could it be a balanced binary tree?\\n         \\n\\n\\n  [1]: http://s14.postimg.org/ebtn4tmpd/Untitled_drawing.jpg"
                    }
                ]
            },
            {
                "id": 1569429,
                "content": [
                    {
                        "username": "Sailor20",
                        "content": "How is this use case : \"[1,2,2,3,null,null,3,4,null,null,4] should return false ?\\nAm i correct that following will be the tree structure for above ![image](https://assets.leetcode.com/users/shibha/image_1554673933.png)\\n\\n\\n"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/balanced-binary-tree.html"
                    },
                    {
                        "username": "user8763A",
                        "content": "testCase 84\n[1,null,2,null,3]\nis it correct tree?\nlooks like null node have right child\n ```\n       1\n     /    \\\n    -       2\n  /    \\\n-       3\n```"
                    },
                    {
                        "username": "ling6253112000",
                        "content": "I have the same question"
                    },
                    {
                        "username": "Cole_Donat",
                        "content": "EXPLANATION for testcase [1,2,2,3,null,null,3,4,null,null,4]:\\n\\nIn a balanced tree, *all* nodes must be balanced, not just the root. While the root node is balanced if you check with a depth-first search, every child node is unbalanced. \\n\\nTry checking if the tree is balanced at every step in the traversal, not just the first."
                    },
                    {
                        "username": "Aman_r15",
                        "content": "why this input is true---> [1,2,3,4,5,6,null,8]\\nit should be false. can anyone please help me to understand this."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "A height-balanced binary tree is a binary tree in which the depth of the two subtrees (left and right) of every node never differs by more than one.\\n\\nnode 8 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 4 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 5 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 2 -> left = 2, right = 1 then the differences is 1 (true)\\nnode 6 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 3 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 1 -> left = 3, right = 2 then the differences is 1 (true)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "Explaination after reading the answer\n\n\nAfter checking the answer, I started to know how to treat the binary tree. If my concepts are wrong, please let me know\n\nFirst, each node has a chance of having a left split or right split. For example in example 1, node 3 has a left split 9 and right split [15,20,7]. Then based on this we can talk about depth of the 2 splits. According to the question, no node can have a depth difference more than one for the 2 splits if we want a true return.\n\nTake example 2 as an example. For the [4,3,4] subtree, the depth difference between 2 splits is 0. Then the upper layer [3,2,3] has a left split depth of 2 and a right split depth of 1, so the difference is 1. Then for the [2,1,2] part, the left split has a depth of 3 but the right split has a depth of 1, so the difference is 2 and causing a false return.\n\nBare in mind that without showing a split means the depth is 0. Take example 1 as sample, the node 9 does not show any left or right split means both splits are none (depth 0). Taking this concept we can move on to the next part, which is the part confuse me most at first.\n\n![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)\n\nAt first I thought the answer should be false because the right side has a depth of 2 and the left side has a depth of 4. However, after knowing how depth is actually calculated, I know I was wrong.\n\nFor this tree the left side we start with [5,4,5] the 4 node here have a depth of 1 and left right diff is 0. Then we move up to the [4,3,4] above. Since the left 4 node has 2 5 nodes below, this node 3 has a depth of 2 with the right split having a depth of 1 (only a 4 node on the right). We say this 3 subtree has a depth of 2 and the diff between left and right split is 1. So on move to the above 2 node and we have a subtree of depth 3 on the left split and depth 2 on the right split. Therefore subtree has a depth of 3 and diff of depth between splits 3-2 = 1\n\nNow move to the right hand side. the 3 node on the left is [4,3,4] so it has a depth of 1 and diff = 0. The 2 node above has a depth of 2 and a diff of 1. \n\nBy combineing the result of the 2 largest subtrees, we then can know the left split has a depth of 4, the right side has a depth of 3. Therefore the diff is 1 which fulfill diff <= 1. The answer therefore is true.\n\n\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\n\nTake another example, at first I think the left and right subtree are perfectly symmetric so that should be true. However, I found that is not how depth calculation works.\n\nFor the node 3 on the left side, it has a left split 4 and a none right split. The depth in the view of node 3 therefore is 1 and having a split diff of 1-0 = 1. Remember this fact then we move to the node 2 above. This node 2 has a left split of depth 2 (node 3 + node 4 => depth : 1 + 1 = 2) but a right split of depth 0 (none means nothing > means the depth is 0), which means the depth in the view of node 2 is 2 and having a depth diff of 2 - 0 = 2. This alrealy enough to return a false. The same also happens on the right hand side. the node 1 finally has a depth of 3 and a depth diff of 0 but this is not important as the node 2 view point already violates the true condition.\n\n\nI am very disappointed that the example provided by leetcode cannot let users understand the concept of node tree. I hope this message can save beginners like me from hours of research after checking the answer provided by more experienced users.\n\n\n\n\n\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have understood already how it works but still thanks for explanation"
                    },
                    {
                        "username": "user7368jA",
                        "content": "I am getting Wrong answer in the testcase [1,null,2,null,3], but this is only when I submit the solution. But when I test run that testcase in the console of Leetcode it gets accepted. What is the Problem please fix it. Correct answer is false."
                    },
                    {
                        "username": "ghost204nit",
                        "content": "194 / 227 testcase looks incorrect.  I think input makes height balanced tree, and answer should be true. Am I missing anything? Please help. \\n\\nInput:\\n[1,2,3,4,5,null,6,7,null,null,null,null,8]\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "leitor79",
                        "content": "Hi! I assume you\\'ve already found the answer \\uD83D\\uDE02, but in case someone else is struggling with this, I\\'ll answer: it\\'s not balanced from the \"3\" node, since the left subtree is null and the right subtree has a height of 2. There is another problem with this exact same input where you could see the drawn tree: https://leetcode.com/problems/deepest-leaves-sum/"
                    },
                    {
                        "username": "wol_blue",
                        "content": "![image](https://assets.leetcode.com/users/panfengli/image_1551082094.png)\\n\\n![image](https://assets.leetcode.com/users/panfengli/image_1551082255.png)\\n\\n\\nAdded:\\n\\nI find it is actually a true case. It only compares the depth of two subtrees of the same node. The 2-3-4 one could only compared to 2-3."
                    },
                    {
                        "username": "anakinfoxe",
                        "content": "I got confused with this input. Doesn't it represent a tree like:\\n                      ![enter image description here][1]\\n\\nHow could it be a balanced binary tree?\\n         \\n\\n\\n  [1]: http://s14.postimg.org/ebtn4tmpd/Untitled_drawing.jpg"
                    }
                ]
            },
            {
                "id": 1568931,
                "content": [
                    {
                        "username": "Sailor20",
                        "content": "How is this use case : \"[1,2,2,3,null,null,3,4,null,null,4] should return false ?\\nAm i correct that following will be the tree structure for above ![image](https://assets.leetcode.com/users/shibha/image_1554673933.png)\\n\\n\\n"
                    },
                    {
                        "username": "zxak",
                        "content": "solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/balanced-binary-tree.html"
                    },
                    {
                        "username": "user8763A",
                        "content": "testCase 84\n[1,null,2,null,3]\nis it correct tree?\nlooks like null node have right child\n ```\n       1\n     /    \\\n    -       2\n  /    \\\n-       3\n```"
                    },
                    {
                        "username": "ling6253112000",
                        "content": "I have the same question"
                    },
                    {
                        "username": "Cole_Donat",
                        "content": "EXPLANATION for testcase [1,2,2,3,null,null,3,4,null,null,4]:\\n\\nIn a balanced tree, *all* nodes must be balanced, not just the root. While the root node is balanced if you check with a depth-first search, every child node is unbalanced. \\n\\nTry checking if the tree is balanced at every step in the traversal, not just the first."
                    },
                    {
                        "username": "Aman_r15",
                        "content": "why this input is true---> [1,2,3,4,5,6,null,8]\\nit should be false. can anyone please help me to understand this."
                    },
                    {
                        "username": "Mohamad-Ilham-Ramadhan",
                        "content": "A height-balanced binary tree is a binary tree in which the depth of the two subtrees (left and right) of every node never differs by more than one.\\n\\nnode 8 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 4 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 5 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 2 -> left = 2, right = 1 then the differences is 1 (true)\\nnode 6 -> left = 0, right = 0 then the differences is 0 (true)\\nnode 3 -> left = 1, right = 0 then the differences is 1 (true)\\nnode 1 -> left = 3, right = 2 then the differences is 1 (true)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "Explaination after reading the answer\n\n\nAfter checking the answer, I started to know how to treat the binary tree. If my concepts are wrong, please let me know\n\nFirst, each node has a chance of having a left split or right split. For example in example 1, node 3 has a left split 9 and right split [15,20,7]. Then based on this we can talk about depth of the 2 splits. According to the question, no node can have a depth difference more than one for the 2 splits if we want a true return.\n\nTake example 2 as an example. For the [4,3,4] subtree, the depth difference between 2 splits is 0. Then the upper layer [3,2,3] has a left split depth of 2 and a right split depth of 1, so the difference is 1. Then for the [2,1,2] part, the left split has a depth of 3 but the right split has a depth of 1, so the difference is 2 and causing a false return.\n\nBare in mind that without showing a split means the depth is 0. Take example 1 as sample, the node 9 does not show any left or right split means both splits are none (depth 0). Taking this concept we can move on to the next part, which is the part confuse me most at first.\n\n![image](https://assets.leetcode.com/users/shashankdutt/image_1559201456.png)\n\nAt first I thought the answer should be false because the right side has a depth of 2 and the left side has a depth of 4. However, after knowing how depth is actually calculated, I know I was wrong.\n\nFor this tree the left side we start with [5,4,5] the 4 node here have a depth of 1 and left right diff is 0. Then we move up to the [4,3,4] above. Since the left 4 node has 2 5 nodes below, this node 3 has a depth of 2 with the right split having a depth of 1 (only a 4 node on the right). We say this 3 subtree has a depth of 2 and the diff between left and right split is 1. So on move to the above 2 node and we have a subtree of depth 3 on the left split and depth 2 on the right split. Therefore subtree has a depth of 3 and diff of depth between splits 3-2 = 1\n\nNow move to the right hand side. the 3 node on the left is [4,3,4] so it has a depth of 1 and diff = 0. The 2 node above has a depth of 2 and a diff of 1. \n\nBy combineing the result of the 2 largest subtrees, we then can know the left split has a depth of 4, the right side has a depth of 3. Therefore the diff is 1 which fulfill diff <= 1. The answer therefore is true.\n\n\n![image](https://assets.leetcode.com/users/lekhaemerald/image_1577738437.png)\n\nTake another example, at first I think the left and right subtree are perfectly symmetric so that should be true. However, I found that is not how depth calculation works.\n\nFor the node 3 on the left side, it has a left split 4 and a none right split. The depth in the view of node 3 therefore is 1 and having a split diff of 1-0 = 1. Remember this fact then we move to the node 2 above. This node 2 has a left split of depth 2 (node 3 + node 4 => depth : 1 + 1 = 2) but a right split of depth 0 (none means nothing > means the depth is 0), which means the depth in the view of node 2 is 2 and having a depth diff of 2 - 0 = 2. This alrealy enough to return a false. The same also happens on the right hand side. the node 1 finally has a depth of 3 and a depth diff of 0 but this is not important as the node 2 view point already violates the true condition.\n\n\nI am very disappointed that the example provided by leetcode cannot let users understand the concept of node tree. I hope this message can save beginners like me from hours of research after checking the answer provided by more experienced users.\n\n\n\n\n\n"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "I have understood already how it works but still thanks for explanation"
                    },
                    {
                        "username": "user7368jA",
                        "content": "I am getting Wrong answer in the testcase [1,null,2,null,3], but this is only when I submit the solution. But when I test run that testcase in the console of Leetcode it gets accepted. What is the Problem please fix it. Correct answer is false."
                    },
                    {
                        "username": "ghost204nit",
                        "content": "194 / 227 testcase looks incorrect.  I think input makes height balanced tree, and answer should be true. Am I missing anything? Please help. \\n\\nInput:\\n[1,2,3,4,5,null,6,7,null,null,null,null,8]\\nOutput:\\ntrue\\nExpected:\\nfalse"
                    },
                    {
                        "username": "leitor79",
                        "content": "Hi! I assume you\\'ve already found the answer \\uD83D\\uDE02, but in case someone else is struggling with this, I\\'ll answer: it\\'s not balanced from the \"3\" node, since the left subtree is null and the right subtree has a height of 2. There is another problem with this exact same input where you could see the drawn tree: https://leetcode.com/problems/deepest-leaves-sum/"
                    },
                    {
                        "username": "wol_blue",
                        "content": "![image](https://assets.leetcode.com/users/panfengli/image_1551082094.png)\\n\\n![image](https://assets.leetcode.com/users/panfengli/image_1551082255.png)\\n\\n\\nAdded:\\n\\nI find it is actually a true case. It only compares the depth of two subtrees of the same node. The 2-3-4 one could only compared to 2-3."
                    },
                    {
                        "username": "anakinfoxe",
                        "content": "I got confused with this input. Doesn't it represent a tree like:\\n                      ![enter image description here][1]\\n\\nHow could it be a balanced binary tree?\\n         \\n\\n\\n  [1]: http://s14.postimg.org/ebtn4tmpd/Untitled_drawing.jpg"
                    }
                ]
            },
            {
                "id": 1568932,
                "content": [
                    {
                        "username": "qoinqoder",
                        "content": "Please provide help as understanding test cases is equally important for good coding skills."
                    },
                    {
                        "username": "Echotuan0809",
                        "content": "I thought the time complexity of this solution should be O(N^2), since we have traverse every node in the function of isBalanced and for each node we have to traverse every node in its subtree to calculate the height.\\n\\nBut I searched online that some said that the time complexity is O(NlogN). Is anybody could explain why? \\n\\n\\nHere is my solution:\\npublic static boolean isBalanced(TreeNode root){\\n\\t   if(root == null) return true;\\n\\t   \\n\\t   if(Math.abs(getHeight(root.left)-getHeight(root.right))>1)\\n\\t\\t   return false;\\n\\t   else\\n\\t\\t   return isBalanced(root.left)&&isBalanced(root.right);\\n   }\\n   \\n    public static int getHeight(TreeNode root){\\n\\t   if(root == null) return 0;\\n\\t   return Math.max(getHeight(root.left), getHeight(root.right))+1;\\n   }"
                    },
                    {
                        "username": "006arjunks",
                        "content": "Try to fix\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Bro it is simple case it happens because here each and every subtree needs to be balanced and in your case only root is balanced, once try by drawing the tree you will get it.\\nSolution: Try checking the balanced or not for the whole tree by recursion. "
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": " int depth(TreeNode* node){\\n        if(node==NULL)return 0;\\n        return max(depth(node->left),depth(node->right))+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        int L=depth(root->left);\\n        int R=depth(root->right);\\n        if(abs(L-R)==1)return true;\\n        return false;\\n    }\\n\\nwhat is wrong in this logic?"
                    },
                    {
                        "username": "eat_da_rude",
                        "content": "Why cant we do it with BFS?\\nBalanced Tree is defined in terms of height in the question, but we dont deal with heights in bfs.\\nI think there are 2 kinds of test cases here which will return false here.\\nFirst, where a node(lets say left node) has 0 children. And its complementary node(right node) have children for more than 1 depth.\\nSecond, when there are 2 or more consequent single child nodes(skewed tree).\\n\\nWhile we can code for case 1 easily, Solving case 2 is trivial.\\nAm i right? views?"
                    },
                    {
                        "username": "L-cloud",
                        "content": "[1,2,3,4,null,5,null,6,7,9] `return false`\\nI can\\'t understand why it `return false`\\nBut [1,2,3,4,5,6,null,7]  `reurn True`\\ncould you explain more about  Balanced Binary Tree?"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/e7df3dc6-6f22-4da2-9249-2bbf0f261a9c_1619377633.4001045.png)\\n\\n![image](https://assets.leetcode.com/users/images/bf7ee12b-ff8c-4fc2-b28d-5aec1d0fa267_1619376253.2744794.png)\\n"
                    },
                    {
                        "username": "harryhoods",
                        "content": "Input: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n(is this a balanced BST?)\\nExpected: True?? Shouldn\\'t it be false?\\n![image](https://assets.leetcode.com/users/harryhoods/image_1561403414.png)\\n"
                    },
                    {
                        "username": "nomadwashere",
                        "content": "Specifically this one [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\nThe expectation is true but how is that possible? The minimum depth is 2 and the max is 4."
                    },
                    {
                        "username": "sailfish",
                        "content": "![image](https://assets.leetcode.com/users/sailfish/image_1553945662.png)\\nWhy [1,2,2,3,3,null,null,4,4] is expected to be false, but \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] is expected to be true"
                    }
                ]
            },
            {
                "id": 1568933,
                "content": [
                    {
                        "username": "qoinqoder",
                        "content": "Please provide help as understanding test cases is equally important for good coding skills."
                    },
                    {
                        "username": "Echotuan0809",
                        "content": "I thought the time complexity of this solution should be O(N^2), since we have traverse every node in the function of isBalanced and for each node we have to traverse every node in its subtree to calculate the height.\\n\\nBut I searched online that some said that the time complexity is O(NlogN). Is anybody could explain why? \\n\\n\\nHere is my solution:\\npublic static boolean isBalanced(TreeNode root){\\n\\t   if(root == null) return true;\\n\\t   \\n\\t   if(Math.abs(getHeight(root.left)-getHeight(root.right))>1)\\n\\t\\t   return false;\\n\\t   else\\n\\t\\t   return isBalanced(root.left)&&isBalanced(root.right);\\n   }\\n   \\n    public static int getHeight(TreeNode root){\\n\\t   if(root == null) return 0;\\n\\t   return Math.max(getHeight(root.left), getHeight(root.right))+1;\\n   }"
                    },
                    {
                        "username": "006arjunks",
                        "content": "Try to fix\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Bro it is simple case it happens because here each and every subtree needs to be balanced and in your case only root is balanced, once try by drawing the tree you will get it.\\nSolution: Try checking the balanced or not for the whole tree by recursion. "
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": " int depth(TreeNode* node){\\n        if(node==NULL)return 0;\\n        return max(depth(node->left),depth(node->right))+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        int L=depth(root->left);\\n        int R=depth(root->right);\\n        if(abs(L-R)==1)return true;\\n        return false;\\n    }\\n\\nwhat is wrong in this logic?"
                    },
                    {
                        "username": "eat_da_rude",
                        "content": "Why cant we do it with BFS?\\nBalanced Tree is defined in terms of height in the question, but we dont deal with heights in bfs.\\nI think there are 2 kinds of test cases here which will return false here.\\nFirst, where a node(lets say left node) has 0 children. And its complementary node(right node) have children for more than 1 depth.\\nSecond, when there are 2 or more consequent single child nodes(skewed tree).\\n\\nWhile we can code for case 1 easily, Solving case 2 is trivial.\\nAm i right? views?"
                    },
                    {
                        "username": "L-cloud",
                        "content": "[1,2,3,4,null,5,null,6,7,9] `return false`\\nI can\\'t understand why it `return false`\\nBut [1,2,3,4,5,6,null,7]  `reurn True`\\ncould you explain more about  Balanced Binary Tree?"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/e7df3dc6-6f22-4da2-9249-2bbf0f261a9c_1619377633.4001045.png)\\n\\n![image](https://assets.leetcode.com/users/images/bf7ee12b-ff8c-4fc2-b28d-5aec1d0fa267_1619376253.2744794.png)\\n"
                    },
                    {
                        "username": "harryhoods",
                        "content": "Input: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n(is this a balanced BST?)\\nExpected: True?? Shouldn\\'t it be false?\\n![image](https://assets.leetcode.com/users/harryhoods/image_1561403414.png)\\n"
                    },
                    {
                        "username": "nomadwashere",
                        "content": "Specifically this one [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\nThe expectation is true but how is that possible? The minimum depth is 2 and the max is 4."
                    },
                    {
                        "username": "sailfish",
                        "content": "![image](https://assets.leetcode.com/users/sailfish/image_1553945662.png)\\nWhy [1,2,2,3,3,null,null,4,4] is expected to be false, but \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] is expected to be true"
                    }
                ]
            },
            {
                "id": 2010353,
                "content": [
                    {
                        "username": "qoinqoder",
                        "content": "Please provide help as understanding test cases is equally important for good coding skills."
                    },
                    {
                        "username": "Echotuan0809",
                        "content": "I thought the time complexity of this solution should be O(N^2), since we have traverse every node in the function of isBalanced and for each node we have to traverse every node in its subtree to calculate the height.\\n\\nBut I searched online that some said that the time complexity is O(NlogN). Is anybody could explain why? \\n\\n\\nHere is my solution:\\npublic static boolean isBalanced(TreeNode root){\\n\\t   if(root == null) return true;\\n\\t   \\n\\t   if(Math.abs(getHeight(root.left)-getHeight(root.right))>1)\\n\\t\\t   return false;\\n\\t   else\\n\\t\\t   return isBalanced(root.left)&&isBalanced(root.right);\\n   }\\n   \\n    public static int getHeight(TreeNode root){\\n\\t   if(root == null) return 0;\\n\\t   return Math.max(getHeight(root.left), getHeight(root.right))+1;\\n   }"
                    },
                    {
                        "username": "006arjunks",
                        "content": "Try to fix\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Bro it is simple case it happens because here each and every subtree needs to be balanced and in your case only root is balanced, once try by drawing the tree you will get it.\\nSolution: Try checking the balanced or not for the whole tree by recursion. "
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": " int depth(TreeNode* node){\\n        if(node==NULL)return 0;\\n        return max(depth(node->left),depth(node->right))+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        int L=depth(root->left);\\n        int R=depth(root->right);\\n        if(abs(L-R)==1)return true;\\n        return false;\\n    }\\n\\nwhat is wrong in this logic?"
                    },
                    {
                        "username": "eat_da_rude",
                        "content": "Why cant we do it with BFS?\\nBalanced Tree is defined in terms of height in the question, but we dont deal with heights in bfs.\\nI think there are 2 kinds of test cases here which will return false here.\\nFirst, where a node(lets say left node) has 0 children. And its complementary node(right node) have children for more than 1 depth.\\nSecond, when there are 2 or more consequent single child nodes(skewed tree).\\n\\nWhile we can code for case 1 easily, Solving case 2 is trivial.\\nAm i right? views?"
                    },
                    {
                        "username": "L-cloud",
                        "content": "[1,2,3,4,null,5,null,6,7,9] `return false`\\nI can\\'t understand why it `return false`\\nBut [1,2,3,4,5,6,null,7]  `reurn True`\\ncould you explain more about  Balanced Binary Tree?"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/e7df3dc6-6f22-4da2-9249-2bbf0f261a9c_1619377633.4001045.png)\\n\\n![image](https://assets.leetcode.com/users/images/bf7ee12b-ff8c-4fc2-b28d-5aec1d0fa267_1619376253.2744794.png)\\n"
                    },
                    {
                        "username": "harryhoods",
                        "content": "Input: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n(is this a balanced BST?)\\nExpected: True?? Shouldn\\'t it be false?\\n![image](https://assets.leetcode.com/users/harryhoods/image_1561403414.png)\\n"
                    },
                    {
                        "username": "nomadwashere",
                        "content": "Specifically this one [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\nThe expectation is true but how is that possible? The minimum depth is 2 and the max is 4."
                    },
                    {
                        "username": "sailfish",
                        "content": "![image](https://assets.leetcode.com/users/sailfish/image_1553945662.png)\\nWhy [1,2,2,3,3,null,null,4,4] is expected to be false, but \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] is expected to be true"
                    }
                ]
            },
            {
                "id": 1709638,
                "content": [
                    {
                        "username": "qoinqoder",
                        "content": "Please provide help as understanding test cases is equally important for good coding skills."
                    },
                    {
                        "username": "Echotuan0809",
                        "content": "I thought the time complexity of this solution should be O(N^2), since we have traverse every node in the function of isBalanced and for each node we have to traverse every node in its subtree to calculate the height.\\n\\nBut I searched online that some said that the time complexity is O(NlogN). Is anybody could explain why? \\n\\n\\nHere is my solution:\\npublic static boolean isBalanced(TreeNode root){\\n\\t   if(root == null) return true;\\n\\t   \\n\\t   if(Math.abs(getHeight(root.left)-getHeight(root.right))>1)\\n\\t\\t   return false;\\n\\t   else\\n\\t\\t   return isBalanced(root.left)&&isBalanced(root.right);\\n   }\\n   \\n    public static int getHeight(TreeNode root){\\n\\t   if(root == null) return 0;\\n\\t   return Math.max(getHeight(root.left), getHeight(root.right))+1;\\n   }"
                    },
                    {
                        "username": "006arjunks",
                        "content": "Try to fix\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Bro it is simple case it happens because here each and every subtree needs to be balanced and in your case only root is balanced, once try by drawing the tree you will get it.\\nSolution: Try checking the balanced or not for the whole tree by recursion. "
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": " int depth(TreeNode* node){\\n        if(node==NULL)return 0;\\n        return max(depth(node->left),depth(node->right))+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        int L=depth(root->left);\\n        int R=depth(root->right);\\n        if(abs(L-R)==1)return true;\\n        return false;\\n    }\\n\\nwhat is wrong in this logic?"
                    },
                    {
                        "username": "eat_da_rude",
                        "content": "Why cant we do it with BFS?\\nBalanced Tree is defined in terms of height in the question, but we dont deal with heights in bfs.\\nI think there are 2 kinds of test cases here which will return false here.\\nFirst, where a node(lets say left node) has 0 children. And its complementary node(right node) have children for more than 1 depth.\\nSecond, when there are 2 or more consequent single child nodes(skewed tree).\\n\\nWhile we can code for case 1 easily, Solving case 2 is trivial.\\nAm i right? views?"
                    },
                    {
                        "username": "L-cloud",
                        "content": "[1,2,3,4,null,5,null,6,7,9] `return false`\\nI can\\'t understand why it `return false`\\nBut [1,2,3,4,5,6,null,7]  `reurn True`\\ncould you explain more about  Balanced Binary Tree?"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/e7df3dc6-6f22-4da2-9249-2bbf0f261a9c_1619377633.4001045.png)\\n\\n![image](https://assets.leetcode.com/users/images/bf7ee12b-ff8c-4fc2-b28d-5aec1d0fa267_1619376253.2744794.png)\\n"
                    },
                    {
                        "username": "harryhoods",
                        "content": "Input: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n(is this a balanced BST?)\\nExpected: True?? Shouldn\\'t it be false?\\n![image](https://assets.leetcode.com/users/harryhoods/image_1561403414.png)\\n"
                    },
                    {
                        "username": "nomadwashere",
                        "content": "Specifically this one [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\nThe expectation is true but how is that possible? The minimum depth is 2 and the max is 4."
                    },
                    {
                        "username": "sailfish",
                        "content": "![image](https://assets.leetcode.com/users/sailfish/image_1553945662.png)\\nWhy [1,2,2,3,3,null,null,4,4] is expected to be false, but \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] is expected to be true"
                    }
                ]
            },
            {
                "id": 1576680,
                "content": [
                    {
                        "username": "qoinqoder",
                        "content": "Please provide help as understanding test cases is equally important for good coding skills."
                    },
                    {
                        "username": "Echotuan0809",
                        "content": "I thought the time complexity of this solution should be O(N^2), since we have traverse every node in the function of isBalanced and for each node we have to traverse every node in its subtree to calculate the height.\\n\\nBut I searched online that some said that the time complexity is O(NlogN). Is anybody could explain why? \\n\\n\\nHere is my solution:\\npublic static boolean isBalanced(TreeNode root){\\n\\t   if(root == null) return true;\\n\\t   \\n\\t   if(Math.abs(getHeight(root.left)-getHeight(root.right))>1)\\n\\t\\t   return false;\\n\\t   else\\n\\t\\t   return isBalanced(root.left)&&isBalanced(root.right);\\n   }\\n   \\n    public static int getHeight(TreeNode root){\\n\\t   if(root == null) return 0;\\n\\t   return Math.max(getHeight(root.left), getHeight(root.right))+1;\\n   }"
                    },
                    {
                        "username": "006arjunks",
                        "content": "Try to fix\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Bro it is simple case it happens because here each and every subtree needs to be balanced and in your case only root is balanced, once try by drawing the tree you will get it.\\nSolution: Try checking the balanced or not for the whole tree by recursion. "
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": " int depth(TreeNode* node){\\n        if(node==NULL)return 0;\\n        return max(depth(node->left),depth(node->right))+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        int L=depth(root->left);\\n        int R=depth(root->right);\\n        if(abs(L-R)==1)return true;\\n        return false;\\n    }\\n\\nwhat is wrong in this logic?"
                    },
                    {
                        "username": "eat_da_rude",
                        "content": "Why cant we do it with BFS?\\nBalanced Tree is defined in terms of height in the question, but we dont deal with heights in bfs.\\nI think there are 2 kinds of test cases here which will return false here.\\nFirst, where a node(lets say left node) has 0 children. And its complementary node(right node) have children for more than 1 depth.\\nSecond, when there are 2 or more consequent single child nodes(skewed tree).\\n\\nWhile we can code for case 1 easily, Solving case 2 is trivial.\\nAm i right? views?"
                    },
                    {
                        "username": "L-cloud",
                        "content": "[1,2,3,4,null,5,null,6,7,9] `return false`\\nI can\\'t understand why it `return false`\\nBut [1,2,3,4,5,6,null,7]  `reurn True`\\ncould you explain more about  Balanced Binary Tree?"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/e7df3dc6-6f22-4da2-9249-2bbf0f261a9c_1619377633.4001045.png)\\n\\n![image](https://assets.leetcode.com/users/images/bf7ee12b-ff8c-4fc2-b28d-5aec1d0fa267_1619376253.2744794.png)\\n"
                    },
                    {
                        "username": "harryhoods",
                        "content": "Input: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n(is this a balanced BST?)\\nExpected: True?? Shouldn\\'t it be false?\\n![image](https://assets.leetcode.com/users/harryhoods/image_1561403414.png)\\n"
                    },
                    {
                        "username": "nomadwashere",
                        "content": "Specifically this one [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\nThe expectation is true but how is that possible? The minimum depth is 2 and the max is 4."
                    },
                    {
                        "username": "sailfish",
                        "content": "![image](https://assets.leetcode.com/users/sailfish/image_1553945662.png)\\nWhy [1,2,2,3,3,null,null,4,4] is expected to be false, but \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] is expected to be true"
                    }
                ]
            },
            {
                "id": 1575999,
                "content": [
                    {
                        "username": "qoinqoder",
                        "content": "Please provide help as understanding test cases is equally important for good coding skills."
                    },
                    {
                        "username": "Echotuan0809",
                        "content": "I thought the time complexity of this solution should be O(N^2), since we have traverse every node in the function of isBalanced and for each node we have to traverse every node in its subtree to calculate the height.\\n\\nBut I searched online that some said that the time complexity is O(NlogN). Is anybody could explain why? \\n\\n\\nHere is my solution:\\npublic static boolean isBalanced(TreeNode root){\\n\\t   if(root == null) return true;\\n\\t   \\n\\t   if(Math.abs(getHeight(root.left)-getHeight(root.right))>1)\\n\\t\\t   return false;\\n\\t   else\\n\\t\\t   return isBalanced(root.left)&&isBalanced(root.right);\\n   }\\n   \\n    public static int getHeight(TreeNode root){\\n\\t   if(root == null) return 0;\\n\\t   return Math.max(getHeight(root.left), getHeight(root.right))+1;\\n   }"
                    },
                    {
                        "username": "006arjunks",
                        "content": "Try to fix\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Bro it is simple case it happens because here each and every subtree needs to be balanced and in your case only root is balanced, once try by drawing the tree you will get it.\\nSolution: Try checking the balanced or not for the whole tree by recursion. "
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": " int depth(TreeNode* node){\\n        if(node==NULL)return 0;\\n        return max(depth(node->left),depth(node->right))+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        int L=depth(root->left);\\n        int R=depth(root->right);\\n        if(abs(L-R)==1)return true;\\n        return false;\\n    }\\n\\nwhat is wrong in this logic?"
                    },
                    {
                        "username": "eat_da_rude",
                        "content": "Why cant we do it with BFS?\\nBalanced Tree is defined in terms of height in the question, but we dont deal with heights in bfs.\\nI think there are 2 kinds of test cases here which will return false here.\\nFirst, where a node(lets say left node) has 0 children. And its complementary node(right node) have children for more than 1 depth.\\nSecond, when there are 2 or more consequent single child nodes(skewed tree).\\n\\nWhile we can code for case 1 easily, Solving case 2 is trivial.\\nAm i right? views?"
                    },
                    {
                        "username": "L-cloud",
                        "content": "[1,2,3,4,null,5,null,6,7,9] `return false`\\nI can\\'t understand why it `return false`\\nBut [1,2,3,4,5,6,null,7]  `reurn True`\\ncould you explain more about  Balanced Binary Tree?"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/e7df3dc6-6f22-4da2-9249-2bbf0f261a9c_1619377633.4001045.png)\\n\\n![image](https://assets.leetcode.com/users/images/bf7ee12b-ff8c-4fc2-b28d-5aec1d0fa267_1619376253.2744794.png)\\n"
                    },
                    {
                        "username": "harryhoods",
                        "content": "Input: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n(is this a balanced BST?)\\nExpected: True?? Shouldn\\'t it be false?\\n![image](https://assets.leetcode.com/users/harryhoods/image_1561403414.png)\\n"
                    },
                    {
                        "username": "nomadwashere",
                        "content": "Specifically this one [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\nThe expectation is true but how is that possible? The minimum depth is 2 and the max is 4."
                    },
                    {
                        "username": "sailfish",
                        "content": "![image](https://assets.leetcode.com/users/sailfish/image_1553945662.png)\\nWhy [1,2,2,3,3,null,null,4,4] is expected to be false, but \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] is expected to be true"
                    }
                ]
            },
            {
                "id": 1575184,
                "content": [
                    {
                        "username": "qoinqoder",
                        "content": "Please provide help as understanding test cases is equally important for good coding skills."
                    },
                    {
                        "username": "Echotuan0809",
                        "content": "I thought the time complexity of this solution should be O(N^2), since we have traverse every node in the function of isBalanced and for each node we have to traverse every node in its subtree to calculate the height.\\n\\nBut I searched online that some said that the time complexity is O(NlogN). Is anybody could explain why? \\n\\n\\nHere is my solution:\\npublic static boolean isBalanced(TreeNode root){\\n\\t   if(root == null) return true;\\n\\t   \\n\\t   if(Math.abs(getHeight(root.left)-getHeight(root.right))>1)\\n\\t\\t   return false;\\n\\t   else\\n\\t\\t   return isBalanced(root.left)&&isBalanced(root.right);\\n   }\\n   \\n    public static int getHeight(TreeNode root){\\n\\t   if(root == null) return 0;\\n\\t   return Math.max(getHeight(root.left), getHeight(root.right))+1;\\n   }"
                    },
                    {
                        "username": "006arjunks",
                        "content": "Try to fix\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Bro it is simple case it happens because here each and every subtree needs to be balanced and in your case only root is balanced, once try by drawing the tree you will get it.\\nSolution: Try checking the balanced or not for the whole tree by recursion. "
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": " int depth(TreeNode* node){\\n        if(node==NULL)return 0;\\n        return max(depth(node->left),depth(node->right))+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        int L=depth(root->left);\\n        int R=depth(root->right);\\n        if(abs(L-R)==1)return true;\\n        return false;\\n    }\\n\\nwhat is wrong in this logic?"
                    },
                    {
                        "username": "eat_da_rude",
                        "content": "Why cant we do it with BFS?\\nBalanced Tree is defined in terms of height in the question, but we dont deal with heights in bfs.\\nI think there are 2 kinds of test cases here which will return false here.\\nFirst, where a node(lets say left node) has 0 children. And its complementary node(right node) have children for more than 1 depth.\\nSecond, when there are 2 or more consequent single child nodes(skewed tree).\\n\\nWhile we can code for case 1 easily, Solving case 2 is trivial.\\nAm i right? views?"
                    },
                    {
                        "username": "L-cloud",
                        "content": "[1,2,3,4,null,5,null,6,7,9] `return false`\\nI can\\'t understand why it `return false`\\nBut [1,2,3,4,5,6,null,7]  `reurn True`\\ncould you explain more about  Balanced Binary Tree?"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/e7df3dc6-6f22-4da2-9249-2bbf0f261a9c_1619377633.4001045.png)\\n\\n![image](https://assets.leetcode.com/users/images/bf7ee12b-ff8c-4fc2-b28d-5aec1d0fa267_1619376253.2744794.png)\\n"
                    },
                    {
                        "username": "harryhoods",
                        "content": "Input: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n(is this a balanced BST?)\\nExpected: True?? Shouldn\\'t it be false?\\n![image](https://assets.leetcode.com/users/harryhoods/image_1561403414.png)\\n"
                    },
                    {
                        "username": "nomadwashere",
                        "content": "Specifically this one [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\nThe expectation is true but how is that possible? The minimum depth is 2 and the max is 4."
                    },
                    {
                        "username": "sailfish",
                        "content": "![image](https://assets.leetcode.com/users/sailfish/image_1553945662.png)\\nWhy [1,2,2,3,3,null,null,4,4] is expected to be false, but \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] is expected to be true"
                    }
                ]
            },
            {
                "id": 1572792,
                "content": [
                    {
                        "username": "qoinqoder",
                        "content": "Please provide help as understanding test cases is equally important for good coding skills."
                    },
                    {
                        "username": "Echotuan0809",
                        "content": "I thought the time complexity of this solution should be O(N^2), since we have traverse every node in the function of isBalanced and for each node we have to traverse every node in its subtree to calculate the height.\\n\\nBut I searched online that some said that the time complexity is O(NlogN). Is anybody could explain why? \\n\\n\\nHere is my solution:\\npublic static boolean isBalanced(TreeNode root){\\n\\t   if(root == null) return true;\\n\\t   \\n\\t   if(Math.abs(getHeight(root.left)-getHeight(root.right))>1)\\n\\t\\t   return false;\\n\\t   else\\n\\t\\t   return isBalanced(root.left)&&isBalanced(root.right);\\n   }\\n   \\n    public static int getHeight(TreeNode root){\\n\\t   if(root == null) return 0;\\n\\t   return Math.max(getHeight(root.left), getHeight(root.right))+1;\\n   }"
                    },
                    {
                        "username": "006arjunks",
                        "content": "Try to fix\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Bro it is simple case it happens because here each and every subtree needs to be balanced and in your case only root is balanced, once try by drawing the tree you will get it.\\nSolution: Try checking the balanced or not for the whole tree by recursion. "
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": " int depth(TreeNode* node){\\n        if(node==NULL)return 0;\\n        return max(depth(node->left),depth(node->right))+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        int L=depth(root->left);\\n        int R=depth(root->right);\\n        if(abs(L-R)==1)return true;\\n        return false;\\n    }\\n\\nwhat is wrong in this logic?"
                    },
                    {
                        "username": "eat_da_rude",
                        "content": "Why cant we do it with BFS?\\nBalanced Tree is defined in terms of height in the question, but we dont deal with heights in bfs.\\nI think there are 2 kinds of test cases here which will return false here.\\nFirst, where a node(lets say left node) has 0 children. And its complementary node(right node) have children for more than 1 depth.\\nSecond, when there are 2 or more consequent single child nodes(skewed tree).\\n\\nWhile we can code for case 1 easily, Solving case 2 is trivial.\\nAm i right? views?"
                    },
                    {
                        "username": "L-cloud",
                        "content": "[1,2,3,4,null,5,null,6,7,9] `return false`\\nI can\\'t understand why it `return false`\\nBut [1,2,3,4,5,6,null,7]  `reurn True`\\ncould you explain more about  Balanced Binary Tree?"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/e7df3dc6-6f22-4da2-9249-2bbf0f261a9c_1619377633.4001045.png)\\n\\n![image](https://assets.leetcode.com/users/images/bf7ee12b-ff8c-4fc2-b28d-5aec1d0fa267_1619376253.2744794.png)\\n"
                    },
                    {
                        "username": "harryhoods",
                        "content": "Input: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n(is this a balanced BST?)\\nExpected: True?? Shouldn\\'t it be false?\\n![image](https://assets.leetcode.com/users/harryhoods/image_1561403414.png)\\n"
                    },
                    {
                        "username": "nomadwashere",
                        "content": "Specifically this one [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\nThe expectation is true but how is that possible? The minimum depth is 2 and the max is 4."
                    },
                    {
                        "username": "sailfish",
                        "content": "![image](https://assets.leetcode.com/users/sailfish/image_1553945662.png)\\nWhy [1,2,2,3,3,null,null,4,4] is expected to be false, but \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] is expected to be true"
                    }
                ]
            },
            {
                "id": 1572682,
                "content": [
                    {
                        "username": "qoinqoder",
                        "content": "Please provide help as understanding test cases is equally important for good coding skills."
                    },
                    {
                        "username": "Echotuan0809",
                        "content": "I thought the time complexity of this solution should be O(N^2), since we have traverse every node in the function of isBalanced and for each node we have to traverse every node in its subtree to calculate the height.\\n\\nBut I searched online that some said that the time complexity is O(NlogN). Is anybody could explain why? \\n\\n\\nHere is my solution:\\npublic static boolean isBalanced(TreeNode root){\\n\\t   if(root == null) return true;\\n\\t   \\n\\t   if(Math.abs(getHeight(root.left)-getHeight(root.right))>1)\\n\\t\\t   return false;\\n\\t   else\\n\\t\\t   return isBalanced(root.left)&&isBalanced(root.right);\\n   }\\n   \\n    public static int getHeight(TreeNode root){\\n\\t   if(root == null) return 0;\\n\\t   return Math.max(getHeight(root.left), getHeight(root.right))+1;\\n   }"
                    },
                    {
                        "username": "006arjunks",
                        "content": "Try to fix\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Bro it is simple case it happens because here each and every subtree needs to be balanced and in your case only root is balanced, once try by drawing the tree you will get it.\\nSolution: Try checking the balanced or not for the whole tree by recursion. "
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": " int depth(TreeNode* node){\\n        if(node==NULL)return 0;\\n        return max(depth(node->left),depth(node->right))+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        int L=depth(root->left);\\n        int R=depth(root->right);\\n        if(abs(L-R)==1)return true;\\n        return false;\\n    }\\n\\nwhat is wrong in this logic?"
                    },
                    {
                        "username": "eat_da_rude",
                        "content": "Why cant we do it with BFS?\\nBalanced Tree is defined in terms of height in the question, but we dont deal with heights in bfs.\\nI think there are 2 kinds of test cases here which will return false here.\\nFirst, where a node(lets say left node) has 0 children. And its complementary node(right node) have children for more than 1 depth.\\nSecond, when there are 2 or more consequent single child nodes(skewed tree).\\n\\nWhile we can code for case 1 easily, Solving case 2 is trivial.\\nAm i right? views?"
                    },
                    {
                        "username": "L-cloud",
                        "content": "[1,2,3,4,null,5,null,6,7,9] `return false`\\nI can\\'t understand why it `return false`\\nBut [1,2,3,4,5,6,null,7]  `reurn True`\\ncould you explain more about  Balanced Binary Tree?"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/e7df3dc6-6f22-4da2-9249-2bbf0f261a9c_1619377633.4001045.png)\\n\\n![image](https://assets.leetcode.com/users/images/bf7ee12b-ff8c-4fc2-b28d-5aec1d0fa267_1619376253.2744794.png)\\n"
                    },
                    {
                        "username": "harryhoods",
                        "content": "Input: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n(is this a balanced BST?)\\nExpected: True?? Shouldn\\'t it be false?\\n![image](https://assets.leetcode.com/users/harryhoods/image_1561403414.png)\\n"
                    },
                    {
                        "username": "nomadwashere",
                        "content": "Specifically this one [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\nThe expectation is true but how is that possible? The minimum depth is 2 and the max is 4."
                    },
                    {
                        "username": "sailfish",
                        "content": "![image](https://assets.leetcode.com/users/sailfish/image_1553945662.png)\\nWhy [1,2,2,3,3,null,null,4,4] is expected to be false, but \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] is expected to be true"
                    }
                ]
            },
            {
                "id": 1572567,
                "content": [
                    {
                        "username": "qoinqoder",
                        "content": "Please provide help as understanding test cases is equally important for good coding skills."
                    },
                    {
                        "username": "Echotuan0809",
                        "content": "I thought the time complexity of this solution should be O(N^2), since we have traverse every node in the function of isBalanced and for each node we have to traverse every node in its subtree to calculate the height.\\n\\nBut I searched online that some said that the time complexity is O(NlogN). Is anybody could explain why? \\n\\n\\nHere is my solution:\\npublic static boolean isBalanced(TreeNode root){\\n\\t   if(root == null) return true;\\n\\t   \\n\\t   if(Math.abs(getHeight(root.left)-getHeight(root.right))>1)\\n\\t\\t   return false;\\n\\t   else\\n\\t\\t   return isBalanced(root.left)&&isBalanced(root.right);\\n   }\\n   \\n    public static int getHeight(TreeNode root){\\n\\t   if(root == null) return 0;\\n\\t   return Math.max(getHeight(root.left), getHeight(root.right))+1;\\n   }"
                    },
                    {
                        "username": "006arjunks",
                        "content": "Try to fix\\n[1,2,2,3,null,null,3,4,null,null,4]"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Bro it is simple case it happens because here each and every subtree needs to be balanced and in your case only root is balanced, once try by drawing the tree you will get it.\\nSolution: Try checking the balanced or not for the whole tree by recursion. "
                    },
                    {
                        "username": "ankitbelieve07",
                        "content": " int depth(TreeNode* node){\\n        if(node==NULL)return 0;\\n        return max(depth(node->left),depth(node->right))+1;\\n    }\\n    bool isBalanced(TreeNode* root) {\\n        int L=depth(root->left);\\n        int R=depth(root->right);\\n        if(abs(L-R)==1)return true;\\n        return false;\\n    }\\n\\nwhat is wrong in this logic?"
                    },
                    {
                        "username": "eat_da_rude",
                        "content": "Why cant we do it with BFS?\\nBalanced Tree is defined in terms of height in the question, but we dont deal with heights in bfs.\\nI think there are 2 kinds of test cases here which will return false here.\\nFirst, where a node(lets say left node) has 0 children. And its complementary node(right node) have children for more than 1 depth.\\nSecond, when there are 2 or more consequent single child nodes(skewed tree).\\n\\nWhile we can code for case 1 easily, Solving case 2 is trivial.\\nAm i right? views?"
                    },
                    {
                        "username": "L-cloud",
                        "content": "[1,2,3,4,null,5,null,6,7,9] `return false`\\nI can\\'t understand why it `return false`\\nBut [1,2,3,4,5,6,null,7]  `reurn True`\\ncould you explain more about  Balanced Binary Tree?"
                    },
                    {
                        "username": "dustlihy",
                        "content": "![image](https://assets.leetcode.com/users/images/e7df3dc6-6f22-4da2-9249-2bbf0f261a9c_1619377633.4001045.png)\\n\\n![image](https://assets.leetcode.com/users/images/bf7ee12b-ff8c-4fc2-b28d-5aec1d0fa267_1619376253.2744794.png)\\n"
                    },
                    {
                        "username": "harryhoods",
                        "content": "Input: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n(is this a balanced BST?)\\nExpected: True?? Shouldn\\'t it be false?\\n![image](https://assets.leetcode.com/users/harryhoods/image_1561403414.png)\\n"
                    },
                    {
                        "username": "nomadwashere",
                        "content": "Specifically this one [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\nThe expectation is true but how is that possible? The minimum depth is 2 and the max is 4."
                    },
                    {
                        "username": "sailfish",
                        "content": "![image](https://assets.leetcode.com/users/sailfish/image_1553945662.png)\\nWhy [1,2,2,3,3,null,null,4,4] is expected to be false, but \\n[1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5] is expected to be true"
                    }
                ]
            },
            {
                "id": 1572149,
                "content": [
                    {
                        "username": "bob56",
                        "content": "I keep on failing on this test case: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n\\nmy output: false\\nexpected: true\\n\\nI don\\'t understand how this is expected to return true???\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147332.png)\\n\\nTree node visualization:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147429.png)\\n\\n"
                    },
                    {
                        "username": "sttony",
                        "content": "looks like python just can recursive 997, so 1,2,#,3,#,4,#,.... failed."
                    },
                    {
                        "username": "user6227l",
                        "content": "https://github.com/manish33/LeetCodeSolved/blob/master/src/main/java/BalancedBinaryTree/Solution.java"
                    },
                    {
                        "username": "Mohan165",
                        "content": "Should be [1,2,2,3,null,null,3,4,null,null,null,null,4]\\nExpected result false. Correct me if I am wrong."
                    },
                    {
                        "username": "Musfik41",
                        "content": "leetcode should provide better explanation atleast for the beginners \\uD83D\\uDE05, even i am also falls under beginner category\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "user9322HQ",
                        "content": "How is this false? I don't understand\n\n [1,2,2,3,null,null,3,4,null,null,4]\n\n\n                                                             1\n                                                      /              \\\n                              \t\t\t       2\t                  2\n                                              /     \\              /          \\\n                                         3         null        null      3\n                                     /.     \\                                /       \\\n                                  4         null                        null.    4\n"
                    },
                    {
                        "username": "aftabalam1056",
                        "content": "It needs to be balanced at each node. Both the Nodes with value 2 are not balanced."
                    },
                    {
                        "username": "Drink7",
                        "content": "Could use the same method of LC. 124 Binary Tree Maximum Path Sum"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Not a easy question! Atleast medium."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "think about the difference between the maximum left height and the maximum right height `for every single node.`\n`abs(left_height-right_height) >=2`\nupvote to reach everyone"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "Actually, it's not easy. it should be in medium category."
                    }
                ]
            },
            {
                "id": 1568934,
                "content": [
                    {
                        "username": "bob56",
                        "content": "I keep on failing on this test case: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n\\nmy output: false\\nexpected: true\\n\\nI don\\'t understand how this is expected to return true???\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147332.png)\\n\\nTree node visualization:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147429.png)\\n\\n"
                    },
                    {
                        "username": "sttony",
                        "content": "looks like python just can recursive 997, so 1,2,#,3,#,4,#,.... failed."
                    },
                    {
                        "username": "user6227l",
                        "content": "https://github.com/manish33/LeetCodeSolved/blob/master/src/main/java/BalancedBinaryTree/Solution.java"
                    },
                    {
                        "username": "Mohan165",
                        "content": "Should be [1,2,2,3,null,null,3,4,null,null,null,null,4]\\nExpected result false. Correct me if I am wrong."
                    },
                    {
                        "username": "Musfik41",
                        "content": "leetcode should provide better explanation atleast for the beginners \\uD83D\\uDE05, even i am also falls under beginner category\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "user9322HQ",
                        "content": "How is this false? I don't understand\n\n [1,2,2,3,null,null,3,4,null,null,4]\n\n\n                                                             1\n                                                      /              \\\n                              \t\t\t       2\t                  2\n                                              /     \\              /          \\\n                                         3         null        null      3\n                                     /.     \\                                /       \\\n                                  4         null                        null.    4\n"
                    },
                    {
                        "username": "aftabalam1056",
                        "content": "It needs to be balanced at each node. Both the Nodes with value 2 are not balanced."
                    },
                    {
                        "username": "Drink7",
                        "content": "Could use the same method of LC. 124 Binary Tree Maximum Path Sum"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Not a easy question! Atleast medium."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "think about the difference between the maximum left height and the maximum right height `for every single node.`\n`abs(left_height-right_height) >=2`\nupvote to reach everyone"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "Actually, it's not easy. it should be in medium category."
                    }
                ]
            },
            {
                "id": 1574734,
                "content": [
                    {
                        "username": "bob56",
                        "content": "I keep on failing on this test case: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n\\nmy output: false\\nexpected: true\\n\\nI don\\'t understand how this is expected to return true???\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147332.png)\\n\\nTree node visualization:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147429.png)\\n\\n"
                    },
                    {
                        "username": "sttony",
                        "content": "looks like python just can recursive 997, so 1,2,#,3,#,4,#,.... failed."
                    },
                    {
                        "username": "user6227l",
                        "content": "https://github.com/manish33/LeetCodeSolved/blob/master/src/main/java/BalancedBinaryTree/Solution.java"
                    },
                    {
                        "username": "Mohan165",
                        "content": "Should be [1,2,2,3,null,null,3,4,null,null,null,null,4]\\nExpected result false. Correct me if I am wrong."
                    },
                    {
                        "username": "Musfik41",
                        "content": "leetcode should provide better explanation atleast for the beginners \\uD83D\\uDE05, even i am also falls under beginner category\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "user9322HQ",
                        "content": "How is this false? I don't understand\n\n [1,2,2,3,null,null,3,4,null,null,4]\n\n\n                                                             1\n                                                      /              \\\n                              \t\t\t       2\t                  2\n                                              /     \\              /          \\\n                                         3         null        null      3\n                                     /.     \\                                /       \\\n                                  4         null                        null.    4\n"
                    },
                    {
                        "username": "aftabalam1056",
                        "content": "It needs to be balanced at each node. Both the Nodes with value 2 are not balanced."
                    },
                    {
                        "username": "Drink7",
                        "content": "Could use the same method of LC. 124 Binary Tree Maximum Path Sum"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Not a easy question! Atleast medium."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "think about the difference between the maximum left height and the maximum right height `for every single node.`\n`abs(left_height-right_height) >=2`\nupvote to reach everyone"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "Actually, it's not easy. it should be in medium category."
                    }
                ]
            },
            {
                "id": 1574467,
                "content": [
                    {
                        "username": "bob56",
                        "content": "I keep on failing on this test case: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n\\nmy output: false\\nexpected: true\\n\\nI don\\'t understand how this is expected to return true???\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147332.png)\\n\\nTree node visualization:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147429.png)\\n\\n"
                    },
                    {
                        "username": "sttony",
                        "content": "looks like python just can recursive 997, so 1,2,#,3,#,4,#,.... failed."
                    },
                    {
                        "username": "user6227l",
                        "content": "https://github.com/manish33/LeetCodeSolved/blob/master/src/main/java/BalancedBinaryTree/Solution.java"
                    },
                    {
                        "username": "Mohan165",
                        "content": "Should be [1,2,2,3,null,null,3,4,null,null,null,null,4]\\nExpected result false. Correct me if I am wrong."
                    },
                    {
                        "username": "Musfik41",
                        "content": "leetcode should provide better explanation atleast for the beginners \\uD83D\\uDE05, even i am also falls under beginner category\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "user9322HQ",
                        "content": "How is this false? I don't understand\n\n [1,2,2,3,null,null,3,4,null,null,4]\n\n\n                                                             1\n                                                      /              \\\n                              \t\t\t       2\t                  2\n                                              /     \\              /          \\\n                                         3         null        null      3\n                                     /.     \\                                /       \\\n                                  4         null                        null.    4\n"
                    },
                    {
                        "username": "aftabalam1056",
                        "content": "It needs to be balanced at each node. Both the Nodes with value 2 are not balanced."
                    },
                    {
                        "username": "Drink7",
                        "content": "Could use the same method of LC. 124 Binary Tree Maximum Path Sum"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Not a easy question! Atleast medium."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "think about the difference between the maximum left height and the maximum right height `for every single node.`\n`abs(left_height-right_height) >=2`\nupvote to reach everyone"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "Actually, it's not easy. it should be in medium category."
                    }
                ]
            },
            {
                "id": 2051856,
                "content": [
                    {
                        "username": "bob56",
                        "content": "I keep on failing on this test case: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n\\nmy output: false\\nexpected: true\\n\\nI don\\'t understand how this is expected to return true???\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147332.png)\\n\\nTree node visualization:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147429.png)\\n\\n"
                    },
                    {
                        "username": "sttony",
                        "content": "looks like python just can recursive 997, so 1,2,#,3,#,4,#,.... failed."
                    },
                    {
                        "username": "user6227l",
                        "content": "https://github.com/manish33/LeetCodeSolved/blob/master/src/main/java/BalancedBinaryTree/Solution.java"
                    },
                    {
                        "username": "Mohan165",
                        "content": "Should be [1,2,2,3,null,null,3,4,null,null,null,null,4]\\nExpected result false. Correct me if I am wrong."
                    },
                    {
                        "username": "Musfik41",
                        "content": "leetcode should provide better explanation atleast for the beginners \\uD83D\\uDE05, even i am also falls under beginner category\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "user9322HQ",
                        "content": "How is this false? I don't understand\n\n [1,2,2,3,null,null,3,4,null,null,4]\n\n\n                                                             1\n                                                      /              \\\n                              \t\t\t       2\t                  2\n                                              /     \\              /          \\\n                                         3         null        null      3\n                                     /.     \\                                /       \\\n                                  4         null                        null.    4\n"
                    },
                    {
                        "username": "aftabalam1056",
                        "content": "It needs to be balanced at each node. Both the Nodes with value 2 are not balanced."
                    },
                    {
                        "username": "Drink7",
                        "content": "Could use the same method of LC. 124 Binary Tree Maximum Path Sum"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Not a easy question! Atleast medium."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "think about the difference between the maximum left height and the maximum right height `for every single node.`\n`abs(left_height-right_height) >=2`\nupvote to reach everyone"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "Actually, it's not easy. it should be in medium category."
                    }
                ]
            },
            {
                "id": 2051393,
                "content": [
                    {
                        "username": "bob56",
                        "content": "I keep on failing on this test case: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n\\nmy output: false\\nexpected: true\\n\\nI don\\'t understand how this is expected to return true???\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147332.png)\\n\\nTree node visualization:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147429.png)\\n\\n"
                    },
                    {
                        "username": "sttony",
                        "content": "looks like python just can recursive 997, so 1,2,#,3,#,4,#,.... failed."
                    },
                    {
                        "username": "user6227l",
                        "content": "https://github.com/manish33/LeetCodeSolved/blob/master/src/main/java/BalancedBinaryTree/Solution.java"
                    },
                    {
                        "username": "Mohan165",
                        "content": "Should be [1,2,2,3,null,null,3,4,null,null,null,null,4]\\nExpected result false. Correct me if I am wrong."
                    },
                    {
                        "username": "Musfik41",
                        "content": "leetcode should provide better explanation atleast for the beginners \\uD83D\\uDE05, even i am also falls under beginner category\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "user9322HQ",
                        "content": "How is this false? I don't understand\n\n [1,2,2,3,null,null,3,4,null,null,4]\n\n\n                                                             1\n                                                      /              \\\n                              \t\t\t       2\t                  2\n                                              /     \\              /          \\\n                                         3         null        null      3\n                                     /.     \\                                /       \\\n                                  4         null                        null.    4\n"
                    },
                    {
                        "username": "aftabalam1056",
                        "content": "It needs to be balanced at each node. Both the Nodes with value 2 are not balanced."
                    },
                    {
                        "username": "Drink7",
                        "content": "Could use the same method of LC. 124 Binary Tree Maximum Path Sum"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Not a easy question! Atleast medium."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "think about the difference between the maximum left height and the maximum right height `for every single node.`\n`abs(left_height-right_height) >=2`\nupvote to reach everyone"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "Actually, it's not easy. it should be in medium category."
                    }
                ]
            },
            {
                "id": 2042840,
                "content": [
                    {
                        "username": "bob56",
                        "content": "I keep on failing on this test case: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n\\nmy output: false\\nexpected: true\\n\\nI don\\'t understand how this is expected to return true???\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147332.png)\\n\\nTree node visualization:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147429.png)\\n\\n"
                    },
                    {
                        "username": "sttony",
                        "content": "looks like python just can recursive 997, so 1,2,#,3,#,4,#,.... failed."
                    },
                    {
                        "username": "user6227l",
                        "content": "https://github.com/manish33/LeetCodeSolved/blob/master/src/main/java/BalancedBinaryTree/Solution.java"
                    },
                    {
                        "username": "Mohan165",
                        "content": "Should be [1,2,2,3,null,null,3,4,null,null,null,null,4]\\nExpected result false. Correct me if I am wrong."
                    },
                    {
                        "username": "Musfik41",
                        "content": "leetcode should provide better explanation atleast for the beginners \\uD83D\\uDE05, even i am also falls under beginner category\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "user9322HQ",
                        "content": "How is this false? I don't understand\n\n [1,2,2,3,null,null,3,4,null,null,4]\n\n\n                                                             1\n                                                      /              \\\n                              \t\t\t       2\t                  2\n                                              /     \\              /          \\\n                                         3         null        null      3\n                                     /.     \\                                /       \\\n                                  4         null                        null.    4\n"
                    },
                    {
                        "username": "aftabalam1056",
                        "content": "It needs to be balanced at each node. Both the Nodes with value 2 are not balanced."
                    },
                    {
                        "username": "Drink7",
                        "content": "Could use the same method of LC. 124 Binary Tree Maximum Path Sum"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Not a easy question! Atleast medium."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "think about the difference between the maximum left height and the maximum right height `for every single node.`\n`abs(left_height-right_height) >=2`\nupvote to reach everyone"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "Actually, it's not easy. it should be in medium category."
                    }
                ]
            },
            {
                "id": 2042440,
                "content": [
                    {
                        "username": "bob56",
                        "content": "I keep on failing on this test case: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n\\nmy output: false\\nexpected: true\\n\\nI don\\'t understand how this is expected to return true???\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147332.png)\\n\\nTree node visualization:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147429.png)\\n\\n"
                    },
                    {
                        "username": "sttony",
                        "content": "looks like python just can recursive 997, so 1,2,#,3,#,4,#,.... failed."
                    },
                    {
                        "username": "user6227l",
                        "content": "https://github.com/manish33/LeetCodeSolved/blob/master/src/main/java/BalancedBinaryTree/Solution.java"
                    },
                    {
                        "username": "Mohan165",
                        "content": "Should be [1,2,2,3,null,null,3,4,null,null,null,null,4]\\nExpected result false. Correct me if I am wrong."
                    },
                    {
                        "username": "Musfik41",
                        "content": "leetcode should provide better explanation atleast for the beginners \\uD83D\\uDE05, even i am also falls under beginner category\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "user9322HQ",
                        "content": "How is this false? I don't understand\n\n [1,2,2,3,null,null,3,4,null,null,4]\n\n\n                                                             1\n                                                      /              \\\n                              \t\t\t       2\t                  2\n                                              /     \\              /          \\\n                                         3         null        null      3\n                                     /.     \\                                /       \\\n                                  4         null                        null.    4\n"
                    },
                    {
                        "username": "aftabalam1056",
                        "content": "It needs to be balanced at each node. Both the Nodes with value 2 are not balanced."
                    },
                    {
                        "username": "Drink7",
                        "content": "Could use the same method of LC. 124 Binary Tree Maximum Path Sum"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Not a easy question! Atleast medium."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "think about the difference between the maximum left height and the maximum right height `for every single node.`\n`abs(left_height-right_height) >=2`\nupvote to reach everyone"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "Actually, it's not easy. it should be in medium category."
                    }
                ]
            },
            {
                "id": 2020949,
                "content": [
                    {
                        "username": "bob56",
                        "content": "I keep on failing on this test case: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n\\nmy output: false\\nexpected: true\\n\\nI don\\'t understand how this is expected to return true???\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147332.png)\\n\\nTree node visualization:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147429.png)\\n\\n"
                    },
                    {
                        "username": "sttony",
                        "content": "looks like python just can recursive 997, so 1,2,#,3,#,4,#,.... failed."
                    },
                    {
                        "username": "user6227l",
                        "content": "https://github.com/manish33/LeetCodeSolved/blob/master/src/main/java/BalancedBinaryTree/Solution.java"
                    },
                    {
                        "username": "Mohan165",
                        "content": "Should be [1,2,2,3,null,null,3,4,null,null,null,null,4]\\nExpected result false. Correct me if I am wrong."
                    },
                    {
                        "username": "Musfik41",
                        "content": "leetcode should provide better explanation atleast for the beginners \\uD83D\\uDE05, even i am also falls under beginner category\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "user9322HQ",
                        "content": "How is this false? I don't understand\n\n [1,2,2,3,null,null,3,4,null,null,4]\n\n\n                                                             1\n                                                      /              \\\n                              \t\t\t       2\t                  2\n                                              /     \\              /          \\\n                                         3         null        null      3\n                                     /.     \\                                /       \\\n                                  4         null                        null.    4\n"
                    },
                    {
                        "username": "aftabalam1056",
                        "content": "It needs to be balanced at each node. Both the Nodes with value 2 are not balanced."
                    },
                    {
                        "username": "Drink7",
                        "content": "Could use the same method of LC. 124 Binary Tree Maximum Path Sum"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Not a easy question! Atleast medium."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "think about the difference between the maximum left height and the maximum right height `for every single node.`\n`abs(left_height-right_height) >=2`\nupvote to reach everyone"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "Actually, it's not easy. it should be in medium category."
                    }
                ]
            },
            {
                "id": 1995876,
                "content": [
                    {
                        "username": "bob56",
                        "content": "I keep on failing on this test case: [1,2,2,3,3,3,3,4,4,4,4,4,4,null,null,5,5]\\n\\nmy output: false\\nexpected: true\\n\\nI don\\'t understand how this is expected to return true???\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147332.png)\\n\\nTree node visualization:\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/mikerojaswa/image_1537147429.png)\\n\\n"
                    },
                    {
                        "username": "sttony",
                        "content": "looks like python just can recursive 997, so 1,2,#,3,#,4,#,.... failed."
                    },
                    {
                        "username": "user6227l",
                        "content": "https://github.com/manish33/LeetCodeSolved/blob/master/src/main/java/BalancedBinaryTree/Solution.java"
                    },
                    {
                        "username": "Mohan165",
                        "content": "Should be [1,2,2,3,null,null,3,4,null,null,null,null,4]\\nExpected result false. Correct me if I am wrong."
                    },
                    {
                        "username": "Musfik41",
                        "content": "leetcode should provide better explanation atleast for the beginners \\uD83D\\uDE05, even i am also falls under beginner category\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "user9322HQ",
                        "content": "How is this false? I don't understand\n\n [1,2,2,3,null,null,3,4,null,null,4]\n\n\n                                                             1\n                                                      /              \\\n                              \t\t\t       2\t                  2\n                                              /     \\              /          \\\n                                         3         null        null      3\n                                     /.     \\                                /       \\\n                                  4         null                        null.    4\n"
                    },
                    {
                        "username": "aftabalam1056",
                        "content": "It needs to be balanced at each node. Both the Nodes with value 2 are not balanced."
                    },
                    {
                        "username": "Drink7",
                        "content": "Could use the same method of LC. 124 Binary Tree Maximum Path Sum"
                    },
                    {
                        "username": "kalpeshkj646",
                        "content": "Not a easy question! Atleast medium."
                    },
                    {
                        "username": "alighraibeh87",
                        "content": "think about the difference between the maximum left height and the maximum right height `for every single node.`\n`abs(left_height-right_height) >=2`\nupvote to reach everyone"
                    },
                    {
                        "username": "SumitVerma9005",
                        "content": "Actually, it's not easy. it should be in medium category."
                    }
                ]
            },
            {
                "id": 1960757,
                "content": [
                    {
                        "username": "jimxu1988",
                        "content": "just like  [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/), dfs to calculate the depth, while in the meantime, keep track one more thing  `isBalanced` by comparing the depth from left and right sub tree."
                    },
                    {
                        "username": "jamalie",
                        "content": "The reason ```[1,2,2,3,null,null,3,4,null,null,4]``` is not a balanced tree is because the balance considers the depth of the two subtrees of EVERY child node starting from root. This means we not only need to consider the two immediate subtrees but every childs subtree. Here\\'s my solution:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def find_max_depth(self, root):\\n        if not root: return 0\\n\\n        return 1 + max(self.find_max_depth(root.left), self.find_max_depth(root.right))\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if not root: return True\\n        left = 0\\n        right = 0\\n\\n        if root.left:\\n            if not self.isBalanced(root.left):\\n                return False\\n            left = self.find_max_depth(root.left)\\n        if root.right:\\n            if not self.isBalanced(root.right):\\n                return False\\n            right = self.find_max_depth(root.right)\\n\\n        print(left, right)\\n\\n        if abs(left - right) > 1:\\n            return False\\n        return True\\n\\n```"
                    },
                    {
                        "username": "Yiggu_",
                        "content": "I wrote this code by myself and compared it with the official answer, but I couldn\\'t understand why this code can not be passed. Is any people willing to help me ?\\n\\n\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        res = True\\n        level = 1\\n        return self.getHeight(root)[0]\\n    \\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        if not root:    #if root is null \\n            return True,-1\\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n        if abs(lheight - rheight) > 1:\\n            return False,0\\n        \\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        return self.getHeight(root)[0]\\n\\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        # print(root)\\n        if not root:    #if root is null \\n            return True,-1\\n        \\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n\\n        if abs(lheight - rheight) > 1 or left_is_balanced == False or right_is_balanced == False:\\n            return False,0\\n\\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[1,2,2,3,null,null,3,4,null,null,4]\\n       1\\n      / \\\\\\n     2   2\\n    /     \\\\\\n   3       3\\n  /         \\\\\\n 4           4\\ncan someone tell  why this tree is not height balanced?\\nor it\\'s wrong test case?"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sunchipsster",
                        "content": "Why is [1,null,2,null,3] supposed to be False? There is only one leaf (3) from 1-> 2-> 3\n\nExpected: false\n\nTest case 88/228"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "can anyone give an example when (lh==-1 || rh==-1)?\nI find most of the optimised codes using this:\n int height(TreeNode* root)\n    {\n        if(root==NULL)\n            return 0;\n        int lh=height(root->left);\n        int rh=height(root->right);\n        if(lh==-1 || rh==-1)\n            return -1;\n        if(abs(lh-rh)>1)\n            return -1;\n        return 1+max(lh,rh);\n    }\n    bool isBalanced(TreeNode* root) {\n        return height(root)!=-1;  \n    }"
                    },
                    {
                        "username": "RChandra612",
                        "content": "\n` \nbool isBalanced(TreeNode* root) {\n            if(!root)\n                return true;\n            int lh = height(root->left);\n            int rh = height(root->right);\n            if(abs(lh - rh) > 1)\n                return false;\n            return true;\n    }\n    int height(TreeNode* root){\n        if(root == NULL)\n            return 0;\n        return 1 + max(height(root->left), height(root->right));\n    }\n `\n\nwhat is the problem with above code, i intentionally left checking the subtrees to be balanced, because i could not think of any binary tree which has over all height difference is 1, but whose subtrees have overall height differences greater than 1."
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I saw a lots of guys discussing not using DFS. OK, I think the best benefit of DFS is that if you state your recursion correct, you will never worry about those stupid weird cases."
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "The standard of Height balanced is \"if the difference in the depth of subtrees own by two node is less than 2\""
                    },
                    {
                        "username": "zacktimusprime18",
                        "content": "python"
                    }
                ]
            },
            {
                "id": 1956855,
                "content": [
                    {
                        "username": "jimxu1988",
                        "content": "just like  [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/), dfs to calculate the depth, while in the meantime, keep track one more thing  `isBalanced` by comparing the depth from left and right sub tree."
                    },
                    {
                        "username": "jamalie",
                        "content": "The reason ```[1,2,2,3,null,null,3,4,null,null,4]``` is not a balanced tree is because the balance considers the depth of the two subtrees of EVERY child node starting from root. This means we not only need to consider the two immediate subtrees but every childs subtree. Here\\'s my solution:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def find_max_depth(self, root):\\n        if not root: return 0\\n\\n        return 1 + max(self.find_max_depth(root.left), self.find_max_depth(root.right))\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if not root: return True\\n        left = 0\\n        right = 0\\n\\n        if root.left:\\n            if not self.isBalanced(root.left):\\n                return False\\n            left = self.find_max_depth(root.left)\\n        if root.right:\\n            if not self.isBalanced(root.right):\\n                return False\\n            right = self.find_max_depth(root.right)\\n\\n        print(left, right)\\n\\n        if abs(left - right) > 1:\\n            return False\\n        return True\\n\\n```"
                    },
                    {
                        "username": "Yiggu_",
                        "content": "I wrote this code by myself and compared it with the official answer, but I couldn\\'t understand why this code can not be passed. Is any people willing to help me ?\\n\\n\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        res = True\\n        level = 1\\n        return self.getHeight(root)[0]\\n    \\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        if not root:    #if root is null \\n            return True,-1\\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n        if abs(lheight - rheight) > 1:\\n            return False,0\\n        \\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        return self.getHeight(root)[0]\\n\\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        # print(root)\\n        if not root:    #if root is null \\n            return True,-1\\n        \\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n\\n        if abs(lheight - rheight) > 1 or left_is_balanced == False or right_is_balanced == False:\\n            return False,0\\n\\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[1,2,2,3,null,null,3,4,null,null,4]\\n       1\\n      / \\\\\\n     2   2\\n    /     \\\\\\n   3       3\\n  /         \\\\\\n 4           4\\ncan someone tell  why this tree is not height balanced?\\nor it\\'s wrong test case?"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sunchipsster",
                        "content": "Why is [1,null,2,null,3] supposed to be False? There is only one leaf (3) from 1-> 2-> 3\n\nExpected: false\n\nTest case 88/228"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "can anyone give an example when (lh==-1 || rh==-1)?\nI find most of the optimised codes using this:\n int height(TreeNode* root)\n    {\n        if(root==NULL)\n            return 0;\n        int lh=height(root->left);\n        int rh=height(root->right);\n        if(lh==-1 || rh==-1)\n            return -1;\n        if(abs(lh-rh)>1)\n            return -1;\n        return 1+max(lh,rh);\n    }\n    bool isBalanced(TreeNode* root) {\n        return height(root)!=-1;  \n    }"
                    },
                    {
                        "username": "RChandra612",
                        "content": "\n` \nbool isBalanced(TreeNode* root) {\n            if(!root)\n                return true;\n            int lh = height(root->left);\n            int rh = height(root->right);\n            if(abs(lh - rh) > 1)\n                return false;\n            return true;\n    }\n    int height(TreeNode* root){\n        if(root == NULL)\n            return 0;\n        return 1 + max(height(root->left), height(root->right));\n    }\n `\n\nwhat is the problem with above code, i intentionally left checking the subtrees to be balanced, because i could not think of any binary tree which has over all height difference is 1, but whose subtrees have overall height differences greater than 1."
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I saw a lots of guys discussing not using DFS. OK, I think the best benefit of DFS is that if you state your recursion correct, you will never worry about those stupid weird cases."
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "The standard of Height balanced is \"if the difference in the depth of subtrees own by two node is less than 2\""
                    },
                    {
                        "username": "zacktimusprime18",
                        "content": "python"
                    }
                ]
            },
            {
                "id": 1920186,
                "content": [
                    {
                        "username": "jimxu1988",
                        "content": "just like  [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/), dfs to calculate the depth, while in the meantime, keep track one more thing  `isBalanced` by comparing the depth from left and right sub tree."
                    },
                    {
                        "username": "jamalie",
                        "content": "The reason ```[1,2,2,3,null,null,3,4,null,null,4]``` is not a balanced tree is because the balance considers the depth of the two subtrees of EVERY child node starting from root. This means we not only need to consider the two immediate subtrees but every childs subtree. Here\\'s my solution:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def find_max_depth(self, root):\\n        if not root: return 0\\n\\n        return 1 + max(self.find_max_depth(root.left), self.find_max_depth(root.right))\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if not root: return True\\n        left = 0\\n        right = 0\\n\\n        if root.left:\\n            if not self.isBalanced(root.left):\\n                return False\\n            left = self.find_max_depth(root.left)\\n        if root.right:\\n            if not self.isBalanced(root.right):\\n                return False\\n            right = self.find_max_depth(root.right)\\n\\n        print(left, right)\\n\\n        if abs(left - right) > 1:\\n            return False\\n        return True\\n\\n```"
                    },
                    {
                        "username": "Yiggu_",
                        "content": "I wrote this code by myself and compared it with the official answer, but I couldn\\'t understand why this code can not be passed. Is any people willing to help me ?\\n\\n\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        res = True\\n        level = 1\\n        return self.getHeight(root)[0]\\n    \\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        if not root:    #if root is null \\n            return True,-1\\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n        if abs(lheight - rheight) > 1:\\n            return False,0\\n        \\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        return self.getHeight(root)[0]\\n\\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        # print(root)\\n        if not root:    #if root is null \\n            return True,-1\\n        \\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n\\n        if abs(lheight - rheight) > 1 or left_is_balanced == False or right_is_balanced == False:\\n            return False,0\\n\\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[1,2,2,3,null,null,3,4,null,null,4]\\n       1\\n      / \\\\\\n     2   2\\n    /     \\\\\\n   3       3\\n  /         \\\\\\n 4           4\\ncan someone tell  why this tree is not height balanced?\\nor it\\'s wrong test case?"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sunchipsster",
                        "content": "Why is [1,null,2,null,3] supposed to be False? There is only one leaf (3) from 1-> 2-> 3\n\nExpected: false\n\nTest case 88/228"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "can anyone give an example when (lh==-1 || rh==-1)?\nI find most of the optimised codes using this:\n int height(TreeNode* root)\n    {\n        if(root==NULL)\n            return 0;\n        int lh=height(root->left);\n        int rh=height(root->right);\n        if(lh==-1 || rh==-1)\n            return -1;\n        if(abs(lh-rh)>1)\n            return -1;\n        return 1+max(lh,rh);\n    }\n    bool isBalanced(TreeNode* root) {\n        return height(root)!=-1;  \n    }"
                    },
                    {
                        "username": "RChandra612",
                        "content": "\n` \nbool isBalanced(TreeNode* root) {\n            if(!root)\n                return true;\n            int lh = height(root->left);\n            int rh = height(root->right);\n            if(abs(lh - rh) > 1)\n                return false;\n            return true;\n    }\n    int height(TreeNode* root){\n        if(root == NULL)\n            return 0;\n        return 1 + max(height(root->left), height(root->right));\n    }\n `\n\nwhat is the problem with above code, i intentionally left checking the subtrees to be balanced, because i could not think of any binary tree which has over all height difference is 1, but whose subtrees have overall height differences greater than 1."
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I saw a lots of guys discussing not using DFS. OK, I think the best benefit of DFS is that if you state your recursion correct, you will never worry about those stupid weird cases."
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "The standard of Height balanced is \"if the difference in the depth of subtrees own by two node is less than 2\""
                    },
                    {
                        "username": "zacktimusprime18",
                        "content": "python"
                    }
                ]
            },
            {
                "id": 1919832,
                "content": [
                    {
                        "username": "jimxu1988",
                        "content": "just like  [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/), dfs to calculate the depth, while in the meantime, keep track one more thing  `isBalanced` by comparing the depth from left and right sub tree."
                    },
                    {
                        "username": "jamalie",
                        "content": "The reason ```[1,2,2,3,null,null,3,4,null,null,4]``` is not a balanced tree is because the balance considers the depth of the two subtrees of EVERY child node starting from root. This means we not only need to consider the two immediate subtrees but every childs subtree. Here\\'s my solution:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def find_max_depth(self, root):\\n        if not root: return 0\\n\\n        return 1 + max(self.find_max_depth(root.left), self.find_max_depth(root.right))\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if not root: return True\\n        left = 0\\n        right = 0\\n\\n        if root.left:\\n            if not self.isBalanced(root.left):\\n                return False\\n            left = self.find_max_depth(root.left)\\n        if root.right:\\n            if not self.isBalanced(root.right):\\n                return False\\n            right = self.find_max_depth(root.right)\\n\\n        print(left, right)\\n\\n        if abs(left - right) > 1:\\n            return False\\n        return True\\n\\n```"
                    },
                    {
                        "username": "Yiggu_",
                        "content": "I wrote this code by myself and compared it with the official answer, but I couldn\\'t understand why this code can not be passed. Is any people willing to help me ?\\n\\n\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        res = True\\n        level = 1\\n        return self.getHeight(root)[0]\\n    \\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        if not root:    #if root is null \\n            return True,-1\\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n        if abs(lheight - rheight) > 1:\\n            return False,0\\n        \\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        return self.getHeight(root)[0]\\n\\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        # print(root)\\n        if not root:    #if root is null \\n            return True,-1\\n        \\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n\\n        if abs(lheight - rheight) > 1 or left_is_balanced == False or right_is_balanced == False:\\n            return False,0\\n\\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[1,2,2,3,null,null,3,4,null,null,4]\\n       1\\n      / \\\\\\n     2   2\\n    /     \\\\\\n   3       3\\n  /         \\\\\\n 4           4\\ncan someone tell  why this tree is not height balanced?\\nor it\\'s wrong test case?"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sunchipsster",
                        "content": "Why is [1,null,2,null,3] supposed to be False? There is only one leaf (3) from 1-> 2-> 3\n\nExpected: false\n\nTest case 88/228"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "can anyone give an example when (lh==-1 || rh==-1)?\nI find most of the optimised codes using this:\n int height(TreeNode* root)\n    {\n        if(root==NULL)\n            return 0;\n        int lh=height(root->left);\n        int rh=height(root->right);\n        if(lh==-1 || rh==-1)\n            return -1;\n        if(abs(lh-rh)>1)\n            return -1;\n        return 1+max(lh,rh);\n    }\n    bool isBalanced(TreeNode* root) {\n        return height(root)!=-1;  \n    }"
                    },
                    {
                        "username": "RChandra612",
                        "content": "\n` \nbool isBalanced(TreeNode* root) {\n            if(!root)\n                return true;\n            int lh = height(root->left);\n            int rh = height(root->right);\n            if(abs(lh - rh) > 1)\n                return false;\n            return true;\n    }\n    int height(TreeNode* root){\n        if(root == NULL)\n            return 0;\n        return 1 + max(height(root->left), height(root->right));\n    }\n `\n\nwhat is the problem with above code, i intentionally left checking the subtrees to be balanced, because i could not think of any binary tree which has over all height difference is 1, but whose subtrees have overall height differences greater than 1."
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I saw a lots of guys discussing not using DFS. OK, I think the best benefit of DFS is that if you state your recursion correct, you will never worry about those stupid weird cases."
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "The standard of Height balanced is \"if the difference in the depth of subtrees own by two node is less than 2\""
                    },
                    {
                        "username": "zacktimusprime18",
                        "content": "python"
                    }
                ]
            },
            {
                "id": 1865058,
                "content": [
                    {
                        "username": "jimxu1988",
                        "content": "just like  [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/), dfs to calculate the depth, while in the meantime, keep track one more thing  `isBalanced` by comparing the depth from left and right sub tree."
                    },
                    {
                        "username": "jamalie",
                        "content": "The reason ```[1,2,2,3,null,null,3,4,null,null,4]``` is not a balanced tree is because the balance considers the depth of the two subtrees of EVERY child node starting from root. This means we not only need to consider the two immediate subtrees but every childs subtree. Here\\'s my solution:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def find_max_depth(self, root):\\n        if not root: return 0\\n\\n        return 1 + max(self.find_max_depth(root.left), self.find_max_depth(root.right))\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if not root: return True\\n        left = 0\\n        right = 0\\n\\n        if root.left:\\n            if not self.isBalanced(root.left):\\n                return False\\n            left = self.find_max_depth(root.left)\\n        if root.right:\\n            if not self.isBalanced(root.right):\\n                return False\\n            right = self.find_max_depth(root.right)\\n\\n        print(left, right)\\n\\n        if abs(left - right) > 1:\\n            return False\\n        return True\\n\\n```"
                    },
                    {
                        "username": "Yiggu_",
                        "content": "I wrote this code by myself and compared it with the official answer, but I couldn\\'t understand why this code can not be passed. Is any people willing to help me ?\\n\\n\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        res = True\\n        level = 1\\n        return self.getHeight(root)[0]\\n    \\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        if not root:    #if root is null \\n            return True,-1\\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n        if abs(lheight - rheight) > 1:\\n            return False,0\\n        \\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        return self.getHeight(root)[0]\\n\\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        # print(root)\\n        if not root:    #if root is null \\n            return True,-1\\n        \\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n\\n        if abs(lheight - rheight) > 1 or left_is_balanced == False or right_is_balanced == False:\\n            return False,0\\n\\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[1,2,2,3,null,null,3,4,null,null,4]\\n       1\\n      / \\\\\\n     2   2\\n    /     \\\\\\n   3       3\\n  /         \\\\\\n 4           4\\ncan someone tell  why this tree is not height balanced?\\nor it\\'s wrong test case?"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sunchipsster",
                        "content": "Why is [1,null,2,null,3] supposed to be False? There is only one leaf (3) from 1-> 2-> 3\n\nExpected: false\n\nTest case 88/228"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "can anyone give an example when (lh==-1 || rh==-1)?\nI find most of the optimised codes using this:\n int height(TreeNode* root)\n    {\n        if(root==NULL)\n            return 0;\n        int lh=height(root->left);\n        int rh=height(root->right);\n        if(lh==-1 || rh==-1)\n            return -1;\n        if(abs(lh-rh)>1)\n            return -1;\n        return 1+max(lh,rh);\n    }\n    bool isBalanced(TreeNode* root) {\n        return height(root)!=-1;  \n    }"
                    },
                    {
                        "username": "RChandra612",
                        "content": "\n` \nbool isBalanced(TreeNode* root) {\n            if(!root)\n                return true;\n            int lh = height(root->left);\n            int rh = height(root->right);\n            if(abs(lh - rh) > 1)\n                return false;\n            return true;\n    }\n    int height(TreeNode* root){\n        if(root == NULL)\n            return 0;\n        return 1 + max(height(root->left), height(root->right));\n    }\n `\n\nwhat is the problem with above code, i intentionally left checking the subtrees to be balanced, because i could not think of any binary tree which has over all height difference is 1, but whose subtrees have overall height differences greater than 1."
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I saw a lots of guys discussing not using DFS. OK, I think the best benefit of DFS is that if you state your recursion correct, you will never worry about those stupid weird cases."
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "The standard of Height balanced is \"if the difference in the depth of subtrees own by two node is less than 2\""
                    },
                    {
                        "username": "zacktimusprime18",
                        "content": "python"
                    }
                ]
            },
            {
                "id": 1861288,
                "content": [
                    {
                        "username": "jimxu1988",
                        "content": "just like  [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/), dfs to calculate the depth, while in the meantime, keep track one more thing  `isBalanced` by comparing the depth from left and right sub tree."
                    },
                    {
                        "username": "jamalie",
                        "content": "The reason ```[1,2,2,3,null,null,3,4,null,null,4]``` is not a balanced tree is because the balance considers the depth of the two subtrees of EVERY child node starting from root. This means we not only need to consider the two immediate subtrees but every childs subtree. Here\\'s my solution:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def find_max_depth(self, root):\\n        if not root: return 0\\n\\n        return 1 + max(self.find_max_depth(root.left), self.find_max_depth(root.right))\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if not root: return True\\n        left = 0\\n        right = 0\\n\\n        if root.left:\\n            if not self.isBalanced(root.left):\\n                return False\\n            left = self.find_max_depth(root.left)\\n        if root.right:\\n            if not self.isBalanced(root.right):\\n                return False\\n            right = self.find_max_depth(root.right)\\n\\n        print(left, right)\\n\\n        if abs(left - right) > 1:\\n            return False\\n        return True\\n\\n```"
                    },
                    {
                        "username": "Yiggu_",
                        "content": "I wrote this code by myself and compared it with the official answer, but I couldn\\'t understand why this code can not be passed. Is any people willing to help me ?\\n\\n\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        res = True\\n        level = 1\\n        return self.getHeight(root)[0]\\n    \\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        if not root:    #if root is null \\n            return True,-1\\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n        if abs(lheight - rheight) > 1:\\n            return False,0\\n        \\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        return self.getHeight(root)[0]\\n\\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        # print(root)\\n        if not root:    #if root is null \\n            return True,-1\\n        \\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n\\n        if abs(lheight - rheight) > 1 or left_is_balanced == False or right_is_balanced == False:\\n            return False,0\\n\\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[1,2,2,3,null,null,3,4,null,null,4]\\n       1\\n      / \\\\\\n     2   2\\n    /     \\\\\\n   3       3\\n  /         \\\\\\n 4           4\\ncan someone tell  why this tree is not height balanced?\\nor it\\'s wrong test case?"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sunchipsster",
                        "content": "Why is [1,null,2,null,3] supposed to be False? There is only one leaf (3) from 1-> 2-> 3\n\nExpected: false\n\nTest case 88/228"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "can anyone give an example when (lh==-1 || rh==-1)?\nI find most of the optimised codes using this:\n int height(TreeNode* root)\n    {\n        if(root==NULL)\n            return 0;\n        int lh=height(root->left);\n        int rh=height(root->right);\n        if(lh==-1 || rh==-1)\n            return -1;\n        if(abs(lh-rh)>1)\n            return -1;\n        return 1+max(lh,rh);\n    }\n    bool isBalanced(TreeNode* root) {\n        return height(root)!=-1;  \n    }"
                    },
                    {
                        "username": "RChandra612",
                        "content": "\n` \nbool isBalanced(TreeNode* root) {\n            if(!root)\n                return true;\n            int lh = height(root->left);\n            int rh = height(root->right);\n            if(abs(lh - rh) > 1)\n                return false;\n            return true;\n    }\n    int height(TreeNode* root){\n        if(root == NULL)\n            return 0;\n        return 1 + max(height(root->left), height(root->right));\n    }\n `\n\nwhat is the problem with above code, i intentionally left checking the subtrees to be balanced, because i could not think of any binary tree which has over all height difference is 1, but whose subtrees have overall height differences greater than 1."
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I saw a lots of guys discussing not using DFS. OK, I think the best benefit of DFS is that if you state your recursion correct, you will never worry about those stupid weird cases."
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "The standard of Height balanced is \"if the difference in the depth of subtrees own by two node is less than 2\""
                    },
                    {
                        "username": "zacktimusprime18",
                        "content": "python"
                    }
                ]
            },
            {
                "id": 1860612,
                "content": [
                    {
                        "username": "jimxu1988",
                        "content": "just like  [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/), dfs to calculate the depth, while in the meantime, keep track one more thing  `isBalanced` by comparing the depth from left and right sub tree."
                    },
                    {
                        "username": "jamalie",
                        "content": "The reason ```[1,2,2,3,null,null,3,4,null,null,4]``` is not a balanced tree is because the balance considers the depth of the two subtrees of EVERY child node starting from root. This means we not only need to consider the two immediate subtrees but every childs subtree. Here\\'s my solution:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def find_max_depth(self, root):\\n        if not root: return 0\\n\\n        return 1 + max(self.find_max_depth(root.left), self.find_max_depth(root.right))\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if not root: return True\\n        left = 0\\n        right = 0\\n\\n        if root.left:\\n            if not self.isBalanced(root.left):\\n                return False\\n            left = self.find_max_depth(root.left)\\n        if root.right:\\n            if not self.isBalanced(root.right):\\n                return False\\n            right = self.find_max_depth(root.right)\\n\\n        print(left, right)\\n\\n        if abs(left - right) > 1:\\n            return False\\n        return True\\n\\n```"
                    },
                    {
                        "username": "Yiggu_",
                        "content": "I wrote this code by myself and compared it with the official answer, but I couldn\\'t understand why this code can not be passed. Is any people willing to help me ?\\n\\n\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        res = True\\n        level = 1\\n        return self.getHeight(root)[0]\\n    \\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        if not root:    #if root is null \\n            return True,-1\\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n        if abs(lheight - rheight) > 1:\\n            return False,0\\n        \\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        return self.getHeight(root)[0]\\n\\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        # print(root)\\n        if not root:    #if root is null \\n            return True,-1\\n        \\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n\\n        if abs(lheight - rheight) > 1 or left_is_balanced == False or right_is_balanced == False:\\n            return False,0\\n\\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[1,2,2,3,null,null,3,4,null,null,4]\\n       1\\n      / \\\\\\n     2   2\\n    /     \\\\\\n   3       3\\n  /         \\\\\\n 4           4\\ncan someone tell  why this tree is not height balanced?\\nor it\\'s wrong test case?"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sunchipsster",
                        "content": "Why is [1,null,2,null,3] supposed to be False? There is only one leaf (3) from 1-> 2-> 3\n\nExpected: false\n\nTest case 88/228"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "can anyone give an example when (lh==-1 || rh==-1)?\nI find most of the optimised codes using this:\n int height(TreeNode* root)\n    {\n        if(root==NULL)\n            return 0;\n        int lh=height(root->left);\n        int rh=height(root->right);\n        if(lh==-1 || rh==-1)\n            return -1;\n        if(abs(lh-rh)>1)\n            return -1;\n        return 1+max(lh,rh);\n    }\n    bool isBalanced(TreeNode* root) {\n        return height(root)!=-1;  \n    }"
                    },
                    {
                        "username": "RChandra612",
                        "content": "\n` \nbool isBalanced(TreeNode* root) {\n            if(!root)\n                return true;\n            int lh = height(root->left);\n            int rh = height(root->right);\n            if(abs(lh - rh) > 1)\n                return false;\n            return true;\n    }\n    int height(TreeNode* root){\n        if(root == NULL)\n            return 0;\n        return 1 + max(height(root->left), height(root->right));\n    }\n `\n\nwhat is the problem with above code, i intentionally left checking the subtrees to be balanced, because i could not think of any binary tree which has over all height difference is 1, but whose subtrees have overall height differences greater than 1."
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I saw a lots of guys discussing not using DFS. OK, I think the best benefit of DFS is that if you state your recursion correct, you will never worry about those stupid weird cases."
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "The standard of Height balanced is \"if the difference in the depth of subtrees own by two node is less than 2\""
                    },
                    {
                        "username": "zacktimusprime18",
                        "content": "python"
                    }
                ]
            },
            {
                "id": 1832222,
                "content": [
                    {
                        "username": "jimxu1988",
                        "content": "just like  [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/), dfs to calculate the depth, while in the meantime, keep track one more thing  `isBalanced` by comparing the depth from left and right sub tree."
                    },
                    {
                        "username": "jamalie",
                        "content": "The reason ```[1,2,2,3,null,null,3,4,null,null,4]``` is not a balanced tree is because the balance considers the depth of the two subtrees of EVERY child node starting from root. This means we not only need to consider the two immediate subtrees but every childs subtree. Here\\'s my solution:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def find_max_depth(self, root):\\n        if not root: return 0\\n\\n        return 1 + max(self.find_max_depth(root.left), self.find_max_depth(root.right))\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if not root: return True\\n        left = 0\\n        right = 0\\n\\n        if root.left:\\n            if not self.isBalanced(root.left):\\n                return False\\n            left = self.find_max_depth(root.left)\\n        if root.right:\\n            if not self.isBalanced(root.right):\\n                return False\\n            right = self.find_max_depth(root.right)\\n\\n        print(left, right)\\n\\n        if abs(left - right) > 1:\\n            return False\\n        return True\\n\\n```"
                    },
                    {
                        "username": "Yiggu_",
                        "content": "I wrote this code by myself and compared it with the official answer, but I couldn\\'t understand why this code can not be passed. Is any people willing to help me ?\\n\\n\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        res = True\\n        level = 1\\n        return self.getHeight(root)[0]\\n    \\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        if not root:    #if root is null \\n            return True,-1\\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n        if abs(lheight - rheight) > 1:\\n            return False,0\\n        \\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        return self.getHeight(root)[0]\\n\\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        # print(root)\\n        if not root:    #if root is null \\n            return True,-1\\n        \\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n\\n        if abs(lheight - rheight) > 1 or left_is_balanced == False or right_is_balanced == False:\\n            return False,0\\n\\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[1,2,2,3,null,null,3,4,null,null,4]\\n       1\\n      / \\\\\\n     2   2\\n    /     \\\\\\n   3       3\\n  /         \\\\\\n 4           4\\ncan someone tell  why this tree is not height balanced?\\nor it\\'s wrong test case?"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sunchipsster",
                        "content": "Why is [1,null,2,null,3] supposed to be False? There is only one leaf (3) from 1-> 2-> 3\n\nExpected: false\n\nTest case 88/228"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "can anyone give an example when (lh==-1 || rh==-1)?\nI find most of the optimised codes using this:\n int height(TreeNode* root)\n    {\n        if(root==NULL)\n            return 0;\n        int lh=height(root->left);\n        int rh=height(root->right);\n        if(lh==-1 || rh==-1)\n            return -1;\n        if(abs(lh-rh)>1)\n            return -1;\n        return 1+max(lh,rh);\n    }\n    bool isBalanced(TreeNode* root) {\n        return height(root)!=-1;  \n    }"
                    },
                    {
                        "username": "RChandra612",
                        "content": "\n` \nbool isBalanced(TreeNode* root) {\n            if(!root)\n                return true;\n            int lh = height(root->left);\n            int rh = height(root->right);\n            if(abs(lh - rh) > 1)\n                return false;\n            return true;\n    }\n    int height(TreeNode* root){\n        if(root == NULL)\n            return 0;\n        return 1 + max(height(root->left), height(root->right));\n    }\n `\n\nwhat is the problem with above code, i intentionally left checking the subtrees to be balanced, because i could not think of any binary tree which has over all height difference is 1, but whose subtrees have overall height differences greater than 1."
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I saw a lots of guys discussing not using DFS. OK, I think the best benefit of DFS is that if you state your recursion correct, you will never worry about those stupid weird cases."
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "The standard of Height balanced is \"if the difference in the depth of subtrees own by two node is less than 2\""
                    },
                    {
                        "username": "zacktimusprime18",
                        "content": "python"
                    }
                ]
            },
            {
                "id": 1803609,
                "content": [
                    {
                        "username": "jimxu1988",
                        "content": "just like  [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/), dfs to calculate the depth, while in the meantime, keep track one more thing  `isBalanced` by comparing the depth from left and right sub tree."
                    },
                    {
                        "username": "jamalie",
                        "content": "The reason ```[1,2,2,3,null,null,3,4,null,null,4]``` is not a balanced tree is because the balance considers the depth of the two subtrees of EVERY child node starting from root. This means we not only need to consider the two immediate subtrees but every childs subtree. Here\\'s my solution:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def find_max_depth(self, root):\\n        if not root: return 0\\n\\n        return 1 + max(self.find_max_depth(root.left), self.find_max_depth(root.right))\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if not root: return True\\n        left = 0\\n        right = 0\\n\\n        if root.left:\\n            if not self.isBalanced(root.left):\\n                return False\\n            left = self.find_max_depth(root.left)\\n        if root.right:\\n            if not self.isBalanced(root.right):\\n                return False\\n            right = self.find_max_depth(root.right)\\n\\n        print(left, right)\\n\\n        if abs(left - right) > 1:\\n            return False\\n        return True\\n\\n```"
                    },
                    {
                        "username": "Yiggu_",
                        "content": "I wrote this code by myself and compared it with the official answer, but I couldn\\'t understand why this code can not be passed. Is any people willing to help me ?\\n\\n\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        res = True\\n        level = 1\\n        return self.getHeight(root)[0]\\n    \\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        if not root:    #if root is null \\n            return True,-1\\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n        if abs(lheight - rheight) > 1:\\n            return False,0\\n        \\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        return self.getHeight(root)[0]\\n\\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        # print(root)\\n        if not root:    #if root is null \\n            return True,-1\\n        \\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n\\n        if abs(lheight - rheight) > 1 or left_is_balanced == False or right_is_balanced == False:\\n            return False,0\\n\\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[1,2,2,3,null,null,3,4,null,null,4]\\n       1\\n      / \\\\\\n     2   2\\n    /     \\\\\\n   3       3\\n  /         \\\\\\n 4           4\\ncan someone tell  why this tree is not height balanced?\\nor it\\'s wrong test case?"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sunchipsster",
                        "content": "Why is [1,null,2,null,3] supposed to be False? There is only one leaf (3) from 1-> 2-> 3\n\nExpected: false\n\nTest case 88/228"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "can anyone give an example when (lh==-1 || rh==-1)?\nI find most of the optimised codes using this:\n int height(TreeNode* root)\n    {\n        if(root==NULL)\n            return 0;\n        int lh=height(root->left);\n        int rh=height(root->right);\n        if(lh==-1 || rh==-1)\n            return -1;\n        if(abs(lh-rh)>1)\n            return -1;\n        return 1+max(lh,rh);\n    }\n    bool isBalanced(TreeNode* root) {\n        return height(root)!=-1;  \n    }"
                    },
                    {
                        "username": "RChandra612",
                        "content": "\n` \nbool isBalanced(TreeNode* root) {\n            if(!root)\n                return true;\n            int lh = height(root->left);\n            int rh = height(root->right);\n            if(abs(lh - rh) > 1)\n                return false;\n            return true;\n    }\n    int height(TreeNode* root){\n        if(root == NULL)\n            return 0;\n        return 1 + max(height(root->left), height(root->right));\n    }\n `\n\nwhat is the problem with above code, i intentionally left checking the subtrees to be balanced, because i could not think of any binary tree which has over all height difference is 1, but whose subtrees have overall height differences greater than 1."
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I saw a lots of guys discussing not using DFS. OK, I think the best benefit of DFS is that if you state your recursion correct, you will never worry about those stupid weird cases."
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "The standard of Height balanced is \"if the difference in the depth of subtrees own by two node is less than 2\""
                    },
                    {
                        "username": "zacktimusprime18",
                        "content": "python"
                    }
                ]
            },
            {
                "id": 1801305,
                "content": [
                    {
                        "username": "jimxu1988",
                        "content": "just like  [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/), dfs to calculate the depth, while in the meantime, keep track one more thing  `isBalanced` by comparing the depth from left and right sub tree."
                    },
                    {
                        "username": "jamalie",
                        "content": "The reason ```[1,2,2,3,null,null,3,4,null,null,4]``` is not a balanced tree is because the balance considers the depth of the two subtrees of EVERY child node starting from root. This means we not only need to consider the two immediate subtrees but every childs subtree. Here\\'s my solution:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def find_max_depth(self, root):\\n        if not root: return 0\\n\\n        return 1 + max(self.find_max_depth(root.left), self.find_max_depth(root.right))\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        if not root: return True\\n        left = 0\\n        right = 0\\n\\n        if root.left:\\n            if not self.isBalanced(root.left):\\n                return False\\n            left = self.find_max_depth(root.left)\\n        if root.right:\\n            if not self.isBalanced(root.right):\\n                return False\\n            right = self.find_max_depth(root.right)\\n\\n        print(left, right)\\n\\n        if abs(left - right) > 1:\\n            return False\\n        return True\\n\\n```"
                    },
                    {
                        "username": "Yiggu_",
                        "content": "I wrote this code by myself and compared it with the official answer, but I couldn\\'t understand why this code can not be passed. Is any people willing to help me ?\\n\\n\\n\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        res = True\\n        level = 1\\n        return self.getHeight(root)[0]\\n    \\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        if not root:    #if root is null \\n            return True,-1\\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n        if abs(lheight - rheight) > 1:\\n            return False,0\\n        \\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "tomyanth",
                        "content": "# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\\n        return self.getHeight(root)[0]\\n\\n    def getHeight(self,root:Optional[TreeNode]) -> (bool,int):\\n        # print(root)\\n        if not root:    #if root is null \\n            return True,-1\\n        \\n        left_is_balanced,lheight = self.getHeight(root.left)\\n        right_is_balanced,rheight = self.getHeight(root.right)\\n\\n        if abs(lheight - rheight) > 1 or left_is_balanced == False or right_is_balanced == False:\\n            return False,0\\n\\n        return True,1+max(lheight,rheight)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[1,2,2,3,null,null,3,4,null,null,4]\\n       1\\n      / \\\\\\n     2   2\\n    /     \\\\\\n   3       3\\n  /         \\\\\\n 4           4\\ncan someone tell  why this tree is not height balanced?\\nor it\\'s wrong test case?"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sunchipsster",
                        "content": "Why is [1,null,2,null,3] supposed to be False? There is only one leaf (3) from 1-> 2-> 3\n\nExpected: false\n\nTest case 88/228"
                    },
                    {
                        "username": "tomyanth",
                        "content": "https://leetcode.com/problems/balanced-binary-tree/description/comments/1915107"
                    },
                    {
                        "username": "sachindramishra204",
                        "content": "can anyone give an example when (lh==-1 || rh==-1)?\nI find most of the optimised codes using this:\n int height(TreeNode* root)\n    {\n        if(root==NULL)\n            return 0;\n        int lh=height(root->left);\n        int rh=height(root->right);\n        if(lh==-1 || rh==-1)\n            return -1;\n        if(abs(lh-rh)>1)\n            return -1;\n        return 1+max(lh,rh);\n    }\n    bool isBalanced(TreeNode* root) {\n        return height(root)!=-1;  \n    }"
                    },
                    {
                        "username": "RChandra612",
                        "content": "\n` \nbool isBalanced(TreeNode* root) {\n            if(!root)\n                return true;\n            int lh = height(root->left);\n            int rh = height(root->right);\n            if(abs(lh - rh) > 1)\n                return false;\n            return true;\n    }\n    int height(TreeNode* root){\n        if(root == NULL)\n            return 0;\n        return 1 + max(height(root->left), height(root->right));\n    }\n `\n\nwhat is the problem with above code, i intentionally left checking the subtrees to be balanced, because i could not think of any binary tree which has over all height difference is 1, but whose subtrees have overall height differences greater than 1."
                    },
                    {
                        "username": "MeloWang0308",
                        "content": "I saw a lots of guys discussing not using DFS. OK, I think the best benefit of DFS is that if you state your recursion correct, you will never worry about those stupid weird cases."
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "The standard of Height balanced is \"if the difference in the depth of subtrees own by two node is less than 2\""
                    },
                    {
                        "username": "zacktimusprime18",
                        "content": "python"
                    }
                ]
            }
        ]
    }
]